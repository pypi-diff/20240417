# Comparing `tmp/dara_components-1.8.0-py3-none-any.whl.zip` & `tmp/dara_components-1.8.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,8 +1,8 @@
-Zip file size: 3049572 bytes, number of entries: 83
+Zip file size: 3053527 bytes, number of entries: 86
 -rw-r--r--  2.0 unx      808 b- defN 80-Jan-01 00:00 dara/components/__init__.py
 -rw-r--r--  2.0 unx     3866 b- defN 80-Jan-01 00:00 dara/components/common/__init__.py
 -rw-r--r--  2.0 unx     9487 b- defN 80-Jan-01 00:00 dara/components/common/accordion.py
 -rw-r--r--  2.0 unx     2869 b- defN 80-Jan-01 00:00 dara/components/common/anchor.py
 -rw-r--r--  2.0 unx     4707 b- defN 80-Jan-01 00:00 dara/components/common/base_component.py
 -rw-r--r--  2.0 unx     1433 b- defN 80-Jan-01 00:00 dara/components/common/bullet_list.py
 -rw-r--r--  2.0 unx     4549 b- defN 80-Jan-01 00:00 dara/components/common/button.py
@@ -58,28 +58,31 @@
 -rw-r--r--  2.0 unx      681 b- defN 80-Jan-01 00:00 dara/components/plotting/matplotlib/__init__.py
 -rw-r--r--  2.0 unx     1851 b- defN 80-Jan-01 00:00 dara/components/plotting/matplotlib/matplotlib.py
 -rw-r--r--  2.0 unx     8001 b- defN 80-Jan-01 00:00 dara/components/plotting/palettes.py
 -rw-r--r--  2.0 unx      835 b- defN 80-Jan-01 00:00 dara/components/plotting/plotly/__init__.py
 -rw-r--r--  2.0 unx     4361 b- defN 80-Jan-01 00:00 dara/components/plotting/plotly/plotly.py
 -rw-r--r--  2.0 unx     4298 b- defN 80-Jan-01 00:00 dara/components/plotting/plotly/themes.py
 -rw-r--r--  2.0 unx     1083 b- defN 80-Jan-01 00:00 dara/components/smart/__init__.py
--rw-r--r--  2.0 unx      647 b- defN 80-Jan-01 00:00 dara/components/smart/chat/__init__.py
--rw-r--r--  2.0 unx     2964 b- defN 80-Jan-01 00:00 dara/components/smart/chat/chat.py
+-rw-r--r--  2.0 unx      796 b- defN 80-Jan-01 00:00 dara/components/smart/chat/__init__.py
+-rw-r--r--  2.0 unx     3067 b- defN 80-Jan-01 00:00 dara/components/smart/chat/chat.py
+-rw-r--r--  2.0 unx      590 b- defN 80-Jan-01 00:00 dara/components/smart/chat/config.py
+-rw-r--r--  2.0 unx      490 b- defN 80-Jan-01 00:00 dara/components/smart/chat/endpoints.py
+-rw-r--r--  2.0 unx     1316 b- defN 80-Jan-01 00:00 dara/components/smart/chat/types.py
 -rw-r--r--  2.0 unx      749 b- defN 80-Jan-01 00:00 dara/components/smart/code_editor/__init__.py
 -rw-r--r--  2.0 unx      930 b- defN 80-Jan-01 00:00 dara/components/smart/code_editor/code_editor.py
 -rw-r--r--  2.0 unx     4476 b- defN 80-Jan-01 00:00 dara/components/smart/code_editor/util.py
 -rw-r--r--  2.0 unx      783 b- defN 80-Jan-01 00:00 dara/components/smart/data_slicer/__init__.py
 -rw-r--r--  2.0 unx     7490 b- defN 80-Jan-01 00:00 dara/components/smart/data_slicer/data_slicer.py
 -rw-r--r--  2.0 unx     4120 b- defN 80-Jan-01 00:00 dara/components/smart/data_slicer/data_slicer_modal.py
 -rw-r--r--  2.0 unx     1616 b- defN 80-Jan-01 00:00 dara/components/smart/data_slicer/extension/data_slicer_filter.py
 -rw-r--r--  2.0 unx     1345 b- defN 80-Jan-01 00:00 dara/components/smart/data_slicer/extension/filter_status_button.py
 -rw-r--r--  2.0 unx     8656 b- defN 80-Jan-01 00:00 dara/components/smart/data_slicer/utils/core.py
 -rw-r--r--  2.0 unx     1722 b- defN 80-Jan-01 00:00 dara/components/smart/data_slicer/utils/data_preview.py
 -rw-r--r--  2.0 unx     3313 b- defN 80-Jan-01 00:00 dara/components/smart/data_slicer/utils/plotting.py
 -rw-r--r--  2.0 unx     2877 b- defN 80-Jan-01 00:00 dara/components/smart/hierarchy.py
--rw-r--r--  2.0 unx 16866614 b- defN 80-Jan-01 00:00 dara/components/umd/dara.components.umd.js
+-rw-r--r--  2.0 unx 16879670 b- defN 80-Jan-01 00:00 dara/components/umd/dara.components.umd.js
 -rw-r--r--  2.0 unx    23576 b- defN 80-Jan-01 00:00 dara/components/umd/style.css
--rw-r--r--  2.0 unx    10944 b- defN 80-Jan-01 00:00 dara_components-1.8.0.dist-info/LICENSE
--rw-r--r--  2.0 unx     2710 b- defN 80-Jan-01 00:00 dara_components-1.8.0.dist-info/METADATA
--rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 dara_components-1.8.0.dist-info/WHEEL
-?rw-r--r--  2.0 unx     7873 b- defN 16-Jan-01 00:00 dara_components-1.8.0.dist-info/RECORD
-83 files, 17193206 bytes uncompressed, 3036846 bytes compressed:  82.3%
+-rw-r--r--  2.0 unx    10944 b- defN 80-Jan-01 00:00 dara_components-1.8.1.dist-info/LICENSE
+-rw-r--r--  2.0 unx     2710 b- defN 80-Jan-01 00:00 dara_components-1.8.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 dara_components-1.8.1.dist-info/WHEEL
+?rw-r--r--  2.0 unx     8152 b- defN 16-Jan-01 00:00 dara_components-1.8.1.dist-info/RECORD
+86 files, 17209189 bytes uncompressed, 3040353 bytes compressed:  82.3%
```

## zipnote {}

```diff
@@ -189,14 +189,23 @@
 
 Filename: dara/components/smart/chat/__init__.py
 Comment: 
 
 Filename: dara/components/smart/chat/chat.py
 Comment: 
 
+Filename: dara/components/smart/chat/config.py
+Comment: 
+
+Filename: dara/components/smart/chat/endpoints.py
+Comment: 
+
+Filename: dara/components/smart/chat/types.py
+Comment: 
+
 Filename: dara/components/smart/code_editor/__init__.py
 Comment: 
 
 Filename: dara/components/smart/code_editor/code_editor.py
 Comment: 
 
 Filename: dara/components/smart/code_editor/util.py
@@ -231,20 +240,20 @@
 
 Filename: dara/components/umd/dara.components.umd.js
 Comment: 
 
 Filename: dara/components/umd/style.css
 Comment: 
 
-Filename: dara_components-1.8.0.dist-info/LICENSE
+Filename: dara_components-1.8.1.dist-info/LICENSE
 Comment: 
 
-Filename: dara_components-1.8.0.dist-info/METADATA
+Filename: dara_components-1.8.1.dist-info/METADATA
 Comment: 
 
-Filename: dara_components-1.8.0.dist-info/WHEEL
+Filename: dara_components-1.8.1.dist-info/WHEEL
 Comment: 
 
-Filename: dara_components-1.8.0.dist-info/RECORD
+Filename: dara_components-1.8.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## dara/components/smart/chat/__init__.py

```diff
@@ -12,9 +12,11 @@
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 """
 
 from dara.components.smart.chat.chat import Chat
+from dara.components.smart.chat.config import ChatConfig
+from dara.components.smart.chat.types import NewMessageBody
 
-__all__ = ['Chat']
+__all__ = ['Chat', 'NewMessageBody', 'ChatConfig']
```

## dara/components/smart/chat/chat.py

```diff
@@ -13,14 +13,15 @@
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 """
 
 from pydantic import validator
 
+from dara.components.smart.chat.endpoints import on_new_message
 from dara.core.definitions import StyledComponentInstance
 from dara.core.interactivity import NonDataVariable
 from dara.core.persistence import BackendStore
 
 
 class Chat(StyledComponentInstance):
     """
@@ -56,14 +57,15 @@
     )
     ```
 
     :param value: A Variable which stores the chat's state
     """
 
     js_module = '@darajs/components'
+    required_routes = [on_new_message]
 
     value: NonDataVariable
 
     class Config:
         extra = 'forbid'
 
     @validator('value')
```

## dara/components/umd/dara.components.umd.js

### js-beautify {}

```diff
@@ -306,76 +306,76 @@
             constructor: {
                 value: subClass,
                 writable: true,
                 configurable: true
             }
         });
         if (superClass)
-            _setPrototypeOf$5(subClass, superClass);
+            _setPrototypeOf$6(subClass, superClass);
     }
 
-    function _setPrototypeOf$5(o2, p2) {
-        _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
+    function _setPrototypeOf$6(o2, p2) {
+        _setPrototypeOf$6 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
             o3.__proto__ = p3;
             return o3;
         };
-        return _setPrototypeOf$5(o2, p2);
+        return _setPrototypeOf$6(o2, p2);
     }
 
     function _createSuper$3(Derived) {
-        var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
+        var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
         return function _createSuperInternal() {
-            var Super = _getPrototypeOf$4(Derived),
+            var Super = _getPrototypeOf$5(Derived),
                 result;
             if (hasNativeReflectConstruct) {
-                var NewTarget = _getPrototypeOf$4(this).constructor;
+                var NewTarget = _getPrototypeOf$5(this).constructor;
                 result = Reflect.construct(Super, arguments, NewTarget);
             } else {
                 result = Super.apply(this, arguments);
             }
             return _possibleConstructorReturn$3(this, result);
         };
     }
 
     function _possibleConstructorReturn$3(self2, call2) {
         if (call2 && (_typeof$9(call2) === "object" || typeof call2 === "function")) {
             return call2;
         } else if (call2 !== void 0) {
             throw new TypeError("Derived constructors may only return object or undefined");
         }
-        return _assertThisInitialized$5(self2);
+        return _assertThisInitialized$6(self2);
     }
 
-    function _assertThisInitialized$5(self2) {
+    function _assertThisInitialized$6(self2) {
         if (self2 === void 0) {
             throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
         }
         return self2;
     }
 
-    function _isNativeReflectConstruct$4() {
+    function _isNativeReflectConstruct$5() {
         if (typeof Reflect === "undefined" || !Reflect.construct)
             return false;
         if (Reflect.construct.sham)
             return false;
         if (typeof Proxy === "function")
             return true;
         try {
             Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
             return true;
         } catch (e3) {
             return false;
         }
     }
 
-    function _getPrototypeOf$4(o2) {
-        _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
+    function _getPrototypeOf$5(o2) {
+        _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
             return o3.__proto__ || Object.getPrototypeOf(o3);
         };
-        return _getPrototypeOf$4(o2);
+        return _getPrototypeOf$5(o2);
     }
 
     function _defineProperty$s(obj, key, value) {
         if (key in obj) {
             Object.defineProperty(obj, key, {
                 value,
                 enumerable: true,
@@ -391,18 +391,18 @@
         _inherits$3(Collapse2, _React$Component);
         var _super = _createSuper$3(Collapse2);
 
         function Collapse2(props) {
             var _this;
             _classCallCheck$j(this, Collapse2);
             _this = _super.call(this, props);
-            _defineProperty$s(_assertThisInitialized$5(_this), "timeout", void 0);
-            _defineProperty$s(_assertThisInitialized$5(_this), "container", void 0);
-            _defineProperty$s(_assertThisInitialized$5(_this), "content", void 0);
-            _defineProperty$s(_assertThisInitialized$5(_this), "onResize", function() {
+            _defineProperty$s(_assertThisInitialized$6(_this), "timeout", void 0);
+            _defineProperty$s(_assertThisInitialized$6(_this), "container", void 0);
+            _defineProperty$s(_assertThisInitialized$6(_this), "content", void 0);
+            _defineProperty$s(_assertThisInitialized$6(_this), "onResize", function() {
                 clearTimeout(_this.timeout);
                 if (!_this.container || !_this.content) {
                     return;
                 }
                 var _this$props = _this.props,
                     isOpened = _this$props.isOpened,
                     checkTimeout = _this$props.checkTimeout;
@@ -427,15 +427,15 @@
                         contentHeight
                     });
                     _this.timeout = setTimeout(function() {
                         return _this.onResize();
                     }, checkTimeout);
                 }
             });
-            _defineProperty$s(_assertThisInitialized$5(_this), "onRest", function(_ref2) {
+            _defineProperty$s(_assertThisInitialized$6(_this), "onRest", function(_ref2) {
                 var isFullyOpened = _ref2.isFullyOpened,
                     isFullyClosed = _ref2.isFullyClosed,
                     isOpened = _ref2.isOpened,
                     containerHeight = _ref2.containerHeight,
                     contentHeight = _ref2.contentHeight;
                 if (!_this.container || !_this.content) {
                     return;
@@ -453,15 +453,15 @@
                             isOpened,
                             containerHeight,
                             contentHeight
                         });
                     }
                 }
             });
-            _defineProperty$s(_assertThisInitialized$5(_this), "onWork", function(_ref2) {
+            _defineProperty$s(_assertThisInitialized$6(_this), "onWork", function(_ref2) {
                 var isFullyOpened = _ref2.isFullyOpened,
                     isFullyClosed = _ref2.isFullyClosed,
                     isOpened = _ref2.isOpened,
                     containerHeight = _ref2.containerHeight,
                     contentHeight = _ref2.contentHeight;
                 if (!_this.container || !_this.content) {
                     return;
@@ -480,18 +480,18 @@
                         isFullyClosed,
                         isOpened,
                         containerHeight,
                         contentHeight
                     });
                 }
             });
-            _defineProperty$s(_assertThisInitialized$5(_this), "onRefContainer", function(container) {
+            _defineProperty$s(_assertThisInitialized$6(_this), "onRefContainer", function(container) {
                 _this.container = container;
             });
-            _defineProperty$s(_assertThisInitialized$5(_this), "onRefContent", function(content2) {
+            _defineProperty$s(_assertThisInitialized$6(_this), "onRefContent", function(content2) {
                 _this.content = content2;
             });
             if (props.initialStyle) {
                 _this.initialStyle = props.initialStyle;
             } else {
                 _this.initialStyle = props.isOpened ? {
                     height: "auto",
@@ -716,76 +716,76 @@
             constructor: {
                 value: subClass,
                 writable: true,
                 configurable: true
             }
         });
         if (superClass)
-            _setPrototypeOf$4(subClass, superClass);
+            _setPrototypeOf$5(subClass, superClass);
     }
 
-    function _setPrototypeOf$4(o2, p2) {
-        _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
+    function _setPrototypeOf$5(o2, p2) {
+        _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
             o3.__proto__ = p3;
             return o3;
         };
-        return _setPrototypeOf$4(o2, p2);
+        return _setPrototypeOf$5(o2, p2);
     }
 
     function _createSuper$2(Derived) {
-        var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
+        var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
         return function _createSuperInternal() {
-            var Super = _getPrototypeOf$3(Derived),
+            var Super = _getPrototypeOf$4(Derived),
                 result;
             if (hasNativeReflectConstruct) {
-                var NewTarget = _getPrototypeOf$3(this).constructor;
+                var NewTarget = _getPrototypeOf$4(this).constructor;
                 result = Reflect.construct(Super, arguments, NewTarget);
             } else {
                 result = Super.apply(this, arguments);
             }
             return _possibleConstructorReturn$2(this, result);
         };
     }
 
     function _possibleConstructorReturn$2(self2, call2) {
         if (call2 && (_typeof$8(call2) === "object" || typeof call2 === "function")) {
             return call2;
         } else if (call2 !== void 0) {
             throw new TypeError("Derived constructors may only return object or undefined");
         }
-        return _assertThisInitialized$4(self2);
+        return _assertThisInitialized$5(self2);
     }
 
-    function _assertThisInitialized$4(self2) {
+    function _assertThisInitialized$5(self2) {
         if (self2 === void 0) {
             throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
         }
         return self2;
     }
 
-    function _isNativeReflectConstruct$3() {
+    function _isNativeReflectConstruct$4() {
         if (typeof Reflect === "undefined" || !Reflect.construct)
             return false;
         if (Reflect.construct.sham)
             return false;
         if (typeof Proxy === "function")
             return true;
         try {
             Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
             return true;
         } catch (e3) {
             return false;
         }
     }
 
-    function _getPrototypeOf$3(o2) {
-        _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
+    function _getPrototypeOf$4(o2) {
+        _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
             return o3.__proto__ || Object.getPrototypeOf(o3);
         };
-        return _getPrototypeOf$3(o2);
+        return _getPrototypeOf$4(o2);
     }
 
     function _defineProperty$r(obj, key, value) {
         if (key in obj) {
             Object.defineProperty(obj, key, {
                 value,
                 enumerable: true,
@@ -801,44 +801,44 @@
         _inherits$2(UnmountClosed2, _React$PureComponent);
         var _super = _createSuper$2(UnmountClosed2);
 
         function UnmountClosed2(props) {
             var _this;
             _classCallCheck$i(this, UnmountClosed2);
             _this = _super.call(this, props);
-            _defineProperty$r(_assertThisInitialized$4(_this), "onWork", function(_ref2) {
+            _defineProperty$r(_assertThisInitialized$5(_this), "onWork", function(_ref2) {
                 var isOpened = _ref2.isOpened,
                     rest = _objectWithoutProperties$3(_ref2, _excluded$6);
                 _this.setState({
                     isResting: false,
                     isOpened
                 });
                 var onWork = _this.props.onWork;
                 if (onWork) {
                     onWork(_objectSpread$6({
                         isOpened
                     }, rest));
                 }
             });
-            _defineProperty$r(_assertThisInitialized$4(_this), "onRest", function(_ref2) {
+            _defineProperty$r(_assertThisInitialized$5(_this), "onRest", function(_ref2) {
                 var isOpened = _ref2.isOpened,
                     rest = _objectWithoutProperties$3(_ref2, _excluded2$4);
                 _this.setState({
                     isResting: true,
                     isOpened,
                     isInitialRender: false
                 });
                 var onRest = _this.props.onRest;
                 if (onRest) {
                     onRest(_objectSpread$6({
                         isOpened
                     }, rest));
                 }
             });
-            _defineProperty$r(_assertThisInitialized$4(_this), "getInitialStyle", function() {
+            _defineProperty$r(_assertThisInitialized$5(_this), "getInitialStyle", function() {
                 var _this$state = _this.state,
                     isOpened = _this$state.isOpened,
                     isInitialRender = _this$state.isInitialRender;
                 if (isInitialRender) {
                     return isOpened ? {
                         height: "auto",
                         overflow: "initial"
@@ -6607,18 +6607,18 @@
                 if (adjustedIndex < 0 || adjustedIndex > internalData.length) {
                     return;
                 }
                 return internalData[adjustedIndex];
             },
             useDeepCompare([currentStartIdx, internalData])
         );
-        const onItemsRendered = React.useCallback((_a3, forceRefresh_1) => __awaiter$3(this, [_a3, forceRefresh_1], void 0, function*({
+        const onItemsRendered = React.useCallback(({
             overscanStartIndex,
             overscanStopIndex
-        }, forceRefresh) {
+        }, forceRefresh) => __awaiter$3(this, void 0, void 0, function*() {
             try {
                 const isFirstItemLoaded = overscanStartIndex >= currentStartIdx && overscanStartIndex <= currentStopIdx;
                 const isLastItemLoaded = overscanStopIndex >= currentStartIdx && overscanStopIndex <= currentStopIdx;
                 setCurrentRange({
                     overscanStartIndex,
                     overscanStopIndex
                 });
@@ -6883,66 +6883,66 @@
                 }
             }
             return target;
         };
         return _extends$3.apply(this, arguments);
     }
 
-    function _assertThisInitialized$3(self2) {
+    function _assertThisInitialized$4(self2) {
         if (self2 === void 0) {
             throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
         }
         return self2;
     }
 
-    function _setPrototypeOf$3(o2, p2) {
-        _setPrototypeOf$3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
+    function _setPrototypeOf$4(o2, p2) {
+        _setPrototypeOf$4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
             o3.__proto__ = p3;
             return o3;
         };
-        return _setPrototypeOf$3(o2, p2);
+        return _setPrototypeOf$4(o2, p2);
     }
 
     function _inheritsLoose$2(subClass, superClass) {
         subClass.prototype = Object.create(superClass.prototype);
         subClass.prototype.constructor = subClass;
-        _setPrototypeOf$3(subClass, superClass);
+        _setPrototypeOf$4(subClass, superClass);
     }
 
-    function _getPrototypeOf$2(o2) {
-        _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
+    function _getPrototypeOf$3(o2) {
+        _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
             return o3.__proto__ || Object.getPrototypeOf(o3);
         };
-        return _getPrototypeOf$2(o2);
+        return _getPrototypeOf$3(o2);
     }
 
     function _isNativeFunction$1(fn2) {
         try {
             return Function.toString.call(fn2).indexOf("[native code]") !== -1;
         } catch (e3) {
             return typeof fn2 === "function";
         }
     }
 
-    function _isNativeReflectConstruct$2() {
+    function _isNativeReflectConstruct$3() {
         try {
             var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
         } catch (t3) {}
-        return (_isNativeReflectConstruct$2 = function _isNativeReflectConstruct2() {
+        return (_isNativeReflectConstruct$3 = function _isNativeReflectConstruct2() {
             return !!t2;
         })();
     }
 
     function _construct$1(t2, e3, r2) {
-        if (_isNativeReflectConstruct$2())
+        if (_isNativeReflectConstruct$3())
             return Reflect.construct.apply(null, arguments);
         var o2 = [null];
         o2.push.apply(o2, e3);
         var p2 = new(t2.bind.apply(t2, o2))();
-        return r2 && _setPrototypeOf$3(p2, r2.prototype), p2;
+        return r2 && _setPrototypeOf$4(p2, r2.prototype), p2;
     }
 
     function _wrapNativeSuper$1(Class) {
         var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
         _wrapNativeSuper$1 = function _wrapNativeSuper2(Class2) {
             if (Class2 === null || !_isNativeFunction$1(Class2))
                 return Class2;
@@ -6952,37 +6952,37 @@
             if (typeof _cache !== "undefined") {
                 if (_cache.has(Class2))
                     return _cache.get(Class2);
                 _cache.set(Class2, Wrapper2);
             }
 
             function Wrapper2() {
-                return _construct$1(Class2, arguments, _getPrototypeOf$2(this).constructor);
+                return _construct$1(Class2, arguments, _getPrototypeOf$3(this).constructor);
             }
             Wrapper2.prototype = Object.create(Class2.prototype, {
                 constructor: {
                     value: Wrapper2,
                     enumerable: false,
                     writable: true,
                     configurable: true
                 }
             });
-            return _setPrototypeOf$3(Wrapper2, Class2);
+            return _setPrototypeOf$4(Wrapper2, Class2);
         };
         return _wrapNativeSuper$1(Class);
     }
     var PolishedError$2 = /* @__PURE__ */ function(_Error) {
         _inheritsLoose$2(PolishedError2, _Error);
 
         function PolishedError2(code2) {
             var _this;
             {
                 _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/master/src/internalHelpers/errors.md#" + code2 + " for more information.") || this;
             }
-            return _assertThisInitialized$3(_this);
+            return _assertThisInitialized$4(_this);
         }
         return PolishedError2;
     }( /* @__PURE__ */ _wrapNativeSuper$1(Error));
 
     function colorToInt$2(color2) {
         return Math.round(color2 * 255);
     }
@@ -7494,15 +7494,15 @@
                 })]
             }), (props.showText || props.text) && jsxRuntime.exports.jsx(LoadingText, {
                 color: props.color,
                 children: (_a3 = props.text) !== null && _a3 !== void 0 ? _a3 : "LOADING"
             })]
         });
     }
-    var __rest$c = globalThis && globalThis.__rest || function(s2, e3) {
+    var __rest$d = globalThis && globalThis.__rest || function(s2, e3) {
         var t2 = {};
         for (var p2 in s2)
             if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
                 t2[p2] = s2[p2];
         if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
             for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
                 if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
@@ -7617,15 +7617,15 @@
             loading,
             id: id2,
             onClick,
             outline = false,
             style: style2,
             styling = "primary",
             type: type2 = "button"
-        } = _a3, props = __rest$c(_a3, ["autoFocus", "children", "className", "disabled", "download", "href", "loading", "id", "onClick", "outline", "style", "styling", "type"]);
+        } = _a3, props = __rest$d(_a3, ["autoFocus", "children", "className", "disabled", "download", "href", "loading", "id", "onClick", "outline", "style", "styling", "type"]);
         const currentTheme = useClTheme();
         const Component = stylingMap[styling];
         const content2 = loading ? jsxRuntime.exports.jsx(StyledLoading, {
             color: outline ? currentTheme.colors.grey2 : currentTheme.colors.blue1
         }) : children2;
         const wrappedContent = href ? jsxRuntime.exports.jsx(AnchorWrapper, {
             download,
@@ -14472,14 +14472,17 @@
                 onChange2(target.value, e3);
             }
         };
         const onKeyDown = (e3) => {
             if (keydownFilter && !keydownFilter(e3)) {
                 e3.preventDefault();
             }
+            if (e3.key === Key.ENTER && e3.shiftKey && onComplete) {
+                return;
+            }
             if (e3.key === Key.ENTER && onComplete) {
                 onComplete();
             }
         };
         return jsxRuntime.exports.jsxs("div", {
             className,
             style: style2,
@@ -17712,43782 +17715,47334 @@
         }
         return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
     }
 
     function validateTimezone$1(_hours, minutes) {
         return minutes >= 0 && minutes <= 59;
     }
-    var top$2 = "top";
-    var bottom$1 = "bottom";
-    var right$1 = "right";
-    var left$1 = "left";
-    var auto$1 = "auto";
-    var basePlacements$1 = [top$2, bottom$1, right$1, left$1];
-    var start$2 = "start";
-    var end$1 = "end";
-    var clippingParents$1 = "clippingParents";
-    var viewport$1 = "viewport";
-    var popper$1 = "popper";
-    var reference$1 = "reference";
-    var variationPlacements$1 = /* @__PURE__ */ basePlacements$1.reduce(function(acc, placement) {
-        return acc.concat([placement + "-" + start$2, placement + "-" + end$1]);
-    }, []);
-    var placements$1 = /* @__PURE__ */ [].concat(basePlacements$1, [auto$1]).reduce(function(acc, placement) {
-        return acc.concat([placement, placement + "-" + start$2, placement + "-" + end$1]);
-    }, []);
-    var beforeRead$1 = "beforeRead";
-    var read$1 = "read";
-    var afterRead$1 = "afterRead";
-    var beforeMain$1 = "beforeMain";
-    var main$1 = "main";
-    var afterMain$1 = "afterMain";
-    var beforeWrite$1 = "beforeWrite";
-    var write$1 = "write";
-    var afterWrite$1 = "afterWrite";
-    var modifierPhases$1 = [beforeRead$1, read$1, afterRead$1, beforeMain$1, main$1, afterMain$1, beforeWrite$1, write$1, afterWrite$1];
 
-    function getNodeName$1(element2) {
-        return element2 ? (element2.nodeName || "").toLowerCase() : null;
-    }
+    function ok$2() {}
 
-    function getWindow$1(node2) {
-        if (node2 == null) {
-            return window;
-        }
-        if (node2.toString() !== "[object Window]") {
-            var ownerDocument = node2.ownerDocument;
-            return ownerDocument ? ownerDocument.defaultView || window : window;
+    function unreachable() {}
+
+    function parse$8(value) {
+        const tokens2 = [];
+        const input = String(value || "");
+        let index2 = input.indexOf(",");
+        let start2 = 0;
+        let end2 = false;
+        while (!end2) {
+            if (index2 === -1) {
+                index2 = input.length;
+                end2 = true;
+            }
+            const token = input.slice(start2, index2).trim();
+            if (token || !end2) {
+                tokens2.push(token);
+            }
+            start2 = index2 + 1;
+            index2 = input.indexOf(",", start2);
         }
-        return node2;
+        return tokens2;
     }
 
-    function isElement$4(node2) {
-        var OwnElement = getWindow$1(node2).Element;
-        return node2 instanceof OwnElement || node2 instanceof Element;
+    function stringify$3(values, options) {
+        const settings2 = options || {};
+        const input = values[values.length - 1] === "" ? [...values, ""] : values;
+        return input.join(
+            (settings2.padRight ? " " : "") + "," + (settings2.padLeft === false ? "" : " ")
+        ).trim();
     }
+    const nameRe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
+    const nameReJsx = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
+    const emptyOptions$3 = {};
 
-    function isHTMLElement$1(node2) {
-        var OwnElement = getWindow$1(node2).HTMLElement;
-        return node2 instanceof OwnElement || node2 instanceof HTMLElement;
+    function name$2(name2, options) {
+        const settings2 = options || emptyOptions$3;
+        const re2 = settings2.jsx ? nameReJsx : nameRe;
+        return re2.test(name2);
     }
+    const re$1 = /[ \t\n\f\r]/g;
 
-    function isShadowRoot(node2) {
-        if (typeof ShadowRoot === "undefined") {
-            return false;
-        }
-        var OwnElement = getWindow$1(node2).ShadowRoot;
-        return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
+    function whitespace(thing) {
+        return typeof thing === "object" ? thing.type === "text" ? empty$3(thing.value) : false : empty$3(thing);
     }
 
-    function applyStyles$2(_ref2) {
-        var state = _ref2.state;
-        Object.keys(state.elements).forEach(function(name2) {
-            var style2 = state.styles[name2] || {};
-            var attributes2 = state.attributes[name2] || {};
-            var element2 = state.elements[name2];
-            if (!isHTMLElement$1(element2) || !getNodeName$1(element2)) {
-                return;
+    function empty$3(value) {
+        return value.replace(re$1, "") === "";
+    }
+    class Schema {
+        constructor(property, normal, space2) {
+            this.property = property;
+            this.normal = normal;
+            if (space2) {
+                this.space = space2;
             }
-            Object.assign(element2.style, style2);
-            Object.keys(attributes2).forEach(function(name3) {
-                var value = attributes2[name3];
-                if (value === false) {
-                    element2.removeAttribute(name3);
-                } else {
-                    element2.setAttribute(name3, value === true ? "" : value);
-                }
-            });
-        });
+        }
     }
+    Schema.prototype.property = {};
+    Schema.prototype.normal = {};
+    Schema.prototype.space = null;
 
-    function effect$5(_ref2) {
-        var state = _ref2.state;
-        var initialStyles = {
-            popper: {
-                position: state.options.strategy,
-                left: "0",
-                top: "0",
-                margin: "0"
-            },
-            arrow: {
-                position: "absolute"
-            },
-            reference: {}
-        };
-        Object.assign(state.elements.popper.style, initialStyles.popper);
-        state.styles = initialStyles;
-        if (state.elements.arrow) {
-            Object.assign(state.elements.arrow.style, initialStyles.arrow);
+    function merge$1(definitions, space2) {
+        const property = {};
+        const normal = {};
+        let index2 = -1;
+        while (++index2 < definitions.length) {
+            Object.assign(property, definitions[index2].property);
+            Object.assign(normal, definitions[index2].normal);
         }
-        return function() {
-            Object.keys(state.elements).forEach(function(name2) {
-                var element2 = state.elements[name2];
-                var attributes2 = state.attributes[name2] || {};
-                var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
-                var style2 = styleProperties.reduce(function(style3, property) {
-                    style3[property] = "";
-                    return style3;
-                }, {});
-                if (!isHTMLElement$1(element2) || !getNodeName$1(element2)) {
-                    return;
-                }
-                Object.assign(element2.style, style2);
-                Object.keys(attributes2).forEach(function(attribute) {
-                    element2.removeAttribute(attribute);
-                });
-            });
-        };
+        return new Schema(property, normal, space2);
     }
-    const applyStyles$3 = {
-        name: "applyStyles",
-        enabled: true,
-        phase: "write",
-        fn: applyStyles$2,
-        effect: effect$5,
-        requires: ["computeStyles"]
-    };
 
-    function getBasePlacement$3(placement) {
-        return placement.split("-")[0];
+    function normalize$2(value) {
+        return value.toLowerCase();
     }
-    var max$3 = Math.max;
-    var min$2 = Math.min;
-    var round$2 = Math.round;
-
-    function getUAString() {
-        var uaData = navigator.userAgentData;
-        if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
-            return uaData.brands.map(function(item) {
-                return item.brand + "/" + item.version;
-            }).join(" ");
+    class Info {
+        constructor(property, attribute) {
+            this.property = property;
+            this.attribute = attribute;
         }
-        return navigator.userAgent;
     }
+    Info.prototype.space = null;
+    Info.prototype.boolean = false;
+    Info.prototype.booleanish = false;
+    Info.prototype.overloadedBoolean = false;
+    Info.prototype.number = false;
+    Info.prototype.commaSeparated = false;
+    Info.prototype.spaceSeparated = false;
+    Info.prototype.commaOrSpaceSeparated = false;
+    Info.prototype.mustUseProperty = false;
+    Info.prototype.defined = false;
+    let powers = 0;
+    const boolean = increment();
+    const booleanish = increment();
+    const overloadedBoolean = increment();
+    const number$3 = increment();
+    const spaceSeparated = increment();
+    const commaSeparated = increment();
+    const commaOrSpaceSeparated = increment();
 
-    function isLayoutViewport() {
-        return !/^((?!chrome|android).)*safari/i.test(getUAString());
+    function increment() {
+        return 2 ** ++powers;
     }
-
-    function getBoundingClientRect$1(element2, includeScale, isFixedStrategy) {
-        if (includeScale === void 0) {
-            includeScale = false;
-        }
-        if (isFixedStrategy === void 0) {
-            isFixedStrategy = false;
-        }
-        var clientRect = element2.getBoundingClientRect();
-        var scaleX = 1;
-        var scaleY = 1;
-        if (includeScale && isHTMLElement$1(element2)) {
-            scaleX = element2.offsetWidth > 0 ? round$2(clientRect.width) / element2.offsetWidth || 1 : 1;
-            scaleY = element2.offsetHeight > 0 ? round$2(clientRect.height) / element2.offsetHeight || 1 : 1;
+    const types$1 = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
+        __proto__: null,
+        boolean,
+        booleanish,
+        overloadedBoolean,
+        number: number$3,
+        spaceSeparated,
+        commaSeparated,
+        commaOrSpaceSeparated
+    }, Symbol.toStringTag, {
+        value: "Module"
+    }));
+    const checks = Object.keys(types$1);
+    class DefinedInfo extends Info {
+        constructor(property, attribute, mask, space2) {
+            let index2 = -1;
+            super(property, attribute);
+            mark(this, "space", space2);
+            if (typeof mask === "number") {
+                while (++index2 < checks.length) {
+                    const check = checks[index2];
+                    mark(this, checks[index2], (mask & types$1[check]) === types$1[check]);
+                }
+            }
         }
-        var _ref2 = isElement$4(element2) ? getWindow$1(element2) : window,
-            visualViewport = _ref2.visualViewport;
-        var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
-        var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
-        var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
-        var width = clientRect.width / scaleX;
-        var height = clientRect.height / scaleY;
-        return {
-            width,
-            height,
-            top: y2,
-            right: x2 + width,
-            bottom: y2 + height,
-            left: x2,
-            x: x2,
-            y: y2
-        };
     }
+    DefinedInfo.prototype.defined = true;
 
-    function getLayoutRect$1(element2) {
-        var clientRect = getBoundingClientRect$1(element2);
-        var width = element2.offsetWidth;
-        var height = element2.offsetHeight;
-        if (Math.abs(clientRect.width - width) <= 1) {
-            width = clientRect.width;
-        }
-        if (Math.abs(clientRect.height - height) <= 1) {
-            height = clientRect.height;
+    function mark(values, key, value) {
+        if (value) {
+            values[key] = value;
         }
-        return {
-            x: element2.offsetLeft,
-            y: element2.offsetTop,
-            width,
-            height
-        };
     }
+    const own$8 = {}.hasOwnProperty;
 
-    function contains$2(parent, child) {
-        var rootNode = child.getRootNode && child.getRootNode();
-        if (parent.contains(child)) {
-            return true;
-        } else if (rootNode && isShadowRoot(rootNode)) {
-            var next2 = child;
-            do {
-                if (next2 && parent.isSameNode(next2)) {
-                    return true;
+    function create$1(definition2) {
+        const property = {};
+        const normal = {};
+        let prop;
+        for (prop in definition2.properties) {
+            if (own$8.call(definition2.properties, prop)) {
+                const value = definition2.properties[prop];
+                const info = new DefinedInfo(
+                    prop,
+                    definition2.transform(definition2.attributes || {}, prop),
+                    value,
+                    definition2.space
+                );
+                if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
+                    info.mustUseProperty = true;
                 }
-                next2 = next2.parentNode || next2.host;
-            } while (next2);
+                property[prop] = info;
+                normal[normalize$2(prop)] = prop;
+                normal[normalize$2(info.attribute)] = prop;
+            }
         }
-        return false;
-    }
-
-    function getComputedStyle$2(element2) {
-        return getWindow$1(element2).getComputedStyle(element2);
-    }
-
-    function isTableElement$1(element2) {
-        return ["table", "td", "th"].indexOf(getNodeName$1(element2)) >= 0;
+        return new Schema(property, normal, definition2.space);
     }
+    const xlink = create$1({
+        space: "xlink",
+        transform(_2, prop) {
+            return "xlink:" + prop.slice(5).toLowerCase();
+        },
+        properties: {
+            xLinkActuate: null,
+            xLinkArcRole: null,
+            xLinkHref: null,
+            xLinkRole: null,
+            xLinkShow: null,
+            xLinkTitle: null,
+            xLinkType: null
+        }
+    });
+    const xml = create$1({
+        space: "xml",
+        transform(_2, prop) {
+            return "xml:" + prop.slice(3).toLowerCase();
+        },
+        properties: {
+            xmlLang: null,
+            xmlBase: null,
+            xmlSpace: null
+        }
+    });
 
-    function getDocumentElement$1(element2) {
-        return ((isElement$4(element2) ? element2.ownerDocument : element2.document) || window.document).documentElement;
+    function caseSensitiveTransform(attributes2, attribute) {
+        return attribute in attributes2 ? attributes2[attribute] : attribute;
     }
 
-    function getParentNode$1(element2) {
-        if (getNodeName$1(element2) === "html") {
-            return element2;
-        }
-        return element2.assignedSlot || element2.parentNode || (isShadowRoot(element2) ? element2.host : null) || getDocumentElement$1(element2);
+    function caseInsensitiveTransform(attributes2, property) {
+        return caseSensitiveTransform(attributes2, property.toLowerCase());
     }
-
-    function getTrueOffsetParent$1(element2) {
-        if (!isHTMLElement$1(element2) || getComputedStyle$2(element2).position === "fixed") {
-            return null;
+    const xmlns = create$1({
+        space: "xmlns",
+        attributes: {
+            xmlnsxlink: "xmlns:xlink"
+        },
+        transform: caseInsensitiveTransform,
+        properties: {
+            xmlns: null,
+            xmlnsXLink: null
         }
-        return element2.offsetParent;
-    }
-
-    function getContainingBlock(element2) {
-        var isFirefox2 = /firefox/i.test(getUAString());
-        var isIE2 = /Trident/i.test(getUAString());
-        if (isIE2 && isHTMLElement$1(element2)) {
-            var elementCss = getComputedStyle$2(element2);
-            if (elementCss.position === "fixed") {
-                return null;
-            }
+    });
+    const aria = create$1({
+        transform(_2, prop) {
+            return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
+        },
+        properties: {
+            ariaActiveDescendant: null,
+            ariaAtomic: booleanish,
+            ariaAutoComplete: null,
+            ariaBusy: booleanish,
+            ariaChecked: booleanish,
+            ariaColCount: number$3,
+            ariaColIndex: number$3,
+            ariaColSpan: number$3,
+            ariaControls: spaceSeparated,
+            ariaCurrent: null,
+            ariaDescribedBy: spaceSeparated,
+            ariaDetails: null,
+            ariaDisabled: booleanish,
+            ariaDropEffect: spaceSeparated,
+            ariaErrorMessage: null,
+            ariaExpanded: booleanish,
+            ariaFlowTo: spaceSeparated,
+            ariaGrabbed: booleanish,
+            ariaHasPopup: null,
+            ariaHidden: booleanish,
+            ariaInvalid: null,
+            ariaKeyShortcuts: null,
+            ariaLabel: null,
+            ariaLabelledBy: spaceSeparated,
+            ariaLevel: number$3,
+            ariaLive: null,
+            ariaModal: booleanish,
+            ariaMultiLine: booleanish,
+            ariaMultiSelectable: booleanish,
+            ariaOrientation: null,
+            ariaOwns: spaceSeparated,
+            ariaPlaceholder: null,
+            ariaPosInSet: number$3,
+            ariaPressed: booleanish,
+            ariaReadOnly: booleanish,
+            ariaRelevant: null,
+            ariaRequired: booleanish,
+            ariaRoleDescription: spaceSeparated,
+            ariaRowCount: number$3,
+            ariaRowIndex: number$3,
+            ariaRowSpan: number$3,
+            ariaSelected: booleanish,
+            ariaSetSize: number$3,
+            ariaSort: null,
+            ariaValueMax: number$3,
+            ariaValueMin: number$3,
+            ariaValueNow: number$3,
+            ariaValueText: null,
+            role: null
         }
-        var currentNode = getParentNode$1(element2);
-        if (isShadowRoot(currentNode)) {
-            currentNode = currentNode.host;
+    });
+    const html$4 = create$1({
+        space: "html",
+        attributes: {
+            acceptcharset: "accept-charset",
+            classname: "class",
+            htmlfor: "for",
+            httpequiv: "http-equiv"
+        },
+        transform: caseInsensitiveTransform,
+        mustUseProperty: ["checked", "multiple", "muted", "selected"],
+        properties: {
+            abbr: null,
+            accept: commaSeparated,
+            acceptCharset: spaceSeparated,
+            accessKey: spaceSeparated,
+            action: null,
+            allow: null,
+            allowFullScreen: boolean,
+            allowPaymentRequest: boolean,
+            allowUserMedia: boolean,
+            alt: null,
+            as: null,
+            async: boolean,
+            autoCapitalize: null,
+            autoComplete: spaceSeparated,
+            autoFocus: boolean,
+            autoPlay: boolean,
+            blocking: spaceSeparated,
+            capture: boolean,
+            charSet: null,
+            checked: boolean,
+            cite: null,
+            className: spaceSeparated,
+            cols: number$3,
+            colSpan: null,
+            content: null,
+            contentEditable: booleanish,
+            controls: boolean,
+            controlsList: spaceSeparated,
+            coords: number$3 | commaSeparated,
+            crossOrigin: null,
+            data: null,
+            dateTime: null,
+            decoding: null,
+            default: boolean,
+            defer: boolean,
+            dir: null,
+            dirName: null,
+            disabled: boolean,
+            download: overloadedBoolean,
+            draggable: booleanish,
+            encType: null,
+            enterKeyHint: null,
+            fetchPriority: null,
+            form: null,
+            formAction: null,
+            formEncType: null,
+            formMethod: null,
+            formNoValidate: boolean,
+            formTarget: null,
+            headers: spaceSeparated,
+            height: number$3,
+            hidden: boolean,
+            high: number$3,
+            href: null,
+            hrefLang: null,
+            htmlFor: spaceSeparated,
+            httpEquiv: spaceSeparated,
+            id: null,
+            imageSizes: null,
+            imageSrcSet: null,
+            inert: boolean,
+            inputMode: null,
+            integrity: null,
+            is: null,
+            isMap: boolean,
+            itemId: null,
+            itemProp: spaceSeparated,
+            itemRef: spaceSeparated,
+            itemScope: boolean,
+            itemType: spaceSeparated,
+            kind: null,
+            label: null,
+            lang: null,
+            language: null,
+            list: null,
+            loading: null,
+            loop: boolean,
+            low: number$3,
+            manifest: null,
+            max: null,
+            maxLength: number$3,
+            media: null,
+            method: null,
+            min: null,
+            minLength: number$3,
+            multiple: boolean,
+            muted: boolean,
+            name: null,
+            nonce: null,
+            noModule: boolean,
+            noValidate: boolean,
+            onAbort: null,
+            onAfterPrint: null,
+            onAuxClick: null,
+            onBeforeMatch: null,
+            onBeforePrint: null,
+            onBeforeToggle: null,
+            onBeforeUnload: null,
+            onBlur: null,
+            onCancel: null,
+            onCanPlay: null,
+            onCanPlayThrough: null,
+            onChange: null,
+            onClick: null,
+            onClose: null,
+            onContextLost: null,
+            onContextMenu: null,
+            onContextRestored: null,
+            onCopy: null,
+            onCueChange: null,
+            onCut: null,
+            onDblClick: null,
+            onDrag: null,
+            onDragEnd: null,
+            onDragEnter: null,
+            onDragExit: null,
+            onDragLeave: null,
+            onDragOver: null,
+            onDragStart: null,
+            onDrop: null,
+            onDurationChange: null,
+            onEmptied: null,
+            onEnded: null,
+            onError: null,
+            onFocus: null,
+            onFormData: null,
+            onHashChange: null,
+            onInput: null,
+            onInvalid: null,
+            onKeyDown: null,
+            onKeyPress: null,
+            onKeyUp: null,
+            onLanguageChange: null,
+            onLoad: null,
+            onLoadedData: null,
+            onLoadedMetadata: null,
+            onLoadEnd: null,
+            onLoadStart: null,
+            onMessage: null,
+            onMessageError: null,
+            onMouseDown: null,
+            onMouseEnter: null,
+            onMouseLeave: null,
+            onMouseMove: null,
+            onMouseOut: null,
+            onMouseOver: null,
+            onMouseUp: null,
+            onOffline: null,
+            onOnline: null,
+            onPageHide: null,
+            onPageShow: null,
+            onPaste: null,
+            onPause: null,
+            onPlay: null,
+            onPlaying: null,
+            onPopState: null,
+            onProgress: null,
+            onRateChange: null,
+            onRejectionHandled: null,
+            onReset: null,
+            onResize: null,
+            onScroll: null,
+            onScrollEnd: null,
+            onSecurityPolicyViolation: null,
+            onSeeked: null,
+            onSeeking: null,
+            onSelect: null,
+            onSlotChange: null,
+            onStalled: null,
+            onStorage: null,
+            onSubmit: null,
+            onSuspend: null,
+            onTimeUpdate: null,
+            onToggle: null,
+            onUnhandledRejection: null,
+            onUnload: null,
+            onVolumeChange: null,
+            onWaiting: null,
+            onWheel: null,
+            open: boolean,
+            optimum: number$3,
+            pattern: null,
+            ping: spaceSeparated,
+            placeholder: null,
+            playsInline: boolean,
+            popover: null,
+            popoverTarget: null,
+            popoverTargetAction: null,
+            poster: null,
+            preload: null,
+            readOnly: boolean,
+            referrerPolicy: null,
+            rel: spaceSeparated,
+            required: boolean,
+            reversed: boolean,
+            rows: number$3,
+            rowSpan: number$3,
+            sandbox: spaceSeparated,
+            scope: null,
+            scoped: boolean,
+            seamless: boolean,
+            selected: boolean,
+            shadowRootDelegatesFocus: boolean,
+            shadowRootMode: null,
+            shape: null,
+            size: number$3,
+            sizes: null,
+            slot: null,
+            span: number$3,
+            spellCheck: booleanish,
+            src: null,
+            srcDoc: null,
+            srcLang: null,
+            srcSet: null,
+            start: number$3,
+            step: null,
+            style: null,
+            tabIndex: number$3,
+            target: null,
+            title: null,
+            translate: null,
+            type: null,
+            typeMustMatch: boolean,
+            useMap: null,
+            value: booleanish,
+            width: number$3,
+            wrap: null,
+            align: null,
+            aLink: null,
+            archive: spaceSeparated,
+            axis: null,
+            background: null,
+            bgColor: null,
+            border: number$3,
+            borderColor: null,
+            bottomMargin: number$3,
+            cellPadding: null,
+            cellSpacing: null,
+            char: null,
+            charOff: null,
+            classId: null,
+            clear: null,
+            code: null,
+            codeBase: null,
+            codeType: null,
+            color: null,
+            compact: boolean,
+            declare: boolean,
+            event: null,
+            face: null,
+            frame: null,
+            frameBorder: null,
+            hSpace: number$3,
+            leftMargin: number$3,
+            link: null,
+            longDesc: null,
+            lowSrc: null,
+            marginHeight: number$3,
+            marginWidth: number$3,
+            noResize: boolean,
+            noHref: boolean,
+            noShade: boolean,
+            noWrap: boolean,
+            object: null,
+            profile: null,
+            prompt: null,
+            rev: null,
+            rightMargin: number$3,
+            rules: null,
+            scheme: null,
+            scrolling: booleanish,
+            standby: null,
+            summary: null,
+            text: null,
+            topMargin: number$3,
+            valueType: null,
+            version: null,
+            vAlign: null,
+            vLink: null,
+            vSpace: number$3,
+            allowTransparency: null,
+            autoCorrect: null,
+            autoSave: null,
+            disablePictureInPicture: boolean,
+            disableRemotePlayback: boolean,
+            prefix: null,
+            property: null,
+            results: number$3,
+            security: null,
+            unselectable: null
         }
-        while (isHTMLElement$1(currentNode) && ["html", "body"].indexOf(getNodeName$1(currentNode)) < 0) {
-            var css2 = getComputedStyle$2(currentNode);
-            if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox2 && css2.willChange === "filter" || isFirefox2 && css2.filter && css2.filter !== "none") {
-                return currentNode;
-            } else {
-                currentNode = currentNode.parentNode;
-            }
+    });
+    const svg$1 = create$1({
+        space: "svg",
+        attributes: {
+            accentHeight: "accent-height",
+            alignmentBaseline: "alignment-baseline",
+            arabicForm: "arabic-form",
+            baselineShift: "baseline-shift",
+            capHeight: "cap-height",
+            className: "class",
+            clipPath: "clip-path",
+            clipRule: "clip-rule",
+            colorInterpolation: "color-interpolation",
+            colorInterpolationFilters: "color-interpolation-filters",
+            colorProfile: "color-profile",
+            colorRendering: "color-rendering",
+            crossOrigin: "crossorigin",
+            dataType: "datatype",
+            dominantBaseline: "dominant-baseline",
+            enableBackground: "enable-background",
+            fillOpacity: "fill-opacity",
+            fillRule: "fill-rule",
+            floodColor: "flood-color",
+            floodOpacity: "flood-opacity",
+            fontFamily: "font-family",
+            fontSize: "font-size",
+            fontSizeAdjust: "font-size-adjust",
+            fontStretch: "font-stretch",
+            fontStyle: "font-style",
+            fontVariant: "font-variant",
+            fontWeight: "font-weight",
+            glyphName: "glyph-name",
+            glyphOrientationHorizontal: "glyph-orientation-horizontal",
+            glyphOrientationVertical: "glyph-orientation-vertical",
+            hrefLang: "hreflang",
+            horizAdvX: "horiz-adv-x",
+            horizOriginX: "horiz-origin-x",
+            horizOriginY: "horiz-origin-y",
+            imageRendering: "image-rendering",
+            letterSpacing: "letter-spacing",
+            lightingColor: "lighting-color",
+            markerEnd: "marker-end",
+            markerMid: "marker-mid",
+            markerStart: "marker-start",
+            navDown: "nav-down",
+            navDownLeft: "nav-down-left",
+            navDownRight: "nav-down-right",
+            navLeft: "nav-left",
+            navNext: "nav-next",
+            navPrev: "nav-prev",
+            navRight: "nav-right",
+            navUp: "nav-up",
+            navUpLeft: "nav-up-left",
+            navUpRight: "nav-up-right",
+            onAbort: "onabort",
+            onActivate: "onactivate",
+            onAfterPrint: "onafterprint",
+            onBeforePrint: "onbeforeprint",
+            onBegin: "onbegin",
+            onCancel: "oncancel",
+            onCanPlay: "oncanplay",
+            onCanPlayThrough: "oncanplaythrough",
+            onChange: "onchange",
+            onClick: "onclick",
+            onClose: "onclose",
+            onCopy: "oncopy",
+            onCueChange: "oncuechange",
+            onCut: "oncut",
+            onDblClick: "ondblclick",
+            onDrag: "ondrag",
+            onDragEnd: "ondragend",
+            onDragEnter: "ondragenter",
+            onDragExit: "ondragexit",
+            onDragLeave: "ondragleave",
+            onDragOver: "ondragover",
+            onDragStart: "ondragstart",
+            onDrop: "ondrop",
+            onDurationChange: "ondurationchange",
+            onEmptied: "onemptied",
+            onEnd: "onend",
+            onEnded: "onended",
+            onError: "onerror",
+            onFocus: "onfocus",
+            onFocusIn: "onfocusin",
+            onFocusOut: "onfocusout",
+            onHashChange: "onhashchange",
+            onInput: "oninput",
+            onInvalid: "oninvalid",
+            onKeyDown: "onkeydown",
+            onKeyPress: "onkeypress",
+            onKeyUp: "onkeyup",
+            onLoad: "onload",
+            onLoadedData: "onloadeddata",
+            onLoadedMetadata: "onloadedmetadata",
+            onLoadStart: "onloadstart",
+            onMessage: "onmessage",
+            onMouseDown: "onmousedown",
+            onMouseEnter: "onmouseenter",
+            onMouseLeave: "onmouseleave",
+            onMouseMove: "onmousemove",
+            onMouseOut: "onmouseout",
+            onMouseOver: "onmouseover",
+            onMouseUp: "onmouseup",
+            onMouseWheel: "onmousewheel",
+            onOffline: "onoffline",
+            onOnline: "ononline",
+            onPageHide: "onpagehide",
+            onPageShow: "onpageshow",
+            onPaste: "onpaste",
+            onPause: "onpause",
+            onPlay: "onplay",
+            onPlaying: "onplaying",
+            onPopState: "onpopstate",
+            onProgress: "onprogress",
+            onRateChange: "onratechange",
+            onRepeat: "onrepeat",
+            onReset: "onreset",
+            onResize: "onresize",
+            onScroll: "onscroll",
+            onSeeked: "onseeked",
+            onSeeking: "onseeking",
+            onSelect: "onselect",
+            onShow: "onshow",
+            onStalled: "onstalled",
+            onStorage: "onstorage",
+            onSubmit: "onsubmit",
+            onSuspend: "onsuspend",
+            onTimeUpdate: "ontimeupdate",
+            onToggle: "ontoggle",
+            onUnload: "onunload",
+            onVolumeChange: "onvolumechange",
+            onWaiting: "onwaiting",
+            onZoom: "onzoom",
+            overlinePosition: "overline-position",
+            overlineThickness: "overline-thickness",
+            paintOrder: "paint-order",
+            panose1: "panose-1",
+            pointerEvents: "pointer-events",
+            referrerPolicy: "referrerpolicy",
+            renderingIntent: "rendering-intent",
+            shapeRendering: "shape-rendering",
+            stopColor: "stop-color",
+            stopOpacity: "stop-opacity",
+            strikethroughPosition: "strikethrough-position",
+            strikethroughThickness: "strikethrough-thickness",
+            strokeDashArray: "stroke-dasharray",
+            strokeDashOffset: "stroke-dashoffset",
+            strokeLineCap: "stroke-linecap",
+            strokeLineJoin: "stroke-linejoin",
+            strokeMiterLimit: "stroke-miterlimit",
+            strokeOpacity: "stroke-opacity",
+            strokeWidth: "stroke-width",
+            tabIndex: "tabindex",
+            textAnchor: "text-anchor",
+            textDecoration: "text-decoration",
+            textRendering: "text-rendering",
+            transformOrigin: "transform-origin",
+            typeOf: "typeof",
+            underlinePosition: "underline-position",
+            underlineThickness: "underline-thickness",
+            unicodeBidi: "unicode-bidi",
+            unicodeRange: "unicode-range",
+            unitsPerEm: "units-per-em",
+            vAlphabetic: "v-alphabetic",
+            vHanging: "v-hanging",
+            vIdeographic: "v-ideographic",
+            vMathematical: "v-mathematical",
+            vectorEffect: "vector-effect",
+            vertAdvY: "vert-adv-y",
+            vertOriginX: "vert-origin-x",
+            vertOriginY: "vert-origin-y",
+            wordSpacing: "word-spacing",
+            writingMode: "writing-mode",
+            xHeight: "x-height",
+            playbackOrder: "playbackorder",
+            timelineBegin: "timelinebegin"
+        },
+        transform: caseSensitiveTransform,
+        properties: {
+            about: commaOrSpaceSeparated,
+            accentHeight: number$3,
+            accumulate: null,
+            additive: null,
+            alignmentBaseline: null,
+            alphabetic: number$3,
+            amplitude: number$3,
+            arabicForm: null,
+            ascent: number$3,
+            attributeName: null,
+            attributeType: null,
+            azimuth: number$3,
+            bandwidth: null,
+            baselineShift: null,
+            baseFrequency: null,
+            baseProfile: null,
+            bbox: null,
+            begin: null,
+            bias: number$3,
+            by: null,
+            calcMode: null,
+            capHeight: number$3,
+            className: spaceSeparated,
+            clip: null,
+            clipPath: null,
+            clipPathUnits: null,
+            clipRule: null,
+            color: null,
+            colorInterpolation: null,
+            colorInterpolationFilters: null,
+            colorProfile: null,
+            colorRendering: null,
+            content: null,
+            contentScriptType: null,
+            contentStyleType: null,
+            crossOrigin: null,
+            cursor: null,
+            cx: null,
+            cy: null,
+            d: null,
+            dataType: null,
+            defaultAction: null,
+            descent: number$3,
+            diffuseConstant: number$3,
+            direction: null,
+            display: null,
+            dur: null,
+            divisor: number$3,
+            dominantBaseline: null,
+            download: boolean,
+            dx: null,
+            dy: null,
+            edgeMode: null,
+            editable: null,
+            elevation: number$3,
+            enableBackground: null,
+            end: null,
+            event: null,
+            exponent: number$3,
+            externalResourcesRequired: null,
+            fill: null,
+            fillOpacity: number$3,
+            fillRule: null,
+            filter: null,
+            filterRes: null,
+            filterUnits: null,
+            floodColor: null,
+            floodOpacity: null,
+            focusable: null,
+            focusHighlight: null,
+            fontFamily: null,
+            fontSize: null,
+            fontSizeAdjust: null,
+            fontStretch: null,
+            fontStyle: null,
+            fontVariant: null,
+            fontWeight: null,
+            format: null,
+            fr: null,
+            from: null,
+            fx: null,
+            fy: null,
+            g1: commaSeparated,
+            g2: commaSeparated,
+            glyphName: commaSeparated,
+            glyphOrientationHorizontal: null,
+            glyphOrientationVertical: null,
+            glyphRef: null,
+            gradientTransform: null,
+            gradientUnits: null,
+            handler: null,
+            hanging: number$3,
+            hatchContentUnits: null,
+            hatchUnits: null,
+            height: null,
+            href: null,
+            hrefLang: null,
+            horizAdvX: number$3,
+            horizOriginX: number$3,
+            horizOriginY: number$3,
+            id: null,
+            ideographic: number$3,
+            imageRendering: null,
+            initialVisibility: null,
+            in: null,
+            in2: null,
+            intercept: number$3,
+            k: number$3,
+            k1: number$3,
+            k2: number$3,
+            k3: number$3,
+            k4: number$3,
+            kernelMatrix: commaOrSpaceSeparated,
+            kernelUnitLength: null,
+            keyPoints: null,
+            keySplines: null,
+            keyTimes: null,
+            kerning: null,
+            lang: null,
+            lengthAdjust: null,
+            letterSpacing: null,
+            lightingColor: null,
+            limitingConeAngle: number$3,
+            local: null,
+            markerEnd: null,
+            markerMid: null,
+            markerStart: null,
+            markerHeight: null,
+            markerUnits: null,
+            markerWidth: null,
+            mask: null,
+            maskContentUnits: null,
+            maskUnits: null,
+            mathematical: null,
+            max: null,
+            media: null,
+            mediaCharacterEncoding: null,
+            mediaContentEncodings: null,
+            mediaSize: number$3,
+            mediaTime: null,
+            method: null,
+            min: null,
+            mode: null,
+            name: null,
+            navDown: null,
+            navDownLeft: null,
+            navDownRight: null,
+            navLeft: null,
+            navNext: null,
+            navPrev: null,
+            navRight: null,
+            navUp: null,
+            navUpLeft: null,
+            navUpRight: null,
+            numOctaves: null,
+            observer: null,
+            offset: null,
+            onAbort: null,
+            onActivate: null,
+            onAfterPrint: null,
+            onBeforePrint: null,
+            onBegin: null,
+            onCancel: null,
+            onCanPlay: null,
+            onCanPlayThrough: null,
+            onChange: null,
+            onClick: null,
+            onClose: null,
+            onCopy: null,
+            onCueChange: null,
+            onCut: null,
+            onDblClick: null,
+            onDrag: null,
+            onDragEnd: null,
+            onDragEnter: null,
+            onDragExit: null,
+            onDragLeave: null,
+            onDragOver: null,
+            onDragStart: null,
+            onDrop: null,
+            onDurationChange: null,
+            onEmptied: null,
+            onEnd: null,
+            onEnded: null,
+            onError: null,
+            onFocus: null,
+            onFocusIn: null,
+            onFocusOut: null,
+            onHashChange: null,
+            onInput: null,
+            onInvalid: null,
+            onKeyDown: null,
+            onKeyPress: null,
+            onKeyUp: null,
+            onLoad: null,
+            onLoadedData: null,
+            onLoadedMetadata: null,
+            onLoadStart: null,
+            onMessage: null,
+            onMouseDown: null,
+            onMouseEnter: null,
+            onMouseLeave: null,
+            onMouseMove: null,
+            onMouseOut: null,
+            onMouseOver: null,
+            onMouseUp: null,
+            onMouseWheel: null,
+            onOffline: null,
+            onOnline: null,
+            onPageHide: null,
+            onPageShow: null,
+            onPaste: null,
+            onPause: null,
+            onPlay: null,
+            onPlaying: null,
+            onPopState: null,
+            onProgress: null,
+            onRateChange: null,
+            onRepeat: null,
+            onReset: null,
+            onResize: null,
+            onScroll: null,
+            onSeeked: null,
+            onSeeking: null,
+            onSelect: null,
+            onShow: null,
+            onStalled: null,
+            onStorage: null,
+            onSubmit: null,
+            onSuspend: null,
+            onTimeUpdate: null,
+            onToggle: null,
+            onUnload: null,
+            onVolumeChange: null,
+            onWaiting: null,
+            onZoom: null,
+            opacity: null,
+            operator: null,
+            order: null,
+            orient: null,
+            orientation: null,
+            origin: null,
+            overflow: null,
+            overlay: null,
+            overlinePosition: number$3,
+            overlineThickness: number$3,
+            paintOrder: null,
+            panose1: null,
+            path: null,
+            pathLength: number$3,
+            patternContentUnits: null,
+            patternTransform: null,
+            patternUnits: null,
+            phase: null,
+            ping: spaceSeparated,
+            pitch: null,
+            playbackOrder: null,
+            pointerEvents: null,
+            points: null,
+            pointsAtX: number$3,
+            pointsAtY: number$3,
+            pointsAtZ: number$3,
+            preserveAlpha: null,
+            preserveAspectRatio: null,
+            primitiveUnits: null,
+            propagate: null,
+            property: commaOrSpaceSeparated,
+            r: null,
+            radius: null,
+            referrerPolicy: null,
+            refX: null,
+            refY: null,
+            rel: commaOrSpaceSeparated,
+            rev: commaOrSpaceSeparated,
+            renderingIntent: null,
+            repeatCount: null,
+            repeatDur: null,
+            requiredExtensions: commaOrSpaceSeparated,
+            requiredFeatures: commaOrSpaceSeparated,
+            requiredFonts: commaOrSpaceSeparated,
+            requiredFormats: commaOrSpaceSeparated,
+            resource: null,
+            restart: null,
+            result: null,
+            rotate: null,
+            rx: null,
+            ry: null,
+            scale: null,
+            seed: null,
+            shapeRendering: null,
+            side: null,
+            slope: null,
+            snapshotTime: null,
+            specularConstant: number$3,
+            specularExponent: number$3,
+            spreadMethod: null,
+            spacing: null,
+            startOffset: null,
+            stdDeviation: null,
+            stemh: null,
+            stemv: null,
+            stitchTiles: null,
+            stopColor: null,
+            stopOpacity: null,
+            strikethroughPosition: number$3,
+            strikethroughThickness: number$3,
+            string: null,
+            stroke: null,
+            strokeDashArray: commaOrSpaceSeparated,
+            strokeDashOffset: null,
+            strokeLineCap: null,
+            strokeLineJoin: null,
+            strokeMiterLimit: number$3,
+            strokeOpacity: number$3,
+            strokeWidth: null,
+            style: null,
+            surfaceScale: number$3,
+            syncBehavior: null,
+            syncBehaviorDefault: null,
+            syncMaster: null,
+            syncTolerance: null,
+            syncToleranceDefault: null,
+            systemLanguage: commaOrSpaceSeparated,
+            tabIndex: number$3,
+            tableValues: null,
+            target: null,
+            targetX: number$3,
+            targetY: number$3,
+            textAnchor: null,
+            textDecoration: null,
+            textRendering: null,
+            textLength: null,
+            timelineBegin: null,
+            title: null,
+            transformBehavior: null,
+            type: null,
+            typeOf: commaOrSpaceSeparated,
+            to: null,
+            transform: null,
+            transformOrigin: null,
+            u1: null,
+            u2: null,
+            underlinePosition: number$3,
+            underlineThickness: number$3,
+            unicode: null,
+            unicodeBidi: null,
+            unicodeRange: null,
+            unitsPerEm: number$3,
+            values: null,
+            vAlphabetic: number$3,
+            vMathematical: number$3,
+            vectorEffect: null,
+            vHanging: number$3,
+            vIdeographic: number$3,
+            version: null,
+            vertAdvY: number$3,
+            vertOriginX: number$3,
+            vertOriginY: number$3,
+            viewBox: null,
+            viewTarget: null,
+            visibility: null,
+            width: null,
+            widths: null,
+            wordSpacing: null,
+            writingMode: null,
+            x: null,
+            x1: null,
+            x2: null,
+            xChannelSelector: null,
+            xHeight: number$3,
+            y: null,
+            y1: null,
+            y2: null,
+            yChannelSelector: null,
+            z: null,
+            zoomAndPan: null
         }
-        return null;
-    }
+    });
+    const valid$1 = /^data[-\w.:]+$/i;
+    const dash = /-[a-z]/g;
+    const cap$1 = /[A-Z]/g;
 
-    function getOffsetParent$1(element2) {
-        var window2 = getWindow$1(element2);
-        var offsetParent = getTrueOffsetParent$1(element2);
-        while (offsetParent && isTableElement$1(offsetParent) && getComputedStyle$2(offsetParent).position === "static") {
-            offsetParent = getTrueOffsetParent$1(offsetParent);
+    function find$3(schema, value) {
+        const normal = normalize$2(value);
+        let prop = value;
+        let Type2 = Info;
+        if (normal in schema.normal) {
+            return schema.property[schema.normal[normal]];
         }
-        if (offsetParent && (getNodeName$1(offsetParent) === "html" || getNodeName$1(offsetParent) === "body" && getComputedStyle$2(offsetParent).position === "static")) {
-            return window2;
+        if (normal.length > 4 && normal.slice(0, 4) === "data" && valid$1.test(value)) {
+            if (value.charAt(4) === "-") {
+                const rest = value.slice(5).replace(dash, camelcase);
+                prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
+            } else {
+                const rest = value.slice(4);
+                if (!dash.test(rest)) {
+                    let dashes = rest.replace(cap$1, kebab);
+                    if (dashes.charAt(0) !== "-") {
+                        dashes = "-" + dashes;
+                    }
+                    value = "data" + dashes;
+                }
+            }
+            Type2 = DefinedInfo;
         }
-        return offsetParent || getContainingBlock(element2) || window2;
-    }
-
-    function getMainAxisFromPlacement$1(placement) {
-        return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
+        return new Type2(prop, value);
     }
 
-    function within$1(min2, value, max2) {
-        return max$3(min2, min$2(value, max2));
+    function kebab($0) {
+        return "-" + $0.toLowerCase();
     }
 
-    function withinMaxClamp(min2, value, max2) {
-        var v2 = within$1(min2, value, max2);
-        return v2 > max2 ? max2 : v2;
+    function camelcase($0) {
+        return $0.charAt(1).toUpperCase();
     }
+    const hastToReact = {
+        classId: "classID",
+        dataType: "datatype",
+        itemId: "itemID",
+        strokeDashArray: "strokeDasharray",
+        strokeDashOffset: "strokeDashoffset",
+        strokeLineCap: "strokeLinecap",
+        strokeLineJoin: "strokeLinejoin",
+        strokeMiterLimit: "strokeMiterlimit",
+        typeOf: "typeof",
+        xLinkActuate: "xlinkActuate",
+        xLinkArcRole: "xlinkArcrole",
+        xLinkHref: "xlinkHref",
+        xLinkRole: "xlinkRole",
+        xLinkShow: "xlinkShow",
+        xLinkTitle: "xlinkTitle",
+        xLinkType: "xlinkType",
+        xmlnsXLink: "xmlnsXlink"
+    };
+    const html$3 = merge$1([xml, xlink, xmlns, aria, html$4], "html");
+    const svg = merge$1([xml, xlink, xmlns, aria, svg$1], "svg");
 
-    function getFreshSideObject$1() {
-        return {
-            top: 0,
-            right: 0,
-            bottom: 0,
-            left: 0
-        };
+    function parse$7(value) {
+        const input = String(value || "").trim();
+        return input ? input.split(/[ \t\n\r\f]+/g) : [];
     }
 
-    function mergePaddingObject$1(paddingObject) {
-        return Object.assign({}, getFreshSideObject$1(), paddingObject);
+    function stringify$2(values) {
+        return values.join(" ").trim();
     }
+    var cjs = {};
+    var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
+    var NEWLINE_REGEX = /\n/g;
+    var WHITESPACE_REGEX = /^\s*/;
+    var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
+    var COLON_REGEX = /^:\s*/;
+    var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
+    var SEMICOLON_REGEX = /^[;\s]*/;
+    var TRIM_REGEX = /^\s+|\s+$/g;
+    var NEWLINE = "\n";
+    var FORWARD_SLASH = "/";
+    var ASTERISK = "*";
+    var EMPTY_STRING = "";
+    var TYPE_COMMENT = "comment";
+    var TYPE_DECLARATION = "declaration";
+    var inlineStyleParser = function(style2, options) {
+        if (typeof style2 !== "string") {
+            throw new TypeError("First argument must be a string");
+        }
+        if (!style2)
+            return [];
+        options = options || {};
+        var lineno = 1;
+        var column = 1;
 
-    function expandToHashMap$1(value, keys2) {
-        return keys2.reduce(function(hashMap, key) {
-            hashMap[key] = value;
-            return hashMap;
-        }, {});
-    }
-    var toPaddingObject = function toPaddingObject2(padding, state) {
-        padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
-            placement: state.placement
-        })) : padding;
-        return mergePaddingObject$1(typeof padding !== "number" ? padding : expandToHashMap$1(padding, basePlacements$1));
-    };
+        function updatePosition(str) {
+            var lines = str.match(NEWLINE_REGEX);
+            if (lines)
+                lineno += lines.length;
+            var i2 = str.lastIndexOf(NEWLINE);
+            column = ~i2 ? str.length - i2 : column + str.length;
+        }
 
-    function arrow$2(_ref2) {
-        var _state$modifiersData$;
-        var state = _ref2.state,
-            name2 = _ref2.name,
-            options = _ref2.options;
-        var arrowElement = state.elements.arrow;
-        var popperOffsets2 = state.modifiersData.popperOffsets;
-        var basePlacement = getBasePlacement$3(state.placement);
-        var axis = getMainAxisFromPlacement$1(basePlacement);
-        var isVertical = [left$1, right$1].indexOf(basePlacement) >= 0;
-        var len = isVertical ? "height" : "width";
-        if (!arrowElement || !popperOffsets2) {
-            return;
+        function position2() {
+            var start2 = {
+                line: lineno,
+                column
+            };
+            return function(node2) {
+                node2.position = new Position(start2);
+                whitespace2();
+                return node2;
+            };
         }
-        var paddingObject = toPaddingObject(options.padding, state);
-        var arrowRect = getLayoutRect$1(arrowElement);
-        var minProp = axis === "y" ? top$2 : left$1;
-        var maxProp = axis === "y" ? bottom$1 : right$1;
-        var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
-        var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
-        var arrowOffsetParent = getOffsetParent$1(arrowElement);
-        var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
-        var centerToReference = endDiff / 2 - startDiff / 2;
-        var min2 = paddingObject[minProp];
-        var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
-        var center2 = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
-        var offset2 = within$1(min2, center2, max2);
-        var axisProp = axis;
-        state.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center2, _state$modifiersData$);
-    }
 
-    function effect$4(_ref2) {
-        var state = _ref2.state,
-            options = _ref2.options;
-        var _options$element = options.element,
-            arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
-        if (arrowElement == null) {
-            return;
+        function Position(start2) {
+            this.start = start2;
+            this.end = {
+                line: lineno,
+                column
+            };
+            this.source = options.source;
         }
-        if (typeof arrowElement === "string") {
-            arrowElement = state.elements.popper.querySelector(arrowElement);
-            if (!arrowElement) {
-                return;
+        Position.prototype.content = style2;
+
+        function error2(msg) {
+            var err = new Error(
+                options.source + ":" + lineno + ":" + column + ": " + msg
+            );
+            err.reason = msg;
+            err.filename = options.source;
+            err.line = lineno;
+            err.column = column;
+            err.source = style2;
+            if (options.silent)
+            ;
+            else {
+                throw err;
             }
         }
-        if (!contains$2(state.elements.popper, arrowElement)) {
-            return;
-        }
-        state.elements.arrow = arrowElement;
-    }
-    const arrow$3 = {
-        name: "arrow",
-        enabled: true,
-        phase: "main",
-        fn: arrow$2,
-        effect: effect$4,
-        requires: ["popperOffsets"],
-        requiresIfExists: ["preventOverflow"]
-    };
 
-    function getVariation$1(placement) {
-        return placement.split("-")[1];
-    }
-    var unsetSides$1 = {
-        top: "auto",
-        right: "auto",
-        bottom: "auto",
-        left: "auto"
-    };
+        function match2(re2) {
+            var m2 = re2.exec(style2);
+            if (!m2)
+                return;
+            var str = m2[0];
+            updatePosition(str);
+            style2 = style2.slice(str.length);
+            return m2;
+        }
 
-    function roundOffsetsByDPR(_ref2, win) {
-        var x2 = _ref2.x,
-            y2 = _ref2.y;
-        var dpr = win.devicePixelRatio || 1;
-        return {
-            x: round$2(x2 * dpr) / dpr || 0,
-            y: round$2(y2 * dpr) / dpr || 0
-        };
-    }
+        function whitespace2() {
+            match2(WHITESPACE_REGEX);
+        }
 
-    function mapToStyles$1(_ref2) {
-        var _Object$assign2;
-        var popper2 = _ref2.popper,
-            popperRect = _ref2.popperRect,
-            placement = _ref2.placement,
-            variation = _ref2.variation,
-            offsets = _ref2.offsets,
-            position2 = _ref2.position,
-            gpuAcceleration = _ref2.gpuAcceleration,
-            adaptive = _ref2.adaptive,
-            roundOffsets2 = _ref2.roundOffsets,
-            isFixed = _ref2.isFixed;
-        var _offsets$x = offsets.x,
-            x2 = _offsets$x === void 0 ? 0 : _offsets$x,
-            _offsets$y = offsets.y,
-            y2 = _offsets$y === void 0 ? 0 : _offsets$y;
-        var _ref3 = typeof roundOffsets2 === "function" ? roundOffsets2({
-            x: x2,
-            y: y2
-        }) : {
-            x: x2,
-            y: y2
-        };
-        x2 = _ref3.x;
-        y2 = _ref3.y;
-        var hasX = offsets.hasOwnProperty("x");
-        var hasY = offsets.hasOwnProperty("y");
-        var sideX = left$1;
-        var sideY = top$2;
-        var win = window;
-        if (adaptive) {
-            var offsetParent = getOffsetParent$1(popper2);
-            var heightProp = "clientHeight";
-            var widthProp = "clientWidth";
-            if (offsetParent === getWindow$1(popper2)) {
-                offsetParent = getDocumentElement$1(popper2);
-                if (getComputedStyle$2(offsetParent).position !== "static" && position2 === "absolute") {
-                    heightProp = "scrollHeight";
-                    widthProp = "scrollWidth";
+        function comments(rules) {
+            var c2;
+            rules = rules || [];
+            while (c2 = comment2()) {
+                if (c2 !== false) {
+                    rules.push(c2);
                 }
             }
-            offsetParent = offsetParent;
-            if (placement === top$2 || (placement === left$1 || placement === right$1) && variation === end$1) {
-                sideY = bottom$1;
-                var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
-                y2 -= offsetY - popperRect.height;
-                y2 *= gpuAcceleration ? 1 : -1;
-            }
-            if (placement === left$1 || (placement === top$2 || placement === bottom$1) && variation === end$1) {
-                sideX = right$1;
-                var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
-                x2 -= offsetX - popperRect.width;
-                x2 *= gpuAcceleration ? 1 : -1;
-            }
-        }
-        var commonStyles = Object.assign({
-            position: position2
-        }, adaptive && unsetSides$1);
-        var _ref4 = roundOffsets2 === true ? roundOffsetsByDPR({
-            x: x2,
-            y: y2
-        }, getWindow$1(popper2)) : {
-            x: x2,
-            y: y2
-        };
-        x2 = _ref4.x;
-        y2 = _ref4.y;
-        if (gpuAcceleration) {
-            var _Object$assign;
-            return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
+            return rules;
         }
-        return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
-    }
 
-    function computeStyles$2(_ref5) {
-        var state = _ref5.state,
-            options = _ref5.options;
-        var _options$gpuAccelerat = options.gpuAcceleration,
-            gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
-            _options$adaptive = options.adaptive,
-            adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
-            _options$roundOffsets = options.roundOffsets,
-            roundOffsets2 = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
-        var commonStyles = {
-            placement: getBasePlacement$3(state.placement),
-            variation: getVariation$1(state.placement),
-            popper: state.elements.popper,
-            popperRect: state.rects.popper,
-            gpuAcceleration,
-            isFixed: state.options.strategy === "fixed"
-        };
-        if (state.modifiersData.popperOffsets != null) {
-            state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles$1(Object.assign({}, commonStyles, {
-                offsets: state.modifiersData.popperOffsets,
-                position: state.options.strategy,
-                adaptive,
-                roundOffsets: roundOffsets2
-            })));
-        }
-        if (state.modifiersData.arrow != null) {
-            state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles$1(Object.assign({}, commonStyles, {
-                offsets: state.modifiersData.arrow,
-                position: "absolute",
-                adaptive: false,
-                roundOffsets: roundOffsets2
-            })));
+        function comment2() {
+            var pos = position2();
+            if (FORWARD_SLASH != style2.charAt(0) || ASTERISK != style2.charAt(1))
+                return;
+            var i2 = 2;
+            while (EMPTY_STRING != style2.charAt(i2) && (ASTERISK != style2.charAt(i2) || FORWARD_SLASH != style2.charAt(i2 + 1))) {
+                ++i2;
+            }
+            i2 += 2;
+            if (EMPTY_STRING === style2.charAt(i2 - 1)) {
+                return error2("End of comment missing");
+            }
+            var str = style2.slice(2, i2 - 2);
+            column += 2;
+            updatePosition(str);
+            style2 = style2.slice(i2);
+            column += 2;
+            return pos({
+                type: TYPE_COMMENT,
+                comment: str
+            });
         }
-        state.attributes.popper = Object.assign({}, state.attributes.popper, {
-            "data-popper-placement": state.placement
-        });
-    }
-    const computeStyles$3 = {
-        name: "computeStyles",
-        enabled: true,
-        phase: "beforeWrite",
-        fn: computeStyles$2,
-        data: {}
-    };
-    var passive$1 = {
-        passive: true
-    };
 
-    function effect$3(_ref2) {
-        var state = _ref2.state,
-            instance2 = _ref2.instance,
-            options = _ref2.options;
-        var _options$scroll = options.scroll,
-            scroll = _options$scroll === void 0 ? true : _options$scroll,
-            _options$resize = options.resize,
-            resize = _options$resize === void 0 ? true : _options$resize;
-        var window2 = getWindow$1(state.elements.popper);
-        var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
-        if (scroll) {
-            scrollParents.forEach(function(scrollParent) {
-                scrollParent.addEventListener("scroll", instance2.update, passive$1);
+        function declaration() {
+            var pos = position2();
+            var prop = match2(PROPERTY_REGEX);
+            if (!prop)
+                return;
+            comment2();
+            if (!match2(COLON_REGEX))
+                return error2("property missing ':'");
+            var val = match2(VALUE_REGEX);
+            var ret = pos({
+                type: TYPE_DECLARATION,
+                property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
+                value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
             });
+            match2(SEMICOLON_REGEX);
+            return ret;
         }
-        if (resize) {
-            window2.addEventListener("resize", instance2.update, passive$1);
-        }
-        return function() {
-            if (scroll) {
-                scrollParents.forEach(function(scrollParent) {
-                    scrollParent.removeEventListener("scroll", instance2.update, passive$1);
-                });
-            }
-            if (resize) {
-                window2.removeEventListener("resize", instance2.update, passive$1);
+
+        function declarations() {
+            var decls = [];
+            comments(decls);
+            var decl;
+            while (decl = declaration()) {
+                if (decl !== false) {
+                    decls.push(decl);
+                    comments(decls);
+                }
             }
-        };
-    }
-    const eventListeners$1 = {
-        name: "eventListeners",
-        enabled: true,
-        phase: "write",
-        fn: function fn2() {},
-        effect: effect$3,
-        data: {}
-    };
-    var hash$4 = {
-        left: "right",
-        right: "left",
-        bottom: "top",
-        top: "bottom"
+            return decls;
+        }
+        whitespace2();
+        return declarations();
     };
 
-    function getOppositePlacement$1(placement) {
-        return placement.replace(/left|right|bottom|top/g, function(matched) {
-            return hash$4[matched];
-        });
+    function trim(str) {
+        return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
     }
-    var hash$3 = {
-        start: "end",
-        end: "start"
+    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
+        return mod && mod.__esModule ? mod : {
+            "default": mod
+        };
     };
+    Object.defineProperty(cjs, "__esModule", {
+        value: true
+    });
+    var inline_style_parser_1 = __importDefault(inlineStyleParser);
 
-    function getOppositeVariationPlacement$1(placement) {
-        return placement.replace(/start|end/g, function(matched) {
-            return hash$3[matched];
+    function StyleToObject(style2, iterator2) {
+        var styleObject = null;
+        if (!style2 || typeof style2 !== "string") {
+            return styleObject;
+        }
+        var declarations = (0, inline_style_parser_1.default)(style2);
+        var hasIterator = typeof iterator2 === "function";
+        declarations.forEach(function(declaration) {
+            if (declaration.type !== "declaration") {
+                return;
+            }
+            var property = declaration.property,
+                value = declaration.value;
+            if (hasIterator) {
+                iterator2(property, value, declaration);
+            } else if (value) {
+                styleObject = styleObject || {};
+                styleObject[property] = value;
+            }
         });
+        return styleObject;
     }
+    var _default$2 = cjs.default = StyleToObject;
+    const styleToObject = _default$2.default || _default$2;
+    const pointEnd$1 = point$4("end");
+    const pointStart$1 = point$4("start");
 
-    function getWindowScroll$1(node2) {
-        var win = getWindow$1(node2);
-        var scrollLeft = win.pageXOffset;
-        var scrollTop = win.pageYOffset;
-        return {
-            scrollLeft,
-            scrollTop
-        };
-    }
-
-    function getWindowScrollBarX$1(element2) {
-        return getBoundingClientRect$1(getDocumentElement$1(element2)).left + getWindowScroll$1(element2).scrollLeft;
-    }
+    function point$4(type2) {
+        return point2;
 
-    function getViewportRect$1(element2, strategy) {
-        var win = getWindow$1(element2);
-        var html2 = getDocumentElement$1(element2);
-        var visualViewport = win.visualViewport;
-        var width = html2.clientWidth;
-        var height = html2.clientHeight;
-        var x2 = 0;
-        var y2 = 0;
-        if (visualViewport) {
-            width = visualViewport.width;
-            height = visualViewport.height;
-            var layoutViewport = isLayoutViewport();
-            if (layoutViewport || !layoutViewport && strategy === "fixed") {
-                x2 = visualViewport.offsetLeft;
-                y2 = visualViewport.offsetTop;
+        function point2(node2) {
+            const point3 = node2 && node2.position && node2.position[type2] || {};
+            if (typeof point3.line === "number" && point3.line > 0 && typeof point3.column === "number" && point3.column > 0) {
+                return {
+                    line: point3.line,
+                    column: point3.column,
+                    offset: typeof point3.offset === "number" && point3.offset > -1 ? point3.offset : void 0
+                };
             }
         }
-        return {
-            width,
-            height,
-            x: x2 + getWindowScrollBarX$1(element2),
-            y: y2
-        };
     }
 
-    function getDocumentRect$1(element2) {
-        var _element$ownerDocumen;
-        var html2 = getDocumentElement$1(element2);
-        var winScroll = getWindowScroll$1(element2);
-        var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
-        var width = max$3(html2.scrollWidth, html2.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
-        var height = max$3(html2.scrollHeight, html2.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
-        var x2 = -winScroll.scrollLeft + getWindowScrollBarX$1(element2);
-        var y2 = -winScroll.scrollTop;
-        if (getComputedStyle$2(body || html2).direction === "rtl") {
-            x2 += max$3(html2.clientWidth, body ? body.clientWidth : 0) - width;
+    function position$3(node2) {
+        const start2 = pointStart$1(node2);
+        const end2 = pointEnd$1(node2);
+        if (start2 && end2) {
+            return {
+                start: start2,
+                end: end2
+            };
         }
-        return {
-            width,
-            height,
-            x: x2,
-            y: y2
-        };
-    }
-
-    function isScrollParent$1(element2) {
-        var _getComputedStyle = getComputedStyle$2(element2),
-            overflow = _getComputedStyle.overflow,
-            overflowX = _getComputedStyle.overflowX,
-            overflowY = _getComputedStyle.overflowY;
-        return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
     }
 
-    function getScrollParent$1(node2) {
-        if (["html", "body", "#document"].indexOf(getNodeName$1(node2)) >= 0) {
-            return node2.ownerDocument.body;
+    function stringifyPosition(value) {
+        if (!value || typeof value !== "object") {
+            return "";
         }
-        if (isHTMLElement$1(node2) && isScrollParent$1(node2)) {
-            return node2;
+        if ("position" in value || "type" in value) {
+            return position$2(value.position);
         }
-        return getScrollParent$1(getParentNode$1(node2));
-    }
-
-    function listScrollParents$1(element2, list2) {
-        var _element$ownerDocumen;
-        if (list2 === void 0) {
-            list2 = [];
+        if ("start" in value || "end" in value) {
+            return position$2(value);
         }
-        var scrollParent = getScrollParent$1(element2);
-        var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
-        var win = getWindow$1(scrollParent);
-        var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent$1(scrollParent) ? scrollParent : []) : scrollParent;
-        var updatedList = list2.concat(target);
-        return isBody ? updatedList : updatedList.concat(listScrollParents$1(getParentNode$1(target)));
+        if ("line" in value || "column" in value) {
+            return point$3(value);
+        }
+        return "";
     }
 
-    function rectToClientRect$1(rect) {
-        return Object.assign({}, rect, {
-            left: rect.x,
-            top: rect.y,
-            right: rect.x + rect.width,
-            bottom: rect.y + rect.height
-        });
+    function point$3(point2) {
+        return index$2(point2 && point2.line) + ":" + index$2(point2 && point2.column);
     }
 
-    function getInnerBoundingClientRect(element2, strategy) {
-        var rect = getBoundingClientRect$1(element2, false, strategy === "fixed");
-        rect.top = rect.top + element2.clientTop;
-        rect.left = rect.left + element2.clientLeft;
-        rect.bottom = rect.top + element2.clientHeight;
-        rect.right = rect.left + element2.clientWidth;
-        rect.width = element2.clientWidth;
-        rect.height = element2.clientHeight;
-        rect.x = rect.left;
-        rect.y = rect.top;
-        return rect;
+    function position$2(pos) {
+        return point$3(pos && pos.start) + "-" + point$3(pos && pos.end);
     }
 
-    function getClientRectFromMixedType$1(element2, clippingParent, strategy) {
-        return clippingParent === viewport$1 ? rectToClientRect$1(getViewportRect$1(element2, strategy)) : isElement$4(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect$1(getDocumentRect$1(getDocumentElement$1(element2)));
+    function index$2(value) {
+        return value && typeof value === "number" ? value : 1;
     }
-
-    function getClippingParents$1(element2) {
-        var clippingParents2 = listScrollParents$1(getParentNode$1(element2));
-        var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$2(element2).position) >= 0;
-        var clipperElement = canEscapeClipping && isHTMLElement$1(element2) ? getOffsetParent$1(element2) : element2;
-        if (!isElement$4(clipperElement)) {
-            return [];
+    class VFileMessage extends Error {
+        constructor(causeOrReason, optionsOrParentOrPlace, origin) {
+            super();
+            if (typeof optionsOrParentOrPlace === "string") {
+                origin = optionsOrParentOrPlace;
+                optionsOrParentOrPlace = void 0;
+            }
+            let reason = "";
+            let options = {};
+            let legacyCause = false;
+            if (optionsOrParentOrPlace) {
+                if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
+                    options = {
+                        place: optionsOrParentOrPlace
+                    };
+                } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
+                    options = {
+                        place: optionsOrParentOrPlace
+                    };
+                } else if ("type" in optionsOrParentOrPlace) {
+                    options = {
+                        ancestors: [optionsOrParentOrPlace],
+                        place: optionsOrParentOrPlace.position
+                    };
+                } else {
+                    options = {
+                        ...optionsOrParentOrPlace
+                    };
+                }
+            }
+            if (typeof causeOrReason === "string") {
+                reason = causeOrReason;
+            } else if (!options.cause && causeOrReason) {
+                legacyCause = true;
+                reason = causeOrReason.message;
+                options.cause = causeOrReason;
+            }
+            if (!options.ruleId && !options.source && typeof origin === "string") {
+                const index2 = origin.indexOf(":");
+                if (index2 === -1) {
+                    options.ruleId = origin;
+                } else {
+                    options.source = origin.slice(0, index2);
+                    options.ruleId = origin.slice(index2 + 1);
+                }
+            }
+            if (!options.place && options.ancestors && options.ancestors) {
+                const parent = options.ancestors[options.ancestors.length - 1];
+                if (parent) {
+                    options.place = parent.position;
+                }
+            }
+            const start2 = options.place && "start" in options.place ? options.place.start : options.place;
+            this.ancestors = options.ancestors || void 0;
+            this.cause = options.cause || void 0;
+            this.column = start2 ? start2.column : void 0;
+            this.fatal = void 0;
+            this.file;
+            this.message = reason;
+            this.line = start2 ? start2.line : void 0;
+            this.name = stringifyPosition(options.place) || "1:1";
+            this.place = options.place || void 0;
+            this.reason = this.message;
+            this.ruleId = options.ruleId || void 0;
+            this.source = options.source || void 0;
+            this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
+            this.actual;
+            this.expected;
+            this.note;
+            this.url;
         }
-        return clippingParents2.filter(function(clippingParent) {
-            return isElement$4(clippingParent) && contains$2(clippingParent, clipperElement) && getNodeName$1(clippingParent) !== "body";
-        });
-    }
-
-    function getClippingRect$1(element2, boundary, rootBoundary, strategy) {
-        var mainClippingParents = boundary === "clippingParents" ? getClippingParents$1(element2) : [].concat(boundary);
-        var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
-        var firstClippingParent = clippingParents2[0];
-        var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
-            var rect = getClientRectFromMixedType$1(element2, clippingParent, strategy);
-            accRect.top = max$3(rect.top, accRect.top);
-            accRect.right = min$2(rect.right, accRect.right);
-            accRect.bottom = min$2(rect.bottom, accRect.bottom);
-            accRect.left = max$3(rect.left, accRect.left);
-            return accRect;
-        }, getClientRectFromMixedType$1(element2, firstClippingParent, strategy));
-        clippingRect.width = clippingRect.right - clippingRect.left;
-        clippingRect.height = clippingRect.bottom - clippingRect.top;
-        clippingRect.x = clippingRect.left;
-        clippingRect.y = clippingRect.top;
-        return clippingRect;
     }
+    VFileMessage.prototype.file = "";
+    VFileMessage.prototype.name = "";
+    VFileMessage.prototype.reason = "";
+    VFileMessage.prototype.message = "";
+    VFileMessage.prototype.stack = "";
+    VFileMessage.prototype.column = void 0;
+    VFileMessage.prototype.line = void 0;
+    VFileMessage.prototype.ancestors = void 0;
+    VFileMessage.prototype.cause = void 0;
+    VFileMessage.prototype.fatal = void 0;
+    VFileMessage.prototype.place = void 0;
+    VFileMessage.prototype.ruleId = void 0;
+    VFileMessage.prototype.source = void 0;
+    const own$7 = {}.hasOwnProperty;
+    const emptyMap = /* @__PURE__ */ new Map();
+    const cap = /[A-Z]/g;
+    const dashSomething = /-([a-z])/g;
+    const tableElements = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]);
+    const tableCellElement = /* @__PURE__ */ new Set(["td", "th"]);
+    const docs = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
 
-    function computeOffsets$1(_ref2) {
-        var reference2 = _ref2.reference,
-            element2 = _ref2.element,
-            placement = _ref2.placement;
-        var basePlacement = placement ? getBasePlacement$3(placement) : null;
-        var variation = placement ? getVariation$1(placement) : null;
-        var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
-        var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
-        var offsets;
-        switch (basePlacement) {
-            case top$2:
-                offsets = {
-                    x: commonX,
-                    y: reference2.y - element2.height
-                };
-                break;
-            case bottom$1:
-                offsets = {
-                    x: commonX,
-                    y: reference2.y + reference2.height
-                };
-                break;
-            case right$1:
-                offsets = {
-                    x: reference2.x + reference2.width,
-                    y: commonY
-                };
-                break;
-            case left$1:
-                offsets = {
-                    x: reference2.x - element2.width,
-                    y: commonY
-                };
-                break;
-            default:
-                offsets = {
-                    x: reference2.x,
-                    y: reference2.y
-                };
+    function toJsxRuntime(tree, options) {
+        if (!options || options.Fragment === void 0) {
+            throw new TypeError("Expected `Fragment` in options");
         }
-        var mainAxis = basePlacement ? getMainAxisFromPlacement$1(basePlacement) : null;
-        if (mainAxis != null) {
-            var len = mainAxis === "y" ? "height" : "width";
-            switch (variation) {
-                case start$2:
-                    offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
-                    break;
-                case end$1:
-                    offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
-                    break;
+        const filePath = options.filePath || void 0;
+        let create2;
+        if (options.development) {
+            if (typeof options.jsxDEV !== "function") {
+                throw new TypeError(
+                    "Expected `jsxDEV` in options when `development: true`"
+                );
             }
+            create2 = developmentCreate(filePath, options.jsxDEV);
+        } else {
+            if (typeof options.jsx !== "function") {
+                throw new TypeError("Expected `jsx` in production options");
+            }
+            if (typeof options.jsxs !== "function") {
+                throw new TypeError("Expected `jsxs` in production options");
+            }
+            create2 = productionCreate(filePath, options.jsx, options.jsxs);
         }
-        return offsets;
-    }
-
-    function detectOverflow$1(state, options) {
-        if (options === void 0) {
-            options = {};
-        }
-        var _options = options,
-            _options$placement = _options.placement,
-            placement = _options$placement === void 0 ? state.placement : _options$placement,
-            _options$strategy = _options.strategy,
-            strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
-            _options$boundary = _options.boundary,
-            boundary = _options$boundary === void 0 ? clippingParents$1 : _options$boundary,
-            _options$rootBoundary = _options.rootBoundary,
-            rootBoundary = _options$rootBoundary === void 0 ? viewport$1 : _options$rootBoundary,
-            _options$elementConte = _options.elementContext,
-            elementContext = _options$elementConte === void 0 ? popper$1 : _options$elementConte,
-            _options$altBoundary = _options.altBoundary,
-            altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
-            _options$padding = _options.padding,
-            padding = _options$padding === void 0 ? 0 : _options$padding;
-        var paddingObject = mergePaddingObject$1(typeof padding !== "number" ? padding : expandToHashMap$1(padding, basePlacements$1));
-        var altContext = elementContext === popper$1 ? reference$1 : popper$1;
-        var popperRect = state.rects.popper;
-        var element2 = state.elements[altBoundary ? altContext : elementContext];
-        var clippingClientRect = getClippingRect$1(isElement$4(element2) ? element2 : element2.contextElement || getDocumentElement$1(state.elements.popper), boundary, rootBoundary, strategy);
-        var referenceClientRect = getBoundingClientRect$1(state.elements.reference);
-        var popperOffsets2 = computeOffsets$1({
-            reference: referenceClientRect,
-            element: popperRect,
-            strategy: "absolute",
-            placement
-        });
-        var popperClientRect = rectToClientRect$1(Object.assign({}, popperRect, popperOffsets2));
-        var elementClientRect = elementContext === popper$1 ? popperClientRect : referenceClientRect;
-        var overflowOffsets = {
-            top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
-            bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
-            left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
-            right: elementClientRect.right - clippingClientRect.right + paddingObject.right
+        const state = {
+            Fragment: options.Fragment,
+            ancestors: [],
+            components: options.components || {},
+            create: create2,
+            elementAttributeNameCase: options.elementAttributeNameCase || "react",
+            evaluater: options.createEvaluater ? options.createEvaluater() : void 0,
+            filePath,
+            ignoreInvalidStyle: options.ignoreInvalidStyle || false,
+            passKeys: options.passKeys !== false,
+            passNode: options.passNode || false,
+            schema: options.space === "svg" ? svg : html$3,
+            stylePropertyNameCase: options.stylePropertyNameCase || "dom",
+            tableCellAlignToStyle: options.tableCellAlignToStyle !== false
         };
-        var offsetData = state.modifiersData.offset;
-        if (elementContext === popper$1 && offsetData) {
-            var offset2 = offsetData[placement];
-            Object.keys(overflowOffsets).forEach(function(key) {
-                var multiply = [right$1, bottom$1].indexOf(key) >= 0 ? 1 : -1;
-                var axis = [top$2, bottom$1].indexOf(key) >= 0 ? "y" : "x";
-                overflowOffsets[key] += offset2[axis] * multiply;
-            });
+        const result = one$4(state, tree, void 0);
+        if (result && typeof result !== "string") {
+            return result;
         }
-        return overflowOffsets;
+        return state.create(
+            tree,
+            state.Fragment, {
+                children: result || void 0
+            },
+            void 0
+        );
     }
 
-    function computeAutoPlacement$1(state, options) {
-        if (options === void 0) {
-            options = {};
+    function one$4(state, node2, key) {
+        if (node2.type === "element") {
+            return element$4(state, node2, key);
         }
-        var _options = options,
-            placement = _options.placement,
-            boundary = _options.boundary,
-            rootBoundary = _options.rootBoundary,
-            padding = _options.padding,
-            flipVariations = _options.flipVariations,
-            _options$allowedAutoP = _options.allowedAutoPlacements,
-            allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements$1 : _options$allowedAutoP;
-        var variation = getVariation$1(placement);
-        var placements2 = variation ? flipVariations ? variationPlacements$1 : variationPlacements$1.filter(function(placement2) {
-            return getVariation$1(placement2) === variation;
-        }) : basePlacements$1;
-        var allowedPlacements = placements2.filter(function(placement2) {
-            return allowedAutoPlacements.indexOf(placement2) >= 0;
-        });
-        if (allowedPlacements.length === 0) {
-            allowedPlacements = placements2;
+        if (node2.type === "mdxFlowExpression" || node2.type === "mdxTextExpression") {
+            return mdxExpression(state, node2);
         }
-        var overflows = allowedPlacements.reduce(function(acc, placement2) {
-            acc[placement2] = detectOverflow$1(state, {
-                placement: placement2,
-                boundary,
-                rootBoundary,
-                padding
-            })[getBasePlacement$3(placement2)];
-            return acc;
-        }, {});
-        return Object.keys(overflows).sort(function(a2, b2) {
-            return overflows[a2] - overflows[b2];
-        });
-    }
-
-    function getExpandedFallbackPlacements$1(placement) {
-        if (getBasePlacement$3(placement) === auto$1) {
-            return [];
+        if (node2.type === "mdxJsxFlowElement" || node2.type === "mdxJsxTextElement") {
+            return mdxJsxElement(state, node2, key);
+        }
+        if (node2.type === "mdxjsEsm") {
+            return mdxEsm(state, node2);
+        }
+        if (node2.type === "root") {
+            return root$5(state, node2, key);
+        }
+        if (node2.type === "text") {
+            return text$6(state, node2);
         }
-        var oppositePlacement = getOppositePlacement$1(placement);
-        return [getOppositeVariationPlacement$1(placement), oppositePlacement, getOppositeVariationPlacement$1(oppositePlacement)];
     }
 
-    function flip$2(_ref2) {
-        var state = _ref2.state,
-            options = _ref2.options,
-            name2 = _ref2.name;
-        if (state.modifiersData[name2]._skip) {
-            return;
+    function element$4(state, node2, key) {
+        const parentSchema = state.schema;
+        let schema = parentSchema;
+        if (node2.tagName.toLowerCase() === "svg" && parentSchema.space === "html") {
+            schema = svg;
+            state.schema = schema;
         }
-        var _options$mainAxis = options.mainAxis,
-            checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
-            _options$altAxis = options.altAxis,
-            checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
-            specifiedFallbackPlacements = options.fallbackPlacements,
-            padding = options.padding,
-            boundary = options.boundary,
-            rootBoundary = options.rootBoundary,
-            altBoundary = options.altBoundary,
-            _options$flipVariatio = options.flipVariations,
-            flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
-            allowedAutoPlacements = options.allowedAutoPlacements;
-        var preferredPlacement = state.options.placement;
-        var basePlacement = getBasePlacement$3(preferredPlacement);
-        var isBasePlacement = basePlacement === preferredPlacement;
-        var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement$1(preferredPlacement)] : getExpandedFallbackPlacements$1(preferredPlacement));
-        var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
-            return acc.concat(getBasePlacement$3(placement2) === auto$1 ? computeAutoPlacement$1(state, {
-                placement: placement2,
-                boundary,
-                rootBoundary,
-                padding,
-                flipVariations,
-                allowedAutoPlacements
-            }) : placement2);
-        }, []);
-        var referenceRect = state.rects.reference;
-        var popperRect = state.rects.popper;
-        var checksMap = /* @__PURE__ */ new Map();
-        var makeFallbackChecks = true;
-        var firstFittingPlacement = placements2[0];
-        for (var i2 = 0; i2 < placements2.length; i2++) {
-            var placement = placements2[i2];
-            var _basePlacement = getBasePlacement$3(placement);
-            var isStartVariation = getVariation$1(placement) === start$2;
-            var isVertical = [top$2, bottom$1].indexOf(_basePlacement) >= 0;
-            var len = isVertical ? "width" : "height";
-            var overflow = detectOverflow$1(state, {
-                placement,
-                boundary,
-                rootBoundary,
-                altBoundary,
-                padding
+        state.ancestors.push(node2);
+        const type2 = findComponentFromName(state, node2.tagName, false);
+        const props = createElementProps(state, node2);
+        let children2 = createChildren(state, node2);
+        if (tableElements.has(node2.tagName)) {
+            children2 = children2.filter(function(child) {
+                return typeof child === "string" ? !whitespace(child) : true;
             });
-            var mainVariationSide = isVertical ? isStartVariation ? right$1 : left$1 : isStartVariation ? bottom$1 : top$2;
-            if (referenceRect[len] > popperRect[len]) {
-                mainVariationSide = getOppositePlacement$1(mainVariationSide);
-            }
-            var altVariationSide = getOppositePlacement$1(mainVariationSide);
-            var checks2 = [];
-            if (checkMainAxis) {
-                checks2.push(overflow[_basePlacement] <= 0);
-            }
-            if (checkAltAxis) {
-                checks2.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
-            }
-            if (checks2.every(function(check) {
-                    return check;
-                })) {
-                firstFittingPlacement = placement;
-                makeFallbackChecks = false;
-                break;
-            }
-            checksMap.set(placement, checks2);
-        }
-        if (makeFallbackChecks) {
-            var numberOfChecks = flipVariations ? 3 : 1;
-            var _loop = function _loop2(_i3) {
-                var fittingPlacement = placements2.find(function(placement2) {
-                    var checks3 = checksMap.get(placement2);
-                    if (checks3) {
-                        return checks3.slice(0, _i3).every(function(check) {
-                            return check;
-                        });
-                    }
-                });
-                if (fittingPlacement) {
-                    firstFittingPlacement = fittingPlacement;
-                    return "break";
-                }
-            };
-            for (var _i2 = numberOfChecks; _i2 > 0; _i2--) {
-                var _ret = _loop(_i2);
-                if (_ret === "break")
-                    break;
-            }
-        }
-        if (state.placement !== firstFittingPlacement) {
-            state.modifiersData[name2]._skip = true;
-            state.placement = firstFittingPlacement;
-            state.reset = true;
         }
+        addNode$1(state, props, type2, node2);
+        addChildren$1(props, children2);
+        state.ancestors.pop();
+        state.schema = parentSchema;
+        return state.create(node2, type2, props, key);
     }
-    const flip$3 = {
-        name: "flip",
-        enabled: true,
-        phase: "main",
-        fn: flip$2,
-        requiresIfExists: ["offset"],
-        data: {
-            _skip: false
+
+    function mdxExpression(state, node2) {
+        if (node2.data && node2.data.estree && state.evaluater) {
+            const program = node2.data.estree;
+            const expression = program.body[0];
+            ok$2(expression.type === "ExpressionStatement");
+            return state.evaluater.evaluateExpression(expression.expression);
         }
-    };
+        crashEstree(state, node2.position);
+    }
 
-    function getSideOffsets$1(overflow, rect, preventedOffsets) {
-        if (preventedOffsets === void 0) {
-            preventedOffsets = {
-                x: 0,
-                y: 0
-            };
+    function mdxEsm(state, node2) {
+        if (node2.data && node2.data.estree && state.evaluater) {
+            return state.evaluater.evaluateProgram(node2.data.estree);
         }
-        return {
-            top: overflow.top - rect.height - preventedOffsets.y,
-            right: overflow.right - rect.width + preventedOffsets.x,
-            bottom: overflow.bottom - rect.height + preventedOffsets.y,
-            left: overflow.left - rect.width - preventedOffsets.x
-        };
+        crashEstree(state, node2.position);
     }
 
-    function isAnySideFullyClipped$1(overflow) {
-        return [top$2, right$1, bottom$1, left$1].some(function(side) {
-            return overflow[side] >= 0;
-        });
+    function mdxJsxElement(state, node2, key) {
+        const parentSchema = state.schema;
+        let schema = parentSchema;
+        if (node2.name === "svg" && parentSchema.space === "html") {
+            schema = svg;
+            state.schema = schema;
+        }
+        state.ancestors.push(node2);
+        const type2 = node2.name === null ? state.Fragment : findComponentFromName(state, node2.name, true);
+        const props = createJsxElementProps(state, node2);
+        const children2 = createChildren(state, node2);
+        addNode$1(state, props, type2, node2);
+        addChildren$1(props, children2);
+        state.ancestors.pop();
+        state.schema = parentSchema;
+        return state.create(node2, type2, props, key);
     }
 
-    function hide$2(_ref2) {
-        var state = _ref2.state,
-            name2 = _ref2.name;
-        var referenceRect = state.rects.reference;
-        var popperRect = state.rects.popper;
-        var preventedOffsets = state.modifiersData.preventOverflow;
-        var referenceOverflow = detectOverflow$1(state, {
-            elementContext: "reference"
-        });
-        var popperAltOverflow = detectOverflow$1(state, {
-            altBoundary: true
-        });
-        var referenceClippingOffsets = getSideOffsets$1(referenceOverflow, referenceRect);
-        var popperEscapeOffsets = getSideOffsets$1(popperAltOverflow, popperRect, preventedOffsets);
-        var isReferenceHidden = isAnySideFullyClipped$1(referenceClippingOffsets);
-        var hasPopperEscaped = isAnySideFullyClipped$1(popperEscapeOffsets);
-        state.modifiersData[name2] = {
-            referenceClippingOffsets,
-            popperEscapeOffsets,
-            isReferenceHidden,
-            hasPopperEscaped
-        };
-        state.attributes.popper = Object.assign({}, state.attributes.popper, {
-            "data-popper-reference-hidden": isReferenceHidden,
-            "data-popper-escaped": hasPopperEscaped
-        });
+    function root$5(state, node2, key) {
+        const props = {};
+        addChildren$1(props, createChildren(state, node2));
+        return state.create(node2, state.Fragment, props, key);
     }
-    const hide$3 = {
-        name: "hide",
-        enabled: true,
-        phase: "main",
-        requiresIfExists: ["preventOverflow"],
-        fn: hide$2
-    };
 
-    function distanceAndSkiddingToXY$1(placement, rects, offset2) {
-        var basePlacement = getBasePlacement$3(placement);
-        var invertDistance = [left$1, top$2].indexOf(basePlacement) >= 0 ? -1 : 1;
-        var _ref2 = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
-                placement
-            })) : offset2,
-            skidding = _ref2[0],
-            distance = _ref2[1];
-        skidding = skidding || 0;
-        distance = (distance || 0) * invertDistance;
-        return [left$1, right$1].indexOf(basePlacement) >= 0 ? {
-            x: distance,
-            y: skidding
-        } : {
-            x: skidding,
-            y: distance
-        };
+    function text$6(_2, node2) {
+        return node2.value;
     }
 
-    function offset$2(_ref2) {
-        var state = _ref2.state,
-            options = _ref2.options,
-            name2 = _ref2.name;
-        var _options$offset = options.offset,
-            offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
-        var data2 = placements$1.reduce(function(acc, placement) {
-            acc[placement] = distanceAndSkiddingToXY$1(placement, state.rects, offset2);
-            return acc;
-        }, {});
-        var _data$state$placement = data2[state.placement],
-            x2 = _data$state$placement.x,
-            y2 = _data$state$placement.y;
-        if (state.modifiersData.popperOffsets != null) {
-            state.modifiersData.popperOffsets.x += x2;
-            state.modifiersData.popperOffsets.y += y2;
+    function addNode$1(state, props, type2, node2) {
+        if (typeof type2 !== "string" && type2 !== state.Fragment && state.passNode) {
+            props.node = node2;
         }
-        state.modifiersData[name2] = data2;
     }
-    const offset$3 = {
-        name: "offset",
-        enabled: true,
-        phase: "main",
-        requires: ["popperOffsets"],
-        fn: offset$2
-    };
 
-    function popperOffsets$2(_ref2) {
-        var state = _ref2.state,
-            name2 = _ref2.name;
-        state.modifiersData[name2] = computeOffsets$1({
-            reference: state.rects.reference,
-            element: state.rects.popper,
-            strategy: "absolute",
-            placement: state.placement
-        });
+    function addChildren$1(props, children2) {
+        if (children2.length > 0) {
+            const value = children2.length > 1 ? children2 : children2[0];
+            if (value) {
+                props.children = value;
+            }
+        }
     }
-    const popperOffsets$3 = {
-        name: "popperOffsets",
-        enabled: true,
-        phase: "read",
-        fn: popperOffsets$2,
-        data: {}
-    };
 
-    function getAltAxis$1(axis) {
-        return axis === "x" ? "y" : "x";
-    }
+    function productionCreate(_2, jsx, jsxs) {
+        return create2;
 
-    function preventOverflow$2(_ref2) {
-        var state = _ref2.state,
-            options = _ref2.options,
-            name2 = _ref2.name;
-        var _options$mainAxis = options.mainAxis,
-            checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
-            _options$altAxis = options.altAxis,
-            checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
-            boundary = options.boundary,
-            rootBoundary = options.rootBoundary,
-            altBoundary = options.altBoundary,
-            padding = options.padding,
-            _options$tether = options.tether,
-            tether = _options$tether === void 0 ? true : _options$tether,
-            _options$tetherOffset = options.tetherOffset,
-            tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
-        var overflow = detectOverflow$1(state, {
-            boundary,
-            rootBoundary,
-            padding,
-            altBoundary
-        });
-        var basePlacement = getBasePlacement$3(state.placement);
-        var variation = getVariation$1(state.placement);
-        var isBasePlacement = !variation;
-        var mainAxis = getMainAxisFromPlacement$1(basePlacement);
-        var altAxis = getAltAxis$1(mainAxis);
-        var popperOffsets2 = state.modifiersData.popperOffsets;
-        var referenceRect = state.rects.reference;
-        var popperRect = state.rects.popper;
-        var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
-            placement: state.placement
-        })) : tetherOffset;
-        var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
-            mainAxis: tetherOffsetValue,
-            altAxis: tetherOffsetValue
-        } : Object.assign({
-            mainAxis: 0,
-            altAxis: 0
-        }, tetherOffsetValue);
-        var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
-        var data2 = {
-            x: 0,
-            y: 0
-        };
-        if (!popperOffsets2) {
-            return;
-        }
-        if (checkMainAxis) {
-            var _offsetModifierState$;
-            var mainSide = mainAxis === "y" ? top$2 : left$1;
-            var altSide = mainAxis === "y" ? bottom$1 : right$1;
-            var len = mainAxis === "y" ? "height" : "width";
-            var offset2 = popperOffsets2[mainAxis];
-            var min2 = offset2 + overflow[mainSide];
-            var max2 = offset2 - overflow[altSide];
-            var additive = tether ? -popperRect[len] / 2 : 0;
-            var minLen = variation === start$2 ? referenceRect[len] : popperRect[len];
-            var maxLen = variation === start$2 ? -popperRect[len] : -referenceRect[len];
-            var arrowElement = state.elements.arrow;
-            var arrowRect = tether && arrowElement ? getLayoutRect$1(arrowElement) : {
-                width: 0,
-                height: 0
-            };
-            var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject$1();
-            var arrowPaddingMin = arrowPaddingObject[mainSide];
-            var arrowPaddingMax = arrowPaddingObject[altSide];
-            var arrowLen = within$1(0, referenceRect[len], arrowRect[len]);
-            var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
-            var maxOffset2 = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
-            var arrowOffsetParent = state.elements.arrow && getOffsetParent$1(state.elements.arrow);
-            var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
-            var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
-            var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
-            var tetherMax = offset2 + maxOffset2 - offsetModifierValue;
-            var preventedOffset = within$1(tether ? min$2(min2, tetherMin) : min2, offset2, tether ? max$3(max2, tetherMax) : max2);
-            popperOffsets2[mainAxis] = preventedOffset;
-            data2[mainAxis] = preventedOffset - offset2;
-        }
-        if (checkAltAxis) {
-            var _offsetModifierState$2;
-            var _mainSide = mainAxis === "x" ? top$2 : left$1;
-            var _altSide = mainAxis === "x" ? bottom$1 : right$1;
-            var _offset = popperOffsets2[altAxis];
-            var _len = altAxis === "y" ? "height" : "width";
-            var _min = _offset + overflow[_mainSide];
-            var _max = _offset - overflow[_altSide];
-            var isOriginSide = [top$2, left$1].indexOf(basePlacement) !== -1;
-            var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
-            var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
-            var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
-            var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within$1(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
-            popperOffsets2[altAxis] = _preventedOffset;
-            data2[altAxis] = _preventedOffset - _offset;
+        function create2(_3, type2, props, key) {
+            const isStaticChildren = Array.isArray(props.children);
+            const fn2 = isStaticChildren ? jsxs : jsx;
+            return key ? fn2(type2, props, key) : fn2(type2, props);
         }
-        state.modifiersData[name2] = data2;
     }
-    const preventOverflow$3 = {
-        name: "preventOverflow",
-        enabled: true,
-        phase: "main",
-        fn: preventOverflow$2,
-        requiresIfExists: ["offset"]
-    };
 
-    function getHTMLElementScroll$1(element2) {
-        return {
-            scrollLeft: element2.scrollLeft,
-            scrollTop: element2.scrollTop
-        };
-    }
+    function developmentCreate(filePath, jsxDEV) {
+        return create2;
 
-    function getNodeScroll$1(node2) {
-        if (node2 === getWindow$1(node2) || !isHTMLElement$1(node2)) {
-            return getWindowScroll$1(node2);
-        } else {
-            return getHTMLElementScroll$1(node2);
+        function create2(node2, type2, props, key) {
+            const isStaticChildren = Array.isArray(props.children);
+            const point2 = pointStart$1(node2);
+            return jsxDEV(
+                type2,
+                props,
+                key,
+                isStaticChildren, {
+                    columnNumber: point2 ? point2.column - 1 : void 0,
+                    fileName: filePath,
+                    lineNumber: point2 ? point2.line : void 0
+                },
+                void 0
+            );
         }
     }
 
-    function isElementScaled(element2) {
-        var rect = element2.getBoundingClientRect();
-        var scaleX = round$2(rect.width) / element2.offsetWidth || 1;
-        var scaleY = round$2(rect.height) / element2.offsetHeight || 1;
-        return scaleX !== 1 || scaleY !== 1;
-    }
-
-    function getCompositeRect$1(elementOrVirtualElement, offsetParent, isFixed) {
-        if (isFixed === void 0) {
-            isFixed = false;
-        }
-        var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
-        var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
-        var documentElement = getDocumentElement$1(offsetParent);
-        var rect = getBoundingClientRect$1(elementOrVirtualElement, offsetParentIsScaled, isFixed);
-        var scroll = {
-            scrollLeft: 0,
-            scrollTop: 0
-        };
-        var offsets = {
-            x: 0,
-            y: 0
-        };
-        if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
-            if (getNodeName$1(offsetParent) !== "body" || isScrollParent$1(documentElement)) {
-                scroll = getNodeScroll$1(offsetParent);
-            }
-            if (isHTMLElement$1(offsetParent)) {
-                offsets = getBoundingClientRect$1(offsetParent, true);
-                offsets.x += offsetParent.clientLeft;
-                offsets.y += offsetParent.clientTop;
-            } else if (documentElement) {
-                offsets.x = getWindowScrollBarX$1(documentElement);
+    function createElementProps(state, node2) {
+        const props = {};
+        let alignValue;
+        let prop;
+        for (prop in node2.properties) {
+            if (prop !== "children" && own$7.call(node2.properties, prop)) {
+                const result = createProperty$1(state, prop, node2.properties[prop]);
+                if (result) {
+                    const [key, value] = result;
+                    if (state.tableCellAlignToStyle && key === "align" && typeof value === "string" && tableCellElement.has(node2.tagName)) {
+                        alignValue = value;
+                    } else {
+                        props[key] = value;
+                    }
+                }
             }
         }
-        return {
-            x: rect.left + scroll.scrollLeft - offsets.x,
-            y: rect.top + scroll.scrollTop - offsets.y,
-            width: rect.width,
-            height: rect.height
-        };
+        if (alignValue) {
+            const style2 = props.style || (props.style = {});
+            style2[state.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = alignValue;
+        }
+        return props;
     }
 
-    function order$2(modifiers2) {
-        var map2 = /* @__PURE__ */ new Map();
-        var visited = /* @__PURE__ */ new Set();
-        var result = [];
-        modifiers2.forEach(function(modifier) {
-            map2.set(modifier.name, modifier);
-        });
-
-        function sort(modifier) {
-            visited.add(modifier.name);
-            var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
-            requires.forEach(function(dep) {
-                if (!visited.has(dep)) {
-                    var depModifier = map2.get(dep);
-                    if (depModifier) {
-                        sort(depModifier);
+    function createJsxElementProps(state, node2) {
+        const props = {};
+        for (const attribute of node2.attributes) {
+            if (attribute.type === "mdxJsxExpressionAttribute") {
+                if (attribute.data && attribute.data.estree && state.evaluater) {
+                    const program = attribute.data.estree;
+                    const expression = program.body[0];
+                    ok$2(expression.type === "ExpressionStatement");
+                    const objectExpression = expression.expression;
+                    ok$2(objectExpression.type === "ObjectExpression");
+                    const property = objectExpression.properties[0];
+                    ok$2(property.type === "SpreadElement");
+                    Object.assign(
+                        props,
+                        state.evaluater.evaluateExpression(property.argument)
+                    );
+                } else {
+                    crashEstree(state, node2.position);
+                }
+            } else {
+                const name2 = attribute.name;
+                let value;
+                if (attribute.value && typeof attribute.value === "object") {
+                    if (attribute.value.data && attribute.value.data.estree && state.evaluater) {
+                        const program = attribute.value.data.estree;
+                        const expression = program.body[0];
+                        ok$2(expression.type === "ExpressionStatement");
+                        value = state.evaluater.evaluateExpression(expression.expression);
+                    } else {
+                        crashEstree(state, node2.position);
                     }
+                } else {
+                    value = attribute.value === null ? true : attribute.value;
                 }
-            });
-            result.push(modifier);
-        }
-        modifiers2.forEach(function(modifier) {
-            if (!visited.has(modifier.name)) {
-                sort(modifier);
+                props[name2] = value;
             }
-        });
-        return result;
-    }
-
-    function orderModifiers$1(modifiers2) {
-        var orderedModifiers = order$2(modifiers2);
-        return modifierPhases$1.reduce(function(acc, phase) {
-            return acc.concat(orderedModifiers.filter(function(modifier) {
-                return modifier.phase === phase;
-            }));
-        }, []);
+        }
+        return props;
     }
 
-    function debounce$5(fn2) {
-        var pending;
-        return function() {
-            if (!pending) {
-                pending = new Promise(function(resolve2) {
-                    Promise.resolve().then(function() {
-                        pending = void 0;
-                        resolve2(fn2());
-                    });
-                });
+    function createChildren(state, node2) {
+        const children2 = [];
+        let index2 = -1;
+        const countsByName = state.passKeys ? /* @__PURE__ */ new Map() : emptyMap;
+        while (++index2 < node2.children.length) {
+            const child = node2.children[index2];
+            let key;
+            if (state.passKeys) {
+                const name2 = child.type === "element" ? child.tagName : child.type === "mdxJsxFlowElement" || child.type === "mdxJsxTextElement" ? child.name : void 0;
+                if (name2) {
+                    const count2 = countsByName.get(name2) || 0;
+                    key = name2 + "-" + count2;
+                    countsByName.set(name2, count2 + 1);
+                }
             }
-            return pending;
-        };
-    }
-
-    function mergeByName$1(modifiers2) {
-        var merged = modifiers2.reduce(function(merged2, current2) {
-            var existing = merged2[current2.name];
-            merged2[current2.name] = existing ? Object.assign({}, existing, current2, {
-                options: Object.assign({}, existing.options, current2.options),
-                data: Object.assign({}, existing.data, current2.data)
-            }) : current2;
-            return merged2;
-        }, {});
-        return Object.keys(merged).map(function(key) {
-            return merged[key];
-        });
-    }
-    var DEFAULT_OPTIONS$2 = {
-        placement: "bottom",
-        modifiers: [],
-        strategy: "absolute"
-    };
-
-    function areValidElements$1() {
-        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-            args[_key] = arguments[_key];
+            const result = one$4(state, child, key);
+            if (result !== void 0)
+                children2.push(result);
         }
-        return !args.some(function(element2) {
-            return !(element2 && typeof element2.getBoundingClientRect === "function");
-        });
+        return children2;
     }
 
-    function popperGenerator$1(generatorOptions) {
-        if (generatorOptions === void 0) {
-            generatorOptions = {};
+    function createProperty$1(state, prop, value) {
+        const info = find$3(state.schema, prop);
+        if (value === null || value === void 0 || typeof value === "number" && Number.isNaN(value)) {
+            return;
         }
-        var _generatorOptions = generatorOptions,
-            _generatorOptions$def = _generatorOptions.defaultModifiers,
-            defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
-            _generatorOptions$def2 = _generatorOptions.defaultOptions,
-            defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS$2 : _generatorOptions$def2;
-        return function createPopper2(reference2, popper2, options) {
-            if (options === void 0) {
-                options = defaultOptions2;
-            }
-            var state = {
-                placement: "bottom",
-                orderedModifiers: [],
-                options: Object.assign({}, DEFAULT_OPTIONS$2, defaultOptions2),
-                modifiersData: {},
-                elements: {
-                    reference: reference2,
-                    popper: popper2
-                },
-                attributes: {},
-                styles: {}
-            };
-            var effectCleanupFns = [];
-            var isDestroyed = false;
-            var instance2 = {
-                state,
-                setOptions: function setOptions2(setOptionsAction) {
-                    var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
-                    cleanupModifierEffects();
-                    state.options = Object.assign({}, defaultOptions2, state.options, options2);
-                    state.scrollParents = {
-                        reference: isElement$4(reference2) ? listScrollParents$1(reference2) : reference2.contextElement ? listScrollParents$1(reference2.contextElement) : [],
-                        popper: listScrollParents$1(popper2)
-                    };
-                    var orderedModifiers = orderModifiers$1(mergeByName$1([].concat(defaultModifiers2, state.options.modifiers)));
-                    state.orderedModifiers = orderedModifiers.filter(function(m2) {
-                        return m2.enabled;
-                    });
-                    runModifierEffects();
-                    return instance2.update();
-                },
-                forceUpdate: function forceUpdate() {
-                    if (isDestroyed) {
-                        return;
-                    }
-                    var _state$elements = state.elements,
-                        reference3 = _state$elements.reference,
-                        popper3 = _state$elements.popper;
-                    if (!areValidElements$1(reference3, popper3)) {
-                        return;
-                    }
-                    state.rects = {
-                        reference: getCompositeRect$1(reference3, getOffsetParent$1(popper3), state.options.strategy === "fixed"),
-                        popper: getLayoutRect$1(popper3)
-                    };
-                    state.reset = false;
-                    state.placement = state.options.placement;
-                    state.orderedModifiers.forEach(function(modifier) {
-                        return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
-                    });
-                    for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
-                        if (state.reset === true) {
-                            state.reset = false;
-                            index2 = -1;
-                            continue;
-                        }
-                        var _state$orderedModifie = state.orderedModifiers[index2],
-                            fn2 = _state$orderedModifie.fn,
-                            _state$orderedModifie2 = _state$orderedModifie.options,
-                            _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
-                            name2 = _state$orderedModifie.name;
-                        if (typeof fn2 === "function") {
-                            state = fn2({
-                                state,
-                                options: _options,
-                                name: name2,
-                                instance: instance2
-                            }) || state;
-                        }
-                    }
-                },
-                update: debounce$5(function() {
-                    return new Promise(function(resolve2) {
-                        instance2.forceUpdate();
-                        resolve2(state);
-                    });
-                }),
-                destroy: function destroy() {
-                    cleanupModifierEffects();
-                    isDestroyed = true;
-                }
-            };
-            if (!areValidElements$1(reference2, popper2)) {
-                return instance2;
+        if (Array.isArray(value)) {
+            value = info.commaSeparated ? stringify$3(value) : stringify$2(value);
+        }
+        if (info.property === "style") {
+            let styleObject = typeof value === "object" ? value : parseStyle(state, String(value));
+            if (state.stylePropertyNameCase === "css") {
+                styleObject = transformStylesToCssCasing(styleObject);
             }
-            instance2.setOptions(options).then(function(state2) {
-                if (!isDestroyed && options.onFirstUpdate) {
-                    options.onFirstUpdate(state2);
-                }
-            });
+            return ["style", styleObject];
+        }
+        return [
+            state.elementAttributeNameCase === "react" && info.space ? hastToReact[info.property] || info.property : info.attribute,
+            value
+        ];
+    }
 
-            function runModifierEffects() {
-                state.orderedModifiers.forEach(function(_ref2) {
-                    var name2 = _ref2.name,
-                        _ref$options = _ref2.options,
-                        options2 = _ref$options === void 0 ? {} : _ref$options,
-                        effect2 = _ref2.effect;
-                    if (typeof effect2 === "function") {
-                        var cleanupFn = effect2({
-                            state,
-                            name: name2,
-                            instance: instance2,
-                            options: options2
-                        });
-                        var noopFn = function noopFn2() {};
-                        effectCleanupFns.push(cleanupFn || noopFn);
-                    }
+    function parseStyle(state, value) {
+        const result = {};
+        try {
+            styleToObject(value, replacer);
+        } catch (error2) {
+            if (!state.ignoreInvalidStyle) {
+                const cause = error2;
+                const message = new VFileMessage("Cannot parse `style` attribute", {
+                    ancestors: state.ancestors,
+                    cause,
+                    ruleId: "style",
+                    source: "hast-util-to-jsx-runtime"
                 });
+                message.file = state.filePath || void 0;
+                message.url = docs + "#cannot-parse-style-attribute";
+                throw message;
             }
+        }
+        return result;
 
-            function cleanupModifierEffects() {
-                effectCleanupFns.forEach(function(fn2) {
-                    return fn2();
-                });
-                effectCleanupFns = [];
+        function replacer(name2, value2) {
+            let key = name2;
+            if (key.slice(0, 2) !== "--") {
+                if (key.slice(0, 4) === "-ms-")
+                    key = "ms-" + key.slice(4);
+                key = key.replace(dashSomething, toCamel);
             }
-            return instance2;
-        };
-    }
-    var defaultModifiers$1 = [eventListeners$1, popperOffsets$3, computeStyles$3, applyStyles$3, offset$3, flip$3, preventOverflow$3, arrow$3, hide$3];
-    var createPopper$1 = /* @__PURE__ */ popperGenerator$1({
-        defaultModifiers: defaultModifiers$1
-    });
-    var CONTENT_CLASS$1 = "tippy-content";
-    var BACKDROP_CLASS$1 = "tippy-backdrop";
-    var ARROW_CLASS$1 = "tippy-arrow";
-    var SVG_ARROW_CLASS$1 = "tippy-svg-arrow";
-    var TOUCH_OPTIONS$1 = {
-        passive: true,
-        capture: true
-    };
-
-    function getValueAtIndexOrReturn$1(value, index2, defaultValue2) {
-        if (Array.isArray(value)) {
-            var v2 = value[index2];
-            return v2 == null ? Array.isArray(defaultValue2) ? defaultValue2[index2] : defaultValue2 : v2;
+            result[key] = value2;
         }
-        return value;
-    }
-
-    function isType$1(value, type2) {
-        var str = {}.toString.call(value);
-        return str.indexOf("[object") === 0 && str.indexOf(type2 + "]") > -1;
-    }
-
-    function invokeWithArgsOrReturn$1(value, args) {
-        return typeof value === "function" ? value.apply(void 0, args) : value;
     }
 
-    function debounce$4(fn2, ms2) {
-        if (ms2 === 0) {
-            return fn2;
+    function findComponentFromName(state, name2, allowExpression) {
+        let result;
+        if (!allowExpression) {
+            result = {
+                type: "Literal",
+                value: name2
+            };
+        } else if (name2.includes(".")) {
+            const identifiers = name2.split(".");
+            let index2 = -1;
+            let node2;
+            while (++index2 < identifiers.length) {
+                const prop = name$2(identifiers[index2]) ? {
+                    type: "Identifier",
+                    name: identifiers[index2]
+                } : {
+                    type: "Literal",
+                    value: identifiers[index2]
+                };
+                node2 = node2 ? {
+                    type: "MemberExpression",
+                    object: node2,
+                    property: prop,
+                    computed: Boolean(index2 && prop.type === "Literal"),
+                    optional: false
+                } : prop;
+            }
+            result = node2;
+        } else {
+            result = name$2(name2) && !/^[a-z]/.test(name2) ? {
+                type: "Identifier",
+                name: name2
+            } : {
+                type: "Literal",
+                value: name2
+            };
         }
-        var timeout2;
-        return function(arg) {
-            clearTimeout(timeout2);
-            timeout2 = setTimeout(function() {
-                fn2(arg);
-            }, ms2);
-        };
-    }
-
-    function splitBySpaces$1(value) {
-        return value.split(/\s+/).filter(Boolean);
-    }
-
-    function normalizeToArray$1(value) {
-        return [].concat(value);
-    }
-
-    function pushIfUnique$1(arr, value) {
-        if (arr.indexOf(value) === -1) {
-            arr.push(value);
+        if (result.type === "Literal") {
+            const name3 = result.value;
+            return own$7.call(state.components, name3) ? state.components[name3] : name3;
         }
+        if (state.evaluater) {
+            return state.evaluater.evaluateExpression(result);
+        }
+        crashEstree(state);
     }
 
-    function unique$1(arr) {
-        return arr.filter(function(item, index2) {
-            return arr.indexOf(item) === index2;
-        });
-    }
-
-    function getBasePlacement$2(placement) {
-        return placement.split("-")[0];
-    }
-
-    function arrayFrom$1(value) {
-        return [].slice.call(value);
-    }
-
-    function removeUndefinedProps$1(obj) {
-        return Object.keys(obj).reduce(function(acc, key) {
-            if (obj[key] !== void 0) {
-                acc[key] = obj[key];
+    function crashEstree(state, place2) {
+        const message = new VFileMessage(
+            "Cannot handle MDX estrees without `createEvaluater`", {
+                ancestors: state.ancestors,
+                place: place2,
+                ruleId: "mdx-estree",
+                source: "hast-util-to-jsx-runtime"
             }
-            return acc;
-        }, {});
+        );
+        message.file = state.filePath || void 0;
+        message.url = docs + "#cannot-handle-mdx-estrees-without-createevaluater";
+        throw message;
     }
 
-    function div$1() {
-        return document.createElement("div");
+    function transformStylesToCssCasing(domCasing) {
+        const cssCasing = {};
+        let from;
+        for (from in domCasing) {
+            if (own$7.call(domCasing, from)) {
+                cssCasing[transformStyleToCssCasing(from)] = domCasing[from];
+            }
+        }
+        return cssCasing;
     }
 
-    function isElement$3(value) {
-        return ["Element", "Fragment"].some(function(type2) {
-            return isType$1(value, type2);
-        });
+    function transformStyleToCssCasing(from) {
+        let to2 = from.replace(cap, toDash);
+        if (to2.slice(0, 3) === "ms-")
+            to2 = "-" + to2;
+        return to2;
     }
 
-    function isNodeList$2(value) {
-        return isType$1(value, "NodeList");
+    function toCamel(_2, $1) {
+        return $1.toUpperCase();
     }
 
-    function isMouseEvent$1(value) {
-        return isType$1(value, "MouseEvent");
+    function toDash($0) {
+        return "-" + $0.toLowerCase();
     }
+    const urlAttributes = {
+        action: ["form"],
+        cite: ["blockquote", "del", "ins", "q"],
+        data: ["object"],
+        formAction: ["button", "input"],
+        href: ["a", "area", "base", "link"],
+        icon: ["menuitem"],
+        itemId: null,
+        manifest: ["html"],
+        ping: ["a", "area"],
+        poster: ["video"],
+        src: [
+            "audio",
+            "embed",
+            "iframe",
+            "img",
+            "input",
+            "script",
+            "source",
+            "track",
+            "video"
+        ]
+    };
+    const emptyOptions$2 = {};
 
-    function isReferenceElement$1(value) {
-        return !!(value && value._tippy && value._tippy.reference === value);
+    function toString$6(value, options) {
+        const settings2 = options || emptyOptions$2;
+        const includeImageAlt = typeof settings2.includeImageAlt === "boolean" ? settings2.includeImageAlt : true;
+        const includeHtml = typeof settings2.includeHtml === "boolean" ? settings2.includeHtml : true;
+        return one$3(value, includeImageAlt, includeHtml);
     }
 
-    function getArrayOfElements$1(value) {
-        if (isElement$3(value)) {
-            return [value];
-        }
-        if (isNodeList$2(value)) {
-            return arrayFrom$1(value);
+    function one$3(value, includeImageAlt, includeHtml) {
+        if (node(value)) {
+            if ("value" in value) {
+                return value.type === "html" && !includeHtml ? "" : value.value;
+            }
+            if (includeImageAlt && "alt" in value && value.alt) {
+                return value.alt;
+            }
+            if ("children" in value) {
+                return all$2(value.children, includeImageAlt, includeHtml);
+            }
         }
         if (Array.isArray(value)) {
-            return value;
+            return all$2(value, includeImageAlt, includeHtml);
         }
-        return arrayFrom$1(document.querySelectorAll(value));
+        return "";
     }
 
-    function setTransitionDuration$1(els, value) {
-        els.forEach(function(el) {
-            if (el) {
-                el.style.transitionDuration = value + "ms";
-            }
-        });
+    function all$2(values, includeImageAlt, includeHtml) {
+        const result = [];
+        let index2 = -1;
+        while (++index2 < values.length) {
+            result[index2] = one$3(values[index2], includeImageAlt, includeHtml);
+        }
+        return result.join("");
     }
 
-    function setVisibilityState$1(els, state) {
-        els.forEach(function(el) {
-            if (el) {
-                el.setAttribute("data-state", state);
-            }
-        });
+    function node(value) {
+        return Boolean(value && typeof value === "object");
     }
+    const element$3 = document.createElement("i");
 
-    function getOwnerDocument$1(elementOrElements) {
-        var _normalizeToArray = normalizeToArray$1(elementOrElements),
-            element2 = _normalizeToArray[0];
-        return element2 ? element2.ownerDocument || document : document;
+    function decodeNamedCharacterReference(value) {
+        const characterReference2 = "&" + value + ";";
+        element$3.innerHTML = characterReference2;
+        const char = element$3.textContent;
+        if (char.charCodeAt(char.length - 1) === 59 && value !== "semi") {
+            return false;
+        }
+        return char === characterReference2 ? false : char;
     }
 
-    function isCursorOutsideInteractiveBorder$1(popperTreeData, event2) {
-        var clientX = event2.clientX,
-            clientY = event2.clientY;
-        return popperTreeData.every(function(_ref2) {
-            var popperRect = _ref2.popperRect,
-                popperState = _ref2.popperState,
-                props = _ref2.props;
-            var interactiveBorder = props.interactiveBorder;
-            var basePlacement = getBasePlacement$2(popperState.placement);
-            var offsetData = popperState.modifiersData.offset;
-            if (!offsetData) {
-                return true;
+    function splice(list2, start2, remove2, items) {
+        const end2 = list2.length;
+        let chunkStart = 0;
+        let parameters;
+        if (start2 < 0) {
+            start2 = -start2 > end2 ? 0 : end2 + start2;
+        } else {
+            start2 = start2 > end2 ? end2 : start2;
+        }
+        remove2 = remove2 > 0 ? remove2 : 0;
+        if (items.length < 1e4) {
+            parameters = Array.from(items);
+            parameters.unshift(start2, remove2);
+            list2.splice(...parameters);
+        } else {
+            if (remove2)
+                list2.splice(start2, remove2);
+            while (chunkStart < items.length) {
+                parameters = items.slice(chunkStart, chunkStart + 1e4);
+                parameters.unshift(start2, 0);
+                list2.splice(...parameters);
+                chunkStart += 1e4;
+                start2 += 1e4;
             }
-            var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
-            var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
-            var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
-            var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
-            var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
-            var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
-            var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
-            var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
-            return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
-        });
+        }
     }
 
-    function updateTransitionEndListener$1(box, action, listener2) {
-        var method = action + "EventListener";
-        ["transitionend", "webkitTransitionEnd"].forEach(function(event2) {
-            box[method](event2, listener2);
-        });
+    function push$2(list2, items) {
+        if (list2.length > 0) {
+            splice(list2, list2.length, 0, items);
+            return list2;
+        }
+        return items;
     }
-    var currentInput$1 = {
-        isTouch: false
-    };
-    var lastMouseMoveTime$1 = 0;
+    const hasOwnProperty$5 = {}.hasOwnProperty;
 
-    function onDocumentTouchStart$1() {
-        if (currentInput$1.isTouch) {
-            return;
+    function combineExtensions(extensions2) {
+        const all2 = {};
+        let index2 = -1;
+        while (++index2 < extensions2.length) {
+            syntaxExtension(all2, extensions2[index2]);
         }
-        currentInput$1.isTouch = true;
-        if (window.performance) {
-            document.addEventListener("mousemove", onDocumentMouseMove$1);
+        return all2;
+    }
+
+    function syntaxExtension(all2, extension2) {
+        let hook;
+        for (hook in extension2) {
+            const maybe = hasOwnProperty$5.call(all2, hook) ? all2[hook] : void 0;
+            const left2 = maybe || (all2[hook] = {});
+            const right2 = extension2[hook];
+            let code2;
+            if (right2) {
+                for (code2 in right2) {
+                    if (!hasOwnProperty$5.call(left2, code2))
+                        left2[code2] = [];
+                    const value = right2[code2];
+                    constructs(
+                        left2[code2],
+                        Array.isArray(value) ? value : value ? [value] : []
+                    );
+                }
+            }
         }
     }
 
-    function onDocumentMouseMove$1() {
-        var now2 = performance.now();
-        if (now2 - lastMouseMoveTime$1 < 20) {
-            currentInput$1.isTouch = false;
-            document.removeEventListener("mousemove", onDocumentMouseMove$1);
+    function constructs(existing, list2) {
+        let index2 = -1;
+        const before = [];
+        while (++index2 < list2.length) {
+            (list2[index2].add === "after" ? existing : before).push(list2[index2]);
         }
-        lastMouseMoveTime$1 = now2;
+        splice(existing, 0, 0, before);
     }
 
-    function onWindowBlur$1() {
-        var activeElement = document.activeElement;
-        if (isReferenceElement$1(activeElement)) {
-            var instance2 = activeElement._tippy;
-            if (activeElement.blur && !instance2.state.isVisible) {
-                activeElement.blur();
-            }
+    function decodeNumericCharacterReference(value, base2) {
+        const code2 = Number.parseInt(value, base2);
+        if (code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || code2 > 126 && code2 < 160 || code2 > 55295 && code2 < 57344 || code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || code2 > 1114111) {
+            return "\uFFFD";
         }
+        return String.fromCodePoint(code2);
     }
 
-    function bindGlobalEventListeners$1() {
-        document.addEventListener("touchstart", onDocumentTouchStart$1, TOUCH_OPTIONS$1);
-        window.addEventListener("blur", onWindowBlur$1);
+    function normalizeIdentifier(value) {
+        return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
     }
-    var isBrowser$3 = typeof window !== "undefined" && typeof document !== "undefined";
-    var ua$1 = isBrowser$3 ? navigator.userAgent : "";
-    var isIE$1 = /MSIE |Trident\//.test(ua$1);
-    var pluginProps$1 = {
-        animateFill: false,
-        followCursor: false,
-        inlinePositioning: false,
-        sticky: false
-    };
-    var renderProps$1 = {
-        allowHTML: false,
-        animation: "fade",
-        arrow: true,
-        content: "",
-        inertia: false,
-        maxWidth: 350,
-        role: "tooltip",
-        theme: "",
-        zIndex: 9999
-    };
-    var defaultProps$6 = Object.assign({
-        appendTo: function appendTo() {
-            return document.body;
-        },
-        aria: {
-            content: "auto",
-            expanded: "auto"
-        },
-        delay: 0,
-        duration: [300, 250],
-        getReferenceClientRect: null,
-        hideOnClick: true,
-        ignoreAttributes: false,
-        interactive: false,
-        interactiveBorder: 2,
-        interactiveDebounce: 0,
-        moveTransition: "",
-        offset: [0, 10],
-        onAfterUpdate: function onAfterUpdate() {},
-        onBeforeUpdate: function onBeforeUpdate() {},
-        onCreate: function onCreate() {},
-        onDestroy: function onDestroy() {},
-        onHidden: function onHidden() {},
-        onHide: function onHide() {},
-        onMount: function onMount() {},
-        onShow: function onShow() {},
-        onShown: function onShown() {},
-        onTrigger: function onTrigger() {},
-        onUntrigger: function onUntrigger() {},
-        onClickOutside: function onClickOutside() {},
-        placement: "top",
-        plugins: [],
-        popperOptions: {},
-        render: null,
-        showOnCreate: false,
-        touch: true,
-        trigger: "mouseenter focus",
-        triggerTarget: null
-    }, pluginProps$1, {}, renderProps$1);
-    var defaultKeys$1 = Object.keys(defaultProps$6);
-    var setDefaultProps$1 = function setDefaultProps2(partialProps) {
-        var keys2 = Object.keys(partialProps);
-        keys2.forEach(function(key) {
-            defaultProps$6[key] = partialProps[key];
-        });
-    };
+    const asciiAlpha = regexCheck(/[A-Za-z]/);
+    const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
+    const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
 
-    function getExtendedPassedProps$1(passedProps) {
-        var plugins2 = passedProps.plugins || [];
-        var pluginProps2 = plugins2.reduce(function(acc, plugin) {
-            var name2 = plugin.name,
-                defaultValue2 = plugin.defaultValue;
-            if (name2) {
-                acc[name2] = passedProps[name2] !== void 0 ? passedProps[name2] : defaultValue2;
-            }
-            return acc;
-        }, {});
-        return Object.assign({}, passedProps, {}, pluginProps2);
+    function asciiControl(code2) {
+        return code2 !== null && (code2 < 32 || code2 === 127);
     }
+    const asciiDigit = regexCheck(/\d/);
+    const asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
+    const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
 
-    function getDataAttributeProps$1(reference2, plugins2) {
-        var propKeys = plugins2 ? Object.keys(getExtendedPassedProps$1(Object.assign({}, defaultProps$6, {
-            plugins: plugins2
-        }))) : defaultKeys$1;
-        var props = propKeys.reduce(function(acc, key) {
-            var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
-            if (!valueAsString) {
-                return acc;
-            }
-            if (key === "content") {
-                acc[key] = valueAsString;
-            } else {
-                try {
-                    acc[key] = JSON.parse(valueAsString);
-                } catch (e3) {
-                    acc[key] = valueAsString;
-                }
-            }
-            return acc;
-        }, {});
-        return props;
+    function markdownLineEnding(code2) {
+        return code2 !== null && code2 < -2;
     }
 
-    function evaluateProps$1(reference2, props) {
-        var out = Object.assign({}, props, {
-            content: invokeWithArgsOrReturn$1(props.content, [reference2])
-        }, props.ignoreAttributes ? {} : getDataAttributeProps$1(reference2, props.plugins));
-        out.aria = Object.assign({}, defaultProps$6.aria, {}, out.aria);
-        out.aria = {
-            expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
-            content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
-        };
-        return out;
+    function markdownLineEndingOrSpace(code2) {
+        return code2 !== null && (code2 < 0 || code2 === 32);
     }
 
-    function getChildren$2(popper2) {
-        var box = popper2.firstElementChild;
-        var boxChildren = arrayFrom$1(box.children);
-        return {
-            box,
-            content: boxChildren.find(function(node2) {
-                return node2.classList.contains(CONTENT_CLASS$1);
-            }),
-            arrow: boxChildren.find(function(node2) {
-                return node2.classList.contains(ARROW_CLASS$1) || node2.classList.contains(SVG_ARROW_CLASS$1);
-            }),
-            backdrop: boxChildren.find(function(node2) {
-                return node2.classList.contains(BACKDROP_CLASS$1);
-            })
-        };
+    function markdownSpace(code2) {
+        return code2 === -2 || code2 === -1 || code2 === 32;
     }
-    var idCounter$2 = 1;
-    var mouseMoveListeners$1 = [];
-    var mountedInstances$1 = [];
+    const unicodePunctuation = regexCheck(/\p{P}|\p{S}/u);
+    const unicodeWhitespace = regexCheck(/\s/);
 
-    function createTippy$1(reference2, passedProps) {
-        var props = evaluateProps$1(reference2, Object.assign({}, defaultProps$6, {}, getExtendedPassedProps$1(removeUndefinedProps$1(passedProps))));
-        var showTimeout;
-        var hideTimeout;
-        var scheduleHideAnimationFrame;
-        var isVisibleFromClick = false;
-        var didHideDueToDocumentMouseDown = false;
-        var didTouchMove = false;
-        var ignoreOnFirstUpdate = false;
-        var lastTriggerEvent;
-        var currentTransitionEndListener;
-        var onFirstUpdate;
-        var listeners = [];
-        var debouncedOnMouseMove = debounce$4(onMouseMove, props.interactiveDebounce);
-        var currentTarget;
-        var doc2 = getOwnerDocument$1(props.triggerTarget || reference2);
-        var id2 = idCounter$2++;
-        var popperInstance = null;
-        var plugins2 = unique$1(props.plugins);
-        var state = {
-            isEnabled: true,
-            isVisible: false,
-            isDestroyed: false,
-            isMounted: false,
-            isShown: false
-        };
-        var instance2 = {
-            id: id2,
-            reference: reference2,
-            popper: div$1(),
-            popperInstance,
-            props,
-            state,
-            plugins: plugins2,
-            clearDelayTimeouts,
-            setProps,
-            setContent: setContent2,
-            show,
-            hide: hide2,
-            hideWithInteractivity,
-            enable,
-            disable: disable2,
-            unmount,
-            destroy
-        };
-        if (!props.render) {
-            return instance2;
-        }
-        var _props$render = props.render(instance2),
-            popper2 = _props$render.popper,
-            onUpdate = _props$render.onUpdate;
-        popper2.setAttribute("data-tippy-root", "");
-        popper2.id = "tippy-" + instance2.id;
-        instance2.popper = popper2;
-        reference2._tippy = instance2;
-        popper2._tippy = instance2;
-        var pluginsHooks = plugins2.map(function(plugin) {
-            return plugin.fn(instance2);
-        });
-        var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
-        addListeners();
-        handleAriaExpandedAttribute();
-        handleStyles();
-        invokeHook("onCreate", [instance2]);
-        if (props.showOnCreate) {
-            scheduleShow();
+    function regexCheck(regex) {
+        return check;
+
+        function check(code2) {
+            return code2 !== null && code2 > -1 && regex.test(String.fromCharCode(code2));
         }
-        popper2.addEventListener("mouseenter", function() {
-            if (instance2.props.interactive && instance2.state.isVisible) {
-                instance2.clearDelayTimeouts();
+    }
+
+    function normalizeUri(value) {
+        const result = [];
+        let index2 = -1;
+        let start2 = 0;
+        let skip = 0;
+        while (++index2 < value.length) {
+            const code2 = value.charCodeAt(index2);
+            let replace2 = "";
+            if (code2 === 37 && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
+                skip = 2;
+            } else if (code2 < 128) {
+                if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2))) {
+                    replace2 = String.fromCharCode(code2);
+                }
+            } else if (code2 > 55295 && code2 < 57344) {
+                const next2 = value.charCodeAt(index2 + 1);
+                if (code2 < 56320 && next2 > 56319 && next2 < 57344) {
+                    replace2 = String.fromCharCode(code2, next2);
+                    skip = 1;
+                } else {
+                    replace2 = "\uFFFD";
+                }
+            } else {
+                replace2 = String.fromCharCode(code2);
             }
-        });
-        popper2.addEventListener("mouseleave", function(event2) {
-            if (instance2.props.interactive && instance2.props.trigger.indexOf("mouseenter") >= 0) {
-                doc2.addEventListener("mousemove", debouncedOnMouseMove);
-                debouncedOnMouseMove(event2);
+            if (replace2) {
+                result.push(value.slice(start2, index2), encodeURIComponent(replace2));
+                start2 = index2 + skip + 1;
+                replace2 = "";
+            }
+            if (skip) {
+                index2 += skip;
+                skip = 0;
             }
-        });
-        return instance2;
-
-        function getNormalizedTouchSettings() {
-            var touch = instance2.props.touch;
-            return Array.isArray(touch) ? touch : [touch, 0];
         }
+        return result.join("") + value.slice(start2);
+    }
 
-        function getIsCustomTouchBehavior() {
-            return getNormalizedTouchSettings()[0] === "hold";
-        }
+    function factorySpace(effects, ok2, type2, max2) {
+        const limit = max2 ? max2 - 1 : Number.POSITIVE_INFINITY;
+        let size2 = 0;
+        return start2;
 
-        function getIsDefaultRenderFn() {
-            var _instance$props$rende;
-            return !!((_instance$props$rende = instance2.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
+        function start2(code2) {
+            if (markdownSpace(code2)) {
+                effects.enter(type2);
+                return prefix(code2);
+            }
+            return ok2(code2);
         }
 
-        function getCurrentTarget() {
-            return currentTarget || reference2;
+        function prefix(code2) {
+            if (markdownSpace(code2) && size2++ < limit) {
+                effects.consume(code2);
+                return prefix;
+            }
+            effects.exit(type2);
+            return ok2(code2);
         }
+    }
+    const content$2 = {
+        tokenize: initializeContent
+    };
 
-        function getDefaultTemplateChildren() {
-            return getChildren$2(popper2);
-        }
+    function initializeContent(effects) {
+        const contentStart = effects.attempt(
+            this.parser.constructs.contentInitial,
+            afterContentStartConstruct,
+            paragraphInitial
+        );
+        let previous2;
+        return contentStart;
 
-        function getDelay(isShow) {
-            if (instance2.state.isMounted && !instance2.state.isVisible || currentInput$1.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
-                return 0;
+        function afterContentStartConstruct(code2) {
+            if (code2 === null) {
+                effects.consume(code2);
+                return;
             }
-            return getValueAtIndexOrReturn$1(instance2.props.delay, isShow ? 0 : 1, defaultProps$6.delay);
+            effects.enter("lineEnding");
+            effects.consume(code2);
+            effects.exit("lineEnding");
+            return factorySpace(effects, contentStart, "linePrefix");
         }
 
-        function handleStyles() {
-            popper2.style.pointerEvents = instance2.props.interactive && instance2.state.isVisible ? "" : "none";
-            popper2.style.zIndex = "" + instance2.props.zIndex;
+        function paragraphInitial(code2) {
+            effects.enter("paragraph");
+            return lineStart(code2);
         }
 
-        function invokeHook(hook, args, shouldInvokePropsHook) {
-            if (shouldInvokePropsHook === void 0) {
-                shouldInvokePropsHook = true;
-            }
-            pluginsHooks.forEach(function(pluginHooks) {
-                if (pluginHooks[hook]) {
-                    pluginHooks[hook].apply(void 0, args);
-                }
+        function lineStart(code2) {
+            const token = effects.enter("chunkText", {
+                contentType: "text",
+                previous: previous2
             });
-            if (shouldInvokePropsHook) {
-                var _instance$props;
-                (_instance$props = instance2.props)[hook].apply(_instance$props, args);
+            if (previous2) {
+                previous2.next = token;
             }
+            previous2 = token;
+            return data2(code2);
         }
 
-        function handleAriaContentAttribute() {
-            var aria2 = instance2.props.aria;
-            if (!aria2.content) {
+        function data2(code2) {
+            if (code2 === null) {
+                effects.exit("chunkText");
+                effects.exit("paragraph");
+                effects.consume(code2);
                 return;
             }
-            var attr = "aria-" + aria2.content;
-            var id3 = popper2.id;
-            var nodes = normalizeToArray$1(instance2.props.triggerTarget || reference2);
-            nodes.forEach(function(node2) {
-                var currentValue = node2.getAttribute(attr);
-                if (instance2.state.isVisible) {
-                    node2.setAttribute(attr, currentValue ? currentValue + " " + id3 : id3);
-                } else {
-                    var nextValue = currentValue && currentValue.replace(id3, "").trim();
-                    if (nextValue) {
-                        node2.setAttribute(attr, nextValue);
-                    } else {
-                        node2.removeAttribute(attr);
-                    }
-                }
-            });
-        }
-
-        function handleAriaExpandedAttribute() {
-            if (hasAriaExpanded || !instance2.props.aria.expanded) {
-                return;
+            if (markdownLineEnding(code2)) {
+                effects.consume(code2);
+                effects.exit("chunkText");
+                return lineStart;
             }
-            var nodes = normalizeToArray$1(instance2.props.triggerTarget || reference2);
-            nodes.forEach(function(node2) {
-                if (instance2.props.interactive) {
-                    node2.setAttribute("aria-expanded", instance2.state.isVisible && node2 === getCurrentTarget() ? "true" : "false");
-                } else {
-                    node2.removeAttribute("aria-expanded");
-                }
-            });
+            effects.consume(code2);
+            return data2;
         }
+    }
+    const document$2 = {
+        tokenize: initializeDocument
+    };
+    const containerConstruct = {
+        tokenize: tokenizeContainer
+    };
 
-        function cleanupInteractiveMouseListeners() {
-            doc2.removeEventListener("mousemove", debouncedOnMouseMove);
-            mouseMoveListeners$1 = mouseMoveListeners$1.filter(function(listener2) {
-                return listener2 !== debouncedOnMouseMove;
-            });
+    function initializeDocument(effects) {
+        const self2 = this;
+        const stack = [];
+        let continued = 0;
+        let childFlow;
+        let childToken;
+        let lineStartOffset;
+        return start2;
+
+        function start2(code2) {
+            if (continued < stack.length) {
+                const item = stack[continued];
+                self2.containerState = item[1];
+                return effects.attempt(
+                    item[0].continuation,
+                    documentContinue,
+                    checkNewContainers
+                )(code2);
+            }
+            return checkNewContainers(code2);
         }
 
-        function onDocumentPress(event2) {
-            if (currentInput$1.isTouch) {
-                if (didTouchMove || event2.type === "mousedown") {
-                    return;
+        function documentContinue(code2) {
+            continued++;
+            if (self2.containerState._closeFlow) {
+                self2.containerState._closeFlow = void 0;
+                if (childFlow) {
+                    closeFlow();
                 }
-            }
-            if (instance2.props.interactive && popper2.contains(event2.target)) {
-                return;
-            }
-            if (getCurrentTarget().contains(event2.target)) {
-                if (currentInput$1.isTouch) {
-                    return;
+                const indexBeforeExits = self2.events.length;
+                let indexBeforeFlow = indexBeforeExits;
+                let point2;
+                while (indexBeforeFlow--) {
+                    if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
+                        point2 = self2.events[indexBeforeFlow][1].end;
+                        break;
+                    }
                 }
-                if (instance2.state.isVisible && instance2.props.trigger.indexOf("click") >= 0) {
-                    return;
+                exitContainers(continued);
+                let index2 = indexBeforeExits;
+                while (index2 < self2.events.length) {
+                    self2.events[index2][1].end = Object.assign({}, point2);
+                    index2++;
                 }
-            } else {
-                invokeHook("onClickOutside", [instance2, event2]);
+                splice(
+                    self2.events,
+                    indexBeforeFlow + 1,
+                    0,
+                    self2.events.slice(indexBeforeExits)
+                );
+                self2.events.length = index2;
+                return checkNewContainers(code2);
             }
-            if (instance2.props.hideOnClick === true) {
-                instance2.clearDelayTimeouts();
-                instance2.hide();
-                didHideDueToDocumentMouseDown = true;
-                setTimeout(function() {
-                    didHideDueToDocumentMouseDown = false;
-                });
-                if (!instance2.state.isMounted) {
-                    removeDocumentPress();
+            return start2(code2);
+        }
+
+        function checkNewContainers(code2) {
+            if (continued === stack.length) {
+                if (!childFlow) {
+                    return documentContinued(code2);
                 }
+                if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
+                    return flowStart(code2);
+                }
+                self2.interrupt = Boolean(
+                    childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
+                );
             }
+            self2.containerState = {};
+            return effects.check(
+                containerConstruct,
+                thereIsANewContainer,
+                thereIsNoNewContainer
+            )(code2);
         }
 
-        function onTouchMove() {
-            didTouchMove = true;
+        function thereIsANewContainer(code2) {
+            if (childFlow)
+                closeFlow();
+            exitContainers(continued);
+            return documentContinued(code2);
         }
 
-        function onTouchStart() {
-            didTouchMove = false;
+        function thereIsNoNewContainer(code2) {
+            self2.parser.lazy[self2.now().line] = continued !== stack.length;
+            lineStartOffset = self2.now().offset;
+            return flowStart(code2);
         }
 
-        function addDocumentPress() {
-            doc2.addEventListener("mousedown", onDocumentPress, true);
-            doc2.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS$1);
-            doc2.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS$1);
-            doc2.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS$1);
+        function documentContinued(code2) {
+            self2.containerState = {};
+            return effects.attempt(
+                containerConstruct,
+                containerContinue,
+                flowStart
+            )(code2);
         }
 
-        function removeDocumentPress() {
-            doc2.removeEventListener("mousedown", onDocumentPress, true);
-            doc2.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS$1);
-            doc2.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS$1);
-            doc2.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS$1);
+        function containerContinue(code2) {
+            continued++;
+            stack.push([self2.currentConstruct, self2.containerState]);
+            return documentContinued(code2);
         }
 
-        function onTransitionedOut(duration, callback) {
-            onTransitionEnd(duration, function() {
-                if (!instance2.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
-                    callback();
-                }
+        function flowStart(code2) {
+            if (code2 === null) {
+                if (childFlow)
+                    closeFlow();
+                exitContainers(0);
+                effects.consume(code2);
+                return;
+            }
+            childFlow = childFlow || self2.parser.flow(self2.now());
+            effects.enter("chunkFlow", {
+                contentType: "flow",
+                previous: childToken,
+                _tokenizer: childFlow
             });
+            return flowContinue(code2);
         }
 
-        function onTransitionedIn(duration, callback) {
-            onTransitionEnd(duration, callback);
-        }
-
-        function onTransitionEnd(duration, callback) {
-            var box = getDefaultTemplateChildren().box;
-
-            function listener2(event2) {
-                if (event2.target === box) {
-                    updateTransitionEndListener$1(box, "remove", listener2);
-                    callback();
-                }
+        function flowContinue(code2) {
+            if (code2 === null) {
+                writeToChild(effects.exit("chunkFlow"), true);
+                exitContainers(0);
+                effects.consume(code2);
+                return;
             }
-            if (duration === 0) {
-                return callback();
+            if (markdownLineEnding(code2)) {
+                effects.consume(code2);
+                writeToChild(effects.exit("chunkFlow"));
+                continued = 0;
+                self2.interrupt = void 0;
+                return start2;
             }
-            updateTransitionEndListener$1(box, "remove", currentTransitionEndListener);
-            updateTransitionEndListener$1(box, "add", listener2);
-            currentTransitionEndListener = listener2;
+            effects.consume(code2);
+            return flowContinue;
         }
 
-        function on(eventType, handler, options) {
-            if (options === void 0) {
-                options = false;
+        function writeToChild(token, eof2) {
+            const stream = self2.sliceStream(token);
+            if (eof2)
+                stream.push(null);
+            token.previous = childToken;
+            if (childToken)
+                childToken.next = token;
+            childToken = token;
+            childFlow.defineSkip(token.start);
+            childFlow.write(stream);
+            if (self2.parser.lazy[token.start.line]) {
+                let index2 = childFlow.events.length;
+                while (index2--) {
+                    if (childFlow.events[index2][1].start.offset < lineStartOffset && (!childFlow.events[index2][1].end || childFlow.events[index2][1].end.offset > lineStartOffset)) {
+                        return;
+                    }
+                }
+                const indexBeforeExits = self2.events.length;
+                let indexBeforeFlow = indexBeforeExits;
+                let seen;
+                let point2;
+                while (indexBeforeFlow--) {
+                    if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
+                        if (seen) {
+                            point2 = self2.events[indexBeforeFlow][1].end;
+                            break;
+                        }
+                        seen = true;
+                    }
+                }
+                exitContainers(continued);
+                index2 = indexBeforeExits;
+                while (index2 < self2.events.length) {
+                    self2.events[index2][1].end = Object.assign({}, point2);
+                    index2++;
+                }
+                splice(
+                    self2.events,
+                    indexBeforeFlow + 1,
+                    0,
+                    self2.events.slice(indexBeforeExits)
+                );
+                self2.events.length = index2;
             }
-            var nodes = normalizeToArray$1(instance2.props.triggerTarget || reference2);
-            nodes.forEach(function(node2) {
-                node2.addEventListener(eventType, handler, options);
-                listeners.push({
-                    node: node2,
-                    eventType,
-                    handler,
-                    options
-                });
-            });
         }
 
-        function addListeners() {
-            if (getIsCustomTouchBehavior()) {
-                on("touchstart", onTrigger, {
-                    passive: true
-                });
-                on("touchend", onMouseLeave, {
-                    passive: true
-                });
+        function exitContainers(size2) {
+            let index2 = stack.length;
+            while (index2-- > size2) {
+                const entry = stack[index2];
+                self2.containerState = entry[1];
+                entry[0].exit.call(self2, effects);
             }
-            splitBySpaces$1(instance2.props.trigger).forEach(function(eventType) {
-                if (eventType === "manual") {
-                    return;
-                }
-                on(eventType, onTrigger);
-                switch (eventType) {
-                    case "mouseenter":
-                        on("mouseleave", onMouseLeave);
-                        break;
-                    case "focus":
-                        on(isIE$1 ? "focusout" : "blur", onBlurOrFocusOut);
-                        break;
-                    case "focusin":
-                        on("focusout", onBlurOrFocusOut);
-                        break;
-                }
-            });
+            stack.length = size2;
         }
 
-        function removeListeners() {
-            listeners.forEach(function(_ref2) {
-                var node2 = _ref2.node,
-                    eventType = _ref2.eventType,
-                    handler = _ref2.handler,
-                    options = _ref2.options;
-                node2.removeEventListener(eventType, handler, options);
-            });
-            listeners = [];
+        function closeFlow() {
+            childFlow.write([null]);
+            childToken = void 0;
+            childFlow = void 0;
+            self2.containerState._closeFlow = void 0;
         }
+    }
 
-        function onTrigger(event2) {
-            var _lastTriggerEvent;
-            var shouldScheduleClickHide = false;
-            if (!instance2.state.isEnabled || isEventListenerStopped(event2) || didHideDueToDocumentMouseDown) {
-                return;
+    function tokenizeContainer(effects, ok2, nok) {
+        return factorySpace(
+            effects,
+            effects.attempt(this.parser.constructs.document, ok2, nok),
+            "linePrefix",
+            this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
+        );
+    }
+
+    function classifyCharacter(code2) {
+        if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
+            return 1;
+        }
+        if (unicodePunctuation(code2)) {
+            return 2;
+        }
+    }
+
+    function resolveAll(constructs2, events2, context2) {
+        const called = [];
+        let index2 = -1;
+        while (++index2 < constructs2.length) {
+            const resolve2 = constructs2[index2].resolveAll;
+            if (resolve2 && !called.includes(resolve2)) {
+                events2 = resolve2(events2, context2);
+                called.push(resolve2);
             }
-            var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
-            lastTriggerEvent = event2;
-            currentTarget = event2.currentTarget;
-            handleAriaExpandedAttribute();
-            if (!instance2.state.isVisible && isMouseEvent$1(event2)) {
-                mouseMoveListeners$1.forEach(function(listener2) {
-                    return listener2(event2);
-                });
+        }
+        return events2;
+    }
+    const attention = {
+        name: "attention",
+        tokenize: tokenizeAttention,
+        resolveAll: resolveAllAttention
+    };
+
+    function resolveAllAttention(events2, context2) {
+        let index2 = -1;
+        let open;
+        let group;
+        let text2;
+        let openingSequence;
+        let closingSequence;
+        let use;
+        let nextEvents;
+        let offset2;
+        while (++index2 < events2.length) {
+            if (events2[index2][0] === "enter" && events2[index2][1].type === "attentionSequence" && events2[index2][1]._close) {
+                open = index2;
+                while (open--) {
+                    if (events2[open][0] === "exit" && events2[open][1].type === "attentionSequence" && events2[open][1]._open && context2.sliceSerialize(events2[open][1]).charCodeAt(0) === context2.sliceSerialize(events2[index2][1]).charCodeAt(0)) {
+                        if ((events2[open][1]._close || events2[index2][1]._open) && (events2[index2][1].end.offset - events2[index2][1].start.offset) % 3 && !((events2[open][1].end.offset - events2[open][1].start.offset + events2[index2][1].end.offset - events2[index2][1].start.offset) % 3)) {
+                            continue;
+                        }
+                        use = events2[open][1].end.offset - events2[open][1].start.offset > 1 && events2[index2][1].end.offset - events2[index2][1].start.offset > 1 ? 2 : 1;
+                        const start2 = Object.assign({}, events2[open][1].end);
+                        const end2 = Object.assign({}, events2[index2][1].start);
+                        movePoint(start2, -use);
+                        movePoint(end2, use);
+                        openingSequence = {
+                            type: use > 1 ? "strongSequence" : "emphasisSequence",
+                            start: start2,
+                            end: Object.assign({}, events2[open][1].end)
+                        };
+                        closingSequence = {
+                            type: use > 1 ? "strongSequence" : "emphasisSequence",
+                            start: Object.assign({}, events2[index2][1].start),
+                            end: end2
+                        };
+                        text2 = {
+                            type: use > 1 ? "strongText" : "emphasisText",
+                            start: Object.assign({}, events2[open][1].end),
+                            end: Object.assign({}, events2[index2][1].start)
+                        };
+                        group = {
+                            type: use > 1 ? "strong" : "emphasis",
+                            start: Object.assign({}, openingSequence.start),
+                            end: Object.assign({}, closingSequence.end)
+                        };
+                        events2[open][1].end = Object.assign({}, openingSequence.start);
+                        events2[index2][1].start = Object.assign({}, closingSequence.end);
+                        nextEvents = [];
+                        if (events2[open][1].end.offset - events2[open][1].start.offset) {
+                            nextEvents = push$2(nextEvents, [
+                                ["enter", events2[open][1], context2],
+                                ["exit", events2[open][1], context2]
+                            ]);
+                        }
+                        nextEvents = push$2(nextEvents, [
+                            ["enter", group, context2],
+                            ["enter", openingSequence, context2],
+                            ["exit", openingSequence, context2],
+                            ["enter", text2, context2]
+                        ]);
+                        nextEvents = push$2(
+                            nextEvents,
+                            resolveAll(
+                                context2.parser.constructs.insideSpan.null,
+                                events2.slice(open + 1, index2),
+                                context2
+                            )
+                        );
+                        nextEvents = push$2(nextEvents, [
+                            ["exit", text2, context2],
+                            ["enter", closingSequence, context2],
+                            ["exit", closingSequence, context2],
+                            ["exit", group, context2]
+                        ]);
+                        if (events2[index2][1].end.offset - events2[index2][1].start.offset) {
+                            offset2 = 2;
+                            nextEvents = push$2(nextEvents, [
+                                ["enter", events2[index2][1], context2],
+                                ["exit", events2[index2][1], context2]
+                            ]);
+                        } else {
+                            offset2 = 0;
+                        }
+                        splice(events2, open - 1, index2 - open + 3, nextEvents);
+                        index2 = open + nextEvents.length - offset2 - 2;
+                        break;
+                    }
+                }
             }
-            if (event2.type === "click" && (instance2.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance2.props.hideOnClick !== false && instance2.state.isVisible) {
-                shouldScheduleClickHide = true;
-            } else {
-                scheduleShow(event2);
+        }
+        index2 = -1;
+        while (++index2 < events2.length) {
+            if (events2[index2][1].type === "attentionSequence") {
+                events2[index2][1].type = "data";
             }
-            if (event2.type === "click") {
-                isVisibleFromClick = !shouldScheduleClickHide;
+        }
+        return events2;
+    }
+
+    function tokenizeAttention(effects, ok2) {
+        const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
+        const previous2 = this.previous;
+        const before = classifyCharacter(previous2);
+        let marker;
+        return start2;
+
+        function start2(code2) {
+            marker = code2;
+            effects.enter("attentionSequence");
+            return inside2(code2);
+        }
+
+        function inside2(code2) {
+            if (code2 === marker) {
+                effects.consume(code2);
+                return inside2;
             }
-            if (shouldScheduleClickHide && !wasFocused) {
-                scheduleHide(event2);
+            const token = effects.exit("attentionSequence");
+            const after = classifyCharacter(code2);
+            const open = !after || after === 2 && before || attentionMarkers2.includes(code2);
+            const close = !before || before === 2 && after || attentionMarkers2.includes(previous2);
+            token._open = Boolean(marker === 42 ? open : open && (before || !close));
+            token._close = Boolean(marker === 42 ? close : close && (after || !open));
+            return ok2(code2);
+        }
+    }
+
+    function movePoint(point2, offset2) {
+        point2.column += offset2;
+        point2.offset += offset2;
+        point2._bufferIndex += offset2;
+    }
+    const autolink = {
+        name: "autolink",
+        tokenize: tokenizeAutolink
+    };
+
+    function tokenizeAutolink(effects, ok2, nok) {
+        let size2 = 0;
+        return start2;
+
+        function start2(code2) {
+            effects.enter("autolink");
+            effects.enter("autolinkMarker");
+            effects.consume(code2);
+            effects.exit("autolinkMarker");
+            effects.enter("autolinkProtocol");
+            return open;
+        }
+
+        function open(code2) {
+            if (asciiAlpha(code2)) {
+                effects.consume(code2);
+                return schemeOrEmailAtext;
             }
+            return emailAtext(code2);
         }
 
-        function onMouseMove(event2) {
-            var target = event2.target;
-            var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
-            if (event2.type === "mousemove" && isCursorOverReferenceOrPopper) {
-                return;
+        function schemeOrEmailAtext(code2) {
+            if (code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) {
+                size2 = 1;
+                return schemeInsideOrEmailAtext(code2);
             }
-            var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
-                var _instance$popperInsta;
-                var instance3 = popper3._tippy;
-                var state2 = (_instance$popperInsta = instance3.popperInstance) == null ? void 0 : _instance$popperInsta.state;
-                if (state2) {
-                    return {
-                        popperRect: popper3.getBoundingClientRect(),
-                        popperState: state2,
-                        props
-                    };
-                }
-                return null;
-            }).filter(Boolean);
-            if (isCursorOutsideInteractiveBorder$1(popperTreeData, event2)) {
-                cleanupInteractiveMouseListeners();
-                scheduleHide(event2);
+            return emailAtext(code2);
+        }
+
+        function schemeInsideOrEmailAtext(code2) {
+            if (code2 === 58) {
+                effects.consume(code2);
+                size2 = 0;
+                return urlInside;
+            }
+            if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size2++ < 32) {
+                effects.consume(code2);
+                return schemeInsideOrEmailAtext;
             }
+            size2 = 0;
+            return emailAtext(code2);
         }
 
-        function onMouseLeave(event2) {
-            var shouldBail = isEventListenerStopped(event2) || instance2.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
-            if (shouldBail) {
-                return;
+        function urlInside(code2) {
+            if (code2 === 62) {
+                effects.exit("autolinkProtocol");
+                effects.enter("autolinkMarker");
+                effects.consume(code2);
+                effects.exit("autolinkMarker");
+                effects.exit("autolink");
+                return ok2;
             }
-            if (instance2.props.interactive) {
-                instance2.hideWithInteractivity(event2);
-                return;
+            if (code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2)) {
+                return nok(code2);
             }
-            scheduleHide(event2);
+            effects.consume(code2);
+            return urlInside;
         }
 
-        function onBlurOrFocusOut(event2) {
-            if (instance2.props.trigger.indexOf("focusin") < 0 && event2.target !== getCurrentTarget()) {
-                return;
+        function emailAtext(code2) {
+            if (code2 === 64) {
+                effects.consume(code2);
+                return emailAtSignOrDot;
             }
-            if (instance2.props.interactive && event2.relatedTarget && popper2.contains(event2.relatedTarget)) {
-                return;
+            if (asciiAtext(code2)) {
+                effects.consume(code2);
+                return emailAtext;
             }
-            scheduleHide(event2);
+            return nok(code2);
         }
 
-        function isEventListenerStopped(event2) {
-            return currentInput$1.isTouch ? getIsCustomTouchBehavior() !== event2.type.indexOf("touch") >= 0 : false;
+        function emailAtSignOrDot(code2) {
+            return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
         }
 
-        function createPopperInstance() {
-            destroyPopperInstance();
-            var _instance$props2 = instance2.props,
-                popperOptions = _instance$props2.popperOptions,
-                placement = _instance$props2.placement,
-                offset2 = _instance$props2.offset,
-                getReferenceClientRect = _instance$props2.getReferenceClientRect,
-                moveTransition = _instance$props2.moveTransition;
-            var arrow2 = getIsDefaultRenderFn() ? getChildren$2(popper2).arrow : null;
-            var computedReference = getReferenceClientRect ? {
-                getBoundingClientRect: getReferenceClientRect,
-                contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
-            } : reference2;
-            var tippyModifier = {
-                name: "$$tippy",
-                enabled: true,
-                phase: "beforeWrite",
-                requires: ["computeStyles"],
-                fn: function fn2(_ref2) {
-                    var state2 = _ref2.state;
-                    if (getIsDefaultRenderFn()) {
-                        var _getDefaultTemplateCh = getDefaultTemplateChildren(),
-                            box = _getDefaultTemplateCh.box;
-                        ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
-                            if (attr === "placement") {
-                                box.setAttribute("data-placement", state2.placement);
-                            } else {
-                                if (state2.attributes.popper["data-popper-" + attr]) {
-                                    box.setAttribute("data-" + attr, "");
-                                } else {
-                                    box.removeAttribute("data-" + attr);
-                                }
-                            }
-                        });
-                        state2.attributes.popper = {};
-                    }
-                }
-            };
-            var modifiers2 = [{
-                name: "offset",
-                options: {
-                    offset: offset2
-                }
-            }, {
-                name: "preventOverflow",
-                options: {
-                    padding: {
-                        top: 2,
-                        bottom: 2,
-                        left: 5,
-                        right: 5
-                    }
-                }
-            }, {
-                name: "flip",
-                options: {
-                    padding: 5
-                }
-            }, {
-                name: "computeStyles",
-                options: {
-                    adaptive: !moveTransition
-                }
-            }, tippyModifier];
-            if (getIsDefaultRenderFn() && arrow2) {
-                modifiers2.push({
-                    name: "arrow",
-                    options: {
-                        element: arrow2,
-                        padding: 3
-                    }
-                });
+        function emailLabel(code2) {
+            if (code2 === 46) {
+                effects.consume(code2);
+                size2 = 0;
+                return emailAtSignOrDot;
             }
-            modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
-            instance2.popperInstance = createPopper$1(computedReference, popper2, Object.assign({}, popperOptions, {
-                placement,
-                onFirstUpdate,
-                modifiers: modifiers2
-            }));
+            if (code2 === 62) {
+                effects.exit("autolinkProtocol").type = "autolinkEmail";
+                effects.enter("autolinkMarker");
+                effects.consume(code2);
+                effects.exit("autolinkMarker");
+                effects.exit("autolink");
+                return ok2;
+            }
+            return emailValue(code2);
         }
 
-        function destroyPopperInstance() {
-            if (instance2.popperInstance) {
-                instance2.popperInstance.destroy();
-                instance2.popperInstance = null;
+        function emailValue(code2) {
+            if ((code2 === 45 || asciiAlphanumeric(code2)) && size2++ < 63) {
+                const next2 = code2 === 45 ? emailValue : emailLabel;
+                effects.consume(code2);
+                return next2;
             }
+            return nok(code2);
         }
+    }
+    const blankLine = {
+        tokenize: tokenizeBlankLine,
+        partial: true
+    };
 
-        function mount() {
-            var appendTo = instance2.props.appendTo;
-            var parentNode;
-            var node2 = getCurrentTarget();
-            if (instance2.props.interactive && appendTo === defaultProps$6.appendTo || appendTo === "parent") {
-                parentNode = node2.parentNode;
-            } else {
-                parentNode = invokeWithArgsOrReturn$1(appendTo, [node2]);
-            }
-            if (!parentNode.contains(popper2)) {
-                parentNode.appendChild(popper2);
-            }
-            createPopperInstance();
+    function tokenizeBlankLine(effects, ok2, nok) {
+        return start2;
+
+        function start2(code2) {
+            return markdownSpace(code2) ? factorySpace(effects, after, "linePrefix")(code2) : after(code2);
         }
 
-        function getNestedPopperTree() {
-            return arrayFrom$1(popper2.querySelectorAll("[data-tippy-root]"));
+        function after(code2) {
+            return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
         }
+    }
+    const blockQuote = {
+        name: "blockQuote",
+        tokenize: tokenizeBlockQuoteStart,
+        continuation: {
+            tokenize: tokenizeBlockQuoteContinuation
+        },
+        exit: exit$1
+    };
 
-        function scheduleShow(event2) {
-            instance2.clearDelayTimeouts();
-            if (event2) {
-                invokeHook("onTrigger", [instance2, event2]);
+    function tokenizeBlockQuoteStart(effects, ok2, nok) {
+        const self2 = this;
+        return start2;
+
+        function start2(code2) {
+            if (code2 === 62) {
+                const state = self2.containerState;
+                if (!state.open) {
+                    effects.enter("blockQuote", {
+                        _container: true
+                    });
+                    state.open = true;
+                }
+                effects.enter("blockQuotePrefix");
+                effects.enter("blockQuoteMarker");
+                effects.consume(code2);
+                effects.exit("blockQuoteMarker");
+                return after;
             }
-            addDocumentPress();
-            var delay = getDelay(true);
-            var _getNormalizedTouchSe = getNormalizedTouchSettings(),
-                touchValue = _getNormalizedTouchSe[0],
-                touchDelay = _getNormalizedTouchSe[1];
-            if (currentInput$1.isTouch && touchValue === "hold" && touchDelay) {
-                delay = touchDelay;
+            return nok(code2);
+        }
+
+        function after(code2) {
+            if (markdownSpace(code2)) {
+                effects.enter("blockQuotePrefixWhitespace");
+                effects.consume(code2);
+                effects.exit("blockQuotePrefixWhitespace");
+                effects.exit("blockQuotePrefix");
+                return ok2;
             }
-            if (delay) {
-                showTimeout = setTimeout(function() {
-                    instance2.show();
-                }, delay);
-            } else {
-                instance2.show();
+            effects.exit("blockQuotePrefix");
+            return ok2(code2);
+        }
+    }
+
+    function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
+        const self2 = this;
+        return contStart;
+
+        function contStart(code2) {
+            if (markdownSpace(code2)) {
+                return factorySpace(
+                    effects,
+                    contBefore,
+                    "linePrefix",
+                    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
+                )(code2);
             }
+            return contBefore(code2);
         }
 
-        function scheduleHide(event2) {
-            instance2.clearDelayTimeouts();
-            invokeHook("onUntrigger", [instance2, event2]);
-            if (!instance2.state.isVisible) {
-                removeDocumentPress();
-                return;
+        function contBefore(code2) {
+            return effects.attempt(blockQuote, ok2, nok)(code2);
+        }
+    }
+
+    function exit$1(effects) {
+        effects.exit("blockQuote");
+    }
+    const characterEscape = {
+        name: "characterEscape",
+        tokenize: tokenizeCharacterEscape
+    };
+
+    function tokenizeCharacterEscape(effects, ok2, nok) {
+        return start2;
+
+        function start2(code2) {
+            effects.enter("characterEscape");
+            effects.enter("escapeMarker");
+            effects.consume(code2);
+            effects.exit("escapeMarker");
+            return inside2;
+        }
+
+        function inside2(code2) {
+            if (asciiPunctuation(code2)) {
+                effects.enter("characterEscapeValue");
+                effects.consume(code2);
+                effects.exit("characterEscapeValue");
+                effects.exit("characterEscape");
+                return ok2;
             }
-            if (instance2.props.trigger.indexOf("mouseenter") >= 0 && instance2.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event2.type) >= 0 && isVisibleFromClick) {
-                return;
+            return nok(code2);
+        }
+    }
+    const characterReference = {
+        name: "characterReference",
+        tokenize: tokenizeCharacterReference
+    };
+
+    function tokenizeCharacterReference(effects, ok2, nok) {
+        const self2 = this;
+        let size2 = 0;
+        let max2;
+        let test2;
+        return start2;
+
+        function start2(code2) {
+            effects.enter("characterReference");
+            effects.enter("characterReferenceMarker");
+            effects.consume(code2);
+            effects.exit("characterReferenceMarker");
+            return open;
+        }
+
+        function open(code2) {
+            if (code2 === 35) {
+                effects.enter("characterReferenceMarkerNumeric");
+                effects.consume(code2);
+                effects.exit("characterReferenceMarkerNumeric");
+                return numeric2;
             }
-            var delay = getDelay(false);
-            if (delay) {
-                hideTimeout = setTimeout(function() {
-                    if (instance2.state.isVisible) {
-                        instance2.hide();
-                    }
-                }, delay);
-            } else {
-                scheduleHideAnimationFrame = requestAnimationFrame(function() {
-                    instance2.hide();
-                });
+            effects.enter("characterReferenceValue");
+            max2 = 31;
+            test2 = asciiAlphanumeric;
+            return value(code2);
+        }
+
+        function numeric2(code2) {
+            if (code2 === 88 || code2 === 120) {
+                effects.enter("characterReferenceMarkerHexadecimal");
+                effects.consume(code2);
+                effects.exit("characterReferenceMarkerHexadecimal");
+                effects.enter("characterReferenceValue");
+                max2 = 6;
+                test2 = asciiHexDigit;
+                return value;
             }
+            effects.enter("characterReferenceValue");
+            max2 = 7;
+            test2 = asciiDigit;
+            return value(code2);
         }
 
-        function enable() {
-            instance2.state.isEnabled = true;
+        function value(code2) {
+            if (code2 === 59 && size2) {
+                const token = effects.exit("characterReferenceValue");
+                if (test2 === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
+                    return nok(code2);
+                }
+                effects.enter("characterReferenceMarker");
+                effects.consume(code2);
+                effects.exit("characterReferenceMarker");
+                effects.exit("characterReference");
+                return ok2;
+            }
+            if (test2(code2) && size2++ < max2) {
+                effects.consume(code2);
+                return value;
+            }
+            return nok(code2);
         }
+    }
+    const nonLazyContinuation = {
+        tokenize: tokenizeNonLazyContinuation,
+        partial: true
+    };
+    const codeFenced = {
+        name: "codeFenced",
+        tokenize: tokenizeCodeFenced,
+        concrete: true
+    };
 
-        function disable2() {
-            instance2.hide();
-            instance2.state.isEnabled = false;
+    function tokenizeCodeFenced(effects, ok2, nok) {
+        const self2 = this;
+        const closeStart = {
+            tokenize: tokenizeCloseStart,
+            partial: true
+        };
+        let initialPrefix = 0;
+        let sizeOpen = 0;
+        let marker;
+        return start2;
+
+        function start2(code2) {
+            return beforeSequenceOpen(code2);
         }
 
-        function clearDelayTimeouts() {
-            clearTimeout(showTimeout);
-            clearTimeout(hideTimeout);
-            cancelAnimationFrame(scheduleHideAnimationFrame);
+        function beforeSequenceOpen(code2) {
+            const tail = self2.events[self2.events.length - 1];
+            initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
+            marker = code2;
+            effects.enter("codeFenced");
+            effects.enter("codeFencedFence");
+            effects.enter("codeFencedFenceSequence");
+            return sequenceOpen(code2);
         }
 
-        function setProps(partialProps) {
-            if (instance2.state.isDestroyed) {
-                return;
+        function sequenceOpen(code2) {
+            if (code2 === marker) {
+                sizeOpen++;
+                effects.consume(code2);
+                return sequenceOpen;
             }
-            invokeHook("onBeforeUpdate", [instance2, partialProps]);
-            removeListeners();
-            var prevProps = instance2.props;
-            var nextProps = evaluateProps$1(reference2, Object.assign({}, instance2.props, {}, partialProps, {
-                ignoreAttributes: true
-            }));
-            instance2.props = nextProps;
-            addListeners();
-            if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
-                cleanupInteractiveMouseListeners();
-                debouncedOnMouseMove = debounce$4(onMouseMove, nextProps.interactiveDebounce);
+            if (sizeOpen < 3) {
+                return nok(code2);
             }
-            if (prevProps.triggerTarget && !nextProps.triggerTarget) {
-                normalizeToArray$1(prevProps.triggerTarget).forEach(function(node2) {
-                    node2.removeAttribute("aria-expanded");
-                });
-            } else if (nextProps.triggerTarget) {
-                reference2.removeAttribute("aria-expanded");
+            effects.exit("codeFencedFenceSequence");
+            return markdownSpace(code2) ? factorySpace(effects, infoBefore, "whitespace")(code2) : infoBefore(code2);
+        }
+
+        function infoBefore(code2) {
+            if (code2 === null || markdownLineEnding(code2)) {
+                effects.exit("codeFencedFence");
+                return self2.interrupt ? ok2(code2) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
             }
-            handleAriaExpandedAttribute();
-            handleStyles();
-            if (onUpdate) {
-                onUpdate(prevProps, nextProps);
+            effects.enter("codeFencedFenceInfo");
+            effects.enter("chunkString", {
+                contentType: "string"
+            });
+            return info(code2);
+        }
+
+        function info(code2) {
+            if (code2 === null || markdownLineEnding(code2)) {
+                effects.exit("chunkString");
+                effects.exit("codeFencedFenceInfo");
+                return infoBefore(code2);
             }
-            if (instance2.popperInstance) {
-                createPopperInstance();
-                getNestedPopperTree().forEach(function(nestedPopper) {
-                    requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
-                });
+            if (markdownSpace(code2)) {
+                effects.exit("chunkString");
+                effects.exit("codeFencedFenceInfo");
+                return factorySpace(effects, metaBefore, "whitespace")(code2);
             }
-            invokeHook("onAfterUpdate", [instance2, partialProps]);
+            if (code2 === 96 && code2 === marker) {
+                return nok(code2);
+            }
+            effects.consume(code2);
+            return info;
         }
 
-        function setContent2(content2) {
-            instance2.setProps({
-                content: content2
+        function metaBefore(code2) {
+            if (code2 === null || markdownLineEnding(code2)) {
+                return infoBefore(code2);
+            }
+            effects.enter("codeFencedFenceMeta");
+            effects.enter("chunkString", {
+                contentType: "string"
             });
+            return meta2(code2);
         }
 
-        function show() {
-            var isAlreadyVisible = instance2.state.isVisible;
-            var isDestroyed = instance2.state.isDestroyed;
-            var isDisabled = !instance2.state.isEnabled;
-            var isTouchAndTouchDisabled = currentInput$1.isTouch && !instance2.props.touch;
-            var duration = getValueAtIndexOrReturn$1(instance2.props.duration, 0, defaultProps$6.duration);
-            if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
-                return;
-            }
-            if (getCurrentTarget().hasAttribute("disabled")) {
-                return;
-            }
-            invokeHook("onShow", [instance2], false);
-            if (instance2.props.onShow(instance2) === false) {
-                return;
+        function meta2(code2) {
+            if (code2 === null || markdownLineEnding(code2)) {
+                effects.exit("chunkString");
+                effects.exit("codeFencedFenceMeta");
+                return infoBefore(code2);
             }
-            instance2.state.isVisible = true;
-            if (getIsDefaultRenderFn()) {
-                popper2.style.visibility = "visible";
+            if (code2 === 96 && code2 === marker) {
+                return nok(code2);
             }
-            handleStyles();
-            addDocumentPress();
-            if (!instance2.state.isMounted) {
-                popper2.style.transition = "none";
+            effects.consume(code2);
+            return meta2;
+        }
+
+        function atNonLazyBreak(code2) {
+            return effects.attempt(closeStart, after, contentBefore)(code2);
+        }
+
+        function contentBefore(code2) {
+            effects.enter("lineEnding");
+            effects.consume(code2);
+            effects.exit("lineEnding");
+            return contentStart;
+        }
+
+        function contentStart(code2) {
+            return initialPrefix > 0 && markdownSpace(code2) ? factorySpace(
+                effects,
+                beforeContentChunk,
+                "linePrefix",
+                initialPrefix + 1
+            )(code2) : beforeContentChunk(code2);
+        }
+
+        function beforeContentChunk(code2) {
+            if (code2 === null || markdownLineEnding(code2)) {
+                return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
             }
-            if (getIsDefaultRenderFn()) {
-                var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
-                    box = _getDefaultTemplateCh2.box,
-                    content2 = _getDefaultTemplateCh2.content;
-                setTransitionDuration$1([box, content2], 0);
+            effects.enter("codeFlowValue");
+            return contentChunk(code2);
+        }
+
+        function contentChunk(code2) {
+            if (code2 === null || markdownLineEnding(code2)) {
+                effects.exit("codeFlowValue");
+                return beforeContentChunk(code2);
             }
-            onFirstUpdate = function onFirstUpdate2() {
-                if (!instance2.state.isVisible || ignoreOnFirstUpdate) {
-                    return;
-                }
-                ignoreOnFirstUpdate = true;
-                void popper2.offsetHeight;
-                popper2.style.transition = instance2.props.moveTransition;
-                if (getIsDefaultRenderFn() && instance2.props.animation) {
-                    var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
-                        _box = _getDefaultTemplateCh3.box,
-                        _content = _getDefaultTemplateCh3.content;
-                    setTransitionDuration$1([_box, _content], duration);
-                    setVisibilityState$1([_box, _content], "visible");
-                }
-                handleAriaContentAttribute();
-                handleAriaExpandedAttribute();
-                pushIfUnique$1(mountedInstances$1, instance2);
-                instance2.state.isMounted = true;
-                invokeHook("onMount", [instance2]);
-                if (instance2.props.animation && getIsDefaultRenderFn()) {
-                    onTransitionedIn(duration, function() {
-                        instance2.state.isShown = true;
-                        invokeHook("onShown", [instance2]);
-                    });
-                }
-            };
-            mount();
+            effects.consume(code2);
+            return contentChunk;
         }
 
-        function hide2() {
-            var isAlreadyHidden = !instance2.state.isVisible;
-            var isDestroyed = instance2.state.isDestroyed;
-            var isDisabled = !instance2.state.isEnabled;
-            var duration = getValueAtIndexOrReturn$1(instance2.props.duration, 1, defaultProps$6.duration);
-            if (isAlreadyHidden || isDestroyed || isDisabled) {
-                return;
+        function after(code2) {
+            effects.exit("codeFenced");
+            return ok2(code2);
+        }
+
+        function tokenizeCloseStart(effects2, ok3, nok2) {
+            let size2 = 0;
+            return startBefore;
+
+            function startBefore(code2) {
+                effects2.enter("lineEnding");
+                effects2.consume(code2);
+                effects2.exit("lineEnding");
+                return start3;
             }
-            invokeHook("onHide", [instance2], false);
-            if (instance2.props.onHide(instance2) === false) {
-                return;
+
+            function start3(code2) {
+                effects2.enter("codeFencedFence");
+                return markdownSpace(code2) ? factorySpace(
+                    effects2,
+                    beforeSequenceClose,
+                    "linePrefix",
+                    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
+                )(code2) : beforeSequenceClose(code2);
             }
-            instance2.state.isVisible = false;
-            instance2.state.isShown = false;
-            ignoreOnFirstUpdate = false;
-            isVisibleFromClick = false;
-            if (getIsDefaultRenderFn()) {
-                popper2.style.visibility = "hidden";
+
+            function beforeSequenceClose(code2) {
+                if (code2 === marker) {
+                    effects2.enter("codeFencedFenceSequence");
+                    return sequenceClose(code2);
+                }
+                return nok2(code2);
             }
-            cleanupInteractiveMouseListeners();
-            removeDocumentPress();
-            handleStyles();
-            if (getIsDefaultRenderFn()) {
-                var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
-                    box = _getDefaultTemplateCh4.box,
-                    content2 = _getDefaultTemplateCh4.content;
-                if (instance2.props.animation) {
-                    setTransitionDuration$1([box, content2], duration);
-                    setVisibilityState$1([box, content2], "hidden");
+
+            function sequenceClose(code2) {
+                if (code2 === marker) {
+                    size2++;
+                    effects2.consume(code2);
+                    return sequenceClose;
+                }
+                if (size2 >= sizeOpen) {
+                    effects2.exit("codeFencedFenceSequence");
+                    return markdownSpace(code2) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code2) : sequenceCloseAfter(code2);
                 }
+                return nok2(code2);
             }
-            handleAriaContentAttribute();
-            handleAriaExpandedAttribute();
-            if (instance2.props.animation) {
-                if (getIsDefaultRenderFn()) {
-                    onTransitionedOut(duration, instance2.unmount);
+
+            function sequenceCloseAfter(code2) {
+                if (code2 === null || markdownLineEnding(code2)) {
+                    effects2.exit("codeFencedFence");
+                    return ok3(code2);
                 }
-            } else {
-                instance2.unmount();
+                return nok2(code2);
             }
         }
+    }
 
-        function hideWithInteractivity(event2) {
-            doc2.addEventListener("mousemove", debouncedOnMouseMove);
-            pushIfUnique$1(mouseMoveListeners$1, debouncedOnMouseMove);
-            debouncedOnMouseMove(event2);
-        }
+    function tokenizeNonLazyContinuation(effects, ok2, nok) {
+        const self2 = this;
+        return start2;
 
-        function unmount() {
-            if (instance2.state.isVisible) {
-                instance2.hide();
-            }
-            if (!instance2.state.isMounted) {
-                return;
-            }
-            destroyPopperInstance();
-            getNestedPopperTree().forEach(function(nestedPopper) {
-                nestedPopper._tippy.unmount();
-            });
-            if (popper2.parentNode) {
-                popper2.parentNode.removeChild(popper2);
+        function start2(code2) {
+            if (code2 === null) {
+                return nok(code2);
             }
-            mountedInstances$1 = mountedInstances$1.filter(function(i2) {
-                return i2 !== instance2;
-            });
-            instance2.state.isMounted = false;
-            invokeHook("onHidden", [instance2]);
+            effects.enter("lineEnding");
+            effects.consume(code2);
+            effects.exit("lineEnding");
+            return lineStart;
         }
 
-        function destroy() {
-            if (instance2.state.isDestroyed) {
-                return;
-            }
-            instance2.clearDelayTimeouts();
-            instance2.unmount();
-            removeListeners();
-            delete reference2._tippy;
-            instance2.state.isDestroyed = true;
-            invokeHook("onDestroy", [instance2]);
+        function lineStart(code2) {
+            return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
         }
     }
+    const codeIndented = {
+        name: "codeIndented",
+        tokenize: tokenizeCodeIndented
+    };
+    const furtherStart = {
+        tokenize: tokenizeFurtherStart,
+        partial: true
+    };
 
-    function tippy$1(targets, optionalProps) {
-        if (optionalProps === void 0) {
-            optionalProps = {};
+    function tokenizeCodeIndented(effects, ok2, nok) {
+        const self2 = this;
+        return start2;
+
+        function start2(code2) {
+            effects.enter("codeIndented");
+            return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
         }
-        var plugins2 = defaultProps$6.plugins.concat(optionalProps.plugins || []);
-        bindGlobalEventListeners$1();
-        var passedProps = Object.assign({}, optionalProps, {
-            plugins: plugins2
-        });
-        var elements = getArrayOfElements$1(targets);
-        var instances = elements.reduce(function(acc, reference2) {
-            var instance2 = reference2 && createTippy$1(reference2, passedProps);
-            if (instance2) {
-                acc.push(instance2);
+
+        function afterPrefix(code2) {
+            const tail = self2.events[self2.events.length - 1];
+            return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code2) : nok(code2);
+        }
+
+        function atBreak(code2) {
+            if (code2 === null) {
+                return after(code2);
             }
-            return acc;
-        }, []);
-        return isElement$3(targets) ? instances[0] : instances;
-    }
-    tippy$1.defaultProps = defaultProps$6;
-    tippy$1.setDefaultProps = setDefaultProps$1;
-    tippy$1.currentInput = currentInput$1;
-    tippy$1.setDefaultProps({
-        animation: false
-    });
+            if (markdownLineEnding(code2)) {
+                return effects.attempt(furtherStart, atBreak, after)(code2);
+            }
+            effects.enter("codeFlowValue");
+            return inside2(code2);
+        }
 
-    function _objectWithoutPropertiesLoose$5(source, excluded) {
-        if (source == null)
-            return {};
-        var target = {};
-        var sourceKeys = Object.keys(source);
-        var key, i2;
-        for (i2 = 0; i2 < sourceKeys.length; i2++) {
-            key = sourceKeys[i2];
-            if (excluded.indexOf(key) >= 0)
-                continue;
-            target[key] = source[key];
+        function inside2(code2) {
+            if (code2 === null || markdownLineEnding(code2)) {
+                effects.exit("codeFlowValue");
+                return atBreak(code2);
+            }
+            effects.consume(code2);
+            return inside2;
+        }
+
+        function after(code2) {
+            effects.exit("codeIndented");
+            return ok2(code2);
         }
-        return target;
     }
-    var isBrowser$2 = typeof window !== "undefined" && typeof document !== "undefined";
 
-    function preserveRef(ref2, node2) {
-        if (ref2) {
-            if (typeof ref2 === "function") {
-                ref2(node2);
+    function tokenizeFurtherStart(effects, ok2, nok) {
+        const self2 = this;
+        return furtherStart2;
+
+        function furtherStart2(code2) {
+            if (self2.parser.lazy[self2.now().line]) {
+                return nok(code2);
             }
-            if ({}.hasOwnProperty.call(ref2, "current")) {
-                ref2.current = node2;
+            if (markdownLineEnding(code2)) {
+                effects.enter("lineEnding");
+                effects.consume(code2);
+                effects.exit("lineEnding");
+                return furtherStart2;
             }
+            return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
         }
-    }
 
-    function ssrSafeCreateDiv() {
-        return isBrowser$2 && document.createElement("div");
+        function afterPrefix(code2) {
+            const tail = self2.events[self2.events.length - 1];
+            return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok2(code2) : markdownLineEnding(code2) ? furtherStart2(code2) : nok(code2);
+        }
     }
+    const codeText = {
+        name: "codeText",
+        tokenize: tokenizeCodeText,
+        resolve: resolveCodeText,
+        previous: previous$1
+    };
 
-    function toDataAttributes(attrs2) {
-        var dataAttrs = {
-            "data-placement": attrs2.placement
-        };
-        if (attrs2.referenceHidden) {
-            dataAttrs["data-reference-hidden"] = "";
+    function resolveCodeText(events2) {
+        let tailExitIndex = events2.length - 4;
+        let headEnterIndex = 3;
+        let index2;
+        let enter;
+        if ((events2[headEnterIndex][1].type === "lineEnding" || events2[headEnterIndex][1].type === "space") && (events2[tailExitIndex][1].type === "lineEnding" || events2[tailExitIndex][1].type === "space")) {
+            index2 = headEnterIndex;
+            while (++index2 < tailExitIndex) {
+                if (events2[index2][1].type === "codeTextData") {
+                    events2[headEnterIndex][1].type = "codeTextPadding";
+                    events2[tailExitIndex][1].type = "codeTextPadding";
+                    headEnterIndex += 2;
+                    tailExitIndex -= 2;
+                    break;
+                }
+            }
         }
-        if (attrs2.escaped) {
-            dataAttrs["data-escaped"] = "";
+        index2 = headEnterIndex - 1;
+        tailExitIndex++;
+        while (++index2 <= tailExitIndex) {
+            if (enter === void 0) {
+                if (index2 !== tailExitIndex && events2[index2][1].type !== "lineEnding") {
+                    enter = index2;
+                }
+            } else if (index2 === tailExitIndex || events2[index2][1].type === "lineEnding") {
+                events2[enter][1].type = "codeTextData";
+                if (index2 !== enter + 2) {
+                    events2[enter][1].end = events2[index2 - 1][1].end;
+                    events2.splice(enter + 2, index2 - enter - 2);
+                    tailExitIndex -= index2 - enter - 2;
+                    index2 = enter + 2;
+                }
+                enter = void 0;
+            }
         }
-        return dataAttrs;
+        return events2;
     }
 
-    function deepPreserveProps(instanceProps, componentProps) {
-        var _instanceProps$popper, _componentProps$poppe;
-        return Object.assign({}, componentProps, {
-            popperOptions: Object.assign({}, instanceProps.popperOptions, componentProps.popperOptions, {
-                modifiers: [].concat((((_instanceProps$popper = instanceProps.popperOptions) == null ? void 0 : _instanceProps$popper.modifiers) || []).filter(function(modifier) {
-                    return modifier.name.indexOf("tippy") >= 0;
-                }), ((_componentProps$poppe = componentProps.popperOptions) == null ? void 0 : _componentProps$poppe.modifiers) || [])
-            })
-        });
+    function previous$1(code2) {
+        return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
     }
-    var useIsomorphicLayoutEffect$4 = isBrowser$2 ? React.useLayoutEffect : React.useEffect;
 
-    function useMutableBox(initialValue) {
-        var ref2 = React.useRef();
-        if (!ref2.current) {
-            ref2.current = typeof initialValue === "function" ? initialValue() : initialValue;
+    function tokenizeCodeText(effects, ok2, nok) {
+        let sizeOpen = 0;
+        let size2;
+        let token;
+        return start2;
+
+        function start2(code2) {
+            effects.enter("codeText");
+            effects.enter("codeTextSequence");
+            return sequenceOpen(code2);
         }
-        return ref2.current;
-    }
 
-    function updateClassName(box, action, classNames) {
-        classNames.split(/\s+/).forEach(function(name2) {
-            if (name2) {
-                box.classList[action](name2);
+        function sequenceOpen(code2) {
+            if (code2 === 96) {
+                effects.consume(code2);
+                sizeOpen++;
+                return sequenceOpen;
             }
-        });
-    }
-    var classNamePlugin = {
-        name: "className",
-        defaultValue: "",
-        fn: function fn2(instance2) {
-            var box = instance2.popper.firstElementChild;
-            var isDefaultRenderFn = function isDefaultRenderFn2() {
-                var _instance$props$rende;
-                return !!((_instance$props$rende = instance2.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
-            };
+            effects.exit("codeTextSequence");
+            return between(code2);
+        }
 
-            function add2() {
-                if (instance2.props.className && !isDefaultRenderFn()) {
-                    return;
-                }
-                updateClassName(box, "add", instance2.props.className);
+        function between(code2) {
+            if (code2 === null) {
+                return nok(code2);
+            }
+            if (code2 === 32) {
+                effects.enter("space");
+                effects.consume(code2);
+                effects.exit("space");
+                return between;
+            }
+            if (code2 === 96) {
+                token = effects.enter("codeTextSequence");
+                size2 = 0;
+                return sequenceClose(code2);
+            }
+            if (markdownLineEnding(code2)) {
+                effects.enter("lineEnding");
+                effects.consume(code2);
+                effects.exit("lineEnding");
+                return between;
             }
+            effects.enter("codeTextData");
+            return data2(code2);
+        }
 
-            function remove2() {
-                if (isDefaultRenderFn()) {
-                    updateClassName(box, "remove", instance2.props.className);
-                }
+        function data2(code2) {
+            if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
+                effects.exit("codeTextData");
+                return between(code2);
             }
-            return {
-                onCreate: add2,
-                onBeforeUpdate: remove2,
-                onAfterUpdate: add2
-            };
+            effects.consume(code2);
+            return data2;
         }
-    };
 
-    function TippyGenerator(tippy2) {
-        function Tippy2(_ref2) {
-            var children2 = _ref2.children,
-                content2 = _ref2.content,
-                visible = _ref2.visible,
-                singleton = _ref2.singleton,
-                render2 = _ref2.render,
-                reference2 = _ref2.reference,
-                _ref$disabled = _ref2.disabled,
-                disabled2 = _ref$disabled === void 0 ? false : _ref$disabled,
-                _ref$ignoreAttributes = _ref2.ignoreAttributes,
-                ignoreAttributes = _ref$ignoreAttributes === void 0 ? true : _ref$ignoreAttributes;
-            _ref2.__source;
-            _ref2.__self;
-            var restOfNativeProps = _objectWithoutPropertiesLoose$5(_ref2, ["children", "content", "visible", "singleton", "render", "reference", "disabled", "ignoreAttributes", "__source", "__self"]);
-            var isControlledMode = visible !== void 0;
-            var isSingletonMode = singleton !== void 0;
-            var _useState = React.useState(false),
-                mounted = _useState[0],
-                setMounted = _useState[1];
-            var _useState2 = React.useState({}),
-                attrs2 = _useState2[0],
-                setAttrs = _useState2[1];
-            var _useState3 = React.useState(),
-                singletonContent = _useState3[0],
-                setSingletonContent = _useState3[1];
-            var mutableBox = useMutableBox(function() {
-                return {
-                    container: ssrSafeCreateDiv(),
-                    renders: 1
-                };
-            });
-            var props = Object.assign({
-                ignoreAttributes
-            }, restOfNativeProps, {
-                content: mutableBox.container
-            });
-            if (isControlledMode) {
-                props.trigger = "manual";
-                props.hideOnClick = false;
+        function sequenceClose(code2) {
+            if (code2 === 96) {
+                effects.consume(code2);
+                size2++;
+                return sequenceClose;
             }
-            if (isSingletonMode) {
-                disabled2 = true;
+            if (size2 === sizeOpen) {
+                effects.exit("codeTextSequence");
+                effects.exit("codeText");
+                return ok2(code2);
             }
-            var computedProps = props;
-            var plugins2 = props.plugins || [];
-            if (render2) {
-                computedProps = Object.assign({}, props, {
-                    plugins: isSingletonMode ? [].concat(plugins2, [{
-                        fn: function fn2() {
-                            return {
-                                onTrigger: function onTrigger(_2, event2) {
-                                    var _singleton$data$child = singleton.data.children.find(function(_ref22) {
-                                            var instance2 = _ref22.instance;
-                                            return instance2.reference === event2.currentTarget;
-                                        }),
-                                        content3 = _singleton$data$child.content;
-                                    setSingletonContent(content3);
-                                }
-                            };
-                        }
-                    }]) : plugins2,
-                    render: function render3() {
-                        return {
-                            popper: mutableBox.container
-                        };
-                    }
-                });
+            token.type = "codeTextData";
+            return data2(code2);
+        }
+    }
+
+    function subtokenize(events2) {
+        const jumps = {};
+        let index2 = -1;
+        let event2;
+        let lineIndex;
+        let otherIndex;
+        let otherEvent;
+        let parameters;
+        let subevents;
+        let more;
+        while (++index2 < events2.length) {
+            while (index2 in jumps) {
+                index2 = jumps[index2];
             }
-            var deps = [reference2].concat(children2 ? [children2.type] : []);
-            useIsomorphicLayoutEffect$4(function() {
-                var element2 = reference2;
-                if (reference2 && reference2.hasOwnProperty("current")) {
-                    element2 = reference2.current;
-                }
-                var instance2 = tippy2(element2 || mutableBox.ref || ssrSafeCreateDiv(), Object.assign({}, computedProps, {
-                    plugins: [classNamePlugin].concat(props.plugins || [])
-                }));
-                mutableBox.instance = instance2;
-                if (disabled2) {
-                    instance2.disable();
-                }
-                if (visible) {
-                    instance2.show();
-                }
-                if (isSingletonMode) {
-                    singleton.hook({
-                        instance: instance2,
-                        content: content2,
-                        props: computedProps
-                    });
+            event2 = events2[index2];
+            if (index2 && event2[1].type === "chunkFlow" && events2[index2 - 1][1].type === "listItemPrefix") {
+                subevents = event2[1]._tokenizer.events;
+                otherIndex = 0;
+                if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
+                    otherIndex += 2;
                 }
-                setMounted(true);
-                return function() {
-                    instance2.destroy();
-                    singleton == null ? void 0 : singleton.cleanup(instance2);
-                };
-            }, deps);
-            useIsomorphicLayoutEffect$4(function() {
-                if (mutableBox.renders === 1) {
-                    mutableBox.renders++;
-                    return;
+                if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
+                    while (++otherIndex < subevents.length) {
+                        if (subevents[otherIndex][1].type === "content") {
+                            break;
+                        }
+                        if (subevents[otherIndex][1].type === "chunkText") {
+                            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
+                            otherIndex++;
+                        }
+                    }
                 }
-                var instance2 = mutableBox.instance;
-                instance2.setProps(deepPreserveProps(instance2.props, computedProps));
-                if (disabled2) {
-                    instance2.disable();
-                } else {
-                    instance2.enable();
+            }
+            if (event2[0] === "enter") {
+                if (event2[1].contentType) {
+                    Object.assign(jumps, subcontent(events2, index2));
+                    index2 = jumps[index2];
+                    more = true;
                 }
-                if (isControlledMode) {
-                    if (visible) {
-                        instance2.show();
+            } else if (event2[1]._container) {
+                otherIndex = index2;
+                lineIndex = void 0;
+                while (otherIndex--) {
+                    otherEvent = events2[otherIndex];
+                    if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
+                        if (otherEvent[0] === "enter") {
+                            if (lineIndex) {
+                                events2[lineIndex][1].type = "lineEndingBlank";
+                            }
+                            otherEvent[1].type = "lineEnding";
+                            lineIndex = otherIndex;
+                        }
                     } else {
-                        instance2.hide();
+                        break;
                     }
                 }
-                if (isSingletonMode) {
-                    singleton.hook({
-                        instance: instance2,
-                        content: content2,
-                        props: computedProps
-                    });
+                if (lineIndex) {
+                    event2[1].end = Object.assign({}, events2[lineIndex][1].start);
+                    parameters = events2.slice(lineIndex, index2);
+                    parameters.unshift(event2);
+                    splice(events2, lineIndex, index2 - lineIndex + 1, parameters);
                 }
-            });
-            useIsomorphicLayoutEffect$4(function() {
-                var _instance$props$poppe;
-                if (!render2) {
-                    return;
+            }
+        }
+        return !more;
+    }
+
+    function subcontent(events2, eventIndex) {
+        const token = events2[eventIndex][1];
+        const context2 = events2[eventIndex][2];
+        let startPosition = eventIndex - 1;
+        const startPositions = [];
+        const tokenizer2 = token._tokenizer || context2.parser[token.contentType](token.start);
+        const childEvents = tokenizer2.events;
+        const jumps = [];
+        const gaps = {};
+        let stream;
+        let previous2;
+        let index2 = -1;
+        let current2 = token;
+        let adjust = 0;
+        let start2 = 0;
+        const breaks = [start2];
+        while (current2) {
+            while (events2[++startPosition][1] !== current2) {}
+            startPositions.push(startPosition);
+            if (!current2._tokenizer) {
+                stream = context2.sliceStream(current2);
+                if (!current2.next) {
+                    stream.push(null);
                 }
-                var instance2 = mutableBox.instance;
-                instance2.setProps({
-                    popperOptions: Object.assign({}, instance2.props.popperOptions, {
-                        modifiers: [].concat(((_instance$props$poppe = instance2.props.popperOptions) == null ? void 0 : _instance$props$poppe.modifiers) || [], [{
-                            name: "$$tippyReact",
-                            enabled: true,
-                            phase: "beforeWrite",
-                            requires: ["computeStyles"],
-                            fn: function fn2(_ref3) {
-                                var _state$modifiersData;
-                                var state = _ref3.state;
-                                var hideData = (_state$modifiersData = state.modifiersData) == null ? void 0 : _state$modifiersData.hide;
-                                if (attrs2.placement !== state.placement || attrs2.referenceHidden !== (hideData == null ? void 0 : hideData.isReferenceHidden) || attrs2.escaped !== (hideData == null ? void 0 : hideData.hasPopperEscaped)) {
-                                    setAttrs({
-                                        placement: state.placement,
-                                        referenceHidden: hideData == null ? void 0 : hideData.isReferenceHidden,
-                                        escaped: hideData == null ? void 0 : hideData.hasPopperEscaped
-                                    });
-                                }
-                                state.attributes.popper = {};
-                            }
-                        }])
-                    })
-                });
-            }, [attrs2.placement, attrs2.referenceHidden, attrs2.escaped].concat(deps));
-            return /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, children2 ? /* @__PURE__ */ React.cloneElement(children2, {
-                ref: function ref2(node2) {
-                    mutableBox.ref = node2;
-                    preserveRef(children2.ref, node2);
+                if (previous2) {
+                    tokenizer2.defineSkip(current2.start);
                 }
-            }) : null, mounted && /* @__PURE__ */ ReactDOM.createPortal(render2 ? render2(toDataAttributes(attrs2), singletonContent) : content2, mutableBox.container));
+                if (current2._isInFirstContentOfListItem) {
+                    tokenizer2._gfmTasklistFirstContentOfListItem = true;
+                }
+                tokenizer2.write(stream);
+                if (current2._isInFirstContentOfListItem) {
+                    tokenizer2._gfmTasklistFirstContentOfListItem = void 0;
+                }
+            }
+            previous2 = current2;
+            current2 = current2.next;
         }
-        return Tippy2;
+        current2 = token;
+        while (++index2 < childEvents.length) {
+            if (childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line) {
+                start2 = index2 + 1;
+                breaks.push(start2);
+                current2._tokenizer = void 0;
+                current2.previous = void 0;
+                current2 = current2.next;
+            }
+        }
+        tokenizer2.events = [];
+        if (current2) {
+            current2._tokenizer = void 0;
+            current2.previous = void 0;
+        } else {
+            breaks.pop();
+        }
+        index2 = breaks.length;
+        while (index2--) {
+            const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
+            const start3 = startPositions.pop();
+            jumps.unshift([start3, start3 + slice.length - 1]);
+            splice(events2, start3, 2, slice);
+        }
+        index2 = -1;
+        while (++index2 < jumps.length) {
+            gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
+            adjust += jumps[index2][1] - jumps[index2][0] - 1;
+        }
+        return gaps;
     }
-    var forwardRef = function(Tippy2, defaultProps2) {
-        return /* @__PURE__ */ React.forwardRef(function TippyWrapper(_ref2, _ref22) {
-            var children2 = _ref2.children,
-                props = _objectWithoutPropertiesLoose$5(_ref2, ["children"]);
-            return /* @__PURE__ */ React__default.default.createElement(Tippy2, Object.assign({}, defaultProps2, props), children2 ? /* @__PURE__ */ React.cloneElement(children2, {
-                ref: function ref2(node2) {
-                    preserveRef(_ref22, node2);
-                    preserveRef(children2.ref, node2);
-                }
-            }) : null);
-        });
+    const content$1 = {
+        tokenize: tokenizeContent,
+        resolve: resolveContent
     };
-    var headless = /* @__PURE__ */ forwardRef( /* @__PURE__ */ TippyGenerator(tippy$1), {
-        render: function render2() {
-            return "";
-        }
-    });
-    const Tippy = headless;
-    var BOX_CLASS = "tippy-box";
-    var CONTENT_CLASS = "tippy-content";
-    var BACKDROP_CLASS = "tippy-backdrop";
-    var ARROW_CLASS = "tippy-arrow";
-    var SVG_ARROW_CLASS = "tippy-svg-arrow";
-    var TOUCH_OPTIONS = {
-        passive: true,
-        capture: true
+    const continuationConstruct = {
+        tokenize: tokenizeContinuation,
+        partial: true
     };
 
-    function getValueAtIndexOrReturn(value, index2, defaultValue2) {
-        if (Array.isArray(value)) {
-            var v2 = value[index2];
-            return v2 == null ? Array.isArray(defaultValue2) ? defaultValue2[index2] : defaultValue2 : v2;
-        }
-        return value;
+    function resolveContent(events2) {
+        subtokenize(events2);
+        return events2;
     }
 
-    function isType(value, type2) {
-        var str = {}.toString.call(value);
-        return str.indexOf("[object") === 0 && str.indexOf(type2 + "]") > -1;
-    }
+    function tokenizeContent(effects, ok2) {
+        let previous2;
+        return chunkStart;
 
-    function invokeWithArgsOrReturn(value, args) {
-        return typeof value === "function" ? value.apply(void 0, args) : value;
-    }
+        function chunkStart(code2) {
+            effects.enter("content");
+            previous2 = effects.enter("chunkContent", {
+                contentType: "content"
+            });
+            return chunkInside(code2);
+        }
 
-    function debounce$3(fn2, ms2) {
-        if (ms2 === 0) {
-            return fn2;
+        function chunkInside(code2) {
+            if (code2 === null) {
+                return contentEnd(code2);
+            }
+            if (markdownLineEnding(code2)) {
+                return effects.check(
+                    continuationConstruct,
+                    contentContinue,
+                    contentEnd
+                )(code2);
+            }
+            effects.consume(code2);
+            return chunkInside;
         }
-        var timeout2;
-        return function(arg) {
-            clearTimeout(timeout2);
-            timeout2 = setTimeout(function() {
-                fn2(arg);
-            }, ms2);
-        };
-    }
 
-    function splitBySpaces(value) {
-        return value.split(/\s+/).filter(Boolean);
-    }
+        function contentEnd(code2) {
+            effects.exit("chunkContent");
+            effects.exit("content");
+            return ok2(code2);
+        }
 
-    function normalizeToArray(value) {
-        return [].concat(value);
+        function contentContinue(code2) {
+            effects.consume(code2);
+            effects.exit("chunkContent");
+            previous2.next = effects.enter("chunkContent", {
+                contentType: "content",
+                previous: previous2
+            });
+            previous2 = previous2.next;
+            return chunkInside;
+        }
     }
 
-    function pushIfUnique(arr, value) {
-        if (arr.indexOf(value) === -1) {
-            arr.push(value);
+    function tokenizeContinuation(effects, ok2, nok) {
+        const self2 = this;
+        return startLookahead;
+
+        function startLookahead(code2) {
+            effects.exit("chunkContent");
+            effects.enter("lineEnding");
+            effects.consume(code2);
+            effects.exit("lineEnding");
+            return factorySpace(effects, prefixed, "linePrefix");
         }
-    }
 
-    function unique(arr) {
-        return arr.filter(function(item, index2) {
-            return arr.indexOf(item) === index2;
-        });
+        function prefixed(code2) {
+            if (code2 === null || markdownLineEnding(code2)) {
+                return nok(code2);
+            }
+            const tail = self2.events[self2.events.length - 1];
+            if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
+                return ok2(code2);
+            }
+            return effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code2);
+        }
     }
 
-    function getBasePlacement$1(placement) {
-        return placement.split("-")[0];
-    }
+    function factoryDestination(effects, ok2, nok, type2, literalType, literalMarkerType, rawType, stringType, max2) {
+        const limit = max2 || Number.POSITIVE_INFINITY;
+        let balance = 0;
+        return start2;
 
-    function arrayFrom(value) {
-        return [].slice.call(value);
-    }
+        function start2(code2) {
+            if (code2 === 60) {
+                effects.enter(type2);
+                effects.enter(literalType);
+                effects.enter(literalMarkerType);
+                effects.consume(code2);
+                effects.exit(literalMarkerType);
+                return enclosedBefore;
+            }
+            if (code2 === null || code2 === 32 || code2 === 41 || asciiControl(code2)) {
+                return nok(code2);
+            }
+            effects.enter(type2);
+            effects.enter(rawType);
+            effects.enter(stringType);
+            effects.enter("chunkString", {
+                contentType: "string"
+            });
+            return raw2(code2);
+        }
 
-    function removeUndefinedProps(obj) {
-        return Object.keys(obj).reduce(function(acc, key) {
-            if (obj[key] !== void 0) {
-                acc[key] = obj[key];
+        function enclosedBefore(code2) {
+            if (code2 === 62) {
+                effects.enter(literalMarkerType);
+                effects.consume(code2);
+                effects.exit(literalMarkerType);
+                effects.exit(literalType);
+                effects.exit(type2);
+                return ok2;
             }
-            return acc;
-        }, {});
-    }
+            effects.enter(stringType);
+            effects.enter("chunkString", {
+                contentType: "string"
+            });
+            return enclosed(code2);
+        }
 
-    function div() {
-        return document.createElement("div");
-    }
+        function enclosed(code2) {
+            if (code2 === 62) {
+                effects.exit("chunkString");
+                effects.exit(stringType);
+                return enclosedBefore(code2);
+            }
+            if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
+                return nok(code2);
+            }
+            effects.consume(code2);
+            return code2 === 92 ? enclosedEscape : enclosed;
+        }
 
-    function isElement$2(value) {
-        return ["Element", "Fragment"].some(function(type2) {
-            return isType(value, type2);
-        });
-    }
+        function enclosedEscape(code2) {
+            if (code2 === 60 || code2 === 62 || code2 === 92) {
+                effects.consume(code2);
+                return enclosed;
+            }
+            return enclosed(code2);
+        }
 
-    function isNodeList$1(value) {
-        return isType(value, "NodeList");
-    }
+        function raw2(code2) {
+            if (!balance && (code2 === null || code2 === 41 || markdownLineEndingOrSpace(code2))) {
+                effects.exit("chunkString");
+                effects.exit(stringType);
+                effects.exit(rawType);
+                effects.exit(type2);
+                return ok2(code2);
+            }
+            if (balance < limit && code2 === 40) {
+                effects.consume(code2);
+                balance++;
+                return raw2;
+            }
+            if (code2 === 41) {
+                effects.consume(code2);
+                balance--;
+                return raw2;
+            }
+            if (code2 === null || code2 === 32 || code2 === 40 || asciiControl(code2)) {
+                return nok(code2);
+            }
+            effects.consume(code2);
+            return code2 === 92 ? rawEscape : raw2;
+        }
 
-    function isMouseEvent(value) {
-        return isType(value, "MouseEvent");
+        function rawEscape(code2) {
+            if (code2 === 40 || code2 === 41 || code2 === 92) {
+                effects.consume(code2);
+                return raw2;
+            }
+            return raw2(code2);
+        }
     }
 
-    function isReferenceElement(value) {
-        return !!(value && value._tippy && value._tippy.reference === value);
-    }
+    function factoryLabel(effects, ok2, nok, type2, markerType, stringType) {
+        const self2 = this;
+        let size2 = 0;
+        let seen;
+        return start2;
 
-    function getArrayOfElements(value) {
-        if (isElement$2(value)) {
-            return [value];
-        }
-        if (isNodeList$1(value)) {
-            return arrayFrom(value);
+        function start2(code2) {
+            effects.enter(type2);
+            effects.enter(markerType);
+            effects.consume(code2);
+            effects.exit(markerType);
+            effects.enter(stringType);
+            return atBreak;
         }
-        if (Array.isArray(value)) {
-            return value;
+
+        function atBreak(code2) {
+            if (size2 > 999 || code2 === null || code2 === 91 || code2 === 93 && !seen || code2 === 94 && !size2 && "_hiddenFootnoteSupport" in self2.parser.constructs) {
+                return nok(code2);
+            }
+            if (code2 === 93) {
+                effects.exit(stringType);
+                effects.enter(markerType);
+                effects.consume(code2);
+                effects.exit(markerType);
+                effects.exit(type2);
+                return ok2;
+            }
+            if (markdownLineEnding(code2)) {
+                effects.enter("lineEnding");
+                effects.consume(code2);
+                effects.exit("lineEnding");
+                return atBreak;
+            }
+            effects.enter("chunkString", {
+                contentType: "string"
+            });
+            return labelInside(code2);
         }
-        return arrayFrom(document.querySelectorAll(value));
-    }
 
-    function setTransitionDuration(els, value) {
-        els.forEach(function(el) {
-            if (el) {
-                el.style.transitionDuration = value + "ms";
+        function labelInside(code2) {
+            if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size2++ > 999) {
+                effects.exit("chunkString");
+                return atBreak(code2);
             }
-        });
-    }
+            effects.consume(code2);
+            if (!seen)
+                seen = !markdownSpace(code2);
+            return code2 === 92 ? labelEscape : labelInside;
+        }
 
-    function setVisibilityState(els, state) {
-        els.forEach(function(el) {
-            if (el) {
-                el.setAttribute("data-state", state);
+        function labelEscape(code2) {
+            if (code2 === 91 || code2 === 92 || code2 === 93) {
+                effects.consume(code2);
+                size2++;
+                return labelInside;
             }
-        });
+            return labelInside(code2);
+        }
     }
 
-    function getOwnerDocument(elementOrElements) {
-        var _normalizeToArray = normalizeToArray(elementOrElements),
-            element2 = _normalizeToArray[0];
-        return element2 ? element2.ownerDocument || document : document;
-    }
+    function factoryTitle(effects, ok2, nok, type2, markerType, stringType) {
+        let marker;
+        return start2;
 
-    function isCursorOutsideInteractiveBorder(popperTreeData, event2) {
-        var clientX = event2.clientX,
-            clientY = event2.clientY;
-        return popperTreeData.every(function(_ref2) {
-            var popperRect = _ref2.popperRect,
-                popperState = _ref2.popperState,
-                props = _ref2.props;
-            var interactiveBorder = props.interactiveBorder;
-            var basePlacement = getBasePlacement$1(popperState.placement);
-            var offsetData = popperState.modifiersData.offset;
-            if (!offsetData) {
-                return true;
+        function start2(code2) {
+            if (code2 === 34 || code2 === 39 || code2 === 40) {
+                effects.enter(type2);
+                effects.enter(markerType);
+                effects.consume(code2);
+                effects.exit(markerType);
+                marker = code2 === 40 ? 41 : code2;
+                return begin2;
             }
-            var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
-            var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
-            var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
-            var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
-            var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
-            var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
-            var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
-            var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
-            return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
-        });
-    }
-
-    function updateTransitionEndListener(box, action, listener2) {
-        var method = action + "EventListener";
-        ["transitionend", "webkitTransitionEnd"].forEach(function(event2) {
-            box[method](event2, listener2);
-        });
-    }
-    var currentInput = {
-        isTouch: false
-    };
-    var lastMouseMoveTime = 0;
+            return nok(code2);
+        }
 
-    function onDocumentTouchStart() {
-        if (currentInput.isTouch) {
-            return;
+        function begin2(code2) {
+            if (code2 === marker) {
+                effects.enter(markerType);
+                effects.consume(code2);
+                effects.exit(markerType);
+                effects.exit(type2);
+                return ok2;
+            }
+            effects.enter(stringType);
+            return atBreak(code2);
         }
-        currentInput.isTouch = true;
-        if (window.performance) {
-            document.addEventListener("mousemove", onDocumentMouseMove);
+
+        function atBreak(code2) {
+            if (code2 === marker) {
+                effects.exit(stringType);
+                return begin2(marker);
+            }
+            if (code2 === null) {
+                return nok(code2);
+            }
+            if (markdownLineEnding(code2)) {
+                effects.enter("lineEnding");
+                effects.consume(code2);
+                effects.exit("lineEnding");
+                return factorySpace(effects, atBreak, "linePrefix");
+            }
+            effects.enter("chunkString", {
+                contentType: "string"
+            });
+            return inside2(code2);
         }
-    }
 
-    function onDocumentMouseMove() {
-        var now2 = performance.now();
-        if (now2 - lastMouseMoveTime < 20) {
-            currentInput.isTouch = false;
-            document.removeEventListener("mousemove", onDocumentMouseMove);
+        function inside2(code2) {
+            if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
+                effects.exit("chunkString");
+                return atBreak(code2);
+            }
+            effects.consume(code2);
+            return code2 === 92 ? escape2 : inside2;
         }
-        lastMouseMoveTime = now2;
-    }
 
-    function onWindowBlur() {
-        var activeElement = document.activeElement;
-        if (isReferenceElement(activeElement)) {
-            var instance2 = activeElement._tippy;
-            if (activeElement.blur && !instance2.state.isVisible) {
-                activeElement.blur();
+        function escape2(code2) {
+            if (code2 === marker || code2 === 92) {
+                effects.consume(code2);
+                return inside2;
             }
+            return inside2(code2);
         }
     }
 
-    function bindGlobalEventListeners() {
-        document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
-        window.addEventListener("blur", onWindowBlur);
+    function factoryWhitespace(effects, ok2) {
+        let seen;
+        return start2;
+
+        function start2(code2) {
+            if (markdownLineEnding(code2)) {
+                effects.enter("lineEnding");
+                effects.consume(code2);
+                effects.exit("lineEnding");
+                seen = true;
+                return start2;
+            }
+            if (markdownSpace(code2)) {
+                return factorySpace(
+                    effects,
+                    start2,
+                    seen ? "linePrefix" : "lineSuffix"
+                )(code2);
+            }
+            return ok2(code2);
+        }
     }
-    var isBrowser$1 = typeof window !== "undefined" && typeof document !== "undefined";
-    var ua = isBrowser$1 ? navigator.userAgent : "";
-    var isIE = /MSIE |Trident\//.test(ua);
-    var pluginProps = {
-        animateFill: false,
-        followCursor: false,
-        inlinePositioning: false,
-        sticky: false
-    };
-    var renderProps = {
-        allowHTML: false,
-        animation: "fade",
-        arrow: true,
-        content: "",
-        inertia: false,
-        maxWidth: 350,
-        role: "tooltip",
-        theme: "",
-        zIndex: 9999
+    const definition$1 = {
+        name: "definition",
+        tokenize: tokenizeDefinition
     };
-    var defaultProps$5 = Object.assign({
-        appendTo: function appendTo() {
-            return document.body;
-        },
-        aria: {
-            content: "auto",
-            expanded: "auto"
-        },
-        delay: 0,
-        duration: [300, 250],
-        getReferenceClientRect: null,
-        hideOnClick: true,
-        ignoreAttributes: false,
-        interactive: false,
-        interactiveBorder: 2,
-        interactiveDebounce: 0,
-        moveTransition: "",
-        offset: [0, 10],
-        onAfterUpdate: function onAfterUpdate() {},
-        onBeforeUpdate: function onBeforeUpdate() {},
-        onCreate: function onCreate() {},
-        onDestroy: function onDestroy() {},
-        onHidden: function onHidden() {},
-        onHide: function onHide() {},
-        onMount: function onMount() {},
-        onShow: function onShow() {},
-        onShown: function onShown() {},
-        onTrigger: function onTrigger() {},
-        onUntrigger: function onUntrigger() {},
-        onClickOutside: function onClickOutside() {},
-        placement: "top",
-        plugins: [],
-        popperOptions: {},
-        render: null,
-        showOnCreate: false,
-        touch: true,
-        trigger: "mouseenter focus",
-        triggerTarget: null
-    }, pluginProps, {}, renderProps);
-    var defaultKeys = Object.keys(defaultProps$5);
-    var setDefaultProps = function setDefaultProps2(partialProps) {
-        var keys2 = Object.keys(partialProps);
-        keys2.forEach(function(key) {
-            defaultProps$5[key] = partialProps[key];
-        });
+    const titleBefore = {
+        tokenize: tokenizeTitleBefore,
+        partial: true
     };
 
-    function getExtendedPassedProps(passedProps) {
-        var plugins2 = passedProps.plugins || [];
-        var pluginProps2 = plugins2.reduce(function(acc, plugin) {
-            var name2 = plugin.name,
-                defaultValue2 = plugin.defaultValue;
-            if (name2) {
-                acc[name2] = passedProps[name2] !== void 0 ? passedProps[name2] : defaultValue2;
-            }
-            return acc;
-        }, {});
-        return Object.assign({}, passedProps, {}, pluginProps2);
-    }
+    function tokenizeDefinition(effects, ok2, nok) {
+        const self2 = this;
+        let identifier;
+        return start2;
 
-    function getDataAttributeProps(reference2, plugins2) {
-        var propKeys = plugins2 ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps$5, {
-            plugins: plugins2
-        }))) : defaultKeys;
-        var props = propKeys.reduce(function(acc, key) {
-            var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
-            if (!valueAsString) {
-                return acc;
+        function start2(code2) {
+            effects.enter("definition");
+            return before(code2);
+        }
+
+        function before(code2) {
+            return factoryLabel.call(
+                self2,
+                effects,
+                labelAfter,
+                nok,
+                "definitionLabel",
+                "definitionLabelMarker",
+                "definitionLabelString"
+            )(code2);
+        }
+
+        function labelAfter(code2) {
+            identifier = normalizeIdentifier(
+                self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
+            );
+            if (code2 === 58) {
+                effects.enter("definitionMarker");
+                effects.consume(code2);
+                effects.exit("definitionMarker");
+                return markerAfter;
             }
-            if (key === "content") {
-                acc[key] = valueAsString;
-            } else {
-                try {
-                    acc[key] = JSON.parse(valueAsString);
-                } catch (e3) {
-                    acc[key] = valueAsString;
-                }
+            return nok(code2);
+        }
+
+        function markerAfter(code2) {
+            return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, destinationBefore)(code2) : destinationBefore(code2);
+        }
+
+        function destinationBefore(code2) {
+            return factoryDestination(
+                effects,
+                destinationAfter,
+                nok,
+                "definitionDestination",
+                "definitionDestinationLiteral",
+                "definitionDestinationLiteralMarker",
+                "definitionDestinationRaw",
+                "definitionDestinationString"
+            )(code2);
+        }
+
+        function destinationAfter(code2) {
+            return effects.attempt(titleBefore, after, after)(code2);
+        }
+
+        function after(code2) {
+            return markdownSpace(code2) ? factorySpace(effects, afterWhitespace, "whitespace")(code2) : afterWhitespace(code2);
+        }
+
+        function afterWhitespace(code2) {
+            if (code2 === null || markdownLineEnding(code2)) {
+                effects.exit("definition");
+                self2.parser.defined.push(identifier);
+                return ok2(code2);
             }
-            return acc;
-        }, {});
-        return props;
+            return nok(code2);
+        }
     }
 
-    function evaluateProps(reference2, props) {
-        var out = Object.assign({}, props, {
-            content: invokeWithArgsOrReturn(props.content, [reference2])
-        }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
-        out.aria = Object.assign({}, defaultProps$5.aria, {}, out.aria);
-        out.aria = {
-            expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
-            content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
-        };
-        return out;
+    function tokenizeTitleBefore(effects, ok2, nok) {
+        return titleBefore2;
+
+        function titleBefore2(code2) {
+            return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, beforeMarker)(code2) : nok(code2);
+        }
+
+        function beforeMarker(code2) {
+            return factoryTitle(
+                effects,
+                titleAfter,
+                nok,
+                "definitionTitle",
+                "definitionTitleMarker",
+                "definitionTitleString"
+            )(code2);
+        }
+
+        function titleAfter(code2) {
+            return markdownSpace(code2) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code2) : titleAfterOptionalWhitespace(code2);
+        }
+
+        function titleAfterOptionalWhitespace(code2) {
+            return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
+        }
     }
-    var innerHTML = function innerHTML2() {
-        return "innerHTML";
+    const hardBreakEscape = {
+        name: "hardBreakEscape",
+        tokenize: tokenizeHardBreakEscape
     };
 
-    function dangerouslySetInnerHTML(element2, html2) {
-        element2[innerHTML()] = html2;
-    }
+    function tokenizeHardBreakEscape(effects, ok2, nok) {
+        return start2;
 
-    function createArrowElement(value) {
-        var arrow2 = div();
-        if (value === true) {
-            arrow2.className = ARROW_CLASS;
-        } else {
-            arrow2.className = SVG_ARROW_CLASS;
-            if (isElement$2(value)) {
-                arrow2.appendChild(value);
-            } else {
-                dangerouslySetInnerHTML(arrow2, value);
-            }
+        function start2(code2) {
+            effects.enter("hardBreakEscape");
+            effects.consume(code2);
+            return after;
         }
-        return arrow2;
-    }
 
-    function setContent(content2, props) {
-        if (isElement$2(props.content)) {
-            dangerouslySetInnerHTML(content2, "");
-            content2.appendChild(props.content);
-        } else if (typeof props.content !== "function") {
-            if (props.allowHTML) {
-                dangerouslySetInnerHTML(content2, props.content);
-            } else {
-                content2.textContent = props.content;
+        function after(code2) {
+            if (markdownLineEnding(code2)) {
+                effects.exit("hardBreakEscape");
+                return ok2(code2);
             }
+            return nok(code2);
         }
     }
+    const headingAtx = {
+        name: "headingAtx",
+        tokenize: tokenizeHeadingAtx,
+        resolve: resolveHeadingAtx
+    };
 
-    function getChildren$1(popper2) {
-        var box = popper2.firstElementChild;
-        var boxChildren = arrayFrom(box.children);
-        return {
-            box,
-            content: boxChildren.find(function(node2) {
-                return node2.classList.contains(CONTENT_CLASS);
-            }),
-            arrow: boxChildren.find(function(node2) {
-                return node2.classList.contains(ARROW_CLASS) || node2.classList.contains(SVG_ARROW_CLASS);
-            }),
-            backdrop: boxChildren.find(function(node2) {
-                return node2.classList.contains(BACKDROP_CLASS);
-            })
-        };
+    function resolveHeadingAtx(events2, context2) {
+        let contentEnd = events2.length - 2;
+        let contentStart = 3;
+        let content2;
+        let text2;
+        if (events2[contentStart][1].type === "whitespace") {
+            contentStart += 2;
+        }
+        if (contentEnd - 2 > contentStart && events2[contentEnd][1].type === "whitespace") {
+            contentEnd -= 2;
+        }
+        if (events2[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events2[contentEnd - 2][1].type === "whitespace")) {
+            contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
+        }
+        if (contentEnd > contentStart) {
+            content2 = {
+                type: "atxHeadingText",
+                start: events2[contentStart][1].start,
+                end: events2[contentEnd][1].end
+            };
+            text2 = {
+                type: "chunkText",
+                start: events2[contentStart][1].start,
+                end: events2[contentEnd][1].end,
+                contentType: "text"
+            };
+            splice(events2, contentStart, contentEnd - contentStart + 1, [
+                ["enter", content2, context2],
+                ["enter", text2, context2],
+                ["exit", text2, context2],
+                ["exit", content2, context2]
+            ]);
+        }
+        return events2;
     }
 
-    function render(instance2) {
-        var popper2 = div();
-        var box = div();
-        box.className = BOX_CLASS;
-        box.setAttribute("data-state", "hidden");
-        box.setAttribute("tabindex", "-1");
-        var content2 = div();
-        content2.className = CONTENT_CLASS;
-        content2.setAttribute("data-state", "hidden");
-        setContent(content2, instance2.props);
-        popper2.appendChild(box);
-        box.appendChild(content2);
-        onUpdate(instance2.props, instance2.props);
+    function tokenizeHeadingAtx(effects, ok2, nok) {
+        let size2 = 0;
+        return start2;
 
-        function onUpdate(prevProps, nextProps) {
-            var _getChildren = getChildren$1(popper2),
-                box2 = _getChildren.box,
-                content3 = _getChildren.content,
-                arrow2 = _getChildren.arrow;
-            if (nextProps.theme) {
-                box2.setAttribute("data-theme", nextProps.theme);
-            } else {
-                box2.removeAttribute("data-theme");
+        function start2(code2) {
+            effects.enter("atxHeading");
+            return before(code2);
+        }
+
+        function before(code2) {
+            effects.enter("atxHeadingSequence");
+            return sequenceOpen(code2);
+        }
+
+        function sequenceOpen(code2) {
+            if (code2 === 35 && size2++ < 6) {
+                effects.consume(code2);
+                return sequenceOpen;
             }
-            if (typeof nextProps.animation === "string") {
-                box2.setAttribute("data-animation", nextProps.animation);
-            } else {
-                box2.removeAttribute("data-animation");
+            if (code2 === null || markdownLineEndingOrSpace(code2)) {
+                effects.exit("atxHeadingSequence");
+                return atBreak(code2);
             }
-            if (nextProps.inertia) {
-                box2.setAttribute("data-inertia", "");
-            } else {
-                box2.removeAttribute("data-inertia");
+            return nok(code2);
+        }
+
+        function atBreak(code2) {
+            if (code2 === 35) {
+                effects.enter("atxHeadingSequence");
+                return sequenceFurther(code2);
             }
-            box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
-            if (nextProps.role) {
-                box2.setAttribute("role", nextProps.role);
-            } else {
-                box2.removeAttribute("role");
+            if (code2 === null || markdownLineEnding(code2)) {
+                effects.exit("atxHeading");
+                return ok2(code2);
             }
-            if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
-                setContent(content3, instance2.props);
+            if (markdownSpace(code2)) {
+                return factorySpace(effects, atBreak, "whitespace")(code2);
             }
-            if (nextProps.arrow) {
-                if (!arrow2) {
-                    box2.appendChild(createArrowElement(nextProps.arrow));
-                } else if (prevProps.arrow !== nextProps.arrow) {
-                    box2.removeChild(arrow2);
-                    box2.appendChild(createArrowElement(nextProps.arrow));
-                }
-            } else if (arrow2) {
-                box2.removeChild(arrow2);
+            effects.enter("atxHeadingText");
+            return data2(code2);
+        }
+
+        function sequenceFurther(code2) {
+            if (code2 === 35) {
+                effects.consume(code2);
+                return sequenceFurther;
             }
+            effects.exit("atxHeadingSequence");
+            return atBreak(code2);
+        }
+
+        function data2(code2) {
+            if (code2 === null || code2 === 35 || markdownLineEndingOrSpace(code2)) {
+                effects.exit("atxHeadingText");
+                return atBreak(code2);
+            }
+            effects.consume(code2);
+            return data2;
         }
-        return {
-            popper: popper2,
-            onUpdate
-        };
     }
-    render.$$tippy = true;
-    var idCounter$1 = 1;
-    var mouseMoveListeners = [];
-    var mountedInstances = [];
+    const htmlBlockNames = [
+        "address",
+        "article",
+        "aside",
+        "base",
+        "basefont",
+        "blockquote",
+        "body",
+        "caption",
+        "center",
+        "col",
+        "colgroup",
+        "dd",
+        "details",
+        "dialog",
+        "dir",
+        "div",
+        "dl",
+        "dt",
+        "fieldset",
+        "figcaption",
+        "figure",
+        "footer",
+        "form",
+        "frame",
+        "frameset",
+        "h1",
+        "h2",
+        "h3",
+        "h4",
+        "h5",
+        "h6",
+        "head",
+        "header",
+        "hr",
+        "html",
+        "iframe",
+        "legend",
+        "li",
+        "link",
+        "main",
+        "menu",
+        "menuitem",
+        "nav",
+        "noframes",
+        "ol",
+        "optgroup",
+        "option",
+        "p",
+        "param",
+        "search",
+        "section",
+        "summary",
+        "table",
+        "tbody",
+        "td",
+        "tfoot",
+        "th",
+        "thead",
+        "title",
+        "tr",
+        "track",
+        "ul"
+    ];
+    const htmlRawNames = ["pre", "script", "style", "textarea"];
+    const htmlFlow = {
+        name: "htmlFlow",
+        tokenize: tokenizeHtmlFlow,
+        resolveTo: resolveToHtmlFlow,
+        concrete: true
+    };
+    const blankLineBefore = {
+        tokenize: tokenizeBlankLineBefore,
+        partial: true
+    };
+    const nonLazyContinuationStart = {
+        tokenize: tokenizeNonLazyContinuationStart,
+        partial: true
+    };
 
-    function createTippy(reference2, passedProps) {
-        var props = evaluateProps(reference2, Object.assign({}, defaultProps$5, {}, getExtendedPassedProps(removeUndefinedProps(passedProps))));
-        var showTimeout;
-        var hideTimeout;
-        var scheduleHideAnimationFrame;
-        var isVisibleFromClick = false;
-        var didHideDueToDocumentMouseDown = false;
-        var didTouchMove = false;
-        var ignoreOnFirstUpdate = false;
-        var lastTriggerEvent;
-        var currentTransitionEndListener;
-        var onFirstUpdate;
-        var listeners = [];
-        var debouncedOnMouseMove = debounce$3(onMouseMove, props.interactiveDebounce);
-        var currentTarget;
-        var doc2 = getOwnerDocument(props.triggerTarget || reference2);
-        var id2 = idCounter$1++;
-        var popperInstance = null;
-        var plugins2 = unique(props.plugins);
-        var state = {
-            isEnabled: true,
-            isVisible: false,
-            isDestroyed: false,
-            isMounted: false,
-            isShown: false
-        };
-        var instance2 = {
-            id: id2,
-            reference: reference2,
-            popper: div(),
-            popperInstance,
-            props,
-            state,
-            plugins: plugins2,
-            clearDelayTimeouts,
-            setProps,
-            setContent: setContent2,
-            show,
-            hide: hide2,
-            hideWithInteractivity,
-            enable,
-            disable: disable2,
-            unmount,
-            destroy
-        };
-        if (!props.render) {
-            return instance2;
+    function resolveToHtmlFlow(events2) {
+        let index2 = events2.length;
+        while (index2--) {
+            if (events2[index2][0] === "enter" && events2[index2][1].type === "htmlFlow") {
+                break;
+            }
         }
-        var _props$render = props.render(instance2),
-            popper2 = _props$render.popper,
-            onUpdate = _props$render.onUpdate;
-        popper2.setAttribute("data-tippy-root", "");
-        popper2.id = "tippy-" + instance2.id;
-        instance2.popper = popper2;
-        reference2._tippy = instance2;
-        popper2._tippy = instance2;
-        var pluginsHooks = plugins2.map(function(plugin) {
-            return plugin.fn(instance2);
-        });
-        var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
-        addListeners();
-        handleAriaExpandedAttribute();
-        handleStyles();
-        invokeHook("onCreate", [instance2]);
-        if (props.showOnCreate) {
-            scheduleShow();
+        if (index2 > 1 && events2[index2 - 2][1].type === "linePrefix") {
+            events2[index2][1].start = events2[index2 - 2][1].start;
+            events2[index2 + 1][1].start = events2[index2 - 2][1].start;
+            events2.splice(index2 - 2, 2);
         }
-        popper2.addEventListener("mouseenter", function() {
-            if (instance2.props.interactive && instance2.state.isVisible) {
-                instance2.clearDelayTimeouts();
+        return events2;
+    }
+
+    function tokenizeHtmlFlow(effects, ok2, nok) {
+        const self2 = this;
+        let marker;
+        let closingTag;
+        let buffer;
+        let index2;
+        let markerB;
+        return start2;
+
+        function start2(code2) {
+            return before(code2);
+        }
+
+        function before(code2) {
+            effects.enter("htmlFlow");
+            effects.enter("htmlFlowData");
+            effects.consume(code2);
+            return open;
+        }
+
+        function open(code2) {
+            if (code2 === 33) {
+                effects.consume(code2);
+                return declarationOpen;
             }
-        });
-        popper2.addEventListener("mouseleave", function(event2) {
-            if (instance2.props.interactive && instance2.props.trigger.indexOf("mouseenter") >= 0) {
-                doc2.addEventListener("mousemove", debouncedOnMouseMove);
-                debouncedOnMouseMove(event2);
+            if (code2 === 47) {
+                effects.consume(code2);
+                closingTag = true;
+                return tagCloseStart;
             }
-        });
-        return instance2;
+            if (code2 === 63) {
+                effects.consume(code2);
+                marker = 3;
+                return self2.interrupt ? ok2 : continuationDeclarationInside;
+            }
+            if (asciiAlpha(code2)) {
+                effects.consume(code2);
+                buffer = String.fromCharCode(code2);
+                return tagName;
+            }
+            return nok(code2);
+        }
 
-        function getNormalizedTouchSettings() {
-            var touch = instance2.props.touch;
-            return Array.isArray(touch) ? touch : [touch, 0];
+        function declarationOpen(code2) {
+            if (code2 === 45) {
+                effects.consume(code2);
+                marker = 2;
+                return commentOpenInside;
+            }
+            if (code2 === 91) {
+                effects.consume(code2);
+                marker = 5;
+                index2 = 0;
+                return cdataOpenInside;
+            }
+            if (asciiAlpha(code2)) {
+                effects.consume(code2);
+                marker = 4;
+                return self2.interrupt ? ok2 : continuationDeclarationInside;
+            }
+            return nok(code2);
         }
 
-        function getIsCustomTouchBehavior() {
-            return getNormalizedTouchSettings()[0] === "hold";
+        function commentOpenInside(code2) {
+            if (code2 === 45) {
+                effects.consume(code2);
+                return self2.interrupt ? ok2 : continuationDeclarationInside;
+            }
+            return nok(code2);
         }
 
-        function getIsDefaultRenderFn() {
-            var _instance$props$rende;
-            return !!((_instance$props$rende = instance2.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
+        function cdataOpenInside(code2) {
+            const value = "CDATA[";
+            if (code2 === value.charCodeAt(index2++)) {
+                effects.consume(code2);
+                if (index2 === value.length) {
+                    return self2.interrupt ? ok2 : continuation;
+                }
+                return cdataOpenInside;
+            }
+            return nok(code2);
         }
 
-        function getCurrentTarget() {
-            return currentTarget || reference2;
+        function tagCloseStart(code2) {
+            if (asciiAlpha(code2)) {
+                effects.consume(code2);
+                buffer = String.fromCharCode(code2);
+                return tagName;
+            }
+            return nok(code2);
         }
 
-        function getDefaultTemplateChildren() {
-            return getChildren$1(popper2);
+        function tagName(code2) {
+            if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
+                const slash = code2 === 47;
+                const name2 = buffer.toLowerCase();
+                if (!slash && !closingTag && htmlRawNames.includes(name2)) {
+                    marker = 1;
+                    return self2.interrupt ? ok2(code2) : continuation(code2);
+                }
+                if (htmlBlockNames.includes(buffer.toLowerCase())) {
+                    marker = 6;
+                    if (slash) {
+                        effects.consume(code2);
+                        return basicSelfClosing;
+                    }
+                    return self2.interrupt ? ok2(code2) : continuation(code2);
+                }
+                marker = 7;
+                return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2);
+            }
+            if (code2 === 45 || asciiAlphanumeric(code2)) {
+                effects.consume(code2);
+                buffer += String.fromCharCode(code2);
+                return tagName;
+            }
+            return nok(code2);
         }
 
-        function getDelay(isShow) {
-            if (instance2.state.isMounted && !instance2.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
-                return 0;
+        function basicSelfClosing(code2) {
+            if (code2 === 62) {
+                effects.consume(code2);
+                return self2.interrupt ? ok2 : continuation;
             }
-            return getValueAtIndexOrReturn(instance2.props.delay, isShow ? 0 : 1, defaultProps$5.delay);
+            return nok(code2);
         }
 
-        function handleStyles() {
-            popper2.style.pointerEvents = instance2.props.interactive && instance2.state.isVisible ? "" : "none";
-            popper2.style.zIndex = "" + instance2.props.zIndex;
+        function completeClosingTagAfter(code2) {
+            if (markdownSpace(code2)) {
+                effects.consume(code2);
+                return completeClosingTagAfter;
+            }
+            return completeEnd(code2);
         }
 
-        function invokeHook(hook, args, shouldInvokePropsHook) {
-            if (shouldInvokePropsHook === void 0) {
-                shouldInvokePropsHook = true;
+        function completeAttributeNameBefore(code2) {
+            if (code2 === 47) {
+                effects.consume(code2);
+                return completeEnd;
             }
-            pluginsHooks.forEach(function(pluginHooks) {
-                if (pluginHooks[hook]) {
-                    pluginHooks[hook].apply(void 0, args);
-                }
-            });
-            if (shouldInvokePropsHook) {
-                var _instance$props;
-                (_instance$props = instance2.props)[hook].apply(_instance$props, args);
+            if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
+                effects.consume(code2);
+                return completeAttributeName;
+            }
+            if (markdownSpace(code2)) {
+                effects.consume(code2);
+                return completeAttributeNameBefore;
             }
+            return completeEnd(code2);
         }
 
-        function handleAriaContentAttribute() {
-            var aria2 = instance2.props.aria;
-            if (!aria2.content) {
-                return;
+        function completeAttributeName(code2) {
+            if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
+                effects.consume(code2);
+                return completeAttributeName;
             }
-            var attr = "aria-" + aria2.content;
-            var id3 = popper2.id;
-            var nodes = normalizeToArray(instance2.props.triggerTarget || reference2);
-            nodes.forEach(function(node2) {
-                var currentValue = node2.getAttribute(attr);
-                if (instance2.state.isVisible) {
-                    node2.setAttribute(attr, currentValue ? currentValue + " " + id3 : id3);
-                } else {
-                    var nextValue = currentValue && currentValue.replace(id3, "").trim();
-                    if (nextValue) {
-                        node2.setAttribute(attr, nextValue);
-                    } else {
-                        node2.removeAttribute(attr);
-                    }
-                }
-            });
+            return completeAttributeNameAfter(code2);
         }
 
-        function handleAriaExpandedAttribute() {
-            if (hasAriaExpanded || !instance2.props.aria.expanded) {
-                return;
+        function completeAttributeNameAfter(code2) {
+            if (code2 === 61) {
+                effects.consume(code2);
+                return completeAttributeValueBefore;
             }
-            var nodes = normalizeToArray(instance2.props.triggerTarget || reference2);
-            nodes.forEach(function(node2) {
-                if (instance2.props.interactive) {
-                    node2.setAttribute("aria-expanded", instance2.state.isVisible && node2 === getCurrentTarget() ? "true" : "false");
-                } else {
-                    node2.removeAttribute("aria-expanded");
-                }
-            });
+            if (markdownSpace(code2)) {
+                effects.consume(code2);
+                return completeAttributeNameAfter;
+            }
+            return completeAttributeNameBefore(code2);
         }
 
-        function cleanupInteractiveMouseListeners() {
-            doc2.removeEventListener("mousemove", debouncedOnMouseMove);
-            mouseMoveListeners = mouseMoveListeners.filter(function(listener2) {
-                return listener2 !== debouncedOnMouseMove;
-            });
+        function completeAttributeValueBefore(code2) {
+            if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
+                return nok(code2);
+            }
+            if (code2 === 34 || code2 === 39) {
+                effects.consume(code2);
+                markerB = code2;
+                return completeAttributeValueQuoted;
+            }
+            if (markdownSpace(code2)) {
+                effects.consume(code2);
+                return completeAttributeValueBefore;
+            }
+            return completeAttributeValueUnquoted(code2);
         }
 
-        function onDocumentPress(event2) {
-            if (currentInput.isTouch) {
-                if (didTouchMove || event2.type === "mousedown") {
-                    return;
-                }
+        function completeAttributeValueQuoted(code2) {
+            if (code2 === markerB) {
+                effects.consume(code2);
+                markerB = null;
+                return completeAttributeValueQuotedAfter;
             }
-            if (instance2.props.interactive && popper2.contains(event2.target)) {
-                return;
+            if (code2 === null || markdownLineEnding(code2)) {
+                return nok(code2);
             }
-            if (getCurrentTarget().contains(event2.target)) {
-                if (currentInput.isTouch) {
-                    return;
-                }
-                if (instance2.state.isVisible && instance2.props.trigger.indexOf("click") >= 0) {
-                    return;
-                }
-            } else {
-                invokeHook("onClickOutside", [instance2, event2]);
+            effects.consume(code2);
+            return completeAttributeValueQuoted;
+        }
+
+        function completeAttributeValueUnquoted(code2) {
+            if (code2 === null || code2 === 34 || code2 === 39 || code2 === 47 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace(code2)) {
+                return completeAttributeNameAfter(code2);
             }
-            if (instance2.props.hideOnClick === true) {
-                instance2.clearDelayTimeouts();
-                instance2.hide();
-                didHideDueToDocumentMouseDown = true;
-                setTimeout(function() {
-                    didHideDueToDocumentMouseDown = false;
-                });
-                if (!instance2.state.isMounted) {
-                    removeDocumentPress();
-                }
+            effects.consume(code2);
+            return completeAttributeValueUnquoted;
+        }
+
+        function completeAttributeValueQuotedAfter(code2) {
+            if (code2 === 47 || code2 === 62 || markdownSpace(code2)) {
+                return completeAttributeNameBefore(code2);
             }
+            return nok(code2);
         }
 
-        function onTouchMove() {
-            didTouchMove = true;
+        function completeEnd(code2) {
+            if (code2 === 62) {
+                effects.consume(code2);
+                return completeAfter;
+            }
+            return nok(code2);
         }
 
-        function onTouchStart() {
-            didTouchMove = false;
+        function completeAfter(code2) {
+            if (code2 === null || markdownLineEnding(code2)) {
+                return continuation(code2);
+            }
+            if (markdownSpace(code2)) {
+                effects.consume(code2);
+                return completeAfter;
+            }
+            return nok(code2);
         }
 
-        function addDocumentPress() {
-            doc2.addEventListener("mousedown", onDocumentPress, true);
-            doc2.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
-            doc2.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
-            doc2.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
+        function continuation(code2) {
+            if (code2 === 45 && marker === 2) {
+                effects.consume(code2);
+                return continuationCommentInside;
+            }
+            if (code2 === 60 && marker === 1) {
+                effects.consume(code2);
+                return continuationRawTagOpen;
+            }
+            if (code2 === 62 && marker === 4) {
+                effects.consume(code2);
+                return continuationClose;
+            }
+            if (code2 === 63 && marker === 3) {
+                effects.consume(code2);
+                return continuationDeclarationInside;
+            }
+            if (code2 === 93 && marker === 5) {
+                effects.consume(code2);
+                return continuationCdataInside;
+            }
+            if (markdownLineEnding(code2) && (marker === 6 || marker === 7)) {
+                effects.exit("htmlFlowData");
+                return effects.check(
+                    blankLineBefore,
+                    continuationAfter,
+                    continuationStart
+                )(code2);
+            }
+            if (code2 === null || markdownLineEnding(code2)) {
+                effects.exit("htmlFlowData");
+                return continuationStart(code2);
+            }
+            effects.consume(code2);
+            return continuation;
         }
 
-        function removeDocumentPress() {
-            doc2.removeEventListener("mousedown", onDocumentPress, true);
-            doc2.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
-            doc2.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
-            doc2.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
+        function continuationStart(code2) {
+            return effects.check(
+                nonLazyContinuationStart,
+                continuationStartNonLazy,
+                continuationAfter
+            )(code2);
         }
 
-        function onTransitionedOut(duration, callback) {
-            onTransitionEnd(duration, function() {
-                if (!instance2.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
-                    callback();
-                }
-            });
+        function continuationStartNonLazy(code2) {
+            effects.enter("lineEnding");
+            effects.consume(code2);
+            effects.exit("lineEnding");
+            return continuationBefore;
         }
 
-        function onTransitionedIn(duration, callback) {
-            onTransitionEnd(duration, callback);
+        function continuationBefore(code2) {
+            if (code2 === null || markdownLineEnding(code2)) {
+                return continuationStart(code2);
+            }
+            effects.enter("htmlFlowData");
+            return continuation(code2);
         }
 
-        function onTransitionEnd(duration, callback) {
-            var box = getDefaultTemplateChildren().box;
+        function continuationCommentInside(code2) {
+            if (code2 === 45) {
+                effects.consume(code2);
+                return continuationDeclarationInside;
+            }
+            return continuation(code2);
+        }
 
-            function listener2(event2) {
-                if (event2.target === box) {
-                    updateTransitionEndListener(box, "remove", listener2);
-                    callback();
+        function continuationRawTagOpen(code2) {
+            if (code2 === 47) {
+                effects.consume(code2);
+                buffer = "";
+                return continuationRawEndTag;
+            }
+            return continuation(code2);
+        }
+
+        function continuationRawEndTag(code2) {
+            if (code2 === 62) {
+                const name2 = buffer.toLowerCase();
+                if (htmlRawNames.includes(name2)) {
+                    effects.consume(code2);
+                    return continuationClose;
                 }
+                return continuation(code2);
             }
-            if (duration === 0) {
-                return callback();
+            if (asciiAlpha(code2) && buffer.length < 8) {
+                effects.consume(code2);
+                buffer += String.fromCharCode(code2);
+                return continuationRawEndTag;
             }
-            updateTransitionEndListener(box, "remove", currentTransitionEndListener);
-            updateTransitionEndListener(box, "add", listener2);
-            currentTransitionEndListener = listener2;
+            return continuation(code2);
         }
 
-        function on(eventType, handler, options) {
-            if (options === void 0) {
-                options = false;
+        function continuationCdataInside(code2) {
+            if (code2 === 93) {
+                effects.consume(code2);
+                return continuationDeclarationInside;
             }
-            var nodes = normalizeToArray(instance2.props.triggerTarget || reference2);
-            nodes.forEach(function(node2) {
-                node2.addEventListener(eventType, handler, options);
-                listeners.push({
-                    node: node2,
-                    eventType,
-                    handler,
-                    options
-                });
-            });
+            return continuation(code2);
         }
 
-        function addListeners() {
-            if (getIsCustomTouchBehavior()) {
-                on("touchstart", onTrigger, {
-                    passive: true
-                });
-                on("touchend", onMouseLeave, {
-                    passive: true
-                });
+        function continuationDeclarationInside(code2) {
+            if (code2 === 62) {
+                effects.consume(code2);
+                return continuationClose;
             }
-            splitBySpaces(instance2.props.trigger).forEach(function(eventType) {
-                if (eventType === "manual") {
-                    return;
-                }
-                on(eventType, onTrigger);
-                switch (eventType) {
-                    case "mouseenter":
-                        on("mouseleave", onMouseLeave);
-                        break;
-                    case "focus":
-                        on(isIE ? "focusout" : "blur", onBlurOrFocusOut);
-                        break;
-                    case "focusin":
-                        on("focusout", onBlurOrFocusOut);
-                        break;
-                }
-            });
+            if (code2 === 45 && marker === 2) {
+                effects.consume(code2);
+                return continuationDeclarationInside;
+            }
+            return continuation(code2);
         }
 
-        function removeListeners() {
-            listeners.forEach(function(_ref2) {
-                var node2 = _ref2.node,
-                    eventType = _ref2.eventType,
-                    handler = _ref2.handler,
-                    options = _ref2.options;
-                node2.removeEventListener(eventType, handler, options);
-            });
-            listeners = [];
+        function continuationClose(code2) {
+            if (code2 === null || markdownLineEnding(code2)) {
+                effects.exit("htmlFlowData");
+                return continuationAfter(code2);
+            }
+            effects.consume(code2);
+            return continuationClose;
         }
 
-        function onTrigger(event2) {
-            var _lastTriggerEvent;
-            var shouldScheduleClickHide = false;
-            if (!instance2.state.isEnabled || isEventListenerStopped(event2) || didHideDueToDocumentMouseDown) {
-                return;
+        function continuationAfter(code2) {
+            effects.exit("htmlFlow");
+            return ok2(code2);
+        }
+    }
+
+    function tokenizeNonLazyContinuationStart(effects, ok2, nok) {
+        const self2 = this;
+        return start2;
+
+        function start2(code2) {
+            if (markdownLineEnding(code2)) {
+                effects.enter("lineEnding");
+                effects.consume(code2);
+                effects.exit("lineEnding");
+                return after;
             }
-            var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
-            lastTriggerEvent = event2;
-            currentTarget = event2.currentTarget;
-            handleAriaExpandedAttribute();
-            if (!instance2.state.isVisible && isMouseEvent(event2)) {
-                mouseMoveListeners.forEach(function(listener2) {
-                    return listener2(event2);
-                });
+            return nok(code2);
+        }
+
+        function after(code2) {
+            return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
+        }
+    }
+
+    function tokenizeBlankLineBefore(effects, ok2, nok) {
+        return start2;
+
+        function start2(code2) {
+            effects.enter("lineEnding");
+            effects.consume(code2);
+            effects.exit("lineEnding");
+            return effects.attempt(blankLine, ok2, nok);
+        }
+    }
+    const htmlText = {
+        name: "htmlText",
+        tokenize: tokenizeHtmlText
+    };
+
+    function tokenizeHtmlText(effects, ok2, nok) {
+        const self2 = this;
+        let marker;
+        let index2;
+        let returnState;
+        return start2;
+
+        function start2(code2) {
+            effects.enter("htmlText");
+            effects.enter("htmlTextData");
+            effects.consume(code2);
+            return open;
+        }
+
+        function open(code2) {
+            if (code2 === 33) {
+                effects.consume(code2);
+                return declarationOpen;
             }
-            if (event2.type === "click" && (instance2.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance2.props.hideOnClick !== false && instance2.state.isVisible) {
-                shouldScheduleClickHide = true;
-            } else {
-                scheduleShow(event2);
+            if (code2 === 47) {
+                effects.consume(code2);
+                return tagCloseStart;
             }
-            if (event2.type === "click") {
-                isVisibleFromClick = !shouldScheduleClickHide;
+            if (code2 === 63) {
+                effects.consume(code2);
+                return instruction;
             }
-            if (shouldScheduleClickHide && !wasFocused) {
-                scheduleHide(event2);
+            if (asciiAlpha(code2)) {
+                effects.consume(code2);
+                return tagOpen;
             }
+            return nok(code2);
         }
 
-        function onMouseMove(event2) {
-            var target = event2.target;
-            var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
-            if (event2.type === "mousemove" && isCursorOverReferenceOrPopper) {
-                return;
+        function declarationOpen(code2) {
+            if (code2 === 45) {
+                effects.consume(code2);
+                return commentOpenInside;
             }
-            var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
-                var _instance$popperInsta;
-                var instance3 = popper3._tippy;
-                var state2 = (_instance$popperInsta = instance3.popperInstance) == null ? void 0 : _instance$popperInsta.state;
-                if (state2) {
-                    return {
-                        popperRect: popper3.getBoundingClientRect(),
-                        popperState: state2,
-                        props
-                    };
-                }
-                return null;
-            }).filter(Boolean);
-            if (isCursorOutsideInteractiveBorder(popperTreeData, event2)) {
-                cleanupInteractiveMouseListeners();
-                scheduleHide(event2);
+            if (code2 === 91) {
+                effects.consume(code2);
+                index2 = 0;
+                return cdataOpenInside;
+            }
+            if (asciiAlpha(code2)) {
+                effects.consume(code2);
+                return declaration;
             }
+            return nok(code2);
         }
 
-        function onMouseLeave(event2) {
-            var shouldBail = isEventListenerStopped(event2) || instance2.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
-            if (shouldBail) {
-                return;
-            }
-            if (instance2.props.interactive) {
-                instance2.hideWithInteractivity(event2);
-                return;
+        function commentOpenInside(code2) {
+            if (code2 === 45) {
+                effects.consume(code2);
+                return commentEnd;
             }
-            scheduleHide(event2);
+            return nok(code2);
         }
 
-        function onBlurOrFocusOut(event2) {
-            if (instance2.props.trigger.indexOf("focusin") < 0 && event2.target !== getCurrentTarget()) {
-                return;
+        function comment2(code2) {
+            if (code2 === null) {
+                return nok(code2);
             }
-            if (instance2.props.interactive && event2.relatedTarget && popper2.contains(event2.relatedTarget)) {
-                return;
+            if (code2 === 45) {
+                effects.consume(code2);
+                return commentClose;
             }
-            scheduleHide(event2);
+            if (markdownLineEnding(code2)) {
+                returnState = comment2;
+                return lineEndingBefore(code2);
+            }
+            effects.consume(code2);
+            return comment2;
         }
 
-        function isEventListenerStopped(event2) {
-            return currentInput.isTouch ? getIsCustomTouchBehavior() !== event2.type.indexOf("touch") >= 0 : false;
+        function commentClose(code2) {
+            if (code2 === 45) {
+                effects.consume(code2);
+                return commentEnd;
+            }
+            return comment2(code2);
         }
 
-        function createPopperInstance() {
-            destroyPopperInstance();
-            var _instance$props2 = instance2.props,
-                popperOptions = _instance$props2.popperOptions,
-                placement = _instance$props2.placement,
-                offset2 = _instance$props2.offset,
-                getReferenceClientRect = _instance$props2.getReferenceClientRect,
-                moveTransition = _instance$props2.moveTransition;
-            var arrow2 = getIsDefaultRenderFn() ? getChildren$1(popper2).arrow : null;
-            var computedReference = getReferenceClientRect ? {
-                getBoundingClientRect: getReferenceClientRect,
-                contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
-            } : reference2;
-            var tippyModifier = {
-                name: "$$tippy",
-                enabled: true,
-                phase: "beforeWrite",
-                requires: ["computeStyles"],
-                fn: function fn2(_ref2) {
-                    var state2 = _ref2.state;
-                    if (getIsDefaultRenderFn()) {
-                        var _getDefaultTemplateCh = getDefaultTemplateChildren(),
-                            box = _getDefaultTemplateCh.box;
-                        ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
-                            if (attr === "placement") {
-                                box.setAttribute("data-placement", state2.placement);
-                            } else {
-                                if (state2.attributes.popper["data-popper-" + attr]) {
-                                    box.setAttribute("data-" + attr, "");
-                                } else {
-                                    box.removeAttribute("data-" + attr);
-                                }
-                            }
-                        });
-                        state2.attributes.popper = {};
-                    }
-                }
-            };
-            var modifiers2 = [{
-                name: "offset",
-                options: {
-                    offset: offset2
-                }
-            }, {
-                name: "preventOverflow",
-                options: {
-                    padding: {
-                        top: 2,
-                        bottom: 2,
-                        left: 5,
-                        right: 5
-                    }
-                }
-            }, {
-                name: "flip",
-                options: {
-                    padding: 5
-                }
-            }, {
-                name: "computeStyles",
-                options: {
-                    adaptive: !moveTransition
-                }
-            }, tippyModifier];
-            if (getIsDefaultRenderFn() && arrow2) {
-                modifiers2.push({
-                    name: "arrow",
-                    options: {
-                        element: arrow2,
-                        padding: 3
-                    }
-                });
-            }
-            modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
-            instance2.popperInstance = createPopper$1(computedReference, popper2, Object.assign({}, popperOptions, {
-                placement,
-                onFirstUpdate,
-                modifiers: modifiers2
-            }));
+        function commentEnd(code2) {
+            return code2 === 62 ? end2(code2) : code2 === 45 ? commentClose(code2) : comment2(code2);
         }
 
-        function destroyPopperInstance() {
-            if (instance2.popperInstance) {
-                instance2.popperInstance.destroy();
-                instance2.popperInstance = null;
+        function cdataOpenInside(code2) {
+            const value = "CDATA[";
+            if (code2 === value.charCodeAt(index2++)) {
+                effects.consume(code2);
+                return index2 === value.length ? cdata : cdataOpenInside;
             }
+            return nok(code2);
         }
 
-        function mount() {
-            var appendTo = instance2.props.appendTo;
-            var parentNode;
-            var node2 = getCurrentTarget();
-            if (instance2.props.interactive && appendTo === defaultProps$5.appendTo || appendTo === "parent") {
-                parentNode = node2.parentNode;
-            } else {
-                parentNode = invokeWithArgsOrReturn(appendTo, [node2]);
+        function cdata(code2) {
+            if (code2 === null) {
+                return nok(code2);
             }
-            if (!parentNode.contains(popper2)) {
-                parentNode.appendChild(popper2);
+            if (code2 === 93) {
+                effects.consume(code2);
+                return cdataClose;
             }
-            createPopperInstance();
+            if (markdownLineEnding(code2)) {
+                returnState = cdata;
+                return lineEndingBefore(code2);
+            }
+            effects.consume(code2);
+            return cdata;
         }
 
-        function getNestedPopperTree() {
-            return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
+        function cdataClose(code2) {
+            if (code2 === 93) {
+                effects.consume(code2);
+                return cdataEnd;
+            }
+            return cdata(code2);
         }
 
-        function scheduleShow(event2) {
-            instance2.clearDelayTimeouts();
-            if (event2) {
-                invokeHook("onTrigger", [instance2, event2]);
+        function cdataEnd(code2) {
+            if (code2 === 62) {
+                return end2(code2);
             }
-            addDocumentPress();
-            var delay = getDelay(true);
-            var _getNormalizedTouchSe = getNormalizedTouchSettings(),
-                touchValue = _getNormalizedTouchSe[0],
-                touchDelay = _getNormalizedTouchSe[1];
-            if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
-                delay = touchDelay;
+            if (code2 === 93) {
+                effects.consume(code2);
+                return cdataEnd;
             }
-            if (delay) {
-                showTimeout = setTimeout(function() {
-                    instance2.show();
-                }, delay);
-            } else {
-                instance2.show();
+            return cdata(code2);
+        }
+
+        function declaration(code2) {
+            if (code2 === null || code2 === 62) {
+                return end2(code2);
+            }
+            if (markdownLineEnding(code2)) {
+                returnState = declaration;
+                return lineEndingBefore(code2);
             }
+            effects.consume(code2);
+            return declaration;
         }
 
-        function scheduleHide(event2) {
-            instance2.clearDelayTimeouts();
-            invokeHook("onUntrigger", [instance2, event2]);
-            if (!instance2.state.isVisible) {
-                removeDocumentPress();
-                return;
+        function instruction(code2) {
+            if (code2 === null) {
+                return nok(code2);
             }
-            if (instance2.props.trigger.indexOf("mouseenter") >= 0 && instance2.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event2.type) >= 0 && isVisibleFromClick) {
-                return;
+            if (code2 === 63) {
+                effects.consume(code2);
+                return instructionClose;
             }
-            var delay = getDelay(false);
-            if (delay) {
-                hideTimeout = setTimeout(function() {
-                    if (instance2.state.isVisible) {
-                        instance2.hide();
-                    }
-                }, delay);
-            } else {
-                scheduleHideAnimationFrame = requestAnimationFrame(function() {
-                    instance2.hide();
-                });
+            if (markdownLineEnding(code2)) {
+                returnState = instruction;
+                return lineEndingBefore(code2);
             }
+            effects.consume(code2);
+            return instruction;
         }
 
-        function enable() {
-            instance2.state.isEnabled = true;
+        function instructionClose(code2) {
+            return code2 === 62 ? end2(code2) : instruction(code2);
         }
 
-        function disable2() {
-            instance2.hide();
-            instance2.state.isEnabled = false;
+        function tagCloseStart(code2) {
+            if (asciiAlpha(code2)) {
+                effects.consume(code2);
+                return tagClose;
+            }
+            return nok(code2);
         }
 
-        function clearDelayTimeouts() {
-            clearTimeout(showTimeout);
-            clearTimeout(hideTimeout);
-            cancelAnimationFrame(scheduleHideAnimationFrame);
+        function tagClose(code2) {
+            if (code2 === 45 || asciiAlphanumeric(code2)) {
+                effects.consume(code2);
+                return tagClose;
+            }
+            return tagCloseBetween(code2);
         }
 
-        function setProps(partialProps) {
-            if (instance2.state.isDestroyed) {
-                return;
+        function tagCloseBetween(code2) {
+            if (markdownLineEnding(code2)) {
+                returnState = tagCloseBetween;
+                return lineEndingBefore(code2);
             }
-            invokeHook("onBeforeUpdate", [instance2, partialProps]);
-            removeListeners();
-            var prevProps = instance2.props;
-            var nextProps = evaluateProps(reference2, Object.assign({}, instance2.props, {}, partialProps, {
-                ignoreAttributes: true
-            }));
-            instance2.props = nextProps;
-            addListeners();
-            if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
-                cleanupInteractiveMouseListeners();
-                debouncedOnMouseMove = debounce$3(onMouseMove, nextProps.interactiveDebounce);
+            if (markdownSpace(code2)) {
+                effects.consume(code2);
+                return tagCloseBetween;
             }
-            if (prevProps.triggerTarget && !nextProps.triggerTarget) {
-                normalizeToArray(prevProps.triggerTarget).forEach(function(node2) {
-                    node2.removeAttribute("aria-expanded");
-                });
-            } else if (nextProps.triggerTarget) {
-                reference2.removeAttribute("aria-expanded");
+            return end2(code2);
+        }
+
+        function tagOpen(code2) {
+            if (code2 === 45 || asciiAlphanumeric(code2)) {
+                effects.consume(code2);
+                return tagOpen;
             }
-            handleAriaExpandedAttribute();
-            handleStyles();
-            if (onUpdate) {
-                onUpdate(prevProps, nextProps);
+            if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
+                return tagOpenBetween(code2);
             }
-            if (instance2.popperInstance) {
-                createPopperInstance();
-                getNestedPopperTree().forEach(function(nestedPopper) {
-                    requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
-                });
+            return nok(code2);
+        }
+
+        function tagOpenBetween(code2) {
+            if (code2 === 47) {
+                effects.consume(code2);
+                return end2;
             }
-            invokeHook("onAfterUpdate", [instance2, partialProps]);
+            if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
+                effects.consume(code2);
+                return tagOpenAttributeName;
+            }
+            if (markdownLineEnding(code2)) {
+                returnState = tagOpenBetween;
+                return lineEndingBefore(code2);
+            }
+            if (markdownSpace(code2)) {
+                effects.consume(code2);
+                return tagOpenBetween;
+            }
+            return end2(code2);
         }
 
-        function setContent2(content2) {
-            instance2.setProps({
-                content: content2
-            });
+        function tagOpenAttributeName(code2) {
+            if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
+                effects.consume(code2);
+                return tagOpenAttributeName;
+            }
+            return tagOpenAttributeNameAfter(code2);
         }
 
-        function show() {
-            var isAlreadyVisible = instance2.state.isVisible;
-            var isDestroyed = instance2.state.isDestroyed;
-            var isDisabled = !instance2.state.isEnabled;
-            var isTouchAndTouchDisabled = currentInput.isTouch && !instance2.props.touch;
-            var duration = getValueAtIndexOrReturn(instance2.props.duration, 0, defaultProps$5.duration);
-            if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
-                return;
+        function tagOpenAttributeNameAfter(code2) {
+            if (code2 === 61) {
+                effects.consume(code2);
+                return tagOpenAttributeValueBefore;
             }
-            if (getCurrentTarget().hasAttribute("disabled")) {
-                return;
+            if (markdownLineEnding(code2)) {
+                returnState = tagOpenAttributeNameAfter;
+                return lineEndingBefore(code2);
             }
-            invokeHook("onShow", [instance2], false);
-            if (instance2.props.onShow(instance2) === false) {
-                return;
+            if (markdownSpace(code2)) {
+                effects.consume(code2);
+                return tagOpenAttributeNameAfter;
             }
-            instance2.state.isVisible = true;
-            if (getIsDefaultRenderFn()) {
-                popper2.style.visibility = "visible";
+            return tagOpenBetween(code2);
+        }
+
+        function tagOpenAttributeValueBefore(code2) {
+            if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
+                return nok(code2);
             }
-            handleStyles();
-            addDocumentPress();
-            if (!instance2.state.isMounted) {
-                popper2.style.transition = "none";
+            if (code2 === 34 || code2 === 39) {
+                effects.consume(code2);
+                marker = code2;
+                return tagOpenAttributeValueQuoted;
             }
-            if (getIsDefaultRenderFn()) {
-                var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
-                    box = _getDefaultTemplateCh2.box,
-                    content2 = _getDefaultTemplateCh2.content;
-                setTransitionDuration([box, content2], 0);
+            if (markdownLineEnding(code2)) {
+                returnState = tagOpenAttributeValueBefore;
+                return lineEndingBefore(code2);
             }
-            onFirstUpdate = function onFirstUpdate2() {
-                if (!instance2.state.isVisible || ignoreOnFirstUpdate) {
-                    return;
-                }
-                ignoreOnFirstUpdate = true;
-                void popper2.offsetHeight;
-                popper2.style.transition = instance2.props.moveTransition;
-                if (getIsDefaultRenderFn() && instance2.props.animation) {
-                    var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
-                        _box = _getDefaultTemplateCh3.box,
-                        _content = _getDefaultTemplateCh3.content;
-                    setTransitionDuration([_box, _content], duration);
-                    setVisibilityState([_box, _content], "visible");
-                }
-                handleAriaContentAttribute();
-                handleAriaExpandedAttribute();
-                pushIfUnique(mountedInstances, instance2);
-                instance2.state.isMounted = true;
-                invokeHook("onMount", [instance2]);
-                if (instance2.props.animation && getIsDefaultRenderFn()) {
-                    onTransitionedIn(duration, function() {
-                        instance2.state.isShown = true;
-                        invokeHook("onShown", [instance2]);
-                    });
-                }
-            };
-            mount();
+            if (markdownSpace(code2)) {
+                effects.consume(code2);
+                return tagOpenAttributeValueBefore;
+            }
+            effects.consume(code2);
+            return tagOpenAttributeValueUnquoted;
         }
 
-        function hide2() {
-            var isAlreadyHidden = !instance2.state.isVisible;
-            var isDestroyed = instance2.state.isDestroyed;
-            var isDisabled = !instance2.state.isEnabled;
-            var duration = getValueAtIndexOrReturn(instance2.props.duration, 1, defaultProps$5.duration);
-            if (isAlreadyHidden || isDestroyed || isDisabled) {
-                return;
+        function tagOpenAttributeValueQuoted(code2) {
+            if (code2 === marker) {
+                effects.consume(code2);
+                marker = void 0;
+                return tagOpenAttributeValueQuotedAfter;
             }
-            invokeHook("onHide", [instance2], false);
-            if (instance2.props.onHide(instance2) === false) {
-                return;
+            if (code2 === null) {
+                return nok(code2);
             }
-            instance2.state.isVisible = false;
-            instance2.state.isShown = false;
-            ignoreOnFirstUpdate = false;
-            isVisibleFromClick = false;
-            if (getIsDefaultRenderFn()) {
-                popper2.style.visibility = "hidden";
+            if (markdownLineEnding(code2)) {
+                returnState = tagOpenAttributeValueQuoted;
+                return lineEndingBefore(code2);
             }
-            cleanupInteractiveMouseListeners();
-            removeDocumentPress();
-            handleStyles();
-            if (getIsDefaultRenderFn()) {
-                var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
-                    box = _getDefaultTemplateCh4.box,
-                    content2 = _getDefaultTemplateCh4.content;
-                if (instance2.props.animation) {
-                    setTransitionDuration([box, content2], duration);
-                    setVisibilityState([box, content2], "hidden");
-                }
+            effects.consume(code2);
+            return tagOpenAttributeValueQuoted;
+        }
+
+        function tagOpenAttributeValueUnquoted(code2) {
+            if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
+                return nok(code2);
             }
-            handleAriaContentAttribute();
-            handleAriaExpandedAttribute();
-            if (instance2.props.animation) {
-                if (getIsDefaultRenderFn()) {
-                    onTransitionedOut(duration, instance2.unmount);
-                }
-            } else {
-                instance2.unmount();
+            if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
+                return tagOpenBetween(code2);
             }
+            effects.consume(code2);
+            return tagOpenAttributeValueUnquoted;
         }
 
-        function hideWithInteractivity(event2) {
-            doc2.addEventListener("mousemove", debouncedOnMouseMove);
-            pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
-            debouncedOnMouseMove(event2);
+        function tagOpenAttributeValueQuotedAfter(code2) {
+            if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
+                return tagOpenBetween(code2);
+            }
+            return nok(code2);
         }
 
-        function unmount() {
-            if (instance2.state.isVisible) {
-                instance2.hide();
-            }
-            if (!instance2.state.isMounted) {
-                return;
-            }
-            destroyPopperInstance();
-            getNestedPopperTree().forEach(function(nestedPopper) {
-                nestedPopper._tippy.unmount();
-            });
-            if (popper2.parentNode) {
-                popper2.parentNode.removeChild(popper2);
+        function end2(code2) {
+            if (code2 === 62) {
+                effects.consume(code2);
+                effects.exit("htmlTextData");
+                effects.exit("htmlText");
+                return ok2;
             }
-            mountedInstances = mountedInstances.filter(function(i2) {
-                return i2 !== instance2;
-            });
-            instance2.state.isMounted = false;
-            invokeHook("onHidden", [instance2]);
+            return nok(code2);
         }
 
-        function destroy() {
-            if (instance2.state.isDestroyed) {
-                return;
-            }
-            instance2.clearDelayTimeouts();
-            instance2.unmount();
-            removeListeners();
-            delete reference2._tippy;
-            instance2.state.isDestroyed = true;
-            invokeHook("onDestroy", [instance2]);
+        function lineEndingBefore(code2) {
+            effects.exit("htmlTextData");
+            effects.enter("lineEnding");
+            effects.consume(code2);
+            effects.exit("lineEnding");
+            return lineEndingAfter;
         }
-    }
 
-    function tippy(targets, optionalProps) {
-        if (optionalProps === void 0) {
-            optionalProps = {};
+        function lineEndingAfter(code2) {
+            return markdownSpace(code2) ? factorySpace(
+                effects,
+                lineEndingAfterPrefix,
+                "linePrefix",
+                self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
+            )(code2) : lineEndingAfterPrefix(code2);
         }
-        var plugins2 = defaultProps$5.plugins.concat(optionalProps.plugins || []);
-        bindGlobalEventListeners();
-        var passedProps = Object.assign({}, optionalProps, {
-            plugins: plugins2
-        });
-        var elements = getArrayOfElements(targets);
-        var instances = elements.reduce(function(acc, reference2) {
-            var instance2 = reference2 && createTippy(reference2, passedProps);
-            if (instance2) {
-                acc.push(instance2);
-            }
-            return acc;
-        }, []);
-        return isElement$2(targets) ? instances[0] : instances;
-    }
-    tippy.defaultProps = defaultProps$5;
-    tippy.setDefaultProps = setDefaultProps;
-    tippy.currentInput = currentInput;
-    var mouseCoords = {
-        clientX: 0,
-        clientY: 0
-    };
-    var activeInstances = [];
 
-    function storeMouseCoords(_ref2) {
-        var clientX = _ref2.clientX,
-            clientY = _ref2.clientY;
-        mouseCoords = {
-            clientX,
-            clientY
-        };
+        function lineEndingAfterPrefix(code2) {
+            effects.enter("htmlTextData");
+            return returnState(code2);
+        }
     }
+    const labelEnd = {
+        name: "labelEnd",
+        tokenize: tokenizeLabelEnd,
+        resolveTo: resolveToLabelEnd,
+        resolveAll: resolveAllLabelEnd
+    };
+    const resourceConstruct = {
+        tokenize: tokenizeResource
+    };
+    const referenceFullConstruct = {
+        tokenize: tokenizeReferenceFull
+    };
+    const referenceCollapsedConstruct = {
+        tokenize: tokenizeReferenceCollapsed
+    };
 
-    function addMouseCoordsListener(doc2) {
-        doc2.addEventListener("mousemove", storeMouseCoords);
+    function resolveAllLabelEnd(events2) {
+        let index2 = -1;
+        while (++index2 < events2.length) {
+            const token = events2[index2][1];
+            if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
+                events2.splice(index2 + 1, token.type === "labelImage" ? 4 : 2);
+                token.type = "data";
+                index2++;
+            }
+        }
+        return events2;
     }
 
-    function removeMouseCoordsListener(doc2) {
-        doc2.removeEventListener("mousemove", storeMouseCoords);
+    function resolveToLabelEnd(events2, context2) {
+        let index2 = events2.length;
+        let offset2 = 0;
+        let token;
+        let open;
+        let close;
+        let media;
+        while (index2--) {
+            token = events2[index2][1];
+            if (open) {
+                if (token.type === "link" || token.type === "labelLink" && token._inactive) {
+                    break;
+                }
+                if (events2[index2][0] === "enter" && token.type === "labelLink") {
+                    token._inactive = true;
+                }
+            } else if (close) {
+                if (events2[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
+                    open = index2;
+                    if (token.type !== "labelLink") {
+                        offset2 = 2;
+                        break;
+                    }
+                }
+            } else if (token.type === "labelEnd") {
+                close = index2;
+            }
+        }
+        const group = {
+            type: events2[open][1].type === "labelLink" ? "link" : "image",
+            start: Object.assign({}, events2[open][1].start),
+            end: Object.assign({}, events2[events2.length - 1][1].end)
+        };
+        const label = {
+            type: "label",
+            start: Object.assign({}, events2[open][1].start),
+            end: Object.assign({}, events2[close][1].end)
+        };
+        const text2 = {
+            type: "labelText",
+            start: Object.assign({}, events2[open + offset2 + 2][1].end),
+            end: Object.assign({}, events2[close - 2][1].start)
+        };
+        media = [
+            ["enter", group, context2],
+            ["enter", label, context2]
+        ];
+        media = push$2(media, events2.slice(open + 1, open + offset2 + 3));
+        media = push$2(media, [
+            ["enter", text2, context2]
+        ]);
+        media = push$2(
+            media,
+            resolveAll(
+                context2.parser.constructs.insideSpan.null,
+                events2.slice(open + offset2 + 4, close - 3),
+                context2
+            )
+        );
+        media = push$2(media, [
+            ["exit", text2, context2],
+            events2[close - 2],
+            events2[close - 1],
+            ["exit", label, context2]
+        ]);
+        media = push$2(media, events2.slice(close + 1));
+        media = push$2(media, [
+            ["exit", group, context2]
+        ]);
+        splice(events2, open, events2.length, media);
+        return events2;
     }
-    var followCursor = {
-        name: "followCursor",
-        defaultValue: false,
-        fn: function fn2(instance2) {
-            var reference2 = instance2.reference;
-            var doc2 = getOwnerDocument(instance2.props.triggerTarget || reference2);
-            var isInternalUpdate = false;
-            var wasFocusEvent = false;
-            var isUnmounted = true;
-            var prevProps = instance2.props;
 
-            function getIsInitialBehavior() {
-                return instance2.props.followCursor === "initial" && instance2.state.isVisible;
+    function tokenizeLabelEnd(effects, ok2, nok) {
+        const self2 = this;
+        let index2 = self2.events.length;
+        let labelStart;
+        let defined;
+        while (index2--) {
+            if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
+                labelStart = self2.events[index2][1];
+                break;
             }
+        }
+        return start2;
 
-            function addListener() {
-                doc2.addEventListener("mousemove", onMouseMove);
+        function start2(code2) {
+            if (!labelStart) {
+                return nok(code2);
             }
-
-            function removeListener() {
-                doc2.removeEventListener("mousemove", onMouseMove);
+            if (labelStart._inactive) {
+                return labelEndNok(code2);
             }
+            defined = self2.parser.defined.includes(
+                normalizeIdentifier(
+                    self2.sliceSerialize({
+                        start: labelStart.end,
+                        end: self2.now()
+                    })
+                )
+            );
+            effects.enter("labelEnd");
+            effects.enter("labelMarker");
+            effects.consume(code2);
+            effects.exit("labelMarker");
+            effects.exit("labelEnd");
+            return after;
+        }
 
-            function unsetGetReferenceClientRect() {
-                isInternalUpdate = true;
-                instance2.setProps({
-                    getReferenceClientRect: null
-                });
-                isInternalUpdate = false;
+        function after(code2) {
+            if (code2 === 40) {
+                return effects.attempt(
+                    resourceConstruct,
+                    labelEndOk,
+                    defined ? labelEndOk : labelEndNok
+                )(code2);
             }
-
-            function onMouseMove(event2) {
-                var isCursorOverReference = event2.target ? reference2.contains(event2.target) : true;
-                var followCursor2 = instance2.props.followCursor;
-                var clientX = event2.clientX,
-                    clientY = event2.clientY;
-                var rect = reference2.getBoundingClientRect();
-                var relativeX = clientX - rect.left;
-                var relativeY = clientY - rect.top;
-                if (isCursorOverReference || !instance2.props.interactive) {
-                    instance2.setProps({
-                        getReferenceClientRect: function getReferenceClientRect() {
-                            var rect2 = reference2.getBoundingClientRect();
-                            var x2 = clientX;
-                            var y2 = clientY;
-                            if (followCursor2 === "initial") {
-                                x2 = rect2.left + relativeX;
-                                y2 = rect2.top + relativeY;
-                            }
-                            var top2 = followCursor2 === "horizontal" ? rect2.top : y2;
-                            var right2 = followCursor2 === "vertical" ? rect2.right : x2;
-                            var bottom2 = followCursor2 === "horizontal" ? rect2.bottom : y2;
-                            var left2 = followCursor2 === "vertical" ? rect2.left : x2;
-                            return {
-                                width: right2 - left2,
-                                height: bottom2 - top2,
-                                top: top2,
-                                right: right2,
-                                bottom: bottom2,
-                                left: left2
-                            };
-                        }
-                    });
-                }
+            if (code2 === 91) {
+                return effects.attempt(
+                    referenceFullConstruct,
+                    labelEndOk,
+                    defined ? referenceNotFull : labelEndNok
+                )(code2);
             }
+            return defined ? labelEndOk(code2) : labelEndNok(code2);
+        }
 
-            function create2() {
-                if (instance2.props.followCursor) {
-                    activeInstances.push({
-                        instance: instance2,
-                        doc: doc2
-                    });
-                    addMouseCoordsListener(doc2);
-                }
-            }
+        function referenceNotFull(code2) {
+            return effects.attempt(
+                referenceCollapsedConstruct,
+                labelEndOk,
+                labelEndNok
+            )(code2);
+        }
 
-            function destroy() {
-                activeInstances = activeInstances.filter(function(data2) {
-                    return data2.instance !== instance2;
-                });
-                if (activeInstances.filter(function(data2) {
-                        return data2.doc === doc2;
-                    }).length === 0) {
-                    removeMouseCoordsListener(doc2);
-                }
-            }
-            return {
-                onCreate: create2,
-                onDestroy: destroy,
-                onBeforeUpdate: function onBeforeUpdate() {
-                    prevProps = instance2.props;
-                },
-                onAfterUpdate: function onAfterUpdate(_2, _ref2) {
-                    var followCursor2 = _ref2.followCursor;
-                    if (isInternalUpdate) {
-                        return;
-                    }
-                    if (followCursor2 !== void 0 && prevProps.followCursor !== followCursor2) {
-                        destroy();
-                        if (followCursor2) {
-                            create2();
-                            if (instance2.state.isMounted && !wasFocusEvent && !getIsInitialBehavior()) {
-                                addListener();
-                            }
-                        } else {
-                            removeListener();
-                            unsetGetReferenceClientRect();
-                        }
-                    }
-                },
-                onMount: function onMount() {
-                    if (instance2.props.followCursor && !wasFocusEvent) {
-                        if (isUnmounted) {
-                            onMouseMove(mouseCoords);
-                            isUnmounted = false;
-                        }
-                        if (!getIsInitialBehavior()) {
-                            addListener();
-                        }
-                    }
-                },
-                onTrigger: function onTrigger(_2, event2) {
-                    if (isMouseEvent(event2)) {
-                        mouseCoords = {
-                            clientX: event2.clientX,
-                            clientY: event2.clientY
-                        };
-                    }
-                    wasFocusEvent = event2.type === "focus";
-                },
-                onHidden: function onHidden() {
-                    if (instance2.props.followCursor) {
-                        unsetGetReferenceClientRect();
-                        removeListener();
-                        isUnmounted = true;
-                    }
-                }
-            };
+        function labelEndOk(code2) {
+            return ok2(code2);
         }
-    };
-    tippy.setDefaultProps({
-        render
-    });
-    const TooltipWrapper = styled__default.default.div`
-    position: relative;
 
-    display: block;
+        function labelEndNok(code2) {
+            labelStart._balanced = true;
+            return nok(code2);
+        }
+    }
 
-    max-width: 15rem;
-    padding: 0.75rem 1rem;
+    function tokenizeResource(effects, ok2, nok) {
+        return resourceStart;
 
-    word-break: break-word;
+        function resourceStart(code2) {
+            effects.enter("resource");
+            effects.enter("resourceMarker");
+            effects.consume(code2);
+            effects.exit("resourceMarker");
+            return resourceBefore;
+        }
 
-    border-radius: 0.25rem;
+        function resourceBefore(code2) {
+            return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
+        }
 
-    transition: opacity 150ms ease-in-out;
+        function resourceOpen(code2) {
+            if (code2 === 41) {
+                return resourceEnd(code2);
+            }
+            return factoryDestination(
+                effects,
+                resourceDestinationAfter,
+                resourceDestinationMissing,
+                "resourceDestination",
+                "resourceDestinationLiteral",
+                "resourceDestinationLiteralMarker",
+                "resourceDestinationRaw",
+                "resourceDestinationString",
+                32
+            )(code2);
+        }
 
-    ${(props) => {
-    if (!props.$hidden) {
-      return `
-            color: ${props.styling === "default" ? props.theme.colors.grey5 : props.theme.colors.blue1};
-            font-size: ${props.theme.font.size};
-            border: 1px solid ${props.styling === "default" ? props.theme.colors.grey5 : props.theme.colors.errorDown};
+        function resourceDestinationAfter(code2) {
+            return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
+        }
 
-            background-color: ${props.styling === "default" ? props.theme.colors.grey2 : props.theme.colors.error};
-            `;
-    }
-  }};
-`;
-    const Arrow = styled__default.default.span`
-    position: absolute;
+        function resourceDestinationMissing(code2) {
+            return nok(code2);
+        }
 
-    ${(props) => {
-    switch (props.placement) {
-      case "top":
-        return "bottom: 3px; left: -3px !important;";
-      case "bottom":
-        return "top: -5px;";
-      case "left":
-        return "right: 3px;";
-      case "right":
-        return "left: -5px;";
-      default:
-        return "display: none;";
-    }
-  }}
+        function resourceBetween(code2) {
+            if (code2 === 34 || code2 === 39 || code2 === 40) {
+                return factoryTitle(
+                    effects,
+                    resourceTitleAfter,
+                    nok,
+                    "resourceTitle",
+                    "resourceTitleMarker",
+                    "resourceTitleString"
+                )(code2);
+            }
+            return resourceEnd(code2);
+        }
 
-    ${(props) => {
-    if (props.$hidden) {
-      return "display: none;";
+        function resourceTitleAfter(code2) {
+            return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
+        }
+
+        function resourceEnd(code2) {
+            if (code2 === 41) {
+                effects.enter("resourceMarker");
+                effects.consume(code2);
+                effects.exit("resourceMarker");
+                effects.exit("resource");
+                return ok2;
+            }
+            return nok(code2);
+        }
     }
-  }}
 
-    &::before {
-        content: '';
+    function tokenizeReferenceFull(effects, ok2, nok) {
+        const self2 = this;
+        return referenceFull;
 
-        position: absolute;
+        function referenceFull(code2) {
+            return factoryLabel.call(
+                self2,
+                effects,
+                referenceFullAfter,
+                referenceFullMissing,
+                "reference",
+                "referenceMarker",
+                "referenceString"
+            )(code2);
+        }
 
-        ${(props) => {
-    switch (props.placement) {
-      case "top":
-      case "bottom":
-        return "transform: rotate(45deg);";
-      case "left":
-        return "transform: rotate(135deg);";
-      case "right":
-        return "transform: rotate(-45deg);";
-      default:
-        return "display: none;";
+        function referenceFullAfter(code2) {
+            return self2.parser.defined.includes(
+                normalizeIdentifier(
+                    self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
+                )
+            ) ? ok2(code2) : nok(code2);
+        }
+
+        function referenceFullMissing(code2) {
+            return nok(code2);
+        }
     }
-  }}
 
-        width: 0.5rem;
-        height: 0.5rem;
+    function tokenizeReferenceCollapsed(effects, ok2, nok) {
+        return referenceCollapsedStart;
 
-        background: ${(props) => {
-    return props.styling === "default" ? props.theme.colors.grey2 : props.theme.colors.error;
-  }};
-        ${(props) => {
-    if (props.placement === "top") {
-      return `border-bottom: 1px solid ${props.styling === "default" ? props.theme.colors.grey5 : props.theme.colors.errorDown};
-                        border-right: 1px solid ${props.styling === "default" ? props.theme.colors.grey5 : props.theme.colors.errorDown};`;
-    }
-    return `
-    border - top: 1 px solid $ {
-        props.styling === "default" ? props.theme.colors.grey5 : props.theme.colors.errorDown
-    };
-    border - left: 1 px solid $ {
-        props.styling === "default" ? props.theme.colors.grey5 : props.theme.colors.errorDown
-    };
-    `;
-  }}
-    }
-`;
+        function referenceCollapsedStart(code2) {
+            effects.enter("reference");
+            effects.enter("referenceMarker");
+            effects.consume(code2);
+            effects.exit("referenceMarker");
+            return referenceCollapsedOpen;
+        }
 
-    function Tooltip$1({
-        appendTo = document.body,
-        getReferenceClientRect,
-        children: children2,
-        className,
-        content: content2,
-        disabled: disabled2,
-        hideOnClick = true,
-        interactive,
-        visible,
-        placement = "auto",
-        styling = "default",
-        followCursor: followCursor$1 = false,
-        hidden = false,
-        style: style2,
-        delay = 0,
-        onClickOutside = () => false
-    }) {
-        return jsxRuntime.exports.jsx(Tippy, {
-            appendTo,
-            arrow: true,
-            delay,
-            disabled: disabled2,
-            followCursor: followCursor$1,
-            getReferenceClientRect,
-            hideOnClick: visible !== void 0 ? void 0 : hideOnClick,
-            interactive,
-            onClickOutside,
-            placement,
-            plugins: [followCursor],
-            render: (attrs2) => jsxRuntime.exports.jsxs(TooltipWrapper, Object.assign({
-                "$hidden": hidden,
-                className,
-                style: style2,
-                styling
-            }, attrs2, {
-                children: [content2, jsxRuntime.exports.jsx(Arrow, {
-                    "$hidden": hidden,
-                    "data-popper-arrow": "",
-                    placement: attrs2["data-placement"],
-                    styling
-                })]
-            })),
-            visible,
-            zIndex: 9998,
-            children: children2
-        });
+        function referenceCollapsedOpen(code2) {
+            if (code2 === 93) {
+                effects.enter("referenceMarker");
+                effects.consume(code2);
+                effects.exit("referenceMarker");
+                effects.exit("reference");
+                return ok2;
+            }
+            return nok(code2);
+        }
     }
-    const InteractiveIcons = styled__default.default.div`
-    position: absolute;
-    top: 0.75rem;
-    left: 236px;
-
-    display: none;
-    gap: 0.5rem;
-
-    padding: 0.3rem;
-
-    background-color: ${(props) => props.theme.colors.blue1};
-    border-radius: 0.25rem;
-    box-shadow: ${(props) => props.theme.shadow.medium};
-`;
-    const MessageWrapper = styled__default.default.div`
-    position: relative;
+    const labelStartImage = {
+        name: "labelStartImage",
+        tokenize: tokenizeLabelStartImage,
+        resolveAll: labelEnd.resolveAll
+    };
 
-    gap: 0.5rem;
+    function tokenizeLabelStartImage(effects, ok2, nok) {
+        const self2 = this;
+        return start2;
 
-    width: 100%;
-    padding: 1rem;
+        function start2(code2) {
+            effects.enter("labelImage");
+            effects.enter("labelImageMarker");
+            effects.consume(code2);
+            effects.exit("labelImageMarker");
+            return open;
+        }
 
-    background-color: ${(props) => props.theme.colors.blue1};
-    border-radius: 0.25rem;
-    box-shadow: ${(props) => props.theme.shadow.medium};
+        function open(code2) {
+            if (code2 === 91) {
+                effects.enter("labelMarker");
+                effects.consume(code2);
+                effects.exit("labelMarker");
+                effects.exit("labelImage");
+                return after;
+            }
+            return nok(code2);
+        }
 
-    :hover ${InteractiveIcons} {
-        display: flex;
+        function after(code2) {
+            return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
+        }
     }
-`;
-    const MessageTop = styled__default.default.div`
-    display: flex;
-    justify-content: space-between;
+    const labelStartLink = {
+        name: "labelStartLink",
+        tokenize: tokenizeLabelStartLink,
+        resolveAll: labelEnd.resolveAll
+    };
 
-    width: 100%;
-    height: 1.625rem;
+    function tokenizeLabelStartLink(effects, ok2, nok) {
+        const self2 = this;
+        return start2;
 
-    font-size: 0.8rem;
-    color: ${(props) => props.theme.colors.grey5};
-`;
-    const MessageBody = styled__default.default.span`
-    width: 100%;
-    color: ${(props) => props.theme.colors.text};
-    overflow-wrap: break-word;
-`;
-    const EditedText = styled__default.default.span`
-    font-size: 0.8rem;
-    color: ${(props) => props.theme.colors.grey4};
-`;
-    const DeleteIcon = styled__default.default(Trash)`
-    height: 0.8rem;
-    color: ${(props) => props.theme.colors.secondary};
+        function start2(code2) {
+            effects.enter("labelLink");
+            effects.enter("labelMarker");
+            effects.consume(code2);
+            effects.exit("labelMarker");
+            effects.exit("labelLink");
+            return after;
+        }
 
-    :hover {
-        color: ${(props) => props.theme.colors.secondaryHover}CC;
+        function after(code2) {
+            return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
+        }
     }
+    const lineEnding = {
+        name: "lineEnding",
+        tokenize: tokenizeLineEnding
+    };
 
-    :active {
-        color: ${(props) => props.theme.colors.secondaryDown}99;
-    }
-`;
-    const EditIcon = styled__default.default(PenToSquare)`
-    height: 0.8rem;
-    color: ${(props) => props.theme.colors.secondary};
+    function tokenizeLineEnding(effects, ok2) {
+        return start2;
 
-    :hover {
-        color: ${(props) => props.theme.colors.secondaryHover}CC;
+        function start2(code2) {
+            effects.enter("lineEnding");
+            effects.consume(code2);
+            effects.exit("lineEnding");
+            return factorySpace(effects, ok2, "linePrefix");
+        }
     }
+    const thematicBreak$2 = {
+        name: "thematicBreak",
+        tokenize: tokenizeThematicBreak
+    };
 
-    :active {
-        color: ${(props) => props.theme.colors.secondaryDown}99;
-    }
-`;
-    const EditButtons = styled__default.default.div`
-    display: flex;
-    gap: 1rem;
-    justify-content: flex-end;
-`;
+    function tokenizeThematicBreak(effects, ok2, nok) {
+        let size2 = 0;
+        let marker;
+        return start2;
 
-    function getFormattedTimestamp(date) {
-        return format$2(parseISO$1(date), "HH:mm dd/MM/yyyy");
-    }
+        function start2(code2) {
+            effects.enter("thematicBreak");
+            return before(code2);
+        }
 
-    function MessageComponent(props) {
-        const [editMode, setEditMode] = React__namespace.useState(false);
-        const [editMessage, setEditMessage] = React__namespace.useState(props.value.message);
-        const [localMessage, setLocalMessage] = React__namespace.useState(props.value);
-        if (props.value && !lodash$1.exports.isEqual(props.value, localMessage)) {
-            setLocalMessage(props.value);
+        function before(code2) {
+            marker = code2;
+            return atBreak(code2);
         }
-        const onAccept = () => {
-            if (editMessage === localMessage.message) {
-                setEditMode(false);
-                return;
+
+        function atBreak(code2) {
+            if (code2 === marker) {
+                effects.enter("thematicBreakSequence");
+                return sequence(code2);
             }
-            const newMessage = Object.assign(Object.assign({}, localMessage), {
-                message: editMessage.replace(/\n/g, " ").trim(),
-                updated_at: new Date().toISOString()
-            });
-            props === null || props === void 0 ? void 0 : props.onChange(newMessage);
-            setLocalMessage(newMessage);
-            setEditMessage(newMessage.message);
-            setEditMode(false);
-        };
-        const onDelete = () => {
-            if (props.onDelete) {
-                props.onDelete(props.value.id);
+            if (size2 >= 3 && (code2 === null || markdownLineEnding(code2))) {
+                effects.exit("thematicBreak");
+                return ok2(code2);
             }
-        };
-        return jsxRuntime.exports.jsxs(MessageWrapper, {
-            className: props.className,
-            style: props.style,
-            children: [jsxRuntime.exports.jsxs(MessageTop, {
-                children: [jsxRuntime.exports.jsxs("div", {
-                    children: [getFormattedTimestamp(props.value.created_at), localMessage.updated_at !== localMessage.created_at && jsxRuntime.exports.jsx(Tooltip$1, {
-                        content: getFormattedTimestamp(props.value.updated_at),
-                        children: jsxRuntime.exports.jsx(EditedText, {
-                            children: " (edited)"
-                        })
-                    })]
-                }), !editMode && jsxRuntime.exports.jsxs(InteractiveIcons, {
-                    children: [jsxRuntime.exports.jsx(EditIcon, {
-                        "data-testid": "message-edit-button",
-                        onClick: () => setEditMode(true),
-                        role: "button"
-                    }), jsxRuntime.exports.jsx(DeleteIcon, {
-                        "data-testid": "message-delete-button",
-                        onClick: onDelete,
-                        role: "button"
-                    })]
-                })]
-            }), editMode && jsxRuntime.exports.jsxs("div", {
-                style: {
-                    display: "flex",
-                    flexDirection: "column",
-                    gap: "1rem"
-                },
-                children: [jsxRuntime.exports.jsx(TextArea, {
-                    onChange: setEditMessage,
-                    resize: "vertical",
-                    value: editMessage
-                }), jsxRuntime.exports.jsxs(EditButtons, {
-                    children: [jsxRuntime.exports.jsx(Button$3, {
-                        onClick: () => setEditMode(false),
-                        outline: true,
-                        children: "Cancel"
-                    }), jsxRuntime.exports.jsx(Button$3, {
-                        onClick: onAccept,
-                        children: "Save"
-                    })]
-                })]
-            }), !editMode && jsxRuntime.exports.jsx(MessageBody, {
-                children: localMessage.message
-            })]
-        });
-    }
-    const ChatWrapper$1 = styled__default.default.div`
-    overflow-y: auto;
-    display: flex;
-    flex-direction: column;
-    gap: 1rem;
-
-    width: 350px;
-    height: calc(100vh - 2rem);
-    margin: 1rem;
-    padding: 1.5rem;
-
-    background-color: ${(props) => props.theme.colors.background}e6;
-    border-radius: 0.4rem;
-    box-shadow: ${(props) => props.theme.shadow.medium};
-`;
-    const ReplyWrapper = styled__default.default.div`
-    display: flex;
-    flex-direction: column;
-    gap: 1rem;
-    justify-self: flex-end;
-
-    height: 8.6rem;
-    margin-top: auto;
-`;
-    const ReplyButtons = styled__default.default.div`
-    display: flex;
-    gap: 1rem;
-    justify-content: flex-end;
-`;
-    const ChatBody = styled__default.default.div`
-    overflow-y: auto;
-    display: flex;
-    flex-direction: column;
-    gap: 1rem;
-
-    max-height: calc(100% - 10.225rem);
-    margin: -0.25rem;
-    padding: 0.25rem;
-`;
-    const ChatTop = styled__default.default.div`
-    display: flex;
-    align-items: center;
-    justify-content: space-between;
-
-    width: 100%;
-    height: 1.625rem;
-
-    font-size: 1.2rem;
-`;
-    const CloseIcon = styled__default.default(Xmark)`
-    height: 1.2rem;
-    color: ${(props) => props.theme.colors.grey4};
+            return nok(code2);
+        }
 
-    :hover {
-        color: ${(props) => props.theme.colors.grey5};
+        function sequence(code2) {
+            if (code2 === marker) {
+                effects.consume(code2);
+                size2++;
+                return sequence;
+            }
+            effects.exit("thematicBreakSequence");
+            return markdownSpace(code2) ? factorySpace(effects, atBreak, "whitespace")(code2) : atBreak(code2);
+        }
     }
+    const list$2 = {
+        name: "list",
+        tokenize: tokenizeListStart,
+        continuation: {
+            tokenize: tokenizeListContinuation
+        },
+        exit: tokenizeListEnd
+    };
+    const listItemPrefixWhitespaceConstruct = {
+        tokenize: tokenizeListItemPrefixWhitespace,
+        partial: true
+    };
+    const indentConstruct = {
+        tokenize: tokenizeIndent$1,
+        partial: true
+    };
 
-    :active {
-        color: ${(props) => props.theme.colors.grey6};
-    }
-`;
+    function tokenizeListStart(effects, ok2, nok) {
+        const self2 = this;
+        const tail = self2.events[self2.events.length - 1];
+        let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
+        let size2 = 0;
+        return start2;
 
-    function scrollToBottom(node2) {
-        setTimeout(() => {
-            if (node2) {
-                node2.scrollTop = node2.scrollHeight;
+        function start2(code2) {
+            const kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
+            if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
+                if (!self2.containerState.type) {
+                    self2.containerState.type = kind;
+                    effects.enter(kind, {
+                        _container: true
+                    });
+                }
+                if (kind === "listUnordered") {
+                    effects.enter("listItemPrefix");
+                    return code2 === 42 || code2 === 45 ? effects.check(thematicBreak$2, nok, atMarker)(code2) : atMarker(code2);
+                }
+                if (!self2.interrupt || code2 === 49) {
+                    effects.enter("listItemPrefix");
+                    effects.enter("listItemValue");
+                    return inside2(code2);
+                }
             }
-        }, 100);
-    }
-
-    function Chat$1(props) {
-        var _a3;
-        const [reply, setReply] = React__namespace.useState("");
-        const [localMessages, setLocalMessages] = React__namespace.useState((_a3 = props.value) !== null && _a3 !== void 0 ? _a3 : []);
-        if (props.value && !lodash$1.exports.isEqual(props.value, localMessages)) {
-            setLocalMessages(props.value);
+            return nok(code2);
         }
-        const chatBodyRef = React__namespace.useRef(null);
-        const onChangeReply = (text2) => {
-            if (!text2.startsWith("\n")) {
-                setReply(text2);
+
+        function inside2(code2) {
+            if (asciiDigit(code2) && ++size2 < 10) {
+                effects.consume(code2);
+                return inside2;
             }
-        };
-        const onSubmitMessage = () => {
-            var _a4;
-            if (reply) {
-                const timestamp = new Date().toISOString();
-                const newMessage = {
-                    id: nanoid(),
-                    message: reply.trim(),
-                    created_at: timestamp,
-                    updated_at: timestamp
-                };
-                const newMessages = [...localMessages, newMessage];
-                (_a4 = props.onUpdate) === null || _a4 === void 0 ? void 0 : _a4.call(props, newMessages);
-                setLocalMessages(newMessages);
-                setReply("");
-                scrollToBottom(chatBodyRef === null || chatBodyRef === void 0 ? void 0 : chatBodyRef.current);
+            if ((!self2.interrupt || size2 < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
+                effects.exit("listItemValue");
+                return atMarker(code2);
             }
-        };
-        const onEditMessage = (message) => {
-            var _a4;
-            const newMessages = localMessages.map((m2) => {
-                if (m2.id === message.id) {
-                    return message;
-                }
-                return m2;
-            });
-            (_a4 = props.onUpdate) === null || _a4 === void 0 ? void 0 : _a4.call(props, newMessages);
-            setLocalMessages(newMessages);
-        };
-        const onDeleteMessage = (id2) => {
-            var _a4;
-            const newMessages = localMessages.filter((message) => message.id !== id2);
-            (_a4 = props.onUpdate) === null || _a4 === void 0 ? void 0 : _a4.call(props, newMessages);
-            setLocalMessages(newMessages);
-        };
-        React__namespace.useLayoutEffect(() => {
-            scrollToBottom(chatBodyRef === null || chatBodyRef === void 0 ? void 0 : chatBodyRef.current);
-        }, []);
-        return jsxRuntime.exports.jsxs(ChatWrapper$1, {
-            className: props.className,
-            style: props.style,
-            children: [jsxRuntime.exports.jsxs(ChatTop, {
-                children: [jsxRuntime.exports.jsx("span", {
-                    children: "Chat"
-                }), jsxRuntime.exports.jsx(CloseIcon, {
-                    onClick: props.onClose
-                })]
-            }), jsxRuntime.exports.jsx(ChatBody, {
-                ref: chatBodyRef,
-                children: localMessages.map((message) => jsxRuntime.exports.jsx(MessageComponent, {
-                    onChange: onEditMessage,
-                    onDelete: onDeleteMessage,
-                    value: message
-                }, message.id))
-            }), jsxRuntime.exports.jsxs(ReplyWrapper, {
-                children: [jsxRuntime.exports.jsx(TextArea, {
-                    onChange: onChangeReply,
-                    onComplete: onSubmitMessage,
-                    placeholder: "Add a comment",
-                    resize: "none",
-                    value: reply
-                }), jsxRuntime.exports.jsx(ReplyButtons, {
-                    children: jsxRuntime.exports.jsx(Button$3, {
-                        disabled: !(reply.trim().length > 0),
-                        onClick: onSubmitMessage,
-                        children: "Send"
-                    })
-                })]
-            })]
-        });
-    }
-    const CheckboxWrapper$1 = styled__default.default.label`
-    cursor: ${(props) => props.disabled ? "not-allowed" : "pointer"};
-    user-select: none;
+            return nok(code2);
+        }
 
-    position: relative;
+        function atMarker(code2) {
+            effects.enter("listItemMarker");
+            effects.consume(code2);
+            effects.exit("listItemMarker");
+            self2.containerState.marker = self2.containerState.marker || code2;
+            return effects.check(
+                blankLine,
+                self2.interrupt ? nok : onBlank,
+                effects.attempt(
+                    listItemPrefixWhitespaceConstruct,
+                    endOfPrefix,
+                    otherPrefix
+                )
+            );
+        }
 
-    display: flex;
-    align-items: center;
+        function onBlank(code2) {
+            self2.containerState.initialBlankLine = true;
+            initialSize++;
+            return endOfPrefix(code2);
+        }
 
-    width: ${(props) => props.isListStyle ? "100%" : "fit-content"};
-    padding: 0.5625rem 0 0.5625rem 2rem;
+        function otherPrefix(code2) {
+            if (markdownSpace(code2)) {
+                effects.enter("listItemPrefixWhitespace");
+                effects.consume(code2);
+                effects.exit("listItemPrefixWhitespace");
+                return endOfPrefix;
+            }
+            return nok(code2);
+        }
 
-    font-size: 1rem;
+        function endOfPrefix(code2) {
+            self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
+            return ok2(code2);
+        }
+    }
 
-    border-radius: 0.25rem;
+    function tokenizeListContinuation(effects, ok2, nok) {
+        const self2 = this;
+        self2.containerState._closeFlow = void 0;
+        return effects.check(blankLine, onBlank, notBlank);
 
-    ${(props) => {
-    if (props.isListStyle && !props.disabled) {
-      return `
-                :hover {
-                    background-color: ${props.theme.colors.grey1};
+        function onBlank(code2) {
+            self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
+            return factorySpace(
+                effects,
+                ok2,
+                "listItemIndent",
+                self2.containerState.size + 1
+            )(code2);
+        }
 
-                    span {
-                        border: 1px solid ${props.theme.colors.grey4};
-                    }
-                }
+        function notBlank(code2) {
+            if (self2.containerState.furtherBlankLines || !markdownSpace(code2)) {
+                self2.containerState.furtherBlankLines = void 0;
+                self2.containerState.initialBlankLine = void 0;
+                return notInCurrentItem(code2);
+            }
+            self2.containerState.furtherBlankLines = void 0;
+            self2.containerState.initialBlankLine = void 0;
+            return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2);
+        }
 
-                :active {
-                    background-color: ${props.theme.colors.grey2};
-                }
-        `;
+        function notInCurrentItem(code2) {
+            self2.containerState._closeFlow = true;
+            self2.interrupt = void 0;
+            return factorySpace(
+                effects,
+                effects.attempt(list$2, ok2, nok),
+                "linePrefix",
+                self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
+            )(code2);
+        }
     }
-  }}
-
-    /* sets checkmark indicator */
-    span::after {
-        top: 0.05rem;
-        left: 0.3rem;
-        transform: rotate(45deg);
 
-        width: 0.3125rem;
-        height: 0.625rem;
+    function tokenizeIndent$1(effects, ok2, nok) {
+        const self2 = this;
+        return factorySpace(
+            effects,
+            afterPrefix,
+            "listItemIndent",
+            self2.containerState.size + 1
+        );
 
-        border: solid ${(props) => props.theme.colors.grey5};
-        border-width: 0 2px 2px 0;
+        function afterPrefix(code2) {
+            const tail = self2.events[self2.events.length - 1];
+            return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok2(code2) : nok(code2);
+        }
     }
 
-    /* Show the checkmark when checked */
-    input:checked ~ span::after {
-        display: block;
+    function tokenizeListEnd(effects) {
+        effects.exit(this.containerState.type);
     }
 
-    :hover {
-        span,
-        input:checked ~ span {
-            background-color: ${(props) => {
-    if (props.disabled) {
-      return props.theme.colors.grey3;
-    }
-    if (props.isListStyle) {
-      return props.theme.colors.blue1;
-    }
-    return props.theme.colors.grey1;
-  }};
-            border: 1px solid ${(props) => props.theme.colors.grey4};
+    function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
+        const self2 = this;
+        return factorySpace(
+            effects,
+            afterPrefix,
+            "listItemPrefixWhitespace",
+            self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1
+        );
+
+        function afterPrefix(code2) {
+            const tail = self2.events[self2.events.length - 1];
+            return !markdownSpace(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok2(code2) : nok(code2);
         }
     }
+    const setextUnderline = {
+        name: "setextUnderline",
+        tokenize: tokenizeSetextUnderline,
+        resolveTo: resolveToSetextUnderline
+    };
 
-    /* stylelint-disable -- messy specificity ordering */
-    :active {
-        span,
-        input:checked ~ span {
-            background-color: ${(props) => {
-    if (props.disabled) {
-      return props.theme.colors.grey3;
-    }
-    if (props.isListStyle) {
-      return props.theme.colors.blue1;
-    }
-    return props.theme.colors.grey2;
-  }};
+    function resolveToSetextUnderline(events2, context2) {
+        let index2 = events2.length;
+        let content2;
+        let text2;
+        let definition2;
+        while (index2--) {
+            if (events2[index2][0] === "enter") {
+                if (events2[index2][1].type === "content") {
+                    content2 = index2;
+                    break;
+                }
+                if (events2[index2][1].type === "paragraph") {
+                    text2 = index2;
+                }
+            } else {
+                if (events2[index2][1].type === "content") {
+                    events2.splice(index2, 1);
+                }
+                if (!definition2 && events2[index2][1].type === "definition") {
+                    definition2 = index2;
+                }
+            }
         }
+        const heading2 = {
+            type: "setextHeading",
+            start: Object.assign({}, events2[text2][1].start),
+            end: Object.assign({}, events2[events2.length - 1][1].end)
+        };
+        events2[text2][1].type = "setextHeadingText";
+        if (definition2) {
+            events2.splice(text2, 0, ["enter", heading2, context2]);
+            events2.splice(definition2 + 1, 0, ["exit", events2[content2][1], context2]);
+            events2[content2][1].end = Object.assign({}, events2[definition2][1].end);
+        } else {
+            events2[content2][1] = heading2;
+        }
+        events2.push(["exit", heading2, context2]);
+        return events2;
     }
-`;
-    const StyledCheckbox$1 = styled__default.default.input`
-    cursor: pointer;
-
-    /* Hide the browser's default checkbox */
-    position: absolute;
-
-    width: 0;
-    height: 0;
 
-    opacity: 0;
+    function tokenizeSetextUnderline(effects, ok2, nok) {
+        const self2 = this;
+        let marker;
+        return start2;
 
-    :checked ~ span {
-        background-color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.blue1};
-    }
-`;
-    const StyledCheckmark$1 = styled__default.default.span`
-    position: absolute;
-    left: 0.5rem;
+        function start2(code2) {
+            let index2 = self2.events.length;
+            let paragraph2;
+            while (index2--) {
+                if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
+                    paragraph2 = self2.events[index2][1].type === "paragraph";
+                    break;
+                }
+            }
+            if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
+                effects.enter("setextHeadingLine");
+                marker = code2;
+                return before(code2);
+            }
+            return nok(code2);
+        }
 
-    width: 1rem;
-    height: 1rem;
+        function before(code2) {
+            effects.enter("setextHeadingLineSequence");
+            return inside2(code2);
+        }
 
-    background-color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.blue1};
-    border: 1px solid ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.grey4};
-    border-radius: 0.25rem;
+        function inside2(code2) {
+            if (code2 === marker) {
+                effects.consume(code2);
+                return inside2;
+            }
+            effects.exit("setextHeadingLineSequence");
+            return markdownSpace(code2) ? factorySpace(effects, after, "lineSuffix")(code2) : after(code2);
+        }
 
-    // hidden checkmark indicator
-    :after {
-        content: '';
-        position: absolute;
-        display: none;
+        function after(code2) {
+            if (code2 === null || markdownLineEnding(code2)) {
+                effects.exit("setextHeadingLine");
+                return ok2(code2);
+            }
+            return nok(code2);
+        }
     }
-`;
+    const flow$1 = {
+        tokenize: initializeFlow
+    };
 
-    function Checkbox(props) {
-        const [checked, setChecked] = React.useState(props.selected || props.initialValue);
-        React.useEffect(() => {
-            if (props.selected !== void 0) {
-                setChecked(props.selected);
-            }
-        }, [props.selected]);
-        const onClick = (e3) => {
-            if (props.disabled) {
+    function initializeFlow(effects) {
+        const self2 = this;
+        const initial2 = effects.attempt(
+            blankLine,
+            atBlankEnding,
+            effects.attempt(
+                this.parser.constructs.flowInitial,
+                afterConstruct,
+                factorySpace(
+                    effects,
+                    effects.attempt(
+                        this.parser.constructs.flow,
+                        afterConstruct,
+                        effects.attempt(content$1, afterConstruct)
+                    ),
+                    "linePrefix"
+                )
+            )
+        );
+        return initial2;
+
+        function atBlankEnding(code2) {
+            if (code2 === null) {
+                effects.consume(code2);
                 return;
             }
-            if (props.selected === void 0) {
-                setChecked(!checked);
-            }
-            if (props.onChange) {
-                props.onChange(!checked, e3);
-            }
-        };
-        return jsxRuntime.exports.jsxs(CheckboxWrapper$1, {
-            className: props.className,
-            disabled: props.disabled,
-            isListStyle: props.isListStyle,
-            children: [props.label, jsxRuntime.exports.jsx(StyledCheckbox$1, {
-                "aria-disabled": props.disabled,
-                checked: props.selected,
-                disabled: props.disabled,
-                isListStyle: props.isListStyle,
-                onChange: (e3) => onClick(e3),
-                onClick: props.onClick,
-                type: "checkbox",
-                value: props.id
-            }), jsxRuntime.exports.jsx(StyledCheckmark$1, {
-                disabled: props.disabled,
-                isListStyle: props.isListStyle
-            })]
-        });
-    }
-    const CheckboxWrapper = styled__default.default.div`
-    user-select: none;
-    display: flex;
-    width: 100%;
-    border: none;
-`;
-    const CheckboxGroupWrapper = styled__default.default.div`
-    color: ${(props) => props.theme.colors.text};
-`;
-    const CheckboxInfo = styled__default.default.p`
-    font-size: 0.75rem;
-    color: ${(props) => props.theme.colors.grey4};
-`;
-
-    function getInitialValue$3(initialValue) {
-        if (Array.isArray(initialValue)) {
-            return initialValue;
-        }
-        if (initialValue) {
-            return [initialValue];
+            effects.enter("lineEndingBlank");
+            effects.consume(code2);
+            effects.exit("lineEndingBlank");
+            self2.currentConstruct = void 0;
+            return initial2;
         }
-        return [];
-    }
 
-    function getInitialCheckedState(items, initialValues) {
-        if (initialValues) {
-            return items.map((item) => ({
-                state: initialValues.includes(item.value),
-                value: item.value
-            }));
+        function afterConstruct(code2) {
+            if (code2 === null) {
+                effects.consume(code2);
+                return;
+            }
+            effects.enter("lineEnding");
+            effects.consume(code2);
+            effects.exit("lineEnding");
+            self2.currentConstruct = void 0;
+            return initial2;
         }
-        return items.map((item) => ({
-            state: initialValues.includes(item.value),
-            value: false
-        }));
     }
+    const resolver$1 = {
+        resolveAll: createResolver()
+    };
+    const string$3 = initializeFactory("string");
+    const text$5 = initializeFactory("text");
 
-    function CheckboxGroup$1(props) {
-        const [values, setValues] = React.useState(() => getInitialValue$3(props.values || props.initialValue));
-        const [checkedState, setCheckedState] = React.useState(() => getInitialCheckedState(props.items, values));
-        const isSelectPermitted = React.useMemo(() => {
-            if (!props.selectMax || values.length < props.selectMax) {
-                return true;
-            }
-            return false;
-        }, [values, props.selectMax]);
-        const infoMessage = React.useMemo(() => {
-            if (props.selectMax && props.selectMin) {
-                return `You can select from ${props.selectMin} to ${props.selectMax} options`;
-            }
-            if (props.selectMax) {
-                return `You can select up to ${props.selectMax} options`;
-            }
-            if (props.selectMin) {
-                return `You should select at least ${props.selectMin} options`;
+    function initializeFactory(field) {
+        return {
+            tokenize: initializeText,
+            resolveAll: createResolver(
+                field === "text" ? resolveAllLineSuffixes : void 0
+            )
+        };
+
+        function initializeText(effects) {
+            const self2 = this;
+            const constructs2 = this.parser.constructs[field];
+            const text2 = effects.attempt(constructs2, start2, notText);
+            return start2;
+
+            function start2(code2) {
+                return atBreak(code2) ? text2(code2) : notText(code2);
             }
-        }, [props.selectMax, props.selectMin]);
-        const onChangeValue = (event2) => {
-            var _a3;
-            const target = event2.target;
-            const chosenIndex = Number(target.value);
-            const chosenValue = props.items[chosenIndex].value;
-            let newValues = [...values];
-            if (values.includes(chosenValue)) {
-                newValues = newValues.filter((value) => value !== chosenValue);
-            } else {
-                newValues.push(chosenValue);
+
+            function notText(code2) {
+                if (code2 === null) {
+                    effects.consume(code2);
+                    return;
+                }
+                effects.enter("data");
+                effects.consume(code2);
+                return data2;
             }
-            if (newValues.length > props.selectMax && checkedState[chosenIndex] || newValues.length <= props.selectMax || !props.selectMax) {
-                const indexToUpdate = checkedState.findIndex((item) => item.value === chosenValue);
-                checkedState[indexToUpdate].state = !checkedState[indexToUpdate].state;
-                setCheckedState(checkedState);
-                setValues(newValues);
-                if (!props.selectMin || newValues.length >= props.selectMin) {
-                    (_a3 = props.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, props.items.filter((item) => newValues.includes(item.value)), event2);
+
+            function data2(code2) {
+                if (atBreak(code2)) {
+                    effects.exit("data");
+                    return text2(code2);
                 }
+                effects.consume(code2);
+                return data2;
             }
-        };
-        React.useEffect(() => {
-            if (props.values) {
-                const valuesArray = props.values.map((value) => value.value);
-                setCheckedState(props.items.map((item) => ({
-                    state: valuesArray.includes(item.value),
-                    value: item.value
-                })));
-                setValues(valuesArray);
+
+            function atBreak(code2) {
+                if (code2 === null) {
+                    return true;
+                }
+                const list2 = constructs2[code2];
+                let index2 = -1;
+                if (list2) {
+                    while (++index2 < list2.length) {
+                        const item = list2[index2];
+                        if (!item.previous || item.previous.call(self2, self2.previous)) {
+                            return true;
+                        }
+                    }
+                }
+                return false;
             }
-        }, [props.values, props.items]);
-        return jsxRuntime.exports.jsxs(CheckboxGroupWrapper, {
-            className: props.className,
-            style: props.style,
-            children: [(props.selectMax || props.selectMin) && jsxRuntime.exports.jsx(CheckboxInfo, {
-                children: infoMessage
-            }), props.items.map((item, index2) => {
-                var _a3, _b;
-                return jsxRuntime.exports.jsx(CheckboxWrapper, {
-                    "aria-disabled": props.disabled,
-                    children: jsxRuntime.exports.jsx(Checkbox, {
-                        disabled: isSelectPermitted ? props.disabled : ((_a3 = checkedState.find((option) => option.value === item.value)) === null || _a3 === void 0 ? void 0 : _a3.state) === false,
-                        id: index2,
-                        isListStyle: props.isListStyle,
-                        label: item.label ? item.label : item.value,
-                        onChange: (checked, e3) => onChangeValue(e3),
-                        selected: (_b = checkedState.find((option) => option.value === item.value)) === null || _b === void 0 ? void 0 : _b.state
-                    })
-                }, `item-${index2}`);
-            })]
-        });
+        }
     }
-    var __rest$b = globalThis && globalThis.__rest || function(s2, e3) {
-        var t2 = {};
-        for (var p2 in s2)
-            if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
-                t2[p2] = s2[p2];
-        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
-            for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
-                if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
-                    t2[p2[i2]] = s2[p2[i2]];
-            }
-        return t2;
-    };
-    const PrimaryInput = styled__default.default.input`
-    display: flex;
-    align-items: center;
-
-    width: 100%;
-    height: 100%;
-    padding: 0 1rem;
-
-    font-size: 1rem;
-    color: ${(props) => props.disabled ? props.theme.colors.grey2 : props.theme.colors.text};
-
-    background-color: ${(props) => props.theme.colors.grey1};
-    border: 1px solid ${(props) => props.isErrored ? props.theme.colors.error : props.theme.colors.grey1};
-    border-radius: 0.25rem;
-    outline: 0;
 
-    :active:not(:disabled),
-    :focus:not(:disabled) {
-        border: 1px solid ${(props) => props.isErrored ? props.theme.colors.error : props.theme.colors.grey3};
-    }
+    function createResolver(extraResolver) {
+        return resolveAllText;
 
-    :hover:not(:disabled) {
-        background-color: ${(props) => props.theme.colors.grey2};
+        function resolveAllText(events2, context2) {
+            let index2 = -1;
+            let enter;
+            while (++index2 <= events2.length) {
+                if (enter === void 0) {
+                    if (events2[index2] && events2[index2][1].type === "data") {
+                        enter = index2;
+                        index2++;
+                    }
+                } else if (!events2[index2] || events2[index2][1].type !== "data") {
+                    if (index2 !== enter + 2) {
+                        events2[enter][1].end = events2[index2 - 1][1].end;
+                        events2.splice(enter + 2, index2 - enter - 2);
+                        index2 = enter + 2;
+                    }
+                    enter = void 0;
+                }
+            }
+            return extraResolver ? extraResolver(events2, context2) : events2;
+        }
     }
 
-    :disabled {
-        cursor: not-allowed;
+    function resolveAllLineSuffixes(events2, context2) {
+        let eventIndex = 0;
+        while (++eventIndex <= events2.length) {
+            if ((eventIndex === events2.length || events2[eventIndex][1].type === "lineEnding") && events2[eventIndex - 1][1].type === "data") {
+                const data2 = events2[eventIndex - 1][1];
+                const chunks = context2.sliceStream(data2);
+                let index2 = chunks.length;
+                let bufferIndex = -1;
+                let size2 = 0;
+                let tabs;
+                while (index2--) {
+                    const chunk = chunks[index2];
+                    if (typeof chunk === "string") {
+                        bufferIndex = chunk.length;
+                        while (chunk.charCodeAt(bufferIndex - 1) === 32) {
+                            size2++;
+                            bufferIndex--;
+                        }
+                        if (bufferIndex)
+                            break;
+                        bufferIndex = -1;
+                    } else if (chunk === -2) {
+                        tabs = true;
+                        size2++;
+                    } else if (chunk === -1)
+                    ;
+                    else {
+                        index2++;
+                        break;
+                    }
+                }
+                if (size2) {
+                    const token = {
+                        type: eventIndex === events2.length || tabs || size2 < 2 ? "lineSuffix" : "hardBreakTrailing",
+                        start: {
+                            line: data2.end.line,
+                            column: data2.end.column - size2,
+                            offset: data2.end.offset - size2,
+                            _index: data2.start._index + index2,
+                            _bufferIndex: index2 ? bufferIndex : data2.start._bufferIndex + bufferIndex
+                        },
+                        end: Object.assign({}, data2.end)
+                    };
+                    data2.end = Object.assign({}, token.start);
+                    if (data2.start.offset === data2.end.offset) {
+                        Object.assign(data2, token);
+                    } else {
+                        events2.splice(
+                            eventIndex,
+                            0,
+                            ["enter", token, context2],
+                            ["exit", token, context2]
+                        );
+                        eventIndex += 2;
+                    }
+                }
+                eventIndex++;
+            }
+        }
+        return events2;
     }
 
-    ::placeholder {
-        font-style: italic;
-    }
-`;
-    const InputWrapper$5 = styled__default.default.div`
-    width: 22ch;
-    max-width: 100%;
-    height: 2.5rem;
-`;
-    const ErrorMessage$1 = styled__default.default.span`
-    margin-left: 1rem;
-    font-size: 0.75rem;
-    color: ${(props) => props.theme.colors.error};
-`;
-    const Input$3 = React.forwardRef((_a3, ref2) => {
-        var {
-            type: type2 = "text"
-        } = _a3, props = __rest$b(_a3, ["type"]);
-        const onChange2 = (e3) => {
-            const target = e3.target;
-            if (props.onChange) {
-                props.onChange(target.value, e3);
+    function createTokenizer(parser2, initialize, from) {
+        let point2 = Object.assign(
+            from ? Object.assign({}, from) : {
+                line: 1,
+                column: 1,
+                offset: 0
+            }, {
+                _index: 0,
+                _bufferIndex: -1
             }
+        );
+        const columnStart = {};
+        const resolveAllConstructs = [];
+        let chunks = [];
+        let stack = [];
+        const effects = {
+            consume,
+            enter,
+            exit: exit2,
+            attempt: constructFactory(onsuccessfulconstruct),
+            check: constructFactory(onsuccessfulcheck),
+            interrupt: constructFactory(onsuccessfulcheck, {
+                interrupt: true
+            })
         };
-        const onKeyDown = (e3) => {
-            if (props.onKeyDown) {
-                props.onKeyDown(e3);
-            }
-            if (props.keydownFilter && !props.keydownFilter(e3)) {
-                e3.preventDefault();
-            }
-            if (e3.key === Key.ENTER && props.onComplete) {
-                props.onComplete();
-            }
+        const context2 = {
+            previous: null,
+            code: null,
+            containerState: {},
+            events: [],
+            parser: parser2,
+            sliceStream,
+            sliceSerialize,
+            now: now2,
+            defineSkip,
+            write: write2
         };
-        const addOptionalItems = () => {
-            const result = {};
-            if (props.minValue) {
-                result.minValue = props.minValue;
-            }
-            if (props.maxValue) {
-                result.maxValue = props.minValue;
+        let state = initialize.tokenize.call(context2, effects);
+        if (initialize.resolveAll) {
+            resolveAllConstructs.push(initialize);
+        }
+        return context2;
+
+        function write2(slice) {
+            chunks = push$2(chunks, slice);
+            main2();
+            if (chunks[chunks.length - 1] !== null) {
+                return [];
             }
-            return result;
-        };
-        return jsxRuntime.exports.jsxs(InputWrapper$5, {
-            className: props.className,
-            style: props.style,
-            children: [jsxRuntime.exports.jsx(PrimaryInput, Object.assign({
-                autoFocus: props.autoFocus,
-                defaultValue: props.initialValue,
-                disabled: props.disabled,
-                isErrored: !!props.errorMsg,
-                maxLength: props.maxLength,
-                onBlur: props.onBlur,
-                onChange: onChange2,
-                onClick: props.onClick,
-                onKeyDown,
-                placeholder: props.placeholder,
-                ref: ref2,
-                type: type2,
-                value: props.value
-            }, addOptionalItems())), props.errorMsg && jsxRuntime.exports.jsxs(ErrorMessage$1, {
-                children: [props.errorMsg, " "]
-            })]
-        });
-    });
-    Input$3.displayName = "Input";
-    const Wrapper$b = styled__default.default.div`
-    display: flex;
-    margin: 0 0.5rem;
-`;
-    const SearchBarComponent = styled__default.default(Input$3)`
-    input {
-        padding-right: 2.25rem;
-    }
+            addResult(initialize, 0);
+            context2.events = resolveAll(resolveAllConstructs, context2.events, context2);
+            return context2.events;
+        }
 
-    :hover:not(:disabled) {
-        input {
-            border: 1px solid ${(props) => props.theme.colors.grey3};
+        function sliceSerialize(token, expandTabs) {
+            return serializeChunks(sliceStream(token), expandTabs);
         }
-    }
-`;
-    const SearchBarIcon = styled__default.default(MagnifyingGlass)`
-    position: relative;
-    top: 0.625rem;
-    right: 1.75rem;
 
-    height: 1.25rem;
+        function sliceStream(token) {
+            return sliceChunks(chunks, token);
+        }
 
-    color: ${(props) => props.theme.colors.grey4};
-`;
+        function now2() {
+            const {
+                line,
+                column,
+                offset: offset2,
+                _index,
+                _bufferIndex
+            } = point2;
+            return {
+                line,
+                column,
+                offset: offset2,
+                _index,
+                _bufferIndex
+            };
+        }
 
-    function SearchBar(props) {
-        var _a3;
-        return jsxRuntime.exports.jsxs(Wrapper$b, {
-            children: [jsxRuntime.exports.jsx(SearchBarComponent, {
-                className: props.className,
-                disabled: props.disabled,
-                maxLength: props.maxLength,
-                onChange: props.onChange,
-                placeholder: (_a3 = props.placeholder) !== null && _a3 !== void 0 ? _a3 : "Search",
-                style: props.style,
-                value: props.value
-            }), jsxRuntime.exports.jsx(SearchBarIcon, {})]
-        });
-    }
-    const FilterWrapper = styled__default.default.div`
-    display: flex;
-    flex-direction: column;
-    gap: 0.5rem;
+        function defineSkip(value) {
+            columnStart[value.line] = value.column;
+            accountForPotentialSkip();
+        }
 
-    width: 17.5rem;
-    padding: 1.25rem 0.5rem;
+        function main2() {
+            let chunkIndex;
+            while (point2._index < chunks.length) {
+                const chunk = chunks[point2._index];
+                if (typeof chunk === "string") {
+                    chunkIndex = point2._index;
+                    if (point2._bufferIndex < 0) {
+                        point2._bufferIndex = 0;
+                    }
+                    while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
+                        go2(chunk.charCodeAt(point2._bufferIndex));
+                    }
+                } else {
+                    go2(chunk);
+                }
+            }
+        }
 
-    background-color: ${(props) => props.theme.colors.grey1};
-    border-radius: 0.25rem;
-    box-shadow: ${(props) => props.theme.shadow.light};
-`;
-    const StyledSearchBar = styled__default.default(SearchBar)`
-    width: 15.5rem;
-    background-color: ${(props) => props.theme.colors.blue1};
-    border: 1px solid ${(props) => props.theme.colors.blue1};
-    border-radius: 0.25rem;
+        function go2(code2) {
+            state = state(code2);
+        }
 
-    input {
-        width: 15.5rem;
-        background-color: ${(props) => props.theme.colors.blue1};
-        border: none;
+        function consume(code2) {
+            if (markdownLineEnding(code2)) {
+                point2.line++;
+                point2.column = 1;
+                point2.offset += code2 === -3 ? 2 : 1;
+                accountForPotentialSkip();
+            } else if (code2 !== -1) {
+                point2.column++;
+                point2.offset++;
+            }
+            if (point2._bufferIndex < 0) {
+                point2._index++;
+            } else {
+                point2._bufferIndex++;
+                if (point2._bufferIndex === chunks[point2._index].length) {
+                    point2._bufferIndex = -1;
+                    point2._index++;
+                }
+            }
+            context2.previous = code2;
+        }
 
-        :active:not(:disabled),
-        :focus:not(:disabled) {
-            border: none;
+        function enter(type2, fields) {
+            const token = fields || {};
+            token.type = type2;
+            token.start = now2();
+            context2.events.push(["enter", token, context2]);
+            stack.push(token);
+            return token;
         }
-    }
 
-    :hover:not(:disabled) {
-        background-color: ${(props) => props.theme.colors.blue1};
-        border: 1px solid ${(props) => props.theme.colors.grey2};
+        function exit2(type2) {
+            const token = stack.pop();
+            token.end = now2();
+            context2.events.push(["exit", token, context2]);
+            return token;
+        }
 
-        input {
-            background-color: ${(props) => props.theme.colors.blue1};
-            border: none;
+        function onsuccessfulconstruct(construct, info) {
+            addResult(construct, info.from);
         }
-    }
-`;
-    const FilterButtons = styled__default.default.button`
-    font-size: 0.75rem;
-    font-weight: 400;
-    color: ${(props) => props.theme.colors.primary};
 
-    background-color: inherit;
-    border: none;
+        function onsuccessfulcheck(_2, info) {
+            info.restore();
+        }
 
-    :hover {
-        cursor: pointer;
-        color: ${(props) => props.theme.colors.primaryHover};
-    }
+        function constructFactory(onreturn, fields) {
+            return hook;
 
-    :active {
-        color: ${(props) => props.theme.colors.primaryDown};
-    }
+            function hook(constructs2, returnState, bogusState) {
+                let listOfConstructs;
+                let constructIndex;
+                let currentConstruct;
+                let info;
+                return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? handleListOfConstructs([constructs2]) : handleMapOfConstructs(constructs2);
 
-    :disabled {
-        cursor: not-allowed;
-        color: ${(props) => props.theme.colors.grey2};
-    }
-`;
-    const OptionsWrapper = styled__default.default.div`
-    overflow-y: auto;
-    height: 10rem;
-`;
-    const StyledCheckboxGroup = styled__default.default(CheckboxGroup$1)`
-    div {
-        height: 2rem;
-        padding: 0 0.75rem;
-    }
+                function handleMapOfConstructs(map2) {
+                    return start2;
 
-    label {
-        font-size: 0.75rem;
+                    function start2(code2) {
+                        const def = code2 !== null && map2[code2];
+                        const all2 = code2 !== null && map2.null;
+                        const list2 = [
+                            ...Array.isArray(def) ? def : def ? [def] : [],
+                            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
+                        ];
+                        return handleListOfConstructs(list2)(code2);
+                    }
+                }
 
-        :hover {
-            background: ${(props) => props.theme.colors.grey2} !important;
+                function handleListOfConstructs(list2) {
+                    listOfConstructs = list2;
+                    constructIndex = 0;
+                    if (list2.length === 0) {
+                        return bogusState;
+                    }
+                    return handleConstruct(list2[constructIndex]);
+                }
+
+                function handleConstruct(construct) {
+                    return start2;
+
+                    function start2(code2) {
+                        info = store();
+                        currentConstruct = construct;
+                        if (!construct.partial) {
+                            context2.currentConstruct = construct;
+                        }
+                        if (construct.name && context2.parser.constructs.disable.null.includes(construct.name)) {
+                            return nok();
+                        }
+                        return construct.tokenize.call(
+                            fields ? Object.assign(Object.create(context2), fields) : context2,
+                            effects,
+                            ok2,
+                            nok
+                        )(code2);
+                    }
+                }
+
+                function ok2(code2) {
+                    onreturn(currentConstruct, info);
+                    return returnState;
+                }
+
+                function nok(code2) {
+                    info.restore();
+                    if (++constructIndex < listOfConstructs.length) {
+                        return handleConstruct(listOfConstructs[constructIndex]);
+                    }
+                    return bogusState;
+                }
+            }
         }
 
-        :active {
-            background: ${(props) => props.theme.colors.grey3} !important;
+        function addResult(construct, from2) {
+            if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
+                resolveAllConstructs.push(construct);
+            }
+            if (construct.resolve) {
+                splice(
+                    context2.events,
+                    from2,
+                    context2.events.length - from2,
+                    construct.resolve(context2.events.slice(from2), context2)
+                );
+            }
+            if (construct.resolveTo) {
+                context2.events = construct.resolveTo(context2.events, context2);
+            }
         }
-    }
-`;
-    const ApplyButton = styled__default.default(FilterButtons)`
-    align-self: center;
 
-    width: fit-content;
-    height: 2rem;
-    padding: 0.5rem;
+        function store() {
+            const startPoint = now2();
+            const startPrevious = context2.previous;
+            const startCurrentConstruct = context2.currentConstruct;
+            const startEventsIndex = context2.events.length;
+            const startStack = Array.from(stack);
+            return {
+                restore,
+                from: startEventsIndex
+            };
 
-    font-size: 0.875rem;
-`;
+            function restore() {
+                point2 = startPoint;
+                context2.previous = startPrevious;
+                context2.currentConstruct = startCurrentConstruct;
+                context2.events.length = startEventsIndex;
+                stack = startStack;
+                accountForPotentialSkip();
+            }
+        }
 
-    function CategoricalFilter(props) {
-        var _a3;
-        const [inputValue, setInputValue] = React.useState("");
-        const [filterValue, setFilterValue] = React.useState((_a3 = props.values) !== null && _a3 !== void 0 ? _a3 : []);
-        const [previousFilter, setPreviousFilter] = React.useState(props.values);
-        const filteredItems = props.items.filter((item) => {
-            var _a4;
-            return inputValue ? (_a4 = item.label) === null || _a4 === void 0 ? void 0 : _a4.toLowerCase().includes(inputValue === null || inputValue === void 0 ? void 0 : inputValue.toLowerCase()) : true;
-        });
-        return jsxRuntime.exports.jsxs(FilterWrapper, {
-            className: props.className,
-            children: [jsxRuntime.exports.jsx(StyledSearchBar, {
-                onChange: (change) => setInputValue(change)
-            }), jsxRuntime.exports.jsxs("div", {
-                style: {
-                    display: "flex",
-                    height: "2rem",
-                    margin: "0rem 0.75rem -0.5rem 0.75rem"
-                },
-                children: [jsxRuntime.exports.jsx(FilterButtons, {
-                    onClick: () => setFilterValue(filteredItems),
-                    children: "Select all"
-                }), jsxRuntime.exports.jsx(FilterButtons, {
-                    onClick: () => setFilterValue([]),
-                    children: "Clear"
-                })]
-            }), jsxRuntime.exports.jsx(OptionsWrapper, {
-                children: jsxRuntime.exports.jsx(StyledCheckboxGroup, {
-                    isListStyle: true,
-                    items: filteredItems,
-                    onChange: (v2) => {
-                        var _a4, _b;
-                        const selectedFilteredItems = Array.isArray(v2) ? v2 : [v2];
-                        const unchecked = (_a4 = filterValue === null || filterValue === void 0 ? void 0 : filterValue.filter((value) => selectedFilteredItems.every((item) => !isEqual_1(value, item)) && filteredItems.some((item) => isEqual_1(value, item)))) !== null && _a4 !== void 0 ? _a4 : [];
-                        const newlyChecked = selectedFilteredItems.filter((value) => filterValue === null || filterValue === void 0 ? void 0 : filterValue.every((item) => !isEqual_1(value, item)));
-                        const stillChecked = (_b = filterValue === null || filterValue === void 0 ? void 0 : filterValue.filter((value) => !unchecked.some((item) => isEqual_1(value, item)))) !== null && _b !== void 0 ? _b : [];
-                        setFilterValue([...stillChecked, ...newlyChecked]);
-                    },
-                    values: filterValue
-                })
-            }), jsxRuntime.exports.jsx(ApplyButton, {
-                disabled: props.disabled || previousFilter === filterValue,
-                onClick: (e3) => {
-                    var _a4, _b;
-                    (_a4 = props.onChange) === null || _a4 === void 0 ? void 0 : _a4.call(props, filterValue, e3);
-                    (_b = props === null || props === void 0 ? void 0 : props.column) === null || _b === void 0 ? void 0 : _b.setFilter(filterValue || void 0);
-                    setPreviousFilter(filterValue);
-                },
-                children: "Apply"
-            })]
-        });
+        function accountForPotentialSkip() {
+            if (point2.line in columnStart && point2.column < 2) {
+                point2.column = columnStart[point2.line];
+                point2.offset += columnStart[point2.line] - 1;
+            }
+        }
     }
 
-    function _objectWithoutPropertiesLoose$4(source, excluded) {
-        if (source == null)
-            return {};
-        var target = {};
-        var sourceKeys = Object.keys(source);
-        var key, i2;
-        for (i2 = 0; i2 < sourceKeys.length; i2++) {
-            key = sourceKeys[i2];
-            if (excluded.indexOf(key) >= 0)
-                continue;
-            target[key] = source[key];
+    function sliceChunks(chunks, token) {
+        const startIndex = token.start._index;
+        const startBufferIndex = token.start._bufferIndex;
+        const endIndex = token.end._index;
+        const endBufferIndex = token.end._bufferIndex;
+        let view;
+        if (startIndex === endIndex) {
+            view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
+        } else {
+            view = chunks.slice(startIndex, endIndex);
+            if (startBufferIndex > -1) {
+                const head = view[0];
+                if (typeof head === "string") {
+                    view[0] = head.slice(startBufferIndex);
+                } else {
+                    view.shift();
+                }
+            }
+            if (endBufferIndex > 0) {
+                view.push(chunks[endIndex].slice(0, endBufferIndex));
+            }
         }
-        return target;
-    }
-    var reactIs = {
-        exports: {}
-    };
-    var reactIs_production_min = {};
-    /** @license React v17.0.2
-     * react-is.production.min.js
-     *
-     * Copyright (c) Facebook, Inc. and its affiliates.
-     *
-     * This source code is licensed under the MIT license found in the
-     * LICENSE file in the root directory of this source tree.
-     */
-    var b$3 = 60103,
-        c$4 = 60106,
-        d$1 = 60107,
-        e$2 = 60108,
-        f$2 = 60114,
-        g$2 = 60109,
-        h$2 = 60110,
-        k$2 = 60112,
-        l$2 = 60113,
-        m$2 = 60120,
-        n$2 = 60115,
-        p$2 = 60116,
-        q$2 = 60121,
-        r$2 = 60122,
-        u$1 = 60117,
-        v$2 = 60129,
-        w$3 = 60131;
-    if ("function" === typeof Symbol && Symbol.for) {
-        var x$3 = Symbol.for;
-        b$3 = x$3("react.element");
-        c$4 = x$3("react.portal");
-        d$1 = x$3("react.fragment");
-        e$2 = x$3("react.strict_mode");
-        f$2 = x$3("react.profiler");
-        g$2 = x$3("react.provider");
-        h$2 = x$3("react.context");
-        k$2 = x$3("react.forward_ref");
-        l$2 = x$3("react.suspense");
-        m$2 = x$3("react.suspense_list");
-        n$2 = x$3("react.memo");
-        p$2 = x$3("react.lazy");
-        q$2 = x$3("react.block");
-        r$2 = x$3("react.server.block");
-        u$1 = x$3("react.fundamental");
-        v$2 = x$3("react.debug_trace_mode");
-        w$3 = x$3("react.legacy_hidden");
+        return view;
     }
 
-    function y$5(a2) {
-        if ("object" === typeof a2 && null !== a2) {
-            var t2 = a2.$$typeof;
-            switch (t2) {
-                case b$3:
-                    switch (a2 = a2.type, a2) {
-                        case d$1:
-                        case f$2:
-                        case e$2:
-                        case l$2:
-                        case m$2:
-                            return a2;
-                        default:
-                            switch (a2 = a2 && a2.$$typeof, a2) {
-                                case h$2:
-                                case k$2:
-                                case p$2:
-                                case n$2:
-                                case g$2:
-                                    return a2;
-                                default:
-                                    return t2;
-                            }
+    function serializeChunks(chunks, expandTabs) {
+        let index2 = -1;
+        const result = [];
+        let atTab;
+        while (++index2 < chunks.length) {
+            const chunk = chunks[index2];
+            let value;
+            if (typeof chunk === "string") {
+                value = chunk;
+            } else
+                switch (chunk) {
+                    case -5: {
+                        value = "\r";
+                        break;
                     }
-                case c$4:
-                    return t2;
-            }
+                    case -4: {
+                        value = "\n";
+                        break;
+                    }
+                    case -3: {
+                        value = "\r\n";
+                        break;
+                    }
+                    case -2: {
+                        value = expandTabs ? " " : "	";
+                        break;
+                    }
+                    case -1: {
+                        if (!expandTabs && atTab)
+                            continue;
+                        value = " ";
+                        break;
+                    }
+                    default: {
+                        value = String.fromCharCode(chunk);
+                    }
+                }
+            atTab = chunk === -2;
+            result.push(value);
         }
+        return result.join("");
     }
-    var z$2 = g$2,
-        A$2 = b$3,
-        B$1 = k$2,
-        C$3 = d$1,
-        D$2 = p$2,
-        E$1 = n$2,
-        F$3 = c$4,
-        G$1 = f$2,
-        H$3 = e$2,
-        I$1 = l$2;
-    reactIs_production_min.ContextConsumer = h$2;
-    reactIs_production_min.ContextProvider = z$2;
-    reactIs_production_min.Element = A$2;
-    reactIs_production_min.ForwardRef = B$1;
-    reactIs_production_min.Fragment = C$3;
-    reactIs_production_min.Lazy = D$2;
-    reactIs_production_min.Memo = E$1;
-    reactIs_production_min.Portal = F$3;
-    reactIs_production_min.Profiler = G$1;
-    reactIs_production_min.StrictMode = H$3;
-    reactIs_production_min.Suspense = I$1;
-    reactIs_production_min.isAsyncMode = function() {
-        return false;
-    };
-    reactIs_production_min.isConcurrentMode = function() {
-        return false;
-    };
-    reactIs_production_min.isContextConsumer = function(a2) {
-        return y$5(a2) === h$2;
-    };
-    reactIs_production_min.isContextProvider = function(a2) {
-        return y$5(a2) === g$2;
-    };
-    reactIs_production_min.isElement = function(a2) {
-        return "object" === typeof a2 && null !== a2 && a2.$$typeof === b$3;
-    };
-    reactIs_production_min.isForwardRef = function(a2) {
-        return y$5(a2) === k$2;
+    const document$1 = {
+        [42]: list$2,
+        [43]: list$2,
+        [45]: list$2,
+        [48]: list$2,
+        [49]: list$2,
+        [50]: list$2,
+        [51]: list$2,
+        [52]: list$2,
+        [53]: list$2,
+        [54]: list$2,
+        [55]: list$2,
+        [56]: list$2,
+        [57]: list$2,
+        [62]: blockQuote
     };
-    reactIs_production_min.isFragment = function(a2) {
-        return y$5(a2) === d$1;
+    const contentInitial = {
+        [91]: definition$1
     };
-    reactIs_production_min.isLazy = function(a2) {
-        return y$5(a2) === p$2;
+    const flowInitial = {
+        [-2]: codeIndented,
+        [-1]: codeIndented,
+        [32]: codeIndented
     };
-    reactIs_production_min.isMemo = function(a2) {
-        return y$5(a2) === n$2;
+    const flow = {
+        [35]: headingAtx,
+        [42]: thematicBreak$2,
+        [45]: [setextUnderline, thematicBreak$2],
+        [60]: htmlFlow,
+        [61]: setextUnderline,
+        [95]: thematicBreak$2,
+        [96]: codeFenced,
+        [126]: codeFenced
     };
-    reactIs_production_min.isPortal = function(a2) {
-        return y$5(a2) === c$4;
+    const string$2 = {
+        [38]: characterReference,
+        [92]: characterEscape
     };
-    reactIs_production_min.isProfiler = function(a2) {
-        return y$5(a2) === f$2;
+    const text$4 = {
+        [-5]: lineEnding,
+        [-4]: lineEnding,
+        [-3]: lineEnding,
+        [33]: labelStartImage,
+        [38]: characterReference,
+        [42]: attention,
+        [60]: [autolink, htmlText],
+        [91]: labelStartLink,
+        [92]: [hardBreakEscape, characterEscape],
+        [93]: labelEnd,
+        [95]: attention,
+        [96]: codeText
     };
-    reactIs_production_min.isStrictMode = function(a2) {
-        return y$5(a2) === e$2;
+    const insideSpan = {
+        null: [attention, resolver$1]
     };
-    reactIs_production_min.isSuspense = function(a2) {
-        return y$5(a2) === l$2;
+    const attentionMarkers = {
+        null: [42, 95]
     };
-    reactIs_production_min.isValidElementType = function(a2) {
-        return "string" === typeof a2 || "function" === typeof a2 || a2 === d$1 || a2 === f$2 || a2 === v$2 || a2 === e$2 || a2 === l$2 || a2 === m$2 || a2 === w$3 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === p$2 || a2.$$typeof === n$2 || a2.$$typeof === g$2 || a2.$$typeof === h$2 || a2.$$typeof === k$2 || a2.$$typeof === u$1 || a2.$$typeof === q$2 || a2[0] === r$2) ? true : false;
+    const disable = {
+        null: []
     };
-    reactIs_production_min.typeOf = y$5;
-    (function(module2) {
-        {
-            module2.exports = reactIs_production_min;
+    const defaultConstructs = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
+        __proto__: null,
+        document: document$1,
+        contentInitial,
+        flowInitial,
+        flow,
+        string: string$2,
+        text: text$4,
+        insideSpan,
+        attentionMarkers,
+        disable
+    }, Symbol.toStringTag, {
+        value: "Module"
+    }));
+
+    function parse$6(options) {
+        const settings2 = options || {};
+        const constructs2 = combineExtensions([defaultConstructs, ...settings2.extensions || []]);
+        const parser2 = {
+            defined: [],
+            lazy: {},
+            constructs: constructs2,
+            content: create2(content$2),
+            document: create2(document$2),
+            flow: create2(flow$1),
+            string: create2(string$3),
+            text: create2(text$5)
+        };
+        return parser2;
+
+        function create2(initial2) {
+            return creator2;
+
+            function creator2(from) {
+                return createTokenizer(parser2, initial2, from);
+            }
         }
-    })(reactIs);
-    let e$1 = (e3) => "object" == typeof e3 && null != e3 && 1 === e3.nodeType,
-        t$2 = (e3, t2) => (!t2 || "hidden" !== e3) && ("visible" !== e3 && "clip" !== e3),
-        n$1 = (e3, n2) => {
-            if (e3.clientHeight < e3.scrollHeight || e3.clientWidth < e3.scrollWidth) {
-                let l2 = getComputedStyle(e3, null);
-                return t$2(l2.overflowY, n2) || t$2(l2.overflowX, n2) || ((e4) => {
-                    let t2 = ((e6) => {
-                        if (!e6.ownerDocument || !e6.ownerDocument.defaultView)
-                            return null;
-                        try {
-                            return e6.ownerDocument.defaultView.frameElement;
-                        } catch (e7) {
-                            return null;
+    }
+
+    function postprocess(events2) {
+        while (!subtokenize(events2)) {}
+        return events2;
+    }
+    const search$1 = /[\0\t\n\r]/g;
+
+    function preprocess() {
+        let column = 1;
+        let buffer = "";
+        let start2 = true;
+        let atCarriageReturn;
+        return preprocessor2;
+
+        function preprocessor2(value, encoding, end2) {
+            const chunks = [];
+            let match2;
+            let next2;
+            let startPosition;
+            let endPosition;
+            let code2;
+            value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
+            startPosition = 0;
+            buffer = "";
+            if (start2) {
+                if (value.charCodeAt(0) === 65279) {
+                    startPosition++;
+                }
+                start2 = void 0;
+            }
+            while (startPosition < value.length) {
+                search$1.lastIndex = startPosition;
+                match2 = search$1.exec(value);
+                endPosition = match2 && match2.index !== void 0 ? match2.index : value.length;
+                code2 = value.charCodeAt(endPosition);
+                if (!match2) {
+                    buffer = value.slice(startPosition);
+                    break;
+                }
+                if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
+                    chunks.push(-3);
+                    atCarriageReturn = void 0;
+                } else {
+                    if (atCarriageReturn) {
+                        chunks.push(-5);
+                        atCarriageReturn = void 0;
+                    }
+                    if (startPosition < endPosition) {
+                        chunks.push(value.slice(startPosition, endPosition));
+                        column += endPosition - startPosition;
+                    }
+                    switch (code2) {
+                        case 0: {
+                            chunks.push(65533);
+                            column++;
+                            break;
                         }
-                    })(e4);
-                    return !!t2 && (t2.clientHeight < e4.scrollHeight || t2.clientWidth < e4.scrollWidth);
-                })(e3);
+                        case 9: {
+                            next2 = Math.ceil(column / 4) * 4;
+                            chunks.push(-2);
+                            while (column++ < next2)
+                                chunks.push(-1);
+                            break;
+                        }
+                        case 10: {
+                            chunks.push(-4);
+                            column = 1;
+                            break;
+                        }
+                        default: {
+                            atCarriageReturn = true;
+                            column = 1;
+                        }
+                    }
+                }
+                startPosition = endPosition + 1;
             }
-            return false;
-        },
-        l$1 = (e3, t2, n2, l2, i2, o2, r2, d2) => o2 < e3 && r2 > t2 || o2 > e3 && r2 < t2 ? 0 : o2 <= e3 && d2 <= n2 || r2 >= t2 && d2 >= n2 ? o2 - e3 - l2 : r2 > t2 && d2 < n2 || o2 < e3 && d2 > n2 ? r2 - t2 + i2 : 0,
-        i$4 = (e3) => {
-            let t2 = e3.parentElement;
-            return null == t2 ? e3.getRootNode().host || null : t2;
-        };
-    var o$3 = (t2, o2) => {
-        var r2, d2, h2, f2, u2, s2;
-        if ("undefined" == typeof document)
-            return [];
-        let {
-            scrollMode: a2,
-            block: c2,
-            inline: g2,
-            boundary: m2,
-            skipOverflowHiddenElements: p2
-        } = o2, w2 = "function" == typeof m2 ? m2 : (e3) => e3 !== m2;
-        if (!e$1(t2))
-            throw new TypeError("Invalid target");
-        let W2 = document.scrollingElement || document.documentElement,
-            H2 = [],
-            b2 = t2;
-        for (; e$1(b2) && w2(b2);) {
-            if (b2 = i$4(b2), b2 === W2) {
-                H2.push(b2);
-                break;
+            if (end2) {
+                if (atCarriageReturn)
+                    chunks.push(-5);
+                if (buffer)
+                    chunks.push(buffer);
+                chunks.push(null);
             }
-            null != b2 && b2 === document.body && n$1(b2) && !n$1(document.documentElement) || null != b2 && n$1(b2, p2) && H2.push(b2);
+            return chunks;
         }
-        let v2 = null != (d2 = null == (r2 = window.visualViewport) ? void 0 : r2.width) ? d2 : innerWidth,
-            y2 = null != (f2 = null == (h2 = window.visualViewport) ? void 0 : h2.height) ? f2 : innerHeight,
-            E2 = null != (u2 = window.scrollX) ? u2 : pageXOffset,
-            M2 = null != (s2 = window.scrollY) ? s2 : pageYOffset,
-            {
-                height: x2,
-                width: I2,
-                top: C2,
-                right: R2,
-                bottom: T2,
-                left: V2
-            } = t2.getBoundingClientRect(),
-            k2 = "start" === c2 || "nearest" === c2 ? C2 : "end" === c2 ? T2 : C2 + x2 / 2,
-            B2 = "center" === g2 ? V2 + I2 / 2 : "end" === g2 ? R2 : V2,
-            D2 = [];
-        for (let e3 = 0; e3 < H2.length; e3++) {
-            let t3 = H2[e3],
-                {
-                    height: n2,
-                    width: i2,
-                    top: o3,
-                    right: r3,
-                    bottom: d3,
-                    left: h3
-                } = t3.getBoundingClientRect();
-            if ("if-needed" === a2 && C2 >= 0 && V2 >= 0 && T2 <= y2 && R2 <= v2 && C2 >= o3 && T2 <= d3 && V2 >= h3 && R2 <= r3)
-                return D2;
-            let f3 = getComputedStyle(t3),
-                u3 = parseInt(f3.borderLeftWidth, 10),
-                s3 = parseInt(f3.borderTopWidth, 10),
-                m3 = parseInt(f3.borderRightWidth, 10),
-                p3 = parseInt(f3.borderBottomWidth, 10),
-                w3 = 0,
-                b3 = 0,
-                O2 = "offsetWidth" in t3 ? t3.offsetWidth - t3.clientWidth - u3 - m3 : 0,
-                X2 = "offsetHeight" in t3 ? t3.offsetHeight - t3.clientHeight - s3 - p3 : 0,
-                Y2 = "offsetWidth" in t3 ? 0 === t3.offsetWidth ? 0 : i2 / t3.offsetWidth : 0,
-                L2 = "offsetHeight" in t3 ? 0 === t3.offsetHeight ? 0 : n2 / t3.offsetHeight : 0;
-            if (W2 === t3)
-                w3 = "start" === c2 ? k2 : "end" === c2 ? k2 - y2 : "nearest" === c2 ? l$1(M2, M2 + y2, y2, s3, p3, M2 + k2, M2 + k2 + x2, x2) : k2 - y2 / 2, b3 = "start" === g2 ? B2 : "center" === g2 ? B2 - v2 / 2 : "end" === g2 ? B2 - v2 : l$1(E2, E2 + v2, v2, u3, m3, E2 + B2, E2 + B2 + I2, I2), w3 = Math.max(0, w3 + M2), b3 = Math.max(0, b3 + E2);
-            else {
-                w3 = "start" === c2 ? k2 - o3 - s3 : "end" === c2 ? k2 - d3 + p3 + X2 : "nearest" === c2 ? l$1(o3, d3, n2, s3, p3 + X2, k2, k2 + x2, x2) : k2 - (o3 + n2 / 2) + X2 / 2, b3 = "start" === g2 ? B2 - h3 - u3 : "center" === g2 ? B2 - (h3 + i2 / 2) + O2 / 2 : "end" === g2 ? B2 - r3 + m3 + O2 : l$1(h3, r3, i2, u3, m3 + O2, B2, B2 + I2, I2);
-                let {
-                    scrollLeft: e4,
-                    scrollTop: f4
-                } = t3;
-                w3 = Math.max(0, Math.min(f4 + w3 / L2, t3.scrollHeight - n2 / L2 + X2)), b3 = Math.max(0, Math.min(e4 + b3 / Y2, t3.scrollWidth - i2 / Y2 + O2)), k2 += f4 - w3, B2 += e4 - b3;
-            }
-            D2.push({
-                el: t3,
-                top: w3,
-                left: b3
-            });
+    }
+    const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
+
+    function decodeString(value) {
+        return value.replace(characterEscapeOrReference, decode$1);
+    }
+
+    function decode$1($0, $1, $2) {
+        if ($1) {
+            return $1;
         }
-        return D2;
-    };
-    var extendStatics = function(d2, b2) {
-        extendStatics = Object.setPrototypeOf || {
-            __proto__: []
+        const head = $2.charCodeAt(0);
+        if (head === 35) {
+            const head2 = $2.charCodeAt(1);
+            const hex2 = head2 === 120 || head2 === 88;
+            return decodeNumericCharacterReference($2.slice(hex2 ? 2 : 1), hex2 ? 16 : 10);
         }
-        instanceof Array && function(d3, b3) {
-            d3.__proto__ = b3;
-        } || function(d3, b3) {
-            for (var p2 in b3)
-                if (Object.prototype.hasOwnProperty.call(b3, p2))
-                    d3[p2] = b3[p2];
-        };
-        return extendStatics(d2, b2);
-    };
-
-    function __extends(d2, b2) {
-        if (typeof b2 !== "function" && b2 !== null)
-            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
-        extendStatics(d2, b2);
+        return decodeNamedCharacterReference($2) || $0;
+    }
+    const own$6 = {}.hasOwnProperty;
 
-        function __() {
-            this.constructor = d2;
+    function fromMarkdown(value, encoding, options) {
+        if (typeof encoding !== "string") {
+            options = encoding;
+            encoding = void 0;
         }
-        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
+        return compiler(options)(
+            postprocess(
+                parse$6(options).document().write(preprocess()(value, encoding, true))
+            )
+        );
     }
-    var __assign = function() {
-        __assign = Object.assign || function __assign2(t2) {
-            for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
-                s2 = arguments[i2];
-                for (var p2 in s2)
-                    if (Object.prototype.hasOwnProperty.call(s2, p2))
-                        t2[p2] = s2[p2];
+
+    function compiler(options) {
+        const config2 = {
+            transforms: [],
+            canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
+            enter: {
+                autolink: opener(link2),
+                autolinkProtocol: onenterdata,
+                autolinkEmail: onenterdata,
+                atxHeading: opener(heading2),
+                blockQuote: opener(blockQuote2),
+                characterEscape: onenterdata,
+                characterReference: onenterdata,
+                codeFenced: opener(codeFlow),
+                codeFencedFenceInfo: buffer,
+                codeFencedFenceMeta: buffer,
+                codeIndented: opener(codeFlow, buffer),
+                codeText: opener(codeText2, buffer),
+                codeTextData: onenterdata,
+                data: onenterdata,
+                codeFlowValue: onenterdata,
+                definition: opener(definition2),
+                definitionDestinationString: buffer,
+                definitionLabelString: buffer,
+                definitionTitleString: buffer,
+                emphasis: opener(emphasis2),
+                hardBreakEscape: opener(hardBreak2),
+                hardBreakTrailing: opener(hardBreak2),
+                htmlFlow: opener(html2, buffer),
+                htmlFlowData: onenterdata,
+                htmlText: opener(html2, buffer),
+                htmlTextData: onenterdata,
+                image: opener(image2),
+                label: buffer,
+                link: opener(link2),
+                listItem: opener(listItem2),
+                listItemValue: onenterlistitemvalue,
+                listOrdered: opener(list2, onenterlistordered),
+                listUnordered: opener(list2),
+                paragraph: opener(paragraph2),
+                reference: onenterreference,
+                referenceString: buffer,
+                resourceDestinationString: buffer,
+                resourceTitleString: buffer,
+                setextHeading: opener(heading2),
+                strong: opener(strong2),
+                thematicBreak: opener(thematicBreak2)
+            },
+            exit: {
+                atxHeading: closer(),
+                atxHeadingSequence: onexitatxheadingsequence,
+                autolink: closer(),
+                autolinkEmail: onexitautolinkemail,
+                autolinkProtocol: onexitautolinkprotocol,
+                blockQuote: closer(),
+                characterEscapeValue: onexitdata,
+                characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
+                characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
+                characterReferenceValue: onexitcharacterreferencevalue,
+                codeFenced: closer(onexitcodefenced),
+                codeFencedFence: onexitcodefencedfence,
+                codeFencedFenceInfo: onexitcodefencedfenceinfo,
+                codeFencedFenceMeta: onexitcodefencedfencemeta,
+                codeFlowValue: onexitdata,
+                codeIndented: closer(onexitcodeindented),
+                codeText: closer(onexitcodetext),
+                codeTextData: onexitdata,
+                data: onexitdata,
+                definition: closer(),
+                definitionDestinationString: onexitdefinitiondestinationstring,
+                definitionLabelString: onexitdefinitionlabelstring,
+                definitionTitleString: onexitdefinitiontitlestring,
+                emphasis: closer(),
+                hardBreakEscape: closer(onexithardbreak),
+                hardBreakTrailing: closer(onexithardbreak),
+                htmlFlow: closer(onexithtmlflow),
+                htmlFlowData: onexitdata,
+                htmlText: closer(onexithtmltext),
+                htmlTextData: onexitdata,
+                image: closer(onexitimage),
+                label: onexitlabel,
+                labelText: onexitlabeltext,
+                lineEnding: onexitlineending,
+                link: closer(onexitlink),
+                listItem: closer(),
+                listOrdered: closer(),
+                listUnordered: closer(),
+                paragraph: closer(),
+                referenceString: onexitreferencestring,
+                resourceDestinationString: onexitresourcedestinationstring,
+                resourceTitleString: onexitresourcetitlestring,
+                resource: onexitresource,
+                setextHeading: closer(onexitsetextheading),
+                setextHeadingLineSequence: onexitsetextheadinglinesequence,
+                setextHeadingText: onexitsetextheadingtext,
+                strong: closer(),
+                thematicBreak: closer()
             }
-            return t2;
         };
-        return __assign.apply(this, arguments);
-    };
+        configure(config2, (options || {}).mdastExtensions || []);
+        const data2 = {};
+        return compile;
 
-    function __awaiter$2(thisArg, _arguments, P2, generator) {
-        function adopt(value) {
-            return value instanceof P2 ? value : new P2(function(resolve2) {
-                resolve2(value);
-            });
-        }
-        return new(P2 || (P2 = Promise))(function(resolve2, reject) {
-            function fulfilled(value) {
-                try {
-                    step2(generator.next(value));
-                } catch (e3) {
-                    reject(e3);
+        function compile(events2) {
+            let tree = {
+                type: "root",
+                children: []
+            };
+            const context2 = {
+                stack: [tree],
+                tokenStack: [],
+                config: config2,
+                enter,
+                exit: exit2,
+                buffer,
+                resume,
+                data: data2
+            };
+            const listStack = [];
+            let index2 = -1;
+            while (++index2 < events2.length) {
+                if (events2[index2][1].type === "listOrdered" || events2[index2][1].type === "listUnordered") {
+                    if (events2[index2][0] === "enter") {
+                        listStack.push(index2);
+                    } else {
+                        const tail = listStack.pop();
+                        index2 = prepareList(events2, tail, index2);
+                    }
                 }
             }
-
-            function rejected(value) {
-                try {
-                    step2(generator["throw"](value));
-                } catch (e3) {
-                    reject(e3);
+            index2 = -1;
+            while (++index2 < events2.length) {
+                const handler = config2[events2[index2][0]];
+                if (own$6.call(handler, events2[index2][1].type)) {
+                    handler[events2[index2][1].type].call(
+                        Object.assign({
+                                sliceSerialize: events2[index2][2].sliceSerialize
+                            },
+                            context2
+                        ),
+                        events2[index2][1]
+                    );
                 }
             }
-
-            function step2(result) {
-                result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
+            if (context2.tokenStack.length > 0) {
+                const tail = context2.tokenStack[context2.tokenStack.length - 1];
+                const handler = tail[1] || defaultOnError;
+                handler.call(context2, void 0, tail[0]);
             }
-            step2((generator = generator.apply(thisArg, _arguments || [])).next());
-        });
-    }
-
-    function __generator(thisArg, body) {
-        var _2 = {
-                label: 0,
-                sent: function() {
-                    if (t2[0] & 1)
-                        throw t2[1];
-                    return t2[1];
-                },
-                trys: [],
-                ops: []
-            },
-            f2, y2, t2, g2;
-        return g2 = {
-            next: verb(0),
-            "throw": verb(1),
-            "return": verb(2)
-        }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
-            return this;
-        }), g2;
-
-        function verb(n2) {
-            return function(v2) {
-                return step2([n2, v2]);
+            tree.position = {
+                start: point$2(
+                    events2.length > 0 ? events2[0][1].start : {
+                        line: 1,
+                        column: 1,
+                        offset: 0
+                    }
+                ),
+                end: point$2(
+                    events2.length > 0 ? events2[events2.length - 2][1].end : {
+                        line: 1,
+                        column: 1,
+                        offset: 0
+                    }
+                )
             };
+            index2 = -1;
+            while (++index2 < config2.transforms.length) {
+                tree = config2.transforms[index2](tree) || tree;
+            }
+            return tree;
         }
 
-        function step2(op) {
-            if (f2)
-                throw new TypeError("Generator is already executing.");
-            while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
-                try {
-                    if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
-                        return t2;
-                    if (y2 = 0, t2)
-                        op = [op[0] & 2, t2.value];
-                    switch (op[0]) {
-                        case 0:
-                        case 1:
-                            t2 = op;
-                            break;
-                        case 4:
-                            _2.label++;
-                            return {
-                                value: op[1], done: false
-                            };
-                        case 5:
-                            _2.label++;
-                            y2 = op[1];
-                            op = [0];
-                            continue;
-                        case 7:
-                            op = _2.ops.pop();
-                            _2.trys.pop();
-                            continue;
-                        default:
-                            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
-                                _2 = 0;
-                                continue;
-                            }
-                            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
-                                _2.label = op[1];
-                                break;
-                            }
-                            if (op[0] === 6 && _2.label < t2[1]) {
-                                _2.label = t2[1];
-                                t2 = op;
-                                break;
+        function prepareList(events2, start2, length) {
+            let index2 = start2 - 1;
+            let containerBalance = -1;
+            let listSpread = false;
+            let listItem3;
+            let lineIndex;
+            let firstBlankLineIndex;
+            let atMarker;
+            while (++index2 <= length) {
+                const event2 = events2[index2];
+                switch (event2[1].type) {
+                    case "listUnordered":
+                    case "listOrdered":
+                    case "blockQuote": {
+                        if (event2[0] === "enter") {
+                            containerBalance++;
+                        } else {
+                            containerBalance--;
+                        }
+                        atMarker = void 0;
+                        break;
+                    }
+                    case "lineEndingBlank": {
+                        if (event2[0] === "enter") {
+                            if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
+                                firstBlankLineIndex = index2;
                             }
-                            if (t2 && _2.label < t2[2]) {
-                                _2.label = t2[2];
-                                _2.ops.push(op);
+                            atMarker = void 0;
+                        }
+                        break;
+                    }
+                    case "linePrefix":
+                    case "listItemValue":
+                    case "listItemMarker":
+                    case "listItemPrefix":
+                    case "listItemPrefixWhitespace": {
+                        break;
+                    }
+                    default: {
+                        atMarker = void 0;
+                    }
+                }
+                if (!containerBalance && event2[0] === "enter" && event2[1].type === "listItemPrefix" || containerBalance === -1 && event2[0] === "exit" && (event2[1].type === "listUnordered" || event2[1].type === "listOrdered")) {
+                    if (listItem3) {
+                        let tailIndex = index2;
+                        lineIndex = void 0;
+                        while (tailIndex--) {
+                            const tailEvent = events2[tailIndex];
+                            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
+                                if (tailEvent[0] === "exit")
+                                    continue;
+                                if (lineIndex) {
+                                    events2[lineIndex][1].type = "lineEndingBlank";
+                                    listSpread = true;
+                                }
+                                tailEvent[1].type = "lineEnding";
+                                lineIndex = tailIndex;
+                            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent")
+                            ;
+                            else {
                                 break;
                             }
-                            if (t2[2])
-                                _2.ops.pop();
-                            _2.trys.pop();
-                            continue;
+                        }
+                        if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
+                            listItem3._spread = true;
+                        }
+                        listItem3.end = Object.assign({},
+                            lineIndex ? events2[lineIndex][1].start : event2[1].end
+                        );
+                        events2.splice(lineIndex || index2, 0, ["exit", listItem3, event2[2]]);
+                        index2++;
+                        length++;
+                    }
+                    if (event2[1].type === "listItemPrefix") {
+                        const item = {
+                            type: "listItem",
+                            _spread: false,
+                            start: Object.assign({}, event2[1].start),
+                            end: void 0
+                        };
+                        listItem3 = item;
+                        events2.splice(index2, 0, ["enter", item, event2[2]]);
+                        index2++;
+                        length++;
+                        firstBlankLineIndex = void 0;
+                        atMarker = true;
                     }
-                    op = body.call(thisArg, _2);
-                } catch (e3) {
-                    op = [6, e3];
-                    y2 = 0;
-                } finally {
-                    f2 = t2 = 0;
                 }
-            if (op[0] & 5)
-                throw op[1];
-            return {
-                value: op[0] ? op[1] : void 0,
-                done: true
-            };
+            }
+            events2[start2][1]._spread = listSpread;
+            return length;
         }
-    }
 
-    function __values(o2) {
-        var s2 = typeof Symbol === "function" && Symbol.iterator,
-            m2 = s2 && o2[s2],
-            i2 = 0;
-        if (m2)
-            return m2.call(o2);
-        if (o2 && typeof o2.length === "number")
-            return {
-                next: function() {
-                    if (o2 && i2 >= o2.length)
-                        o2 = void 0;
-                    return {
-                        value: o2 && o2[i2++],
-                        done: !o2
-                    };
-                }
-            };
-        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
-    }
+        function opener(create2, and) {
+            return open;
 
-    function __read(o2, n2) {
-        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
-        if (!m2)
-            return o2;
-        var i2 = m2.call(o2),
-            r2, ar = [],
-            e3;
-        try {
-            while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
-                ar.push(r2.value);
-        } catch (error2) {
-            e3 = {
-                error: error2
-            };
-        } finally {
-            try {
-                if (r2 && !r2.done && (m2 = i2["return"]))
-                    m2.call(i2);
-            } finally {
-                if (e3)
-                    throw e3.error;
+            function open(token) {
+                enter.call(this, create2(token), token);
+                if (and)
+                    and.call(this, token);
             }
         }
-        return ar;
-    }
 
-    function __spread() {
-        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
-            ar = ar.concat(__read(arguments[i2]));
-        return ar;
-    }
+        function buffer() {
+            this.stack.push({
+                type: "fragment",
+                children: []
+            });
+        }
 
-    function __spreadArray(to2, from, pack) {
-        if (pack || arguments.length === 2)
-            for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
-                if (ar || !(i2 in from)) {
-                    if (!ar)
-                        ar = Array.prototype.slice.call(from, 0, i2);
-                    ar[i2] = from[i2];
+        function enter(node2, token, errorHandler) {
+            const parent = this.stack[this.stack.length - 1];
+            const siblings = parent.children;
+            siblings.push(node2);
+            this.stack.push(node2);
+            this.tokenStack.push([token, errorHandler]);
+            node2.position = {
+                start: point$2(token.start),
+                end: void 0
+            };
+        }
+
+        function closer(and) {
+            return close;
+
+            function close(token) {
+                if (and)
+                    and.call(this, token);
+                exit2.call(this, token);
+            }
+        }
+
+        function exit2(token, onExitError) {
+            const node2 = this.stack.pop();
+            const open = this.tokenStack.pop();
+            if (!open) {
+                throw new Error(
+                    "Cannot close `" + token.type + "` (" + stringifyPosition({
+                        start: token.start,
+                        end: token.end
+                    }) + "): it\u2019s not open"
+                );
+            } else if (open[0].type !== token.type) {
+                if (onExitError) {
+                    onExitError.call(this, token, open[0]);
+                } else {
+                    const handler = open[1] || defaultOnError;
+                    handler.call(this, token, open[0]);
                 }
             }
-        return to2.concat(ar || Array.prototype.slice.call(from));
-    }
-    typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
-        var e3 = new Error(message);
-        return e3.name = "SuppressedError", e3.error = error2, e3.suppressed = suppressed, e3;
-    };
-    var idCounter = 0;
+            node2.position.end = point$2(token.end);
+        }
 
-    function noop$6() {}
+        function resume() {
+            return toString$6(this.stack.pop());
+        }
 
-    function scrollIntoView$1(node2, menuNode) {
-        if (!node2) {
-            return;
+        function onenterlistordered() {
+            this.data.expectingFirstListItemValue = true;
         }
-        var actions = o$3(node2, {
-            boundary: menuNode,
-            block: "nearest",
-            scrollMode: "if-needed"
-        });
-        actions.forEach(function(_ref2) {
-            var el = _ref2.el,
-                top2 = _ref2.top,
-                left2 = _ref2.left;
-            el.scrollTop = top2;
-            el.scrollLeft = left2;
-        });
-    }
 
-    function isOrContainsNode(parent, child, environment) {
-        var result = parent === child || child instanceof environment.Node && parent.contains && parent.contains(child);
-        return result;
-    }
+        function onenterlistitemvalue(token) {
+            if (this.data.expectingFirstListItemValue) {
+                const ancestor = this.stack[this.stack.length - 2];
+                ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
+                this.data.expectingFirstListItemValue = void 0;
+            }
+        }
 
-    function debounce$2(fn2, time) {
-        var timeoutId;
+        function onexitcodefencedfenceinfo() {
+            const data3 = this.resume();
+            const node2 = this.stack[this.stack.length - 1];
+            node2.lang = data3;
+        }
 
-        function cancel() {
-            if (timeoutId) {
-                clearTimeout(timeoutId);
+        function onexitcodefencedfencemeta() {
+            const data3 = this.resume();
+            const node2 = this.stack[this.stack.length - 1];
+            node2.meta = data3;
+        }
+
+        function onexitcodefencedfence() {
+            if (this.data.flowCodeInside)
+                return;
+            this.buffer();
+            this.data.flowCodeInside = true;
+        }
+
+        function onexitcodefenced() {
+            const data3 = this.resume();
+            const node2 = this.stack[this.stack.length - 1];
+            node2.value = data3.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
+            this.data.flowCodeInside = void 0;
+        }
+
+        function onexitcodeindented() {
+            const data3 = this.resume();
+            const node2 = this.stack[this.stack.length - 1];
+            node2.value = data3.replace(/(\r?\n|\r)$/g, "");
+        }
+
+        function onexitdefinitionlabelstring(token) {
+            const label = this.resume();
+            const node2 = this.stack[this.stack.length - 1];
+            node2.label = label;
+            node2.identifier = normalizeIdentifier(
+                this.sliceSerialize(token)
+            ).toLowerCase();
+        }
+
+        function onexitdefinitiontitlestring() {
+            const data3 = this.resume();
+            const node2 = this.stack[this.stack.length - 1];
+            node2.title = data3;
+        }
+
+        function onexitdefinitiondestinationstring() {
+            const data3 = this.resume();
+            const node2 = this.stack[this.stack.length - 1];
+            node2.url = data3;
+        }
+
+        function onexitatxheadingsequence(token) {
+            const node2 = this.stack[this.stack.length - 1];
+            if (!node2.depth) {
+                const depth = this.sliceSerialize(token).length;
+                node2.depth = depth;
             }
         }
 
-        function wrapper() {
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+        function onexitsetextheadingtext() {
+            this.data.setextHeadingSlurpLineEnding = true;
+        }
+
+        function onexitsetextheadinglinesequence(token) {
+            const node2 = this.stack[this.stack.length - 1];
+            node2.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;
+        }
+
+        function onexitsetextheading() {
+            this.data.setextHeadingSlurpLineEnding = void 0;
+        }
+
+        function onenterdata(token) {
+            const node2 = this.stack[this.stack.length - 1];
+            const siblings = node2.children;
+            let tail = siblings[siblings.length - 1];
+            if (!tail || tail.type !== "text") {
+                tail = text2();
+                tail.position = {
+                    start: point$2(token.start),
+                    end: void 0
+                };
+                siblings.push(tail);
             }
-            cancel();
-            timeoutId = setTimeout(function() {
-                timeoutId = null;
-                fn2.apply(void 0, args);
-            }, time);
+            this.stack.push(tail);
         }
-        wrapper.cancel = cancel;
-        return wrapper;
-    }
 
-    function callAllEventHandlers() {
-        for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
-            fns[_key2] = arguments[_key2];
+        function onexitdata(token) {
+            const tail = this.stack.pop();
+            tail.value += this.sliceSerialize(token);
+            tail.position.end = point$2(token.end);
         }
-        return function(event2) {
-            for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
-                args[_key3 - 1] = arguments[_key3];
+
+        function onexitlineending(token) {
+            const context2 = this.stack[this.stack.length - 1];
+            if (this.data.atHardBreak) {
+                const tail = context2.children[context2.children.length - 1];
+                tail.position.end = point$2(token.end);
+                this.data.atHardBreak = void 0;
+                return;
             }
-            return fns.some(function(fn2) {
-                if (fn2) {
-                    fn2.apply(void 0, [event2].concat(args));
-                }
-                return event2.preventDownshiftDefault || event2.hasOwnProperty("nativeEvent") && event2.nativeEvent.preventDownshiftDefault;
-            });
-        };
-    }
+            if (!this.data.setextHeadingSlurpLineEnding && config2.canContainEols.includes(context2.type)) {
+                onenterdata.call(this, token);
+                onexitdata.call(this, token);
+            }
+        }
 
-    function handleRefs() {
-        for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
-            refs[_key4] = arguments[_key4];
+        function onexithardbreak() {
+            this.data.atHardBreak = true;
         }
-        return function(node2) {
-            refs.forEach(function(ref2) {
-                if (typeof ref2 === "function") {
-                    ref2(node2);
-                } else if (ref2) {
-                    ref2.current = node2;
-                }
-            });
-        };
-    }
 
-    function generateId() {
-        return String(idCounter++);
-    }
+        function onexithtmlflow() {
+            const data3 = this.resume();
+            const node2 = this.stack[this.stack.length - 1];
+            node2.value = data3;
+        }
 
-    function getA11yStatusMessage$1(_ref2) {
-        var isOpen = _ref2.isOpen,
-            resultCount = _ref2.resultCount,
-            previousResultCount = _ref2.previousResultCount;
-        if (!isOpen) {
-            return "";
+        function onexithtmltext() {
+            const data3 = this.resume();
+            const node2 = this.stack[this.stack.length - 1];
+            node2.value = data3;
         }
-        if (!resultCount) {
-            return "No results are available.";
+
+        function onexitcodetext() {
+            const data3 = this.resume();
+            const node2 = this.stack[this.stack.length - 1];
+            node2.value = data3;
         }
-        if (resultCount !== previousResultCount) {
-            return resultCount + " result" + (resultCount === 1 ? " is" : "s are") + " available, use up and down arrow keys to navigate. Press Enter key to select.";
+
+        function onexitlink() {
+            const node2 = this.stack[this.stack.length - 1];
+            if (this.data.inReference) {
+                const referenceType = this.data.referenceType || "shortcut";
+                node2.type += "Reference";
+                node2.referenceType = referenceType;
+                delete node2.url;
+                delete node2.title;
+            } else {
+                delete node2.identifier;
+                delete node2.label;
+            }
+            this.data.referenceType = void 0;
         }
-        return "";
-    }
 
-    function getState(state, props) {
-        return Object.keys(state).reduce(function(prevState, key) {
-            prevState[key] = isControlledProp(props, key) ? props[key] : state[key];
-            return prevState;
-        }, {});
-    }
+        function onexitimage() {
+            const node2 = this.stack[this.stack.length - 1];
+            if (this.data.inReference) {
+                const referenceType = this.data.referenceType || "shortcut";
+                node2.type += "Reference";
+                node2.referenceType = referenceType;
+                delete node2.url;
+                delete node2.title;
+            } else {
+                delete node2.identifier;
+                delete node2.label;
+            }
+            this.data.referenceType = void 0;
+        }
 
-    function isControlledProp(props, key) {
-        return props[key] !== void 0;
-    }
+        function onexitlabeltext(token) {
+            const string2 = this.sliceSerialize(token);
+            const ancestor = this.stack[this.stack.length - 2];
+            ancestor.label = decodeString(string2);
+            ancestor.identifier = normalizeIdentifier(string2).toLowerCase();
+        }
 
-    function normalizeArrowKey(event2) {
-        var key = event2.key,
-            keyCode = event2.keyCode;
-        if (keyCode >= 37 && keyCode <= 40 && key.indexOf("Arrow") !== 0) {
-            return "Arrow" + key;
+        function onexitlabel() {
+            const fragment2 = this.stack[this.stack.length - 1];
+            const value = this.resume();
+            const node2 = this.stack[this.stack.length - 1];
+            this.data.inReference = true;
+            if (node2.type === "link") {
+                const children2 = fragment2.children;
+                node2.children = children2;
+            } else {
+                node2.alt = value;
+            }
         }
-        return key;
-    }
 
-    function getNextWrappingIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular2) {
-        if (circular2 === void 0) {
-            circular2 = true;
+        function onexitresourcedestinationstring() {
+            const data3 = this.resume();
+            const node2 = this.stack[this.stack.length - 1];
+            node2.url = data3;
         }
-        if (itemCount === 0) {
-            return -1;
+
+        function onexitresourcetitlestring() {
+            const data3 = this.resume();
+            const node2 = this.stack[this.stack.length - 1];
+            node2.title = data3;
         }
-        var itemsLastIndex = itemCount - 1;
-        if (typeof baseIndex !== "number" || baseIndex < 0 || baseIndex >= itemCount) {
-            baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;
+
+        function onexitresource() {
+            this.data.inReference = void 0;
         }
-        var newIndex = baseIndex + moveAmount;
-        if (newIndex < 0) {
-            newIndex = circular2 ? itemsLastIndex : 0;
-        } else if (newIndex > itemsLastIndex) {
-            newIndex = circular2 ? 0 : itemsLastIndex;
+
+        function onenterreference() {
+            this.data.referenceType = "collapsed";
         }
-        var nonDisabledNewIndex = getNextNonDisabledIndex(moveAmount, newIndex, itemCount, getItemNodeFromIndex, circular2);
-        if (nonDisabledNewIndex === -1) {
-            return baseIndex >= itemCount ? -1 : baseIndex;
+
+        function onexitreferencestring(token) {
+            const label = this.resume();
+            const node2 = this.stack[this.stack.length - 1];
+            node2.label = label;
+            node2.identifier = normalizeIdentifier(
+                this.sliceSerialize(token)
+            ).toLowerCase();
+            this.data.referenceType = "full";
         }
-        return nonDisabledNewIndex;
-    }
 
-    function getNextNonDisabledIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular2) {
-        var currentElementNode = getItemNodeFromIndex(baseIndex);
-        if (!currentElementNode || !currentElementNode.hasAttribute("disabled")) {
-            return baseIndex;
+        function onexitcharacterreferencemarker(token) {
+            this.data.characterReferenceType = token.type;
         }
-        if (moveAmount > 0) {
-            for (var index2 = baseIndex + 1; index2 < itemCount; index2++) {
-                if (!getItemNodeFromIndex(index2).hasAttribute("disabled")) {
-                    return index2;
-                }
-            }
-        } else {
-            for (var _index = baseIndex - 1; _index >= 0; _index--) {
-                if (!getItemNodeFromIndex(_index).hasAttribute("disabled")) {
-                    return _index;
-                }
+
+        function onexitcharacterreferencevalue(token) {
+            const data3 = this.sliceSerialize(token);
+            const type2 = this.data.characterReferenceType;
+            let value;
+            if (type2) {
+                value = decodeNumericCharacterReference(
+                    data3,
+                    type2 === "characterReferenceMarkerNumeric" ? 10 : 16
+                );
+                this.data.characterReferenceType = void 0;
+            } else {
+                const result = decodeNamedCharacterReference(data3);
+                value = result;
             }
+            const tail = this.stack.pop();
+            tail.value += value;
+            tail.position.end = point$2(token.end);
         }
-        if (circular2) {
-            return moveAmount > 0 ? getNextNonDisabledIndex(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex(-1, itemCount - 1, itemCount, getItemNodeFromIndex, false);
+
+        function onexitautolinkprotocol(token) {
+            onexitdata.call(this, token);
+            const node2 = this.stack[this.stack.length - 1];
+            node2.url = this.sliceSerialize(token);
         }
-        return -1;
-    }
 
-    function targetWithinDownshift(target, downshiftElements, environment, checkActiveElement) {
-        if (checkActiveElement === void 0) {
-            checkActiveElement = true;
+        function onexitautolinkemail(token) {
+            onexitdata.call(this, token);
+            const node2 = this.stack[this.stack.length - 1];
+            node2.url = "mailto:" + this.sliceSerialize(token);
         }
-        return downshiftElements.some(function(contextNode) {
-            return contextNode && (isOrContainsNode(contextNode, target, environment) || checkActiveElement && isOrContainsNode(contextNode, environment.document.activeElement, environment));
-        });
-    }
-    var cleanupStatus = debounce$2(function(documentProp) {
-        getStatusDiv(documentProp).textContent = "";
-    }, 500);
 
-    function setStatus(status2, documentProp) {
-        var div2 = getStatusDiv(documentProp);
-        if (!status2) {
-            return;
+        function blockQuote2() {
+            return {
+                type: "blockquote",
+                children: []
+            };
         }
-        div2.textContent = status2;
-        cleanupStatus(documentProp);
-    }
 
-    function getStatusDiv(documentProp) {
-        if (documentProp === void 0) {
-            documentProp = document;
+        function codeFlow() {
+            return {
+                type: "code",
+                lang: null,
+                meta: null,
+                value: ""
+            };
         }
-        var statusDiv = documentProp.getElementById("a11y-status-message");
-        if (statusDiv) {
-            return statusDiv;
+
+        function codeText2() {
+            return {
+                type: "inlineCode",
+                value: ""
+            };
         }
-        statusDiv = documentProp.createElement("div");
-        statusDiv.setAttribute("id", "a11y-status-message");
-        statusDiv.setAttribute("role", "status");
-        statusDiv.setAttribute("aria-live", "polite");
-        statusDiv.setAttribute("aria-relevant", "additions text");
-        Object.assign(statusDiv.style, {
-            border: "0",
-            clip: "rect(0 0 0 0)",
-            height: "1px",
-            margin: "-1px",
-            overflow: "hidden",
-            padding: "0",
-            position: "absolute",
-            width: "1px"
-        });
-        documentProp.body.appendChild(statusDiv);
-        return statusDiv;
-    }
-    var _excluded$3 = ["isInitialMount", "highlightedIndex", "items", "environment"];
-    var dropdownDefaultStateValues = {
-        highlightedIndex: -1,
-        isOpen: false,
-        selectedItem: null,
-        inputValue: ""
-    };
 
-    function callOnChangeProps(action, state, newState) {
-        var props = action.props,
-            type2 = action.type;
-        var changes = {};
-        Object.keys(state).forEach(function(key) {
-            invokeOnChangeHandler(key, action, state, newState);
-            if (newState[key] !== state[key]) {
-                changes[key] = newState[key];
-            }
-        });
-        if (props.onStateChange && Object.keys(changes).length) {
-            props.onStateChange(_extends$3({
-                type: type2
-            }, changes));
+        function definition2() {
+            return {
+                type: "definition",
+                identifier: "",
+                label: null,
+                title: null,
+                url: ""
+            };
         }
-    }
 
-    function invokeOnChangeHandler(key, action, state, newState) {
-        var props = action.props,
-            type2 = action.type;
-        var handler = "on" + capitalizeString(key) + "Change";
-        if (props[handler] && newState[key] !== void 0 && newState[key] !== state[key]) {
-            props[handler](_extends$3({
-                type: type2
-            }, newState));
+        function emphasis2() {
+            return {
+                type: "emphasis",
+                children: []
+            };
         }
-    }
 
-    function stateReducer(s2, a2) {
-        return a2.changes;
+        function heading2() {
+            return {
+                type: "heading",
+                depth: 0,
+                children: []
+            };
+        }
+
+        function hardBreak2() {
+            return {
+                type: "break"
+            };
+        }
+
+        function html2() {
+            return {
+                type: "html",
+                value: ""
+            };
+        }
+
+        function image2() {
+            return {
+                type: "image",
+                title: null,
+                url: "",
+                alt: null
+            };
+        }
+
+        function link2() {
+            return {
+                type: "link",
+                title: null,
+                url: "",
+                children: []
+            };
+        }
+
+        function list2(token) {
+            return {
+                type: "list",
+                ordered: token.type === "listOrdered",
+                start: null,
+                spread: token._spread,
+                children: []
+            };
+        }
+
+        function listItem2(token) {
+            return {
+                type: "listItem",
+                spread: token._spread,
+                checked: null,
+                children: []
+            };
+        }
+
+        function paragraph2() {
+            return {
+                type: "paragraph",
+                children: []
+            };
+        }
+
+        function strong2() {
+            return {
+                type: "strong",
+                children: []
+            };
+        }
+
+        function text2() {
+            return {
+                type: "text",
+                value: ""
+            };
+        }
+
+        function thematicBreak2() {
+            return {
+                type: "thematicBreak"
+            };
+        }
     }
 
-    function getA11ySelectionMessage(selectionParameters) {
-        var selectedItem = selectionParameters.selectedItem,
-            itemToStringLocal = selectionParameters.itemToString;
-        return selectedItem ? itemToStringLocal(selectedItem) + " has been selected." : "";
+    function point$2(d2) {
+        return {
+            line: d2.line,
+            column: d2.column,
+            offset: d2.offset
+        };
     }
-    var updateA11yStatus = debounce$2(function(getA11yMessage, document2) {
-        setStatus(getA11yMessage(), document2);
-    }, 200);
-    var useIsomorphicLayoutEffect$3 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? React.useLayoutEffect : React.useEffect;
 
-    function useElementIds(_ref2) {
-        var _ref$id = _ref2.id,
-            id2 = _ref$id === void 0 ? "downshift-" + generateId() : _ref$id,
-            labelId = _ref2.labelId,
-            menuId = _ref2.menuId,
-            getItemId = _ref2.getItemId,
-            toggleButtonId = _ref2.toggleButtonId,
-            inputId = _ref2.inputId;
-        var elementIdsRef = React.useRef({
-            labelId: labelId || id2 + "-label",
-            menuId: menuId || id2 + "-menu",
-            getItemId: getItemId || function(index2) {
-                return id2 + "-item-" + index2;
-            },
-            toggleButtonId: toggleButtonId || id2 + "-toggle-button",
-            inputId: inputId || id2 + "-input"
-        });
-        return elementIdsRef.current;
+    function configure(combined, extensions2) {
+        let index2 = -1;
+        while (++index2 < extensions2.length) {
+            const value = extensions2[index2];
+            if (Array.isArray(value)) {
+                configure(combined, value);
+            } else {
+                extension$1(combined, value);
+            }
+        }
     }
 
-    function getItemAndIndex(itemProp, indexProp, items, errorMessage) {
-        var item, index2;
-        if (itemProp === void 0) {
-            if (indexProp === void 0) {
-                throw new Error(errorMessage);
+    function extension$1(combined, extension2) {
+        let key;
+        for (key in extension2) {
+            if (own$6.call(extension2, key)) {
+                switch (key) {
+                    case "canContainEols": {
+                        const right2 = extension2[key];
+                        if (right2) {
+                            combined[key].push(...right2);
+                        }
+                        break;
+                    }
+                    case "transforms": {
+                        const right2 = extension2[key];
+                        if (right2) {
+                            combined[key].push(...right2);
+                        }
+                        break;
+                    }
+                    case "enter":
+                    case "exit": {
+                        const right2 = extension2[key];
+                        if (right2) {
+                            Object.assign(combined[key], right2);
+                        }
+                        break;
+                    }
+                }
             }
-            item = items[indexProp];
-            index2 = indexProp;
+        }
+    }
+
+    function defaultOnError(left2, right2) {
+        if (left2) {
+            throw new Error(
+                "Cannot close `" + left2.type + "` (" + stringifyPosition({
+                    start: left2.start,
+                    end: left2.end
+                }) + "): a different token (`" + right2.type + "`, " + stringifyPosition({
+                    start: right2.start,
+                    end: right2.end
+                }) + ") is open"
+            );
         } else {
-            index2 = indexProp === void 0 ? items.indexOf(itemProp) : indexProp;
-            item = itemProp;
+            throw new Error(
+                "Cannot close document, a token (`" + right2.type + "`, " + stringifyPosition({
+                    start: right2.start,
+                    end: right2.end
+                }) + ") is still open"
+            );
         }
-        return [item, index2];
     }
 
-    function itemToString(item) {
-        return item ? String(item) : "";
+    function remarkParse(options) {
+        const self2 = this;
+        self2.parser = parser2;
+
+        function parser2(doc2) {
+            return fromMarkdown(doc2, {
+                ...self2.data("settings"),
+                ...options,
+                extensions: self2.data("micromarkExtensions") || [],
+                mdastExtensions: self2.data("fromMarkdownExtensions") || []
+            });
+        }
     }
 
-    function isAcceptedCharacterKey(key) {
-        return /^\S{1}$/.test(key);
+    function blockquote$1(state, node2) {
+        const result = {
+            type: "element",
+            tagName: "blockquote",
+            properties: {},
+            children: state.wrap(state.all(node2), true)
+        };
+        state.patch(node2, result);
+        return state.applyData(node2, result);
     }
 
-    function capitalizeString(string2) {
-        return "" + string2.slice(0, 1).toUpperCase() + string2.slice(1);
+    function hardBreak$1(state, node2) {
+        const result = {
+            type: "element",
+            tagName: "br",
+            properties: {},
+            children: []
+        };
+        state.patch(node2, result);
+        return [state.applyData(node2, result), {
+            type: "text",
+            value: "\n"
+        }];
     }
 
-    function useLatestRef(val) {
-        var ref2 = React.useRef(val);
-        ref2.current = val;
-        return ref2;
+    function code$3(state, node2) {
+        const value = node2.value ? node2.value + "\n" : "";
+        const properties = {};
+        if (node2.lang) {
+            properties.className = ["language-" + node2.lang];
+        }
+        let result = {
+            type: "element",
+            tagName: "code",
+            properties,
+            children: [{
+                type: "text",
+                value
+            }]
+        };
+        if (node2.meta) {
+            result.data = {
+                meta: node2.meta
+            };
+        }
+        state.patch(node2, result);
+        result = state.applyData(node2, result);
+        result = {
+            type: "element",
+            tagName: "pre",
+            properties: {},
+            children: [result]
+        };
+        state.patch(node2, result);
+        return result;
     }
 
-    function useEnhancedReducer(reducer2, initialState2, props) {
-        var prevStateRef = React.useRef();
-        var actionRef = React.useRef();
-        var enhancedReducer = React.useCallback(function(state2, action2) {
-            actionRef.current = action2;
-            state2 = getState(state2, action2.props);
-            var changes = reducer2(state2, action2);
-            var newState = action2.props.stateReducer(state2, _extends$3({}, action2, {
-                changes
-            }));
-            return newState;
-        }, [reducer2]);
-        var _useReducer = React.useReducer(enhancedReducer, initialState2),
-            state = _useReducer[0],
-            dispatch2 = _useReducer[1];
-        var propsRef = useLatestRef(props);
-        var dispatchWithProps = React.useCallback(function(action2) {
-            return dispatch2(_extends$3({
-                props: propsRef.current
-            }, action2));
-        }, [propsRef]);
-        var action = actionRef.current;
-        React.useEffect(function() {
-            if (action && prevStateRef.current && prevStateRef.current !== state) {
-                callOnChangeProps(action, getState(prevStateRef.current, action.props), state);
-            }
-            prevStateRef.current = state;
-        }, [state, props, action]);
-        return [state, dispatchWithProps];
+    function strikethrough(state, node2) {
+        const result = {
+            type: "element",
+            tagName: "del",
+            properties: {},
+            children: state.all(node2)
+        };
+        state.patch(node2, result);
+        return state.applyData(node2, result);
     }
 
-    function useControlledReducer$1(reducer2, initialState2, props) {
-        var _useEnhancedReducer = useEnhancedReducer(reducer2, initialState2, props),
-            state = _useEnhancedReducer[0],
-            dispatch2 = _useEnhancedReducer[1];
-        return [getState(state, props), dispatch2];
+    function emphasis$1(state, node2) {
+        const result = {
+            type: "element",
+            tagName: "em",
+            properties: {},
+            children: state.all(node2)
+        };
+        state.patch(node2, result);
+        return state.applyData(node2, result);
     }
-    var defaultProps$3 = {
-        itemToString,
-        stateReducer,
-        getA11ySelectionMessage,
-        scrollIntoView: scrollIntoView$1,
-        environment: typeof window === "undefined" ? {} : window
-    };
 
-    function getDefaultValue$1(props, propKey, defaultStateValues2) {
-        if (defaultStateValues2 === void 0) {
-            defaultStateValues2 = dropdownDefaultStateValues;
+    function footnoteReference$1(state, node2) {
+        const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
+        const id2 = String(node2.identifier).toUpperCase();
+        const safeId = normalizeUri(id2.toLowerCase());
+        const index2 = state.footnoteOrder.indexOf(id2);
+        let counter2;
+        let reuseCounter = state.footnoteCounts.get(id2);
+        if (reuseCounter === void 0) {
+            reuseCounter = 0;
+            state.footnoteOrder.push(id2);
+            counter2 = state.footnoteOrder.length;
+        } else {
+            counter2 = index2 + 1;
         }
-        var defaultValue2 = props["default" + capitalizeString(propKey)];
-        if (defaultValue2 !== void 0) {
-            return defaultValue2;
+        reuseCounter += 1;
+        state.footnoteCounts.set(id2, reuseCounter);
+        const link2 = {
+            type: "element",
+            tagName: "a",
+            properties: {
+                href: "#" + clobberPrefix + "fn-" + safeId,
+                id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
+                dataFootnoteRef: true,
+                ariaDescribedBy: ["footnote-label"]
+            },
+            children: [{
+                type: "text",
+                value: String(counter2)
+            }]
+        };
+        state.patch(node2, link2);
+        const sup = {
+            type: "element",
+            tagName: "sup",
+            properties: {},
+            children: [link2]
+        };
+        state.patch(node2, sup);
+        return state.applyData(node2, sup);
+    }
+
+    function heading$2(state, node2) {
+        const result = {
+            type: "element",
+            tagName: "h" + node2.depth,
+            properties: {},
+            children: state.all(node2)
+        };
+        state.patch(node2, result);
+        return state.applyData(node2, result);
+    }
+
+    function html$2(state, node2) {
+        if (state.options.allowDangerousHtml) {
+            const result = {
+                type: "raw",
+                value: node2.value
+            };
+            state.patch(node2, result);
+            return state.applyData(node2, result);
         }
-        return defaultStateValues2[propKey];
+        return void 0;
     }
 
-    function getInitialValue$1(props, propKey, defaultStateValues2) {
-        if (defaultStateValues2 === void 0) {
-            defaultStateValues2 = dropdownDefaultStateValues;
+    function revert(state, node2) {
+        const subtype = node2.referenceType;
+        let suffix = "]";
+        if (subtype === "collapsed") {
+            suffix += "[]";
+        } else if (subtype === "full") {
+            suffix += "[" + (node2.label || node2.identifier) + "]";
         }
-        var value = props[propKey];
-        if (value !== void 0) {
-            return value;
+        if (node2.type === "imageReference") {
+            return [{
+                type: "text",
+                value: "![" + node2.alt + suffix
+            }];
         }
-        var initialValue = props["initial" + capitalizeString(propKey)];
-        if (initialValue !== void 0) {
-            return initialValue;
+        const contents = state.all(node2);
+        const head = contents[0];
+        if (head && head.type === "text") {
+            head.value = "[" + head.value;
+        } else {
+            contents.unshift({
+                type: "text",
+                value: "["
+            });
         }
-        return getDefaultValue$1(props, propKey, defaultStateValues2);
+        const tail = contents[contents.length - 1];
+        if (tail && tail.type === "text") {
+            tail.value += suffix;
+        } else {
+            contents.push({
+                type: "text",
+                value: suffix
+            });
+        }
+        return contents;
     }
 
-    function getInitialState$2(props) {
-        var selectedItem = getInitialValue$1(props, "selectedItem");
-        var isOpen = getInitialValue$1(props, "isOpen");
-        var highlightedIndex = getInitialValue$1(props, "highlightedIndex");
-        var inputValue = getInitialValue$1(props, "inputValue");
-        return {
-            highlightedIndex: highlightedIndex < 0 && selectedItem && isOpen ? props.items.indexOf(selectedItem) : highlightedIndex,
-            isOpen,
-            selectedItem,
-            inputValue
+    function imageReference$1(state, node2) {
+        const id2 = String(node2.identifier).toUpperCase();
+        const def = state.definitionById.get(id2);
+        if (!def) {
+            return revert(state, node2);
+        }
+        const properties = {
+            src: normalizeUri(def.url || ""),
+            alt: node2.alt
+        };
+        if (def.title !== null && def.title !== void 0) {
+            properties.title = def.title;
+        }
+        const result = {
+            type: "element",
+            tagName: "img",
+            properties,
+            children: []
         };
+        state.patch(node2, result);
+        return state.applyData(node2, result);
     }
 
-    function getHighlightedIndexOnOpen(props, state, offset2) {
-        var items = props.items,
-            initialHighlightedIndex = props.initialHighlightedIndex,
-            defaultHighlightedIndex = props.defaultHighlightedIndex;
-        var selectedItem = state.selectedItem,
-            highlightedIndex = state.highlightedIndex;
-        if (items.length === 0) {
-            return -1;
-        }
-        if (initialHighlightedIndex !== void 0 && highlightedIndex === initialHighlightedIndex) {
-            return initialHighlightedIndex;
+    function image$1(state, node2) {
+        const properties = {
+            src: normalizeUri(node2.url)
+        };
+        if (node2.alt !== null && node2.alt !== void 0) {
+            properties.alt = node2.alt;
         }
-        if (defaultHighlightedIndex !== void 0) {
-            return defaultHighlightedIndex;
+        if (node2.title !== null && node2.title !== void 0) {
+            properties.title = node2.title;
         }
-        if (selectedItem) {
-            return items.indexOf(selectedItem);
+        const result = {
+            type: "element",
+            tagName: "img",
+            properties,
+            children: []
+        };
+        state.patch(node2, result);
+        return state.applyData(node2, result);
+    }
+
+    function inlineCode$1(state, node2) {
+        const text2 = {
+            type: "text",
+            value: node2.value.replace(/\r?\n|\r/g, " ")
+        };
+        state.patch(node2, text2);
+        const result = {
+            type: "element",
+            tagName: "code",
+            properties: {},
+            children: [text2]
+        };
+        state.patch(node2, result);
+        return state.applyData(node2, result);
+    }
+
+    function linkReference$1(state, node2) {
+        const id2 = String(node2.identifier).toUpperCase();
+        const def = state.definitionById.get(id2);
+        if (!def) {
+            return revert(state, node2);
         }
-        if (offset2 === 0) {
-            return -1;
+        const properties = {
+            href: normalizeUri(def.url || "")
+        };
+        if (def.title !== null && def.title !== void 0) {
+            properties.title = def.title;
         }
-        return offset2 < 0 ? items.length - 1 : 0;
+        const result = {
+            type: "element",
+            tagName: "a",
+            properties,
+            children: state.all(node2)
+        };
+        state.patch(node2, result);
+        return state.applyData(node2, result);
     }
 
-    function useMouseAndTouchTracker(isOpen, downshiftElementRefs, environment, handleBlur) {
-        var mouseAndTouchTrackersRef = React.useRef({
-            isMouseDown: false,
-            isTouchMove: false
-        });
-        React.useEffect(function() {
-            if ((environment == null ? void 0 : environment.addEventListener) == null) {
-                return;
-            }
-            var onMouseDown = function onMouseDown2() {
-                mouseAndTouchTrackersRef.current.isMouseDown = true;
-            };
-            var onMouseUp = function onMouseUp2(event2) {
-                mouseAndTouchTrackersRef.current.isMouseDown = false;
-                if (isOpen && !targetWithinDownshift(event2.target, downshiftElementRefs.map(function(ref2) {
-                        return ref2.current;
-                    }), environment)) {
-                    handleBlur();
-                }
-            };
-            var onTouchStart = function onTouchStart2() {
-                mouseAndTouchTrackersRef.current.isTouchMove = false;
-            };
-            var onTouchMove = function onTouchMove2() {
-                mouseAndTouchTrackersRef.current.isTouchMove = true;
-            };
-            var onTouchEnd = function onTouchEnd2(event2) {
-                if (isOpen && !mouseAndTouchTrackersRef.current.isTouchMove && !targetWithinDownshift(event2.target, downshiftElementRefs.map(function(ref2) {
-                        return ref2.current;
-                    }), environment, false)) {
-                    handleBlur();
-                }
-            };
-            environment.addEventListener("mousedown", onMouseDown);
-            environment.addEventListener("mouseup", onMouseUp);
-            environment.addEventListener("touchstart", onTouchStart);
-            environment.addEventListener("touchmove", onTouchMove);
-            environment.addEventListener("touchend", onTouchEnd);
-            return function cleanup() {
-                environment.removeEventListener("mousedown", onMouseDown);
-                environment.removeEventListener("mouseup", onMouseUp);
-                environment.removeEventListener("touchstart", onTouchStart);
-                environment.removeEventListener("touchmove", onTouchMove);
-                environment.removeEventListener("touchend", onTouchEnd);
-            };
-        }, [isOpen, environment]);
-        return mouseAndTouchTrackersRef;
+    function link$2(state, node2) {
+        const properties = {
+            href: normalizeUri(node2.url)
+        };
+        if (node2.title !== null && node2.title !== void 0) {
+            properties.title = node2.title;
+        }
+        const result = {
+            type: "element",
+            tagName: "a",
+            properties,
+            children: state.all(node2)
+        };
+        state.patch(node2, result);
+        return state.applyData(node2, result);
     }
-    var useGetterPropsCalledChecker = function useGetterPropsCalledChecker2() {
-        return noop$6;
-    };
 
-    function useA11yMessageSetter(getA11yMessage, dependencyArray, _ref2) {
-        var isInitialMount = _ref2.isInitialMount,
-            highlightedIndex = _ref2.highlightedIndex,
-            items = _ref2.items,
-            environment = _ref2.environment,
-            rest = _objectWithoutPropertiesLoose$4(_ref2, _excluded$3);
-        React.useEffect(function() {
-            if (isInitialMount || false) {
-                return;
+    function listItem$1(state, node2, parent) {
+        const results = state.all(node2);
+        const loose = parent ? listLoose(parent) : listItemLoose(node2);
+        const properties = {};
+        const children2 = [];
+        if (typeof node2.checked === "boolean") {
+            const head = results[0];
+            let paragraph2;
+            if (head && head.type === "element" && head.tagName === "p") {
+                paragraph2 = head;
+            } else {
+                paragraph2 = {
+                    type: "element",
+                    tagName: "p",
+                    properties: {},
+                    children: []
+                };
+                results.unshift(paragraph2);
             }
-            updateA11yStatus(function() {
-                return getA11yMessage(_extends$3({
-                    highlightedIndex,
-                    highlightedItem: items[highlightedIndex],
-                    resultCount: items.length
-                }, rest));
-            }, environment.document);
-        }, dependencyArray);
-    }
-
-    function useScrollIntoView(_ref3) {
-        var highlightedIndex = _ref3.highlightedIndex,
-            isOpen = _ref3.isOpen,
-            itemRefs = _ref3.itemRefs,
-            getItemNodeFromIndex = _ref3.getItemNodeFromIndex,
-            menuElement = _ref3.menuElement,
-            scrollIntoViewProp = _ref3.scrollIntoView;
-        var shouldScrollRef = React.useRef(true);
-        useIsomorphicLayoutEffect$3(function() {
-            if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {
-                return;
+            if (paragraph2.children.length > 0) {
+                paragraph2.children.unshift({
+                    type: "text",
+                    value: " "
+                });
             }
-            if (shouldScrollRef.current === false) {
-                shouldScrollRef.current = true;
+            paragraph2.children.unshift({
+                type: "element",
+                tagName: "input",
+                properties: {
+                    type: "checkbox",
+                    checked: node2.checked,
+                    disabled: true
+                },
+                children: []
+            });
+            properties.className = ["task-list-item"];
+        }
+        let index2 = -1;
+        while (++index2 < results.length) {
+            const child = results[index2];
+            if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
+                children2.push({
+                    type: "text",
+                    value: "\n"
+                });
+            }
+            if (child.type === "element" && child.tagName === "p" && !loose) {
+                children2.push(...child.children);
             } else {
-                scrollIntoViewProp(getItemNodeFromIndex(highlightedIndex), menuElement);
+                children2.push(child);
             }
-        }, [highlightedIndex]);
-        return shouldScrollRef;
+        }
+        const tail = results[results.length - 1];
+        if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
+            children2.push({
+                type: "text",
+                value: "\n"
+            });
+        }
+        const result = {
+            type: "element",
+            tagName: "li",
+            properties,
+            children: children2
+        };
+        state.patch(node2, result);
+        return state.applyData(node2, result);
     }
-    var useControlPropsValidator = noop$6;
 
-    function getChangesOnSelection(props, highlightedIndex, inputValue) {
-        var _props$items;
-        if (inputValue === void 0) {
-            inputValue = true;
+    function listLoose(node2) {
+        let loose = false;
+        if (node2.type === "list") {
+            loose = node2.spread || false;
+            const children2 = node2.children;
+            let index2 = -1;
+            while (!loose && ++index2 < children2.length) {
+                loose = listItemLoose(children2[index2]);
+            }
         }
-        var shouldSelect = ((_props$items = props.items) == null ? void 0 : _props$items.length) && highlightedIndex >= 0;
-        return _extends$3({
-            isOpen: false,
-            highlightedIndex: -1
-        }, shouldSelect && _extends$3({
-            selectedItem: props.items[highlightedIndex],
-            isOpen: getDefaultValue$1(props, "isOpen"),
-            highlightedIndex: getDefaultValue$1(props, "highlightedIndex")
-        }, inputValue && {
-            inputValue: props.itemToString(props.items[highlightedIndex])
-        }));
+        return loose;
     }
 
-    function downshiftCommonReducer(state, action, stateChangeTypes2) {
-        var type2 = action.type,
-            props = action.props;
-        var changes;
-        switch (type2) {
-            case stateChangeTypes2.ItemMouseMove:
-                changes = {
-                    highlightedIndex: action.disabled ? -1 : action.index
-                };
-                break;
-            case stateChangeTypes2.MenuMouseLeave:
-                changes = {
-                    highlightedIndex: -1
-                };
-                break;
-            case stateChangeTypes2.ToggleButtonClick:
-            case stateChangeTypes2.FunctionToggleMenu:
-                changes = {
-                    isOpen: !state.isOpen,
-                    highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)
-                };
-                break;
-            case stateChangeTypes2.FunctionOpenMenu:
-                changes = {
-                    isOpen: true,
-                    highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)
-                };
-                break;
-            case stateChangeTypes2.FunctionCloseMenu:
-                changes = {
-                    isOpen: false
-                };
-                break;
-            case stateChangeTypes2.FunctionSetHighlightedIndex:
-                changes = {
-                    highlightedIndex: action.highlightedIndex
-                };
-                break;
-            case stateChangeTypes2.FunctionSetInputValue:
-                changes = {
-                    inputValue: action.inputValue
-                };
+    function listItemLoose(node2) {
+        const spread = node2.spread;
+        return spread === null || spread === void 0 ? node2.children.length > 1 : spread;
+    }
+
+    function list$1(state, node2) {
+        const properties = {};
+        const results = state.all(node2);
+        let index2 = -1;
+        if (typeof node2.start === "number" && node2.start !== 1) {
+            properties.start = node2.start;
+        }
+        while (++index2 < results.length) {
+            const child = results[index2];
+            if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
+                properties.className = ["contains-task-list"];
                 break;
-            case stateChangeTypes2.FunctionReset:
-                changes = {
-                    highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
-                    isOpen: getDefaultValue$1(props, "isOpen"),
-                    selectedItem: getDefaultValue$1(props, "selectedItem"),
-                    inputValue: getDefaultValue$1(props, "inputValue")
+            }
+        }
+        const result = {
+            type: "element",
+            tagName: node2.ordered ? "ol" : "ul",
+            properties,
+            children: state.wrap(results, true)
+        };
+        state.patch(node2, result);
+        return state.applyData(node2, result);
+    }
+
+    function paragraph$1(state, node2) {
+        const result = {
+            type: "element",
+            tagName: "p",
+            properties: {},
+            children: state.all(node2)
+        };
+        state.patch(node2, result);
+        return state.applyData(node2, result);
+    }
+
+    function root$4(state, node2) {
+        const result = {
+            type: "root",
+            children: state.wrap(state.all(node2))
+        };
+        state.patch(node2, result);
+        return state.applyData(node2, result);
+    }
+
+    function strong$1(state, node2) {
+        const result = {
+            type: "element",
+            tagName: "strong",
+            properties: {},
+            children: state.all(node2)
+        };
+        state.patch(node2, result);
+        return state.applyData(node2, result);
+    }
+
+    function table(state, node2) {
+        const rows = state.all(node2);
+        const firstRow = rows.shift();
+        const tableContent = [];
+        if (firstRow) {
+            const head = {
+                type: "element",
+                tagName: "thead",
+                properties: {},
+                children: state.wrap([firstRow], true)
+            };
+            state.patch(node2.children[0], head);
+            tableContent.push(head);
+        }
+        if (rows.length > 0) {
+            const body = {
+                type: "element",
+                tagName: "tbody",
+                properties: {},
+                children: state.wrap(rows, true)
+            };
+            const start2 = pointStart$1(node2.children[1]);
+            const end2 = pointEnd$1(node2.children[node2.children.length - 1]);
+            if (start2 && end2)
+                body.position = {
+                    start: start2,
+                    end: end2
                 };
-                break;
-            default:
-                throw new Error("Reducer called without proper action type.");
+            tableContent.push(body);
         }
-        return _extends$3({}, state, changes);
+        const result = {
+            type: "element",
+            tagName: "table",
+            properties: {},
+            children: state.wrap(tableContent, true)
+        };
+        state.patch(node2, result);
+        return state.applyData(node2, result);
     }
 
-    function getItemIndexByCharacterKey(_a3) {
-        var keysSoFar = _a3.keysSoFar,
-            highlightedIndex = _a3.highlightedIndex,
-            items = _a3.items,
-            itemToString2 = _a3.itemToString,
-            getItemNodeFromIndex = _a3.getItemNodeFromIndex;
-        var lowerCasedKeysSoFar = keysSoFar.toLowerCase();
-        for (var index2 = 0; index2 < items.length; index2++) {
-            var offsetIndex = (index2 + highlightedIndex + (keysSoFar.length < 2 ? 1 : 0)) % items.length;
-            var item = items[offsetIndex];
-            if (item !== void 0 && itemToString2(item).toLowerCase().startsWith(lowerCasedKeysSoFar)) {
-                var element2 = getItemNodeFromIndex(offsetIndex);
-                if (!(element2 === null || element2 === void 0 ? void 0 : element2.hasAttribute("disabled"))) {
-                    return offsetIndex;
-                }
+    function tableRow(state, node2, parent) {
+        const siblings = parent ? parent.children : void 0;
+        const rowIndex = siblings ? siblings.indexOf(node2) : 1;
+        const tagName = rowIndex === 0 ? "th" : "td";
+        const align = parent && parent.type === "table" ? parent.align : void 0;
+        const length = align ? align.length : node2.children.length;
+        let cellIndex = -1;
+        const cells2 = [];
+        while (++cellIndex < length) {
+            const cell = node2.children[cellIndex];
+            const properties = {};
+            const alignValue = align ? align[cellIndex] : void 0;
+            if (alignValue) {
+                properties.align = alignValue;
+            }
+            let result2 = {
+                type: "element",
+                tagName,
+                properties,
+                children: []
+            };
+            if (cell) {
+                result2.children = state.all(cell);
+                state.patch(cell, result2);
+                result2 = state.applyData(cell, result2);
             }
+            cells2.push(result2);
         }
-        return highlightedIndex;
+        const result = {
+            type: "element",
+            tagName: "tr",
+            properties: {},
+            children: state.wrap(cells2, true)
+        };
+        state.patch(node2, result);
+        return state.applyData(node2, result);
     }
-    ({
-        items: propTypes.exports.array.isRequired,
-        itemToString: propTypes.exports.func,
-        getA11yStatusMessage: propTypes.exports.func,
-        getA11ySelectionMessage: propTypes.exports.func,
-        highlightedIndex: propTypes.exports.number,
-        defaultHighlightedIndex: propTypes.exports.number,
-        initialHighlightedIndex: propTypes.exports.number,
-        isOpen: propTypes.exports.bool,
-        defaultIsOpen: propTypes.exports.bool,
-        initialIsOpen: propTypes.exports.bool,
-        selectedItem: propTypes.exports.any,
-        initialSelectedItem: propTypes.exports.any,
-        defaultSelectedItem: propTypes.exports.any,
-        id: propTypes.exports.string,
-        labelId: propTypes.exports.string,
-        menuId: propTypes.exports.string,
-        getItemId: propTypes.exports.func,
-        toggleButtonId: propTypes.exports.string,
-        stateReducer: propTypes.exports.func,
-        onSelectedItemChange: propTypes.exports.func,
-        onHighlightedIndexChange: propTypes.exports.func,
-        onStateChange: propTypes.exports.func,
-        onIsOpenChange: propTypes.exports.func,
-        environment: propTypes.exports.shape({
-            addEventListener: propTypes.exports.func,
-            removeEventListener: propTypes.exports.func,
-            document: propTypes.exports.shape({
-                getElementById: propTypes.exports.func,
-                activeElement: propTypes.exports.any,
-                body: propTypes.exports.any
-            })
-        })
-    });
 
-    function getA11yStatusMessage(_a3) {
-        var isOpen = _a3.isOpen,
-            resultCount = _a3.resultCount,
-            previousResultCount = _a3.previousResultCount;
-        if (!isOpen) {
-            return "";
+    function tableCell(state, node2) {
+        const result = {
+            type: "element",
+            tagName: "td",
+            properties: {},
+            children: state.all(node2)
+        };
+        state.patch(node2, result);
+        return state.applyData(node2, result);
+    }
+    const tab$1 = 9;
+    const space$1 = 32;
+
+    function trimLines(value) {
+        const source = String(value);
+        const search2 = /\r?\n|\r/g;
+        let match2 = search2.exec(source);
+        let last = 0;
+        const lines = [];
+        while (match2) {
+            lines.push(
+                trimLine(source.slice(last, match2.index), last > 0, true),
+                match2[0]
+            );
+            last = match2.index + match2[0].length;
+            match2 = search2.exec(source);
         }
-        if (!resultCount) {
-            return "No results are available.";
+        lines.push(trimLine(source.slice(last), last > 0, false));
+        return lines.join("");
+    }
+
+    function trimLine(value, start2, end2) {
+        let startIndex = 0;
+        let endIndex = value.length;
+        if (start2) {
+            let code2 = value.codePointAt(startIndex);
+            while (code2 === tab$1 || code2 === space$1) {
+                startIndex++;
+                code2 = value.codePointAt(startIndex);
+            }
         }
-        if (resultCount !== previousResultCount) {
-            return "".concat(resultCount, " result").concat(resultCount === 1 ? " is" : "s are", " available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.");
+        if (end2) {
+            let code2 = value.codePointAt(endIndex - 1);
+            while (code2 === tab$1 || code2 === space$1) {
+                endIndex--;
+                code2 = value.codePointAt(endIndex - 1);
+            }
         }
-        return "";
+        return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
     }
-    var defaultProps$2 = __assign(__assign({}, defaultProps$3), {
-        getA11yStatusMessage
-    });
-    var ToggleButtonClick$1 = 0;
-    var ToggleButtonKeyDownArrowDown = 1;
-    var ToggleButtonKeyDownArrowUp = 2;
-    var ToggleButtonKeyDownCharacter = 3;
-    var ToggleButtonKeyDownEscape = 4;
-    var ToggleButtonKeyDownHome = 5;
-    var ToggleButtonKeyDownEnd = 6;
-    var ToggleButtonKeyDownEnter = 7;
-    var ToggleButtonKeyDownSpaceButton = 8;
-    var ToggleButtonKeyDownPageUp = 9;
-    var ToggleButtonKeyDownPageDown = 10;
-    var ToggleButtonBlur = 11;
-    var MenuMouseLeave$1 = 12;
-    var ItemMouseMove$1 = 13;
-    var ItemClick$1 = 14;
-    var FunctionToggleMenu$1 = 15;
-    var FunctionOpenMenu$1 = 16;
-    var FunctionCloseMenu$1 = 17;
-    var FunctionSetHighlightedIndex$1 = 18;
-    var FunctionSelectItem$1 = 19;
-    var FunctionSetInputValue$1 = 20;
-    var FunctionReset$2 = 21;
-    var stateChangeTypes$2$1 = /* @__PURE__ */ Object.freeze({
-        __proto__: null,
-        ToggleButtonClick: ToggleButtonClick$1,
-        ToggleButtonKeyDownArrowDown,
-        ToggleButtonKeyDownArrowUp,
-        ToggleButtonKeyDownCharacter,
-        ToggleButtonKeyDownEscape,
-        ToggleButtonKeyDownHome,
-        ToggleButtonKeyDownEnd,
-        ToggleButtonKeyDownEnter,
-        ToggleButtonKeyDownSpaceButton,
-        ToggleButtonKeyDownPageUp,
-        ToggleButtonKeyDownPageDown,
-        ToggleButtonBlur,
-        MenuMouseLeave: MenuMouseLeave$1,
-        ItemMouseMove: ItemMouseMove$1,
-        ItemClick: ItemClick$1,
-        FunctionToggleMenu: FunctionToggleMenu$1,
-        FunctionOpenMenu: FunctionOpenMenu$1,
-        FunctionCloseMenu: FunctionCloseMenu$1,
-        FunctionSetHighlightedIndex: FunctionSetHighlightedIndex$1,
-        FunctionSelectItem: FunctionSelectItem$1,
-        FunctionSetInputValue: FunctionSetInputValue$1,
-        FunctionReset: FunctionReset$2
-    });
 
-    function downshiftSelectReducer(state, action) {
-        var _props$items;
-        var type2 = action.type,
-            props = action.props,
-            altKey = action.altKey;
-        var changes;
-        switch (type2) {
-            case ItemClick$1:
-                changes = {
-                    isOpen: getDefaultValue$1(props, "isOpen"),
-                    highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
-                    selectedItem: props.items[action.index]
-                };
-                break;
-            case ToggleButtonKeyDownCharacter: {
-                var lowercasedKey = action.key;
-                var inputValue = "" + state.inputValue + lowercasedKey;
-                var prevHighlightedIndex = !state.isOpen && state.selectedItem ? props.items.indexOf(state.selectedItem) : state.highlightedIndex;
-                var highlightedIndex = getItemIndexByCharacterKey({
-                    keysSoFar: inputValue,
-                    highlightedIndex: prevHighlightedIndex,
-                    items: props.items,
-                    itemToString: props.itemToString,
-                    getItemNodeFromIndex: action.getItemNodeFromIndex
-                });
-                changes = {
-                    inputValue,
-                    highlightedIndex,
-                    isOpen: true
-                };
-            }
-            break;
-            case ToggleButtonKeyDownArrowDown: {
-                var _highlightedIndex = state.isOpen ? getNextWrappingIndex(1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, false) : altKey && state.selectedItem == null ? -1 : getHighlightedIndexOnOpen(props, state, 1);
-                changes = {
-                    highlightedIndex: _highlightedIndex,
-                    isOpen: true
-                };
-            }
-            break;
-            case ToggleButtonKeyDownArrowUp:
-                if (state.isOpen && altKey) {
-                    changes = getChangesOnSelection(props, state.highlightedIndex, false);
-                } else {
-                    var _highlightedIndex2 = state.isOpen ? getNextWrappingIndex(-1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, false) : getHighlightedIndexOnOpen(props, state, -1);
-                    changes = {
-                        highlightedIndex: _highlightedIndex2,
-                        isOpen: true
-                    };
-                }
-                break;
-            case ToggleButtonKeyDownEnter:
-            case ToggleButtonKeyDownSpaceButton:
-                changes = getChangesOnSelection(props, state.highlightedIndex, false);
-                break;
-            case ToggleButtonKeyDownHome:
-                changes = {
-                    highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false),
-                    isOpen: true
-                };
-                break;
-            case ToggleButtonKeyDownEnd:
-                changes = {
-                    highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false),
-                    isOpen: true
-                };
-                break;
-            case ToggleButtonKeyDownPageUp:
-                changes = {
-                    highlightedIndex: getNextWrappingIndex(-10, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, false)
-                };
-                break;
-            case ToggleButtonKeyDownPageDown:
-                changes = {
-                    highlightedIndex: getNextWrappingIndex(10, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, false)
-                };
-                break;
-            case ToggleButtonKeyDownEscape:
-                changes = {
-                    isOpen: false,
-                    highlightedIndex: -1
-                };
-                break;
-            case ToggleButtonBlur:
-                changes = _extends$3({
-                    isOpen: false,
-                    highlightedIndex: -1
-                }, state.highlightedIndex >= 0 && ((_props$items = props.items) == null ? void 0 : _props$items.length) && {
-                    selectedItem: props.items[state.highlightedIndex]
-                });
-                break;
-            case FunctionSelectItem$1:
-                changes = {
-                    selectedItem: action.selectedItem
-                };
-                break;
-            default:
-                return downshiftCommonReducer(state, action, stateChangeTypes$2$1);
-        }
-        return _extends$3({}, state, changes);
+    function text$3(state, node2) {
+        const result = {
+            type: "text",
+            value: trimLines(String(node2.value))
+        };
+        state.patch(node2, result);
+        return state.applyData(node2, result);
     }
-    var _excluded$2 = ["onMouseLeave", "refKey", "onKeyDown", "onBlur", "ref"],
-        _excluded2$2 = ["onBlur", "onClick", "onPress", "onKeyDown", "refKey", "ref"],
-        _excluded3$1 = ["item", "index", "onMouseMove", "onClick", "onPress", "refKey", "ref", "disabled"];
-    useSelect.stateChangeTypes = stateChangeTypes$2$1;
 
-    function useSelect(userProps) {
-        if (userProps === void 0) {
-            userProps = {};
-        }
-        var props = _extends$3({}, defaultProps$2, userProps);
-        var items = props.items,
-            scrollIntoView2 = props.scrollIntoView,
-            environment = props.environment,
-            itemToString2 = props.itemToString,
-            getA11ySelectionMessage2 = props.getA11ySelectionMessage,
-            getA11yStatusMessage2 = props.getA11yStatusMessage;
-        var initialState2 = getInitialState$2(props);
-        var _useControlledReducer = useControlledReducer$1(downshiftSelectReducer, initialState2, props),
-            state = _useControlledReducer[0],
-            dispatch2 = _useControlledReducer[1];
-        var isOpen = state.isOpen,
-            highlightedIndex = state.highlightedIndex,
-            selectedItem = state.selectedItem,
-            inputValue = state.inputValue;
-        var toggleButtonRef = React.useRef(null);
-        var menuRef = React.useRef(null);
-        var itemRefs = React.useRef({});
-        var clearTimeoutRef = React.useRef(null);
-        var elementIds = useElementIds(props);
-        var previousResultCountRef = React.useRef();
-        var isInitialMountRef = React.useRef(true);
-        var latest2 = useLatestRef({
-            state,
-            props
-        });
-        var getItemNodeFromIndex = React.useCallback(function(index2) {
-            return itemRefs.current[elementIds.getItemId(index2)];
-        }, [elementIds]);
-        useA11yMessageSetter(getA11yStatusMessage2, [isOpen, highlightedIndex, inputValue, items], _extends$3({
-            isInitialMount: isInitialMountRef.current,
-            previousResultCount: previousResultCountRef.current,
-            items,
-            environment,
-            itemToString: itemToString2
-        }, state));
-        useA11yMessageSetter(getA11ySelectionMessage2, [selectedItem], _extends$3({
-            isInitialMount: isInitialMountRef.current,
-            previousResultCount: previousResultCountRef.current,
-            items,
-            environment,
-            itemToString: itemToString2
-        }, state));
-        var shouldScrollRef = useScrollIntoView({
-            menuElement: menuRef.current,
-            highlightedIndex,
-            isOpen,
-            itemRefs,
-            scrollIntoView: scrollIntoView2,
-            getItemNodeFromIndex
-        });
-        React.useEffect(function() {
-            clearTimeoutRef.current = debounce$2(function(outerDispatch) {
-                outerDispatch({
-                    type: FunctionSetInputValue$1,
-                    inputValue: ""
-                });
-            }, 500);
-            return function() {
-                clearTimeoutRef.current.cancel();
-            };
-        }, []);
-        React.useEffect(function() {
-            if (!inputValue) {
-                return;
-            }
-            clearTimeoutRef.current(dispatch2);
-        }, [dispatch2, inputValue]);
-        useControlPropsValidator({
-            isInitialMount: isInitialMountRef.current,
-            props,
-            state
-        });
-        React.useEffect(function() {
-            if (isInitialMountRef.current) {
-                return;
-            }
-            previousResultCountRef.current = items.length;
-        });
-        var mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [menuRef, toggleButtonRef], environment, function() {
-            dispatch2({
-                type: ToggleButtonBlur
-            });
-        });
-        var setGetterPropCallInfo = useGetterPropsCalledChecker();
-        React.useEffect(function() {
-            isInitialMountRef.current = false;
-            return function() {
-                isInitialMountRef.current = true;
-            };
-        }, []);
-        React.useEffect(function() {
-            if (!isOpen) {
-                itemRefs.current = {};
-            }
-        }, [isOpen]);
-        var toggleButtonKeyDownHandlers = React.useMemo(function() {
-            return {
-                ArrowDown: function ArrowDown2(event2) {
-                    event2.preventDefault();
-                    dispatch2({
-                        type: ToggleButtonKeyDownArrowDown,
-                        getItemNodeFromIndex,
-                        altKey: event2.altKey
-                    });
-                },
-                ArrowUp: function ArrowUp2(event2) {
-                    event2.preventDefault();
-                    dispatch2({
-                        type: ToggleButtonKeyDownArrowUp,
-                        getItemNodeFromIndex,
-                        altKey: event2.altKey
-                    });
-                },
-                Home: function Home(event2) {
-                    event2.preventDefault();
-                    dispatch2({
-                        type: ToggleButtonKeyDownHome,
-                        getItemNodeFromIndex
-                    });
-                },
-                End: function End(event2) {
-                    event2.preventDefault();
-                    dispatch2({
-                        type: ToggleButtonKeyDownEnd,
-                        getItemNodeFromIndex
-                    });
-                },
-                Escape: function Escape2() {
-                    if (latest2.current.state.isOpen) {
-                        dispatch2({
-                            type: ToggleButtonKeyDownEscape
-                        });
-                    }
-                },
-                Enter: function Enter(event2) {
-                    event2.preventDefault();
-                    dispatch2({
-                        type: latest2.current.state.isOpen ? ToggleButtonKeyDownEnter : ToggleButtonClick$1
-                    });
-                },
-                PageUp: function PageUp(event2) {
-                    if (latest2.current.state.isOpen) {
-                        event2.preventDefault();
-                        dispatch2({
-                            type: ToggleButtonKeyDownPageUp,
-                            getItemNodeFromIndex
-                        });
-                    }
-                },
-                PageDown: function PageDown(event2) {
-                    if (latest2.current.state.isOpen) {
-                        event2.preventDefault();
-                        dispatch2({
-                            type: ToggleButtonKeyDownPageDown,
-                            getItemNodeFromIndex
-                        });
-                    }
-                },
-                " ": function _2(event2) {
-                    event2.preventDefault();
-                    var currentState = latest2.current.state;
-                    if (!currentState.isOpen) {
-                        dispatch2({
-                            type: ToggleButtonClick$1
-                        });
-                        return;
-                    }
-                    if (currentState.inputValue) {
-                        dispatch2({
-                            type: ToggleButtonKeyDownCharacter,
-                            key: " ",
-                            getItemNodeFromIndex
-                        });
-                    } else {
-                        dispatch2({
-                            type: ToggleButtonKeyDownSpaceButton
-                        });
-                    }
+    function thematicBreak$1(state, node2) {
+        const result = {
+            type: "element",
+            tagName: "hr",
+            properties: {},
+            children: []
+        };
+        state.patch(node2, result);
+        return state.applyData(node2, result);
+    }
+    const handlers$1 = {
+        blockquote: blockquote$1,
+        break: hardBreak$1,
+        code: code$3,
+        delete: strikethrough,
+        emphasis: emphasis$1,
+        footnoteReference: footnoteReference$1,
+        heading: heading$2,
+        html: html$2,
+        imageReference: imageReference$1,
+        image: image$1,
+        inlineCode: inlineCode$1,
+        linkReference: linkReference$1,
+        link: link$2,
+        listItem: listItem$1,
+        list: list$1,
+        paragraph: paragraph$1,
+        root: root$4,
+        strong: strong$1,
+        table,
+        tableCell,
+        tableRow,
+        text: text$3,
+        thematicBreak: thematicBreak$1,
+        toml: ignore,
+        yaml: ignore,
+        definition: ignore,
+        footnoteDefinition: ignore
+    };
+
+    function ignore() {
+        return void 0;
+    }
+    const VOID = -1;
+    const PRIMITIVE = 0;
+    const ARRAY = 1;
+    const OBJECT = 2;
+    const DATE = 3;
+    const REGEXP = 4;
+    const MAP = 5;
+    const SET$1 = 6;
+    const ERROR = 7;
+    const BIGINT = 8;
+    const env = typeof self === "object" ? self : globalThis;
+    const deserializer = ($2, _2) => {
+        const as = (out, index2) => {
+            $2.set(index2, out);
+            return out;
+        };
+        const unpair = (index2) => {
+            if ($2.has(index2))
+                return $2.get(index2);
+            const [type2, value] = _2[index2];
+            switch (type2) {
+                case PRIMITIVE:
+                case VOID:
+                    return as(value, index2);
+                case ARRAY: {
+                    const arr = as([], index2);
+                    for (const index3 of value)
+                        arr.push(unpair(index3));
+                    return arr;
                 }
-            };
-        }, [dispatch2, getItemNodeFromIndex, latest2]);
-        var toggleMenu = React.useCallback(function() {
-            dispatch2({
-                type: FunctionToggleMenu$1
-            });
-        }, [dispatch2]);
-        var closeMenu = React.useCallback(function() {
-            dispatch2({
-                type: FunctionCloseMenu$1
-            });
-        }, [dispatch2]);
-        var openMenu = React.useCallback(function() {
-            dispatch2({
-                type: FunctionOpenMenu$1
-            });
-        }, [dispatch2]);
-        var setHighlightedIndex = React.useCallback(function(newHighlightedIndex) {
-            dispatch2({
-                type: FunctionSetHighlightedIndex$1,
-                highlightedIndex: newHighlightedIndex
-            });
-        }, [dispatch2]);
-        var selectItem = React.useCallback(function(newSelectedItem) {
-            dispatch2({
-                type: FunctionSelectItem$1,
-                selectedItem: newSelectedItem
-            });
-        }, [dispatch2]);
-        var reset2 = React.useCallback(function() {
-            dispatch2({
-                type: FunctionReset$2
-            });
-        }, [dispatch2]);
-        var setInputValue = React.useCallback(function(newInputValue) {
-            dispatch2({
-                type: FunctionSetInputValue$1,
-                inputValue: newInputValue
-            });
-        }, [dispatch2]);
-        var getLabelProps = React.useCallback(function(labelProps) {
-            return _extends$3({
-                id: elementIds.labelId,
-                htmlFor: elementIds.toggleButtonId
-            }, labelProps);
-        }, [elementIds]);
-        var getMenuProps = React.useCallback(function(_temp, _temp2) {
-            var _extends2;
-            var _ref2 = _temp === void 0 ? {} : _temp,
-                onMouseLeave = _ref2.onMouseLeave,
-                _ref$refKey = _ref2.refKey,
-                refKey = _ref$refKey === void 0 ? "ref" : _ref$refKey;
-            _ref2.onKeyDown;
-            _ref2.onBlur;
-            var ref2 = _ref2.ref,
-                rest = _objectWithoutPropertiesLoose$4(_ref2, _excluded$2);
-            var _ref22 = _temp2 === void 0 ? {} : _temp2;
-            _ref22.suppressRefError;
-            var menuHandleMouseLeave = function menuHandleMouseLeave2() {
-                dispatch2({
-                    type: MenuMouseLeave$1
-                });
-            };
-            return _extends$3((_extends2 = {}, _extends2[refKey] = handleRefs(ref2, function(menuNode) {
-                menuRef.current = menuNode;
-            }), _extends2.id = elementIds.menuId, _extends2.role = "listbox", _extends2["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : "" + elementIds.labelId, _extends2.onMouseLeave = callAllEventHandlers(onMouseLeave, menuHandleMouseLeave), _extends2), rest);
-        }, [dispatch2, setGetterPropCallInfo, elementIds]);
-        var getToggleButtonProps = React.useCallback(function(_temp3, _temp4) {
-            var _extends3;
-            var _ref3 = _temp3 === void 0 ? {} : _temp3,
-                onBlur = _ref3.onBlur,
-                onClick = _ref3.onClick;
-            _ref3.onPress;
-            var onKeyDown = _ref3.onKeyDown,
-                _ref3$refKey = _ref3.refKey,
-                refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey,
-                ref2 = _ref3.ref,
-                rest = _objectWithoutPropertiesLoose$4(_ref3, _excluded2$2);
-            var _ref4 = _temp4 === void 0 ? {} : _temp4;
-            _ref4.suppressRefError;
-            var latestState = latest2.current.state;
-            var toggleButtonHandleClick = function toggleButtonHandleClick2() {
-                dispatch2({
-                    type: ToggleButtonClick$1
-                });
-            };
-            var toggleButtonHandleBlur = function toggleButtonHandleBlur2() {
-                if (latestState.isOpen && !mouseAndTouchTrackersRef.current.isMouseDown) {
-                    dispatch2({
-                        type: ToggleButtonBlur
-                    });
+                case OBJECT: {
+                    const object2 = as({}, index2);
+                    for (const [key, index3] of value)
+                        object2[unpair(key)] = unpair(index3);
+                    return object2;
                 }
-            };
-            var toggleButtonHandleKeyDown = function toggleButtonHandleKeyDown2(event2) {
-                var key = normalizeArrowKey(event2);
-                if (key && toggleButtonKeyDownHandlers[key]) {
-                    toggleButtonKeyDownHandlers[key](event2);
-                } else if (isAcceptedCharacterKey(key)) {
-                    dispatch2({
-                        type: ToggleButtonKeyDownCharacter,
-                        key,
-                        getItemNodeFromIndex
-                    });
+                case DATE:
+                    return as(new Date(value), index2);
+                case REGEXP: {
+                    const {
+                        source,
+                        flags
+                    } = value;
+                    return as(new RegExp(source, flags), index2);
                 }
-            };
-            var toggleProps = _extends$3((_extends3 = {}, _extends3[refKey] = handleRefs(ref2, function(toggleButtonNode) {
-                toggleButtonRef.current = toggleButtonNode;
-            }), _extends3["aria-activedescendant"] = latestState.isOpen && latestState.highlightedIndex > -1 ? elementIds.getItemId(latestState.highlightedIndex) : "", _extends3["aria-controls"] = elementIds.menuId, _extends3["aria-expanded"] = latest2.current.state.isOpen, _extends3["aria-haspopup"] = "listbox", _extends3["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : "" + elementIds.labelId, _extends3.id = elementIds.toggleButtonId, _extends3.role = "combobox", _extends3.tabIndex = 0, _extends3.onBlur = callAllEventHandlers(onBlur, toggleButtonHandleBlur), _extends3), rest);
-            if (!rest.disabled) {
-                {
-                    toggleProps.onClick = callAllEventHandlers(onClick, toggleButtonHandleClick);
-                    toggleProps.onKeyDown = callAllEventHandlers(onKeyDown, toggleButtonHandleKeyDown);
+                case MAP: {
+                    const map2 = as( /* @__PURE__ */ new Map(), index2);
+                    for (const [key, index3] of value)
+                        map2.set(unpair(key), unpair(index3));
+                    return map2;
+                }
+                case SET$1: {
+                    const set2 = as( /* @__PURE__ */ new Set(), index2);
+                    for (const index3 of value)
+                        set2.add(unpair(index3));
+                    return set2;
                 }
+                case ERROR: {
+                    const {
+                        name: name2,
+                        message
+                    } = value;
+                    return as(new env[name2](message), index2);
+                }
+                case BIGINT:
+                    return as(BigInt(value), index2);
+                case "BigInt":
+                    return as(Object(BigInt(value)), index2);
             }
-            return toggleProps;
-        }, [latest2, elementIds, setGetterPropCallInfo, dispatch2, mouseAndTouchTrackersRef, toggleButtonKeyDownHandlers, getItemNodeFromIndex]);
-        var getItemProps = React.useCallback(function(_temp5) {
-            var _extends4;
-            var _ref5 = _temp5 === void 0 ? {} : _temp5,
-                itemProp = _ref5.item,
-                indexProp = _ref5.index,
-                onMouseMove = _ref5.onMouseMove,
-                onClick = _ref5.onClick;
-            _ref5.onPress;
-            var _ref5$refKey = _ref5.refKey,
-                refKey = _ref5$refKey === void 0 ? "ref" : _ref5$refKey,
-                ref2 = _ref5.ref,
-                disabled2 = _ref5.disabled,
-                rest = _objectWithoutPropertiesLoose$4(_ref5, _excluded3$1);
-            var _latest$current = latest2.current,
-                latestState = _latest$current.state,
-                latestProps = _latest$current.props;
-            var _getItemAndIndex = getItemAndIndex(itemProp, indexProp, latestProps.items, "Pass either item or index to getItemProps!"),
-                item = _getItemAndIndex[0],
-                index2 = _getItemAndIndex[1];
-            var itemHandleMouseMove = function itemHandleMouseMove2() {
-                if (index2 === latestState.highlightedIndex) {
-                    return;
+            return as(new env[type2](value), index2);
+        };
+        return unpair;
+    };
+    const deserialize = (serialized) => deserializer( /* @__PURE__ */ new Map(), serialized)(0);
+    const EMPTY = "";
+    const {
+        toString: toString$5
+    } = {};
+    const {
+        keys: keys$2
+    } = Object;
+    const typeOf = (value) => {
+        const type2 = typeof value;
+        if (type2 !== "object" || !value)
+            return [PRIMITIVE, type2];
+        const asString = toString$5.call(value).slice(8, -1);
+        switch (asString) {
+            case "Array":
+                return [ARRAY, EMPTY];
+            case "Object":
+                return [OBJECT, EMPTY];
+            case "Date":
+                return [DATE, EMPTY];
+            case "RegExp":
+                return [REGEXP, EMPTY];
+            case "Map":
+                return [MAP, EMPTY];
+            case "Set":
+                return [SET$1, EMPTY];
+        }
+        if (asString.includes("Array"))
+            return [ARRAY, asString];
+        if (asString.includes("Error"))
+            return [ERROR, asString];
+        return [OBJECT, asString];
+    };
+    const shouldSkip = ([TYPE, type2]) => TYPE === PRIMITIVE && (type2 === "function" || type2 === "symbol");
+    const serializer = (strict, json2, $2, _2) => {
+        const as = (out, value) => {
+            const index2 = _2.push(out) - 1;
+            $2.set(value, index2);
+            return index2;
+        };
+        const pair2 = (value) => {
+            if ($2.has(value))
+                return $2.get(value);
+            let [TYPE, type2] = typeOf(value);
+            switch (TYPE) {
+                case PRIMITIVE: {
+                    let entry = value;
+                    switch (type2) {
+                        case "bigint":
+                            TYPE = BIGINT;
+                            entry = value.toString();
+                            break;
+                        case "function":
+                        case "symbol":
+                            if (strict)
+                                throw new TypeError("unable to serialize " + type2);
+                            entry = null;
+                            break;
+                        case "undefined":
+                            return as([VOID], value);
+                    }
+                    return as([TYPE, entry], value);
                 }
-                shouldScrollRef.current = false;
-                dispatch2({
-                    type: ItemMouseMove$1,
-                    index: index2,
-                    disabled: disabled2
-                });
-            };
-            var itemHandleClick = function itemHandleClick2() {
-                dispatch2({
-                    type: ItemClick$1,
-                    index: index2
-                });
-            };
-            var itemProps = _extends$3((_extends4 = {
-                disabled: disabled2,
-                role: "option",
-                "aria-selected": "" + (item === selectedItem),
-                id: elementIds.getItemId(index2)
-            }, _extends4[refKey] = handleRefs(ref2, function(itemNode) {
-                if (itemNode) {
-                    itemRefs.current[elementIds.getItemId(index2)] = itemNode;
+                case ARRAY: {
+                    if (type2)
+                        return as([type2, [...value]], value);
+                    const arr = [];
+                    const index2 = as([TYPE, arr], value);
+                    for (const entry of value)
+                        arr.push(pair2(entry));
+                    return index2;
                 }
-            }), _extends4), rest);
-            if (!disabled2) {
-                {
-                    itemProps.onClick = callAllEventHandlers(onClick, itemHandleClick);
+                case OBJECT: {
+                    if (type2) {
+                        switch (type2) {
+                            case "BigInt":
+                                return as([type2, value.toString()], value);
+                            case "Boolean":
+                            case "Number":
+                            case "String":
+                                return as([type2, value.valueOf()], value);
+                        }
+                    }
+                    if (json2 && "toJSON" in value)
+                        return pair2(value.toJSON());
+                    const entries = [];
+                    const index2 = as([TYPE, entries], value);
+                    for (const key of keys$2(value)) {
+                        if (strict || !shouldSkip(typeOf(value[key])))
+                            entries.push([pair2(key), pair2(value[key])]);
+                    }
+                    return index2;
+                }
+                case DATE:
+                    return as([TYPE, value.toISOString()], value);
+                case REGEXP: {
+                    const {
+                        source,
+                        flags
+                    } = value;
+                    return as([TYPE, {
+                        source,
+                        flags
+                    }], value);
+                }
+                case MAP: {
+                    const entries = [];
+                    const index2 = as([TYPE, entries], value);
+                    for (const [key, entry] of value) {
+                        if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))
+                            entries.push([pair2(key), pair2(entry)]);
+                    }
+                    return index2;
+                }
+                case SET$1: {
+                    const entries = [];
+                    const index2 = as([TYPE, entries], value);
+                    for (const entry of value) {
+                        if (strict || !shouldSkip(typeOf(entry)))
+                            entries.push(pair2(entry));
+                    }
+                    return index2;
                 }
             }
-            itemProps.onMouseMove = callAllEventHandlers(onMouseMove, itemHandleMouseMove);
-            return itemProps;
-        }, [latest2, selectedItem, elementIds, shouldScrollRef, dispatch2]);
-        return {
-            getToggleButtonProps,
-            getLabelProps,
-            getMenuProps,
-            getItemProps,
-            toggleMenu,
-            openMenu,
-            closeMenu,
-            setHighlightedIndex,
-            selectItem,
-            reset: reset2,
-            setInputValue,
-            highlightedIndex,
-            isOpen,
-            selectedItem,
-            inputValue
+            const {
+                message
+            } = value;
+            return as([TYPE, {
+                name: type2,
+                message
+            }], value);
         };
-    }
-    var InputKeyDownArrowDown = 0;
-    var InputKeyDownArrowUp = 1;
-    var InputKeyDownEscape = 2;
-    var InputKeyDownHome = 3;
-    var InputKeyDownEnd = 4;
-    var InputKeyDownPageUp = 5;
-    var InputKeyDownPageDown = 6;
-    var InputKeyDownEnter = 7;
-    var InputChange = 8;
-    var InputBlur = 9;
-    var InputFocus = 10;
-    var MenuMouseLeave = 11;
-    var ItemMouseMove = 12;
-    var ItemClick = 13;
-    var ToggleButtonClick = 14;
-    var FunctionToggleMenu = 15;
-    var FunctionOpenMenu = 16;
-    var FunctionCloseMenu = 17;
-    var FunctionSetHighlightedIndex = 18;
-    var FunctionSelectItem = 19;
-    var FunctionSetInputValue = 20;
-    var FunctionReset$1 = 21;
-    var ControlledPropUpdatedSelectedItem = 22;
-    var stateChangeTypes$1$1 = /* @__PURE__ */ Object.freeze({
-        __proto__: null,
-        InputKeyDownArrowDown,
-        InputKeyDownArrowUp,
-        InputKeyDownEscape,
-        InputKeyDownHome,
-        InputKeyDownEnd,
-        InputKeyDownPageUp,
-        InputKeyDownPageDown,
-        InputKeyDownEnter,
-        InputChange,
-        InputBlur,
-        InputFocus,
-        MenuMouseLeave,
-        ItemMouseMove,
-        ItemClick,
-        ToggleButtonClick,
-        FunctionToggleMenu,
-        FunctionOpenMenu,
-        FunctionCloseMenu,
-        FunctionSetHighlightedIndex,
-        FunctionSelectItem,
-        FunctionSetInputValue,
-        FunctionReset: FunctionReset$1,
-        ControlledPropUpdatedSelectedItem
-    });
+        return pair2;
+    };
+    const serialize$1 = (value, {
+        json: json2,
+        lossy
+    } = {}) => {
+        const _2 = [];
+        return serializer(!(json2 || lossy), !!json2, /* @__PURE__ */ new Map(), _2)(value), _2;
+    };
+    const structuredClone$1 = typeof structuredClone === "function" ? (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize$1(any, options)) : structuredClone(any) : (any, options) => deserialize(serialize$1(any, options));
 
-    function getInitialState$1(props) {
-        var initialState2 = getInitialState$2(props);
-        var selectedItem = initialState2.selectedItem;
-        var inputValue = initialState2.inputValue;
-        if (inputValue === "" && selectedItem && props.defaultInputValue === void 0 && props.initialInputValue === void 0 && props.inputValue === void 0) {
-            inputValue = props.itemToString(selectedItem);
+    function defaultFootnoteBackContent(_2, rereferenceIndex) {
+        const result = [{
+            type: "text",
+            value: "\u21A9"
+        }];
+        if (rereferenceIndex > 1) {
+            result.push({
+                type: "element",
+                tagName: "sup",
+                properties: {},
+                children: [{
+                    type: "text",
+                    value: String(rereferenceIndex)
+                }]
+            });
         }
-        return _extends$3({}, initialState2, {
-            inputValue
-        });
-    }
-    ({
-        items: propTypes.exports.array.isRequired,
-        itemToString: propTypes.exports.func,
-        selectedItemChanged: propTypes.exports.func,
-        getA11yStatusMessage: propTypes.exports.func,
-        getA11ySelectionMessage: propTypes.exports.func,
-        highlightedIndex: propTypes.exports.number,
-        defaultHighlightedIndex: propTypes.exports.number,
-        initialHighlightedIndex: propTypes.exports.number,
-        isOpen: propTypes.exports.bool,
-        defaultIsOpen: propTypes.exports.bool,
-        initialIsOpen: propTypes.exports.bool,
-        selectedItem: propTypes.exports.any,
-        initialSelectedItem: propTypes.exports.any,
-        defaultSelectedItem: propTypes.exports.any,
-        inputValue: propTypes.exports.string,
-        defaultInputValue: propTypes.exports.string,
-        initialInputValue: propTypes.exports.string,
-        id: propTypes.exports.string,
-        labelId: propTypes.exports.string,
-        menuId: propTypes.exports.string,
-        getItemId: propTypes.exports.func,
-        inputId: propTypes.exports.string,
-        toggleButtonId: propTypes.exports.string,
-        stateReducer: propTypes.exports.func,
-        onSelectedItemChange: propTypes.exports.func,
-        onHighlightedIndexChange: propTypes.exports.func,
-        onStateChange: propTypes.exports.func,
-        onIsOpenChange: propTypes.exports.func,
-        onInputValueChange: propTypes.exports.func,
-        environment: propTypes.exports.shape({
-            addEventListener: propTypes.exports.func,
-            removeEventListener: propTypes.exports.func,
-            document: propTypes.exports.shape({
-                getElementById: propTypes.exports.func,
-                activeElement: propTypes.exports.any,
-                body: propTypes.exports.any
-            })
-        })
-    });
-
-    function useControlledReducer(reducer2, initialState2, props) {
-        var previousSelectedItemRef = React.useRef();
-        var _useEnhancedReducer = useEnhancedReducer(reducer2, initialState2, props),
-            state = _useEnhancedReducer[0],
-            dispatch2 = _useEnhancedReducer[1];
-        React.useEffect(function() {
-            if (!isControlledProp(props, "selectedItem")) {
-                return;
-            }
-            if (props.selectedItemChanged(previousSelectedItemRef.current, props.selectedItem)) {
-                dispatch2({
-                    type: ControlledPropUpdatedSelectedItem,
-                    inputValue: props.itemToString(props.selectedItem)
-                });
-            }
-            previousSelectedItemRef.current = state.selectedItem === previousSelectedItemRef.current ? props.selectedItem : state.selectedItem;
-        }, [state.selectedItem, props.selectedItem]);
-        return [getState(state, props), dispatch2];
+        return result;
     }
-    var defaultProps$1 = _extends$3({}, defaultProps$3, {
-        selectedItemChanged: function selectedItemChanged(prevItem, item) {
-            return prevItem !== item;
-        },
-        getA11yStatusMessage: getA11yStatusMessage$1
-    });
 
-    function downshiftUseComboboxReducer(state, action) {
-        var _props$items;
-        var type2 = action.type,
-            props = action.props,
-            altKey = action.altKey;
-        var changes;
-        switch (type2) {
-            case ItemClick:
-                changes = {
-                    isOpen: getDefaultValue$1(props, "isOpen"),
-                    highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
-                    selectedItem: props.items[action.index],
-                    inputValue: props.itemToString(props.items[action.index])
-                };
-                break;
-            case InputKeyDownArrowDown:
-                if (state.isOpen) {
-                    changes = {
-                        highlightedIndex: getNextWrappingIndex(1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, true)
-                    };
-                } else {
-                    changes = {
-                        highlightedIndex: altKey && state.selectedItem == null ? -1 : getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),
-                        isOpen: props.items.length >= 0
-                    };
-                }
-                break;
-            case InputKeyDownArrowUp:
-                if (state.isOpen) {
-                    if (altKey) {
-                        changes = getChangesOnSelection(props, state.highlightedIndex);
-                    } else {
-                        changes = {
-                            highlightedIndex: getNextWrappingIndex(-1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, true)
-                        };
-                    }
-                } else {
-                    changes = {
-                        highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),
-                        isOpen: props.items.length >= 0
-                    };
-                }
-                break;
-            case InputKeyDownEnter:
-                changes = getChangesOnSelection(props, state.highlightedIndex);
-                break;
-            case InputKeyDownEscape:
-                changes = _extends$3({
-                    isOpen: false,
-                    highlightedIndex: -1
-                }, !state.isOpen && {
-                    selectedItem: null,
-                    inputValue: ""
-                });
-                break;
-            case InputKeyDownPageUp:
-                changes = {
-                    highlightedIndex: getNextWrappingIndex(-10, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, false)
-                };
-                break;
-            case InputKeyDownPageDown:
-                changes = {
-                    highlightedIndex: getNextWrappingIndex(10, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, false)
-                };
-                break;
-            case InputKeyDownHome:
-                changes = {
-                    highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)
-                };
-                break;
-            case InputKeyDownEnd:
-                changes = {
-                    highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)
-                };
-                break;
-            case InputBlur:
-                changes = _extends$3({
-                    isOpen: false,
-                    highlightedIndex: -1
-                }, state.highlightedIndex >= 0 && ((_props$items = props.items) == null ? void 0 : _props$items.length) && action.selectItem && {
-                    selectedItem: props.items[state.highlightedIndex],
-                    inputValue: props.itemToString(props.items[state.highlightedIndex])
-                });
-                break;
-            case InputChange:
-                changes = {
-                    isOpen: true,
-                    highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
-                    inputValue: action.inputValue
-                };
-                break;
-            case InputFocus:
-                changes = {
-                    isOpen: true,
-                    highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)
-                };
-                break;
-            case FunctionSelectItem:
-                changes = {
-                    selectedItem: action.selectedItem,
-                    inputValue: props.itemToString(action.selectedItem)
-                };
-                break;
-            case ControlledPropUpdatedSelectedItem:
-                changes = {
-                    inputValue: action.inputValue
-                };
-                break;
-            default:
-                return downshiftCommonReducer(state, action, stateChangeTypes$1$1);
-        }
-        return _extends$3({}, state, changes);
+    function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
+        return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
     }
-    var _excluded$1$1 = ["onMouseLeave", "refKey", "ref"],
-        _excluded2$1 = ["item", "index", "refKey", "ref", "onMouseMove", "onMouseDown", "onClick", "onPress", "disabled"],
-        _excluded3 = ["onClick", "onPress", "refKey", "ref"],
-        _excluded4 = ["onKeyDown", "onChange", "onInput", "onFocus", "onBlur", "onChangeText", "refKey", "ref"];
-    useCombobox.stateChangeTypes = stateChangeTypes$1$1;
 
-    function useCombobox(userProps) {
-        if (userProps === void 0) {
-            userProps = {};
-        }
-        var props = _extends$3({}, defaultProps$1, userProps);
-        var initialIsOpen = props.initialIsOpen,
-            defaultIsOpen = props.defaultIsOpen,
-            items = props.items,
-            scrollIntoView2 = props.scrollIntoView,
-            environment = props.environment,
-            getA11yStatusMessage2 = props.getA11yStatusMessage,
-            getA11ySelectionMessage2 = props.getA11ySelectionMessage,
-            itemToString2 = props.itemToString;
-        var initialState2 = getInitialState$1(props);
-        var _useControlledReducer = useControlledReducer(downshiftUseComboboxReducer, initialState2, props),
-            state = _useControlledReducer[0],
-            dispatch2 = _useControlledReducer[1];
-        var isOpen = state.isOpen,
-            highlightedIndex = state.highlightedIndex,
-            selectedItem = state.selectedItem,
-            inputValue = state.inputValue;
-        var menuRef = React.useRef(null);
-        var itemRefs = React.useRef({});
-        var inputRef = React.useRef(null);
-        var toggleButtonRef = React.useRef(null);
-        var isInitialMountRef = React.useRef(true);
-        var elementIds = useElementIds(props);
-        var previousResultCountRef = React.useRef();
-        var latest2 = useLatestRef({
-            state,
-            props
-        });
-        var getItemNodeFromIndex = React.useCallback(function(index2) {
-            return itemRefs.current[elementIds.getItemId(index2)];
-        }, [elementIds]);
-        useA11yMessageSetter(getA11yStatusMessage2, [isOpen, highlightedIndex, inputValue, items], _extends$3({
-            isInitialMount: isInitialMountRef.current,
-            previousResultCount: previousResultCountRef.current,
-            items,
-            environment,
-            itemToString: itemToString2
-        }, state));
-        useA11yMessageSetter(getA11ySelectionMessage2, [selectedItem], _extends$3({
-            isInitialMount: isInitialMountRef.current,
-            previousResultCount: previousResultCountRef.current,
-            items,
-            environment,
-            itemToString: itemToString2
-        }, state));
-        var shouldScrollRef = useScrollIntoView({
-            menuElement: menuRef.current,
-            highlightedIndex,
-            isOpen,
-            itemRefs,
-            scrollIntoView: scrollIntoView2,
-            getItemNodeFromIndex
-        });
-        useControlPropsValidator({
-            isInitialMount: isInitialMountRef.current,
-            props,
-            state
-        });
-        React.useEffect(function() {
-            var focusOnOpen = initialIsOpen || defaultIsOpen || isOpen;
-            if (focusOnOpen && inputRef.current) {
-                inputRef.current.focus();
-            }
-        }, []);
-        React.useEffect(function() {
-            if (isInitialMountRef.current) {
-                return;
-            }
-            previousResultCountRef.current = items.length;
-        });
-        var mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [inputRef, menuRef, toggleButtonRef], environment, function() {
-            dispatch2({
-                type: InputBlur,
-                selectItem: false
-            });
-        });
-        var setGetterPropCallInfo = useGetterPropsCalledChecker();
-        React.useEffect(function() {
-            isInitialMountRef.current = false;
-            return function() {
-                isInitialMountRef.current = true;
-            };
-        }, []);
-        React.useEffect(function() {
-            var _environment$document;
-            if (!isOpen) {
-                itemRefs.current = {};
-            } else if (((_environment$document = environment.document) == null ? void 0 : _environment$document.activeElement) !== inputRef.current) {
-                var _inputRef$current;
-                inputRef == null || (_inputRef$current = inputRef.current) == null ? void 0 : _inputRef$current.focus();
+    function footer(state) {
+        const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
+        const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
+        const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
+        const footnoteLabel = state.options.footnoteLabel || "Footnotes";
+        const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
+        const footnoteLabelProperties = state.options.footnoteLabelProperties || {
+            className: ["sr-only"]
+        };
+        const listItems = [];
+        let referenceIndex = -1;
+        while (++referenceIndex < state.footnoteOrder.length) {
+            const def = state.footnoteById.get(state.footnoteOrder[referenceIndex]);
+            if (!def) {
+                continue;
             }
-        }, [isOpen, environment]);
-        var inputKeyDownHandlers = React.useMemo(function() {
-            return {
-                ArrowDown: function ArrowDown2(event2) {
-                    event2.preventDefault();
-                    dispatch2({
-                        type: InputKeyDownArrowDown,
-                        altKey: event2.altKey,
-                        getItemNodeFromIndex
-                    });
-                },
-                ArrowUp: function ArrowUp2(event2) {
-                    event2.preventDefault();
-                    dispatch2({
-                        type: InputKeyDownArrowUp,
-                        altKey: event2.altKey,
-                        getItemNodeFromIndex
-                    });
-                },
-                Home: function Home(event2) {
-                    if (!latest2.current.state.isOpen) {
-                        return;
-                    }
-                    event2.preventDefault();
-                    dispatch2({
-                        type: InputKeyDownHome,
-                        getItemNodeFromIndex
-                    });
-                },
-                End: function End(event2) {
-                    if (!latest2.current.state.isOpen) {
-                        return;
-                    }
-                    event2.preventDefault();
-                    dispatch2({
-                        type: InputKeyDownEnd,
-                        getItemNodeFromIndex
-                    });
-                },
-                Escape: function Escape2(event2) {
-                    var latestState = latest2.current.state;
-                    if (latestState.isOpen || latestState.inputValue || latestState.selectedItem || latestState.highlightedIndex > -1) {
-                        event2.preventDefault();
-                        dispatch2({
-                            type: InputKeyDownEscape
-                        });
-                    }
-                },
-                Enter: function Enter(event2) {
-                    var latestState = latest2.current.state;
-                    if (!latestState.isOpen || event2.which === 229) {
-                        return;
-                    }
-                    event2.preventDefault();
-                    dispatch2({
-                        type: InputKeyDownEnter,
-                        getItemNodeFromIndex
+            const content2 = state.all(def);
+            const id2 = String(def.identifier).toUpperCase();
+            const safeId = normalizeUri(id2.toLowerCase());
+            let rereferenceIndex = 0;
+            const backReferences = [];
+            const counts = state.footnoteCounts.get(id2);
+            while (counts !== void 0 && ++rereferenceIndex <= counts) {
+                if (backReferences.length > 0) {
+                    backReferences.push({
+                        type: "text",
+                        value: " "
                     });
-                },
-                PageUp: function PageUp(event2) {
-                    if (latest2.current.state.isOpen) {
-                        event2.preventDefault();
-                        dispatch2({
-                            type: InputKeyDownPageUp,
-                            getItemNodeFromIndex
-                        });
-                    }
-                },
-                PageDown: function PageDown(event2) {
-                    if (latest2.current.state.isOpen) {
-                        event2.preventDefault();
-                        dispatch2({
-                            type: InputKeyDownPageDown,
-                            getItemNodeFromIndex
-                        });
-                    }
-                }
-            };
-        }, [dispatch2, latest2, getItemNodeFromIndex]);
-        var getLabelProps = React.useCallback(function(labelProps) {
-            return _extends$3({
-                id: elementIds.labelId,
-                htmlFor: elementIds.inputId
-            }, labelProps);
-        }, [elementIds]);
-        var getMenuProps = React.useCallback(function(_temp, _temp2) {
-            var _extends2;
-            var _ref2 = _temp === void 0 ? {} : _temp,
-                onMouseLeave = _ref2.onMouseLeave,
-                _ref$refKey = _ref2.refKey,
-                refKey = _ref$refKey === void 0 ? "ref" : _ref$refKey,
-                ref2 = _ref2.ref,
-                rest = _objectWithoutPropertiesLoose$4(_ref2, _excluded$1$1);
-            var _ref22 = _temp2 === void 0 ? {} : _temp2;
-            _ref22.suppressRefError;
-            return _extends$3((_extends2 = {}, _extends2[refKey] = handleRefs(ref2, function(menuNode) {
-                menuRef.current = menuNode;
-            }), _extends2.id = elementIds.menuId, _extends2.role = "listbox", _extends2["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : "" + elementIds.labelId, _extends2.onMouseLeave = callAllEventHandlers(onMouseLeave, function() {
-                dispatch2({
-                    type: MenuMouseLeave
-                });
-            }), _extends2), rest);
-        }, [dispatch2, setGetterPropCallInfo, elementIds]);
-        var getItemProps = React.useCallback(function(_temp3) {
-            var _extends3, _ref4;
-            var _ref3 = _temp3 === void 0 ? {} : _temp3,
-                itemProp = _ref3.item,
-                indexProp = _ref3.index,
-                _ref3$refKey = _ref3.refKey,
-                refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey,
-                ref2 = _ref3.ref,
-                onMouseMove = _ref3.onMouseMove,
-                onMouseDown = _ref3.onMouseDown,
-                onClick = _ref3.onClick;
-            _ref3.onPress;
-            var disabled2 = _ref3.disabled,
-                rest = _objectWithoutPropertiesLoose$4(_ref3, _excluded2$1);
-            var _latest$current = latest2.current,
-                latestProps = _latest$current.props,
-                latestState = _latest$current.state;
-            var _getItemAndIndex = getItemAndIndex(itemProp, indexProp, latestProps.items, "Pass either item or index to getItemProps!"),
-                index2 = _getItemAndIndex[1];
-            var onSelectKey = "onClick";
-            var customClickHandler = onClick;
-            var itemHandleMouseMove = function itemHandleMouseMove2() {
-                if (index2 === latestState.highlightedIndex) {
-                    return;
-                }
-                shouldScrollRef.current = false;
-                dispatch2({
-                    type: ItemMouseMove,
-                    index: index2,
-                    disabled: disabled2
-                });
-            };
-            var itemHandleClick = function itemHandleClick2() {
-                dispatch2({
-                    type: ItemClick,
-                    index: index2
-                });
-            };
-            var itemHandleMouseDown = function itemHandleMouseDown2(e3) {
-                return e3.preventDefault();
-            };
-            return _extends$3((_extends3 = {}, _extends3[refKey] = handleRefs(ref2, function(itemNode) {
-                if (itemNode) {
-                    itemRefs.current[elementIds.getItemId(index2)] = itemNode;
                 }
-            }), _extends3.disabled = disabled2, _extends3.role = "option", _extends3["aria-selected"] = "" + (index2 === latestState.highlightedIndex), _extends3.id = elementIds.getItemId(index2), _extends3), !disabled2 && (_ref4 = {}, _ref4[onSelectKey] = callAllEventHandlers(customClickHandler, itemHandleClick), _ref4), {
-                onMouseMove: callAllEventHandlers(onMouseMove, itemHandleMouseMove),
-                onMouseDown: callAllEventHandlers(onMouseDown, itemHandleMouseDown)
-            }, rest);
-        }, [dispatch2, latest2, shouldScrollRef, elementIds]);
-        var getToggleButtonProps = React.useCallback(function(_temp4) {
-            var _extends4;
-            var _ref5 = _temp4 === void 0 ? {} : _temp4,
-                onClick = _ref5.onClick;
-            _ref5.onPress;
-            var _ref5$refKey = _ref5.refKey,
-                refKey = _ref5$refKey === void 0 ? "ref" : _ref5$refKey,
-                ref2 = _ref5.ref,
-                rest = _objectWithoutPropertiesLoose$4(_ref5, _excluded3);
-            var latestState = latest2.current.state;
-            var toggleButtonHandleClick = function toggleButtonHandleClick2() {
-                dispatch2({
-                    type: ToggleButtonClick
-                });
-            };
-            return _extends$3((_extends4 = {}, _extends4[refKey] = handleRefs(ref2, function(toggleButtonNode) {
-                toggleButtonRef.current = toggleButtonNode;
-            }), _extends4["aria-controls"] = elementIds.menuId, _extends4["aria-expanded"] = latestState.isOpen, _extends4.id = elementIds.toggleButtonId, _extends4.tabIndex = -1, _extends4), !rest.disabled && _extends$3({}, {
-                onClick: callAllEventHandlers(onClick, toggleButtonHandleClick)
-            }), rest);
-        }, [dispatch2, latest2, elementIds]);
-        var getInputProps = React.useCallback(function(_temp5, _temp6) {
-            var _extends5;
-            var _ref6 = _temp5 === void 0 ? {} : _temp5,
-                onKeyDown = _ref6.onKeyDown,
-                onChange2 = _ref6.onChange,
-                onInput = _ref6.onInput,
-                onFocus = _ref6.onFocus,
-                onBlur = _ref6.onBlur;
-            _ref6.onChangeText;
-            var _ref6$refKey = _ref6.refKey,
-                refKey = _ref6$refKey === void 0 ? "ref" : _ref6$refKey,
-                ref2 = _ref6.ref,
-                rest = _objectWithoutPropertiesLoose$4(_ref6, _excluded4);
-            var _ref7 = _temp6 === void 0 ? {} : _temp6;
-            _ref7.suppressRefError;
-            var latestState = latest2.current.state;
-            var inputHandleKeyDown = function inputHandleKeyDown2(event2) {
-                var key = normalizeArrowKey(event2);
-                if (key && inputKeyDownHandlers[key]) {
-                    inputKeyDownHandlers[key](event2);
+                let children2 = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
+                if (typeof children2 === "string") {
+                    children2 = {
+                        type: "text",
+                        value: children2
+                    };
                 }
-            };
-            var inputHandleChange = function inputHandleChange2(event2) {
-                dispatch2({
-                    type: InputChange,
-                    inputValue: event2.target.value
+                backReferences.push({
+                    type: "element",
+                    tagName: "a",
+                    properties: {
+                        href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
+                        dataFootnoteBackref: "",
+                        ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
+                        className: ["data-footnote-backref"]
+                    },
+                    children: Array.isArray(children2) ? children2 : [children2]
                 });
-            };
-            var inputHandleBlur = function inputHandleBlur2(event2) {
-                if (latestState.isOpen && !mouseAndTouchTrackersRef.current.isMouseDown) {
-                    var isBlurByTabChange = event2.relatedTarget === null && environment.document.activeElement !== environment.document.body;
-                    dispatch2({
-                        type: InputBlur,
-                        selectItem: !isBlurByTabChange
-                    });
-                }
-            };
-            var inputHandleFocus = function inputHandleFocus2() {
-                if (!latestState.isOpen) {
-                    dispatch2({
-                        type: InputFocus
+            }
+            const tail = content2[content2.length - 1];
+            if (tail && tail.type === "element" && tail.tagName === "p") {
+                const tailTail = tail.children[tail.children.length - 1];
+                if (tailTail && tailTail.type === "text") {
+                    tailTail.value += " ";
+                } else {
+                    tail.children.push({
+                        type: "text",
+                        value: " "
                     });
                 }
-            };
-            var onChangeKey = "onChange";
-            var eventHandlers = {};
-            if (!rest.disabled) {
-                var _eventHandlers;
-                eventHandlers = (_eventHandlers = {}, _eventHandlers[onChangeKey] = callAllEventHandlers(onChange2, onInput, inputHandleChange), _eventHandlers.onKeyDown = callAllEventHandlers(onKeyDown, inputHandleKeyDown), _eventHandlers.onBlur = callAllEventHandlers(onBlur, inputHandleBlur), _eventHandlers.onFocus = callAllEventHandlers(onFocus, inputHandleFocus), _eventHandlers);
+                tail.children.push(...backReferences);
+            } else {
+                content2.push(...backReferences);
             }
-            return _extends$3((_extends5 = {}, _extends5[refKey] = handleRefs(ref2, function(inputNode) {
-                inputRef.current = inputNode;
-            }), _extends5["aria-activedescendant"] = latestState.isOpen && latestState.highlightedIndex > -1 ? elementIds.getItemId(latestState.highlightedIndex) : "", _extends5["aria-autocomplete"] = "list", _extends5["aria-controls"] = elementIds.menuId, _extends5["aria-expanded"] = latestState.isOpen, _extends5["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : "" + elementIds.labelId, _extends5.autoComplete = "off", _extends5.id = elementIds.inputId, _extends5.role = "combobox", _extends5.value = latestState.inputValue, _extends5), eventHandlers, rest);
-        }, [setGetterPropCallInfo, latest2, elementIds, inputKeyDownHandlers, dispatch2, mouseAndTouchTrackersRef, environment]);
-        var toggleMenu = React.useCallback(function() {
-            dispatch2({
-                type: FunctionToggleMenu
-            });
-        }, [dispatch2]);
-        var closeMenu = React.useCallback(function() {
-            dispatch2({
-                type: FunctionCloseMenu
-            });
-        }, [dispatch2]);
-        var openMenu = React.useCallback(function() {
-            dispatch2({
-                type: FunctionOpenMenu
-            });
-        }, [dispatch2]);
-        var setHighlightedIndex = React.useCallback(function(newHighlightedIndex) {
-            dispatch2({
-                type: FunctionSetHighlightedIndex,
-                highlightedIndex: newHighlightedIndex
-            });
-        }, [dispatch2]);
-        var selectItem = React.useCallback(function(newSelectedItem) {
-            dispatch2({
-                type: FunctionSelectItem,
-                selectedItem: newSelectedItem
-            });
-        }, [dispatch2]);
-        var setInputValue = React.useCallback(function(newInputValue) {
-            dispatch2({
-                type: FunctionSetInputValue,
-                inputValue: newInputValue
-            });
-        }, [dispatch2]);
-        var reset2 = React.useCallback(function() {
-            dispatch2({
-                type: FunctionReset$1
-            });
-        }, [dispatch2]);
+            const listItem2 = {
+                type: "element",
+                tagName: "li",
+                properties: {
+                    id: clobberPrefix + "fn-" + safeId
+                },
+                children: state.wrap(content2, true)
+            };
+            state.patch(def, listItem2);
+            listItems.push(listItem2);
+        }
+        if (listItems.length === 0) {
+            return;
+        }
         return {
-            getItemProps,
-            getLabelProps,
-            getMenuProps,
-            getInputProps,
-            getToggleButtonProps,
-            toggleMenu,
-            openMenu,
-            closeMenu,
-            setHighlightedIndex,
-            setInputValue,
-            selectItem,
-            reset: reset2,
-            highlightedIndex,
-            isOpen,
-            selectedItem,
-            inputValue
+            type: "element",
+            tagName: "section",
+            properties: {
+                dataFootnotes: true,
+                className: ["footnotes"]
+            },
+            children: [{
+                type: "element",
+                tagName: footnoteLabelTagName,
+                properties: {
+                    ...structuredClone$1(footnoteLabelProperties),
+                    id: "footnote-label"
+                },
+                children: [{
+                    type: "text",
+                    value: footnoteLabel
+                }]
+            }, {
+                type: "text",
+                value: "\n"
+            }, {
+                type: "element",
+                tagName: "ol",
+                properties: {},
+                children: state.wrap(listItems, true)
+            }, {
+                type: "text",
+                value: "\n"
+            }]
         };
     }
-    var defaultStateValues = {
-        activeIndex: -1,
-        selectedItems: []
+    const convert$1 = function(test2) {
+        if (test2 === null || test2 === void 0) {
+            return ok$1;
+        }
+        if (typeof test2 === "function") {
+            return castFactory$1(test2);
+        }
+        if (typeof test2 === "object") {
+            return Array.isArray(test2) ? anyFactory$1(test2) : propsFactory$1(test2);
+        }
+        if (typeof test2 === "string") {
+            return typeFactory$1(test2);
+        }
+        throw new Error("Expected function, string, or object as test");
     };
 
-    function getInitialValue$2(props, propKey) {
-        return getInitialValue$1(props, propKey, defaultStateValues);
-    }
+    function anyFactory$1(tests) {
+        const checks2 = [];
+        let index2 = -1;
+        while (++index2 < tests.length) {
+            checks2[index2] = convert$1(tests[index2]);
+        }
+        return castFactory$1(any);
 
-    function getDefaultValue(props, propKey) {
-        return getDefaultValue$1(props, propKey, defaultStateValues);
+        function any(...parameters) {
+            let index3 = -1;
+            while (++index3 < checks2.length) {
+                if (checks2[index3].apply(this, parameters))
+                    return true;
+            }
+            return false;
+        }
     }
 
-    function getInitialState(props) {
-        var activeIndex = getInitialValue$2(props, "activeIndex");
-        var selectedItems = getInitialValue$2(props, "selectedItems");
-        return {
-            activeIndex,
-            selectedItems
-        };
+    function propsFactory$1(check) {
+        const checkAsRecord = check;
+        return castFactory$1(all2);
+
+        function all2(node2) {
+            const nodeAsRecord = node2;
+            let key;
+            for (key in check) {
+                if (nodeAsRecord[key] !== checkAsRecord[key])
+                    return false;
+            }
+            return true;
+        }
     }
 
-    function isKeyDownOperationPermitted(event2) {
-        if (event2.shiftKey || event2.metaKey || event2.ctrlKey || event2.altKey) {
-            return false;
+    function typeFactory$1(check) {
+        return castFactory$1(type2);
+
+        function type2(node2) {
+            return node2 && node2.type === check;
         }
-        var element2 = event2.target;
-        if (element2 instanceof HTMLInputElement && element2.value !== "" && (element2.selectionStart !== 0 || element2.selectionEnd !== 0)) {
-            return false;
+    }
+
+    function castFactory$1(testFunction) {
+        return check;
+
+        function check(value, index2, parent) {
+            return Boolean(
+                looksLikeANode(value) && testFunction.call(
+                    this,
+                    value,
+                    typeof index2 === "number" ? index2 : void 0,
+                    parent || void 0
+                )
+            );
         }
+    }
+
+    function ok$1() {
         return true;
     }
 
-    function getA11yRemovalMessage(selectionParameters) {
-        var removedSelectedItem = selectionParameters.removedSelectedItem,
-            itemToStringLocal = selectionParameters.itemToString;
-        return itemToStringLocal(removedSelectedItem) + " has been removed.";
+    function looksLikeANode(value) {
+        return value !== null && typeof value === "object" && "type" in value;
     }
-    ({
-        selectedItems: propTypes.exports.array,
-        initialSelectedItems: propTypes.exports.array,
-        defaultSelectedItems: propTypes.exports.array,
-        itemToString: propTypes.exports.func,
-        getA11yRemovalMessage: propTypes.exports.func,
-        stateReducer: propTypes.exports.func,
-        activeIndex: propTypes.exports.number,
-        initialActiveIndex: propTypes.exports.number,
-        defaultActiveIndex: propTypes.exports.number,
-        onActiveIndexChange: propTypes.exports.func,
-        onSelectedItemsChange: propTypes.exports.func,
-        keyNavigationNext: propTypes.exports.string,
-        keyNavigationPrevious: propTypes.exports.string,
-        environment: propTypes.exports.shape({
-            addEventListener: propTypes.exports.func,
-            removeEventListener: propTypes.exports.func,
-            document: propTypes.exports.shape({
-                getElementById: propTypes.exports.func,
-                activeElement: propTypes.exports.any,
-                body: propTypes.exports.any
-            })
-        })
-    });
-    var defaultProps$4 = {
-        itemToString: defaultProps$3.itemToString,
-        stateReducer: defaultProps$3.stateReducer,
-        environment: defaultProps$3.environment,
-        getA11yRemovalMessage,
-        keyNavigationNext: "ArrowRight",
-        keyNavigationPrevious: "ArrowLeft"
-    };
-    var SelectedItemClick = 0;
-    var SelectedItemKeyDownDelete = 1;
-    var SelectedItemKeyDownBackspace = 2;
-    var SelectedItemKeyDownNavigationNext = 3;
-    var SelectedItemKeyDownNavigationPrevious = 4;
-    var DropdownKeyDownNavigationPrevious = 5;
-    var DropdownKeyDownBackspace = 6;
-    var DropdownClick = 7;
-    var FunctionAddSelectedItem = 8;
-    var FunctionRemoveSelectedItem = 9;
-    var FunctionSetSelectedItems = 10;
-    var FunctionSetActiveIndex = 11;
-    var FunctionReset = 12;
-    var stateChangeTypes$4 = /* @__PURE__ */ Object.freeze({
-        __proto__: null,
-        SelectedItemClick,
-        SelectedItemKeyDownDelete,
-        SelectedItemKeyDownBackspace,
-        SelectedItemKeyDownNavigationNext,
-        SelectedItemKeyDownNavigationPrevious,
-        DropdownKeyDownNavigationPrevious,
-        DropdownKeyDownBackspace,
-        DropdownClick,
-        FunctionAddSelectedItem,
-        FunctionRemoveSelectedItem,
-        FunctionSetSelectedItems,
-        FunctionSetActiveIndex,
-        FunctionReset
-    });
 
-    function downshiftMultipleSelectionReducer(state, action) {
-        var type2 = action.type,
-            index2 = action.index,
-            props = action.props,
-            selectedItem = action.selectedItem;
-        var activeIndex = state.activeIndex,
-            selectedItems = state.selectedItems;
-        var changes;
-        switch (type2) {
-            case SelectedItemClick:
-                changes = {
-                    activeIndex: index2
-                };
-                break;
-            case SelectedItemKeyDownNavigationPrevious:
-                changes = {
-                    activeIndex: activeIndex - 1 < 0 ? 0 : activeIndex - 1
-                };
-                break;
-            case SelectedItemKeyDownNavigationNext:
-                changes = {
-                    activeIndex: activeIndex + 1 >= selectedItems.length ? -1 : activeIndex + 1
-                };
-                break;
-            case SelectedItemKeyDownBackspace:
-            case SelectedItemKeyDownDelete: {
-                if (activeIndex < 0) {
-                    break;
-                }
-                var newActiveIndex = activeIndex;
-                if (selectedItems.length === 1) {
-                    newActiveIndex = -1;
-                } else if (activeIndex === selectedItems.length - 1) {
-                    newActiveIndex = selectedItems.length - 2;
-                }
-                changes = _extends$3({
-                    selectedItems: [].concat(selectedItems.slice(0, activeIndex), selectedItems.slice(activeIndex + 1))
-                }, {
-                    activeIndex: newActiveIndex
+    function color$2(d2) {
+        return d2;
+    }
+    const empty$2 = [];
+    const CONTINUE$1 = true;
+    const EXIT$1 = false;
+    const SKIP$1 = "skip";
+
+    function visitParents$1(tree, test2, visitor, reverse) {
+        let check;
+        if (typeof test2 === "function" && typeof visitor !== "function") {
+            reverse = visitor;
+            visitor = test2;
+        } else {
+            check = test2;
+        }
+        const is2 = convert$1(check);
+        const step2 = reverse ? -1 : 1;
+        factory2(tree, void 0, [])();
+
+        function factory2(node2, index2, parents) {
+            const value = node2 && typeof node2 === "object" ? node2 : {};
+            if (typeof value.type === "string") {
+                const name2 = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
+                Object.defineProperty(visit2, "name", {
+                    value: "node (" + color$2(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
                 });
-                break;
             }
-            case DropdownKeyDownNavigationPrevious:
-                changes = {
-                    activeIndex: selectedItems.length - 1
-                };
-                break;
-            case DropdownKeyDownBackspace:
-                changes = {
-                    selectedItems: selectedItems.slice(0, selectedItems.length - 1)
-                };
-                break;
-            case FunctionAddSelectedItem:
-                changes = {
-                    selectedItems: [].concat(selectedItems, [selectedItem])
-                };
-                break;
-            case DropdownClick:
-                changes = {
-                    activeIndex: -1
-                };
-                break;
-            case FunctionRemoveSelectedItem: {
-                var _newActiveIndex = activeIndex;
-                var selectedItemIndex = selectedItems.indexOf(selectedItem);
-                if (selectedItemIndex < 0) {
-                    break;
+            return visit2;
+
+            function visit2() {
+                let result = empty$2;
+                let subresult;
+                let offset2;
+                let grandparents;
+                if (!test2 || is2(node2, index2, parents[parents.length - 1] || void 0)) {
+                    result = toResult$1(visitor(node2, parents));
+                    if (result[0] === EXIT$1) {
+                        return result;
+                    }
                 }
-                if (selectedItems.length === 1) {
-                    _newActiveIndex = -1;
-                } else if (selectedItemIndex === selectedItems.length - 1) {
-                    _newActiveIndex = selectedItems.length - 2;
+                if ("children" in node2 && node2.children) {
+                    const nodeAsParent = node2;
+                    if (nodeAsParent.children && result[0] !== SKIP$1) {
+                        offset2 = (reverse ? nodeAsParent.children.length : -1) + step2;
+                        grandparents = parents.concat(nodeAsParent);
+                        while (offset2 > -1 && offset2 < nodeAsParent.children.length) {
+                            const child = nodeAsParent.children[offset2];
+                            subresult = factory2(child, offset2, grandparents)();
+                            if (subresult[0] === EXIT$1) {
+                                return subresult;
+                            }
+                            offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step2;
+                        }
+                    }
                 }
-                changes = {
-                    selectedItems: [].concat(selectedItems.slice(0, selectedItemIndex), selectedItems.slice(selectedItemIndex + 1)),
-                    activeIndex: _newActiveIndex
-                };
-                break;
-            }
-            case FunctionSetSelectedItems: {
-                var newSelectedItems = action.selectedItems;
-                changes = {
-                    selectedItems: newSelectedItems
-                };
-                break;
-            }
-            case FunctionSetActiveIndex: {
-                var _newActiveIndex2 = action.activeIndex;
-                changes = {
-                    activeIndex: _newActiveIndex2
-                };
-                break;
+                return result;
             }
-            case FunctionReset:
-                changes = {
-                    activeIndex: getDefaultValue(props, "activeIndex"),
-                    selectedItems: getDefaultValue(props, "selectedItems")
-                };
-                break;
-            default:
-                throw new Error("Reducer called without proper action type.");
         }
-        return _extends$3({}, state, changes);
     }
-    var _excluded$4 = ["refKey", "ref", "onClick", "onKeyDown", "selectedItem", "index"],
-        _excluded2$3 = ["refKey", "ref", "onKeyDown", "onClick", "preventKeyAction"];
-    useMultipleSelection.stateChangeTypes = stateChangeTypes$4;
 
-    function useMultipleSelection(userProps) {
-        if (userProps === void 0) {
-            userProps = {};
+    function toResult$1(value) {
+        if (Array.isArray(value)) {
+            return value;
         }
-        var props = _extends$3({}, defaultProps$4, userProps);
-        var getA11yRemovalMessage2 = props.getA11yRemovalMessage,
-            itemToString2 = props.itemToString,
-            environment = props.environment,
-            keyNavigationNext = props.keyNavigationNext,
-            keyNavigationPrevious = props.keyNavigationPrevious;
-        var _useControlledReducer = useControlledReducer$1(downshiftMultipleSelectionReducer, getInitialState(props), props),
-            state = _useControlledReducer[0],
-            dispatch2 = _useControlledReducer[1];
-        var activeIndex = state.activeIndex,
-            selectedItems = state.selectedItems;
-        var isInitialMountRef = React.useRef(true);
-        var dropdownRef = React.useRef(null);
-        var previousSelectedItemsRef = React.useRef(selectedItems);
-        var selectedItemRefs = React.useRef();
-        selectedItemRefs.current = [];
-        var latest2 = useLatestRef({
-            state,
-            props
-        });
-        React.useEffect(function() {
-            if (isInitialMountRef.current || false) {
-                return;
-            }
-            if (selectedItems.length < previousSelectedItemsRef.current.length) {
-                var removedSelectedItem = previousSelectedItemsRef.current.find(function(item) {
-                    return selectedItems.indexOf(item) < 0;
-                });
-                setStatus(getA11yRemovalMessage2({
-                    itemToString: itemToString2,
-                    resultCount: selectedItems.length,
-                    removedSelectedItem,
-                    activeIndex,
-                    activeSelectedItem: selectedItems[activeIndex]
-                }), environment.document);
-            }
-            previousSelectedItemsRef.current = selectedItems;
-        }, [selectedItems.length]);
-        React.useEffect(function() {
-            if (isInitialMountRef.current) {
-                return;
-            }
-            if (activeIndex === -1 && dropdownRef.current) {
-                dropdownRef.current.focus();
-            } else if (selectedItemRefs.current[activeIndex]) {
-                selectedItemRefs.current[activeIndex].focus();
+        if (typeof value === "number") {
+            return [CONTINUE$1, value];
+        }
+        return value === null || value === void 0 ? empty$2 : [value];
+    }
+
+    function visit$1(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
+        let reverse;
+        let test2;
+        let visitor;
+        if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
+            test2 = void 0;
+            visitor = testOrVisitor;
+            reverse = visitorOrReverse;
+        } else {
+            test2 = testOrVisitor;
+            visitor = visitorOrReverse;
+            reverse = maybeReverse;
+        }
+        visitParents$1(tree, test2, overload, reverse);
+
+        function overload(node2, parents) {
+            const parent = parents[parents.length - 1];
+            const index2 = parent ? parent.children.indexOf(node2) : void 0;
+            return visitor(node2, index2, parent);
+        }
+    }
+    const own$5 = {}.hasOwnProperty;
+    const emptyOptions$1 = {};
+
+    function createState(tree, options) {
+        const settings2 = options || emptyOptions$1;
+        const definitionById = /* @__PURE__ */ new Map();
+        const footnoteById = /* @__PURE__ */ new Map();
+        const footnoteCounts = /* @__PURE__ */ new Map();
+        const handlers2 = {
+            ...handlers$1,
+            ...settings2.handlers
+        };
+        const state = {
+            all: all2,
+            applyData,
+            definitionById,
+            footnoteById,
+            footnoteCounts,
+            footnoteOrder: [],
+            handlers: handlers2,
+            one: one2,
+            options: settings2,
+            patch: patch$2,
+            wrap: wrap$1
+        };
+        visit$1(tree, function(node2) {
+            if (node2.type === "definition" || node2.type === "footnoteDefinition") {
+                const map2 = node2.type === "definition" ? definitionById : footnoteById;
+                const id2 = String(node2.identifier).toUpperCase();
+                if (!map2.has(id2)) {
+                    map2.set(id2, node2);
+                }
             }
-        }, [activeIndex]);
-        useControlPropsValidator({
-            isInitialMount: isInitialMountRef.current,
-            props,
-            state
         });
-        var setGetterPropCallInfo = useGetterPropsCalledChecker();
-        React.useEffect(function() {
-            isInitialMountRef.current = false;
-            return function() {
-                isInitialMountRef.current = true;
-            };
-        }, []);
-        var selectedItemKeyDownHandlers = React.useMemo(function() {
-            var _ref2;
-            return _ref2 = {}, _ref2[keyNavigationPrevious] = function() {
-                dispatch2({
-                    type: SelectedItemKeyDownNavigationPrevious
-                });
-            }, _ref2[keyNavigationNext] = function() {
-                dispatch2({
-                    type: SelectedItemKeyDownNavigationNext
-                });
-            }, _ref2.Delete = function Delete() {
-                dispatch2({
-                    type: SelectedItemKeyDownDelete
-                });
-            }, _ref2.Backspace = function Backspace() {
-                dispatch2({
-                    type: SelectedItemKeyDownBackspace
-                });
-            }, _ref2;
-        }, [dispatch2, keyNavigationNext, keyNavigationPrevious]);
-        var dropdownKeyDownHandlers = React.useMemo(function() {
-            var _ref2;
-            return _ref2 = {}, _ref2[keyNavigationPrevious] = function(event2) {
-                if (isKeyDownOperationPermitted(event2)) {
-                    dispatch2({
-                        type: DropdownKeyDownNavigationPrevious
-                    });
-                }
-            }, _ref2.Backspace = function Backspace(event2) {
-                if (isKeyDownOperationPermitted(event2)) {
-                    dispatch2({
-                        type: DropdownKeyDownBackspace
-                    });
-                }
-            }, _ref2;
-        }, [dispatch2, keyNavigationPrevious]);
-        var getSelectedItemProps = React.useCallback(function(_temp) {
-            var _extends2;
-            var _ref3 = _temp === void 0 ? {} : _temp,
-                _ref3$refKey = _ref3.refKey,
-                refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey,
-                ref2 = _ref3.ref,
-                onClick = _ref3.onClick,
-                onKeyDown = _ref3.onKeyDown,
-                selectedItemProp = _ref3.selectedItem,
-                indexProp = _ref3.index,
-                rest = _objectWithoutPropertiesLoose$4(_ref3, _excluded$4);
-            var latestState = latest2.current.state;
-            var _getItemAndIndex = getItemAndIndex(selectedItemProp, indexProp, latestState.selectedItems, "Pass either item or index to getSelectedItemProps!"),
-                index2 = _getItemAndIndex[1];
-            var isFocusable = index2 > -1 && index2 === latestState.activeIndex;
-            var selectedItemHandleClick = function selectedItemHandleClick2() {
-                dispatch2({
-                    type: SelectedItemClick,
-                    index: index2
-                });
-            };
-            var selectedItemHandleKeyDown = function selectedItemHandleKeyDown2(event2) {
-                var key = normalizeArrowKey(event2);
-                if (key && selectedItemKeyDownHandlers[key]) {
-                    selectedItemKeyDownHandlers[key](event2);
-                }
-            };
-            return _extends$3((_extends2 = {}, _extends2[refKey] = handleRefs(ref2, function(selectedItemNode) {
-                if (selectedItemNode) {
-                    selectedItemRefs.current.push(selectedItemNode);
-                }
-            }), _extends2.tabIndex = isFocusable ? 0 : -1, _extends2.onClick = callAllEventHandlers(onClick, selectedItemHandleClick), _extends2.onKeyDown = callAllEventHandlers(onKeyDown, selectedItemHandleKeyDown), _extends2), rest);
-        }, [dispatch2, latest2, selectedItemKeyDownHandlers]);
-        var getDropdownProps = React.useCallback(function(_temp2, _temp3) {
-            var _extends3;
-            var _ref4 = _temp2 === void 0 ? {} : _temp2,
-                _ref4$refKey = _ref4.refKey,
-                refKey = _ref4$refKey === void 0 ? "ref" : _ref4$refKey,
-                ref2 = _ref4.ref,
-                onKeyDown = _ref4.onKeyDown,
-                onClick = _ref4.onClick,
-                _ref4$preventKeyActio = _ref4.preventKeyAction,
-                preventKeyAction = _ref4$preventKeyActio === void 0 ? false : _ref4$preventKeyActio,
-                rest = _objectWithoutPropertiesLoose$4(_ref4, _excluded2$3);
-            var _ref5 = _temp3 === void 0 ? {} : _temp3;
-            _ref5.suppressRefError;
-            var dropdownHandleKeyDown = function dropdownHandleKeyDown2(event2) {
-                var key = normalizeArrowKey(event2);
-                if (key && dropdownKeyDownHandlers[key]) {
-                    dropdownKeyDownHandlers[key](event2);
+        return state;
+
+        function one2(node2, parent) {
+            const type2 = node2.type;
+            const handle2 = state.handlers[type2];
+            if (own$5.call(state.handlers, type2) && handle2) {
+                return handle2(state, node2, parent);
+            }
+            if (state.options.passThrough && state.options.passThrough.includes(type2)) {
+                if ("children" in node2) {
+                    const {
+                        children: children2,
+                        ...shallow
+                    } = node2;
+                    const result = structuredClone$1(shallow);
+                    result.children = state.all(node2);
+                    return result;
                 }
-            };
-            var dropdownHandleClick = function dropdownHandleClick2() {
-                dispatch2({
-                    type: DropdownClick
-                });
-            };
-            return _extends$3((_extends3 = {}, _extends3[refKey] = handleRefs(ref2, function(dropdownNode) {
-                if (dropdownNode) {
-                    dropdownRef.current = dropdownNode;
+                return structuredClone$1(node2);
+            }
+            const unknown2 = state.options.unknownHandler || defaultUnknownHandler;
+            return unknown2(state, node2, parent);
+        }
+
+        function all2(parent) {
+            const values = [];
+            if ("children" in parent) {
+                const nodes = parent.children;
+                let index2 = -1;
+                while (++index2 < nodes.length) {
+                    const result = state.one(nodes[index2], parent);
+                    if (result) {
+                        if (index2 && nodes[index2 - 1].type === "break") {
+                            if (!Array.isArray(result) && result.type === "text") {
+                                result.value = trimMarkdownSpaceStart(result.value);
+                            }
+                            if (!Array.isArray(result) && result.type === "element") {
+                                const head = result.children[0];
+                                if (head && head.type === "text") {
+                                    head.value = trimMarkdownSpaceStart(head.value);
+                                }
+                            }
+                        }
+                        if (Array.isArray(result)) {
+                            values.push(...result);
+                        } else {
+                            values.push(result);
+                        }
+                    }
                 }
-            }), _extends3), !preventKeyAction && {
-                onKeyDown: callAllEventHandlers(onKeyDown, dropdownHandleKeyDown),
-                onClick: callAllEventHandlers(onClick, dropdownHandleClick)
-            }, rest);
-        }, [dispatch2, dropdownKeyDownHandlers, setGetterPropCallInfo]);
-        var addSelectedItem = React.useCallback(function(selectedItem) {
-            dispatch2({
-                type: FunctionAddSelectedItem,
-                selectedItem
-            });
-        }, [dispatch2]);
-        var removeSelectedItem = React.useCallback(function(selectedItem) {
-            dispatch2({
-                type: FunctionRemoveSelectedItem,
-                selectedItem
-            });
-        }, [dispatch2]);
-        var setSelectedItems = React.useCallback(function(newSelectedItems) {
-            dispatch2({
-                type: FunctionSetSelectedItems,
-                selectedItems: newSelectedItems
-            });
-        }, [dispatch2]);
-        var setActiveIndex = React.useCallback(function(newActiveIndex) {
-            dispatch2({
-                type: FunctionSetActiveIndex,
-                activeIndex: newActiveIndex
-            });
-        }, [dispatch2]);
-        var reset2 = React.useCallback(function() {
-            dispatch2({
-                type: FunctionReset
-            });
-        }, [dispatch2]);
-        return {
-            getSelectedItemProps,
-            getDropdownProps,
-            addSelectedItem,
-            removeSelectedItem,
-            setSelectedItems,
-            setActiveIndex,
-            reset: reset2,
-            selectedItems,
-            activeIndex
-        };
+            }
+            return values;
+        }
     }
-    var fromEntries$1 = function fromEntries2(entries) {
-        return entries.reduce(function(acc, _ref2) {
-            var key = _ref2[0],
-                value = _ref2[1];
-            acc[key] = value;
-            return acc;
-        }, {});
-    };
-    var useIsomorphicLayoutEffect$2 = typeof window !== "undefined" && window.document && window.document.createElement ? React__namespace.useLayoutEffect : React__namespace.useEffect;
 
-    function getBoundingClientRect(element2) {
-        var rect = element2.getBoundingClientRect();
-        return {
-            width: rect.width,
-            height: rect.height,
-            top: rect.top,
-            right: rect.right,
-            bottom: rect.bottom,
-            left: rect.left,
-            x: rect.left,
-            y: rect.top
-        };
+    function patch$2(from, to2) {
+        if (from.position)
+            to2.position = position$3(from);
     }
 
-    function getWindow(node2) {
-        if (node2.toString() !== "[object Window]") {
-            var ownerDocument = node2.ownerDocument;
-            return ownerDocument ? ownerDocument.defaultView : window;
+    function applyData(from, to2) {
+        let result = to2;
+        if (from && from.data) {
+            const hName = from.data.hName;
+            const hChildren = from.data.hChildren;
+            const hProperties = from.data.hProperties;
+            if (typeof hName === "string") {
+                if (result.type === "element") {
+                    result.tagName = hName;
+                } else {
+                    const children2 = "children" in result ? result.children : [result];
+                    result = {
+                        type: "element",
+                        tagName: hName,
+                        properties: {},
+                        children: children2
+                    };
+                }
+            }
+            if (result.type === "element" && hProperties) {
+                Object.assign(result.properties, structuredClone$1(hProperties));
+            }
+            if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
+                result.children = hChildren;
+            }
         }
-        return node2;
+        return result;
     }
 
-    function getWindowScroll(node2) {
-        var win = getWindow(node2);
-        var scrollLeft = win.pageXOffset;
-        var scrollTop = win.pageYOffset;
-        return {
-            scrollLeft,
-            scrollTop
+    function defaultUnknownHandler(state, node2) {
+        const data2 = node2.data || {};
+        const result = "value" in node2 && !(own$5.call(data2, "hProperties") || own$5.call(data2, "hChildren")) ? {
+            type: "text",
+            value: node2.value
+        } : {
+            type: "element",
+            tagName: "div",
+            properties: {},
+            children: state.all(node2)
         };
+        state.patch(node2, result);
+        return state.applyData(node2, result);
     }
 
-    function isElement$1(node2) {
-        var OwnElement = getWindow(node2).Element;
-        return node2 instanceof OwnElement || node2 instanceof Element;
+    function wrap$1(nodes, loose) {
+        const result = [];
+        let index2 = -1;
+        if (loose) {
+            result.push({
+                type: "text",
+                value: "\n"
+            });
+        }
+        while (++index2 < nodes.length) {
+            if (index2)
+                result.push({
+                    type: "text",
+                    value: "\n"
+                });
+            result.push(nodes[index2]);
+        }
+        if (loose && nodes.length > 0) {
+            result.push({
+                type: "text",
+                value: "\n"
+            });
+        }
+        return result;
     }
 
-    function isHTMLElement(node2) {
-        var OwnElement = getWindow(node2).HTMLElement;
-        return node2 instanceof OwnElement || node2 instanceof HTMLElement;
+    function trimMarkdownSpaceStart(value) {
+        let index2 = 0;
+        let code2 = value.charCodeAt(index2);
+        while (code2 === 9 || code2 === 32) {
+            index2++;
+            code2 = value.charCodeAt(index2);
+        }
+        return value.slice(index2);
     }
 
-    function getHTMLElementScroll(element2) {
-        return {
-            scrollLeft: element2.scrollLeft,
-            scrollTop: element2.scrollTop
+    function toHast(tree, options) {
+        const state = createState(tree, options);
+        const node2 = state.one(tree, void 0);
+        const foot = footer(state);
+        const result = Array.isArray(node2) ? {
+            type: "root",
+            children: node2
+        } : node2 || {
+            type: "root",
+            children: []
         };
+        if (foot) {
+            result.children.push({
+                type: "text",
+                value: "\n"
+            }, foot);
+        }
+        return result;
     }
 
-    function getNodeScroll(node2) {
-        if (node2 === getWindow(node2) || !isHTMLElement(node2)) {
-            return getWindowScroll(node2);
-        } else {
-            return getHTMLElementScroll(node2);
+    function remarkRehype(destination, options) {
+        if (destination && "run" in destination) {
+            return async function(tree, file) {
+                const hastTree = toHast(tree, {
+                    file,
+                    ...options
+                });
+                await destination.run(hastTree, file);
+            };
         }
+        return function(tree, file) {
+            return toHast(tree, {
+                file,
+                ...options || destination
+            });
+        };
     }
 
-    function getNodeName(element2) {
-        return element2 ? (element2.nodeName || "").toLowerCase() : null;
+    function bail(error2) {
+        if (error2) {
+            throw error2;
+        }
     }
+    var hasOwn$2 = Object.prototype.hasOwnProperty;
+    var toStr$2 = Object.prototype.toString;
+    var defineProperty$2 = Object.defineProperty;
+    var gOPD$1 = Object.getOwnPropertyDescriptor;
+    var isArray$b = function isArray2(arr) {
+        if (typeof Array.isArray === "function") {
+            return Array.isArray(arr);
+        }
+        return toStr$2.call(arr) === "[object Array]";
+    };
+    var isPlainObject$4 = function isPlainObject2(obj) {
+        if (!obj || toStr$2.call(obj) !== "[object Object]") {
+            return false;
+        }
+        var hasOwnConstructor = hasOwn$2.call(obj, "constructor");
+        var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn$2.call(obj.constructor.prototype, "isPrototypeOf");
+        if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
+            return false;
+        }
+        var key;
+        for (key in obj) {}
+        return typeof key === "undefined" || hasOwn$2.call(obj, key);
+    };
+    var setProperty = function setProperty2(target, options) {
+        if (defineProperty$2 && options.name === "__proto__") {
+            defineProperty$2(target, options.name, {
+                enumerable: true,
+                configurable: true,
+                value: options.newValue,
+                writable: true
+            });
+        } else {
+            target[options.name] = options.newValue;
+        }
+    };
+    var getProperty = function getProperty2(obj, name2) {
+        if (name2 === "__proto__") {
+            if (!hasOwn$2.call(obj, name2)) {
+                return void 0;
+            } else if (gOPD$1) {
+                return gOPD$1(obj, name2).value;
+            }
+        }
+        return obj[name2];
+    };
+    var extend$3 = function extend2() {
+        var options, name2, src, copy2, copyIsArray, clone2;
+        var target = arguments[0];
+        var i2 = 1;
+        var length = arguments.length;
+        var deep = false;
+        if (typeof target === "boolean") {
+            deep = target;
+            target = arguments[1] || {};
+            i2 = 2;
+        }
+        if (target == null || typeof target !== "object" && typeof target !== "function") {
+            target = {};
+        }
+        for (; i2 < length; ++i2) {
+            options = arguments[i2];
+            if (options != null) {
+                for (name2 in options) {
+                    src = getProperty(target, name2);
+                    copy2 = getProperty(options, name2);
+                    if (target !== copy2) {
+                        if (deep && copy2 && (isPlainObject$4(copy2) || (copyIsArray = isArray$b(copy2)))) {
+                            if (copyIsArray) {
+                                copyIsArray = false;
+                                clone2 = src && isArray$b(src) ? src : [];
+                            } else {
+                                clone2 = src && isPlainObject$4(src) ? src : {};
+                            }
+                            setProperty(target, {
+                                name: name2,
+                                newValue: extend2(deep, clone2, copy2)
+                            });
+                        } else if (typeof copy2 !== "undefined") {
+                            setProperty(target, {
+                                name: name2,
+                                newValue: copy2
+                            });
+                        }
+                    }
+                }
+            }
+        }
+        return target;
+    };
 
-    function getDocumentElement(element2) {
-        return (isElement$1(element2) ? element2.ownerDocument : element2.document).documentElement;
+    function isPlainObject$3(value) {
+        if (typeof value !== "object" || value === null) {
+            return false;
+        }
+        const prototype = Object.getPrototypeOf(value);
+        return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
     }
 
-    function getWindowScrollBarX(element2) {
-        return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
-    }
+    function trough() {
+        const fns = [];
+        const pipeline = {
+            run,
+            use
+        };
+        return pipeline;
 
-    function getComputedStyle$1(element2) {
-        return getWindow(element2).getComputedStyle(element2);
-    }
+        function run(...values) {
+            let middlewareIndex = -1;
+            const callback = values.pop();
+            if (typeof callback !== "function") {
+                throw new TypeError("Expected function as last argument, not " + callback);
+            }
+            next2(null, ...values);
 
-    function isScrollParent(element2) {
-        var _getComputedStyle = getComputedStyle$1(element2),
-            overflow = _getComputedStyle.overflow,
-            overflowX = _getComputedStyle.overflowX,
-            overflowY = _getComputedStyle.overflowY;
-        return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
-    }
+            function next2(error2, ...output2) {
+                const fn2 = fns[++middlewareIndex];
+                let index2 = -1;
+                if (error2) {
+                    callback(error2);
+                    return;
+                }
+                while (++index2 < values.length) {
+                    if (output2[index2] === null || output2[index2] === void 0) {
+                        output2[index2] = values[index2];
+                    }
+                }
+                values = output2;
+                if (fn2) {
+                    wrap(fn2, next2)(...output2);
+                } else {
+                    callback(null, ...output2);
+                }
+            }
+        }
 
-    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
-        if (isFixed === void 0) {
-            isFixed = false;
+        function use(middelware) {
+            if (typeof middelware !== "function") {
+                throw new TypeError(
+                    "Expected `middelware` to be a function, not " + middelware
+                );
+            }
+            fns.push(middelware);
+            return pipeline;
         }
-        var documentElement = getDocumentElement(offsetParent);
-        var rect = getBoundingClientRect(elementOrVirtualElement);
-        var scroll = {
-            scrollLeft: 0,
-            scrollTop: 0
-        };
-        var offsets = {
-            x: 0,
-            y: 0
-        };
-        if (!isFixed) {
-            if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
-                scroll = getNodeScroll(offsetParent);
+    }
+
+    function wrap(middleware, callback) {
+        let called;
+        return wrapped;
+
+        function wrapped(...parameters) {
+            const fnExpectsCallback = middleware.length > parameters.length;
+            let result;
+            if (fnExpectsCallback) {
+                parameters.push(done);
             }
-            if (isHTMLElement(offsetParent)) {
-                offsets = getBoundingClientRect(offsetParent);
-                offsets.x += offsetParent.clientLeft;
-                offsets.y += offsetParent.clientTop;
-            } else if (documentElement) {
-                offsets.x = getWindowScrollBarX(documentElement);
+            try {
+                result = middleware.apply(this, parameters);
+            } catch (error2) {
+                const exception = error2;
+                if (fnExpectsCallback && called) {
+                    throw exception;
+                }
+                return done(exception);
+            }
+            if (!fnExpectsCallback) {
+                if (result instanceof Promise) {
+                    result.then(then, done);
+                } else if (result instanceof Error) {
+                    done(result);
+                } else {
+                    then(result);
+                }
             }
         }
-        return {
-            x: rect.left + scroll.scrollLeft - offsets.x,
-            y: rect.top + scroll.scrollTop - offsets.y,
-            width: rect.width,
-            height: rect.height
-        };
-    }
 
-    function getLayoutRect(element2) {
-        return {
-            x: element2.offsetLeft,
-            y: element2.offsetTop,
-            width: element2.offsetWidth,
-            height: element2.offsetHeight
-        };
-    }
+        function done(error2, ...output2) {
+            if (!called) {
+                called = true;
+                callback(error2, ...output2);
+            }
+        }
 
-    function getParentNode(element2) {
-        if (getNodeName(element2) === "html") {
-            return element2;
+        function then(value) {
+            done(null, value);
         }
-        return element2.assignedSlot || element2.parentNode || element2.host || getDocumentElement(element2);
     }
+    const path$2 = {
+        basename,
+        dirname,
+        extname,
+        join,
+        sep: "/"
+    };
 
-    function getScrollParent(node2) {
-        if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
-            return node2.ownerDocument.body;
+    function basename(path2, ext) {
+        if (ext !== void 0 && typeof ext !== "string") {
+            throw new TypeError('"ext" argument must be a string');
         }
-        if (isHTMLElement(node2) && isScrollParent(node2)) {
-            return node2;
+        assertPath$2(path2);
+        let start2 = 0;
+        let end2 = -1;
+        let index2 = path2.length;
+        let seenNonSlash;
+        if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
+            while (index2--) {
+                if (path2.codePointAt(index2) === 47) {
+                    if (seenNonSlash) {
+                        start2 = index2 + 1;
+                        break;
+                    }
+                } else if (end2 < 0) {
+                    seenNonSlash = true;
+                    end2 = index2 + 1;
+                }
+            }
+            return end2 < 0 ? "" : path2.slice(start2, end2);
         }
-        return getScrollParent(getParentNode(node2));
+        if (ext === path2) {
+            return "";
+        }
+        let firstNonSlashEnd = -1;
+        let extIndex = ext.length - 1;
+        while (index2--) {
+            if (path2.codePointAt(index2) === 47) {
+                if (seenNonSlash) {
+                    start2 = index2 + 1;
+                    break;
+                }
+            } else {
+                if (firstNonSlashEnd < 0) {
+                    seenNonSlash = true;
+                    firstNonSlashEnd = index2 + 1;
+                }
+                if (extIndex > -1) {
+                    if (path2.codePointAt(index2) === ext.codePointAt(extIndex--)) {
+                        if (extIndex < 0) {
+                            end2 = index2;
+                        }
+                    } else {
+                        extIndex = -1;
+                        end2 = firstNonSlashEnd;
+                    }
+                }
+            }
+        }
+        if (start2 === end2) {
+            end2 = firstNonSlashEnd;
+        } else if (end2 < 0) {
+            end2 = path2.length;
+        }
+        return path2.slice(start2, end2);
     }
 
-    function listScrollParents(element2, list2) {
-        if (list2 === void 0) {
-            list2 = [];
+    function dirname(path2) {
+        assertPath$2(path2);
+        if (path2.length === 0) {
+            return ".";
         }
-        var scrollParent = getScrollParent(element2);
-        var isBody = getNodeName(scrollParent) === "body";
-        var win = getWindow(scrollParent);
-        var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
-        var updatedList = list2.concat(target);
-        return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
+        let end2 = -1;
+        let index2 = path2.length;
+        let unmatchedSlash;
+        while (--index2) {
+            if (path2.codePointAt(index2) === 47) {
+                if (unmatchedSlash) {
+                    end2 = index2;
+                    break;
+                }
+            } else if (!unmatchedSlash) {
+                unmatchedSlash = true;
+            }
+        }
+        return end2 < 0 ? path2.codePointAt(0) === 47 ? "/" : "." : end2 === 1 && path2.codePointAt(0) === 47 ? "//" : path2.slice(0, end2);
     }
 
-    function isTableElement(element2) {
-        return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
+    function extname(path2) {
+        assertPath$2(path2);
+        let index2 = path2.length;
+        let end2 = -1;
+        let startPart = 0;
+        let startDot = -1;
+        let preDotState = 0;
+        let unmatchedSlash;
+        while (index2--) {
+            const code2 = path2.codePointAt(index2);
+            if (code2 === 47) {
+                if (unmatchedSlash) {
+                    startPart = index2 + 1;
+                    break;
+                }
+                continue;
+            }
+            if (end2 < 0) {
+                unmatchedSlash = true;
+                end2 = index2 + 1;
+            }
+            if (code2 === 46) {
+                if (startDot < 0) {
+                    startDot = index2;
+                } else if (preDotState !== 1) {
+                    preDotState = 1;
+                }
+            } else if (startDot > -1) {
+                preDotState = -1;
+            }
+        }
+        if (startDot < 0 || end2 < 0 || preDotState === 0 || preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1) {
+            return "";
+        }
+        return path2.slice(startDot, end2);
     }
 
-    function getTrueOffsetParent(element2) {
-        if (!isHTMLElement(element2) || getComputedStyle$1(element2).position === "fixed") {
-            return null;
+    function join(...segments) {
+        let index2 = -1;
+        let joined;
+        while (++index2 < segments.length) {
+            assertPath$2(segments[index2]);
+            if (segments[index2]) {
+                joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
+            }
         }
-        return element2.offsetParent;
+        return joined === void 0 ? "." : normalize$1(joined);
     }
 
-    function getOffsetParent(element2) {
-        var window2 = getWindow(element2);
-        var offsetParent = getTrueOffsetParent(element2);
-        while (offsetParent && isTableElement(offsetParent)) {
-            offsetParent = getTrueOffsetParent(offsetParent);
+    function normalize$1(path2) {
+        assertPath$2(path2);
+        const absolute = path2.codePointAt(0) === 47;
+        let value = normalizeString(path2, !absolute);
+        if (value.length === 0 && !absolute) {
+            value = ".";
         }
-        if (offsetParent && getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static") {
-            return window2;
+        if (value.length > 0 && path2.codePointAt(path2.length - 1) === 47) {
+            value += "/";
         }
-        return offsetParent || window2;
+        return absolute ? "/" + value : value;
     }
-    var top$1 = "top";
-    var bottom = "bottom";
-    var right = "right";
-    var left = "left";
-    var auto = "auto";
-    var basePlacements = [top$1, bottom, right, left];
-    var start$1 = "start";
-    var end = "end";
-    var clippingParents = "clippingParents";
-    var viewport = "viewport";
-    var popper = "popper";
-    var reference = "reference";
-    var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
-        return acc.concat([placement + "-" + start$1, placement + "-" + end]);
-    }, []);
-    var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
-        return acc.concat([placement, placement + "-" + start$1, placement + "-" + end]);
-    }, []);
-    var beforeRead = "beforeRead";
-    var read = "read";
-    var afterRead = "afterRead";
-    var beforeMain = "beforeMain";
-    var main = "main";
-    var afterMain = "afterMain";
-    var beforeWrite = "beforeWrite";
-    var write = "write";
-    var afterWrite = "afterWrite";
-    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
-
-    function order$1(modifiers2) {
-        var map2 = /* @__PURE__ */ new Map();
-        var visited = /* @__PURE__ */ new Set();
-        var result = [];
-        modifiers2.forEach(function(modifier) {
-            map2.set(modifier.name, modifier);
-        });
 
-        function sort(modifier) {
-            visited.add(modifier.name);
-            var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
-            requires.forEach(function(dep) {
-                if (!visited.has(dep)) {
-                    var depModifier = map2.get(dep);
-                    if (depModifier) {
-                        sort(depModifier);
+    function normalizeString(path2, allowAboveRoot) {
+        let result = "";
+        let lastSegmentLength = 0;
+        let lastSlash = -1;
+        let dots = 0;
+        let index2 = -1;
+        let code2;
+        let lastSlashIndex;
+        while (++index2 <= path2.length) {
+            if (index2 < path2.length) {
+                code2 = path2.codePointAt(index2);
+            } else if (code2 === 47) {
+                break;
+            } else {
+                code2 = 47;
+            }
+            if (code2 === 47) {
+                if (lastSlash === index2 - 1 || dots === 1)
+                ;
+                else if (lastSlash !== index2 - 1 && dots === 2) {
+                    if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
+                        if (result.length > 2) {
+                            lastSlashIndex = result.lastIndexOf("/");
+                            if (lastSlashIndex !== result.length - 1) {
+                                if (lastSlashIndex < 0) {
+                                    result = "";
+                                    lastSegmentLength = 0;
+                                } else {
+                                    result = result.slice(0, lastSlashIndex);
+                                    lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
+                                }
+                                lastSlash = index2;
+                                dots = 0;
+                                continue;
+                            }
+                        } else if (result.length > 0) {
+                            result = "";
+                            lastSegmentLength = 0;
+                            lastSlash = index2;
+                            dots = 0;
+                            continue;
+                        }
+                    }
+                    if (allowAboveRoot) {
+                        result = result.length > 0 ? result + "/.." : "..";
+                        lastSegmentLength = 2;
+                    }
+                } else {
+                    if (result.length > 0) {
+                        result += "/" + path2.slice(lastSlash + 1, index2);
+                    } else {
+                        result = path2.slice(lastSlash + 1, index2);
                     }
+                    lastSegmentLength = index2 - lastSlash - 1;
                 }
-            });
-            result.push(modifier);
-        }
-        modifiers2.forEach(function(modifier) {
-            if (!visited.has(modifier.name)) {
-                sort(modifier);
+                lastSlash = index2;
+                dots = 0;
+            } else if (code2 === 46 && dots > -1) {
+                dots++;
+            } else {
+                dots = -1;
             }
-        });
+        }
         return result;
     }
 
-    function orderModifiers(modifiers2) {
-        var orderedModifiers = order$1(modifiers2);
-        return modifierPhases.reduce(function(acc, phase) {
-            return acc.concat(orderedModifiers.filter(function(modifier) {
-                return modifier.phase === phase;
-            }));
-        }, []);
-    }
-
-    function debounce$1(fn2) {
-        var pending;
-        return function() {
-            if (!pending) {
-                pending = new Promise(function(resolve2) {
-                    Promise.resolve().then(function() {
-                        pending = void 0;
-                        resolve2(fn2());
-                    });
-                });
-            }
-            return pending;
-        };
+    function assertPath$2(path2) {
+        if (typeof path2 !== "string") {
+            throw new TypeError(
+                "Path must be a string. Received " + JSON.stringify(path2)
+            );
+        }
     }
+    const proc = {
+        cwd
+    };
 
-    function getBasePlacement(placement) {
-        return placement.split("-")[0];
+    function cwd() {
+        return "/";
     }
 
-    function mergeByName(modifiers2) {
-        var merged = modifiers2.reduce(function(merged2, current2) {
-            var existing = merged2[current2.name];
-            merged2[current2.name] = existing ? Object.assign({}, existing, {}, current2, {
-                options: Object.assign({}, existing.options, {}, current2.options),
-                data: Object.assign({}, existing.data, {}, current2.data)
-            }) : current2;
-            return merged2;
-        }, {});
-        return Object.keys(merged).map(function(key) {
-            return merged[key];
-        });
+    function isUrl(fileUrlOrPath) {
+        return Boolean(
+            fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && fileUrlOrPath.auth === void 0
+        );
     }
-    var DEFAULT_OPTIONS$1 = {
-        placement: "bottom",
-        modifiers: [],
-        strategy: "absolute"
-    };
 
-    function areValidElements() {
-        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-            args[_key] = arguments[_key];
+    function urlToPath(path2) {
+        if (typeof path2 === "string") {
+            path2 = new URL(path2);
+        } else if (!isUrl(path2)) {
+            const error2 = new TypeError(
+                'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
+            );
+            error2.code = "ERR_INVALID_ARG_TYPE";
+            throw error2;
         }
-        return !args.some(function(element2) {
-            return !(element2 && typeof element2.getBoundingClientRect === "function");
-        });
+        if (path2.protocol !== "file:") {
+            const error2 = new TypeError("The URL must be of scheme file");
+            error2.code = "ERR_INVALID_URL_SCHEME";
+            throw error2;
+        }
+        return getPathFromURLPosix(path2);
     }
 
-    function popperGenerator(generatorOptions) {
-        if (generatorOptions === void 0) {
-            generatorOptions = {};
+    function getPathFromURLPosix(url2) {
+        if (url2.hostname !== "") {
+            const error2 = new TypeError(
+                'File URL host must be "localhost" or empty on darwin'
+            );
+            error2.code = "ERR_INVALID_FILE_URL_HOST";
+            throw error2;
         }
-        var _generatorOptions = generatorOptions,
-            _generatorOptions$def = _generatorOptions.defaultModifiers,
-            defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
-            _generatorOptions$def2 = _generatorOptions.defaultOptions,
-            defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS$1 : _generatorOptions$def2;
-        return function createPopper2(reference2, popper2, options) {
-            if (options === void 0) {
-                options = defaultOptions2;
+        const pathname = url2.pathname;
+        let index2 = -1;
+        while (++index2 < pathname.length) {
+            if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
+                const third = pathname.codePointAt(index2 + 2);
+                if (third === 70 || third === 102) {
+                    const error2 = new TypeError(
+                        "File URL path must not include encoded / characters"
+                    );
+                    error2.code = "ERR_INVALID_FILE_URL_PATH";
+                    throw error2;
+                }
             }
-            var state = {
-                placement: "bottom",
-                orderedModifiers: [],
-                options: Object.assign({}, DEFAULT_OPTIONS$1, {}, defaultOptions2),
-                modifiersData: {},
-                elements: {
-                    reference: reference2,
-                    popper: popper2
-                },
-                attributes: {},
-                styles: {}
-            };
-            var effectCleanupFns = [];
-            var isDestroyed = false;
-            var instance2 = {
-                state,
-                setOptions: function setOptions2(options2) {
-                    cleanupModifierEffects();
-                    state.options = Object.assign({}, defaultOptions2, {}, state.options, {}, options2);
-                    state.scrollParents = {
-                        reference: isElement$1(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
-                        popper: listScrollParents(popper2)
-                    };
-                    var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
-                    state.orderedModifiers = orderedModifiers.filter(function(m2) {
-                        return m2.enabled;
-                    });
-                    runModifierEffects();
-                    return instance2.update();
-                },
-                forceUpdate: function forceUpdate() {
-                    if (isDestroyed) {
-                        return;
-                    }
-                    var _state$elements = state.elements,
-                        reference3 = _state$elements.reference,
-                        popper3 = _state$elements.popper;
-                    if (!areValidElements(reference3, popper3)) {
-                        return;
-                    }
-                    state.rects = {
-                        reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
-                        popper: getLayoutRect(popper3)
-                    };
-                    state.reset = false;
-                    state.placement = state.options.placement;
-                    state.orderedModifiers.forEach(function(modifier) {
-                        return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
-                    });
-                    for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
-                        if (state.reset === true) {
-                            state.reset = false;
-                            index2 = -1;
-                            continue;
-                        }
-                        var _state$orderedModifie = state.orderedModifiers[index2],
-                            fn2 = _state$orderedModifie.fn,
-                            _state$orderedModifie2 = _state$orderedModifie.options,
-                            _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
-                            name2 = _state$orderedModifie.name;
-                        if (typeof fn2 === "function") {
-                            state = fn2({
-                                state,
-                                options: _options,
-                                name: name2,
-                                instance: instance2
-                            }) || state;
-                        }
-                    }
-                },
-                update: debounce$1(function() {
-                    return new Promise(function(resolve2) {
-                        instance2.forceUpdate();
-                        resolve2(state);
-                    });
-                }),
-                destroy: function destroy() {
-                    cleanupModifierEffects();
-                    isDestroyed = true;
+        }
+        return decodeURIComponent(pathname);
+    }
+    const order$2 = [
+        "history",
+        "path",
+        "basename",
+        "stem",
+        "extname",
+        "dirname"
+    ];
+    class VFile {
+        constructor(value) {
+            let options;
+            if (!value) {
+                options = {};
+            } else if (isUrl(value)) {
+                options = {
+                    path: value
+                };
+            } else if (typeof value === "string" || isUint8Array$1(value)) {
+                options = {
+                    value
+                };
+            } else {
+                options = value;
+            }
+            this.cwd = proc.cwd();
+            this.data = {};
+            this.history = [];
+            this.messages = [];
+            this.value;
+            this.map;
+            this.result;
+            this.stored;
+            let index2 = -1;
+            while (++index2 < order$2.length) {
+                const prop2 = order$2[index2];
+                if (prop2 in options && options[prop2] !== void 0 && options[prop2] !== null) {
+                    this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
                 }
-            };
-            if (!areValidElements(reference2, popper2)) {
-                return instance2;
             }
-            instance2.setOptions(options).then(function(state2) {
-                if (!isDestroyed && options.onFirstUpdate) {
-                    options.onFirstUpdate(state2);
+            let prop;
+            for (prop in options) {
+                if (!order$2.includes(prop)) {
+                    this[prop] = options[prop];
                 }
-            });
-
-            function runModifierEffects() {
-                state.orderedModifiers.forEach(function(_ref3) {
-                    var name2 = _ref3.name,
-                        _ref3$options = _ref3.options,
-                        options2 = _ref3$options === void 0 ? {} : _ref3$options,
-                        effect2 = _ref3.effect;
-                    if (typeof effect2 === "function") {
-                        var cleanupFn = effect2({
-                            state,
-                            name: name2,
-                            instance: instance2,
-                            options: options2
-                        });
-                        var noopFn = function noopFn2() {};
-                        effectCleanupFns.push(cleanupFn || noopFn);
-                    }
-                });
             }
-
-            function cleanupModifierEffects() {
-                effectCleanupFns.forEach(function(fn2) {
-                    return fn2();
-                });
-                effectCleanupFns = [];
+        }
+        get basename() {
+            return typeof this.path === "string" ? path$2.basename(this.path) : void 0;
+        }
+        set basename(basename2) {
+            assertNonEmpty(basename2, "basename");
+            assertPart(basename2, "basename");
+            this.path = path$2.join(this.dirname || "", basename2);
+        }
+        get dirname() {
+            return typeof this.path === "string" ? path$2.dirname(this.path) : void 0;
+        }
+        set dirname(dirname2) {
+            assertPath$1(this.basename, "dirname");
+            this.path = path$2.join(dirname2 || "", this.basename);
+        }
+        get extname() {
+            return typeof this.path === "string" ? path$2.extname(this.path) : void 0;
+        }
+        set extname(extname2) {
+            assertPart(extname2, "extname");
+            assertPath$1(this.dirname, "extname");
+            if (extname2) {
+                if (extname2.codePointAt(0) !== 46) {
+                    throw new Error("`extname` must start with `.`");
+                }
+                if (extname2.includes(".", 1)) {
+                    throw new Error("`extname` cannot contain multiple dots");
+                }
             }
-            return instance2;
-        };
-    }
-    var passive = {
-        passive: true
-    };
-
-    function effect$2(_ref2) {
-        var state = _ref2.state,
-            instance2 = _ref2.instance,
-            options = _ref2.options;
-        var _options$scroll = options.scroll,
-            scroll = _options$scroll === void 0 ? true : _options$scroll,
-            _options$resize = options.resize,
-            resize = _options$resize === void 0 ? true : _options$resize;
-        var window2 = getWindow(state.elements.popper);
-        var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
-        if (scroll) {
-            scrollParents.forEach(function(scrollParent) {
-                scrollParent.addEventListener("scroll", instance2.update, passive);
-            });
+            this.path = path$2.join(this.dirname, this.stem + (extname2 || ""));
         }
-        if (resize) {
-            window2.addEventListener("resize", instance2.update, passive);
+        get path() {
+            return this.history[this.history.length - 1];
         }
-        return function() {
-            if (scroll) {
-                scrollParents.forEach(function(scrollParent) {
-                    scrollParent.removeEventListener("scroll", instance2.update, passive);
-                });
+        set path(path2) {
+            if (isUrl(path2)) {
+                path2 = urlToPath(path2);
             }
-            if (resize) {
-                window2.removeEventListener("resize", instance2.update, passive);
+            assertNonEmpty(path2, "path");
+            if (this.path !== path2) {
+                this.history.push(path2);
             }
-        };
+        }
+        get stem() {
+            return typeof this.path === "string" ? path$2.basename(this.path, this.extname) : void 0;
+        }
+        set stem(stem) {
+            assertNonEmpty(stem, "stem");
+            assertPart(stem, "stem");
+            this.path = path$2.join(this.dirname || "", stem + (this.extname || ""));
+        }
+        fail(causeOrReason, optionsOrParentOrPlace, origin) {
+            const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
+            message.fatal = true;
+            throw message;
+        }
+        info(causeOrReason, optionsOrParentOrPlace, origin) {
+            const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
+            message.fatal = void 0;
+            return message;
+        }
+        message(causeOrReason, optionsOrParentOrPlace, origin) {
+            const message = new VFileMessage(
+                causeOrReason,
+                optionsOrParentOrPlace,
+                origin
+            );
+            if (this.path) {
+                message.name = this.path + ":" + message.name;
+                message.file = this.path;
+            }
+            message.fatal = false;
+            this.messages.push(message);
+            return message;
+        }
+        toString(encoding) {
+            if (this.value === void 0) {
+                return "";
+            }
+            if (typeof this.value === "string") {
+                return this.value;
+            }
+            const decoder = new TextDecoder(encoding || void 0);
+            return decoder.decode(this.value);
+        }
     }
-    const eventListeners = {
-        name: "eventListeners",
-        enabled: true,
-        phase: "write",
-        fn: function fn2() {},
-        effect: effect$2,
-        data: {}
-    };
 
-    function getVariation(placement) {
-        return placement.split("-")[1];
+    function assertPart(part, name2) {
+        if (part && part.includes(path$2.sep)) {
+            throw new Error(
+                "`" + name2 + "` cannot be a path: did not expect `" + path$2.sep + "`"
+            );
+        }
     }
 
-    function getMainAxisFromPlacement(placement) {
-        return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
+    function assertNonEmpty(part, name2) {
+        if (!part) {
+            throw new Error("`" + name2 + "` cannot be empty");
+        }
     }
 
-    function computeOffsets(_ref2) {
-        var reference2 = _ref2.reference,
-            element2 = _ref2.element,
-            placement = _ref2.placement;
-        var basePlacement = placement ? getBasePlacement(placement) : null;
-        var variation = placement ? getVariation(placement) : null;
-        var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
-        var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
-        var offsets;
-        switch (basePlacement) {
-            case top$1:
-                offsets = {
-                    x: commonX,
-                    y: reference2.y - element2.height
-                };
-                break;
-            case bottom:
-                offsets = {
-                    x: commonX,
-                    y: reference2.y + reference2.height
-                };
-                break;
-            case right:
-                offsets = {
-                    x: reference2.x + reference2.width,
-                    y: commonY
-                };
-                break;
-            case left:
-                offsets = {
-                    x: reference2.x - element2.width,
-                    y: commonY
-                };
-                break;
-            default:
-                offsets = {
-                    x: reference2.x,
-                    y: reference2.y
-                };
-        }
-        var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
-        if (mainAxis != null) {
-            var len = mainAxis === "y" ? "height" : "width";
-            switch (variation) {
-                case start$1:
-                    offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference2[len] / 2 - element2[len] / 2);
-                    break;
-                case end:
-                    offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference2[len] / 2 - element2[len] / 2);
-                    break;
-            }
+    function assertPath$1(path2, name2) {
+        if (!path2) {
+            throw new Error("Setting `" + name2 + "` requires `path` to be set too");
         }
-        return offsets;
     }
 
-    function popperOffsets(_ref2) {
-        var state = _ref2.state,
-            name2 = _ref2.name;
-        state.modifiersData[name2] = computeOffsets({
-            reference: state.rects.reference,
-            element: state.rects.popper,
-            strategy: "absolute",
-            placement: state.placement
-        });
+    function isUint8Array$1(value) {
+        return Boolean(
+            value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
+        );
     }
-    const popperOffsets$1 = {
-        name: "popperOffsets",
-        enabled: true,
-        phase: "read",
-        fn: popperOffsets,
-        data: {}
-    };
-    var unsetSides = {
-        top: "auto",
-        right: "auto",
-        bottom: "auto",
-        left: "auto"
+    const CallableInstance = function(property) {
+        const self2 = this;
+        const constr = self2.constructor;
+        const proto2 = constr.prototype;
+        const func = proto2[property];
+        const apply = function() {
+            return func.apply(apply, arguments);
+        };
+        Object.setPrototypeOf(apply, proto2);
+        const names = Object.getOwnPropertyNames(func);
+        for (const p2 of names) {
+            const descriptor = Object.getOwnPropertyDescriptor(func, p2);
+            if (descriptor)
+                Object.defineProperty(apply, p2, descriptor);
+        }
+        return apply;
     };
+    const own$4 = {}.hasOwnProperty;
+    class Processor extends CallableInstance {
+        constructor() {
+            super("copy");
+            this.Compiler = void 0;
+            this.Parser = void 0;
+            this.attachers = [];
+            this.compiler = void 0;
+            this.freezeIndex = -1;
+            this.frozen = void 0;
+            this.namespace = {};
+            this.parser = void 0;
+            this.transformers = trough();
+        }
+        copy() {
+            const destination = new Processor();
+            let index2 = -1;
+            while (++index2 < this.attachers.length) {
+                const attacher = this.attachers[index2];
+                destination.use(...attacher);
+            }
+            destination.data(extend$3(true, {}, this.namespace));
+            return destination;
+        }
+        data(key, value) {
+            if (typeof key === "string") {
+                if (arguments.length === 2) {
+                    assertUnfrozen("data", this.frozen);
+                    this.namespace[key] = value;
+                    return this;
+                }
+                return own$4.call(this.namespace, key) && this.namespace[key] || void 0;
+            }
+            if (key) {
+                assertUnfrozen("data", this.frozen);
+                this.namespace = key;
+                return this;
+            }
+            return this.namespace;
+        }
+        freeze() {
+            if (this.frozen) {
+                return this;
+            }
+            const self2 = this;
+            while (++this.freezeIndex < this.attachers.length) {
+                const [attacher, ...options] = this.attachers[this.freezeIndex];
+                if (options[0] === false) {
+                    continue;
+                }
+                if (options[0] === true) {
+                    options[0] = void 0;
+                }
+                const transformer = attacher.call(self2, ...options);
+                if (typeof transformer === "function") {
+                    this.transformers.use(transformer);
+                }
+            }
+            this.frozen = true;
+            this.freezeIndex = Number.POSITIVE_INFINITY;
+            return this;
+        }
+        parse(file) {
+            this.freeze();
+            const realFile = vfile(file);
+            const parser2 = this.parser || this.Parser;
+            assertParser("parse", parser2);
+            return parser2(String(realFile), realFile);
+        }
+        process(file, done) {
+            const self2 = this;
+            this.freeze();
+            assertParser("process", this.parser || this.Parser);
+            assertCompiler("process", this.compiler || this.Compiler);
+            return done ? executor(void 0, done) : new Promise(executor);
 
-    function roundOffsets(_ref2) {
-        var x2 = _ref2.x,
-            y2 = _ref2.y;
-        var win = window;
-        var dpr = win.devicePixelRatio || 1;
-        return {
-            x: Math.round(x2 * dpr) / dpr || 0,
-            y: Math.round(y2 * dpr) / dpr || 0
-        };
-    }
+            function executor(resolve2, reject) {
+                const realFile = vfile(file);
+                const parseTree = self2.parse(realFile);
+                self2.run(parseTree, realFile, function(error2, tree, file2) {
+                    if (error2 || !tree || !file2) {
+                        return realDone(error2);
+                    }
+                    const compileTree = tree;
+                    const compileResult = self2.stringify(compileTree, file2);
+                    if (looksLikeAValue(compileResult)) {
+                        file2.value = compileResult;
+                    } else {
+                        file2.result = compileResult;
+                    }
+                    realDone(error2, file2);
+                });
 
-    function mapToStyles(_ref2) {
-        var _Object$assign2;
-        var popper2 = _ref2.popper,
-            popperRect = _ref2.popperRect,
-            placement = _ref2.placement,
-            offsets = _ref2.offsets,
-            position2 = _ref2.position,
-            gpuAcceleration = _ref2.gpuAcceleration,
-            adaptive = _ref2.adaptive;
-        var _roundOffsets = roundOffsets(offsets),
-            x2 = _roundOffsets.x,
-            y2 = _roundOffsets.y;
-        var hasX = offsets.hasOwnProperty("x");
-        var hasY = offsets.hasOwnProperty("y");
-        var sideX = left;
-        var sideY = top$1;
-        var win = window;
-        if (adaptive) {
-            var offsetParent = getOffsetParent(popper2);
-            if (offsetParent === getWindow(popper2)) {
-                offsetParent = getDocumentElement(popper2);
-            }
-            if (placement === top$1) {
-                sideY = bottom;
-                y2 -= offsetParent.clientHeight - popperRect.height;
-                y2 *= gpuAcceleration ? 1 : -1;
+                function realDone(error2, file2) {
+                    if (error2 || !file2) {
+                        reject(error2);
+                    } else if (resolve2) {
+                        resolve2(file2);
+                    } else {
+                        done(void 0, file2);
+                    }
+                }
             }
-            if (placement === left) {
-                sideX = right;
-                x2 -= offsetParent.clientWidth - popperRect.width;
-                x2 *= gpuAcceleration ? 1 : -1;
+        }
+        processSync(file) {
+            let complete = false;
+            let result;
+            this.freeze();
+            assertParser("processSync", this.parser || this.Parser);
+            assertCompiler("processSync", this.compiler || this.Compiler);
+            this.process(file, realDone);
+            assertDone("processSync", "process", complete);
+            return result;
+
+            function realDone(error2, file2) {
+                complete = true;
+                bail(error2);
+                result = file2;
             }
         }
-        var commonStyles = Object.assign({
-            position: position2
-        }, adaptive && unsetSides);
-        if (gpuAcceleration) {
-            var _Object$assign;
-            return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
+        run(tree, file, done) {
+            assertNode(tree);
+            this.freeze();
+            const transformers = this.transformers;
+            if (!done && typeof file === "function") {
+                done = file;
+                file = void 0;
+            }
+            return done ? executor(void 0, done) : new Promise(executor);
+
+            function executor(resolve2, reject) {
+                const realFile = vfile(file);
+                transformers.run(tree, realFile, realDone);
+
+                function realDone(error2, outputTree, file2) {
+                    const resultingTree = outputTree || tree;
+                    if (error2) {
+                        reject(error2);
+                    } else if (resolve2) {
+                        resolve2(resultingTree);
+                    } else {
+                        done(void 0, resultingTree, file2);
+                    }
+                }
+            }
         }
-        return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
-    }
+        runSync(tree, file) {
+            let complete = false;
+            let result;
+            this.run(tree, file, realDone);
+            assertDone("runSync", "run", complete);
+            return result;
 
-    function computeStyles(_ref3) {
-        var state = _ref3.state,
-            options = _ref3.options;
-        var _options$gpuAccelerat = options.gpuAcceleration,
-            gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
-            _options$adaptive = options.adaptive,
-            adaptive = _options$adaptive === void 0 ? true : _options$adaptive;
-        var commonStyles = {
-            placement: getBasePlacement(state.placement),
-            popper: state.elements.popper,
-            popperRect: state.rects.popper,
-            gpuAcceleration
-        };
-        if (state.modifiersData.popperOffsets != null) {
-            state.styles.popper = Object.assign({}, state.styles.popper, {}, mapToStyles(Object.assign({}, commonStyles, {
-                offsets: state.modifiersData.popperOffsets,
-                position: state.options.strategy,
-                adaptive
-            })));
+            function realDone(error2, tree2) {
+                bail(error2);
+                result = tree2;
+                complete = true;
+            }
         }
-        if (state.modifiersData.arrow != null) {
-            state.styles.arrow = Object.assign({}, state.styles.arrow, {}, mapToStyles(Object.assign({}, commonStyles, {
-                offsets: state.modifiersData.arrow,
-                position: "absolute",
-                adaptive: false
-            })));
+        stringify(tree, file) {
+            this.freeze();
+            const realFile = vfile(file);
+            const compiler2 = this.compiler || this.Compiler;
+            assertCompiler("stringify", compiler2);
+            assertNode(tree);
+            return compiler2(tree, realFile);
         }
-        state.attributes.popper = Object.assign({}, state.attributes.popper, {
-            "data-popper-placement": state.placement
-        });
-    }
-    const computeStyles$1 = {
-        name: "computeStyles",
-        enabled: true,
-        phase: "beforeWrite",
-        fn: computeStyles,
-        data: {}
-    };
+        use(value, ...parameters) {
+            const attachers = this.attachers;
+            const namespace2 = this.namespace;
+            assertUnfrozen("use", this.frozen);
+            if (value === null || value === void 0)
+            ;
+            else if (typeof value === "function") {
+                addPlugin(value, parameters);
+            } else if (typeof value === "object") {
+                if (Array.isArray(value)) {
+                    addList(value);
+                } else {
+                    addPreset(value);
+                }
+            } else {
+                throw new TypeError("Expected usable value, not `" + value + "`");
+            }
+            return this;
 
-    function applyStyles(_ref2) {
-        var state = _ref2.state;
-        Object.keys(state.elements).forEach(function(name2) {
-            var style2 = state.styles[name2] || {};
-            var attributes2 = state.attributes[name2] || {};
-            var element2 = state.elements[name2];
-            if (!isHTMLElement(element2) || !getNodeName(element2)) {
-                return;
+            function add2(value2) {
+                if (typeof value2 === "function") {
+                    addPlugin(value2, []);
+                } else if (typeof value2 === "object") {
+                    if (Array.isArray(value2)) {
+                        const [plugin, ...parameters2] = value2;
+                        addPlugin(plugin, parameters2);
+                    } else {
+                        addPreset(value2);
+                    }
+                } else {
+                    throw new TypeError("Expected usable value, not `" + value2 + "`");
+                }
             }
-            Object.assign(element2.style, style2);
-            Object.keys(attributes2).forEach(function(name3) {
-                var value = attributes2[name3];
-                if (value === false) {
-                    element2.removeAttribute(name3);
+
+            function addPreset(result) {
+                if (!("plugins" in result) && !("settings" in result)) {
+                    throw new Error(
+                        "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
+                    );
+                }
+                addList(result.plugins);
+                if (result.settings) {
+                    namespace2.settings = extend$3(true, namespace2.settings, result.settings);
+                }
+            }
+
+            function addList(plugins2) {
+                let index2 = -1;
+                if (plugins2 === null || plugins2 === void 0)
+                ;
+                else if (Array.isArray(plugins2)) {
+                    while (++index2 < plugins2.length) {
+                        const thing = plugins2[index2];
+                        add2(thing);
+                    }
                 } else {
-                    element2.setAttribute(name3, value === true ? "" : value);
+                    throw new TypeError("Expected a list of plugins, not `" + plugins2 + "`");
                 }
-            });
-        });
+            }
+
+            function addPlugin(plugin, parameters2) {
+                let index2 = -1;
+                let entryIndex = -1;
+                while (++index2 < attachers.length) {
+                    if (attachers[index2][0] === plugin) {
+                        entryIndex = index2;
+                        break;
+                    }
+                }
+                if (entryIndex === -1) {
+                    attachers.push([plugin, ...parameters2]);
+                } else if (parameters2.length > 0) {
+                    let [primary, ...rest] = parameters2;
+                    const currentPrimary = attachers[entryIndex][1];
+                    if (isPlainObject$3(currentPrimary) && isPlainObject$3(primary)) {
+                        primary = extend$3(true, currentPrimary, primary);
+                    }
+                    attachers[entryIndex] = [plugin, primary, ...rest];
+                }
+            }
+        }
     }
+    const unified = new Processor().freeze();
 
-    function effect$1(_ref2) {
-        var state = _ref2.state;
-        var initialStyles = {
-            popper: {
-                position: state.options.strategy,
-                left: "0",
-                top: "0",
-                margin: "0"
-            },
-            arrow: {
-                position: "absolute"
-            },
-            reference: {}
-        };
-        Object.assign(state.elements.popper.style, initialStyles.popper);
-        if (state.elements.arrow) {
-            Object.assign(state.elements.arrow.style, initialStyles.arrow);
+    function assertParser(name2, value) {
+        if (typeof value !== "function") {
+            throw new TypeError("Cannot `" + name2 + "` without `parser`");
         }
-        return function() {
-            Object.keys(state.elements).forEach(function(name2) {
-                var element2 = state.elements[name2];
-                var attributes2 = state.attributes[name2] || {};
-                var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
-                var style2 = styleProperties.reduce(function(style3, property) {
-                    style3[property] = "";
-                    return style3;
-                }, {});
-                if (!isHTMLElement(element2) || !getNodeName(element2)) {
-                    return;
-                }
-                Object.assign(element2.style, style2);
-                Object.keys(attributes2).forEach(function(attribute) {
-                    element2.removeAttribute(attribute);
-                });
-            });
-        };
     }
-    const applyStyles$1 = {
-        name: "applyStyles",
-        enabled: true,
-        phase: "write",
-        fn: applyStyles,
-        effect: effect$1,
-        requires: ["computeStyles"]
-    };
 
-    function distanceAndSkiddingToXY(placement, rects, offset2) {
-        var basePlacement = getBasePlacement(placement);
-        var invertDistance = [left, top$1].indexOf(basePlacement) >= 0 ? -1 : 1;
-        var _ref2 = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
-                placement
-            })) : offset2,
-            skidding = _ref2[0],
-            distance = _ref2[1];
-        skidding = skidding || 0;
-        distance = (distance || 0) * invertDistance;
-        return [left, right].indexOf(basePlacement) >= 0 ? {
-            x: distance,
-            y: skidding
-        } : {
-            x: skidding,
-            y: distance
-        };
+    function assertCompiler(name2, value) {
+        if (typeof value !== "function") {
+            throw new TypeError("Cannot `" + name2 + "` without `compiler`");
+        }
     }
 
-    function offset(_ref2) {
-        var state = _ref2.state,
-            options = _ref2.options,
-            name2 = _ref2.name;
-        var _options$offset = options.offset,
-            offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
-        var data2 = placements.reduce(function(acc, placement) {
-            acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
-            return acc;
-        }, {});
-        var _data$state$placement = data2[state.placement],
-            x2 = _data$state$placement.x,
-            y2 = _data$state$placement.y;
-        if (state.modifiersData.popperOffsets != null) {
-            state.modifiersData.popperOffsets.x += x2;
-            state.modifiersData.popperOffsets.y += y2;
+    function assertUnfrozen(name2, frozen) {
+        if (frozen) {
+            throw new Error(
+                "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
+            );
         }
-        state.modifiersData[name2] = data2;
     }
-    const offset$1 = {
-        name: "offset",
-        enabled: true,
-        phase: "main",
-        requires: ["popperOffsets"],
-        fn: offset
-    };
-    var hash$2 = {
-        left: "right",
-        right: "left",
-        bottom: "top",
-        top: "bottom"
-    };
 
-    function getOppositePlacement(placement) {
-        return placement.replace(/left|right|bottom|top/g, function(matched) {
-            return hash$2[matched];
-        });
+    function assertNode(node2) {
+        if (!isPlainObject$3(node2) || typeof node2.type !== "string") {
+            throw new TypeError("Expected node, got `" + node2 + "`");
+        }
     }
-    var hash$1 = {
-        start: "end",
-        end: "start"
+
+    function assertDone(name2, asyncName, complete) {
+        if (!complete) {
+            throw new Error(
+                "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
+            );
+        }
+    }
+
+    function vfile(value) {
+        return looksLikeAVFile(value) ? value : new VFile(value);
+    }
+
+    function looksLikeAVFile(value) {
+        return Boolean(
+            value && typeof value === "object" && "message" in value && "messages" in value
+        );
+    }
+
+    function looksLikeAValue(value) {
+        return typeof value === "string" || isUint8Array(value);
+    }
+
+    function isUint8Array(value) {
+        return Boolean(
+            value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
+        );
+    }
+    const changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
+    const emptyPlugins = [];
+    const emptyRemarkRehypeOptions = {
+        allowDangerousHtml: true
     };
+    const safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i;
+    const deprecations = [{
+        from: "astPlugins",
+        id: "remove-buggy-html-in-markdown-parser"
+    }, {
+        from: "allowDangerousHtml",
+        id: "remove-buggy-html-in-markdown-parser"
+    }, {
+        from: "allowNode",
+        id: "replace-allownode-allowedtypes-and-disallowedtypes",
+        to: "allowElement"
+    }, {
+        from: "allowedTypes",
+        id: "replace-allownode-allowedtypes-and-disallowedtypes",
+        to: "allowedElements"
+    }, {
+        from: "disallowedTypes",
+        id: "replace-allownode-allowedtypes-and-disallowedtypes",
+        to: "disallowedElements"
+    }, {
+        from: "escapeHtml",
+        id: "remove-buggy-html-in-markdown-parser"
+    }, {
+        from: "includeElementIndex",
+        id: "#remove-includeelementindex"
+    }, {
+        from: "includeNodeIndex",
+        id: "change-includenodeindex-to-includeelementindex"
+    }, {
+        from: "linkTarget",
+        id: "remove-linktarget"
+    }, {
+        from: "plugins",
+        id: "change-plugins-to-remarkplugins",
+        to: "remarkPlugins"
+    }, {
+        from: "rawSourcePos",
+        id: "#remove-rawsourcepos"
+    }, {
+        from: "renderers",
+        id: "change-renderers-to-components",
+        to: "components"
+    }, {
+        from: "source",
+        id: "change-source-to-children",
+        to: "children"
+    }, {
+        from: "sourcePos",
+        id: "#remove-sourcepos"
+    }, {
+        from: "transformImageUri",
+        id: "#add-urltransform",
+        to: "urlTransform"
+    }, {
+        from: "transformLinkUri",
+        id: "#add-urltransform",
+        to: "urlTransform"
+    }];
 
-    function getOppositeVariationPlacement(placement) {
-        return placement.replace(/start|end/g, function(matched) {
-            return hash$1[matched];
+    function Markdown$2(options) {
+        const allowedElements = options.allowedElements;
+        const allowElement = options.allowElement;
+        const children2 = options.children || "";
+        const className = options.className;
+        const components = options.components;
+        const disallowedElements = options.disallowedElements;
+        const rehypePlugins = options.rehypePlugins || emptyPlugins;
+        const remarkPlugins = options.remarkPlugins || emptyPlugins;
+        const remarkRehypeOptions = options.remarkRehypeOptions ? {
+            ...options.remarkRehypeOptions,
+            ...emptyRemarkRehypeOptions
+        } : emptyRemarkRehypeOptions;
+        const skipHtml = options.skipHtml;
+        const unwrapDisallowed = options.unwrapDisallowed;
+        const urlTransform = options.urlTransform || defaultUrlTransform;
+        const processor = unified().use(remarkParse).use(remarkPlugins).use(remarkRehype, remarkRehypeOptions).use(rehypePlugins);
+        const file = new VFile();
+        if (typeof children2 === "string") {
+            file.value = children2;
+        }
+        for (const deprecation2 of deprecations) {
+            if (Object.hasOwn(options, deprecation2.from)) {
+                unreachable(
+                    "Unexpected `" + deprecation2.from + "` prop, " + (deprecation2.to ? "use `" + deprecation2.to + "` instead" : "remove it") + " (see <" + changelog + "#" + deprecation2.id + "> for more info)"
+                );
+            }
+        }
+        const mdastTree = processor.parse(file);
+        let hastTree = processor.runSync(mdastTree, file);
+        if (className) {
+            hastTree = {
+                type: "element",
+                tagName: "div",
+                properties: {
+                    className
+                },
+                children: hastTree.type === "root" ? hastTree.children : [hastTree]
+            };
+        }
+        visit$1(hastTree, transform);
+        return toJsxRuntime(hastTree, {
+            Fragment: jsxRuntime.exports.Fragment,
+            components,
+            ignoreInvalidStyle: true,
+            jsx: jsxRuntime.exports.jsx,
+            jsxs: jsxRuntime.exports.jsxs,
+            passKeys: true,
+            passNode: true
         });
-    }
 
-    function getViewportRect(element2) {
-        var win = getWindow(element2);
-        var visualViewport = win.visualViewport;
-        var width = win.innerWidth;
-        var height = win.innerHeight;
-        if (visualViewport && /iPhone|iPod|iPad/.test(navigator.platform)) {
-            width = visualViewport.width;
-            height = visualViewport.height;
+        function transform(node2, index2, parent) {
+            if (node2.type === "raw" && parent && typeof index2 === "number") {
+                if (skipHtml) {
+                    parent.children.splice(index2, 1);
+                } else {
+                    parent.children[index2] = {
+                        type: "text",
+                        value: node2.value
+                    };
+                }
+                return index2;
+            }
+            if (node2.type === "element") {
+                let key;
+                for (key in urlAttributes) {
+                    if (Object.hasOwn(urlAttributes, key) && Object.hasOwn(node2.properties, key)) {
+                        const value = node2.properties[key];
+                        const test2 = urlAttributes[key];
+                        if (test2 === null || test2.includes(node2.tagName)) {
+                            node2.properties[key] = urlTransform(String(value || ""), key, node2);
+                        }
+                    }
+                }
+            }
+            if (node2.type === "element") {
+                let remove2 = allowedElements ? !allowedElements.includes(node2.tagName) : disallowedElements ? disallowedElements.includes(node2.tagName) : false;
+                if (!remove2 && allowElement && typeof index2 === "number") {
+                    remove2 = !allowElement(node2, index2, parent);
+                }
+                if (remove2 && parent && typeof index2 === "number") {
+                    if (unwrapDisallowed && node2.children) {
+                        parent.children.splice(index2, 1, ...node2.children);
+                    } else {
+                        parent.children.splice(index2, 1);
+                    }
+                    return index2;
+                }
+            }
         }
-        return {
-            width,
-            height,
-            x: 0,
-            y: 0
-        };
     }
 
-    function getDocumentRect(element2) {
-        var win = getWindow(element2);
-        var winScroll = getWindowScroll(element2);
-        var documentRect = getCompositeRect(getDocumentElement(element2), win);
-        documentRect.height = Math.max(documentRect.height, win.innerHeight);
-        documentRect.width = Math.max(documentRect.width, win.innerWidth);
-        documentRect.x = -winScroll.scrollLeft;
-        documentRect.y = -winScroll.scrollTop;
-        return documentRect;
+    function defaultUrlTransform(value) {
+        const colon = value.indexOf(":");
+        const questionMark = value.indexOf("?");
+        const numberSign = value.indexOf("#");
+        const slash = value.indexOf("/");
+        if (colon < 0 || slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign || safeProtocol.test(value.slice(0, colon))) {
+            return value;
+        }
+        return "";
     }
 
-    function toNumber$2(cssValue) {
-        return parseFloat(cssValue) || 0;
+    function ccount(value, character) {
+        const source = String(value);
+        if (typeof character !== "string") {
+            throw new TypeError("Expected character");
+        }
+        let count2 = 0;
+        let index2 = source.indexOf(character);
+        while (index2 !== -1) {
+            count2++;
+            index2 = source.indexOf(character, index2 + character.length);
+        }
+        return count2;
     }
 
-    function getBorders(element2) {
-        var computedStyle = isHTMLElement(element2) ? getComputedStyle$1(element2) : {};
-        return {
-            top: toNumber$2(computedStyle.borderTopWidth),
-            right: toNumber$2(computedStyle.borderRightWidth),
-            bottom: toNumber$2(computedStyle.borderBottomWidth),
-            left: toNumber$2(computedStyle.borderLeftWidth)
-        };
+    function escapeStringRegexp(string2) {
+        if (typeof string2 !== "string") {
+            throw new TypeError("Expected a string");
+        }
+        return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
     }
 
-    function getDecorations(element2) {
-        var win = getWindow(element2);
-        var borders = getBorders(element2);
-        var isHTML = getNodeName(element2) === "html";
-        var winScrollBarX = getWindowScrollBarX(element2);
-        var x2 = element2.clientWidth + borders.right;
-        var y2 = element2.clientHeight + borders.bottom;
-        if (isHTML && win.innerHeight - element2.clientHeight > 50) {
-            y2 = win.innerHeight - borders.bottom;
+    function findAndReplace(tree, list2, options) {
+        const settings2 = options || {};
+        const ignored = convert$1(settings2.ignore || []);
+        const pairs = toPairs(list2);
+        let pairIndex = -1;
+        while (++pairIndex < pairs.length) {
+            visitParents$1(tree, "text", visitor);
         }
-        return {
-            top: isHTML ? 0 : element2.clientTop,
-            right: element2.clientLeft > borders.left ? borders.right : isHTML ? win.innerWidth - x2 - winScrollBarX : element2.offsetWidth - x2,
-            bottom: isHTML ? win.innerHeight - y2 : element2.offsetHeight - y2,
-            left: isHTML ? winScrollBarX : element2.clientLeft
-        };
-    }
 
-    function contains$1(parent, child) {
-        var isShadow = Boolean(child.getRootNode && child.getRootNode().host);
-        if (parent.contains(child)) {
-            return true;
-        } else if (isShadow) {
-            var next2 = child;
-            do {
-                if (next2 && parent.isSameNode(next2)) {
-                    return true;
+        function visitor(node2, parents) {
+            let index2 = -1;
+            let grandparent;
+            while (++index2 < parents.length) {
+                const parent = parents[index2];
+                const siblings = grandparent ? grandparent.children : void 0;
+                if (ignored(
+                        parent,
+                        siblings ? siblings.indexOf(parent) : void 0,
+                        grandparent
+                    )) {
+                    return;
                 }
-                next2 = next2.parentNode || next2.host;
-            } while (next2);
+                grandparent = parent;
+            }
+            if (grandparent) {
+                return handler(node2, parents);
+            }
+        }
+
+        function handler(node2, parents) {
+            const parent = parents[parents.length - 1];
+            const find2 = pairs[pairIndex][0];
+            const replace2 = pairs[pairIndex][1];
+            let start2 = 0;
+            const siblings = parent.children;
+            const index2 = siblings.indexOf(node2);
+            let change = false;
+            let nodes = [];
+            find2.lastIndex = 0;
+            let match2 = find2.exec(node2.value);
+            while (match2) {
+                const position2 = match2.index;
+                const matchObject = {
+                    index: match2.index,
+                    input: match2.input,
+                    stack: [...parents, node2]
+                };
+                let value = replace2(...match2, matchObject);
+                if (typeof value === "string") {
+                    value = value.length > 0 ? {
+                        type: "text",
+                        value
+                    } : void 0;
+                }
+                if (value === false) {
+                    find2.lastIndex = position2 + 1;
+                } else {
+                    if (start2 !== position2) {
+                        nodes.push({
+                            type: "text",
+                            value: node2.value.slice(start2, position2)
+                        });
+                    }
+                    if (Array.isArray(value)) {
+                        nodes.push(...value);
+                    } else if (value) {
+                        nodes.push(value);
+                    }
+                    start2 = position2 + match2[0].length;
+                    change = true;
+                }
+                if (!find2.global) {
+                    break;
+                }
+                match2 = find2.exec(node2.value);
+            }
+            if (change) {
+                if (start2 < node2.value.length) {
+                    nodes.push({
+                        type: "text",
+                        value: node2.value.slice(start2)
+                    });
+                }
+                parent.children.splice(index2, 1, ...nodes);
+            } else {
+                nodes = [node2];
+            }
+            return index2 + nodes.length;
         }
-        return false;
     }
 
-    function rectToClientRect(rect) {
-        return Object.assign({}, rect, {
-            left: rect.x,
-            top: rect.y,
-            right: rect.x + rect.width,
-            bottom: rect.y + rect.height
-        });
+    function toPairs(tupleOrList) {
+        const result = [];
+        if (!Array.isArray(tupleOrList)) {
+            throw new TypeError("Expected find and replace tuple or list of tuples");
+        }
+        const list2 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
+        let index2 = -1;
+        while (++index2 < list2.length) {
+            const tuple = list2[index2];
+            result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
+        }
+        return result;
     }
 
-    function getClientRectFromMixedType(element2, clippingParent) {
-        return clippingParent === viewport ? rectToClientRect(getViewportRect(element2)) : isHTMLElement(clippingParent) ? getBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
+    function toExpression(find2) {
+        return typeof find2 === "string" ? new RegExp(escapeStringRegexp(find2), "g") : find2;
     }
 
-    function getClippingParents(element2) {
-        var clippingParents2 = listScrollParents(element2);
-        var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element2).position) >= 0;
-        var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
-        if (!isElement$1(clipperElement)) {
-            return [];
-        }
-        return clippingParents2.filter(function(clippingParent) {
-            return isElement$1(clippingParent) && contains$1(clippingParent, clipperElement);
-        });
+    function toFunction(replace2) {
+        return typeof replace2 === "function" ? replace2 : function() {
+            return replace2;
+        };
     }
+    const inConstruct = "phrasing";
+    const notInConstruct = ["autolink", "link", "image", "label"];
 
-    function getClippingRect(element2, boundary, rootBoundary) {
-        var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
-        var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
-        var firstClippingParent = clippingParents2[0];
-        var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
-            var rect = getClientRectFromMixedType(element2, clippingParent);
-            var decorations2 = getDecorations(isHTMLElement(clippingParent) ? clippingParent : getDocumentElement(element2));
-            accRect.top = Math.max(rect.top + decorations2.top, accRect.top);
-            accRect.right = Math.min(rect.right - decorations2.right, accRect.right);
-            accRect.bottom = Math.min(rect.bottom - decorations2.bottom, accRect.bottom);
-            accRect.left = Math.max(rect.left + decorations2.left, accRect.left);
-            return accRect;
-        }, getClientRectFromMixedType(element2, firstClippingParent));
-        clippingRect.width = clippingRect.right - clippingRect.left;
-        clippingRect.height = clippingRect.bottom - clippingRect.top;
-        clippingRect.x = clippingRect.left;
-        clippingRect.y = clippingRect.top;
-        return clippingRect;
+    function gfmAutolinkLiteralFromMarkdown() {
+        return {
+            transforms: [transformGfmAutolinkLiterals],
+            enter: {
+                literalAutolink: enterLiteralAutolink,
+                literalAutolinkEmail: enterLiteralAutolinkValue,
+                literalAutolinkHttp: enterLiteralAutolinkValue,
+                literalAutolinkWww: enterLiteralAutolinkValue
+            },
+            exit: {
+                literalAutolink: exitLiteralAutolink,
+                literalAutolinkEmail: exitLiteralAutolinkEmail,
+                literalAutolinkHttp: exitLiteralAutolinkHttp,
+                literalAutolinkWww: exitLiteralAutolinkWww
+            }
+        };
     }
 
-    function getFreshSideObject() {
+    function gfmAutolinkLiteralToMarkdown() {
         return {
-            top: 0,
-            right: 0,
-            bottom: 0,
-            left: 0
+            unsafe: [{
+                character: "@",
+                before: "[+\\-.\\w]",
+                after: "[\\-.\\w]",
+                inConstruct,
+                notInConstruct
+            }, {
+                character: ".",
+                before: "[Ww]",
+                after: "[\\-.\\w]",
+                inConstruct,
+                notInConstruct
+            }, {
+                character: ":",
+                before: "[ps]",
+                after: "\\/",
+                inConstruct,
+                notInConstruct
+            }]
         };
     }
 
-    function mergePaddingObject(paddingObject) {
-        return Object.assign({}, getFreshSideObject(), {}, paddingObject);
+    function enterLiteralAutolink(token) {
+        this.enter({
+            type: "link",
+            title: null,
+            url: "",
+            children: []
+        }, token);
     }
 
-    function expandToHashMap(value, keys2) {
-        return keys2.reduce(function(hashMap, key) {
-            hashMap[key] = value;
-            return hashMap;
-        }, {});
+    function enterLiteralAutolinkValue(token) {
+        this.config.enter.autolinkProtocol.call(this, token);
     }
 
-    function detectOverflow(state, options) {
-        if (options === void 0) {
-            options = {};
-        }
-        var _options = options,
-            _options$placement = _options.placement,
-            placement = _options$placement === void 0 ? state.placement : _options$placement,
-            _options$boundary = _options.boundary,
-            boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
-            _options$rootBoundary = _options.rootBoundary,
-            rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
-            _options$elementConte = _options.elementContext,
-            elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
-            _options$altBoundary = _options.altBoundary,
-            altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
-            _options$padding = _options.padding,
-            padding = _options$padding === void 0 ? 0 : _options$padding;
-        var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
-        var altContext = elementContext === popper ? reference : popper;
-        var referenceElement = state.elements.reference;
-        var popperRect = state.rects.popper;
-        var element2 = state.elements[altBoundary ? altContext : elementContext];
-        var clippingClientRect = getClippingRect(isElement$1(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
-        var referenceClientRect = getBoundingClientRect(referenceElement);
-        var popperOffsets2 = computeOffsets({
-            reference: referenceClientRect,
-            element: popperRect,
-            strategy: "absolute",
-            placement
-        });
-        var popperClientRect = rectToClientRect(Object.assign({}, popperRect, {}, popperOffsets2));
-        var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
-        var overflowOffsets = {
-            top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
-            bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
-            left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
-            right: elementClientRect.right - clippingClientRect.right + paddingObject.right
-        };
-        var offsetData = state.modifiersData.offset;
-        if (elementContext === popper && offsetData) {
-            var offset2 = offsetData[placement];
-            Object.keys(overflowOffsets).forEach(function(key) {
-                var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
-                var axis = [top$1, bottom].indexOf(key) >= 0 ? "y" : "x";
-                overflowOffsets[key] += offset2[axis] * multiply;
-            });
-        }
-        return overflowOffsets;
+    function exitLiteralAutolinkHttp(token) {
+        this.config.exit.autolinkProtocol.call(this, token);
     }
 
-    function computeAutoPlacement(state, options) {
-        if (options === void 0) {
-            options = {};
-        }
-        var _options = options,
-            placement = _options.placement,
-            boundary = _options.boundary,
-            rootBoundary = _options.rootBoundary,
-            padding = _options.padding,
-            flipVariations = _options.flipVariations,
-            _options$allowedAutoP = _options.allowedAutoPlacements,
-            allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
-        var variation = getVariation(placement);
-        var placements$12 = (variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
-            return getVariation(placement2) === variation;
-        }) : basePlacements).filter(function(placement2) {
-            return allowedAutoPlacements.indexOf(placement2) >= 0;
-        });
-        var overflows = placements$12.reduce(function(acc, placement2) {
-            acc[placement2] = detectOverflow(state, {
-                placement: placement2,
-                boundary,
-                rootBoundary,
-                padding
-            })[getBasePlacement(placement2)];
-            return acc;
-        }, {});
-        return Object.keys(overflows).sort(function(a2, b2) {
-            return overflows[a2] - overflows[b2];
-        });
+    function exitLiteralAutolinkWww(token) {
+        this.config.exit.data.call(this, token);
+        const node2 = this.stack[this.stack.length - 1];
+        ok$2(node2.type === "link");
+        node2.url = "http://" + this.sliceSerialize(token);
     }
 
-    function getExpandedFallbackPlacements(placement) {
-        if (getBasePlacement(placement) === auto) {
-            return [];
-        }
-        var oppositePlacement = getOppositePlacement(placement);
-        return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
+    function exitLiteralAutolinkEmail(token) {
+        this.config.exit.autolinkEmail.call(this, token);
     }
 
-    function flip(_ref2) {
-        var state = _ref2.state,
-            options = _ref2.options,
-            name2 = _ref2.name;
-        if (state.modifiersData[name2]._skip) {
-            return;
-        }
-        var _options$mainAxis = options.mainAxis,
-            checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
-            _options$altAxis = options.altAxis,
-            checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
-            specifiedFallbackPlacements = options.fallbackPlacements,
-            padding = options.padding,
-            boundary = options.boundary,
-            rootBoundary = options.rootBoundary,
-            altBoundary = options.altBoundary,
-            _options$flipVariatio = options.flipVariations,
-            flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
-            allowedAutoPlacements = options.allowedAutoPlacements;
-        var preferredPlacement = state.options.placement;
-        var basePlacement = getBasePlacement(preferredPlacement);
-        var isBasePlacement = basePlacement === preferredPlacement;
-        var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
-        var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
-            return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
-                placement: placement2,
-                boundary,
-                rootBoundary,
-                padding,
-                flipVariations,
-                allowedAutoPlacements
-            }) : placement2);
-        }, []);
-        var referenceRect = state.rects.reference;
-        var popperRect = state.rects.popper;
-        var checksMap = /* @__PURE__ */ new Map();
-        var makeFallbackChecks = true;
-        var firstFittingPlacement = placements2[0];
-        for (var i2 = 0; i2 < placements2.length; i2++) {
-            var placement = placements2[i2];
-            var _basePlacement = getBasePlacement(placement);
-            var isStartVariation = getVariation(placement) === start$1;
-            var isVertical = [top$1, bottom].indexOf(_basePlacement) >= 0;
-            var len = isVertical ? "width" : "height";
-            var overflow = detectOverflow(state, {
-                placement,
-                boundary,
-                rootBoundary,
-                altBoundary,
-                padding
-            });
-            var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top$1;
-            if (referenceRect[len] > popperRect[len]) {
-                mainVariationSide = getOppositePlacement(mainVariationSide);
-            }
-            var altVariationSide = getOppositePlacement(mainVariationSide);
-            var checks2 = [];
-            if (checkMainAxis) {
-                checks2.push(overflow[_basePlacement] <= 0);
-            }
-            if (checkAltAxis) {
-                checks2.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
-            }
-            if (checks2.every(function(check) {
-                    return check;
-                })) {
-                firstFittingPlacement = placement;
-                makeFallbackChecks = false;
-                break;
+    function exitLiteralAutolink(token) {
+        this.exit(token);
+    }
+
+    function transformGfmAutolinkLiterals(tree) {
+        findAndReplace(
+            tree,
+            [
+                [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
+                [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
+            ], {
+                ignore: ["link", "linkReference"]
             }
-            checksMap.set(placement, checks2);
+        );
+    }
+
+    function findUrl(_2, protocol, domain2, path2, match2) {
+        let prefix = "";
+        if (!previous(match2)) {
+            return false;
         }
-        if (makeFallbackChecks) {
-            var numberOfChecks = flipVariations ? 3 : 1;
-            var _loop = function _loop2(_i3) {
-                var fittingPlacement = placements2.find(function(placement2) {
-                    var checks3 = checksMap.get(placement2);
-                    if (checks3) {
-                        return checks3.slice(0, _i3).every(function(check) {
-                            return check;
-                        });
-                    }
-                });
-                if (fittingPlacement) {
-                    firstFittingPlacement = fittingPlacement;
-                    return "break";
-                }
-            };
-            for (var _i2 = numberOfChecks; _i2 > 0; _i2--) {
-                var _ret = _loop(_i2);
-                if (_ret === "break")
-                    break;
-            }
+        if (/^w/i.test(protocol)) {
+            domain2 = protocol + domain2;
+            protocol = "";
+            prefix = "http://";
         }
-        if (state.placement !== firstFittingPlacement) {
-            state.modifiersData[name2]._skip = true;
-            state.placement = firstFittingPlacement;
-            state.reset = true;
+        if (!isCorrectDomain(domain2)) {
+            return false;
         }
-    }
-    const flip$1 = {
-        name: "flip",
-        enabled: true,
-        phase: "main",
-        fn: flip,
-        requiresIfExists: ["offset"],
-        data: {
-            _skip: false
+        const parts = splitUrl(domain2 + path2);
+        if (!parts[0])
+            return false;
+        const result = {
+            type: "link",
+            title: null,
+            url: prefix + protocol + parts[0],
+            children: [{
+                type: "text",
+                value: protocol + parts[0]
+            }]
+        };
+        if (parts[1]) {
+            return [result, {
+                type: "text",
+                value: parts[1]
+            }];
         }
-    };
-
-    function getAltAxis(axis) {
-        return axis === "x" ? "y" : "x";
+        return result;
     }
 
-    function within(min2, value, max2) {
-        return Math.max(min2, Math.min(value, max2));
+    function findEmail(_2, atext, label, match2) {
+        if (!previous(match2, true) || /[-\d_]$/.test(label)) {
+            return false;
+        }
+        return {
+            type: "link",
+            title: null,
+            url: "mailto:" + atext + "@" + label,
+            children: [{
+                type: "text",
+                value: atext + "@" + label
+            }]
+        };
     }
 
-    function preventOverflow(_ref2) {
-        var state = _ref2.state,
-            options = _ref2.options,
-            name2 = _ref2.name;
-        var _options$mainAxis = options.mainAxis,
-            checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
-            _options$altAxis = options.altAxis,
-            checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
-            boundary = options.boundary,
-            rootBoundary = options.rootBoundary,
-            altBoundary = options.altBoundary,
-            padding = options.padding,
-            _options$tether = options.tether,
-            tether = _options$tether === void 0 ? true : _options$tether,
-            _options$tetherOffset = options.tetherOffset,
-            tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
-        var overflow = detectOverflow(state, {
-            boundary,
-            rootBoundary,
-            padding,
-            altBoundary
-        });
-        var basePlacement = getBasePlacement(state.placement);
-        var variation = getVariation(state.placement);
-        var isBasePlacement = !variation;
-        var mainAxis = getMainAxisFromPlacement(basePlacement);
-        var altAxis = getAltAxis(mainAxis);
-        var popperOffsets2 = state.modifiersData.popperOffsets;
-        var referenceRect = state.rects.reference;
-        var popperRect = state.rects.popper;
-        var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
-            placement: state.placement
-        })) : tetherOffset;
-        var data2 = {
-            x: 0,
-            y: 0
-        };
-        if (!popperOffsets2) {
-            return;
+    function isCorrectDomain(domain2) {
+        const parts = domain2.split(".");
+        if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
+            return false;
         }
-        if (checkMainAxis) {
-            var mainSide = mainAxis === "y" ? top$1 : left;
-            var altSide = mainAxis === "y" ? bottom : right;
-            var len = mainAxis === "y" ? "height" : "width";
-            var offset2 = popperOffsets2[mainAxis];
-            var min2 = popperOffsets2[mainAxis] + overflow[mainSide];
-            var max2 = popperOffsets2[mainAxis] - overflow[altSide];
-            var additive = tether ? -popperRect[len] / 2 : 0;
-            var minLen = variation === start$1 ? referenceRect[len] : popperRect[len];
-            var maxLen = variation === start$1 ? -popperRect[len] : -referenceRect[len];
-            var arrowElement = state.elements.arrow;
-            var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
-                width: 0,
-                height: 0
-            };
-            var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
-            var arrowPaddingMin = arrowPaddingObject[mainSide];
-            var arrowPaddingMax = arrowPaddingObject[altSide];
-            var arrowLen = within(0, referenceRect[len], arrowRect[len]);
-            var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
-            var maxOffset2 = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
-            var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
-            var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
-            var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
-            var tetherMin = popperOffsets2[mainAxis] + minOffset - offsetModifierValue - clientOffset;
-            var tetherMax = popperOffsets2[mainAxis] + maxOffset2 - offsetModifierValue;
-            var preventedOffset = within(tether ? Math.min(min2, tetherMin) : min2, offset2, tether ? Math.max(max2, tetherMax) : max2);
-            popperOffsets2[mainAxis] = preventedOffset;
-            data2[mainAxis] = preventedOffset - offset2;
+        return true;
+    }
+
+    function splitUrl(url2) {
+        const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url2);
+        if (!trailExec) {
+            return [url2, void 0];
         }
-        if (checkAltAxis) {
-            var _mainSide = mainAxis === "x" ? top$1 : left;
-            var _altSide = mainAxis === "x" ? bottom : right;
-            var _offset = popperOffsets2[altAxis];
-            var _min = _offset + overflow[_mainSide];
-            var _max = _offset - overflow[_altSide];
-            var _preventedOffset = within(_min, _offset, _max);
-            popperOffsets2[altAxis] = _preventedOffset;
-            data2[altAxis] = _preventedOffset - _offset;
+        url2 = url2.slice(0, trailExec.index);
+        let trail2 = trailExec[0];
+        let closingParenIndex = trail2.indexOf(")");
+        const openingParens = ccount(url2, "(");
+        let closingParens = ccount(url2, ")");
+        while (closingParenIndex !== -1 && openingParens > closingParens) {
+            url2 += trail2.slice(0, closingParenIndex + 1);
+            trail2 = trail2.slice(closingParenIndex + 1);
+            closingParenIndex = trail2.indexOf(")");
+            closingParens++;
         }
-        state.modifiersData[name2] = data2;
+        return [url2, trail2];
     }
-    const preventOverflow$1 = {
-        name: "preventOverflow",
-        enabled: true,
-        phase: "main",
-        fn: preventOverflow,
-        requiresIfExists: ["offset"]
-    };
 
-    function arrow(_ref2) {
-        var _state$modifiersData$;
-        var state = _ref2.state,
-            name2 = _ref2.name;
-        var arrowElement = state.elements.arrow;
-        var popperOffsets2 = state.modifiersData.popperOffsets;
-        var basePlacement = getBasePlacement(state.placement);
-        var axis = getMainAxisFromPlacement(basePlacement);
-        var isVertical = [left, right].indexOf(basePlacement) >= 0;
-        var len = isVertical ? "height" : "width";
-        if (!arrowElement || !popperOffsets2) {
-            return;
-        }
-        var paddingObject = state.modifiersData[name2 + "#persistent"].padding;
-        var arrowRect = getLayoutRect(arrowElement);
-        var minProp = axis === "y" ? top$1 : left;
-        var maxProp = axis === "y" ? bottom : right;
-        var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
-        var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
-        var arrowOffsetParent = getOffsetParent(arrowElement);
-        var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
-        var centerToReference = endDiff / 2 - startDiff / 2;
-        var min2 = paddingObject[minProp];
-        var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
-        var center2 = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
-        var offset2 = within(min2, center2, max2);
-        var axisProp = axis;
-        state.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center2, _state$modifiersData$);
+    function previous(match2, email) {
+        const code2 = match2.input.charCodeAt(match2.index - 1);
+        return (match2.index === 0 || unicodeWhitespace(code2) || unicodePunctuation(code2)) && (!email || code2 !== 47);
     }
+    footnoteReference.peek = footnoteReferencePeek;
 
-    function effect(_ref2) {
-        var state = _ref2.state,
-            options = _ref2.options,
-            name2 = _ref2.name;
-        var _options$element = options.element,
-            arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element,
-            _options$padding = options.padding,
-            padding = _options$padding === void 0 ? 0 : _options$padding;
-        if (arrowElement == null) {
-            return;
-        }
-        if (typeof arrowElement === "string") {
-            arrowElement = state.elements.popper.querySelector(arrowElement);
-            if (!arrowElement) {
-                return;
+    function gfmFootnoteFromMarkdown() {
+        return {
+            enter: {
+                gfmFootnoteDefinition: enterFootnoteDefinition,
+                gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
+                gfmFootnoteCall: enterFootnoteCall,
+                gfmFootnoteCallString: enterFootnoteCallString
+            },
+            exit: {
+                gfmFootnoteDefinition: exitFootnoteDefinition,
+                gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
+                gfmFootnoteCall: exitFootnoteCall,
+                gfmFootnoteCallString: exitFootnoteCallString
             }
-        }
-        if (!contains$1(state.elements.popper, arrowElement)) {
-            return;
-        }
-        state.elements.arrow = arrowElement;
-        state.modifiersData[name2 + "#persistent"] = {
-            padding: mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements))
         };
     }
-    const arrow$1 = {
-        name: "arrow",
-        enabled: true,
-        phase: "main",
-        fn: arrow,
-        effect,
-        requires: ["popperOffsets"],
-        requiresIfExists: ["preventOverflow"]
-    };
 
-    function getSideOffsets(overflow, rect, preventedOffsets) {
-        if (preventedOffsets === void 0) {
-            preventedOffsets = {
-                x: 0,
-                y: 0
-            };
-        }
+    function gfmFootnoteToMarkdown() {
         return {
-            top: overflow.top - rect.height - preventedOffsets.y,
-            right: overflow.right - rect.width + preventedOffsets.x,
-            bottom: overflow.bottom - rect.height + preventedOffsets.y,
-            left: overflow.left - rect.width - preventedOffsets.x
+            unsafe: [{
+                character: "[",
+                inConstruct: ["phrasing", "label", "reference"]
+            }],
+            handlers: {
+                footnoteDefinition,
+                footnoteReference
+            }
         };
     }
 
-    function isAnySideFullyClipped(overflow) {
-        return [top$1, right, bottom, left].some(function(side) {
-            return overflow[side] >= 0;
-        });
+    function enterFootnoteDefinition(token) {
+        this.enter({
+                type: "footnoteDefinition",
+                identifier: "",
+                label: "",
+                children: []
+            },
+            token
+        );
     }
 
-    function hide(_ref2) {
-        var state = _ref2.state,
-            name2 = _ref2.name;
-        var referenceRect = state.rects.reference;
-        var popperRect = state.rects.popper;
-        var preventedOffsets = state.modifiersData.preventOverflow;
-        var referenceOverflow = detectOverflow(state, {
-            elementContext: "reference"
-        });
-        var popperAltOverflow = detectOverflow(state, {
-            altBoundary: true
-        });
-        var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
-        var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
-        var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
-        var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
-        state.modifiersData[name2] = {
-            referenceClippingOffsets,
-            popperEscapeOffsets,
-            isReferenceHidden,
-            hasPopperEscaped
-        };
-        state.attributes.popper = Object.assign({}, state.attributes.popper, {
-            "data-popper-reference-hidden": isReferenceHidden,
-            "data-popper-escaped": hasPopperEscaped
-        });
+    function enterFootnoteDefinitionLabelString() {
+        this.buffer();
     }
-    const hide$1 = {
-        name: "hide",
-        enabled: true,
-        phase: "main",
-        requiresIfExists: ["preventOverflow"],
-        fn: hide
-    };
-    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
-    var createPopper = /* @__PURE__ */ popperGenerator({
-        defaultModifiers
-    });
-    var hasElementType = typeof Element !== "undefined";
-    var hasMap$1 = typeof Map === "function";
-    var hasSet$1 = typeof Set === "function";
-    var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
 
-    function equal$1(a2, b2) {
-        if (a2 === b2)
-            return true;
-        if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
-            if (a2.constructor !== b2.constructor)
-                return false;
-            var length, i2, keys2;
-            if (Array.isArray(a2)) {
-                length = a2.length;
-                if (length != b2.length)
-                    return false;
-                for (i2 = length; i2-- !== 0;)
-                    if (!equal$1(a2[i2], b2[i2]))
-                        return false;
-                return true;
-            }
-            var it2;
-            if (hasMap$1 && a2 instanceof Map && b2 instanceof Map) {
-                if (a2.size !== b2.size)
-                    return false;
-                it2 = a2.entries();
-                while (!(i2 = it2.next()).done)
-                    if (!b2.has(i2.value[0]))
-                        return false;
-                it2 = a2.entries();
-                while (!(i2 = it2.next()).done)
-                    if (!equal$1(i2.value[1], b2.get(i2.value[0])))
-                        return false;
-                return true;
-            }
-            if (hasSet$1 && a2 instanceof Set && b2 instanceof Set) {
-                if (a2.size !== b2.size)
-                    return false;
-                it2 = a2.entries();
-                while (!(i2 = it2.next()).done)
-                    if (!b2.has(i2.value[0]))
-                        return false;
-                return true;
-            }
-            if (hasArrayBuffer && ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
-                length = a2.length;
-                if (length != b2.length)
-                    return false;
-                for (i2 = length; i2-- !== 0;)
-                    if (a2[i2] !== b2[i2])
-                        return false;
-                return true;
-            }
-            if (a2.constructor === RegExp)
-                return a2.source === b2.source && a2.flags === b2.flags;
-            if (a2.valueOf !== Object.prototype.valueOf && typeof a2.valueOf === "function" && typeof b2.valueOf === "function")
-                return a2.valueOf() === b2.valueOf();
-            if (a2.toString !== Object.prototype.toString && typeof a2.toString === "function" && typeof b2.toString === "function")
-                return a2.toString() === b2.toString();
-            keys2 = Object.keys(a2);
-            length = keys2.length;
-            if (length !== Object.keys(b2).length)
-                return false;
-            for (i2 = length; i2-- !== 0;)
-                if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2]))
-                    return false;
-            if (hasElementType && a2 instanceof Element)
-                return false;
-            for (i2 = length; i2-- !== 0;) {
-                if ((keys2[i2] === "_owner" || keys2[i2] === "__v" || keys2[i2] === "__o") && a2.$$typeof) {
-                    continue;
-                }
-                if (!equal$1(a2[keys2[i2]], b2[keys2[i2]]))
-                    return false;
-            }
-            return true;
-        }
-        return a2 !== a2 && b2 !== b2;
+    function exitFootnoteDefinitionLabelString(token) {
+        const label = this.resume();
+        const node2 = this.stack[this.stack.length - 1];
+        ok$2(node2.type === "footnoteDefinition");
+        node2.label = label;
+        node2.identifier = normalizeIdentifier(
+            this.sliceSerialize(token)
+        ).toLowerCase();
     }
-    var reactFastCompare = function isEqual2(a2, b2) {
-        try {
-            return equal$1(a2, b2);
-        } catch (error2) {
-            if ((error2.message || "").match(/stack|recursion/i)) {
-                console.warn("react-fast-compare cannot handle circular refs");
-                return false;
-            }
-            throw error2;
-        }
-    };
-    var EMPTY_MODIFIERS$2 = [];
-    var usePopper$1 = function usePopper2(referenceElement, popperElement, options) {
-        if (options === void 0) {
-            options = {};
-        }
-        var prevOptions = React__namespace.useRef(null);
-        var optionsWithDefaults = {
-            onFirstUpdate: options.onFirstUpdate,
-            placement: options.placement || "bottom",
-            strategy: options.strategy || "absolute",
-            modifiers: options.modifiers || EMPTY_MODIFIERS$2
-        };
-        var _React$useState = React__namespace.useState({
-                styles: {
-                    popper: {
-                        position: optionsWithDefaults.strategy,
-                        left: "0",
-                        top: "0"
-                    },
-                    arrow: {
-                        position: "absolute"
-                    }
-                },
-                attributes: {}
-            }),
-            state = _React$useState[0],
-            setState = _React$useState[1];
-        var updateStateModifier = React__namespace.useMemo(function() {
-            return {
-                name: "updateState",
-                enabled: true,
-                phase: "write",
-                fn: function fn2(_ref2) {
-                    var state2 = _ref2.state;
-                    var elements = Object.keys(state2.elements);
-                    ReactDOM__namespace.flushSync(function() {
-                        setState({
-                            styles: fromEntries$1(elements.map(function(element2) {
-                                return [element2, state2.styles[element2] || {}];
-                            })),
-                            attributes: fromEntries$1(elements.map(function(element2) {
-                                return [element2, state2.attributes[element2]];
-                            }))
-                        });
-                    });
-                },
-                requires: ["computeStyles"]
-            };
-        }, []);
-        var popperOptions = React__namespace.useMemo(function() {
-            var newOptions = {
-                onFirstUpdate: optionsWithDefaults.onFirstUpdate,
-                placement: optionsWithDefaults.placement,
-                strategy: optionsWithDefaults.strategy,
-                modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
-                    name: "applyStyles",
-                    enabled: false
-                }])
-            };
-            if (reactFastCompare(prevOptions.current, newOptions)) {
-                return prevOptions.current || newOptions;
-            } else {
-                prevOptions.current = newOptions;
-                return newOptions;
-            }
-        }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
-        var popperInstanceRef = React__namespace.useRef();
-        useIsomorphicLayoutEffect$2(function() {
-            if (popperInstanceRef.current) {
-                popperInstanceRef.current.setOptions(popperOptions);
-            }
-        }, [popperOptions]);
-        useIsomorphicLayoutEffect$2(function() {
-            if (referenceElement == null || popperElement == null) {
-                return;
-            }
-            var createPopper$12 = options.createPopper || createPopper;
-            var popperInstance = createPopper$12(referenceElement, popperElement, popperOptions);
-            popperInstanceRef.current = popperInstance;
-            return function() {
-                popperInstance.destroy();
-                popperInstanceRef.current = null;
-            };
-        }, [referenceElement, popperElement, options.createPopper]);
-        return {
-            state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
-            styles: state.styles,
-            attributes: state.attributes,
-            update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
-            forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
-        };
-    };
-    const {
-        stateChangeTypes: stateChangeTypes$3
-    } = useCombobox;
-    const Wrapper$a = styled__default.default.div`
-    display: inline-flex;
-
-    width: 100%;
-    min-width: 4rem;
-    height: 2.5rem;
-
-    border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0px 0px" : "0.25rem"};
-
-    ${(props) => {
-    if (props.isDisabled) {
-      return `
-                border: 1px solid ${props.theme.colors.grey2};
 
-                svg {
-                    color: ${props.theme.colors.grey2};
-                }
-            `;
-    }
-    if (props.isErrored) {
-      return `
-    border: 1 px solid $ {
-        props.theme.colors.error
-    };
-    `;
+    function exitFootnoteDefinition(token) {
+        this.exit(token);
     }
-    return `
-    border: 1 px solid $ {
-        props.isOpen ? props.theme.colors.grey3 : props.theme.colors.grey1
-    };: hover {
-        border: 1 px solid $ {
-            props.theme.colors.grey3
-        };
 
+    function enterFootnoteCall(token) {
+        this.enter({
+            type: "footnoteReference",
+            identifier: "",
+            label: ""
+        }, token);
     }
-    `;
-  }}
-`;
-    const InputWrapper$4 = styled__default.default.div`
-    display: flex;
-    flex: 1 1 auto;
-    align-items: center;
-    justify-content: space-between;
 
-    width: calc(100% - 1rem);
-    height: 100%;
-    padding: 0 0.25rem 0 1rem;
+    function enterFootnoteCallString() {
+        this.buffer();
+    }
 
-    color: ${(props) => props.disabled ? props.theme.colors.grey2 : props.theme.colors.text};
+    function exitFootnoteCallString(token) {
+        const label = this.resume();
+        const node2 = this.stack[this.stack.length - 1];
+        ok$2(node2.type === "footnoteReference");
+        node2.label = label;
+        node2.identifier = normalizeIdentifier(
+            this.sliceSerialize(token)
+        ).toLowerCase();
+    }
 
-    background-color: ${(props) => props.theme.colors.grey1};
-    border: none;
-    border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0px 0px" : "0.25rem"};
+    function exitFootnoteCall(token) {
+        this.exit(token);
+    }
 
-    :hover {
-        background-color: ${(props) => props.disabled ? props.theme.colors.grey1 : props.theme.colors.grey2};
+    function footnoteReference(node2, _2, state, info) {
+        const tracker = state.createTracker(info);
+        let value = tracker.move("[^");
+        const exit2 = state.enter("footnoteReference");
+        const subexit = state.enter("reference");
+        value += tracker.move(
+            state.safe(state.associationId(node2), {
+                ...tracker.current(),
+                before: value,
+                after: "]"
+            })
+        );
+        subexit();
+        exit2();
+        value += tracker.move("]");
+        return value;
     }
 
-    svg {
-        height: 0.8rem;
+    function footnoteReferencePeek() {
+        return "[";
     }
-`;
-    const Input$2 = styled__default.default.input`
-    overflow: hidden;
-    flex: 1 1 auto;
 
-    height: 100%;
-    margin-right: 0.5rem;
-    padding: 0;
+    function footnoteDefinition(node2, _2, state, info) {
+        const tracker = state.createTracker(info);
+        let value = tracker.move("[^");
+        const exit2 = state.enter("footnoteDefinition");
+        const subexit = state.enter("label");
+        value += tracker.move(
+            state.safe(state.associationId(node2), {
+                ...tracker.current(),
+                before: value,
+                after: "]"
+            })
+        );
+        subexit();
+        value += tracker.move(
+            "]:" + (node2.children && node2.children.length > 0 ? " " : "")
+        );
+        tracker.shift(4);
+        value += tracker.move(
+            state.indentLines(state.containerFlow(node2, tracker.current()), map$4)
+        );
+        exit2();
+        return value;
+    }
 
-    font-size: ${(props) => props.size ? `${props.size}rem` : props.theme.font.size};
-    font-weight: 300;
-    color: ${(props) => props.theme.colors.text};
-    text-align: left;
-    text-overflow: ellipsis;
-    white-space: nowrap;
+    function map$4(line, index2, blank) {
+        if (index2 === 0) {
+            return line;
+        }
+        return (blank ? "" : "    ") + line;
+    }
+    const constructsWithoutStrikethrough = [
+        "autolink",
+        "destinationLiteral",
+        "destinationRaw",
+        "reference",
+        "titleQuote",
+        "titleApostrophe"
+    ];
+    handleDelete.peek = peekDelete;
 
-    background-color: transparent;
-    border: none;
-    outline: 0;
+    function gfmStrikethroughFromMarkdown() {
+        return {
+            canContainEols: ["delete"],
+            enter: {
+                strikethrough: enterStrikethrough
+            },
+            exit: {
+                strikethrough: exitStrikethrough
+            }
+        };
+    }
 
-    :disabled {
-        cursor: not-allowed;
-        color: ${(props) => props.theme.colors.grey2};
+    function gfmStrikethroughToMarkdown() {
+        return {
+            unsafe: [{
+                character: "~",
+                inConstruct: "phrasing",
+                notInConstruct: constructsWithoutStrikethrough
+            }],
+            handlers: {
+                delete: handleDelete
+            }
+        };
     }
-`;
-    const NoItemsLabel$1 = styled__default.default.span`
-    display: flex;
-    flex: 1 1 auto;
-    align-items: center;
-    justify-content: center;
 
-    height: 2rem;
+    function enterStrikethrough(token) {
+        this.enter({
+            type: "delete",
+            children: []
+        }, token);
+    }
 
-    font-size: 1rem;
-    color: ${(props) => props.theme.colors.text};
+    function exitStrikethrough(token) {
+        this.exit(token);
+    }
 
-    background-color: ${(props) => props.theme.colors.blue1};
-`;
-    const DropdownList$3 = styled__default.default(List)`
-    margin-left: -1px;
-    border-radius: 0 0 0.25rem 0.25rem;
-    box-shadow: ${(props) => props.theme.shadow.light};
-`;
-    const ChevronButton$1 = styled__default.default(Button$3).attrs((attrs2) => Object.assign(Object.assign({}, attrs2), {
-        styling: "ghost"
-    }))`
-    min-width: 0;
-    height: auto;
-    margin: 0;
-    padding: 0 0.25rem;
+    function handleDelete(node2, _2, state, info) {
+        const tracker = state.createTracker(info);
+        const exit2 = state.enter("strikethrough");
+        let value = tracker.move("~~");
+        value += state.containerPhrasing(node2, {
+            ...tracker.current(),
+            before: value,
+            after: "~"
+        });
+        value += tracker.move("~~");
+        exit2();
+        return value;
+    }
 
-    background-color: transparent !important;
-`;
+    function peekDelete() {
+        return "~";
+    }
 
-    function ComboBox(props) {
-        var _a3, _b, _c, _d, _e2, _f, _g;
-        const referenceElement = React.useRef(null);
-        const popperElement = React.useRef(null);
-        const {
-            styles: styles2,
-            attributes: attributes2,
-            update: update2
-        } = usePopper$1(referenceElement.current, popperElement.current, {
-            modifiers: [sameWidthModifier],
-            placement: "bottom-start"
-        });
-        const [inputValue, setInputValue] = React.useState((_d = (_b = (_a3 = props.initialValue) === null || _a3 === void 0 ? void 0 : _a3.label) !== null && _b !== void 0 ? _b : (_c = props.selectedItem) === null || _c === void 0 ? void 0 : _c.label) !== null && _d !== void 0 ? _d : "");
-        const [pendingHighlight, setPendingHighlight] = React.useState(null);
-        const filteredItems = props.items.filter((item) => {
-            var _a4;
-            return inputValue ? (_a4 = item.label) === null || _a4 === void 0 ? void 0 : _a4.toLowerCase().includes(inputValue === null || inputValue === void 0 ? void 0 : inputValue.toLowerCase()) : true;
-        });
-        const {
-            selectedItem,
-            isOpen,
-            getMenuProps,
-            getInputProps,
-            getToggleButtonProps,
-            highlightedIndex,
-            getItemProps,
-            setHighlightedIndex
-        } = useCombobox(Object.assign({
-            initialIsOpen: props.initialIsOpen,
-            initialSelectedItem: (_e2 = props.initialValue) !== null && _e2 !== void 0 ? _e2 : props.selectedItem,
-            itemToString: (item) => item ? item.label : "",
-            items: filteredItems,
-            onInputValueChange: (change) => {
-                setInputValue(change.inputValue);
-            },
-            onSelectedItemChange: (changes) => {
-                var _a4, _b2;
-                if (props.onSelect) {
-                    if (props.selectedItem && ((_a4 = changes.selectedItem) === null || _a4 === void 0 ? void 0 : _a4.value) !== ((_b2 = props.selectedItem) === null || _b2 === void 0 ? void 0 : _b2.value) || !props.selectedItem) {
-                        props.onSelect(changes.selectedItem);
+    function markdownTable(table2, options = {}) {
+        const align = (options.align || []).concat();
+        const stringLength = options.stringLength || defaultStringLength;
+        const alignments = [];
+        const cellMatrix = [];
+        const sizeMatrix = [];
+        const longestCellByColumn = [];
+        let mostCellsPerRow = 0;
+        let rowIndex = -1;
+        while (++rowIndex < table2.length) {
+            const row2 = [];
+            const sizes2 = [];
+            let columnIndex2 = -1;
+            if (table2[rowIndex].length > mostCellsPerRow) {
+                mostCellsPerRow = table2[rowIndex].length;
+            }
+            while (++columnIndex2 < table2[rowIndex].length) {
+                const cell = serialize(table2[rowIndex][columnIndex2]);
+                if (options.alignDelimiters !== false) {
+                    const size2 = stringLength(cell);
+                    sizes2[columnIndex2] = size2;
+                    if (longestCellByColumn[columnIndex2] === void 0 || size2 > longestCellByColumn[columnIndex2]) {
+                        longestCellByColumn[columnIndex2] = size2;
                     }
                 }
-            },
-            stateReducer: (state, {
-                changes,
-                type: type2
-            }) => {
-                var _a4;
-                if (type2 === stateChangeTypes$3.InputFocus || type2 === stateChangeTypes$3.ToggleButtonClick && changes.isOpen || type2 === stateChangeTypes$3.ControlledPropUpdatedSelectedItem && changes.isOpen) {
-                    setPendingHighlight(changes.selectedItem ? props.items.findIndex((i2) => i2.value === changes.selectedItem.value) : 0);
-                    return Object.assign(Object.assign({}, changes), {
-                        inputValue: ""
-                    });
-                }
-                if ([
-                        stateChangeTypes$3.InputKeyDownEnter,
-                        stateChangeTypes$3.ItemClick,
-                        stateChangeTypes$3.InputBlur,
-                        stateChangeTypes$3.InputKeyDownEscape,
-                        stateChangeTypes$3.ToggleButtonClick
-                    ].includes(type2)) {
-                    return Object.assign(Object.assign({}, changes), {
-                        inputValue: ((_a4 = changes.selectedItem) === null || _a4 === void 0 ? void 0 : _a4.label) || ""
-                    });
-                }
-                return changes;
-            }
-        }, "selectedItem" in props && {
-            selectedItem: props.selectedItem
-        }));
-        React.useEffect(() => {
-            if (isOpen && pendingHighlight !== null) {
-                setHighlightedIndex(pendingHighlight);
-                setPendingHighlight(null);
+                row2.push(cell);
             }
-        }, [isOpen, pendingHighlight, setHighlightedIndex]);
-        React.useEffect(() => {
-            if (props.selectedItem === null) {
-                setInputValue("");
+            cellMatrix[rowIndex] = row2;
+            sizeMatrix[rowIndex] = sizes2;
+        }
+        let columnIndex = -1;
+        if (typeof align === "object" && "length" in align) {
+            while (++columnIndex < mostCellsPerRow) {
+                alignments[columnIndex] = toAlignment(align[columnIndex]);
             }
-        }, [props.selectedItem]);
-        React.useEffect(() => {
-            if (isOpen && update2) {
-                update2();
+        } else {
+            const code2 = toAlignment(align);
+            while (++columnIndex < mostCellsPerRow) {
+                alignments[columnIndex] = code2;
             }
-        }, [isOpen, update2]);
-        const menuProps = getMenuProps();
-        const setMenuRef = menuProps.ref;
-        delete menuProps.ref;
-        const setMenuReference = (value) => {
-            setMenuRef(value);
-            popperElement.current = value;
-        };
-        return jsxRuntime.exports.jsx(Tooltip$1, {
-            content: props.errorMsg,
-            disabled: !props.errorMsg,
-            styling: "error",
-            children: jsxRuntime.exports.jsxs(Wrapper$a, {
-                className: props.className,
-                isDisabled: props.disabled,
-                isErrored: !!props.errorMsg,
-                isOpen,
-                style: props.style,
-                children: [jsxRuntime.exports.jsxs(InputWrapper$4, {
-                    disabled: props.disabled,
-                    isOpen,
-                    ref: referenceElement,
-                    children: [jsxRuntime.exports.jsx(Input$2, Object.assign({}, getInputProps({
-                        disabled: props.disabled
-                    }), {
-                        placeholder: (_f = selectedItem === null ? props.placeholder : selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.label) !== null && _f !== void 0 ? _f : props.placeholder,
-                        size: props.size
-                    })), jsxRuntime.exports.jsx(ChevronButton$1, Object.assign({}, getToggleButtonProps(), {
-                        children: jsxRuntime.exports.jsx(Chevron$2, {
-                            disabled: props.disabled,
-                            isOpen
-                        })
-                    }))]
-                }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsxs(DropdownList$3, Object.assign({}, menuProps, attributes2.popper, {
-                    isOpen,
-                    ref: setMenuReference,
-                    style: Object.assign(Object.assign({}, styles2.popper), {
-                        width: parseFloat((_g = styles2.popper) === null || _g === void 0 ? void 0 : _g.width) + 2,
-                        zIndex: 9999
-                    }),
-                    children: [filteredItems.length > 0 && filteredItems.map((item, index2) => React.createElement(ListItem, Object.assign({}, getItemProps({
-                        index: index2,
-                        item
-                    }), {
-                        hovered: index2 === highlightedIndex,
-                        key: `item-${index2}`,
-                        size: props.size,
-                        title: item.label
-                    }), item.label)), filteredItems.length === 0 && jsxRuntime.exports.jsx(NoItemsLabel$1, {
-                        children: "No Items"
-                    })]
-                })), document.body)]
-            })
-        });
-    }
-    styled__default.default(List)`
-    overflow-y: auto;
-    box-shadow: ${(props) => props.theme.shadow.light};
-`;
-    var dateFormats$1 = {
-        full: "EEEE, d MMMM yyyy",
-        long: "d MMMM yyyy",
-        medium: "d MMM yyyy",
-        short: "dd/MM/yyyy"
-    };
-    var timeFormats$1 = {
-        full: "HH:mm:ss zzzz",
-        long: "HH:mm:ss z",
-        medium: "HH:mm:ss",
-        short: "HH:mm"
-    };
-    var dateTimeFormats$1 = {
-        full: "{{date}} 'at' {{time}}",
-        long: "{{date}} 'at' {{time}}",
-        medium: "{{date}}, {{time}}",
-        short: "{{date}}, {{time}}"
-    };
-    var formatLong$2 = {
-        date: buildFormatLongFn$1({
-            formats: dateFormats$1,
-            defaultWidth: "full"
-        }),
-        time: buildFormatLongFn$1({
-            formats: timeFormats$1,
-            defaultWidth: "full"
-        }),
-        dateTime: buildFormatLongFn$1({
-            formats: dateTimeFormats$1,
-            defaultWidth: "full"
-        })
-    };
-    const formatLong$3 = formatLong$2;
-    var locale$1 = {
-        code: "en-GB",
-        formatDistance: formatDistance$2,
-        formatLong: formatLong$3,
-        formatRelative: formatRelative$2,
-        localize: localize$3,
-        match: match$4,
-        options: {
-            weekStartsOn: 1,
-            firstWeekContainsDate: 4
         }
-    };
-    const enGB = locale$1;
-    var classnames = {
-        exports: {}
-    };
-    /*!
-    	Copyright (c) 2018 Jed Watson.
-    	Licensed under the MIT License (MIT), see
-    	http://jedwatson.github.io/classnames
-    */
-    (function(module2) {
-        (function() {
-            var hasOwn2 = {}.hasOwnProperty;
-
-            function classNames() {
-                var classes = "";
-                for (var i2 = 0; i2 < arguments.length; i2++) {
-                    var arg = arguments[i2];
-                    if (arg) {
-                        classes = appendClass(classes, parseValue(arg));
-                    }
+        columnIndex = -1;
+        const row = [];
+        const sizes = [];
+        while (++columnIndex < mostCellsPerRow) {
+            const code2 = alignments[columnIndex];
+            let before = "";
+            let after = "";
+            if (code2 === 99) {
+                before = ":";
+                after = ":";
+            } else if (code2 === 108) {
+                before = ":";
+            } else if (code2 === 114) {
+                after = ":";
+            }
+            let size2 = options.alignDelimiters === false ? 1 : Math.max(
+                1,
+                longestCellByColumn[columnIndex] - before.length - after.length
+            );
+            const cell = before + "-".repeat(size2) + after;
+            if (options.alignDelimiters !== false) {
+                size2 = before.length + size2 + after.length;
+                if (size2 > longestCellByColumn[columnIndex]) {
+                    longestCellByColumn[columnIndex] = size2;
                 }
-                return classes;
+                sizes[columnIndex] = size2;
             }
-
-            function parseValue(arg) {
-                if (typeof arg === "string" || typeof arg === "number") {
-                    return arg;
+            row[columnIndex] = cell;
+        }
+        cellMatrix.splice(1, 0, row);
+        sizeMatrix.splice(1, 0, sizes);
+        rowIndex = -1;
+        const lines = [];
+        while (++rowIndex < cellMatrix.length) {
+            const row2 = cellMatrix[rowIndex];
+            const sizes2 = sizeMatrix[rowIndex];
+            columnIndex = -1;
+            const line = [];
+            while (++columnIndex < mostCellsPerRow) {
+                const cell = row2[columnIndex] || "";
+                let before = "";
+                let after = "";
+                if (options.alignDelimiters !== false) {
+                    const size2 = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
+                    const code2 = alignments[columnIndex];
+                    if (code2 === 114) {
+                        before = " ".repeat(size2);
+                    } else if (code2 === 99) {
+                        if (size2 % 2) {
+                            before = " ".repeat(size2 / 2 + 0.5);
+                            after = " ".repeat(size2 / 2 - 0.5);
+                        } else {
+                            before = " ".repeat(size2 / 2);
+                            after = before;
+                        }
+                    } else {
+                        after = " ".repeat(size2);
+                    }
                 }
-                if (typeof arg !== "object") {
-                    return "";
+                if (options.delimiterStart !== false && !columnIndex) {
+                    line.push("|");
                 }
-                if (Array.isArray(arg)) {
-                    return classNames.apply(null, arg);
+                if (options.padding !== false && !(options.alignDelimiters === false && cell === "") && (options.delimiterStart !== false || columnIndex)) {
+                    line.push(" ");
                 }
-                if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
-                    return arg.toString();
+                if (options.alignDelimiters !== false) {
+                    line.push(before);
                 }
-                var classes = "";
-                for (var key in arg) {
-                    if (hasOwn2.call(arg, key) && arg[key]) {
-                        classes = appendClass(classes, key);
-                    }
+                line.push(cell);
+                if (options.alignDelimiters !== false) {
+                    line.push(after);
                 }
-                return classes;
-            }
-
-            function appendClass(value, newClass) {
-                if (!newClass) {
-                    return value;
+                if (options.padding !== false) {
+                    line.push(" ");
                 }
-                if (value) {
-                    return value + " " + newClass;
+                if (options.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
+                    line.push("|");
                 }
-                return value + newClass;
-            }
-            if (module2.exports) {
-                classNames.default = classNames;
-                module2.exports = classNames;
-            } else {
-                window.classNames = classNames;
             }
-        })();
-    })(classnames);
-    const r$1 = classnames.exports;
+            lines.push(
+                options.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join("")
+            );
+        }
+        return lines.join("\n");
+    }
 
-    function _typeof$5(o2) {
-        "@babel/helpers - typeof";
-        return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
-            return typeof o3;
-        } : function(o3) {
-            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
-        }, _typeof$5(o2);
+    function serialize(value) {
+        return value === null || value === void 0 ? "" : String(value);
     }
 
-    function requiredArgs(required2, args) {
-        if (args.length < required2) {
-            throw new TypeError(required2 + " argument" + (required2 > 1 ? "s" : "") + " required, but only " + args.length + " present");
-        }
+    function defaultStringLength(value) {
+        return value.length;
     }
 
-    function isDate$1(value) {
-        requiredArgs(1, arguments);
-        return value instanceof Date || _typeof$5(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
+    function toAlignment(value) {
+        const code2 = typeof value === "string" ? value.codePointAt(0) : 0;
+        return code2 === 67 || code2 === 99 ? 99 : code2 === 76 || code2 === 108 ? 108 : code2 === 82 || code2 === 114 ? 114 : 0;
     }
+    const own$3 = {}.hasOwnProperty;
 
-    function toDate(argument) {
-        requiredArgs(1, arguments);
-        var argStr = Object.prototype.toString.call(argument);
-        if (argument instanceof Date || _typeof$5(argument) === "object" && argStr === "[object Date]") {
-            return new Date(argument.getTime());
-        } else if (typeof argument === "number" || argStr === "[object Number]") {
-            return new Date(argument);
-        } else {
-            if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
-                console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
-                console.warn(new Error().stack);
+    function zwitch(key, options) {
+        const settings2 = options || {};
+
+        function one2(value, ...parameters) {
+            let fn2 = one2.invalid;
+            const handlers2 = one2.handlers;
+            if (value && own$3.call(value, key)) {
+                const id2 = String(value[key]);
+                fn2 = own$3.call(handlers2, id2) ? handlers2[id2] : one2.unknown;
+            }
+            if (fn2) {
+                return fn2.call(this, value, ...parameters);
             }
-            return new Date(NaN);
         }
+        one2.handlers = settings2.handlers || {};
+        one2.invalid = settings2.invalid;
+        one2.unknown = settings2.unknown;
+        return one2;
     }
 
-    function isValid(dirtyDate) {
-        requiredArgs(1, arguments);
-        if (!isDate$1(dirtyDate) && typeof dirtyDate !== "number") {
-            return false;
-        }
-        var date = toDate(dirtyDate);
-        return !isNaN(Number(date));
+    function blockquote(node2, _2, state, info) {
+        const exit2 = state.enter("blockquote");
+        const tracker = state.createTracker(info);
+        tracker.move("> ");
+        tracker.shift(2);
+        const value = state.indentLines(
+            state.containerFlow(node2, tracker.current()),
+            map$3
+        );
+        exit2();
+        return value;
     }
 
-    function toInteger$2(dirtyNumber) {
-        if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
-            return NaN;
-        }
-        var number2 = Number(dirtyNumber);
-        if (isNaN(number2)) {
-            return number2;
-        }
-        return number2 < 0 ? Math.ceil(number2) : Math.floor(number2);
+    function map$3(line, _2, blank) {
+        return ">" + (blank ? "" : " ") + line;
     }
 
-    function addMilliseconds(dirtyDate, dirtyAmount) {
-        requiredArgs(2, arguments);
-        var timestamp = toDate(dirtyDate).getTime();
-        var amount = toInteger$2(dirtyAmount);
-        return new Date(timestamp + amount);
+    function patternInScope(stack, pattern) {
+        return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
     }
 
-    function subMilliseconds(dirtyDate, dirtyAmount) {
-        requiredArgs(2, arguments);
-        var amount = toInteger$2(dirtyAmount);
-        return addMilliseconds(dirtyDate, -amount);
+    function listInScope(stack, list2, none2) {
+        if (typeof list2 === "string") {
+            list2 = [list2];
+        }
+        if (!list2 || list2.length === 0) {
+            return none2;
+        }
+        let index2 = -1;
+        while (++index2 < list2.length) {
+            if (stack.includes(list2[index2])) {
+                return true;
+            }
+        }
+        return false;
     }
-    var MILLISECONDS_IN_DAY$1 = 864e5;
 
-    function getUTCDayOfYear(dirtyDate) {
-        requiredArgs(1, arguments);
-        var date = toDate(dirtyDate);
-        var timestamp = date.getTime();
-        date.setUTCMonth(0, 1);
-        date.setUTCHours(0, 0, 0, 0);
-        var startOfYearTimestamp = date.getTime();
-        var difference = timestamp - startOfYearTimestamp;
-        return Math.floor(difference / MILLISECONDS_IN_DAY$1) + 1;
+    function hardBreak(_2, _1, state, info) {
+        let index2 = -1;
+        while (++index2 < state.unsafe.length) {
+            if (state.unsafe[index2].character === "\n" && patternInScope(state.stack, state.unsafe[index2])) {
+                return /[ \t]/.test(info.before) ? "" : " ";
+            }
+        }
+        return "\\\n";
     }
 
-    function startOfUTCISOWeek(dirtyDate) {
-        requiredArgs(1, arguments);
-        var weekStartsOn = 1;
-        var date = toDate(dirtyDate);
-        var day = date.getUTCDay();
-        var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
-        date.setUTCDate(date.getUTCDate() - diff);
-        date.setUTCHours(0, 0, 0, 0);
-        return date;
+    function longestStreak(value, substring) {
+        const source = String(value);
+        let index2 = source.indexOf(substring);
+        let expected = index2;
+        let count2 = 0;
+        let max2 = 0;
+        if (typeof substring !== "string") {
+            throw new TypeError("Expected substring");
+        }
+        while (index2 !== -1) {
+            if (index2 === expected) {
+                if (++count2 > max2) {
+                    max2 = count2;
+                }
+            } else {
+                count2 = 1;
+            }
+            expected = index2 + substring.length;
+            index2 = source.indexOf(substring, expected);
+        }
+        return max2;
     }
 
-    function getUTCISOWeekYear(dirtyDate) {
-        requiredArgs(1, arguments);
-        var date = toDate(dirtyDate);
-        var year = date.getUTCFullYear();
-        var fourthOfJanuaryOfNextYear = new Date(0);
-        fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
-        fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
-        var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
-        var fourthOfJanuaryOfThisYear = new Date(0);
-        fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
-        fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
-        var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
-        if (date.getTime() >= startOfNextYear.getTime()) {
-            return year + 1;
-        } else if (date.getTime() >= startOfThisYear.getTime()) {
-            return year;
-        } else {
-            return year - 1;
-        }
+    function formatCodeAsIndented(node2, state) {
+        return Boolean(
+            state.options.fences === false && node2.value && !node2.lang && /[^ \r\n]/.test(node2.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
+        );
     }
 
-    function startOfUTCISOWeekYear(dirtyDate) {
-        requiredArgs(1, arguments);
-        var year = getUTCISOWeekYear(dirtyDate);
-        var fourthOfJanuary = new Date(0);
-        fourthOfJanuary.setUTCFullYear(year, 0, 4);
-        fourthOfJanuary.setUTCHours(0, 0, 0, 0);
-        var date = startOfUTCISOWeek(fourthOfJanuary);
-        return date;
+    function checkFence(state) {
+        const marker = state.options.fence || "`";
+        if (marker !== "`" && marker !== "~") {
+            throw new Error(
+                "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
+            );
+        }
+        return marker;
     }
-    var MILLISECONDS_IN_WEEK$2 = 6048e5;
 
-    function getUTCISOWeek(dirtyDate) {
-        requiredArgs(1, arguments);
-        var date = toDate(dirtyDate);
-        var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
-        return Math.round(diff / MILLISECONDS_IN_WEEK$2) + 1;
+    function code$2(node2, _2, state, info) {
+        const marker = checkFence(state);
+        const raw2 = node2.value || "";
+        const suffix = marker === "`" ? "GraveAccent" : "Tilde";
+        if (formatCodeAsIndented(node2, state)) {
+            const exit3 = state.enter("codeIndented");
+            const value2 = state.indentLines(raw2, map$2);
+            exit3();
+            return value2;
+        }
+        const tracker = state.createTracker(info);
+        const sequence = marker.repeat(Math.max(longestStreak(raw2, marker) + 1, 3));
+        const exit2 = state.enter("codeFenced");
+        let value = tracker.move(sequence);
+        if (node2.lang) {
+            const subexit = state.enter(`codeFencedLang${suffix}`);
+            value += tracker.move(
+                state.safe(node2.lang, {
+                    before: value,
+                    after: " ",
+                    encode: ["`"],
+                    ...tracker.current()
+                })
+            );
+            subexit();
+        }
+        if (node2.lang && node2.meta) {
+            const subexit = state.enter(`codeFencedMeta${suffix}`);
+            value += tracker.move(" ");
+            value += tracker.move(
+                state.safe(node2.meta, {
+                    before: value,
+                    after: "\n",
+                    encode: ["`"],
+                    ...tracker.current()
+                })
+            );
+            subexit();
+        }
+        value += tracker.move("\n");
+        if (raw2) {
+            value += tracker.move(raw2 + "\n");
+        }
+        value += tracker.move(sequence);
+        exit2();
+        return value;
     }
-    var defaultOptions = {};
 
-    function getDefaultOptions() {
-        return defaultOptions;
+    function map$2(line, _2, blank) {
+        return (blank ? "" : "    ") + line;
     }
 
-    function startOfUTCWeek(dirtyDate, options) {
-        var _ref2, _ref22, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
-        requiredArgs(1, arguments);
-        var defaultOptions2 = getDefaultOptions();
-        var weekStartsOn = toInteger$2((_ref2 = (_ref22 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : 0);
-        if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
-            throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
+    function checkQuote(state) {
+        const marker = state.options.quote || '"';
+        if (marker !== '"' && marker !== "'") {
+            throw new Error(
+                "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
+            );
         }
-        var date = toDate(dirtyDate);
-        var day = date.getUTCDay();
-        var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
-        date.setUTCDate(date.getUTCDate() - diff);
-        date.setUTCHours(0, 0, 0, 0);
-        return date;
+        return marker;
     }
 
-    function getUTCWeekYear(dirtyDate, options) {
-        var _ref2, _ref22, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
-        requiredArgs(1, arguments);
-        var date = toDate(dirtyDate);
-        var year = date.getUTCFullYear();
-        var defaultOptions2 = getDefaultOptions();
-        var firstWeekContainsDate = toInteger$2((_ref2 = (_ref22 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
-        if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
-            throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
-        }
-        var firstWeekOfNextYear = new Date(0);
-        firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
-        firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
-        var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
-        var firstWeekOfThisYear = new Date(0);
-        firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
-        firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
-        var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
-        if (date.getTime() >= startOfNextYear.getTime()) {
-            return year + 1;
-        } else if (date.getTime() >= startOfThisYear.getTime()) {
-            return year;
+    function definition(node2, _2, state, info) {
+        const quote2 = checkQuote(state);
+        const suffix = quote2 === '"' ? "Quote" : "Apostrophe";
+        const exit2 = state.enter("definition");
+        let subexit = state.enter("label");
+        const tracker = state.createTracker(info);
+        let value = tracker.move("[");
+        value += tracker.move(
+            state.safe(state.associationId(node2), {
+                before: value,
+                after: "]",
+                ...tracker.current()
+            })
+        );
+        value += tracker.move("]: ");
+        subexit();
+        if (!node2.url || /[\0- \u007F]/.test(node2.url)) {
+            subexit = state.enter("destinationLiteral");
+            value += tracker.move("<");
+            value += tracker.move(
+                state.safe(node2.url, {
+                    before: value,
+                    after: ">",
+                    ...tracker.current()
+                })
+            );
+            value += tracker.move(">");
         } else {
-            return year - 1;
+            subexit = state.enter("destinationRaw");
+            value += tracker.move(
+                state.safe(node2.url, {
+                    before: value,
+                    after: node2.title ? " " : "\n",
+                    ...tracker.current()
+                })
+            );
+        }
+        subexit();
+        if (node2.title) {
+            subexit = state.enter(`title${suffix}`);
+            value += tracker.move(" " + quote2);
+            value += tracker.move(
+                state.safe(node2.title, {
+                    before: value,
+                    after: quote2,
+                    ...tracker.current()
+                })
+            );
+            value += tracker.move(quote2);
+            subexit();
         }
+        exit2();
+        return value;
     }
 
-    function startOfUTCWeekYear(dirtyDate, options) {
-        var _ref2, _ref22, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
-        requiredArgs(1, arguments);
-        var defaultOptions2 = getDefaultOptions();
-        var firstWeekContainsDate = toInteger$2((_ref2 = (_ref22 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
-        var year = getUTCWeekYear(dirtyDate, options);
-        var firstWeek = new Date(0);
-        firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
-        firstWeek.setUTCHours(0, 0, 0, 0);
-        var date = startOfUTCWeek(firstWeek, options);
-        return date;
+    function checkEmphasis(state) {
+        const marker = state.options.emphasis || "*";
+        if (marker !== "*" && marker !== "_") {
+            throw new Error(
+                "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
+            );
+        }
+        return marker;
     }
-    var MILLISECONDS_IN_WEEK$1 = 6048e5;
+    emphasis.peek = emphasisPeek;
 
-    function getUTCWeek(dirtyDate, options) {
-        requiredArgs(1, arguments);
-        var date = toDate(dirtyDate);
-        var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
-        return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
+    function emphasis(node2, _2, state, info) {
+        const marker = checkEmphasis(state);
+        const exit2 = state.enter("emphasis");
+        const tracker = state.createTracker(info);
+        let value = tracker.move(marker);
+        value += tracker.move(
+            state.containerPhrasing(node2, {
+                before: value,
+                after: marker,
+                ...tracker.current()
+            })
+        );
+        value += tracker.move(marker);
+        exit2();
+        return value;
     }
 
-    function addLeadingZeros(number2, targetLength) {
-        var sign2 = number2 < 0 ? "-" : "";
-        var output2 = Math.abs(number2).toString();
-        while (output2.length < targetLength) {
-            output2 = "0" + output2;
-        }
-        return sign2 + output2;
+    function emphasisPeek(_2, _1, state) {
+        return state.options.emphasis || "*";
     }
-    var formatters$2 = {
-        y: function y2(date, token) {
-            var signedYear = date.getUTCFullYear();
-            var year = signedYear > 0 ? signedYear : 1 - signedYear;
-            return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
-        },
-        M: function M2(date, token) {
-            var month = date.getUTCMonth();
-            return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
-        },
-        d: function d2(date, token) {
-            return addLeadingZeros(date.getUTCDate(), token.length);
-        },
-        a: function a2(date, token) {
-            var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
-            switch (token) {
-                case "a":
-                case "aa":
-                    return dayPeriodEnumValue.toUpperCase();
-                case "aaa":
-                    return dayPeriodEnumValue;
-                case "aaaaa":
-                    return dayPeriodEnumValue[0];
-                case "aaaa":
-                default:
-                    return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
+
+    function formatHeadingAsSetext(node2, state) {
+        let literalWithBreak = false;
+        visit$1(node2, function(node3) {
+            if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
+                literalWithBreak = true;
+                return EXIT$1;
             }
-        },
-        h: function h2(date, token) {
-            return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
-        },
-        H: function H2(date, token) {
-            return addLeadingZeros(date.getUTCHours(), token.length);
-        },
-        m: function m2(date, token) {
-            return addLeadingZeros(date.getUTCMinutes(), token.length);
-        },
-        s: function s2(date, token) {
-            return addLeadingZeros(date.getUTCSeconds(), token.length);
-        },
-        S: function S2(date, token) {
-            var numberOfDigits = token.length;
-            var milliseconds = date.getUTCMilliseconds();
-            var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
-            return addLeadingZeros(fractionalSeconds, token.length);
+        });
+        return Boolean(
+            (!node2.depth || node2.depth < 3) && toString$6(node2) && (state.options.setext || literalWithBreak)
+        );
+    }
+
+    function heading$1(node2, _2, state, info) {
+        const rank = Math.max(Math.min(6, node2.depth || 1), 1);
+        const tracker = state.createTracker(info);
+        if (formatHeadingAsSetext(node2, state)) {
+            const exit3 = state.enter("headingSetext");
+            const subexit2 = state.enter("phrasing");
+            const value2 = state.containerPhrasing(node2, {
+                ...tracker.current(),
+                before: "\n",
+                after: "\n"
+            });
+            subexit2();
+            exit3();
+            return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
+                value2.length - (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
+            );
         }
-    };
-    const lightFormatters = formatters$2;
-    var dayPeriodEnum = {
-        am: "am",
-        pm: "pm",
-        midnight: "midnight",
-        noon: "noon",
-        morning: "morning",
-        afternoon: "afternoon",
-        evening: "evening",
-        night: "night"
-    };
-    var formatters = {
-        G: function G2(date, token, localize2) {
-            var era = date.getUTCFullYear() > 0 ? 1 : 0;
-            switch (token) {
-                case "G":
-                case "GG":
-                case "GGG":
-                    return localize2.era(era, {
-                        width: "abbreviated"
-                    });
-                case "GGGGG":
-                    return localize2.era(era, {
-                        width: "narrow"
-                    });
-                case "GGGG":
-                default:
-                    return localize2.era(era, {
-                        width: "wide"
-                    });
-            }
-        },
-        y: function y2(date, token, localize2) {
-            if (token === "yo") {
-                var signedYear = date.getUTCFullYear();
-                var year = signedYear > 0 ? signedYear : 1 - signedYear;
-                return localize2.ordinalNumber(year, {
-                    unit: "year"
-                });
-            }
-            return lightFormatters.y(date, token);
-        },
-        Y: function Y2(date, token, localize2, options) {
-            var signedWeekYear = getUTCWeekYear(date, options);
-            var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
-            if (token === "YY") {
-                var twoDigitYear = weekYear % 100;
-                return addLeadingZeros(twoDigitYear, 2);
-            }
-            if (token === "Yo") {
-                return localize2.ordinalNumber(weekYear, {
-                    unit: "year"
-                });
-            }
-            return addLeadingZeros(weekYear, token.length);
-        },
-        R: function R2(date, token) {
-            var isoWeekYear = getUTCISOWeekYear(date);
-            return addLeadingZeros(isoWeekYear, token.length);
-        },
-        u: function u2(date, token) {
-            var year = date.getUTCFullYear();
-            return addLeadingZeros(year, token.length);
-        },
-        Q: function Q2(date, token, localize2) {
-            var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
-            switch (token) {
-                case "Q":
-                    return String(quarter);
-                case "QQ":
-                    return addLeadingZeros(quarter, 2);
-                case "Qo":
-                    return localize2.ordinalNumber(quarter, {
-                        unit: "quarter"
-                    });
-                case "QQQ":
-                    return localize2.quarter(quarter, {
-                        width: "abbreviated",
-                        context: "formatting"
-                    });
-                case "QQQQQ":
-                    return localize2.quarter(quarter, {
-                        width: "narrow",
-                        context: "formatting"
-                    });
-                case "QQQQ":
-                default:
-                    return localize2.quarter(quarter, {
-                        width: "wide",
-                        context: "formatting"
-                    });
-            }
-        },
-        q: function q2(date, token, localize2) {
-            var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
-            switch (token) {
-                case "q":
-                    return String(quarter);
-                case "qq":
-                    return addLeadingZeros(quarter, 2);
-                case "qo":
-                    return localize2.ordinalNumber(quarter, {
-                        unit: "quarter"
-                    });
-                case "qqq":
-                    return localize2.quarter(quarter, {
-                        width: "abbreviated",
-                        context: "standalone"
-                    });
-                case "qqqqq":
-                    return localize2.quarter(quarter, {
-                        width: "narrow",
-                        context: "standalone"
-                    });
-                case "qqqq":
-                default:
-                    return localize2.quarter(quarter, {
-                        width: "wide",
-                        context: "standalone"
-                    });
-            }
-        },
-        M: function M2(date, token, localize2) {
-            var month = date.getUTCMonth();
-            switch (token) {
-                case "M":
-                case "MM":
-                    return lightFormatters.M(date, token);
-                case "Mo":
-                    return localize2.ordinalNumber(month + 1, {
-                        unit: "month"
-                    });
-                case "MMM":
-                    return localize2.month(month, {
-                        width: "abbreviated",
-                        context: "formatting"
-                    });
-                case "MMMMM":
-                    return localize2.month(month, {
-                        width: "narrow",
-                        context: "formatting"
-                    });
-                case "MMMM":
-                default:
-                    return localize2.month(month, {
-                        width: "wide",
-                        context: "formatting"
-                    });
-            }
-        },
-        L: function L2(date, token, localize2) {
-            var month = date.getUTCMonth();
-            switch (token) {
-                case "L":
-                    return String(month + 1);
-                case "LL":
-                    return addLeadingZeros(month + 1, 2);
-                case "Lo":
-                    return localize2.ordinalNumber(month + 1, {
-                        unit: "month"
-                    });
-                case "LLL":
-                    return localize2.month(month, {
-                        width: "abbreviated",
-                        context: "standalone"
-                    });
-                case "LLLLL":
-                    return localize2.month(month, {
-                        width: "narrow",
-                        context: "standalone"
-                    });
-                case "LLLL":
-                default:
-                    return localize2.month(month, {
-                        width: "wide",
-                        context: "standalone"
-                    });
-            }
-        },
-        w: function w2(date, token, localize2, options) {
-            var week = getUTCWeek(date, options);
-            if (token === "wo") {
-                return localize2.ordinalNumber(week, {
-                    unit: "week"
-                });
-            }
-            return addLeadingZeros(week, token.length);
-        },
-        I: function I2(date, token, localize2) {
-            var isoWeek = getUTCISOWeek(date);
-            if (token === "Io") {
-                return localize2.ordinalNumber(isoWeek, {
-                    unit: "week"
-                });
-            }
-            return addLeadingZeros(isoWeek, token.length);
-        },
-        d: function d2(date, token, localize2) {
-            if (token === "do") {
-                return localize2.ordinalNumber(date.getUTCDate(), {
-                    unit: "date"
-                });
-            }
-            return lightFormatters.d(date, token);
-        },
-        D: function D2(date, token, localize2) {
-            var dayOfYear = getUTCDayOfYear(date);
-            if (token === "Do") {
-                return localize2.ordinalNumber(dayOfYear, {
-                    unit: "dayOfYear"
-                });
-            }
-            return addLeadingZeros(dayOfYear, token.length);
-        },
-        E: function E2(date, token, localize2) {
-            var dayOfWeek = date.getUTCDay();
-            switch (token) {
-                case "E":
-                case "EE":
-                case "EEE":
-                    return localize2.day(dayOfWeek, {
-                        width: "abbreviated",
-                        context: "formatting"
-                    });
-                case "EEEEE":
-                    return localize2.day(dayOfWeek, {
-                        width: "narrow",
-                        context: "formatting"
-                    });
-                case "EEEEEE":
-                    return localize2.day(dayOfWeek, {
-                        width: "short",
-                        context: "formatting"
-                    });
-                case "EEEE":
-                default:
-                    return localize2.day(dayOfWeek, {
-                        width: "wide",
-                        context: "formatting"
-                    });
-            }
-        },
-        e: function e3(date, token, localize2, options) {
-            var dayOfWeek = date.getUTCDay();
-            var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
-            switch (token) {
-                case "e":
-                    return String(localDayOfWeek);
-                case "ee":
-                    return addLeadingZeros(localDayOfWeek, 2);
-                case "eo":
-                    return localize2.ordinalNumber(localDayOfWeek, {
-                        unit: "day"
-                    });
-                case "eee":
-                    return localize2.day(dayOfWeek, {
-                        width: "abbreviated",
-                        context: "formatting"
-                    });
-                case "eeeee":
-                    return localize2.day(dayOfWeek, {
-                        width: "narrow",
-                        context: "formatting"
-                    });
-                case "eeeeee":
-                    return localize2.day(dayOfWeek, {
-                        width: "short",
-                        context: "formatting"
-                    });
-                case "eeee":
-                default:
-                    return localize2.day(dayOfWeek, {
-                        width: "wide",
-                        context: "formatting"
-                    });
-            }
-        },
-        c: function c2(date, token, localize2, options) {
-            var dayOfWeek = date.getUTCDay();
-            var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
-            switch (token) {
-                case "c":
-                    return String(localDayOfWeek);
-                case "cc":
-                    return addLeadingZeros(localDayOfWeek, token.length);
-                case "co":
-                    return localize2.ordinalNumber(localDayOfWeek, {
-                        unit: "day"
-                    });
-                case "ccc":
-                    return localize2.day(dayOfWeek, {
-                        width: "abbreviated",
-                        context: "standalone"
-                    });
-                case "ccccc":
-                    return localize2.day(dayOfWeek, {
-                        width: "narrow",
-                        context: "standalone"
-                    });
-                case "cccccc":
-                    return localize2.day(dayOfWeek, {
-                        width: "short",
-                        context: "standalone"
-                    });
-                case "cccc":
-                default:
-                    return localize2.day(dayOfWeek, {
-                        width: "wide",
-                        context: "standalone"
-                    });
-            }
-        },
-        i: function i2(date, token, localize2) {
-            var dayOfWeek = date.getUTCDay();
-            var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
-            switch (token) {
-                case "i":
-                    return String(isoDayOfWeek);
-                case "ii":
-                    return addLeadingZeros(isoDayOfWeek, token.length);
-                case "io":
-                    return localize2.ordinalNumber(isoDayOfWeek, {
-                        unit: "day"
-                    });
-                case "iii":
-                    return localize2.day(dayOfWeek, {
-                        width: "abbreviated",
-                        context: "formatting"
-                    });
-                case "iiiii":
-                    return localize2.day(dayOfWeek, {
-                        width: "narrow",
-                        context: "formatting"
-                    });
-                case "iiiiii":
-                    return localize2.day(dayOfWeek, {
-                        width: "short",
-                        context: "formatting"
-                    });
-                case "iiii":
-                default:
-                    return localize2.day(dayOfWeek, {
-                        width: "wide",
-                        context: "formatting"
-                    });
-            }
-        },
-        a: function a2(date, token, localize2) {
-            var hours = date.getUTCHours();
-            var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
-            switch (token) {
-                case "a":
-                case "aa":
-                    return localize2.dayPeriod(dayPeriodEnumValue, {
-                        width: "abbreviated",
-                        context: "formatting"
-                    });
-                case "aaa":
-                    return localize2.dayPeriod(dayPeriodEnumValue, {
-                        width: "abbreviated",
-                        context: "formatting"
-                    }).toLowerCase();
-                case "aaaaa":
-                    return localize2.dayPeriod(dayPeriodEnumValue, {
-                        width: "narrow",
-                        context: "formatting"
-                    });
-                case "aaaa":
-                default:
-                    return localize2.dayPeriod(dayPeriodEnumValue, {
-                        width: "wide",
-                        context: "formatting"
-                    });
-            }
-        },
-        b: function b2(date, token, localize2) {
-            var hours = date.getUTCHours();
-            var dayPeriodEnumValue;
-            if (hours === 12) {
-                dayPeriodEnumValue = dayPeriodEnum.noon;
-            } else if (hours === 0) {
-                dayPeriodEnumValue = dayPeriodEnum.midnight;
-            } else {
-                dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
-            }
-            switch (token) {
-                case "b":
-                case "bb":
-                    return localize2.dayPeriod(dayPeriodEnumValue, {
-                        width: "abbreviated",
-                        context: "formatting"
-                    });
-                case "bbb":
-                    return localize2.dayPeriod(dayPeriodEnumValue, {
-                        width: "abbreviated",
-                        context: "formatting"
-                    }).toLowerCase();
-                case "bbbbb":
-                    return localize2.dayPeriod(dayPeriodEnumValue, {
-                        width: "narrow",
-                        context: "formatting"
-                    });
-                case "bbbb":
-                default:
-                    return localize2.dayPeriod(dayPeriodEnumValue, {
-                        width: "wide",
-                        context: "formatting"
-                    });
-            }
-        },
-        B: function B2(date, token, localize2) {
-            var hours = date.getUTCHours();
-            var dayPeriodEnumValue;
-            if (hours >= 17) {
-                dayPeriodEnumValue = dayPeriodEnum.evening;
-            } else if (hours >= 12) {
-                dayPeriodEnumValue = dayPeriodEnum.afternoon;
-            } else if (hours >= 4) {
-                dayPeriodEnumValue = dayPeriodEnum.morning;
-            } else {
-                dayPeriodEnumValue = dayPeriodEnum.night;
-            }
-            switch (token) {
-                case "B":
-                case "BB":
-                case "BBB":
-                    return localize2.dayPeriod(dayPeriodEnumValue, {
-                        width: "abbreviated",
-                        context: "formatting"
-                    });
-                case "BBBBB":
-                    return localize2.dayPeriod(dayPeriodEnumValue, {
-                        width: "narrow",
-                        context: "formatting"
-                    });
-                case "BBBB":
-                default:
-                    return localize2.dayPeriod(dayPeriodEnumValue, {
-                        width: "wide",
-                        context: "formatting"
-                    });
-            }
-        },
-        h: function h2(date, token, localize2) {
-            if (token === "ho") {
-                var hours = date.getUTCHours() % 12;
-                if (hours === 0)
-                    hours = 12;
-                return localize2.ordinalNumber(hours, {
-                    unit: "hour"
-                });
-            }
-            return lightFormatters.h(date, token);
-        },
-        H: function H2(date, token, localize2) {
-            if (token === "Ho") {
-                return localize2.ordinalNumber(date.getUTCHours(), {
-                    unit: "hour"
-                });
-            }
-            return lightFormatters.H(date, token);
-        },
-        K: function K2(date, token, localize2) {
-            var hours = date.getUTCHours() % 12;
-            if (token === "Ko") {
-                return localize2.ordinalNumber(hours, {
-                    unit: "hour"
-                });
-            }
-            return addLeadingZeros(hours, token.length);
-        },
-        k: function k2(date, token, localize2) {
-            var hours = date.getUTCHours();
-            if (hours === 0)
-                hours = 24;
-            if (token === "ko") {
-                return localize2.ordinalNumber(hours, {
-                    unit: "hour"
-                });
-            }
-            return addLeadingZeros(hours, token.length);
-        },
-        m: function m2(date, token, localize2) {
-            if (token === "mo") {
-                return localize2.ordinalNumber(date.getUTCMinutes(), {
-                    unit: "minute"
-                });
-            }
-            return lightFormatters.m(date, token);
-        },
-        s: function s2(date, token, localize2) {
-            if (token === "so") {
-                return localize2.ordinalNumber(date.getUTCSeconds(), {
-                    unit: "second"
-                });
-            }
-            return lightFormatters.s(date, token);
-        },
-        S: function S2(date, token) {
-            return lightFormatters.S(date, token);
-        },
-        X: function X2(date, token, _localize, options) {
-            var originalDate = options._originalDate || date;
-            var timezoneOffset = originalDate.getTimezoneOffset();
-            if (timezoneOffset === 0) {
-                return "Z";
-            }
-            switch (token) {
-                case "X":
-                    return formatTimezoneWithOptionalMinutes(timezoneOffset);
-                case "XXXX":
-                case "XX":
-                    return formatTimezone(timezoneOffset);
-                case "XXXXX":
-                case "XXX":
-                default:
-                    return formatTimezone(timezoneOffset, ":");
-            }
-        },
-        x: function x2(date, token, _localize, options) {
-            var originalDate = options._originalDate || date;
-            var timezoneOffset = originalDate.getTimezoneOffset();
-            switch (token) {
-                case "x":
-                    return formatTimezoneWithOptionalMinutes(timezoneOffset);
-                case "xxxx":
-                case "xx":
-                    return formatTimezone(timezoneOffset);
-                case "xxxxx":
-                case "xxx":
-                default:
-                    return formatTimezone(timezoneOffset, ":");
-            }
-        },
-        O: function O2(date, token, _localize, options) {
-            var originalDate = options._originalDate || date;
-            var timezoneOffset = originalDate.getTimezoneOffset();
-            switch (token) {
-                case "O":
-                case "OO":
-                case "OOO":
-                    return "GMT" + formatTimezoneShort(timezoneOffset, ":");
-                case "OOOO":
-                default:
-                    return "GMT" + formatTimezone(timezoneOffset, ":");
-            }
-        },
-        z: function z2(date, token, _localize, options) {
-            var originalDate = options._originalDate || date;
-            var timezoneOffset = originalDate.getTimezoneOffset();
-            switch (token) {
-                case "z":
-                case "zz":
-                case "zzz":
-                    return "GMT" + formatTimezoneShort(timezoneOffset, ":");
-                case "zzzz":
-                default:
-                    return "GMT" + formatTimezone(timezoneOffset, ":");
-            }
-        },
-        t: function t2(date, token, _localize, options) {
-            var originalDate = options._originalDate || date;
-            var timestamp = Math.floor(originalDate.getTime() / 1e3);
-            return addLeadingZeros(timestamp, token.length);
-        },
-        T: function T2(date, token, _localize, options) {
-            var originalDate = options._originalDate || date;
-            var timestamp = originalDate.getTime();
-            return addLeadingZeros(timestamp, token.length);
+        const sequence = "#".repeat(rank);
+        const exit2 = state.enter("headingAtx");
+        const subexit = state.enter("phrasing");
+        tracker.move(sequence + " ");
+        let value = state.containerPhrasing(node2, {
+            before: "# ",
+            after: "\n",
+            ...tracker.current()
+        });
+        if (/^[\t ]/.test(value)) {
+            value = "&#x" + value.charCodeAt(0).toString(16).toUpperCase() + ";" + value.slice(1);
         }
-    };
-
-    function formatTimezoneShort(offset2, dirtyDelimiter) {
-        var sign2 = offset2 > 0 ? "-" : "+";
-        var absOffset = Math.abs(offset2);
-        var hours = Math.floor(absOffset / 60);
-        var minutes = absOffset % 60;
-        if (minutes === 0) {
-            return sign2 + String(hours);
+        value = value ? sequence + " " + value : sequence;
+        if (state.options.closeAtx) {
+            value += " " + sequence;
         }
-        var delimiter = dirtyDelimiter || "";
-        return sign2 + String(hours) + delimiter + addLeadingZeros(minutes, 2);
+        subexit();
+        exit2();
+        return value;
     }
+    html$1.peek = htmlPeek;
 
-    function formatTimezoneWithOptionalMinutes(offset2, dirtyDelimiter) {
-        if (offset2 % 60 === 0) {
-            var sign2 = offset2 > 0 ? "-" : "+";
-            return sign2 + addLeadingZeros(Math.abs(offset2) / 60, 2);
-        }
-        return formatTimezone(offset2, dirtyDelimiter);
+    function html$1(node2) {
+        return node2.value || "";
     }
 
-    function formatTimezone(offset2, dirtyDelimiter) {
-        var delimiter = dirtyDelimiter || "";
-        var sign2 = offset2 > 0 ? "-" : "+";
-        var absOffset = Math.abs(offset2);
-        var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
-        var minutes = addLeadingZeros(absOffset % 60, 2);
-        return sign2 + hours + delimiter + minutes;
+    function htmlPeek() {
+        return "<";
     }
-    const formatters$1 = formatters;
-    var dateLongFormatter = function dateLongFormatter2(pattern, formatLong2) {
-        switch (pattern) {
-            case "P":
-                return formatLong2.date({
-                    width: "short"
-                });
-            case "PP":
-                return formatLong2.date({
-                    width: "medium"
-                });
-            case "PPP":
-                return formatLong2.date({
-                    width: "long"
-                });
-            case "PPPP":
-            default:
-                return formatLong2.date({
-                    width: "full"
-                });
-        }
-    };
-    var timeLongFormatter = function timeLongFormatter2(pattern, formatLong2) {
-        switch (pattern) {
-            case "p":
-                return formatLong2.time({
-                    width: "short"
-                });
-            case "pp":
-                return formatLong2.time({
-                    width: "medium"
-                });
-            case "ppp":
-                return formatLong2.time({
-                    width: "long"
-                });
-            case "pppp":
-            default:
-                return formatLong2.time({
-                    width: "full"
-                });
-        }
-    };
-    var dateTimeLongFormatter = function dateTimeLongFormatter2(pattern, formatLong2) {
-        var matchResult = pattern.match(/(P+)(p+)?/) || [];
-        var datePattern = matchResult[1];
-        var timePattern = matchResult[2];
-        if (!timePattern) {
-            return dateLongFormatter(pattern, formatLong2);
+    image.peek = imagePeek;
+
+    function image(node2, _2, state, info) {
+        const quote2 = checkQuote(state);
+        const suffix = quote2 === '"' ? "Quote" : "Apostrophe";
+        const exit2 = state.enter("image");
+        let subexit = state.enter("label");
+        const tracker = state.createTracker(info);
+        let value = tracker.move("![");
+        value += tracker.move(
+            state.safe(node2.alt, {
+                before: value,
+                after: "]",
+                ...tracker.current()
+            })
+        );
+        value += tracker.move("](");
+        subexit();
+        if (!node2.url && node2.title || /[\0- \u007F]/.test(node2.url)) {
+            subexit = state.enter("destinationLiteral");
+            value += tracker.move("<");
+            value += tracker.move(
+                state.safe(node2.url, {
+                    before: value,
+                    after: ">",
+                    ...tracker.current()
+                })
+            );
+            value += tracker.move(">");
+        } else {
+            subexit = state.enter("destinationRaw");
+            value += tracker.move(
+                state.safe(node2.url, {
+                    before: value,
+                    after: node2.title ? " " : ")",
+                    ...tracker.current()
+                })
+            );
         }
-        var dateTimeFormat;
-        switch (datePattern) {
-            case "P":
-                dateTimeFormat = formatLong2.dateTime({
-                    width: "short"
-                });
-                break;
-            case "PP":
-                dateTimeFormat = formatLong2.dateTime({
-                    width: "medium"
-                });
-                break;
-            case "PPP":
-                dateTimeFormat = formatLong2.dateTime({
-                    width: "long"
-                });
-                break;
-            case "PPPP":
-            default:
-                dateTimeFormat = formatLong2.dateTime({
-                    width: "full"
-                });
-                break;
+        subexit();
+        if (node2.title) {
+            subexit = state.enter(`title${suffix}`);
+            value += tracker.move(" " + quote2);
+            value += tracker.move(
+                state.safe(node2.title, {
+                    before: value,
+                    after: quote2,
+                    ...tracker.current()
+                })
+            );
+            value += tracker.move(quote2);
+            subexit();
         }
-        return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
-    };
-    var longFormatters = {
-        p: timeLongFormatter,
-        P: dateTimeLongFormatter
-    };
-    const longFormatters$1 = longFormatters;
-
-    function getTimezoneOffsetInMilliseconds(date) {
-        var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
-        utcDate.setUTCFullYear(date.getFullYear());
-        return date.getTime() - utcDate.getTime();
+        value += tracker.move(")");
+        exit2();
+        return value;
     }
-    var protectedDayOfYearTokens = ["D", "DD"];
-    var protectedWeekYearTokens = ["YY", "YYYY"];
 
-    function isProtectedDayOfYearToken(token) {
-        return protectedDayOfYearTokens.indexOf(token) !== -1;
+    function imagePeek() {
+        return "!";
     }
+    imageReference.peek = imageReferencePeek;
 
-    function isProtectedWeekYearToken(token) {
-        return protectedWeekYearTokens.indexOf(token) !== -1;
+    function imageReference(node2, _2, state, info) {
+        const type2 = node2.referenceType;
+        const exit2 = state.enter("imageReference");
+        let subexit = state.enter("label");
+        const tracker = state.createTracker(info);
+        let value = tracker.move("![");
+        const alt = state.safe(node2.alt, {
+            before: value,
+            after: "]",
+            ...tracker.current()
+        });
+        value += tracker.move(alt + "][");
+        subexit();
+        const stack = state.stack;
+        state.stack = [];
+        subexit = state.enter("reference");
+        const reference2 = state.safe(state.associationId(node2), {
+            before: value,
+            after: "]",
+            ...tracker.current()
+        });
+        subexit();
+        state.stack = stack;
+        exit2();
+        if (type2 === "full" || !alt || alt !== reference2) {
+            value += tracker.move(reference2 + "]");
+        } else if (type2 === "shortcut") {
+            value = value.slice(0, -1);
+        } else {
+            value += tracker.move("]");
+        }
+        return value;
     }
 
-    function throwProtectedError(token, format2, input) {
-        if (token === "YYYY") {
-            throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
-        } else if (token === "YY") {
-            throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
-        } else if (token === "D") {
-            throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
-        } else if (token === "DD") {
-            throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
-        }
+    function imageReferencePeek() {
+        return "!";
     }
-    var formatDistanceLocale = {
-        lessThanXSeconds: {
-            one: "less than a second",
-            other: "less than {{count}} seconds"
-        },
-        xSeconds: {
-            one: "1 second",
-            other: "{{count}} seconds"
-        },
-        halfAMinute: "half a minute",
-        lessThanXMinutes: {
-            one: "less than a minute",
-            other: "less than {{count}} minutes"
-        },
-        xMinutes: {
-            one: "1 minute",
-            other: "{{count}} minutes"
-        },
-        aboutXHours: {
-            one: "about 1 hour",
-            other: "about {{count}} hours"
-        },
-        xHours: {
-            one: "1 hour",
-            other: "{{count}} hours"
-        },
-        xDays: {
-            one: "1 day",
-            other: "{{count}} days"
-        },
-        aboutXWeeks: {
-            one: "about 1 week",
-            other: "about {{count}} weeks"
-        },
-        xWeeks: {
-            one: "1 week",
-            other: "{{count}} weeks"
-        },
-        aboutXMonths: {
-            one: "about 1 month",
-            other: "about {{count}} months"
-        },
-        xMonths: {
-            one: "1 month",
-            other: "{{count}} months"
-        },
-        aboutXYears: {
-            one: "about 1 year",
-            other: "about {{count}} years"
-        },
-        xYears: {
-            one: "1 year",
-            other: "{{count}} years"
-        },
-        overXYears: {
-            one: "over 1 year",
-            other: "over {{count}} years"
-        },
-        almostXYears: {
-            one: "almost 1 year",
-            other: "almost {{count}} years"
+    inlineCode.peek = inlineCodePeek;
+
+    function inlineCode(node2, _2, state) {
+        let value = node2.value || "";
+        let sequence = "`";
+        let index2 = -1;
+        while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
+            sequence += "`";
         }
-    };
-    var formatDistance = function formatDistance2(token, count2, options) {
-        var result;
-        var tokenValue = formatDistanceLocale[token];
-        if (typeof tokenValue === "string") {
-            result = tokenValue;
-        } else if (count2 === 1) {
-            result = tokenValue.one;
-        } else {
-            result = tokenValue.other.replace("{{count}}", count2.toString());
+        if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
+            value = " " + value + " ";
         }
-        if (options !== null && options !== void 0 && options.addSuffix) {
-            if (options.comparison && options.comparison > 0) {
-                return "in " + result;
-            } else {
-                return result + " ago";
+        while (++index2 < state.unsafe.length) {
+            const pattern = state.unsafe[index2];
+            const expression = state.compilePattern(pattern);
+            let match2;
+            if (!pattern.atBreak)
+                continue;
+            while (match2 = expression.exec(value)) {
+                let position2 = match2.index;
+                if (value.charCodeAt(position2) === 10 && value.charCodeAt(position2 - 1) === 13) {
+                    position2--;
+                }
+                value = value.slice(0, position2) + " " + value.slice(match2.index + 1);
             }
         }
-        return result;
-    };
-    const formatDistance$1 = formatDistance;
+        return sequence + value + sequence;
+    }
 
-    function buildFormatLongFn(args) {
-        return function() {
-            var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
-            var width = options.width ? String(options.width) : args.defaultWidth;
-            var format2 = args.formats[width] || args.formats[args.defaultWidth];
-            return format2;
-        };
+    function inlineCodePeek() {
+        return "`";
     }
-    var dateFormats = {
-        full: "EEEE, MMMM do, y",
-        long: "MMMM do, y",
-        medium: "MMM d, y",
-        short: "MM/dd/yyyy"
-    };
-    var timeFormats = {
-        full: "h:mm:ss a zzzz",
-        long: "h:mm:ss a z",
-        medium: "h:mm:ss a",
-        short: "h:mm a"
-    };
-    var dateTimeFormats = {
-        full: "{{date}} 'at' {{time}}",
-        long: "{{date}} 'at' {{time}}",
-        medium: "{{date}}, {{time}}",
-        short: "{{date}}, {{time}}"
-    };
-    var formatLong = {
-        date: buildFormatLongFn({
-            formats: dateFormats,
-            defaultWidth: "full"
-        }),
-        time: buildFormatLongFn({
-            formats: timeFormats,
-            defaultWidth: "full"
-        }),
-        dateTime: buildFormatLongFn({
-            formats: dateTimeFormats,
-            defaultWidth: "full"
-        })
-    };
-    const formatLong$1 = formatLong;
-    var formatRelativeLocale = {
-        lastWeek: "'last' eeee 'at' p",
-        yesterday: "'yesterday at' p",
-        today: "'today at' p",
-        tomorrow: "'tomorrow at' p",
-        nextWeek: "eeee 'at' p",
-        other: "P"
-    };
-    var formatRelative = function formatRelative2(token, _date, _baseDate, _options) {
-        return formatRelativeLocale[token];
-    };
-    const formatRelative$1 = formatRelative;
 
-    function buildLocalizeFn(args) {
-        return function(dirtyIndex, options) {
-            var context2 = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
-            var valuesArray;
-            if (context2 === "formatting" && args.formattingValues) {
-                var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
-                var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
-                valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
-            } else {
-                var _defaultWidth = args.defaultWidth;
-                var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
-                valuesArray = args.values[_width] || args.values[_defaultWidth];
-            }
-            var index2 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
-            return valuesArray[index2];
-        };
+    function formatLinkAsAutolink(node2, state) {
+        const raw2 = toString$6(node2);
+        return Boolean(
+            !state.options.resourceLink && node2.url && !node2.title && node2.children && node2.children.length === 1 && node2.children[0].type === "text" && (raw2 === node2.url || "mailto:" + raw2 === node2.url) && /^[a-z][a-z+.-]+:/i.test(node2.url) && !/[\0- <>\u007F]/.test(node2.url)
+        );
     }
-    var eraValues = {
-        narrow: ["B", "A"],
-        abbreviated: ["BC", "AD"],
-        wide: ["Before Christ", "Anno Domini"]
-    };
-    var quarterValues = {
-        narrow: ["1", "2", "3", "4"],
-        abbreviated: ["Q1", "Q2", "Q3", "Q4"],
-        wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
-    };
-    var monthValues = {
-        narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
-        abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
-        wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
-    };
-    var dayValues = {
-        narrow: ["S", "M", "T", "W", "T", "F", "S"],
-        short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
-        abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
-        wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
-    };
-    var dayPeriodValues = {
-        narrow: {
-            am: "a",
-            pm: "p",
-            midnight: "mi",
-            noon: "n",
-            morning: "morning",
-            afternoon: "afternoon",
-            evening: "evening",
-            night: "night"
-        },
-        abbreviated: {
-            am: "AM",
-            pm: "PM",
-            midnight: "midnight",
-            noon: "noon",
-            morning: "morning",
-            afternoon: "afternoon",
-            evening: "evening",
-            night: "night"
-        },
-        wide: {
-            am: "a.m.",
-            pm: "p.m.",
-            midnight: "midnight",
-            noon: "noon",
-            morning: "morning",
-            afternoon: "afternoon",
-            evening: "evening",
-            night: "night"
+    link$1.peek = linkPeek;
+
+    function link$1(node2, _2, state, info) {
+        const quote2 = checkQuote(state);
+        const suffix = quote2 === '"' ? "Quote" : "Apostrophe";
+        const tracker = state.createTracker(info);
+        let exit2;
+        let subexit;
+        if (formatLinkAsAutolink(node2, state)) {
+            const stack = state.stack;
+            state.stack = [];
+            exit2 = state.enter("autolink");
+            let value2 = tracker.move("<");
+            value2 += tracker.move(
+                state.containerPhrasing(node2, {
+                    before: value2,
+                    after: ">",
+                    ...tracker.current()
+                })
+            );
+            value2 += tracker.move(">");
+            exit2();
+            state.stack = stack;
+            return value2;
         }
-    };
-    var formattingDayPeriodValues = {
-        narrow: {
-            am: "a",
-            pm: "p",
-            midnight: "mi",
-            noon: "n",
-            morning: "in the morning",
-            afternoon: "in the afternoon",
-            evening: "in the evening",
-            night: "at night"
-        },
-        abbreviated: {
-            am: "AM",
-            pm: "PM",
-            midnight: "midnight",
-            noon: "noon",
-            morning: "in the morning",
-            afternoon: "in the afternoon",
-            evening: "in the evening",
-            night: "at night"
-        },
-        wide: {
-            am: "a.m.",
-            pm: "p.m.",
-            midnight: "midnight",
-            noon: "noon",
-            morning: "in the morning",
-            afternoon: "in the afternoon",
-            evening: "in the evening",
-            night: "at night"
+        exit2 = state.enter("link");
+        subexit = state.enter("label");
+        let value = tracker.move("[");
+        value += tracker.move(
+            state.containerPhrasing(node2, {
+                before: value,
+                after: "](",
+                ...tracker.current()
+            })
+        );
+        value += tracker.move("](");
+        subexit();
+        if (!node2.url && node2.title || /[\0- \u007F]/.test(node2.url)) {
+            subexit = state.enter("destinationLiteral");
+            value += tracker.move("<");
+            value += tracker.move(
+                state.safe(node2.url, {
+                    before: value,
+                    after: ">",
+                    ...tracker.current()
+                })
+            );
+            value += tracker.move(">");
+        } else {
+            subexit = state.enter("destinationRaw");
+            value += tracker.move(
+                state.safe(node2.url, {
+                    before: value,
+                    after: node2.title ? " " : ")",
+                    ...tracker.current()
+                })
+            );
         }
-    };
-    var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
-        var number2 = Number(dirtyNumber);
-        var rem100 = number2 % 100;
-        if (rem100 > 20 || rem100 < 10) {
-            switch (rem100 % 10) {
-                case 1:
-                    return number2 + "st";
-                case 2:
-                    return number2 + "nd";
-                case 3:
-                    return number2 + "rd";
-            }
+        subexit();
+        if (node2.title) {
+            subexit = state.enter(`title${suffix}`);
+            value += tracker.move(" " + quote2);
+            value += tracker.move(
+                state.safe(node2.title, {
+                    before: value,
+                    after: quote2,
+                    ...tracker.current()
+                })
+            );
+            value += tracker.move(quote2);
+            subexit();
         }
-        return number2 + "th";
-    };
-    var localize = {
-        ordinalNumber,
-        era: buildLocalizeFn({
-            values: eraValues,
-            defaultWidth: "wide"
-        }),
-        quarter: buildLocalizeFn({
-            values: quarterValues,
-            defaultWidth: "wide",
-            argumentCallback: function argumentCallback(quarter) {
-                return quarter - 1;
-            }
-        }),
-        month: buildLocalizeFn({
-            values: monthValues,
-            defaultWidth: "wide"
-        }),
-        day: buildLocalizeFn({
-            values: dayValues,
-            defaultWidth: "wide"
-        }),
-        dayPeriod: buildLocalizeFn({
-            values: dayPeriodValues,
-            defaultWidth: "wide",
-            formattingValues: formattingDayPeriodValues,
-            defaultFormattingWidth: "wide"
-        })
-    };
-    const localize$1 = localize;
-
-    function buildMatchFn(args) {
-        return function(string2) {
-            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
-            var width = options.width;
-            var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
-            var matchResult = string2.match(matchPattern);
-            if (!matchResult) {
-                return null;
-            }
-            var matchedString = matchResult[0];
-            var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
-            var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
-                return pattern.test(matchedString);
-            }) : findKey(parsePatterns, function(pattern) {
-                return pattern.test(matchedString);
-            });
-            var value;
-            value = args.valueCallback ? args.valueCallback(key) : key;
-            value = options.valueCallback ? options.valueCallback(value) : value;
-            var rest = string2.slice(matchedString.length);
-            return {
-                value,
-                rest
-            };
-        };
+        value += tracker.move(")");
+        exit2();
+        return value;
     }
 
-    function findKey(object2, predicate) {
-        for (var key in object2) {
-            if (object2.hasOwnProperty(key) && predicate(object2[key])) {
-                return key;
-            }
-        }
-        return void 0;
+    function linkPeek(node2, _2, state) {
+        return formatLinkAsAutolink(node2, state) ? "<" : "[";
     }
+    linkReference.peek = linkReferencePeek;
 
-    function findIndex(array2, predicate) {
-        for (var key = 0; key < array2.length; key++) {
-            if (predicate(array2[key])) {
-                return key;
-            }
+    function linkReference(node2, _2, state, info) {
+        const type2 = node2.referenceType;
+        const exit2 = state.enter("linkReference");
+        let subexit = state.enter("label");
+        const tracker = state.createTracker(info);
+        let value = tracker.move("[");
+        const text2 = state.containerPhrasing(node2, {
+            before: value,
+            after: "]",
+            ...tracker.current()
+        });
+        value += tracker.move(text2 + "][");
+        subexit();
+        const stack = state.stack;
+        state.stack = [];
+        subexit = state.enter("reference");
+        const reference2 = state.safe(state.associationId(node2), {
+            before: value,
+            after: "]",
+            ...tracker.current()
+        });
+        subexit();
+        state.stack = stack;
+        exit2();
+        if (type2 === "full" || !text2 || text2 !== reference2) {
+            value += tracker.move(reference2 + "]");
+        } else if (type2 === "shortcut") {
+            value = value.slice(0, -1);
+        } else {
+            value += tracker.move("]");
         }
-        return void 0;
+        return value;
     }
 
-    function buildMatchPatternFn(args) {
-        return function(string2) {
-            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
-            var matchResult = string2.match(args.matchPattern);
-            if (!matchResult)
-                return null;
-            var matchedString = matchResult[0];
-            var parseResult = string2.match(args.parsePattern);
-            if (!parseResult)
-                return null;
-            var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
-            value = options.valueCallback ? options.valueCallback(value) : value;
-            var rest = string2.slice(matchedString.length);
-            return {
-                value,
-                rest
-            };
-        };
+    function linkReferencePeek() {
+        return "[";
     }
-    var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
-    var parseOrdinalNumberPattern = /\d+/i;
-    var matchEraPatterns = {
-        narrow: /^(b|a)/i,
-        abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
-        wide: /^(before christ|before common era|anno domini|common era)/i
-    };
-    var parseEraPatterns = {
-        any: [/^b/i, /^(a|c)/i]
-    };
-    var matchQuarterPatterns = {
-        narrow: /^[1234]/i,
-        abbreviated: /^q[1234]/i,
-        wide: /^[1234](th|st|nd|rd)? quarter/i
-    };
-    var parseQuarterPatterns = {
-        any: [/1/i, /2/i, /3/i, /4/i]
-    };
-    var matchMonthPatterns = {
-        narrow: /^[jfmasond]/i,
-        abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
-        wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
-    };
-    var parseMonthPatterns = {
-        narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
-        any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
-    };
-    var matchDayPatterns = {
-        narrow: /^[smtwf]/i,
-        short: /^(su|mo|tu|we|th|fr|sa)/i,
-        abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
-        wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
-    };
-    var parseDayPatterns = {
-        narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
-        any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
-    };
-    var matchDayPeriodPatterns = {
-        narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
-        any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
-    };
-    var parseDayPeriodPatterns = {
-        any: {
-            am: /^a/i,
-            pm: /^p/i,
-            midnight: /^mi/i,
-            noon: /^no/i,
-            morning: /morning/i,
-            afternoon: /afternoon/i,
-            evening: /evening/i,
-            night: /night/i
-        }
-    };
-    var match$1 = {
-        ordinalNumber: buildMatchPatternFn({
-            matchPattern: matchOrdinalNumberPattern,
-            parsePattern: parseOrdinalNumberPattern,
-            valueCallback: function valueCallback(value) {
-                return parseInt(value, 10);
-            }
-        }),
-        era: buildMatchFn({
-            matchPatterns: matchEraPatterns,
-            defaultMatchWidth: "wide",
-            parsePatterns: parseEraPatterns,
-            defaultParseWidth: "any"
-        }),
-        quarter: buildMatchFn({
-            matchPatterns: matchQuarterPatterns,
-            defaultMatchWidth: "wide",
-            parsePatterns: parseQuarterPatterns,
-            defaultParseWidth: "any",
-            valueCallback: function valueCallback(index2) {
-                return index2 + 1;
-            }
-        }),
-        month: buildMatchFn({
-            matchPatterns: matchMonthPatterns,
-            defaultMatchWidth: "wide",
-            parsePatterns: parseMonthPatterns,
-            defaultParseWidth: "any"
-        }),
-        day: buildMatchFn({
-            matchPatterns: matchDayPatterns,
-            defaultMatchWidth: "wide",
-            parsePatterns: parseDayPatterns,
-            defaultParseWidth: "any"
-        }),
-        dayPeriod: buildMatchFn({
-            matchPatterns: matchDayPeriodPatterns,
-            defaultMatchWidth: "any",
-            parsePatterns: parseDayPeriodPatterns,
-            defaultParseWidth: "any"
-        })
-    };
-    const match$2 = match$1;
-    var locale = {
-        code: "en-US",
-        formatDistance: formatDistance$1,
-        formatLong: formatLong$1,
-        formatRelative: formatRelative$1,
-        localize: localize$1,
-        match: match$2,
-        options: {
-            weekStartsOn: 0,
-            firstWeekContainsDate: 1
-        }
-    };
-    const defaultLocale = locale;
-    var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
-    var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
-    var escapedStringRegExp$1 = /^'([^]*?)'?$/;
-    var doubleQuoteRegExp$1 = /''/g;
-    var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
 
-    function format$1(dirtyDate, dirtyFormatStr, options) {
-        var _ref2, _options$locale, _ref22, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
-        requiredArgs(2, arguments);
-        var formatStr = String(dirtyFormatStr);
-        var defaultOptions2 = getDefaultOptions();
-        var locale2 = (_ref2 = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref2 !== void 0 ? _ref2 : defaultLocale;
-        var firstWeekContainsDate = toInteger$2((_ref22 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref22 !== void 0 ? _ref22 : 1);
-        if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
-            throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
-        }
-        var weekStartsOn = toInteger$2((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
-        if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
-            throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
+    function checkBullet(state) {
+        const marker = state.options.bullet || "*";
+        if (marker !== "*" && marker !== "+" && marker !== "-") {
+            throw new Error(
+                "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
+            );
         }
-        if (!locale2.localize) {
-            throw new RangeError("locale must contain localize property");
+        return marker;
+    }
+
+    function checkBulletOther(state) {
+        const bullet = checkBullet(state);
+        const bulletOther = state.options.bulletOther;
+        if (!bulletOther) {
+            return bullet === "*" ? "-" : "*";
         }
-        if (!locale2.formatLong) {
-            throw new RangeError("locale must contain formatLong property");
+        if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
+            throw new Error(
+                "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
+            );
         }
-        var originalDate = toDate(dirtyDate);
-        if (!isValid(originalDate)) {
-            throw new RangeError("Invalid time value");
+        if (bulletOther === bullet) {
+            throw new Error(
+                "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
+            );
         }
-        var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
-        var utcDate = subMilliseconds(originalDate, timezoneOffset);
-        var formatterOptions = {
-            firstWeekContainsDate,
-            weekStartsOn,
-            locale: locale2,
-            _originalDate: originalDate
-        };
-        var result = formatStr.match(longFormattingTokensRegExp$1).map(function(substring) {
-            var firstCharacter = substring[0];
-            if (firstCharacter === "p" || firstCharacter === "P") {
-                var longFormatter = longFormatters$1[firstCharacter];
-                return longFormatter(substring, locale2.formatLong);
-            }
-            return substring;
-        }).join("").match(formattingTokensRegExp$1).map(function(substring) {
-            if (substring === "''") {
-                return "'";
-            }
-            var firstCharacter = substring[0];
-            if (firstCharacter === "'") {
-                return cleanEscapedString$1(substring);
-            }
-            var formatter = formatters$1[firstCharacter];
-            if (formatter) {
-                if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
-                    throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
-                }
-                if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
-                    throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
-                }
-                return formatter(utcDate, substring, locale2.localize, formatterOptions);
-            }
-            if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
-                throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
-            }
-            return substring;
-        }).join("");
-        return result;
+        return bulletOther;
     }
 
-    function cleanEscapedString$1(input) {
-        var matched = input.match(escapedStringRegExp$1);
-        if (!matched) {
-            return input;
+    function checkBulletOrdered(state) {
+        const marker = state.options.bulletOrdered || ".";
+        if (marker !== "." && marker !== ")") {
+            throw new Error(
+                "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
+            );
         }
-        return matched[1].replace(doubleQuoteRegExp$1, "'");
-    }
-    var MILLISECONDS_IN_MINUTE = 6e4;
-
-    function addMinutes(dirtyDate, dirtyAmount) {
-        requiredArgs(2, arguments);
-        var amount = toInteger$2(dirtyAmount);
-        return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE);
+        return marker;
     }
-    var MILLISECONDS_IN_HOUR = 36e5;
 
-    function addHours(dirtyDate, dirtyAmount) {
-        requiredArgs(2, arguments);
-        var amount = toInteger$2(dirtyAmount);
-        return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_HOUR);
+    function checkRule(state) {
+        const marker = state.options.rule || "*";
+        if (marker !== "*" && marker !== "-" && marker !== "_") {
+            throw new Error(
+                "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
+            );
+        }
+        return marker;
     }
 
-    function addDays(dirtyDate, dirtyAmount) {
-        requiredArgs(2, arguments);
-        var date = toDate(dirtyDate);
-        var amount = toInteger$2(dirtyAmount);
-        if (isNaN(amount)) {
-            return new Date(NaN);
+    function list(node2, parent, state, info) {
+        const exit2 = state.enter("list");
+        const bulletCurrent = state.bulletCurrent;
+        let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
+        const bulletOther = node2.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
+        let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
+        if (!node2.ordered) {
+            const firstListItem = node2.children ? node2.children[0] : void 0;
+            if ((bullet === "*" || bullet === "-") && firstListItem && (!firstListItem.children || !firstListItem.children[0]) && state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0) {
+                useDifferentMarker = true;
+            }
+            if (checkRule(state) === bullet && firstListItem) {
+                let index2 = -1;
+                while (++index2 < node2.children.length) {
+                    const item = node2.children[index2];
+                    if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
+                        useDifferentMarker = true;
+                        break;
+                    }
+                }
+            }
         }
-        if (!amount) {
-            return date;
+        if (useDifferentMarker) {
+            bullet = bulletOther;
         }
-        date.setDate(date.getDate() + amount);
-        return date;
+        state.bulletCurrent = bullet;
+        const value = state.containerFlow(node2, info);
+        state.bulletLastUsed = bullet;
+        state.bulletCurrent = bulletCurrent;
+        exit2();
+        return value;
     }
 
-    function addWeeks(dirtyDate, dirtyAmount) {
-        requiredArgs(2, arguments);
-        var amount = toInteger$2(dirtyAmount);
-        var days = amount * 7;
-        return addDays(dirtyDate, days);
+    function checkListItemIndent(state) {
+        const style2 = state.options.listItemIndent || "one";
+        if (style2 !== "tab" && style2 !== "one" && style2 !== "mixed") {
+            throw new Error(
+                "Cannot serialize items with `" + style2 + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
+            );
+        }
+        return style2;
     }
 
-    function addMonths(dirtyDate, dirtyAmount) {
-        requiredArgs(2, arguments);
-        var date = toDate(dirtyDate);
-        var amount = toInteger$2(dirtyAmount);
-        if (isNaN(amount)) {
-            return new Date(NaN);
+    function listItem(node2, parent, state, info) {
+        const listItemIndent = checkListItemIndent(state);
+        let bullet = state.bulletCurrent || checkBullet(state);
+        if (parent && parent.type === "list" && parent.ordered) {
+            bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
         }
-        if (!amount) {
-            return date;
+        let size2 = bullet.length + 1;
+        if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
+            size2 = Math.ceil(size2 / 4) * 4;
         }
-        var dayOfMonth = date.getDate();
-        var endOfDesiredMonth = new Date(date.getTime());
-        endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
-        var daysInMonth = endOfDesiredMonth.getDate();
-        if (dayOfMonth >= daysInMonth) {
-            return endOfDesiredMonth;
-        } else {
-            date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
-            return date;
+        const tracker = state.createTracker(info);
+        tracker.move(bullet + " ".repeat(size2 - bullet.length));
+        tracker.shift(size2);
+        const exit2 = state.enter("listItem");
+        const value = state.indentLines(
+            state.containerFlow(node2, tracker.current()),
+            map2
+        );
+        exit2();
+        return value;
+
+        function map2(line, index2, blank) {
+            if (index2) {
+                return (blank ? "" : " ".repeat(size2)) + line;
+            }
+            return (blank ? bullet : bullet + " ".repeat(size2 - bullet.length)) + line;
         }
     }
 
-    function addYears(dirtyDate, dirtyAmount) {
-        requiredArgs(2, arguments);
-        var amount = toInteger$2(dirtyAmount);
-        return addMonths(dirtyDate, amount * 12);
+    function paragraph(node2, _2, state, info) {
+        const exit2 = state.enter("paragraph");
+        const subexit = state.enter("phrasing");
+        const value = state.containerPhrasing(node2, info);
+        subexit();
+        exit2();
+        return value;
     }
+    const phrasing = convert$1([
+        "break",
+        "delete",
+        "emphasis",
+        "footnote",
+        "footnoteReference",
+        "image",
+        "imageReference",
+        "inlineCode",
+        "inlineMath",
+        "link",
+        "linkReference",
+        "mdxJsxTextElement",
+        "mdxTextExpression",
+        "strong",
+        "text",
+        "textDirective"
+    ]);
 
-    function subDays(dirtyDate, dirtyAmount) {
-        requiredArgs(2, arguments);
-        var amount = toInteger$2(dirtyAmount);
-        return addDays(dirtyDate, -amount);
+    function root$3(node2, _2, state, info) {
+        const hasPhrasing = node2.children.some(function(d2) {
+            return phrasing(d2);
+        });
+        const fn2 = hasPhrasing ? state.containerPhrasing : state.containerFlow;
+        return fn2.call(state, node2, info);
     }
 
-    function subWeeks(dirtyDate, dirtyAmount) {
-        requiredArgs(2, arguments);
-        var amount = toInteger$2(dirtyAmount);
-        return addWeeks(dirtyDate, -amount);
+    function checkStrong(state) {
+        const marker = state.options.strong || "*";
+        if (marker !== "*" && marker !== "_") {
+            throw new Error(
+                "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
+            );
+        }
+        return marker;
     }
+    strong.peek = strongPeek;
 
-    function subMonths(dirtyDate, dirtyAmount) {
-        requiredArgs(2, arguments);
-        var amount = toInteger$2(dirtyAmount);
-        return addMonths(dirtyDate, -amount);
+    function strong(node2, _2, state, info) {
+        const marker = checkStrong(state);
+        const exit2 = state.enter("strong");
+        const tracker = state.createTracker(info);
+        let value = tracker.move(marker + marker);
+        value += tracker.move(
+            state.containerPhrasing(node2, {
+                before: value,
+                after: marker,
+                ...tracker.current()
+            })
+        );
+        value += tracker.move(marker + marker);
+        exit2();
+        return value;
     }
 
-    function subYears(dirtyDate, dirtyAmount) {
-        requiredArgs(2, arguments);
-        var amount = toInteger$2(dirtyAmount);
-        return addYears(dirtyDate, -amount);
+    function strongPeek(_2, _1, state) {
+        return state.options.strong || "*";
     }
 
-    function getSeconds(dirtyDate) {
-        requiredArgs(1, arguments);
-        var date = toDate(dirtyDate);
-        var seconds = date.getSeconds();
-        return seconds;
+    function text$2(node2, _2, state, info) {
+        return state.safe(node2.value, info);
     }
 
-    function getMinutes(dirtyDate) {
-        requiredArgs(1, arguments);
-        var date = toDate(dirtyDate);
-        var minutes = date.getMinutes();
-        return minutes;
+    function checkRuleRepetition(state) {
+        const repetition = state.options.ruleRepetition || 3;
+        if (repetition < 3) {
+            throw new Error(
+                "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
+            );
+        }
+        return repetition;
     }
 
-    function getHours(dirtyDate) {
-        requiredArgs(1, arguments);
-        var date = toDate(dirtyDate);
-        var hours = date.getHours();
-        return hours;
+    function thematicBreak(_2, _1, state) {
+        const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
+        return state.options.ruleSpaces ? value.slice(0, -1) : value;
     }
+    const handle = {
+        blockquote,
+        break: hardBreak,
+        code: code$2,
+        definition,
+        emphasis,
+        hardBreak,
+        heading: heading$1,
+        html: html$1,
+        image,
+        imageReference,
+        inlineCode,
+        link: link$1,
+        linkReference,
+        list,
+        listItem,
+        paragraph,
+        root: root$3,
+        strong,
+        text: text$2,
+        thematicBreak
+    };
 
-    function getDay(dirtyDate) {
-        requiredArgs(1, arguments);
-        var date = toDate(dirtyDate);
-        var day = date.getDay();
-        return day;
+    function gfmTableFromMarkdown() {
+        return {
+            enter: {
+                table: enterTable,
+                tableData: enterCell,
+                tableHeader: enterCell,
+                tableRow: enterRow
+            },
+            exit: {
+                codeText: exitCodeText,
+                table: exitTable,
+                tableData: exit,
+                tableHeader: exit,
+                tableRow: exit
+            }
+        };
     }
 
-    function getDate(dirtyDate) {
-        requiredArgs(1, arguments);
-        var date = toDate(dirtyDate);
-        var dayOfMonth = date.getDate();
-        return dayOfMonth;
+    function enterTable(token) {
+        const align = token._align;
+        this.enter({
+                type: "table",
+                align: align.map(function(d2) {
+                    return d2 === "none" ? null : d2;
+                }),
+                children: []
+            },
+            token
+        );
+        this.data.inTable = true;
     }
 
-    function startOfWeek(dirtyDate, options) {
-        var _ref2, _ref22, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
-        requiredArgs(1, arguments);
-        var defaultOptions2 = getDefaultOptions();
-        var weekStartsOn = toInteger$2((_ref2 = (_ref22 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : 0);
-        if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
-            throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
-        }
-        var date = toDate(dirtyDate);
-        var day = date.getDay();
-        var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
-        date.setDate(date.getDate() - diff);
-        date.setHours(0, 0, 0, 0);
-        return date;
+    function exitTable(token) {
+        this.exit(token);
+        this.data.inTable = void 0;
     }
 
-    function startOfISOWeek(dirtyDate) {
-        requiredArgs(1, arguments);
-        return startOfWeek(dirtyDate, {
-            weekStartsOn: 1
-        });
+    function enterRow(token) {
+        this.enter({
+            type: "tableRow",
+            children: []
+        }, token);
     }
 
-    function getISOWeekYear(dirtyDate) {
-        requiredArgs(1, arguments);
-        var date = toDate(dirtyDate);
-        var year = date.getFullYear();
-        var fourthOfJanuaryOfNextYear = new Date(0);
-        fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
-        fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
-        var startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
-        var fourthOfJanuaryOfThisYear = new Date(0);
-        fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
-        fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
-        var startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
-        if (date.getTime() >= startOfNextYear.getTime()) {
-            return year + 1;
-        } else if (date.getTime() >= startOfThisYear.getTime()) {
-            return year;
-        } else {
-            return year - 1;
-        }
+    function exit(token) {
+        this.exit(token);
     }
 
-    function startOfISOWeekYear(dirtyDate) {
-        requiredArgs(1, arguments);
-        var year = getISOWeekYear(dirtyDate);
-        var fourthOfJanuary = new Date(0);
-        fourthOfJanuary.setFullYear(year, 0, 4);
-        fourthOfJanuary.setHours(0, 0, 0, 0);
-        var date = startOfISOWeek(fourthOfJanuary);
-        return date;
+    function enterCell(token) {
+        this.enter({
+            type: "tableCell",
+            children: []
+        }, token);
     }
-    var MILLISECONDS_IN_WEEK = 6048e5;
 
-    function getISOWeek(dirtyDate) {
-        requiredArgs(1, arguments);
-        var date = toDate(dirtyDate);
-        var diff = startOfISOWeek(date).getTime() - startOfISOWeekYear(date).getTime();
-        return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
+    function exitCodeText(token) {
+        let value = this.resume();
+        if (this.data.inTable) {
+            value = value.replace(/\\([\\|])/g, replace$1);
+        }
+        const node2 = this.stack[this.stack.length - 1];
+        ok$2(node2.type === "inlineCode");
+        node2.value = value;
+        this.exit(token);
     }
 
-    function getMonth(dirtyDate) {
-        requiredArgs(1, arguments);
-        var date = toDate(dirtyDate);
-        var month = date.getMonth();
-        return month;
+    function replace$1($0, $1) {
+        return $1 === "|" ? $1 : $0;
     }
 
-    function getQuarter(dirtyDate) {
-        requiredArgs(1, arguments);
-        var date = toDate(dirtyDate);
-        var quarter = Math.floor(date.getMonth() / 3) + 1;
-        return quarter;
-    }
+    function gfmTableToMarkdown(options) {
+        const settings2 = options || {};
+        const padding = settings2.tableCellPadding;
+        const alignDelimiters = settings2.tablePipeAlign;
+        const stringLength = settings2.stringLength;
+        const around = padding ? " " : "|";
+        return {
+            unsafe: [{
+                character: "\r",
+                inConstruct: "tableCell"
+            }, {
+                character: "\n",
+                inConstruct: "tableCell"
+            }, {
+                atBreak: true,
+                character: "|",
+                after: "[	 :-]"
+            }, {
+                character: "|",
+                inConstruct: "tableCell"
+            }, {
+                atBreak: true,
+                character: ":",
+                after: "-"
+            }, {
+                atBreak: true,
+                character: "-",
+                after: "[:|-]"
+            }],
+            handlers: {
+                inlineCode: inlineCodeWithTable,
+                table: handleTable,
+                tableCell: handleTableCell,
+                tableRow: handleTableRow
+            }
+        };
 
-    function getYear(dirtyDate) {
-        requiredArgs(1, arguments);
-        return toDate(dirtyDate).getFullYear();
-    }
+        function handleTable(node2, _2, state, info) {
+            return serializeData(handleTableAsData(node2, state, info), node2.align);
+        }
 
-    function getTime(dirtyDate) {
-        requiredArgs(1, arguments);
-        var date = toDate(dirtyDate);
-        var timestamp = date.getTime();
-        return timestamp;
-    }
+        function handleTableRow(node2, _2, state, info) {
+            const row = handleTableRowAsData(node2, state, info);
+            const value = serializeData([row]);
+            return value.slice(0, value.indexOf("\n"));
+        }
 
-    function setSeconds(dirtyDate, dirtySeconds) {
-        requiredArgs(2, arguments);
-        var date = toDate(dirtyDate);
-        var seconds = toInteger$2(dirtySeconds);
-        date.setSeconds(seconds);
-        return date;
-    }
+        function handleTableCell(node2, _2, state, info) {
+            const exit2 = state.enter("tableCell");
+            const subexit = state.enter("phrasing");
+            const value = state.containerPhrasing(node2, {
+                ...info,
+                before: around,
+                after: around
+            });
+            subexit();
+            exit2();
+            return value;
+        }
 
-    function setMinutes(dirtyDate, dirtyMinutes) {
-        requiredArgs(2, arguments);
-        var date = toDate(dirtyDate);
-        var minutes = toInteger$2(dirtyMinutes);
-        date.setMinutes(minutes);
-        return date;
-    }
+        function serializeData(matrix, align) {
+            return markdownTable(matrix, {
+                align,
+                alignDelimiters,
+                padding,
+                stringLength
+            });
+        }
 
-    function setHours(dirtyDate, dirtyHours) {
-        requiredArgs(2, arguments);
-        var date = toDate(dirtyDate);
-        var hours = toInteger$2(dirtyHours);
-        date.setHours(hours);
-        return date;
-    }
+        function handleTableAsData(node2, state, info) {
+            const children2 = node2.children;
+            let index2 = -1;
+            const result = [];
+            const subexit = state.enter("table");
+            while (++index2 < children2.length) {
+                result[index2] = handleTableRowAsData(children2[index2], state, info);
+            }
+            subexit();
+            return result;
+        }
 
-    function getDaysInMonth(dirtyDate) {
-        requiredArgs(1, arguments);
-        var date = toDate(dirtyDate);
-        var year = date.getFullYear();
-        var monthIndex = date.getMonth();
-        var lastDayOfMonth = new Date(0);
-        lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
-        lastDayOfMonth.setHours(0, 0, 0, 0);
-        return lastDayOfMonth.getDate();
+        function handleTableRowAsData(node2, state, info) {
+            const children2 = node2.children;
+            let index2 = -1;
+            const result = [];
+            const subexit = state.enter("tableRow");
+            while (++index2 < children2.length) {
+                result[index2] = handleTableCell(children2[index2], node2, state, info);
+            }
+            subexit();
+            return result;
+        }
+
+        function inlineCodeWithTable(node2, parent, state) {
+            let value = handle.inlineCode(node2, parent, state);
+            if (state.stack.includes("tableCell")) {
+                value = value.replace(/\|/g, "\\$&");
+            }
+            return value;
+        }
     }
 
-    function setMonth(dirtyDate, dirtyMonth) {
-        requiredArgs(2, arguments);
-        var date = toDate(dirtyDate);
-        var month = toInteger$2(dirtyMonth);
-        var year = date.getFullYear();
-        var day = date.getDate();
-        var dateWithDesiredMonth = new Date(0);
-        dateWithDesiredMonth.setFullYear(year, month, 15);
-        dateWithDesiredMonth.setHours(0, 0, 0, 0);
-        var daysInMonth = getDaysInMonth(dateWithDesiredMonth);
-        date.setMonth(month, Math.min(day, daysInMonth));
-        return date;
+    function gfmTaskListItemFromMarkdown() {
+        return {
+            exit: {
+                taskListCheckValueChecked: exitCheck,
+                taskListCheckValueUnchecked: exitCheck,
+                paragraph: exitParagraphWithTaskListItem
+            }
+        };
     }
 
-    function setQuarter(dirtyDate, dirtyQuarter) {
-        requiredArgs(2, arguments);
-        var date = toDate(dirtyDate);
-        var quarter = toInteger$2(dirtyQuarter);
-        var oldQuarter = Math.floor(date.getMonth() / 3) + 1;
-        var diff = quarter - oldQuarter;
-        return setMonth(date, date.getMonth() + diff * 3);
+    function gfmTaskListItemToMarkdown() {
+        return {
+            unsafe: [{
+                atBreak: true,
+                character: "-",
+                after: "[:|-]"
+            }],
+            handlers: {
+                listItem: listItemWithTaskListItem
+            }
+        };
     }
 
-    function setYear(dirtyDate, dirtyYear) {
-        requiredArgs(2, arguments);
-        var date = toDate(dirtyDate);
-        var year = toInteger$2(dirtyYear);
-        if (isNaN(date.getTime())) {
-            return new Date(NaN);
-        }
-        date.setFullYear(year);
-        return date;
+    function exitCheck(token) {
+        const node2 = this.stack[this.stack.length - 2];
+        ok$2(node2.type === "listItem");
+        node2.checked = token.type === "taskListCheckValueChecked";
     }
 
-    function min$1(dirtyDatesArray) {
-        requiredArgs(1, arguments);
-        var datesArray;
-        if (dirtyDatesArray && typeof dirtyDatesArray.forEach === "function") {
-            datesArray = dirtyDatesArray;
-        } else if (_typeof$5(dirtyDatesArray) === "object" && dirtyDatesArray !== null) {
-            datesArray = Array.prototype.slice.call(dirtyDatesArray);
-        } else {
-            return new Date(NaN);
-        }
-        var result;
-        datesArray.forEach(function(dirtyDate) {
-            var currentDate = toDate(dirtyDate);
-            if (result === void 0 || result > currentDate || isNaN(currentDate.getDate())) {
-                result = currentDate;
+    function exitParagraphWithTaskListItem(token) {
+        const parent = this.stack[this.stack.length - 2];
+        if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
+            const node2 = this.stack[this.stack.length - 1];
+            ok$2(node2.type === "paragraph");
+            const head = node2.children[0];
+            if (head && head.type === "text") {
+                const siblings = parent.children;
+                let index2 = -1;
+                let firstParaghraph;
+                while (++index2 < siblings.length) {
+                    const sibling = siblings[index2];
+                    if (sibling.type === "paragraph") {
+                        firstParaghraph = sibling;
+                        break;
+                    }
+                }
+                if (firstParaghraph === node2) {
+                    head.value = head.value.slice(1);
+                    if (head.value.length === 0) {
+                        node2.children.shift();
+                    } else if (node2.position && head.position && typeof head.position.start.offset === "number") {
+                        head.position.start.column++;
+                        head.position.start.offset++;
+                        node2.position.start = Object.assign({}, head.position.start);
+                    }
+                }
             }
-        });
-        return result || new Date(NaN);
+        }
+        this.exit(token);
     }
 
-    function max$2(dirtyDatesArray) {
-        requiredArgs(1, arguments);
-        var datesArray;
-        if (dirtyDatesArray && typeof dirtyDatesArray.forEach === "function") {
-            datesArray = dirtyDatesArray;
-        } else if (_typeof$5(dirtyDatesArray) === "object" && dirtyDatesArray !== null) {
-            datesArray = Array.prototype.slice.call(dirtyDatesArray);
-        } else {
-            return new Date(NaN);
+    function listItemWithTaskListItem(node2, parent, state, info) {
+        const head = node2.children[0];
+        const checkable = typeof node2.checked === "boolean" && head && head.type === "paragraph";
+        const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
+        const tracker = state.createTracker(info);
+        if (checkable) {
+            tracker.move(checkbox);
         }
-        var result;
-        datesArray.forEach(function(dirtyDate) {
-            var currentDate = toDate(dirtyDate);
-            if (result === void 0 || result < currentDate || isNaN(Number(currentDate))) {
-                result = currentDate;
-            }
+        let value = handle.listItem(node2, parent, state, {
+            ...info,
+            ...tracker.current()
         });
-        return result || new Date(NaN);
-    }
+        if (checkable) {
+            value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
+        }
+        return value;
 
-    function startOfDay(dirtyDate) {
-        requiredArgs(1, arguments);
-        var date = toDate(dirtyDate);
-        date.setHours(0, 0, 0, 0);
-        return date;
+        function check($0) {
+            return $0 + checkbox;
+        }
     }
-    var MILLISECONDS_IN_DAY = 864e5;
 
-    function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
-        requiredArgs(2, arguments);
-        var startOfDayLeft = startOfDay(dirtyDateLeft);
-        var startOfDayRight = startOfDay(dirtyDateRight);
-        var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
-        var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight);
-        return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY);
+    function gfmFromMarkdown() {
+        return [
+            gfmAutolinkLiteralFromMarkdown(),
+            gfmFootnoteFromMarkdown(),
+            gfmStrikethroughFromMarkdown(),
+            gfmTableFromMarkdown(),
+            gfmTaskListItemFromMarkdown()
+        ];
     }
 
-    function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
-        requiredArgs(2, arguments);
-        var dateLeft = toDate(dirtyDateLeft);
-        var dateRight = toDate(dirtyDateRight);
-        var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
-        var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
-        return yearDiff * 12 + monthDiff;
+    function gfmToMarkdown(options) {
+        return {
+            extensions: [
+                gfmAutolinkLiteralToMarkdown(),
+                gfmFootnoteToMarkdown(),
+                gfmStrikethroughToMarkdown(),
+                gfmTableToMarkdown(options),
+                gfmTaskListItemToMarkdown()
+            ]
+        };
     }
+    const wwwPrefix = {
+        tokenize: tokenizeWwwPrefix,
+        partial: true
+    };
+    const domain = {
+        tokenize: tokenizeDomain,
+        partial: true
+    };
+    const path$1 = {
+        tokenize: tokenizePath,
+        partial: true
+    };
+    const trail = {
+        tokenize: tokenizeTrail,
+        partial: true
+    };
+    const emailDomainDotTrail = {
+        tokenize: tokenizeEmailDomainDotTrail,
+        partial: true
+    };
+    const wwwAutolink = {
+        tokenize: tokenizeWwwAutolink,
+        previous: previousWww
+    };
+    const protocolAutolink = {
+        tokenize: tokenizeProtocolAutolink,
+        previous: previousProtocol
+    };
+    const emailAutolink = {
+        tokenize: tokenizeEmailAutolink,
+        previous: previousEmail
+    };
+    const text$1 = {};
 
-    function differenceInCalendarYears(dirtyDateLeft, dirtyDateRight) {
-        requiredArgs(2, arguments);
-        var dateLeft = toDate(dirtyDateLeft);
-        var dateRight = toDate(dirtyDateRight);
-        return dateLeft.getFullYear() - dateRight.getFullYear();
+    function gfmAutolinkLiteral() {
+        return {
+            text: text$1
+        };
     }
-
-    function startOfMonth(dirtyDate) {
-        requiredArgs(1, arguments);
-        var date = toDate(dirtyDate);
-        date.setDate(1);
-        date.setHours(0, 0, 0, 0);
-        return date;
+    let code$1 = 48;
+    while (code$1 < 123) {
+        text$1[code$1] = emailAutolink;
+        code$1++;
+        if (code$1 === 58)
+            code$1 = 65;
+        else if (code$1 === 91)
+            code$1 = 97;
     }
+    text$1[43] = emailAutolink;
+    text$1[45] = emailAutolink;
+    text$1[46] = emailAutolink;
+    text$1[95] = emailAutolink;
+    text$1[72] = [emailAutolink, protocolAutolink];
+    text$1[104] = [emailAutolink, protocolAutolink];
+    text$1[87] = [emailAutolink, wwwAutolink];
+    text$1[119] = [emailAutolink, wwwAutolink];
 
-    function startOfQuarter(dirtyDate) {
-        requiredArgs(1, arguments);
-        var date = toDate(dirtyDate);
-        var currentMonth = date.getMonth();
-        var month = currentMonth - currentMonth % 3;
-        date.setMonth(month, 1);
-        date.setHours(0, 0, 0, 0);
-        return date;
-    }
+    function tokenizeEmailAutolink(effects, ok2, nok) {
+        const self2 = this;
+        let dot2;
+        let data2;
+        return start2;
 
-    function startOfYear(dirtyDate) {
-        requiredArgs(1, arguments);
-        var cleanDate = toDate(dirtyDate);
-        var date = new Date(0);
-        date.setFullYear(cleanDate.getFullYear(), 0, 1);
-        date.setHours(0, 0, 0, 0);
-        return date;
-    }
+        function start2(code2) {
+            if (!gfmAtext(code2) || !previousEmail.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
+                return nok(code2);
+            }
+            effects.enter("literalAutolink");
+            effects.enter("literalAutolinkEmail");
+            return atext(code2);
+        }
 
-    function endOfDay(dirtyDate) {
-        requiredArgs(1, arguments);
-        var date = toDate(dirtyDate);
-        date.setHours(23, 59, 59, 999);
-        return date;
-    }
+        function atext(code2) {
+            if (gfmAtext(code2)) {
+                effects.consume(code2);
+                return atext;
+            }
+            if (code2 === 64) {
+                effects.consume(code2);
+                return emailDomain;
+            }
+            return nok(code2);
+        }
 
-    function isEqual$2(dirtyLeftDate, dirtyRightDate) {
-        requiredArgs(2, arguments);
-        var dateLeft = toDate(dirtyLeftDate);
-        var dateRight = toDate(dirtyRightDate);
-        return dateLeft.getTime() === dateRight.getTime();
-    }
+        function emailDomain(code2) {
+            if (code2 === 46) {
+                return effects.check(
+                    emailDomainDotTrail,
+                    emailDomainAfter,
+                    emailDomainDot
+                )(code2);
+            }
+            if (code2 === 45 || code2 === 95 || asciiAlphanumeric(code2)) {
+                data2 = true;
+                effects.consume(code2);
+                return emailDomain;
+            }
+            return emailDomainAfter(code2);
+        }
 
-    function isSameDay(dirtyDateLeft, dirtyDateRight) {
-        requiredArgs(2, arguments);
-        var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
-        var dateRightStartOfDay = startOfDay(dirtyDateRight);
-        return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
-    }
+        function emailDomainDot(code2) {
+            effects.consume(code2);
+            dot2 = true;
+            return emailDomain;
+        }
 
-    function isSameMonth(dirtyDateLeft, dirtyDateRight) {
-        requiredArgs(2, arguments);
-        var dateLeft = toDate(dirtyDateLeft);
-        var dateRight = toDate(dirtyDateRight);
-        return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
+        function emailDomainAfter(code2) {
+            if (data2 && dot2 && asciiAlpha(self2.previous)) {
+                effects.exit("literalAutolinkEmail");
+                effects.exit("literalAutolink");
+                return ok2(code2);
+            }
+            return nok(code2);
+        }
     }
 
-    function isSameYear(dirtyDateLeft, dirtyDateRight) {
-        requiredArgs(2, arguments);
-        var dateLeft = toDate(dirtyDateLeft);
-        var dateRight = toDate(dirtyDateRight);
-        return dateLeft.getFullYear() === dateRight.getFullYear();
-    }
+    function tokenizeWwwAutolink(effects, ok2, nok) {
+        const self2 = this;
+        return wwwStart;
 
-    function isSameQuarter(dirtyDateLeft, dirtyDateRight) {
-        requiredArgs(2, arguments);
-        var dateLeftStartOfQuarter = startOfQuarter(dirtyDateLeft);
-        var dateRightStartOfQuarter = startOfQuarter(dirtyDateRight);
-        return dateLeftStartOfQuarter.getTime() === dateRightStartOfQuarter.getTime();
-    }
+        function wwwStart(code2) {
+            if (code2 !== 87 && code2 !== 119 || !previousWww.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
+                return nok(code2);
+            }
+            effects.enter("literalAutolink");
+            effects.enter("literalAutolinkWww");
+            return effects.check(
+                wwwPrefix,
+                effects.attempt(domain, effects.attempt(path$1, wwwAfter), nok),
+                nok
+            )(code2);
+        }
 
-    function isAfter(dirtyDate, dirtyDateToCompare) {
-        requiredArgs(2, arguments);
-        var date = toDate(dirtyDate);
-        var dateToCompare = toDate(dirtyDateToCompare);
-        return date.getTime() > dateToCompare.getTime();
+        function wwwAfter(code2) {
+            effects.exit("literalAutolinkWww");
+            effects.exit("literalAutolink");
+            return ok2(code2);
+        }
     }
 
-    function isBefore(dirtyDate, dirtyDateToCompare) {
-        requiredArgs(2, arguments);
-        var date = toDate(dirtyDate);
-        var dateToCompare = toDate(dirtyDateToCompare);
-        return date.getTime() < dateToCompare.getTime();
-    }
+    function tokenizeProtocolAutolink(effects, ok2, nok) {
+        const self2 = this;
+        let buffer = "";
+        let seen = false;
+        return protocolStart;
 
-    function isWithinInterval(dirtyDate, interval2) {
-        requiredArgs(2, arguments);
-        var time = toDate(dirtyDate).getTime();
-        var startTime = toDate(interval2.start).getTime();
-        var endTime = toDate(interval2.end).getTime();
-        if (!(startTime <= endTime)) {
-            throw new RangeError("Invalid interval");
+        function protocolStart(code2) {
+            if ((code2 === 72 || code2 === 104) && previousProtocol.call(self2, self2.previous) && !previousUnbalanced(self2.events)) {
+                effects.enter("literalAutolink");
+                effects.enter("literalAutolinkHttp");
+                buffer += String.fromCodePoint(code2);
+                effects.consume(code2);
+                return protocolPrefixInside;
+            }
+            return nok(code2);
         }
-        return time >= startTime && time <= endTime;
-    }
 
-    function _arrayLikeToArray$9(arr, len) {
-        if (len == null || len > arr.length)
-            len = arr.length;
-        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
-            arr2[i2] = arr[i2];
-        return arr2;
-    }
-
-    function _unsupportedIterableToArray$9(o2, minLen) {
-        if (!o2)
-            return;
-        if (typeof o2 === "string")
-            return _arrayLikeToArray$9(o2, minLen);
-        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
-        if (n2 === "Object" && o2.constructor)
-            n2 = o2.constructor.name;
-        if (n2 === "Map" || n2 === "Set")
-            return Array.from(o2);
-        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
-            return _arrayLikeToArray$9(o2, minLen);
-    }
-
-    function _createForOfIteratorHelper(o2, allowArrayLike) {
-        var it2 = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
-        if (!it2) {
-            if (Array.isArray(o2) || (it2 = _unsupportedIterableToArray$9(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
-                if (it2)
-                    o2 = it2;
-                var i2 = 0;
-                var F2 = function F3() {};
-                return {
-                    s: F2,
-                    n: function n2() {
-                        if (i2 >= o2.length)
-                            return {
-                                done: true
-                            };
-                        return {
-                            done: false,
-                            value: o2[i2++]
-                        };
-                    },
-                    e: function e3(_e2) {
-                        throw _e2;
-                    },
-                    f: F2
-                };
+        function protocolPrefixInside(code2) {
+            if (asciiAlpha(code2) && buffer.length < 5) {
+                buffer += String.fromCodePoint(code2);
+                effects.consume(code2);
+                return protocolPrefixInside;
             }
-            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
-        }
-        var normalCompletion = true,
-            didErr = false,
-            err;
-        return {
-            s: function s2() {
-                it2 = it2.call(o2);
-            },
-            n: function n2() {
-                var step2 = it2.next();
-                normalCompletion = step2.done;
-                return step2;
-            },
-            e: function e3(_e2) {
-                didErr = true;
-                err = _e2;
-            },
-            f: function f2() {
-                try {
-                    if (!normalCompletion && it2["return"] != null)
-                        it2["return"]();
-                } finally {
-                    if (didErr)
-                        throw err;
+            if (code2 === 58) {
+                const protocol = buffer.toLowerCase();
+                if (protocol === "http" || protocol === "https") {
+                    effects.consume(code2);
+                    return protocolSlashesInside;
                 }
             }
-        };
-    }
-
-    function assign$5(target, object2) {
-        if (target == null) {
-            throw new TypeError("assign requires that input parameter not be null or undefined");
+            return nok(code2);
         }
-        for (var property in object2) {
-            if (Object.prototype.hasOwnProperty.call(object2, property)) {
-                target[property] = object2[property];
+
+        function protocolSlashesInside(code2) {
+            if (code2 === 47) {
+                effects.consume(code2);
+                if (seen) {
+                    return afterProtocol;
+                }
+                seen = true;
+                return protocolSlashesInside;
             }
+            return nok(code2);
         }
-        return target;
-    }
 
-    function _inherits$1(subClass, superClass) {
-        if (typeof superClass !== "function" && superClass !== null) {
-            throw new TypeError("Super expression must either be null or a function");
+        function afterProtocol(code2) {
+            return code2 === null || asciiControl(code2) || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || unicodePunctuation(code2) ? nok(code2) : effects.attempt(domain, effects.attempt(path$1, protocolAfter), nok)(code2);
         }
-        subClass.prototype = Object.create(superClass && superClass.prototype, {
-            constructor: {
-                value: subClass,
-                writable: true,
-                configurable: true
-            }
-        });
-        Object.defineProperty(subClass, "prototype", {
-            writable: false
-        });
-        if (superClass)
-            _setPrototypeOf$3(subClass, superClass);
-    }
 
-    function _possibleConstructorReturn$1(self2, call2) {
-        if (call2 && (_typeof$5(call2) === "object" || typeof call2 === "function")) {
-            return call2;
-        } else if (call2 !== void 0) {
-            throw new TypeError("Derived constructors may only return object or undefined");
+        function protocolAfter(code2) {
+            effects.exit("literalAutolinkHttp");
+            effects.exit("literalAutolink");
+            return ok2(code2);
         }
-        return _assertThisInitialized$3(self2);
     }
 
-    function _createSuper$1(Derived) {
-        var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
-        return function _createSuperInternal() {
-            var Super = _getPrototypeOf$2(Derived),
-                result;
-            if (hasNativeReflectConstruct) {
-                var NewTarget = _getPrototypeOf$2(this).constructor;
-                result = Reflect.construct(Super, arguments, NewTarget);
-            } else {
-                result = Super.apply(this, arguments);
-            }
-            return _possibleConstructorReturn$1(this, result);
-        };
-    }
+    function tokenizeWwwPrefix(effects, ok2, nok) {
+        let size2 = 0;
+        return wwwPrefixInside;
 
-    function _classCallCheck$g(instance2, Constructor) {
-        if (!(instance2 instanceof Constructor)) {
-            throw new TypeError("Cannot call a class as a function");
+        function wwwPrefixInside(code2) {
+            if ((code2 === 87 || code2 === 119) && size2 < 3) {
+                size2++;
+                effects.consume(code2);
+                return wwwPrefixInside;
+            }
+            if (code2 === 46 && size2 === 3) {
+                effects.consume(code2);
+                return wwwPrefixAfter;
+            }
+            return nok(code2);
         }
-    }
 
-    function toPrimitive(t2, r2) {
-        if ("object" != _typeof$5(t2) || !t2)
-            return t2;
-        var e3 = t2[Symbol.toPrimitive];
-        if (void 0 !== e3) {
-            var i2 = e3.call(t2, r2 || "default");
-            if ("object" != _typeof$5(i2))
-                return i2;
-            throw new TypeError("@@toPrimitive must return a primitive value.");
+        function wwwPrefixAfter(code2) {
+            return code2 === null ? nok(code2) : ok2(code2);
         }
-        return ("string" === r2 ? String : Number)(t2);
     }
 
-    function toPropertyKey(t2) {
-        var i2 = toPrimitive(t2, "string");
-        return "symbol" == _typeof$5(i2) ? i2 : i2 + "";
-    }
+    function tokenizeDomain(effects, ok2, nok) {
+        let underscoreInLastSegment;
+        let underscoreInLastLastSegment;
+        let seen;
+        return domainInside;
 
-    function _defineProperties$g(target, props) {
-        for (var i2 = 0; i2 < props.length; i2++) {
-            var descriptor = props[i2];
-            descriptor.enumerable = descriptor.enumerable || false;
-            descriptor.configurable = true;
-            if ("value" in descriptor)
-                descriptor.writable = true;
-            Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
+        function domainInside(code2) {
+            if (code2 === 46 || code2 === 95) {
+                return effects.check(trail, domainAfter, domainAtPunctuation)(code2);
+            }
+            if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || code2 !== 45 && unicodePunctuation(code2)) {
+                return domainAfter(code2);
+            }
+            seen = true;
+            effects.consume(code2);
+            return domainInside;
         }
-    }
 
-    function _createClass$g(Constructor, protoProps, staticProps) {
-        if (protoProps)
-            _defineProperties$g(Constructor.prototype, protoProps);
-        if (staticProps)
-            _defineProperties$g(Constructor, staticProps);
-        Object.defineProperty(Constructor, "prototype", {
-            writable: false
-        });
-        return Constructor;
-    }
+        function domainAtPunctuation(code2) {
+            if (code2 === 95) {
+                underscoreInLastSegment = true;
+            } else {
+                underscoreInLastLastSegment = underscoreInLastSegment;
+                underscoreInLastSegment = void 0;
+            }
+            effects.consume(code2);
+            return domainInside;
+        }
 
-    function _defineProperty$o(obj, key, value) {
-        key = toPropertyKey(key);
-        if (key in obj) {
-            Object.defineProperty(obj, key, {
-                value,
-                enumerable: true,
-                configurable: true,
-                writable: true
-            });
-        } else {
-            obj[key] = value;
+        function domainAfter(code2) {
+            if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
+                return nok(code2);
+            }
+            return ok2(code2);
         }
-        return obj;
     }
-    var TIMEZONE_UNIT_PRIORITY = 10;
-    var Setter = /* @__PURE__ */ function() {
-        function Setter2() {
-            _classCallCheck$g(this, Setter2);
-            _defineProperty$o(this, "priority", void 0);
-            _defineProperty$o(this, "subPriority", 0);
-        }
-        _createClass$g(Setter2, [{
-            key: "validate",
-            value: function validate2(_utcDate, _options) {
-                return true;
-            }
-        }]);
-        return Setter2;
-    }();
-    var ValueSetter = /* @__PURE__ */ function(_Setter) {
-        _inherits$1(ValueSetter2, _Setter);
-        var _super = _createSuper$1(ValueSetter2);
 
-        function ValueSetter2(value, validateValue, setValue, priority, subPriority) {
-            var _this;
-            _classCallCheck$g(this, ValueSetter2);
-            _this = _super.call(this);
-            _this.value = value;
-            _this.validateValue = validateValue;
-            _this.setValue = setValue;
-            _this.priority = priority;
-            if (subPriority) {
-                _this.subPriority = subPriority;
+    function tokenizePath(effects, ok2) {
+        let sizeOpen = 0;
+        let sizeClose = 0;
+        return pathInside;
+
+        function pathInside(code2) {
+            if (code2 === 40) {
+                sizeOpen++;
+                effects.consume(code2);
+                return pathInside;
             }
-            return _this;
-        }
-        _createClass$g(ValueSetter2, [{
-            key: "validate",
-            value: function validate2(utcDate, options) {
-                return this.validateValue(utcDate, this.value, options);
+            if (code2 === 41 && sizeClose < sizeOpen) {
+                return pathAtPunctuation(code2);
             }
-        }, {
-            key: "set",
-            value: function set2(utcDate, flags, options) {
-                return this.setValue(utcDate, flags, this.value, options);
+            if (code2 === 33 || code2 === 34 || code2 === 38 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 60 || code2 === 63 || code2 === 93 || code2 === 95 || code2 === 126) {
+                return effects.check(trail, ok2, pathAtPunctuation)(code2);
             }
-        }]);
-        return ValueSetter2;
-    }(Setter);
-    var DateToSystemTimezoneSetter = /* @__PURE__ */ function(_Setter2) {
-        _inherits$1(DateToSystemTimezoneSetter2, _Setter2);
-        var _super2 = _createSuper$1(DateToSystemTimezoneSetter2);
-
-        function DateToSystemTimezoneSetter2() {
-            var _this2;
-            _classCallCheck$g(this, DateToSystemTimezoneSetter2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+            if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
+                return ok2(code2);
             }
-            _this2 = _super2.call.apply(_super2, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
-            _defineProperty$o(_assertThisInitialized$3(_this2), "subPriority", -1);
-            return _this2;
+            effects.consume(code2);
+            return pathInside;
         }
-        _createClass$g(DateToSystemTimezoneSetter2, [{
-            key: "set",
-            value: function set2(date, flags) {
-                if (flags.timestampIsSet) {
-                    return date;
-                }
-                var convertedDate = new Date(0);
-                convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
-                convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
-                return convertedDate;
+
+        function pathAtPunctuation(code2) {
+            if (code2 === 41) {
+                sizeClose++;
             }
-        }]);
-        return DateToSystemTimezoneSetter2;
-    }(Setter);
-    var Parser$2 = /* @__PURE__ */ function() {
-        function Parser2() {
-            _classCallCheck$g(this, Parser2);
-            _defineProperty$o(this, "incompatibleTokens", void 0);
-            _defineProperty$o(this, "priority", void 0);
-            _defineProperty$o(this, "subPriority", void 0);
+            effects.consume(code2);
+            return pathInside;
         }
-        _createClass$g(Parser2, [{
-            key: "run",
-            value: function run(dateString, token, match2, options) {
-                var result = this.parse(dateString, token, match2, options);
-                if (!result) {
-                    return null;
-                }
-                return {
-                    setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
-                    rest: result.rest
-                };
-            }
-        }, {
-            key: "validate",
-            value: function validate2(_utcDate, _value, _options) {
-                return true;
-            }
-        }]);
-        return Parser2;
-    }();
-    var EraParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(EraParser2, _Parser);
-        var _super = _createSuper$1(EraParser2);
+    }
 
-        function EraParser2() {
-            var _this;
-            _classCallCheck$g(this, EraParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+    function tokenizeTrail(effects, ok2, nok) {
+        return trail2;
+
+        function trail2(code2) {
+            if (code2 === 33 || code2 === 34 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 63 || code2 === 95 || code2 === 126) {
+                effects.consume(code2);
+                return trail2;
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 140);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["R", "u", "t", "T"]);
-            return _this;
-        }
-        _createClass$g(EraParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                switch (token) {
-                    case "G":
-                    case "GG":
-                    case "GGG":
-                        return match2.era(dateString, {
-                            width: "abbreviated"
-                        }) || match2.era(dateString, {
-                            width: "narrow"
-                        });
-                    case "GGGGG":
-                        return match2.era(dateString, {
-                            width: "narrow"
-                        });
-                    case "GGGG":
-                    default:
-                        return match2.era(dateString, {
-                            width: "wide"
-                        }) || match2.era(dateString, {
-                            width: "abbreviated"
-                        }) || match2.era(dateString, {
-                            width: "narrow"
-                        });
-                }
+            if (code2 === 38) {
+                effects.consume(code2);
+                return trailCharRefStart;
             }
-        }, {
-            key: "set",
-            value: function set2(date, flags, value) {
-                flags.era = value;
-                date.setUTCFullYear(value, 0, 1);
-                date.setUTCHours(0, 0, 0, 0);
-                return date;
+            if (code2 === 93) {
+                effects.consume(code2);
+                return trailBracketAfter;
             }
-        }]);
-        return EraParser2;
-    }(Parser$2);
-    var millisecondsInMinute = 6e4;
-    var millisecondsInHour = 36e5;
-    var millisecondsInSecond = 1e3;
-    var numericPatterns = {
-        month: /^(1[0-2]|0?\d)/,
-        date: /^(3[0-1]|[0-2]?\d)/,
-        dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
-        week: /^(5[0-3]|[0-4]?\d)/,
-        hour23h: /^(2[0-3]|[0-1]?\d)/,
-        hour24h: /^(2[0-4]|[0-1]?\d)/,
-        hour11h: /^(1[0-1]|0?\d)/,
-        hour12h: /^(1[0-2]|0?\d)/,
-        minute: /^[0-5]?\d/,
-        second: /^[0-5]?\d/,
-        singleDigit: /^\d/,
-        twoDigits: /^\d{1,2}/,
-        threeDigits: /^\d{1,3}/,
-        fourDigits: /^\d{1,4}/,
-        anyDigitsSigned: /^-?\d+/,
-        singleDigitSigned: /^-?\d/,
-        twoDigitsSigned: /^-?\d{1,2}/,
-        threeDigitsSigned: /^-?\d{1,3}/,
-        fourDigitsSigned: /^-?\d{1,4}/
-    };
-    var timezonePatterns = {
-        basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
-        basic: /^([+-])(\d{2})(\d{2})|Z/,
-        basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
-        extended: /^([+-])(\d{2}):(\d{2})|Z/,
-        extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
-    };
-
-    function mapValue(parseFnResult, mapFn) {
-        if (!parseFnResult) {
-            return parseFnResult;
+            if (code2 === 60 || code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
+                return ok2(code2);
+            }
+            return nok(code2);
         }
-        return {
-            value: mapFn(parseFnResult.value),
-            rest: parseFnResult.rest
-        };
-    }
 
-    function parseNumericPattern(pattern, dateString) {
-        var matchResult = dateString.match(pattern);
-        if (!matchResult) {
-            return null;
+        function trailBracketAfter(code2) {
+            if (code2 === null || code2 === 40 || code2 === 91 || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
+                return ok2(code2);
+            }
+            return trail2(code2);
         }
-        return {
-            value: parseInt(matchResult[0], 10),
-            rest: dateString.slice(matchResult[0].length)
-        };
-    }
 
-    function parseTimezonePattern(pattern, dateString) {
-        var matchResult = dateString.match(pattern);
-        if (!matchResult) {
-            return null;
+        function trailCharRefStart(code2) {
+            return asciiAlpha(code2) ? trailCharRefInside(code2) : nok(code2);
         }
-        if (matchResult[0] === "Z") {
-            return {
-                value: 0,
-                rest: dateString.slice(1)
-            };
+
+        function trailCharRefInside(code2) {
+            if (code2 === 59) {
+                effects.consume(code2);
+                return trail2;
+            }
+            if (asciiAlpha(code2)) {
+                effects.consume(code2);
+                return trailCharRefInside;
+            }
+            return nok(code2);
         }
-        var sign2 = matchResult[1] === "+" ? 1 : -1;
-        var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
-        var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
-        var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
-        return {
-            value: sign2 * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
-            rest: dateString.slice(matchResult[0].length)
-        };
     }
 
-    function parseAnyDigitsSigned(dateString) {
-        return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
-    }
+    function tokenizeEmailDomainDotTrail(effects, ok2, nok) {
+        return start2;
 
-    function parseNDigits(n2, dateString) {
-        switch (n2) {
-            case 1:
-                return parseNumericPattern(numericPatterns.singleDigit, dateString);
-            case 2:
-                return parseNumericPattern(numericPatterns.twoDigits, dateString);
-            case 3:
-                return parseNumericPattern(numericPatterns.threeDigits, dateString);
-            case 4:
-                return parseNumericPattern(numericPatterns.fourDigits, dateString);
-            default:
-                return parseNumericPattern(new RegExp("^\\d{1," + n2 + "}"), dateString);
+        function start2(code2) {
+            effects.consume(code2);
+            return after;
         }
-    }
 
-    function parseNDigitsSigned(n2, dateString) {
-        switch (n2) {
-            case 1:
-                return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
-            case 2:
-                return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
-            case 3:
-                return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
-            case 4:
-                return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
-            default:
-                return parseNumericPattern(new RegExp("^-?\\d{1," + n2 + "}"), dateString);
+        function after(code2) {
+            return asciiAlphanumeric(code2) ? nok(code2) : ok2(code2);
         }
     }
 
-    function dayPeriodEnumToHours(dayPeriod) {
-        switch (dayPeriod) {
-            case "morning":
-                return 4;
-            case "evening":
-                return 17;
-            case "pm":
-            case "noon":
-            case "afternoon":
-                return 12;
-            case "am":
-            case "midnight":
-            case "night":
-            default:
-                return 0;
-        }
+    function previousWww(code2) {
+        return code2 === null || code2 === 40 || code2 === 42 || code2 === 95 || code2 === 91 || code2 === 93 || code2 === 126 || markdownLineEndingOrSpace(code2);
     }
 
-    function normalizeTwoDigitYear(twoDigitYear, currentYear) {
-        var isCommonEra = currentYear > 0;
-        var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
-        var result;
-        if (absCurrentYear <= 50) {
-            result = twoDigitYear || 100;
-        } else {
-            var rangeEnd2 = absCurrentYear + 50;
-            var rangeEndCentury = Math.floor(rangeEnd2 / 100) * 100;
-            var isPreviousCentury = twoDigitYear >= rangeEnd2 % 100;
-            result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
-        }
-        return isCommonEra ? result : 1 - result;
+    function previousProtocol(code2) {
+        return !asciiAlpha(code2);
     }
 
-    function isLeapYearIndex$1(year) {
-        return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
+    function previousEmail(code2) {
+        return !(code2 === 47 || gfmAtext(code2));
     }
-    var YearParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(YearParser2, _Parser);
-        var _super = _createSuper$1(YearParser2);
 
-        function YearParser2() {
-            var _this;
-            _classCallCheck$g(this, YearParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+    function gfmAtext(code2) {
+        return code2 === 43 || code2 === 45 || code2 === 46 || code2 === 95 || asciiAlphanumeric(code2);
+    }
+
+    function previousUnbalanced(events2) {
+        let index2 = events2.length;
+        let result = false;
+        while (index2--) {
+            const token = events2[index2][1];
+            if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
+                result = true;
+                break;
+            }
+            if (token._gfmAutolinkLiteralWalkedInto) {
+                result = false;
+                break;
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 130);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
-            return _this;
         }
-        _createClass$g(YearParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                var valueCallback = function valueCallback2(year) {
-                    return {
-                        year,
-                        isTwoDigitYear: token === "yy"
-                    };
-                };
-                switch (token) {
-                    case "y":
-                        return mapValue(parseNDigits(4, dateString), valueCallback);
-                    case "yo":
-                        return mapValue(match2.ordinalNumber(dateString, {
-                            unit: "year"
-                        }), valueCallback);
-                    default:
-                        return mapValue(parseNDigits(token.length, dateString), valueCallback);
+        if (events2.length > 0 && !result) {
+            events2[events2.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
+        }
+        return result;
+    }
+    const indent$1 = {
+        tokenize: tokenizeIndent,
+        partial: true
+    };
+
+    function gfmFootnote() {
+        return {
+            document: {
+                [91]: {
+                    tokenize: tokenizeDefinitionStart,
+                    continuation: {
+                        tokenize: tokenizeDefinitionContinuation
+                    },
+                    exit: gfmFootnoteDefinitionEnd
                 }
-            }
-        }, {
-            key: "validate",
-            value: function validate2(_date, value) {
-                return value.isTwoDigitYear || value.year > 0;
-            }
-        }, {
-            key: "set",
-            value: function set2(date, flags, value) {
-                var currentYear = date.getUTCFullYear();
-                if (value.isTwoDigitYear) {
-                    var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
-                    date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
-                    date.setUTCHours(0, 0, 0, 0);
-                    return date;
+            },
+            text: {
+                [91]: {
+                    tokenize: tokenizeGfmFootnoteCall
+                },
+                [93]: {
+                    add: "after",
+                    tokenize: tokenizePotentialGfmFootnoteCall,
+                    resolveTo: resolveToPotentialGfmFootnoteCall
                 }
-                var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
-                date.setUTCFullYear(year, 0, 1);
-                date.setUTCHours(0, 0, 0, 0);
-                return date;
             }
-        }]);
-        return YearParser2;
-    }(Parser$2);
-    var LocalWeekYearParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(LocalWeekYearParser2, _Parser);
-        var _super = _createSuper$1(LocalWeekYearParser2);
+        };
+    }
 
-        function LocalWeekYearParser2() {
-            var _this;
-            _classCallCheck$g(this, LocalWeekYearParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+    function tokenizePotentialGfmFootnoteCall(effects, ok2, nok) {
+        const self2 = this;
+        let index2 = self2.events.length;
+        const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
+        let labelStart;
+        while (index2--) {
+            const token = self2.events[index2][1];
+            if (token.type === "labelImage") {
+                labelStart = token;
+                break;
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 130);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]);
-            return _this;
-        }
-        _createClass$g(LocalWeekYearParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                var valueCallback = function valueCallback2(year) {
-                    return {
-                        year,
-                        isTwoDigitYear: token === "YY"
-                    };
-                };
-                switch (token) {
-                    case "Y":
-                        return mapValue(parseNDigits(4, dateString), valueCallback);
-                    case "Yo":
-                        return mapValue(match2.ordinalNumber(dateString, {
-                            unit: "year"
-                        }), valueCallback);
-                    default:
-                        return mapValue(parseNDigits(token.length, dateString), valueCallback);
-                }
+            if (token.type === "gfmFootnoteCall" || token.type === "labelLink" || token.type === "label" || token.type === "image" || token.type === "link") {
+                break;
             }
-        }, {
-            key: "validate",
-            value: function validate2(_date, value) {
-                return value.isTwoDigitYear || value.year > 0;
+        }
+        return start2;
+
+        function start2(code2) {
+            if (!labelStart || !labelStart._balanced) {
+                return nok(code2);
             }
-        }, {
-            key: "set",
-            value: function set2(date, flags, value, options) {
-                var currentYear = getUTCWeekYear(date, options);
-                if (value.isTwoDigitYear) {
-                    var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
-                    date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
-                    date.setUTCHours(0, 0, 0, 0);
-                    return startOfUTCWeek(date, options);
-                }
-                var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
-                date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
-                date.setUTCHours(0, 0, 0, 0);
-                return startOfUTCWeek(date, options);
+            const id2 = normalizeIdentifier(
+                self2.sliceSerialize({
+                    start: labelStart.end,
+                    end: self2.now()
+                })
+            );
+            if (id2.codePointAt(0) !== 94 || !defined.includes(id2.slice(1))) {
+                return nok(code2);
             }
-        }]);
-        return LocalWeekYearParser2;
-    }(Parser$2);
-    var ISOWeekYearParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(ISOWeekYearParser2, _Parser);
-        var _super = _createSuper$1(ISOWeekYearParser2);
+            effects.enter("gfmFootnoteCallLabelMarker");
+            effects.consume(code2);
+            effects.exit("gfmFootnoteCallLabelMarker");
+            return ok2(code2);
+        }
+    }
 
-        function ISOWeekYearParser2() {
-            var _this;
-            _classCallCheck$g(this, ISOWeekYearParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+    function resolveToPotentialGfmFootnoteCall(events2, context2) {
+        let index2 = events2.length;
+        while (index2--) {
+            if (events2[index2][1].type === "labelImage" && events2[index2][0] === "enter") {
+                events2[index2][1];
+                break;
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 130);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
-            return _this;
         }
-        _createClass$g(ISOWeekYearParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token) {
-                if (token === "R") {
-                    return parseNDigitsSigned(4, dateString);
-                }
-                return parseNDigitsSigned(token.length, dateString);
-            }
-        }, {
-            key: "set",
-            value: function set2(_date, _flags, value) {
-                var firstWeekOfYear = new Date(0);
-                firstWeekOfYear.setUTCFullYear(value, 0, 4);
-                firstWeekOfYear.setUTCHours(0, 0, 0, 0);
-                return startOfUTCISOWeek(firstWeekOfYear);
-            }
-        }]);
-        return ISOWeekYearParser2;
-    }(Parser$2);
-    var ExtendedYearParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(ExtendedYearParser2, _Parser);
-        var _super = _createSuper$1(ExtendedYearParser2);
+        events2[index2 + 1][1].type = "data";
+        events2[index2 + 3][1].type = "gfmFootnoteCallLabelMarker";
+        const call2 = {
+            type: "gfmFootnoteCall",
+            start: Object.assign({}, events2[index2 + 3][1].start),
+            end: Object.assign({}, events2[events2.length - 1][1].end)
+        };
+        const marker = {
+            type: "gfmFootnoteCallMarker",
+            start: Object.assign({}, events2[index2 + 3][1].end),
+            end: Object.assign({}, events2[index2 + 3][1].end)
+        };
+        marker.end.column++;
+        marker.end.offset++;
+        marker.end._bufferIndex++;
+        const string2 = {
+            type: "gfmFootnoteCallString",
+            start: Object.assign({}, marker.end),
+            end: Object.assign({}, events2[events2.length - 1][1].start)
+        };
+        const chunk = {
+            type: "chunkString",
+            contentType: "string",
+            start: Object.assign({}, string2.start),
+            end: Object.assign({}, string2.end)
+        };
+        const replacement = [
+            events2[index2 + 1],
+            events2[index2 + 2],
+            ["enter", call2, context2],
+            events2[index2 + 3],
+            events2[index2 + 4],
+            ["enter", marker, context2],
+            ["exit", marker, context2],
+            ["enter", string2, context2],
+            ["enter", chunk, context2],
+            ["exit", chunk, context2],
+            ["exit", string2, context2],
+            events2[events2.length - 2],
+            events2[events2.length - 1],
+            ["exit", call2, context2]
+        ];
+        events2.splice(index2, events2.length - index2 + 1, ...replacement);
+        return events2;
+    }
 
-        function ExtendedYearParser2() {
-            var _this;
-            _classCallCheck$g(this, ExtendedYearParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
-            }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 130);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
-            return _this;
+    function tokenizeGfmFootnoteCall(effects, ok2, nok) {
+        const self2 = this;
+        const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
+        let size2 = 0;
+        let data2;
+        return start2;
+
+        function start2(code2) {
+            effects.enter("gfmFootnoteCall");
+            effects.enter("gfmFootnoteCallLabelMarker");
+            effects.consume(code2);
+            effects.exit("gfmFootnoteCallLabelMarker");
+            return callStart;
         }
-        _createClass$g(ExtendedYearParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token) {
-                if (token === "u") {
-                    return parseNDigitsSigned(4, dateString);
-                }
-                return parseNDigitsSigned(token.length, dateString);
-            }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value) {
-                date.setUTCFullYear(value, 0, 1);
-                date.setUTCHours(0, 0, 0, 0);
-                return date;
-            }
-        }]);
-        return ExtendedYearParser2;
-    }(Parser$2);
-    var QuarterParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(QuarterParser2, _Parser);
-        var _super = _createSuper$1(QuarterParser2);
 
-        function QuarterParser2() {
-            var _this;
-            _classCallCheck$g(this, QuarterParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
-            }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 120);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
-            return _this;
+        function callStart(code2) {
+            if (code2 !== 94)
+                return nok(code2);
+            effects.enter("gfmFootnoteCallMarker");
+            effects.consume(code2);
+            effects.exit("gfmFootnoteCallMarker");
+            effects.enter("gfmFootnoteCallString");
+            effects.enter("chunkString").contentType = "string";
+            return callData;
         }
-        _createClass$g(QuarterParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                switch (token) {
-                    case "Q":
-                    case "QQ":
-                        return parseNDigits(token.length, dateString);
-                    case "Qo":
-                        return match2.ordinalNumber(dateString, {
-                            unit: "quarter"
-                        });
-                    case "QQQ":
-                        return match2.quarter(dateString, {
-                            width: "abbreviated",
-                            context: "formatting"
-                        }) || match2.quarter(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                    case "QQQQQ":
-                        return match2.quarter(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                    case "QQQQ":
-                    default:
-                        return match2.quarter(dateString, {
-                            width: "wide",
-                            context: "formatting"
-                        }) || match2.quarter(dateString, {
-                            width: "abbreviated",
-                            context: "formatting"
-                        }) || match2.quarter(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                }
-            }
-        }, {
-            key: "validate",
-            value: function validate2(_date, value) {
-                return value >= 1 && value <= 4;
-            }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value) {
-                date.setUTCMonth((value - 1) * 3, 1);
-                date.setUTCHours(0, 0, 0, 0);
-                return date;
-            }
-        }]);
-        return QuarterParser2;
-    }(Parser$2);
-    var StandAloneQuarterParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(StandAloneQuarterParser2, _Parser);
-        var _super = _createSuper$1(StandAloneQuarterParser2);
 
-        function StandAloneQuarterParser2() {
-            var _this;
-            _classCallCheck$g(this, StandAloneQuarterParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+        function callData(code2) {
+            if (size2 > 999 || code2 === 93 && !data2 || code2 === null || code2 === 91 || markdownLineEndingOrSpace(code2)) {
+                return nok(code2);
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 120);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
-            return _this;
-        }
-        _createClass$g(StandAloneQuarterParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                switch (token) {
-                    case "q":
-                    case "qq":
-                        return parseNDigits(token.length, dateString);
-                    case "qo":
-                        return match2.ordinalNumber(dateString, {
-                            unit: "quarter"
-                        });
-                    case "qqq":
-                        return match2.quarter(dateString, {
-                            width: "abbreviated",
-                            context: "standalone"
-                        }) || match2.quarter(dateString, {
-                            width: "narrow",
-                            context: "standalone"
-                        });
-                    case "qqqqq":
-                        return match2.quarter(dateString, {
-                            width: "narrow",
-                            context: "standalone"
-                        });
-                    case "qqqq":
-                    default:
-                        return match2.quarter(dateString, {
-                            width: "wide",
-                            context: "standalone"
-                        }) || match2.quarter(dateString, {
-                            width: "abbreviated",
-                            context: "standalone"
-                        }) || match2.quarter(dateString, {
-                            width: "narrow",
-                            context: "standalone"
-                        });
+            if (code2 === 93) {
+                effects.exit("chunkString");
+                const token = effects.exit("gfmFootnoteCallString");
+                if (!defined.includes(normalizeIdentifier(self2.sliceSerialize(token)))) {
+                    return nok(code2);
                 }
+                effects.enter("gfmFootnoteCallLabelMarker");
+                effects.consume(code2);
+                effects.exit("gfmFootnoteCallLabelMarker");
+                effects.exit("gfmFootnoteCall");
+                return ok2;
             }
-        }, {
-            key: "validate",
-            value: function validate2(_date, value) {
-                return value >= 1 && value <= 4;
+            if (!markdownLineEndingOrSpace(code2)) {
+                data2 = true;
             }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value) {
-                date.setUTCMonth((value - 1) * 3, 1);
-                date.setUTCHours(0, 0, 0, 0);
-                return date;
+            size2++;
+            effects.consume(code2);
+            return code2 === 92 ? callEscape : callData;
+        }
+
+        function callEscape(code2) {
+            if (code2 === 91 || code2 === 92 || code2 === 93) {
+                effects.consume(code2);
+                size2++;
+                return callData;
             }
-        }]);
-        return StandAloneQuarterParser2;
-    }(Parser$2);
-    var MonthParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(MonthParser2, _Parser);
-        var _super = _createSuper$1(MonthParser2);
+            return callData(code2);
+        }
+    }
 
-        function MonthParser2() {
-            var _this;
-            _classCallCheck$g(this, MonthParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+    function tokenizeDefinitionStart(effects, ok2, nok) {
+        const self2 = this;
+        const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
+        let identifier;
+        let size2 = 0;
+        let data2;
+        return start2;
+
+        function start2(code2) {
+            effects.enter("gfmFootnoteDefinition")._container = true;
+            effects.enter("gfmFootnoteDefinitionLabel");
+            effects.enter("gfmFootnoteDefinitionLabelMarker");
+            effects.consume(code2);
+            effects.exit("gfmFootnoteDefinitionLabelMarker");
+            return labelAtMarker;
+        }
+
+        function labelAtMarker(code2) {
+            if (code2 === 94) {
+                effects.enter("gfmFootnoteDefinitionMarker");
+                effects.consume(code2);
+                effects.exit("gfmFootnoteDefinitionMarker");
+                effects.enter("gfmFootnoteDefinitionLabelString");
+                effects.enter("chunkString").contentType = "string";
+                return labelInside;
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 110);
-            return _this;
+            return nok(code2);
         }
-        _createClass$g(MonthParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                var valueCallback = function valueCallback2(value) {
-                    return value - 1;
-                };
-                switch (token) {
-                    case "M":
-                        return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
-                    case "MM":
-                        return mapValue(parseNDigits(2, dateString), valueCallback);
-                    case "Mo":
-                        return mapValue(match2.ordinalNumber(dateString, {
-                            unit: "month"
-                        }), valueCallback);
-                    case "MMM":
-                        return match2.month(dateString, {
-                            width: "abbreviated",
-                            context: "formatting"
-                        }) || match2.month(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                    case "MMMMM":
-                        return match2.month(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                    case "MMMM":
-                    default:
-                        return match2.month(dateString, {
-                            width: "wide",
-                            context: "formatting"
-                        }) || match2.month(dateString, {
-                            width: "abbreviated",
-                            context: "formatting"
-                        }) || match2.month(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                }
+
+        function labelInside(code2) {
+            if (size2 > 999 || code2 === 93 && !data2 || code2 === null || code2 === 91 || markdownLineEndingOrSpace(code2)) {
+                return nok(code2);
             }
-        }, {
-            key: "validate",
-            value: function validate2(_date, value) {
-                return value >= 0 && value <= 11;
+            if (code2 === 93) {
+                effects.exit("chunkString");
+                const token = effects.exit("gfmFootnoteDefinitionLabelString");
+                identifier = normalizeIdentifier(self2.sliceSerialize(token));
+                effects.enter("gfmFootnoteDefinitionLabelMarker");
+                effects.consume(code2);
+                effects.exit("gfmFootnoteDefinitionLabelMarker");
+                effects.exit("gfmFootnoteDefinitionLabel");
+                return labelAfter;
             }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value) {
-                date.setUTCMonth(value, 1);
-                date.setUTCHours(0, 0, 0, 0);
-                return date;
+            if (!markdownLineEndingOrSpace(code2)) {
+                data2 = true;
             }
-        }]);
-        return MonthParser2;
-    }(Parser$2);
-    var StandAloneMonthParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(StandAloneMonthParser2, _Parser);
-        var _super = _createSuper$1(StandAloneMonthParser2);
+            size2++;
+            effects.consume(code2);
+            return code2 === 92 ? labelEscape : labelInside;
+        }
 
-        function StandAloneMonthParser2() {
-            var _this;
-            _classCallCheck$g(this, StandAloneMonthParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+        function labelEscape(code2) {
+            if (code2 === 91 || code2 === 92 || code2 === 93) {
+                effects.consume(code2);
+                size2++;
+                return labelInside;
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 110);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]);
-            return _this;
+            return labelInside(code2);
         }
-        _createClass$g(StandAloneMonthParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                var valueCallback = function valueCallback2(value) {
-                    return value - 1;
-                };
-                switch (token) {
-                    case "L":
-                        return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
-                    case "LL":
-                        return mapValue(parseNDigits(2, dateString), valueCallback);
-                    case "Lo":
-                        return mapValue(match2.ordinalNumber(dateString, {
-                            unit: "month"
-                        }), valueCallback);
-                    case "LLL":
-                        return match2.month(dateString, {
-                            width: "abbreviated",
-                            context: "standalone"
-                        }) || match2.month(dateString, {
-                            width: "narrow",
-                            context: "standalone"
-                        });
-                    case "LLLLL":
-                        return match2.month(dateString, {
-                            width: "narrow",
-                            context: "standalone"
-                        });
-                    case "LLLL":
-                    default:
-                        return match2.month(dateString, {
-                            width: "wide",
-                            context: "standalone"
-                        }) || match2.month(dateString, {
-                            width: "abbreviated",
-                            context: "standalone"
-                        }) || match2.month(dateString, {
-                            width: "narrow",
-                            context: "standalone"
-                        });
+
+        function labelAfter(code2) {
+            if (code2 === 58) {
+                effects.enter("definitionMarker");
+                effects.consume(code2);
+                effects.exit("definitionMarker");
+                if (!defined.includes(identifier)) {
+                    defined.push(identifier);
                 }
+                return factorySpace(
+                    effects,
+                    whitespaceAfter,
+                    "gfmFootnoteDefinitionWhitespace"
+                );
             }
-        }, {
-            key: "validate",
-            value: function validate2(_date, value) {
-                return value >= 0 && value <= 11;
-            }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value) {
-                date.setUTCMonth(value, 1);
-                date.setUTCHours(0, 0, 0, 0);
-                return date;
-            }
-        }]);
-        return StandAloneMonthParser2;
-    }(Parser$2);
+            return nok(code2);
+        }
 
-    function setUTCWeek(dirtyDate, dirtyWeek, options) {
-        requiredArgs(2, arguments);
-        var date = toDate(dirtyDate);
-        var week = toInteger$2(dirtyWeek);
-        var diff = getUTCWeek(date, options) - week;
-        date.setUTCDate(date.getUTCDate() - diff * 7);
-        return date;
+        function whitespaceAfter(code2) {
+            return ok2(code2);
+        }
     }
-    var LocalWeekParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(LocalWeekParser2, _Parser);
-        var _super = _createSuper$1(LocalWeekParser2);
 
-        function LocalWeekParser2() {
-            var _this;
-            _classCallCheck$g(this, LocalWeekParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
-            }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 100);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]);
-            return _this;
-        }
-        _createClass$g(LocalWeekParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                switch (token) {
-                    case "w":
-                        return parseNumericPattern(numericPatterns.week, dateString);
-                    case "wo":
-                        return match2.ordinalNumber(dateString, {
-                            unit: "week"
-                        });
-                    default:
-                        return parseNDigits(token.length, dateString);
-                }
-            }
-        }, {
-            key: "validate",
-            value: function validate2(_date, value) {
-                return value >= 1 && value <= 53;
-            }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value, options) {
-                return startOfUTCWeek(setUTCWeek(date, value, options), options);
-            }
-        }]);
-        return LocalWeekParser2;
-    }(Parser$2);
+    function tokenizeDefinitionContinuation(effects, ok2, nok) {
+        return effects.check(blankLine, ok2, effects.attempt(indent$1, ok2, nok));
+    }
 
-    function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
-        requiredArgs(2, arguments);
-        var date = toDate(dirtyDate);
-        var isoWeek = toInteger$2(dirtyISOWeek);
-        var diff = getUTCISOWeek(date) - isoWeek;
-        date.setUTCDate(date.getUTCDate() - diff * 7);
-        return date;
+    function gfmFootnoteDefinitionEnd(effects) {
+        effects.exit("gfmFootnoteDefinition");
     }
-    var ISOWeekParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(ISOWeekParser2, _Parser);
-        var _super = _createSuper$1(ISOWeekParser2);
 
-        function ISOWeekParser2() {
-            var _this;
-            _classCallCheck$g(this, ISOWeekParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
-            }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 100);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
-            return _this;
+    function tokenizeIndent(effects, ok2, nok) {
+        const self2 = this;
+        return factorySpace(
+            effects,
+            afterPrefix,
+            "gfmFootnoteDefinitionIndent",
+            4 + 1
+        );
+
+        function afterPrefix(code2) {
+            const tail = self2.events[self2.events.length - 1];
+            return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok2(code2) : nok(code2);
         }
-        _createClass$g(ISOWeekParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                switch (token) {
-                    case "I":
-                        return parseNumericPattern(numericPatterns.week, dateString);
-                    case "Io":
-                        return match2.ordinalNumber(dateString, {
-                            unit: "week"
-                        });
-                    default:
-                        return parseNDigits(token.length, dateString);
-                }
-            }
-        }, {
-            key: "validate",
-            value: function validate2(_date, value) {
-                return value >= 1 && value <= 53;
-            }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value) {
-                return startOfUTCISOWeek(setUTCISOWeek(date, value));
-            }
-        }]);
-        return ISOWeekParser2;
-    }(Parser$2);
-    var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
-    var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
-    var DateParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(DateParser2, _Parser);
-        var _super = _createSuper$1(DateParser2);
+    }
 
-        function DateParser2() {
-            var _this;
-            _classCallCheck$g(this, DateParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
-            }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 90);
-            _defineProperty$o(_assertThisInitialized$3(_this), "subPriority", 1);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]);
-            return _this;
+    function gfmStrikethrough(options) {
+        const options_ = options || {};
+        let single = options_.singleTilde;
+        const tokenizer2 = {
+            tokenize: tokenizeStrikethrough,
+            resolveAll: resolveAllStrikethrough
+        };
+        if (single === null || single === void 0) {
+            single = true;
         }
-        _createClass$g(DateParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                switch (token) {
-                    case "d":
-                        return parseNumericPattern(numericPatterns.date, dateString);
-                    case "do":
-                        return match2.ordinalNumber(dateString, {
-                            unit: "date"
-                        });
-                    default:
-                        return parseNDigits(token.length, dateString);
-                }
-            }
-        }, {
-            key: "validate",
-            value: function validate2(date, value) {
-                var year = date.getUTCFullYear();
-                var isLeapYear = isLeapYearIndex$1(year);
-                var month = date.getUTCMonth();
-                if (isLeapYear) {
-                    return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
-                } else {
-                    return value >= 1 && value <= DAYS_IN_MONTH[month];
-                }
-            }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value) {
-                date.setUTCDate(value);
-                date.setUTCHours(0, 0, 0, 0);
-                return date;
+        return {
+            text: {
+                [126]: tokenizer2
+            },
+            insideSpan: {
+                null: [tokenizer2]
+            },
+            attentionMarkers: {
+                null: [126]
             }
-        }]);
-        return DateParser2;
-    }(Parser$2);
-    var DayOfYearParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(DayOfYearParser2, _Parser);
-        var _super = _createSuper$1(DayOfYearParser2);
+        };
 
-        function DayOfYearParser2() {
-            var _this;
-            _classCallCheck$g(this, DayOfYearParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
-            }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 90);
-            _defineProperty$o(_assertThisInitialized$3(_this), "subpriority", 1);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]);
-            return _this;
-        }
-        _createClass$g(DayOfYearParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                switch (token) {
-                    case "D":
-                    case "DD":
-                        return parseNumericPattern(numericPatterns.dayOfYear, dateString);
-                    case "Do":
-                        return match2.ordinalNumber(dateString, {
-                            unit: "date"
-                        });
-                    default:
-                        return parseNDigits(token.length, dateString);
+        function resolveAllStrikethrough(events2, context2) {
+            let index2 = -1;
+            while (++index2 < events2.length) {
+                if (events2[index2][0] === "enter" && events2[index2][1].type === "strikethroughSequenceTemporary" && events2[index2][1]._close) {
+                    let open = index2;
+                    while (open--) {
+                        if (events2[open][0] === "exit" && events2[open][1].type === "strikethroughSequenceTemporary" && events2[open][1]._open && events2[index2][1].end.offset - events2[index2][1].start.offset === events2[open][1].end.offset - events2[open][1].start.offset) {
+                            events2[index2][1].type = "strikethroughSequence";
+                            events2[open][1].type = "strikethroughSequence";
+                            const strikethrough2 = {
+                                type: "strikethrough",
+                                start: Object.assign({}, events2[open][1].start),
+                                end: Object.assign({}, events2[index2][1].end)
+                            };
+                            const text2 = {
+                                type: "strikethroughText",
+                                start: Object.assign({}, events2[open][1].end),
+                                end: Object.assign({}, events2[index2][1].start)
+                            };
+                            const nextEvents = [
+                                ["enter", strikethrough2, context2],
+                                ["enter", events2[open][1], context2],
+                                ["exit", events2[open][1], context2],
+                                ["enter", text2, context2]
+                            ];
+                            const insideSpan2 = context2.parser.constructs.insideSpan.null;
+                            if (insideSpan2) {
+                                splice(
+                                    nextEvents,
+                                    nextEvents.length,
+                                    0,
+                                    resolveAll(insideSpan2, events2.slice(open + 1, index2), context2)
+                                );
+                            }
+                            splice(nextEvents, nextEvents.length, 0, [
+                                ["exit", text2, context2],
+                                ["enter", events2[index2][1], context2],
+                                ["exit", events2[index2][1], context2],
+                                ["exit", strikethrough2, context2]
+                            ]);
+                            splice(events2, open - 1, index2 - open + 3, nextEvents);
+                            index2 = open + nextEvents.length - 2;
+                            break;
+                        }
+                    }
                 }
             }
-        }, {
-            key: "validate",
-            value: function validate2(date, value) {
-                var year = date.getUTCFullYear();
-                var isLeapYear = isLeapYearIndex$1(year);
-                if (isLeapYear) {
-                    return value >= 1 && value <= 366;
-                } else {
-                    return value >= 1 && value <= 365;
+            index2 = -1;
+            while (++index2 < events2.length) {
+                if (events2[index2][1].type === "strikethroughSequenceTemporary") {
+                    events2[index2][1].type = "data";
                 }
             }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value) {
-                date.setUTCMonth(0, value);
-                date.setUTCHours(0, 0, 0, 0);
-                return date;
-            }
-        }]);
-        return DayOfYearParser2;
-    }(Parser$2);
-
-    function setUTCDay(dirtyDate, dirtyDay, options) {
-        var _ref2, _ref22, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
-        requiredArgs(2, arguments);
-        var defaultOptions2 = getDefaultOptions();
-        var weekStartsOn = toInteger$2((_ref2 = (_ref22 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : 0);
-        if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
-            throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
+            return events2;
         }
-        var date = toDate(dirtyDate);
-        var day = toInteger$2(dirtyDay);
-        var currentDay = date.getUTCDay();
-        var remainder = day % 7;
-        var dayIndex = (remainder + 7) % 7;
-        var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
-        date.setUTCDate(date.getUTCDate() + diff);
-        return date;
-    }
-    var DayParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(DayParser2, _Parser);
-        var _super = _createSuper$1(DayParser2);
 
-        function DayParser2() {
-            var _this;
-            _classCallCheck$g(this, DayParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
-            }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 90);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
-            return _this;
-        }
-        _createClass$g(DayParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                switch (token) {
-                    case "E":
-                    case "EE":
-                    case "EEE":
-                        return match2.day(dateString, {
-                            width: "abbreviated",
-                            context: "formatting"
-                        }) || match2.day(dateString, {
-                            width: "short",
-                            context: "formatting"
-                        }) || match2.day(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                    case "EEEEE":
-                        return match2.day(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                    case "EEEEEE":
-                        return match2.day(dateString, {
-                            width: "short",
-                            context: "formatting"
-                        }) || match2.day(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                    case "EEEE":
-                    default:
-                        return match2.day(dateString, {
-                            width: "wide",
-                            context: "formatting"
-                        }) || match2.day(dateString, {
-                            width: "abbreviated",
-                            context: "formatting"
-                        }) || match2.day(dateString, {
-                            width: "short",
-                            context: "formatting"
-                        }) || match2.day(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                }
-            }
-        }, {
-            key: "validate",
-            value: function validate2(_date, value) {
-                return value >= 0 && value <= 6;
-            }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value, options) {
-                date = setUTCDay(date, value, options);
-                date.setUTCHours(0, 0, 0, 0);
-                return date;
-            }
-        }]);
-        return DayParser2;
-    }(Parser$2);
-    var LocalDayParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(LocalDayParser2, _Parser);
-        var _super = _createSuper$1(LocalDayParser2);
+        function tokenizeStrikethrough(effects, ok2, nok) {
+            const previous2 = this.previous;
+            const events2 = this.events;
+            let size2 = 0;
+            return start2;
 
-        function LocalDayParser2() {
-            var _this;
-            _classCallCheck$g(this, LocalDayParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
-            }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 90);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]);
-            return _this;
-        }
-        _createClass$g(LocalDayParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2, options) {
-                var valueCallback = function valueCallback2(value) {
-                    var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
-                    return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
-                };
-                switch (token) {
-                    case "e":
-                    case "ee":
-                        return mapValue(parseNDigits(token.length, dateString), valueCallback);
-                    case "eo":
-                        return mapValue(match2.ordinalNumber(dateString, {
-                            unit: "day"
-                        }), valueCallback);
-                    case "eee":
-                        return match2.day(dateString, {
-                            width: "abbreviated",
-                            context: "formatting"
-                        }) || match2.day(dateString, {
-                            width: "short",
-                            context: "formatting"
-                        }) || match2.day(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                    case "eeeee":
-                        return match2.day(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                    case "eeeeee":
-                        return match2.day(dateString, {
-                            width: "short",
-                            context: "formatting"
-                        }) || match2.day(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                    case "eeee":
-                    default:
-                        return match2.day(dateString, {
-                            width: "wide",
-                            context: "formatting"
-                        }) || match2.day(dateString, {
-                            width: "abbreviated",
-                            context: "formatting"
-                        }) || match2.day(dateString, {
-                            width: "short",
-                            context: "formatting"
-                        }) || match2.day(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
+            function start2(code2) {
+                if (previous2 === 126 && events2[events2.length - 1][1].type !== "characterEscape") {
+                    return nok(code2);
                 }
+                effects.enter("strikethroughSequenceTemporary");
+                return more(code2);
             }
-        }, {
-            key: "validate",
-            value: function validate2(_date, value) {
-                return value >= 0 && value <= 6;
-            }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value, options) {
-                date = setUTCDay(date, value, options);
-                date.setUTCHours(0, 0, 0, 0);
-                return date;
-            }
-        }]);
-        return LocalDayParser2;
-    }(Parser$2);
-    var StandAloneLocalDayParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(StandAloneLocalDayParser2, _Parser);
-        var _super = _createSuper$1(StandAloneLocalDayParser2);
 
-        function StandAloneLocalDayParser2() {
-            var _this;
-            _classCallCheck$g(this, StandAloneLocalDayParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+            function more(code2) {
+                const before = classifyCharacter(previous2);
+                if (code2 === 126) {
+                    if (size2 > 1)
+                        return nok(code2);
+                    effects.consume(code2);
+                    size2++;
+                    return more;
+                }
+                if (size2 < 2 && !single)
+                    return nok(code2);
+                const token = effects.exit("strikethroughSequenceTemporary");
+                const after = classifyCharacter(code2);
+                token._open = !after || after === 2 && Boolean(before);
+                token._close = !before || before === 2 && Boolean(after);
+                return ok2(code2);
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 90);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]);
-            return _this;
         }
-        _createClass$g(StandAloneLocalDayParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2, options) {
-                var valueCallback = function valueCallback2(value) {
-                    var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
-                    return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
-                };
-                switch (token) {
-                    case "c":
-                    case "cc":
-                        return mapValue(parseNDigits(token.length, dateString), valueCallback);
-                    case "co":
-                        return mapValue(match2.ordinalNumber(dateString, {
-                            unit: "day"
-                        }), valueCallback);
-                    case "ccc":
-                        return match2.day(dateString, {
-                            width: "abbreviated",
-                            context: "standalone"
-                        }) || match2.day(dateString, {
-                            width: "short",
-                            context: "standalone"
-                        }) || match2.day(dateString, {
-                            width: "narrow",
-                            context: "standalone"
-                        });
-                    case "ccccc":
-                        return match2.day(dateString, {
-                            width: "narrow",
-                            context: "standalone"
-                        });
-                    case "cccccc":
-                        return match2.day(dateString, {
-                            width: "short",
-                            context: "standalone"
-                        }) || match2.day(dateString, {
-                            width: "narrow",
-                            context: "standalone"
-                        });
-                    case "cccc":
-                    default:
-                        return match2.day(dateString, {
-                            width: "wide",
-                            context: "standalone"
-                        }) || match2.day(dateString, {
-                            width: "abbreviated",
-                            context: "standalone"
-                        }) || match2.day(dateString, {
-                            width: "short",
-                            context: "standalone"
-                        }) || match2.day(dateString, {
-                            width: "narrow",
-                            context: "standalone"
-                        });
-                }
+    }
+    class EditMap {
+        constructor() {
+            this.map = [];
+        }
+        add(index2, remove2, add2) {
+            addImpl(this, index2, remove2, add2);
+        }
+        consume(events2) {
+            this.map.sort(function(a2, b2) {
+                return a2[0] - b2[0];
+            });
+            if (this.map.length === 0) {
+                return;
             }
-        }, {
-            key: "validate",
-            value: function validate2(_date, value) {
-                return value >= 0 && value <= 6;
+            let index2 = this.map.length;
+            const vecs = [];
+            while (index2 > 0) {
+                index2 -= 1;
+                vecs.push(
+                    events2.slice(this.map[index2][0] + this.map[index2][1]),
+                    this.map[index2][2]
+                );
+                events2.length = this.map[index2][0];
             }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value, options) {
-                date = setUTCDay(date, value, options);
-                date.setUTCHours(0, 0, 0, 0);
-                return date;
+            vecs.push([...events2]);
+            events2.length = 0;
+            let slice = vecs.pop();
+            while (slice) {
+                events2.push(...slice);
+                slice = vecs.pop();
             }
-        }]);
-        return StandAloneLocalDayParser2;
-    }(Parser$2);
-
-    function setUTCISODay(dirtyDate, dirtyDay) {
-        requiredArgs(2, arguments);
-        var day = toInteger$2(dirtyDay);
-        if (day % 7 === 0) {
-            day = day - 7;
+            this.map.length = 0;
         }
-        var weekStartsOn = 1;
-        var date = toDate(dirtyDate);
-        var currentDay = date.getUTCDay();
-        var remainder = day % 7;
-        var dayIndex = (remainder + 7) % 7;
-        var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
-        date.setUTCDate(date.getUTCDate() + diff);
-        return date;
     }
-    var ISODayParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(ISODayParser2, _Parser);
-        var _super = _createSuper$1(ISODayParser2);
 
-        function ISODayParser2() {
-            var _this;
-            _classCallCheck$g(this, ISODayParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+    function addImpl(editMap, at2, remove2, add2) {
+        let index2 = 0;
+        if (remove2 === 0 && add2.length === 0) {
+            return;
+        }
+        while (index2 < editMap.map.length) {
+            if (editMap.map[index2][0] === at2) {
+                editMap.map[index2][1] += remove2;
+                editMap.map[index2][2].push(...add2);
+                return;
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 90);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]);
-            return _this;
+            index2 += 1;
         }
-        _createClass$g(ISODayParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                var valueCallback = function valueCallback2(value) {
-                    if (value === 0) {
-                        return 7;
+        editMap.map.push([at2, remove2, add2]);
+    }
+
+    function gfmTableAlign(events2, index2) {
+        let inDelimiterRow = false;
+        const align = [];
+        while (index2 < events2.length) {
+            const event2 = events2[index2];
+            if (inDelimiterRow) {
+                if (event2[0] === "enter") {
+                    if (event2[1].type === "tableContent") {
+                        align.push(
+                            events2[index2 + 1][1].type === "tableDelimiterMarker" ? "left" : "none"
+                        );
                     }
-                    return value;
-                };
-                switch (token) {
-                    case "i":
-                    case "ii":
-                        return parseNDigits(token.length, dateString);
-                    case "io":
-                        return match2.ordinalNumber(dateString, {
-                            unit: "day"
-                        });
-                    case "iii":
-                        return mapValue(match2.day(dateString, {
-                            width: "abbreviated",
-                            context: "formatting"
-                        }) || match2.day(dateString, {
-                            width: "short",
-                            context: "formatting"
-                        }) || match2.day(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        }), valueCallback);
-                    case "iiiii":
-                        return mapValue(match2.day(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        }), valueCallback);
-                    case "iiiiii":
-                        return mapValue(match2.day(dateString, {
-                            width: "short",
-                            context: "formatting"
-                        }) || match2.day(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        }), valueCallback);
-                    case "iiii":
-                    default:
-                        return mapValue(match2.day(dateString, {
-                            width: "wide",
-                            context: "formatting"
-                        }) || match2.day(dateString, {
-                            width: "abbreviated",
-                            context: "formatting"
-                        }) || match2.day(dateString, {
-                            width: "short",
-                            context: "formatting"
-                        }) || match2.day(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        }), valueCallback);
+                } else if (event2[1].type === "tableContent") {
+                    if (events2[index2 - 1][1].type === "tableDelimiterMarker") {
+                        const alignIndex = align.length - 1;
+                        align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
+                    }
+                } else if (event2[1].type === "tableDelimiterRow") {
+                    break;
                 }
+            } else if (event2[0] === "enter" && event2[1].type === "tableDelimiterRow") {
+                inDelimiterRow = true;
             }
-        }, {
-            key: "validate",
-            value: function validate2(_date, value) {
-                return value >= 1 && value <= 7;
-            }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value) {
-                date = setUTCISODay(date, value);
-                date.setUTCHours(0, 0, 0, 0);
-                return date;
-            }
-        }]);
-        return ISODayParser2;
-    }(Parser$2);
-    var AMPMParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(AMPMParser2, _Parser);
-        var _super = _createSuper$1(AMPMParser2);
-
-        function AMPMParser2() {
-            var _this;
-            _classCallCheck$g(this, AMPMParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
-            }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 80);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
-            return _this;
+            index2 += 1;
         }
-        _createClass$g(AMPMParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                switch (token) {
-                    case "a":
-                    case "aa":
-                    case "aaa":
-                        return match2.dayPeriod(dateString, {
-                            width: "abbreviated",
-                            context: "formatting"
-                        }) || match2.dayPeriod(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                    case "aaaaa":
-                        return match2.dayPeriod(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                    case "aaaa":
-                    default:
-                        return match2.dayPeriod(dateString, {
-                            width: "wide",
-                            context: "formatting"
-                        }) || match2.dayPeriod(dateString, {
-                            width: "abbreviated",
-                            context: "formatting"
-                        }) || match2.dayPeriod(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
+        return align;
+    }
+
+    function gfmTable() {
+        return {
+            flow: {
+                null: {
+                    tokenize: tokenizeTable,
+                    resolveAll: resolveTable
                 }
             }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value) {
-                date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
-                return date;
-            }
-        }]);
-        return AMPMParser2;
-    }(Parser$2);
-    var AMPMMidnightParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(AMPMMidnightParser2, _Parser);
-        var _super = _createSuper$1(AMPMMidnightParser2);
+        };
+    }
 
-        function AMPMMidnightParser2() {
-            var _this;
-            _classCallCheck$g(this, AMPMMidnightParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
-            }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 80);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
-            return _this;
-        }
-        _createClass$g(AMPMMidnightParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                switch (token) {
-                    case "b":
-                    case "bb":
-                    case "bbb":
-                        return match2.dayPeriod(dateString, {
-                            width: "abbreviated",
-                            context: "formatting"
-                        }) || match2.dayPeriod(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                    case "bbbbb":
-                        return match2.dayPeriod(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                    case "bbbb":
-                    default:
-                        return match2.dayPeriod(dateString, {
-                            width: "wide",
-                            context: "formatting"
-                        }) || match2.dayPeriod(dateString, {
-                            width: "abbreviated",
-                            context: "formatting"
-                        }) || match2.dayPeriod(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                }
+    function tokenizeTable(effects, ok2, nok) {
+        const self2 = this;
+        let size2 = 0;
+        let sizeB = 0;
+        let seen;
+        return start2;
+
+        function start2(code2) {
+            let index2 = self2.events.length - 1;
+            while (index2 > -1) {
+                const type2 = self2.events[index2][1].type;
+                if (type2 === "lineEnding" || type2 === "linePrefix")
+                    index2--;
+                else
+                    break;
             }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value) {
-                date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
-                return date;
+            const tail = index2 > -1 ? self2.events[index2][1].type : null;
+            const next2 = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
+            if (next2 === bodyRowStart && self2.parser.lazy[self2.now().line]) {
+                return nok(code2);
             }
-        }]);
-        return AMPMMidnightParser2;
-    }(Parser$2);
-    var DayPeriodParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(DayPeriodParser2, _Parser);
-        var _super = _createSuper$1(DayPeriodParser2);
+            return next2(code2);
+        }
 
-        function DayPeriodParser2() {
-            var _this;
-            _classCallCheck$g(this, DayPeriodParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
-            }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 80);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["a", "b", "t", "T"]);
-            return _this;
+        function headRowBefore(code2) {
+            effects.enter("tableHead");
+            effects.enter("tableRow");
+            return headRowStart(code2);
         }
-        _createClass$g(DayPeriodParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                switch (token) {
-                    case "B":
-                    case "BB":
-                    case "BBB":
-                        return match2.dayPeriod(dateString, {
-                            width: "abbreviated",
-                            context: "formatting"
-                        }) || match2.dayPeriod(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                    case "BBBBB":
-                        return match2.dayPeriod(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                    case "BBBB":
-                    default:
-                        return match2.dayPeriod(dateString, {
-                            width: "wide",
-                            context: "formatting"
-                        }) || match2.dayPeriod(dateString, {
-                            width: "abbreviated",
-                            context: "formatting"
-                        }) || match2.dayPeriod(dateString, {
-                            width: "narrow",
-                            context: "formatting"
-                        });
-                }
-            }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value) {
-                date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
-                return date;
-            }
-        }]);
-        return DayPeriodParser2;
-    }(Parser$2);
-    var Hour1to12Parser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(Hour1to12Parser2, _Parser);
-        var _super = _createSuper$1(Hour1to12Parser2);
 
-        function Hour1to12Parser2() {
-            var _this;
-            _classCallCheck$g(this, Hour1to12Parser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+        function headRowStart(code2) {
+            if (code2 === 124) {
+                return headRowBreak(code2);
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 70);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["H", "K", "k", "t", "T"]);
-            return _this;
+            seen = true;
+            sizeB += 1;
+            return headRowBreak(code2);
         }
-        _createClass$g(Hour1to12Parser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                switch (token) {
-                    case "h":
-                        return parseNumericPattern(numericPatterns.hour12h, dateString);
-                    case "ho":
-                        return match2.ordinalNumber(dateString, {
-                            unit: "hour"
-                        });
-                    default:
-                        return parseNDigits(token.length, dateString);
-                }
-            }
-        }, {
-            key: "validate",
-            value: function validate2(_date, value) {
-                return value >= 1 && value <= 12;
-            }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value) {
-                var isPM = date.getUTCHours() >= 12;
-                if (isPM && value < 12) {
-                    date.setUTCHours(value + 12, 0, 0, 0);
-                } else if (!isPM && value === 12) {
-                    date.setUTCHours(0, 0, 0, 0);
-                } else {
-                    date.setUTCHours(value, 0, 0, 0);
-                }
-                return date;
-            }
-        }]);
-        return Hour1to12Parser2;
-    }(Parser$2);
-    var Hour0to23Parser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(Hour0to23Parser2, _Parser);
-        var _super = _createSuper$1(Hour0to23Parser2);
 
-        function Hour0to23Parser2() {
-            var _this;
-            _classCallCheck$g(this, Hour0to23Parser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+        function headRowBreak(code2) {
+            if (code2 === null) {
+                return nok(code2);
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 70);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
-            return _this;
-        }
-        _createClass$g(Hour0to23Parser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                switch (token) {
-                    case "H":
-                        return parseNumericPattern(numericPatterns.hour23h, dateString);
-                    case "Ho":
-                        return match2.ordinalNumber(dateString, {
-                            unit: "hour"
-                        });
-                    default:
-                        return parseNDigits(token.length, dateString);
+            if (markdownLineEnding(code2)) {
+                if (sizeB > 1) {
+                    sizeB = 0;
+                    self2.interrupt = true;
+                    effects.exit("tableRow");
+                    effects.enter("lineEnding");
+                    effects.consume(code2);
+                    effects.exit("lineEnding");
+                    return headDelimiterStart;
                 }
+                return nok(code2);
             }
-        }, {
-            key: "validate",
-            value: function validate2(_date, value) {
-                return value >= 0 && value <= 23;
+            if (markdownSpace(code2)) {
+                return factorySpace(effects, headRowBreak, "whitespace")(code2);
             }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value) {
-                date.setUTCHours(value, 0, 0, 0);
-                return date;
+            sizeB += 1;
+            if (seen) {
+                seen = false;
+                size2 += 1;
             }
-        }]);
-        return Hour0to23Parser2;
-    }(Parser$2);
-    var Hour0To11Parser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(Hour0To11Parser2, _Parser);
-        var _super = _createSuper$1(Hour0To11Parser2);
-
-        function Hour0To11Parser2() {
-            var _this;
-            _classCallCheck$g(this, Hour0To11Parser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+            if (code2 === 124) {
+                effects.enter("tableCellDivider");
+                effects.consume(code2);
+                effects.exit("tableCellDivider");
+                seen = true;
+                return headRowBreak;
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 70);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["h", "H", "k", "t", "T"]);
-            return _this;
+            effects.enter("data");
+            return headRowData(code2);
         }
-        _createClass$g(Hour0To11Parser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                switch (token) {
-                    case "K":
-                        return parseNumericPattern(numericPatterns.hour11h, dateString);
-                    case "Ko":
-                        return match2.ordinalNumber(dateString, {
-                            unit: "hour"
-                        });
-                    default:
-                        return parseNDigits(token.length, dateString);
-                }
-            }
-        }, {
-            key: "validate",
-            value: function validate2(_date, value) {
-                return value >= 0 && value <= 11;
-            }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value) {
-                var isPM = date.getUTCHours() >= 12;
-                if (isPM && value < 12) {
-                    date.setUTCHours(value + 12, 0, 0, 0);
-                } else {
-                    date.setUTCHours(value, 0, 0, 0);
-                }
-                return date;
-            }
-        }]);
-        return Hour0To11Parser2;
-    }(Parser$2);
-    var Hour1To24Parser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(Hour1To24Parser2, _Parser);
-        var _super = _createSuper$1(Hour1To24Parser2);
 
-        function Hour1To24Parser2() {
-            var _this;
-            _classCallCheck$g(this, Hour1To24Parser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+        function headRowData(code2) {
+            if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
+                effects.exit("data");
+                return headRowBreak(code2);
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 70);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
-            return _this;
+            effects.consume(code2);
+            return code2 === 92 ? headRowEscape : headRowData;
         }
-        _createClass$g(Hour1To24Parser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                switch (token) {
-                    case "k":
-                        return parseNumericPattern(numericPatterns.hour24h, dateString);
-                    case "ko":
-                        return match2.ordinalNumber(dateString, {
-                            unit: "hour"
-                        });
-                    default:
-                        return parseNDigits(token.length, dateString);
-                }
-            }
-        }, {
-            key: "validate",
-            value: function validate2(_date, value) {
-                return value >= 1 && value <= 24;
-            }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value) {
-                var hours = value <= 24 ? value % 24 : value;
-                date.setUTCHours(hours, 0, 0, 0);
-                return date;
-            }
-        }]);
-        return Hour1To24Parser2;
-    }(Parser$2);
-    var MinuteParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(MinuteParser2, _Parser);
-        var _super = _createSuper$1(MinuteParser2);
 
-        function MinuteParser2() {
-            var _this;
-            _classCallCheck$g(this, MinuteParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+        function headRowEscape(code2) {
+            if (code2 === 92 || code2 === 124) {
+                effects.consume(code2);
+                return headRowData;
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 60);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["t", "T"]);
-            return _this;
+            return headRowData(code2);
         }
-        _createClass$g(MinuteParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                switch (token) {
-                    case "m":
-                        return parseNumericPattern(numericPatterns.minute, dateString);
-                    case "mo":
-                        return match2.ordinalNumber(dateString, {
-                            unit: "minute"
-                        });
-                    default:
-                        return parseNDigits(token.length, dateString);
-                }
+
+        function headDelimiterStart(code2) {
+            self2.interrupt = false;
+            if (self2.parser.lazy[self2.now().line]) {
+                return nok(code2);
             }
-        }, {
-            key: "validate",
-            value: function validate2(_date, value) {
-                return value >= 0 && value <= 59;
+            effects.enter("tableDelimiterRow");
+            seen = false;
+            if (markdownSpace(code2)) {
+                return factorySpace(
+                    effects,
+                    headDelimiterBefore,
+                    "linePrefix",
+                    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
+                )(code2);
             }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value) {
-                date.setUTCMinutes(value, 0, 0);
-                return date;
+            return headDelimiterBefore(code2);
+        }
+
+        function headDelimiterBefore(code2) {
+            if (code2 === 45 || code2 === 58) {
+                return headDelimiterValueBefore(code2);
             }
-        }]);
-        return MinuteParser2;
-    }(Parser$2);
-    var SecondParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(SecondParser2, _Parser);
-        var _super = _createSuper$1(SecondParser2);
+            if (code2 === 124) {
+                seen = true;
+                effects.enter("tableCellDivider");
+                effects.consume(code2);
+                effects.exit("tableCellDivider");
+                return headDelimiterCellBefore;
+            }
+            return headDelimiterNok(code2);
+        }
 
-        function SecondParser2() {
-            var _this;
-            _classCallCheck$g(this, SecondParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+        function headDelimiterCellBefore(code2) {
+            if (markdownSpace(code2)) {
+                return factorySpace(effects, headDelimiterValueBefore, "whitespace")(code2);
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 50);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["t", "T"]);
-            return _this;
+            return headDelimiterValueBefore(code2);
         }
-        _createClass$g(SecondParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token, match2) {
-                switch (token) {
-                    case "s":
-                        return parseNumericPattern(numericPatterns.second, dateString);
-                    case "so":
-                        return match2.ordinalNumber(dateString, {
-                            unit: "second"
-                        });
-                    default:
-                        return parseNDigits(token.length, dateString);
-                }
+
+        function headDelimiterValueBefore(code2) {
+            if (code2 === 58) {
+                sizeB += 1;
+                seen = true;
+                effects.enter("tableDelimiterMarker");
+                effects.consume(code2);
+                effects.exit("tableDelimiterMarker");
+                return headDelimiterLeftAlignmentAfter;
             }
-        }, {
-            key: "validate",
-            value: function validate2(_date, value) {
-                return value >= 0 && value <= 59;
+            if (code2 === 45) {
+                sizeB += 1;
+                return headDelimiterLeftAlignmentAfter(code2);
             }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value) {
-                date.setUTCSeconds(value, 0);
-                return date;
+            if (code2 === null || markdownLineEnding(code2)) {
+                return headDelimiterCellAfter(code2);
             }
-        }]);
-        return SecondParser2;
-    }(Parser$2);
-    var FractionOfSecondParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(FractionOfSecondParser2, _Parser);
-        var _super = _createSuper$1(FractionOfSecondParser2);
+            return headDelimiterNok(code2);
+        }
 
-        function FractionOfSecondParser2() {
-            var _this;
-            _classCallCheck$g(this, FractionOfSecondParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+        function headDelimiterLeftAlignmentAfter(code2) {
+            if (code2 === 45) {
+                effects.enter("tableDelimiterFiller");
+                return headDelimiterFiller(code2);
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 30);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["t", "T"]);
-            return _this;
+            return headDelimiterNok(code2);
         }
-        _createClass$g(FractionOfSecondParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token) {
-                var valueCallback = function valueCallback2(value) {
-                    return Math.floor(value * Math.pow(10, -token.length + 3));
-                };
-                return mapValue(parseNDigits(token.length, dateString), valueCallback);
+
+        function headDelimiterFiller(code2) {
+            if (code2 === 45) {
+                effects.consume(code2);
+                return headDelimiterFiller;
             }
-        }, {
-            key: "set",
-            value: function set2(date, _flags, value) {
-                date.setUTCMilliseconds(value);
-                return date;
+            if (code2 === 58) {
+                seen = true;
+                effects.exit("tableDelimiterFiller");
+                effects.enter("tableDelimiterMarker");
+                effects.consume(code2);
+                effects.exit("tableDelimiterMarker");
+                return headDelimiterRightAlignmentAfter;
             }
-        }]);
-        return FractionOfSecondParser2;
-    }(Parser$2);
-    var ISOTimezoneWithZParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(ISOTimezoneWithZParser2, _Parser);
-        var _super = _createSuper$1(ISOTimezoneWithZParser2);
+            effects.exit("tableDelimiterFiller");
+            return headDelimiterRightAlignmentAfter(code2);
+        }
 
-        function ISOTimezoneWithZParser2() {
-            var _this;
-            _classCallCheck$g(this, ISOTimezoneWithZParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+        function headDelimiterRightAlignmentAfter(code2) {
+            if (markdownSpace(code2)) {
+                return factorySpace(effects, headDelimiterCellAfter, "whitespace")(code2);
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 10);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["t", "T", "x"]);
-            return _this;
+            return headDelimiterCellAfter(code2);
         }
-        _createClass$g(ISOTimezoneWithZParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token) {
-                switch (token) {
-                    case "X":
-                        return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
-                    case "XX":
-                        return parseTimezonePattern(timezonePatterns.basic, dateString);
-                    case "XXXX":
-                        return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
-                    case "XXXXX":
-                        return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
-                    case "XXX":
-                    default:
-                        return parseTimezonePattern(timezonePatterns.extended, dateString);
-                }
+
+        function headDelimiterCellAfter(code2) {
+            if (code2 === 124) {
+                return headDelimiterBefore(code2);
             }
-        }, {
-            key: "set",
-            value: function set2(date, flags, value) {
-                if (flags.timestampIsSet) {
-                    return date;
+            if (code2 === null || markdownLineEnding(code2)) {
+                if (!seen || size2 !== sizeB) {
+                    return headDelimiterNok(code2);
                 }
-                return new Date(date.getTime() - value);
+                effects.exit("tableDelimiterRow");
+                effects.exit("tableHead");
+                return ok2(code2);
             }
-        }]);
-        return ISOTimezoneWithZParser2;
-    }(Parser$2);
-    var ISOTimezoneParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(ISOTimezoneParser2, _Parser);
-        var _super = _createSuper$1(ISOTimezoneParser2);
+            return headDelimiterNok(code2);
+        }
 
-        function ISOTimezoneParser2() {
-            var _this;
-            _classCallCheck$g(this, ISOTimezoneParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
-            }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 10);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["t", "T", "X"]);
-            return _this;
+        function headDelimiterNok(code2) {
+            return nok(code2);
         }
-        _createClass$g(ISOTimezoneParser2, [{
-            key: "parse",
-            value: function parse2(dateString, token) {
-                switch (token) {
-                    case "x":
-                        return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
-                    case "xx":
-                        return parseTimezonePattern(timezonePatterns.basic, dateString);
-                    case "xxxx":
-                        return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
-                    case "xxxxx":
-                        return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
-                    case "xxx":
-                    default:
-                        return parseTimezonePattern(timezonePatterns.extended, dateString);
-                }
-            }
-        }, {
-            key: "set",
-            value: function set2(date, flags, value) {
-                if (flags.timestampIsSet) {
-                    return date;
-                }
-                return new Date(date.getTime() - value);
-            }
-        }]);
-        return ISOTimezoneParser2;
-    }(Parser$2);
-    var TimestampSecondsParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(TimestampSecondsParser2, _Parser);
-        var _super = _createSuper$1(TimestampSecondsParser2);
 
-        function TimestampSecondsParser2() {
-            var _this;
-            _classCallCheck$g(this, TimestampSecondsParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
-            }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 40);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", "*");
-            return _this;
+        function bodyRowStart(code2) {
+            effects.enter("tableRow");
+            return bodyRowBreak(code2);
         }
-        _createClass$g(TimestampSecondsParser2, [{
-            key: "parse",
-            value: function parse2(dateString) {
-                return parseAnyDigitsSigned(dateString);
-            }
-        }, {
-            key: "set",
-            value: function set2(_date, _flags, value) {
-                return [new Date(value * 1e3), {
-                    timestampIsSet: true
-                }];
-            }
-        }]);
-        return TimestampSecondsParser2;
-    }(Parser$2);
-    var TimestampMillisecondsParser = /* @__PURE__ */ function(_Parser) {
-        _inherits$1(TimestampMillisecondsParser2, _Parser);
-        var _super = _createSuper$1(TimestampMillisecondsParser2);
 
-        function TimestampMillisecondsParser2() {
-            var _this;
-            _classCallCheck$g(this, TimestampMillisecondsParser2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+        function bodyRowBreak(code2) {
+            if (code2 === 124) {
+                effects.enter("tableCellDivider");
+                effects.consume(code2);
+                effects.exit("tableCellDivider");
+                return bodyRowBreak;
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 20);
-            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", "*");
-            return _this;
-        }
-        _createClass$g(TimestampMillisecondsParser2, [{
-            key: "parse",
-            value: function parse2(dateString) {
-                return parseAnyDigitsSigned(dateString);
+            if (code2 === null || markdownLineEnding(code2)) {
+                effects.exit("tableRow");
+                return ok2(code2);
             }
-        }, {
-            key: "set",
-            value: function set2(_date, _flags, value) {
-                return [new Date(value), {
-                    timestampIsSet: true
-                }];
+            if (markdownSpace(code2)) {
+                return factorySpace(effects, bodyRowBreak, "whitespace")(code2);
             }
-        }]);
-        return TimestampMillisecondsParser2;
-    }(Parser$2);
-    var parsers = {
-        G: new EraParser(),
-        y: new YearParser(),
-        Y: new LocalWeekYearParser(),
-        R: new ISOWeekYearParser(),
-        u: new ExtendedYearParser(),
-        Q: new QuarterParser(),
-        q: new StandAloneQuarterParser(),
-        M: new MonthParser(),
-        L: new StandAloneMonthParser(),
-        w: new LocalWeekParser(),
-        I: new ISOWeekParser(),
-        d: new DateParser(),
-        D: new DayOfYearParser(),
-        E: new DayParser(),
-        e: new LocalDayParser(),
-        c: new StandAloneLocalDayParser(),
-        i: new ISODayParser(),
-        a: new AMPMParser(),
-        b: new AMPMMidnightParser(),
-        B: new DayPeriodParser(),
-        h: new Hour1to12Parser(),
-        H: new Hour0to23Parser(),
-        K: new Hour0To11Parser(),
-        k: new Hour1To24Parser(),
-        m: new MinuteParser(),
-        s: new SecondParser(),
-        S: new FractionOfSecondParser(),
-        X: new ISOTimezoneWithZParser(),
-        x: new ISOTimezoneParser(),
-        t: new TimestampSecondsParser(),
-        T: new TimestampMillisecondsParser()
-    };
-    var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
-    var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
-    var escapedStringRegExp = /^'([^]*?)'?$/;
-    var doubleQuoteRegExp = /''/g;
-    var notWhitespaceRegExp = /\S/;
-    var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
-
-    function parse$8(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
-        var _ref2, _options$locale, _ref22, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
-        requiredArgs(3, arguments);
-        var dateString = String(dirtyDateString);
-        var formatString = String(dirtyFormatString);
-        var defaultOptions2 = getDefaultOptions();
-        var locale2 = (_ref2 = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref2 !== void 0 ? _ref2 : defaultLocale;
-        if (!locale2.match) {
-            throw new RangeError("locale must contain match property");
-        }
-        var firstWeekContainsDate = toInteger$2((_ref22 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref22 !== void 0 ? _ref22 : 1);
-        if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
-            throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
-        }
-        var weekStartsOn = toInteger$2((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
-        if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
-            throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
+            effects.enter("data");
+            return bodyRowData(code2);
         }
-        if (formatString === "") {
-            if (dateString === "") {
-                return toDate(dirtyReferenceDate);
-            } else {
-                return new Date(NaN);
+
+        function bodyRowData(code2) {
+            if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
+                effects.exit("data");
+                return bodyRowBreak(code2);
             }
+            effects.consume(code2);
+            return code2 === 92 ? bodyRowEscape : bodyRowData;
         }
-        var subFnOptions = {
-            firstWeekContainsDate,
-            weekStartsOn,
-            locale: locale2
-        };
-        var setters = [new DateToSystemTimezoneSetter()];
-        var tokens2 = formatString.match(longFormattingTokensRegExp).map(function(substring) {
-            var firstCharacter = substring[0];
-            if (firstCharacter in longFormatters$1) {
-                var longFormatter = longFormatters$1[firstCharacter];
-                return longFormatter(substring, locale2.formatLong);
+
+        function bodyRowEscape(code2) {
+            if (code2 === 92 || code2 === 124) {
+                effects.consume(code2);
+                return bodyRowData;
             }
-            return substring;
-        }).join("").match(formattingTokensRegExp);
-        var usedTokens = [];
-        var _iterator = _createForOfIteratorHelper(tokens2),
-            _step;
-        try {
-            var _loop = function _loop2() {
-                var token = _step.value;
-                if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
-                    throwProtectedError(token, formatString, dirtyDateString);
-                }
-                if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
-                    throwProtectedError(token, formatString, dirtyDateString);
-                }
-                var firstCharacter = token[0];
-                var parser2 = parsers[firstCharacter];
-                if (parser2) {
-                    var incompatibleTokens = parser2.incompatibleTokens;
-                    if (Array.isArray(incompatibleTokens)) {
-                        var incompatibleToken = usedTokens.find(function(usedToken) {
-                            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
-                        });
-                        if (incompatibleToken) {
-                            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
-                        }
-                    } else if (parser2.incompatibleTokens === "*" && usedTokens.length > 0) {
-                        throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
+            return bodyRowData(code2);
+        }
+    }
+
+    function resolveTable(events2, context2) {
+        let index2 = -1;
+        let inFirstCellAwaitingPipe = true;
+        let rowKind = 0;
+        let lastCell = [0, 0, 0, 0];
+        let cell = [0, 0, 0, 0];
+        let afterHeadAwaitingFirstBodyRow = false;
+        let lastTableEnd = 0;
+        let currentTable;
+        let currentBody;
+        let currentCell;
+        const map2 = new EditMap();
+        while (++index2 < events2.length) {
+            const event2 = events2[index2];
+            const token = event2[1];
+            if (event2[0] === "enter") {
+                if (token.type === "tableHead") {
+                    afterHeadAwaitingFirstBodyRow = false;
+                    if (lastTableEnd !== 0) {
+                        flushTableEnd(map2, context2, lastTableEnd, currentTable, currentBody);
+                        currentBody = void 0;
+                        lastTableEnd = 0;
                     }
-                    usedTokens.push({
-                        token: firstCharacter,
-                        fullToken: token
-                    });
-                    var parseResult = parser2.run(dateString, token, locale2.match, subFnOptions);
-                    if (!parseResult) {
-                        return {
-                            v: new Date(NaN)
+                    currentTable = {
+                        type: "table",
+                        start: Object.assign({}, token.start),
+                        end: Object.assign({}, token.end)
+                    };
+                    map2.add(index2, 0, [
+                        ["enter", currentTable, context2]
+                    ]);
+                } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
+                    inFirstCellAwaitingPipe = true;
+                    currentCell = void 0;
+                    lastCell = [0, 0, 0, 0];
+                    cell = [0, index2 + 1, 0, 0];
+                    if (afterHeadAwaitingFirstBodyRow) {
+                        afterHeadAwaitingFirstBodyRow = false;
+                        currentBody = {
+                            type: "tableBody",
+                            start: Object.assign({}, token.start),
+                            end: Object.assign({}, token.end)
                         };
+                        map2.add(index2, 0, [
+                            ["enter", currentBody, context2]
+                        ]);
                     }
-                    setters.push(parseResult.setter);
-                    dateString = parseResult.rest;
-                } else {
-                    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
-                        throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
-                    }
-                    if (token === "''") {
-                        token = "'";
-                    } else if (firstCharacter === "'") {
-                        token = cleanEscapedString(token);
+                    rowKind = token.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
+                } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
+                    inFirstCellAwaitingPipe = false;
+                    if (cell[2] === 0) {
+                        if (lastCell[1] !== 0) {
+                            cell[0] = cell[1];
+                            currentCell = flushCell(
+                                map2,
+                                context2,
+                                lastCell,
+                                rowKind,
+                                void 0,
+                                currentCell
+                            );
+                            lastCell = [0, 0, 0, 0];
+                        }
+                        cell[2] = index2;
                     }
-                    if (dateString.indexOf(token) === 0) {
-                        dateString = dateString.slice(token.length);
+                } else if (token.type === "tableCellDivider") {
+                    if (inFirstCellAwaitingPipe) {
+                        inFirstCellAwaitingPipe = false;
                     } else {
-                        return {
-                            v: new Date(NaN)
-                        };
+                        if (lastCell[1] !== 0) {
+                            cell[0] = cell[1];
+                            currentCell = flushCell(
+                                map2,
+                                context2,
+                                lastCell,
+                                rowKind,
+                                void 0,
+                                currentCell
+                            );
+                        }
+                        lastCell = cell;
+                        cell = [lastCell[1], index2, 0, 0];
                     }
                 }
-            };
-            for (_iterator.s(); !(_step = _iterator.n()).done;) {
-                var _ret = _loop();
-                if (_typeof$5(_ret) === "object")
-                    return _ret.v;
+            } else if (token.type === "tableHead") {
+                afterHeadAwaitingFirstBodyRow = true;
+                lastTableEnd = index2;
+            } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
+                lastTableEnd = index2;
+                if (lastCell[1] !== 0) {
+                    cell[0] = cell[1];
+                    currentCell = flushCell(
+                        map2,
+                        context2,
+                        lastCell,
+                        rowKind,
+                        index2,
+                        currentCell
+                    );
+                } else if (cell[1] !== 0) {
+                    currentCell = flushCell(map2, context2, cell, rowKind, index2, currentCell);
+                }
+                rowKind = 0;
+            } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
+                cell[3] = index2;
             }
-        } catch (err) {
-            _iterator.e(err);
-        } finally {
-            _iterator.f();
         }
-        if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
-            return new Date(NaN);
-        }
-        var uniquePrioritySetters = setters.map(function(setter2) {
-            return setter2.priority;
-        }).sort(function(a2, b2) {
-            return b2 - a2;
-        }).filter(function(priority, index2, array2) {
-            return array2.indexOf(priority) === index2;
-        }).map(function(priority) {
-            return setters.filter(function(setter2) {
-                return setter2.priority === priority;
-            }).sort(function(a2, b2) {
-                return b2.subPriority - a2.subPriority;
-            });
-        }).map(function(setterArray) {
-            return setterArray[0];
-        });
-        var date = toDate(dirtyReferenceDate);
-        if (isNaN(date.getTime())) {
-            return new Date(NaN);
+        if (lastTableEnd !== 0) {
+            flushTableEnd(map2, context2, lastTableEnd, currentTable, currentBody);
         }
-        var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
-        var flags = {};
-        var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters),
-            _step2;
-        try {
-            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
-                var setter = _step2.value;
-                if (!setter.validate(utcDate, subFnOptions)) {
-                    return new Date(NaN);
-                }
-                var result = setter.set(utcDate, flags, subFnOptions);
-                if (Array.isArray(result)) {
-                    utcDate = result[0];
-                    assign$5(flags, result[1]);
-                } else {
-                    utcDate = result;
-                }
+        map2.consume(context2.events);
+        index2 = -1;
+        while (++index2 < context2.events.length) {
+            const event2 = context2.events[index2];
+            if (event2[0] === "enter" && event2[1].type === "table") {
+                event2[1]._align = gfmTableAlign(context2.events, index2);
             }
-        } catch (err) {
-            _iterator2.e(err);
-        } finally {
-            _iterator2.f();
         }
-        return utcDate;
-    }
-
-    function cleanEscapedString(input) {
-        return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
+        return events2;
     }
 
-    function parseISO(argument, options) {
-        var _options$additionalDi;
-        requiredArgs(1, arguments);
-        var additionalDigits = toInteger$2((_options$additionalDi = options === null || options === void 0 ? void 0 : options.additionalDigits) !== null && _options$additionalDi !== void 0 ? _options$additionalDi : 2);
-        if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
-            throw new RangeError("additionalDigits must be 0, 1 or 2");
-        }
-        if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
-            return new Date(NaN);
-        }
-        var dateStrings = splitDateString(argument);
-        var date;
-        if (dateStrings.date) {
-            var parseYearResult = parseYear(dateStrings.date, additionalDigits);
-            date = parseDate(parseYearResult.restDateString, parseYearResult.year);
-        }
-        if (!date || isNaN(date.getTime())) {
-            return new Date(NaN);
+    function flushCell(map2, context2, range2, rowKind, rowEnd, previousCell) {
+        const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
+        const valueName = "tableContent";
+        if (range2[0] !== 0) {
+            previousCell.end = Object.assign({}, getPoint(context2.events, range2[0]));
+            map2.add(range2[0], 0, [
+                ["exit", previousCell, context2]
+            ]);
         }
-        var timestamp = date.getTime();
-        var time = 0;
-        var offset2;
-        if (dateStrings.time) {
-            time = parseTime(dateStrings.time);
-            if (isNaN(time)) {
-                return new Date(NaN);
+        const now2 = getPoint(context2.events, range2[1]);
+        previousCell = {
+            type: groupName,
+            start: Object.assign({}, now2),
+            end: Object.assign({}, now2)
+        };
+        map2.add(range2[1], 0, [
+            ["enter", previousCell, context2]
+        ]);
+        if (range2[2] !== 0) {
+            const relatedStart = getPoint(context2.events, range2[2]);
+            const relatedEnd = getPoint(context2.events, range2[3]);
+            const valueToken = {
+                type: valueName,
+                start: Object.assign({}, relatedStart),
+                end: Object.assign({}, relatedEnd)
+            };
+            map2.add(range2[2], 0, [
+                ["enter", valueToken, context2]
+            ]);
+            if (rowKind !== 2) {
+                const start2 = context2.events[range2[2]];
+                const end2 = context2.events[range2[3]];
+                start2[1].end = Object.assign({}, end2[1].end);
+                start2[1].type = "chunkText";
+                start2[1].contentType = "text";
+                if (range2[3] > range2[2] + 1) {
+                    const a2 = range2[2] + 1;
+                    const b2 = range2[3] - range2[2] - 1;
+                    map2.add(a2, b2, []);
+                }
             }
+            map2.add(range2[3] + 1, 0, [
+                ["exit", valueToken, context2]
+            ]);
         }
-        if (dateStrings.timezone) {
-            offset2 = parseTimezone(dateStrings.timezone);
-            if (isNaN(offset2)) {
-                return new Date(NaN);
-            }
-        } else {
-            var dirtyDate = new Date(timestamp + time);
-            var result = new Date(0);
-            result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
-            result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
-            return result;
+        if (rowEnd !== void 0) {
+            previousCell.end = Object.assign({}, getPoint(context2.events, rowEnd));
+            map2.add(rowEnd, 0, [
+                ["exit", previousCell, context2]
+            ]);
+            previousCell = void 0;
         }
-        return new Date(timestamp + time + offset2);
+        return previousCell;
     }
-    var patterns = {
-        dateTimeDelimiter: /[T ]/,
-        timeZoneDelimiter: /[Z ]/i,
-        timezone: /([Z+-].*)$/
-    };
-    var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
-    var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
-    var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
 
-    function splitDateString(dateString) {
-        var dateStrings = {};
-        var array2 = dateString.split(patterns.dateTimeDelimiter);
-        var timeString;
-        if (array2.length > 2) {
-            return dateStrings;
-        }
-        if (/:/.test(array2[0])) {
-            timeString = array2[0];
-        } else {
-            dateStrings.date = array2[0];
-            timeString = array2[1];
-            if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
-                dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
-                timeString = dateString.substr(dateStrings.date.length, dateString.length);
-            }
-        }
-        if (timeString) {
-            var token = patterns.timezone.exec(timeString);
-            if (token) {
-                dateStrings.time = timeString.replace(token[1], "");
-                dateStrings.timezone = token[1];
-            } else {
-                dateStrings.time = timeString;
-            }
+    function flushTableEnd(map2, context2, index2, table2, tableBody) {
+        const exits = [];
+        const related = getPoint(context2.events, index2);
+        if (tableBody) {
+            tableBody.end = Object.assign({}, related);
+            exits.push(["exit", tableBody, context2]);
         }
-        return dateStrings;
+        table2.end = Object.assign({}, related);
+        exits.push(["exit", table2, context2]);
+        map2.add(index2 + 1, 0, exits);
     }
 
-    function parseYear(dateString, additionalDigits) {
-        var regex = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
-        var captures = dateString.match(regex);
-        if (!captures)
-            return {
-                year: NaN,
-                restDateString: ""
-            };
-        var year = captures[1] ? parseInt(captures[1]) : null;
-        var century = captures[2] ? parseInt(captures[2]) : null;
+    function getPoint(events2, index2) {
+        const event2 = events2[index2];
+        const side = event2[0] === "enter" ? "start" : "end";
+        return event2[1][side];
+    }
+    const tasklistCheck = {
+        tokenize: tokenizeTasklistCheck
+    };
+
+    function gfmTaskListItem() {
         return {
-            year: century === null ? year : century * 100,
-            restDateString: dateString.slice((captures[1] || captures[2]).length)
+            text: {
+                [91]: tasklistCheck
+            }
         };
     }
 
-    function parseDate(dateString, year) {
-        if (year === null)
-            return new Date(NaN);
-        var captures = dateString.match(dateRegex);
-        if (!captures)
-            return new Date(NaN);
-        var isWeekDate = !!captures[4];
-        var dayOfYear = parseDateUnit(captures[1]);
-        var month = parseDateUnit(captures[2]) - 1;
-        var day = parseDateUnit(captures[3]);
-        var week = parseDateUnit(captures[4]);
-        var dayOfWeek = parseDateUnit(captures[5]) - 1;
-        if (isWeekDate) {
-            if (!validateWeekDate(year, week, dayOfWeek)) {
-                return new Date(NaN);
+    function tokenizeTasklistCheck(effects, ok2, nok) {
+        const self2 = this;
+        return open;
+
+        function open(code2) {
+            if (self2.previous !== null || !self2._gfmTasklistFirstContentOfListItem) {
+                return nok(code2);
             }
-            return dayOfISOWeekYear(year, week, dayOfWeek);
-        } else {
-            var date = new Date(0);
-            if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
-                return new Date(NaN);
+            effects.enter("taskListCheck");
+            effects.enter("taskListCheckMarker");
+            effects.consume(code2);
+            effects.exit("taskListCheckMarker");
+            return inside2;
+        }
+
+        function inside2(code2) {
+            if (markdownLineEndingOrSpace(code2)) {
+                effects.enter("taskListCheckValueUnchecked");
+                effects.consume(code2);
+                effects.exit("taskListCheckValueUnchecked");
+                return close;
             }
-            date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
-            return date;
+            if (code2 === 88 || code2 === 120) {
+                effects.enter("taskListCheckValueChecked");
+                effects.consume(code2);
+                effects.exit("taskListCheckValueChecked");
+                return close;
+            }
+            return nok(code2);
         }
-    }
 
-    function parseDateUnit(value) {
-        return value ? parseInt(value) : 1;
-    }
+        function close(code2) {
+            if (code2 === 93) {
+                effects.enter("taskListCheckMarker");
+                effects.consume(code2);
+                effects.exit("taskListCheckMarker");
+                effects.exit("taskListCheck");
+                return after;
+            }
+            return nok(code2);
+        }
 
-    function parseTime(timeString) {
-        var captures = timeString.match(timeRegex);
-        if (!captures)
-            return NaN;
-        var hours = parseTimeUnit(captures[1]);
-        var minutes = parseTimeUnit(captures[2]);
-        var seconds = parseTimeUnit(captures[3]);
-        if (!validateTime(hours, minutes, seconds)) {
-            return NaN;
+        function after(code2) {
+            if (markdownLineEnding(code2)) {
+                return ok2(code2);
+            }
+            if (markdownSpace(code2)) {
+                return effects.check({
+                        tokenize: spaceThenNonSpace
+                    },
+                    ok2,
+                    nok
+                )(code2);
+            }
+            return nok(code2);
         }
-        return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1e3;
     }
 
-    function parseTimeUnit(value) {
-        return value && parseFloat(value.replace(",", ".")) || 0;
-    }
+    function spaceThenNonSpace(effects, ok2, nok) {
+        return factorySpace(effects, after, "whitespace");
 
-    function parseTimezone(timezoneString) {
-        if (timezoneString === "Z")
-            return 0;
-        var captures = timezoneString.match(timezoneRegex);
-        if (!captures)
-            return 0;
-        var sign2 = captures[1] === "+" ? -1 : 1;
-        var hours = parseInt(captures[2]);
-        var minutes = captures[3] && parseInt(captures[3]) || 0;
-        if (!validateTimezone(hours, minutes)) {
-            return NaN;
+        function after(code2) {
+            return code2 === null ? nok(code2) : ok2(code2);
         }
-        return sign2 * (hours * millisecondsInHour + minutes * millisecondsInMinute);
     }
 
-    function dayOfISOWeekYear(isoWeekYear, week, day) {
-        var date = new Date(0);
-        date.setUTCFullYear(isoWeekYear, 0, 4);
-        var fourthOfJanuaryDay = date.getUTCDay() || 7;
-        var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
-        date.setUTCDate(date.getUTCDate() + diff);
-        return date;
+    function gfm(options) {
+        return combineExtensions([
+            gfmAutolinkLiteral(),
+            gfmFootnote(),
+            gfmStrikethrough(options),
+            gfmTable(),
+            gfmTaskListItem()
+        ]);
     }
-    var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
+    const emptyOptions = {};
 
-    function isLeapYearIndex(year) {
-        return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
+    function remarkGfm(options) {
+        const self2 = this;
+        const settings2 = options || emptyOptions;
+        const data2 = self2.data();
+        const micromarkExtensions = data2.micromarkExtensions || (data2.micromarkExtensions = []);
+        const fromMarkdownExtensions = data2.fromMarkdownExtensions || (data2.fromMarkdownExtensions = []);
+        const toMarkdownExtensions = data2.toMarkdownExtensions || (data2.toMarkdownExtensions = []);
+        micromarkExtensions.push(gfm(settings2));
+        fromMarkdownExtensions.push(gfmFromMarkdown());
+        toMarkdownExtensions.push(gfmToMarkdown(settings2));
     }
-
-    function validateDate(year, month, date) {
-        return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
+    var __rest$c = globalThis && globalThis.__rest || function(s2, e3) {
+        var t2 = {};
+        for (var p2 in s2)
+            if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
+                t2[p2] = s2[p2];
+        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
+            for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
+                if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
+                    t2[p2[i2]] = s2[p2[i2]];
+            }
+        return t2;
+    };
+    const CustomMarkdownWrapper = styled__default.default.div`
+    /*
+     * Apply some base styles to the markdown content so it looks good by default
+     * Inspired by https://tailwindcss.com/docs/typography-plugin
+    */
+    code {
+        font-size: 0.9rem;
     }
 
-    function validateDayOfYearDate(year, dayOfYear) {
-        return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
-    }
+    p {
+        margin-top: 1.25rem;
+        margin-bottom: 1.25rem;
+        line-height: 1.5rem;
 
-    function validateWeekDate(_year, week, day) {
-        return week >= 1 && week <= 53 && day >= 0 && day <= 6;
+        code {
+            padding: 0.1rem;
+            background-color: ${(props) => props.theme.colors.grey1};
+            border: 1px solid ${(props) => props.theme.colors.grey3};
+            border-radius: 0.25rem;
+        }
     }
 
-    function validateTime(hours, minutes, seconds) {
-        if (hours === 24) {
-            return minutes === 0 && seconds === 0;
+    p,
+    tr {
+        math {
+            padding: 0;
+            font-size: 1.25rem;
         }
-        return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
     }
 
-    function validateTimezone(_hours, minutes) {
-        return minutes >= 0 && minutes <= 59;
+    /* stylelint-disable-next-line */
+    math {
+        padding: 0.5rem;
+        font-size: 1.5rem;
     }
 
-    function _inheritsLoose$1(subClass, superClass) {
-        subClass.prototype = Object.create(superClass.prototype);
-        subClass.prototype.constructor = subClass;
-        _setPrototypeOf$2(subClass, superClass);
+    a {
+        color: ${(props) => props.theme.colors.primary};
+        word-break: break-word;
     }
 
-    function _setPrototypeOf$2(o2, p2) {
-        _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
-            o3.__proto__ = p3;
-            return o3;
-        };
-        return _setPrototypeOf$2(o2, p2);
-    }
+    blockquote {
+        /* stylelint-disable-next-line */
+        quotes: '"\\201C""\\201D""\\2018""\\2019"';
 
-    function _objectWithoutPropertiesLoose$3(source, excluded) {
-        if (source == null)
-            return {};
-        var target = {};
-        var sourceKeys = Object.keys(source);
-        var key, i2;
-        for (i2 = 0; i2 < sourceKeys.length; i2++) {
-            key = sourceKeys[i2];
-            if (excluded.indexOf(key) >= 0)
-                continue;
-            target[key] = source[key];
-        }
-        return target;
+        margin-top: 1.5rem;
+        margin-bottom: 1.5rem;
+        padding-left: 1rem;
+
+        font-weight: 500;
+        font-style: italic;
+        color: ${(props) => props.theme.colors.grey6};
+
+        border-left: 0.25rem solid ${(props) => props.theme.colors.grey3};
     }
 
-    function _assertThisInitialized$2(self2) {
-        if (self2 === void 0) {
-            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
-        }
-        return self2;
+    h1 {
+        margin-top: 2rem;
+        margin-bottom: 1rem;
+
+        font-size: 2.5rem;
+        font-weight: 800;
+        line-height: 1.1;
     }
 
-    function isNodeFound(current2, componentNode, ignoreClass) {
-        if (current2 === componentNode) {
-            return true;
-        }
-        if (current2.correspondingElement) {
-            return current2.correspondingElement.classList.contains(ignoreClass);
-        }
-        return current2.classList.contains(ignoreClass);
+    h2 {
+        margin-top: 1rem;
+        margin-bottom: 1rem;
+
+        font-size: 2rem;
+        font-weight: 800;
+        line-height: 1.3;
     }
 
-    function findHighest(current2, componentNode, ignoreClass) {
-        if (current2 === componentNode) {
-            return true;
-        }
-        while (current2.parentNode || current2.host) {
-            if (current2.parentNode && isNodeFound(current2, componentNode, ignoreClass)) {
-                return true;
-            }
-            current2 = current2.parentNode || current2.host;
-        }
-        return current2;
+    h3 {
+        margin-top: 1.6rem;
+        margin-bottom: 0.6rem;
+
+        font-size: 1.25rem;
+        font-weight: 800;
+        line-height: 1.25;
     }
 
-    function clickedScrollbar(evt) {
-        return document.documentElement.clientWidth <= evt.clientX || document.documentElement.clientHeight <= evt.clientY;
+    h4 {
+        margin-top: 1.5rem;
+        margin-bottom: 0.5rem;
+        line-height: 1.5;
     }
-    var testPassiveEventSupport = function testPassiveEventSupport2() {
-        if (typeof window === "undefined" || typeof window.addEventListener !== "function") {
-            return;
-        }
-        var passive2 = false;
-        var options = Object.defineProperty({}, "passive", {
-            get: function get2() {
-                passive2 = true;
-            }
-        });
-        var noop2 = function noop3() {};
-        window.addEventListener("testPassiveEventSupport", noop2, options);
-        window.removeEventListener("testPassiveEventSupport", noop2, options);
-        return passive2;
-    };
 
-    function autoInc(seed2) {
-        if (seed2 === void 0) {
-            seed2 = 0;
+    img,
+    figure,
+    video {
+        margin-top: 1.5rem;
+        margin-bottom: 1.5rem;
+
+        * {
+            margin-top: 0;
+            margin-bottom: 0;
         }
-        return function() {
-            return ++seed2;
-        };
     }
-    var uid$1 = autoInc();
-    var passiveEventSupport;
-    var handlersMap = {};
-    var enabledInstances = {};
-    var touchEvents = ["touchstart", "touchmove"];
-    var IGNORE_CLASS_NAME = "ignore-react-onclickoutside";
 
-    function getEventHandlerOptions(instance2, eventName) {
-        var handlerOptions = {};
-        var isTouchEvent = touchEvents.indexOf(eventName) !== -1;
-        if (isTouchEvent && passiveEventSupport) {
-            handlerOptions.passive = !instance2.props.preventDefault;
-        }
-        return handlerOptions;
+    h2 code {
+        font-size: 0.875rem;
     }
 
-    function onClickOutsideHOC(WrappedComponent, config2) {
-        var _class, _temp;
-        var componentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
-        return _temp = _class = /* @__PURE__ */ function(_Component) {
-            _inheritsLoose$1(onClickOutside, _Component);
+    h3 code {
+        font-size: 0.9rem;
+    }
 
-            function onClickOutside(props) {
-                var _this;
-                _this = _Component.call(this, props) || this;
-                _this.__outsideClickHandler = function(event2) {
-                    if (typeof _this.__clickOutsideHandlerProp === "function") {
-                        _this.__clickOutsideHandlerProp(event2);
-                        return;
-                    }
-                    var instance2 = _this.getInstance();
-                    if (typeof instance2.props.handleClickOutside === "function") {
-                        instance2.props.handleClickOutside(event2);
-                        return;
-                    }
-                    if (typeof instance2.handleClickOutside === "function") {
-                        instance2.handleClickOutside(event2);
-                        return;
-                    }
-                    throw new Error("WrappedComponent: " + componentName + " lacks a handleClickOutside(event) function for processing outside click events.");
-                };
-                _this.__getComponentNode = function() {
-                    var instance2 = _this.getInstance();
-                    if (config2 && typeof config2.setClickOutsideRef === "function") {
-                        return config2.setClickOutsideRef()(instance2);
-                    }
-                    if (typeof instance2.setClickOutsideRef === "function") {
-                        return instance2.setClickOutsideRef();
-                    }
-                    return ReactDOM.findDOMNode(instance2);
-                };
-                _this.enableOnClickOutside = function() {
-                    if (typeof document === "undefined" || enabledInstances[_this._uid]) {
-                        return;
-                    }
-                    if (typeof passiveEventSupport === "undefined") {
-                        passiveEventSupport = testPassiveEventSupport();
-                    }
-                    enabledInstances[_this._uid] = true;
-                    var events2 = _this.props.eventTypes;
-                    if (!events2.forEach) {
-                        events2 = [events2];
-                    }
-                    handlersMap[_this._uid] = function(event2) {
-                        if (_this.componentNode === null)
-                            return;
-                        if (_this.props.preventDefault) {
-                            event2.preventDefault();
-                        }
-                        if (_this.props.stopPropagation) {
-                            event2.stopPropagation();
-                        }
-                        if (_this.props.excludeScrollbar && clickedScrollbar(event2))
-                            return;
-                        var current2 = event2.composed && event2.composedPath && event2.composedPath().shift() || event2.target;
-                        if (findHighest(current2, _this.componentNode, _this.props.outsideClickIgnoreClass) !== document) {
-                            return;
-                        }
-                        _this.__outsideClickHandler(event2);
-                    };
-                    events2.forEach(function(eventName) {
-                        document.addEventListener(eventName, handlersMap[_this._uid], getEventHandlerOptions(_assertThisInitialized$2(_this), eventName));
-                    });
-                };
-                _this.disableOnClickOutside = function() {
-                    delete enabledInstances[_this._uid];
-                    var fn2 = handlersMap[_this._uid];
-                    if (fn2 && typeof document !== "undefined") {
-                        var events2 = _this.props.eventTypes;
-                        if (!events2.forEach) {
-                            events2 = [events2];
-                        }
-                        events2.forEach(function(eventName) {
-                            return document.removeEventListener(eventName, fn2, getEventHandlerOptions(_assertThisInitialized$2(_this), eventName));
-                        });
-                        delete handlersMap[_this._uid];
-                    }
-                };
-                _this.getRef = function(ref2) {
-                    return _this.instanceRef = ref2;
-                };
-                _this._uid = uid$1();
-                return _this;
+    pre {
+        overflow-x: auto;
+
+        margin-top: 1.7rem;
+        margin-bottom: 1.7rem;
+        padding: 0 0.5em;
+
+        font-size: 0.9rem;
+        line-height: 1.7;
+
+        background-color: ${(props) => props.theme.colors.blue2};
+        border: 1px solid ${(props) => props.theme.colors.blue3};
+        border-radius: 0.375rem;
+
+        div {
+            background-color: ${(props) => props.theme.colors.blue2} !important;
+
+            span {
+                background-color: ${(props) => props.theme.colors.blue2};
             }
-            var _proto = onClickOutside.prototype;
-            _proto.getInstance = function getInstance() {
-                if (WrappedComponent.prototype && !WrappedComponent.prototype.isReactComponent) {
-                    return this;
-                }
-                var ref2 = this.instanceRef;
-                return ref2.getInstance ? ref2.getInstance() : ref2;
-            };
-            _proto.componentDidMount = function componentDidMount() {
-                if (typeof document === "undefined" || !document.createElement) {
-                    return;
-                }
-                var instance2 = this.getInstance();
-                if (config2 && typeof config2.handleClickOutside === "function") {
-                    this.__clickOutsideHandlerProp = config2.handleClickOutside(instance2);
-                    if (typeof this.__clickOutsideHandlerProp !== "function") {
-                        throw new Error("WrappedComponent: " + componentName + " lacks a function for processing outside click events specified by the handleClickOutside config option.");
-                    }
-                }
-                this.componentNode = this.__getComponentNode();
-                if (this.props.disableOnClickOutside)
-                    return;
-                this.enableOnClickOutside();
-            };
-            _proto.componentDidUpdate = function componentDidUpdate() {
-                this.componentNode = this.__getComponentNode();
-            };
-            _proto.componentWillUnmount = function componentWillUnmount() {
-                this.disableOnClickOutside();
-            };
-            _proto.render = function render2() {
-                var _this$props = this.props;
-                _this$props.excludeScrollbar;
-                var props = _objectWithoutPropertiesLoose$3(_this$props, ["excludeScrollbar"]);
-                if (WrappedComponent.prototype && WrappedComponent.prototype.isReactComponent) {
-                    props.ref = this.getRef;
-                } else {
-                    props.wrappedRef = this.getRef;
-                }
-                props.disableOnClickOutside = this.disableOnClickOutside;
-                props.enableOnClickOutside = this.enableOnClickOutside;
-                return React.createElement(WrappedComponent, props);
-            };
-            return onClickOutside;
-        }(React.Component), _class.displayName = "OnClickOutside(" + componentName + ")", _class.defaultProps = {
-            eventTypes: ["mousedown", "touchstart"],
-            excludeScrollbar: config2 && config2.excludeScrollbar || false,
-            outsideClickIgnoreClass: IGNORE_CLASS_NAME,
-            preventDefault: false,
-            stopPropagation: false
-        }, _class.getClass = function() {
-            return WrappedComponent.getClass ? WrappedComponent.getClass() : WrappedComponent;
-        }, _temp;
+        }
     }
-    var ManagerReferenceNodeContext = React__namespace.createContext();
-    var ManagerReferenceNodeSetterContext = React__namespace.createContext();
 
-    function Manager(_ref2) {
-        var children2 = _ref2.children;
-        var _React$useState = React__namespace.useState(null),
-            referenceNode = _React$useState[0],
-            setReferenceNode = _React$useState[1];
-        var hasUnmounted = React__namespace.useRef(false);
-        React__namespace.useEffect(function() {
-            return function() {
-                hasUnmounted.current = true;
-            };
-        }, []);
-        var handleSetReferenceNode = React__namespace.useCallback(function(node2) {
-            if (!hasUnmounted.current) {
-                setReferenceNode(node2);
-            }
-        }, []);
-        return /* @__PURE__ */ React__namespace.createElement(ManagerReferenceNodeContext.Provider, {
-            value: referenceNode
-        }, /* @__PURE__ */ React__namespace.createElement(ManagerReferenceNodeSetterContext.Provider, {
-            value: handleSetReferenceNode
-        }, children2));
+    hr + *,
+    h2 + *,
+    h3 + *,
+    h4 + * {
+        margin-top: 0;
     }
-    var unwrapArray = function unwrapArray2(arg) {
-        return Array.isArray(arg) ? arg[0] : arg;
-    };
-    var safeInvoke = function safeInvoke2(fn2) {
-        if (typeof fn2 === "function") {
-            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
-                args[_key - 1] = arguments[_key];
+
+    ol,
+    ul {
+        margin-top: 1.25rem;
+        margin-bottom: 1.25rem;
+        padding-left: 1.625rem;
+
+        li {
+            margin-top: 0.5rem;
+            margin-bottom: 0.5rem;
+            padding-left: 0.375rem;
+            line-height: 1.5rem;
+
+            code {
+                padding: 0.1em;
+                background-color: ${(props) => props.theme.colors.grey1};
+                border: 1px solid ${(props) => props.theme.colors.grey3};
+                border-radius: 0.25rem;
             }
-            return fn2.apply(void 0, args);
-        }
-    };
-    var setRef$1 = function setRef2(ref2, node2) {
-        if (typeof ref2 === "function") {
-            return safeInvoke(ref2, node2);
-        } else if (ref2 != null) {
-            ref2.current = node2;
-        }
-    };
-    var fromEntries = function fromEntries2(entries) {
-        return entries.reduce(function(acc, _ref2) {
-            var key = _ref2[0],
-                value = _ref2[1];
-            acc[key] = value;
-            return acc;
-        }, {});
-    };
-    var useIsomorphicLayoutEffect$1 = typeof window !== "undefined" && window.document && window.document.createElement ? React__namespace.useLayoutEffect : React__namespace.useEffect;
-    var EMPTY_MODIFIERS$1 = [];
-    var usePopper = function usePopper2(referenceElement, popperElement, options) {
-        if (options === void 0) {
-            options = {};
-        }
-        var prevOptions = React__namespace.useRef(null);
-        var optionsWithDefaults = {
-            onFirstUpdate: options.onFirstUpdate,
-            placement: options.placement || "bottom",
-            strategy: options.strategy || "absolute",
-            modifiers: options.modifiers || EMPTY_MODIFIERS$1
-        };
-        var _React$useState = React__namespace.useState({
-                styles: {
-                    popper: {
-                        position: optionsWithDefaults.strategy,
-                        left: "0",
-                        top: "0"
-                    },
-                    arrow: {
-                        position: "absolute"
-                    }
-                },
-                attributes: {}
-            }),
-            state = _React$useState[0],
-            setState = _React$useState[1];
-        var updateStateModifier = React__namespace.useMemo(function() {
-            return {
-                name: "updateState",
-                enabled: true,
-                phase: "write",
-                fn: function fn2(_ref2) {
-                    var state2 = _ref2.state;
-                    var elements = Object.keys(state2.elements);
-                    ReactDOM__namespace.flushSync(function() {
-                        setState({
-                            styles: fromEntries(elements.map(function(element2) {
-                                return [element2, state2.styles[element2] || {}];
-                            })),
-                            attributes: fromEntries(elements.map(function(element2) {
-                                return [element2, state2.attributes[element2]];
-                            }))
-                        });
-                    });
-                },
-                requires: ["computeStyles"]
-            };
-        }, []);
-        var popperOptions = React__namespace.useMemo(function() {
-            var newOptions = {
-                onFirstUpdate: optionsWithDefaults.onFirstUpdate,
-                placement: optionsWithDefaults.placement,
-                strategy: optionsWithDefaults.strategy,
-                modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
-                    name: "applyStyles",
-                    enabled: false
-                }])
-            };
-            if (reactFastCompare(prevOptions.current, newOptions)) {
-                return prevOptions.current || newOptions;
-            } else {
-                prevOptions.current = newOptions;
-                return newOptions;
+
+            strong {
+                font-style: italic;
             }
-        }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
-        var popperInstanceRef = React__namespace.useRef();
-        useIsomorphicLayoutEffect$1(function() {
-            if (popperInstanceRef.current) {
-                popperInstanceRef.current.setOptions(popperOptions);
+
+            p {
+                margin-top: 0.75rem;
+                margin-bottom: 0.75rem;
             }
-        }, [popperOptions]);
-        useIsomorphicLayoutEffect$1(function() {
-            if (referenceElement == null || popperElement == null) {
-                return;
+
+            *:first-child {
+                margin-top: 1.25rem;
             }
-            var createPopper2 = options.createPopper || createPopper$1;
-            var popperInstance = createPopper2(referenceElement, popperElement, popperOptions);
-            popperInstanceRef.current = popperInstance;
-            return function() {
-                popperInstance.destroy();
-                popperInstanceRef.current = null;
-            };
-        }, [referenceElement, popperElement, options.createPopper]);
-        return {
-            state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
-            styles: state.styles,
-            attributes: state.attributes,
-            update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
-            forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
-        };
-    };
-    var NOOP$1 = function NOOP2() {
-        return void 0;
-    };
-    var NOOP_PROMISE = function NOOP_PROMISE2() {
-        return Promise.resolve(null);
-    };
-    var EMPTY_MODIFIERS = [];
 
-    function Popper(_ref2) {
-        var _ref$placement = _ref2.placement,
-            placement = _ref$placement === void 0 ? "bottom" : _ref$placement,
-            _ref$strategy = _ref2.strategy,
-            strategy = _ref$strategy === void 0 ? "absolute" : _ref$strategy,
-            _ref$modifiers = _ref2.modifiers,
-            modifiers2 = _ref$modifiers === void 0 ? EMPTY_MODIFIERS : _ref$modifiers,
-            referenceElement = _ref2.referenceElement,
-            onFirstUpdate = _ref2.onFirstUpdate,
-            innerRef = _ref2.innerRef,
-            children2 = _ref2.children;
-        var referenceNode = React__namespace.useContext(ManagerReferenceNodeContext);
-        var _React$useState = React__namespace.useState(null),
-            popperElement = _React$useState[0],
-            setPopperElement = _React$useState[1];
-        var _React$useState2 = React__namespace.useState(null),
-            arrowElement = _React$useState2[0],
-            setArrowElement = _React$useState2[1];
-        React__namespace.useEffect(function() {
-            setRef$1(innerRef, popperElement);
-        }, [innerRef, popperElement]);
-        var options = React__namespace.useMemo(function() {
-            return {
-                placement,
-                strategy,
-                onFirstUpdate,
-                modifiers: [].concat(modifiers2, [{
-                    name: "arrow",
-                    enabled: arrowElement != null,
-                    options: {
-                        element: arrowElement
-                    }
-                }])
-            };
-        }, [placement, strategy, onFirstUpdate, modifiers2, arrowElement]);
-        var _usePopper = usePopper(referenceElement || referenceNode, popperElement, options),
-            state = _usePopper.state,
-            styles2 = _usePopper.styles,
-            forceUpdate = _usePopper.forceUpdate,
-            update2 = _usePopper.update;
-        var childrenProps = React__namespace.useMemo(function() {
-            return {
-                ref: setPopperElement,
-                style: styles2.popper,
-                placement: state ? state.placement : placement,
-                hasPopperEscaped: state && state.modifiersData.hide ? state.modifiersData.hide.hasPopperEscaped : null,
-                isReferenceHidden: state && state.modifiersData.hide ? state.modifiersData.hide.isReferenceHidden : null,
-                arrowProps: {
-                    style: styles2.arrow,
-                    ref: setArrowElement
-                },
-                forceUpdate: forceUpdate || NOOP$1,
-                update: update2 || NOOP_PROMISE
-            };
-        }, [setPopperElement, setArrowElement, placement, state, styles2, update2, forceUpdate]);
-        return unwrapArray(children2)(childrenProps);
+            *:last-child {
+                margin-bottom: 1.25rem;
+            }
+        }
     }
 
-    function Reference(_ref2) {
-        var children2 = _ref2.children,
-            innerRef = _ref2.innerRef;
-        var setReferenceNode = React__namespace.useContext(ManagerReferenceNodeSetterContext);
-        var refHandler = React__namespace.useCallback(function(node2) {
-            setRef$1(innerRef, node2);
-            safeInvoke(setReferenceNode, node2);
-        }, [innerRef, setReferenceNode]);
-        React__namespace.useEffect(function() {
-            return function() {
-                return setRef$1(innerRef, null);
-            };
-        }, []);
-        React__namespace.useEffect(function() {}, [setReferenceNode]);
-        return unwrapArray(children2)({
-            ref: refHandler
-        });
+    hr {
+        margin-top: 3rem;
+        margin-bottom: 3rem;
     }
 
-    function ae$1(e3, t2) {
-        var r2 = Object.keys(e3);
-        if (Object.getOwnPropertySymbols) {
-            var n2 = Object.getOwnPropertySymbols(e3);
-            t2 && (n2 = n2.filter(function(t3) {
-                return Object.getOwnPropertyDescriptor(e3, t3).enumerable;
-            })), r2.push.apply(r2, n2);
-        }
-        return r2;
-    }
+    table {
+        font-size: 0.875rem;
+        line-height: 1.7;
 
-    function se$1(e3) {
-        for (var t2 = 1; t2 < arguments.length; t2++) {
-            var r2 = null != arguments[t2] ? arguments[t2] : {};
-            t2 % 2 ? ae$1(Object(r2), true).forEach(function(t3) {
-                de$1(e3, t3, r2[t3]);
-            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r2)) : ae$1(Object(r2)).forEach(function(t3) {
-                Object.defineProperty(e3, t3, Object.getOwnPropertyDescriptor(r2, t3));
-            });
+        thead {
+            th {
+                padding-right: 0.5rem;
+                padding-bottom: 0.5rem;
+                padding-left: 0.5rem;
+            }
+
+            th:first-child {
+                padding-left: 0;
+            }
+
+            th:last-child {
+                padding-right: 0;
+            }
         }
-        return e3;
-    }
 
-    function ie$3(e3) {
-        return (ie$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
-            return typeof e4;
-        } : function(e4) {
-            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
-        })(e3);
-    }
+        tbody {
+            td {
+                padding: 0.5rem;
+            }
 
-    function pe$1(e3, t2) {
-        if (!(e3 instanceof t2))
-            throw new TypeError("Cannot call a class as a function");
-    }
+            td:first-child {
+                padding-left: 0;
+            }
 
-    function ce$1(e3, t2) {
-        for (var r2 = 0; r2 < t2.length; r2++) {
-            var n2 = t2[r2];
-            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, n2.key, n2);
+            td:last-child {
+                padding-right: 0;
+            }
         }
     }
 
-    function le$1(e3, t2, r2) {
-        return t2 && ce$1(e3.prototype, t2), r2 && ce$1(e3, r2), Object.defineProperty(e3, "prototype", {
-            writable: false
-        }), e3;
+    /* Remove top margin for first-child */
+    h1:first-child,
+    h2:first-child,
+    h3:first-child,
+    h4:first-child,
+    blockquote:first-child,
+    ol:first-child,
+    ul:first-child,
+    li:first-child,
+    p:first-child,
+    img:first-child,
+    figure:first-child,
+    video:first-child,
+    pre:first-child,
+    hr:first-child {
+        margin-top: 0;
     }
 
-    function de$1(e3, t2, r2) {
-        return t2 in e3 ? Object.defineProperty(e3, t2, {
-            value: r2,
-            enumerable: true,
-            configurable: true,
-            writable: true
-        }) : e3[t2] = r2, e3;
+    /* Remove bottom margin for last-child */
+    h1:last-child,
+    h2:last-child,
+    h3:last-child,
+    h4:last-child,
+    blockquote:last-child,
+    ol:last-child,
+    ul:last-child,
+    li:last-child,
+    p:last-child,
+    img:last-child,
+    figure:last-child,
+    video:last-child,
+    pre:last-child,
+    hr:last-child {
+        margin-bottom: 0;
     }
+`;
 
-    function ue$1() {
-        return (ue$1 = Object.assign || function(e3) {
-            for (var t2 = 1; t2 < arguments.length; t2++) {
-                var r2 = arguments[t2];
-                for (var n2 in r2)
-                    Object.prototype.hasOwnProperty.call(r2, n2) && (e3[n2] = r2[n2]);
-            }
-            return e3;
-        }).apply(this, arguments);
+    function Markdown$1(props) {
+        var _a3;
+        const {
+            markdown,
+            className,
+            style: style2
+        } = props, reactMarkdownProps = __rest$c(props, ["markdown", "className", "style"]);
+        return jsxRuntime.exports.jsx(CustomMarkdownWrapper, {
+            className,
+            style: style2,
+            children: jsxRuntime.exports.jsx(Markdown$2, Object.assign({}, reactMarkdownProps, {
+                remarkPlugins: (_a3 = reactMarkdownProps.remarkPlugins) !== null && _a3 !== void 0 ? _a3 : [remarkGfm],
+                children: markdown
+            }))
+        });
     }
+    var top$2 = "top";
+    var bottom$1 = "bottom";
+    var right$1 = "right";
+    var left$1 = "left";
+    var auto$1 = "auto";
+    var basePlacements$1 = [top$2, bottom$1, right$1, left$1];
+    var start$2 = "start";
+    var end$1 = "end";
+    var clippingParents$1 = "clippingParents";
+    var viewport$1 = "viewport";
+    var popper$1 = "popper";
+    var reference$1 = "reference";
+    var variationPlacements$1 = /* @__PURE__ */ basePlacements$1.reduce(function(acc, placement) {
+        return acc.concat([placement + "-" + start$2, placement + "-" + end$1]);
+    }, []);
+    var placements$1 = /* @__PURE__ */ [].concat(basePlacements$1, [auto$1]).reduce(function(acc, placement) {
+        return acc.concat([placement, placement + "-" + start$2, placement + "-" + end$1]);
+    }, []);
+    var beforeRead$1 = "beforeRead";
+    var read$1 = "read";
+    var afterRead$1 = "afterRead";
+    var beforeMain$1 = "beforeMain";
+    var main$1 = "main";
+    var afterMain$1 = "afterMain";
+    var beforeWrite$1 = "beforeWrite";
+    var write$1 = "write";
+    var afterWrite$1 = "afterWrite";
+    var modifierPhases$1 = [beforeRead$1, read$1, afterRead$1, beforeMain$1, main$1, afterMain$1, beforeWrite$1, write$1, afterWrite$1];
 
-    function he$1(e3, t2) {
-        if ("function" != typeof t2 && null !== t2)
-            throw new TypeError("Super expression must either be null or a function");
-        Object.defineProperty(e3, "prototype", {
-            value: Object.create(t2 && t2.prototype, {
-                constructor: {
-                    value: e3,
-                    writable: true,
-                    configurable: true
-                }
-            }),
-            writable: false
-        }), t2 && fe$1(e3, t2);
+    function getNodeName$1(element2) {
+        return element2 ? (element2.nodeName || "").toLowerCase() : null;
     }
 
-    function me(e3) {
-        return (me = Object.setPrototypeOf ? Object.getPrototypeOf : function(e4) {
-            return e4.__proto__ || Object.getPrototypeOf(e4);
-        })(e3);
+    function getWindow$1(node2) {
+        if (node2 == null) {
+            return window;
+        }
+        if (node2.toString() !== "[object Window]") {
+            var ownerDocument = node2.ownerDocument;
+            return ownerDocument ? ownerDocument.defaultView || window : window;
+        }
+        return node2;
     }
 
-    function fe$1(e3, t2) {
-        return (fe$1 = Object.setPrototypeOf || function(e4, t3) {
-            return e4.__proto__ = t3, e4;
-        })(e3, t2);
+    function isElement$4(node2) {
+        var OwnElement = getWindow$1(node2).Element;
+        return node2 instanceof OwnElement || node2 instanceof Element;
     }
 
-    function ye(e3) {
-        if (void 0 === e3)
-            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
-        return e3;
+    function isHTMLElement$1(node2) {
+        var OwnElement = getWindow$1(node2).HTMLElement;
+        return node2 instanceof OwnElement || node2 instanceof HTMLElement;
     }
 
-    function ve(e3, t2) {
-        if (t2 && ("object" == typeof t2 || "function" == typeof t2))
-            return t2;
-        if (void 0 !== t2)
-            throw new TypeError("Derived constructors may only return object or undefined");
-        return ye(e3);
+    function isShadowRoot(node2) {
+        if (typeof ShadowRoot === "undefined") {
+            return false;
+        }
+        var OwnElement = getWindow$1(node2).ShadowRoot;
+        return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
     }
 
-    function De(e3) {
-        var t2 = function() {
-            if ("undefined" == typeof Reflect || !Reflect.construct)
-                return false;
-            if (Reflect.construct.sham)
-                return false;
-            if ("function" == typeof Proxy)
-                return true;
-            try {
-                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), true;
-            } catch (e4) {
-                return false;
+    function applyStyles$2(_ref2) {
+        var state = _ref2.state;
+        Object.keys(state.elements).forEach(function(name2) {
+            var style2 = state.styles[name2] || {};
+            var attributes2 = state.attributes[name2] || {};
+            var element2 = state.elements[name2];
+            if (!isHTMLElement$1(element2) || !getNodeName$1(element2)) {
+                return;
             }
-        }();
-        return function() {
-            var r2, n2 = me(e3);
-            if (t2) {
-                var o2 = me(this).constructor;
-                r2 = Reflect.construct(n2, arguments, o2);
-            } else
-                r2 = n2.apply(this, arguments);
-            return ve(this, r2);
+            Object.assign(element2.style, style2);
+            Object.keys(attributes2).forEach(function(name3) {
+                var value = attributes2[name3];
+                if (value === false) {
+                    element2.removeAttribute(name3);
+                } else {
+                    element2.setAttribute(name3, value === true ? "" : value);
+                }
+            });
+        });
+    }
+
+    function effect$5(_ref2) {
+        var state = _ref2.state;
+        var initialStyles = {
+            popper: {
+                position: state.options.strategy,
+                left: "0",
+                top: "0",
+                margin: "0"
+            },
+            arrow: {
+                position: "absolute"
+            },
+            reference: {}
+        };
+        Object.assign(state.elements.popper.style, initialStyles.popper);
+        state.styles = initialStyles;
+        if (state.elements.arrow) {
+            Object.assign(state.elements.arrow.style, initialStyles.arrow);
+        }
+        return function() {
+            Object.keys(state.elements).forEach(function(name2) {
+                var element2 = state.elements[name2];
+                var attributes2 = state.attributes[name2] || {};
+                var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
+                var style2 = styleProperties.reduce(function(style3, property) {
+                    style3[property] = "";
+                    return style3;
+                }, {});
+                if (!isHTMLElement$1(element2) || !getNodeName$1(element2)) {
+                    return;
+                }
+                Object.assign(element2.style, style2);
+                Object.keys(attributes2).forEach(function(attribute) {
+                    element2.removeAttribute(attribute);
+                });
+            });
         };
     }
+    const applyStyles$3 = {
+        name: "applyStyles",
+        enabled: true,
+        phase: "write",
+        fn: applyStyles$2,
+        effect: effect$5,
+        requires: ["computeStyles"]
+    };
 
-    function we$1(e3) {
-        return function(e4) {
-            if (Array.isArray(e4))
-                return ge(e4);
-        }(e3) || function(e4) {
-            if ("undefined" != typeof Symbol && null != e4[Symbol.iterator] || null != e4["@@iterator"])
-                return Array.from(e4);
-        }(e3) || function(e4, t2) {
-            if (!e4)
-                return;
-            if ("string" == typeof e4)
-                return ge(e4, t2);
-            var r2 = Object.prototype.toString.call(e4).slice(8, -1);
-            "Object" === r2 && e4.constructor && (r2 = e4.constructor.name);
-            if ("Map" === r2 || "Set" === r2)
-                return Array.from(e4);
-            if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
-                return ge(e4, t2);
-        }(e3) || function() {
-            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
-        }();
+    function getBasePlacement$3(placement) {
+        return placement.split("-")[0];
     }
+    var max$3 = Math.max;
+    var min$2 = Math.min;
+    var round$2 = Math.round;
 
-    function ge(e3, t2) {
-        (null == t2 || t2 > e3.length) && (t2 = e3.length);
-        for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
-            n2[r2] = e3[r2];
-        return n2;
+    function getUAString() {
+        var uaData = navigator.userAgentData;
+        if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
+            return uaData.brands.map(function(item) {
+                return item.brand + "/" + item.version;
+            }).join(" ");
+        }
+        return navigator.userAgent;
     }
 
-    function ke(e3, t2) {
-        switch (e3) {
-            case "P":
-                return t2.date({
-                    width: "short"
-                });
-            case "PP":
-                return t2.date({
-                    width: "medium"
-                });
-            case "PPP":
-                return t2.date({
-                    width: "long"
-                });
-            case "PPPP":
-            default:
-                return t2.date({
-                    width: "full"
-                });
+    function isLayoutViewport() {
+        return !/^((?!chrome|android).)*safari/i.test(getUAString());
+    }
+
+    function getBoundingClientRect$1(element2, includeScale, isFixedStrategy) {
+        if (includeScale === void 0) {
+            includeScale = false;
+        }
+        if (isFixedStrategy === void 0) {
+            isFixedStrategy = false;
+        }
+        var clientRect = element2.getBoundingClientRect();
+        var scaleX = 1;
+        var scaleY = 1;
+        if (includeScale && isHTMLElement$1(element2)) {
+            scaleX = element2.offsetWidth > 0 ? round$2(clientRect.width) / element2.offsetWidth || 1 : 1;
+            scaleY = element2.offsetHeight > 0 ? round$2(clientRect.height) / element2.offsetHeight || 1 : 1;
         }
+        var _ref2 = isElement$4(element2) ? getWindow$1(element2) : window,
+            visualViewport = _ref2.visualViewport;
+        var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
+        var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
+        var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
+        var width = clientRect.width / scaleX;
+        var height = clientRect.height / scaleY;
+        return {
+            width,
+            height,
+            top: y2,
+            right: x2 + width,
+            bottom: y2 + height,
+            left: x2,
+            x: x2,
+            y: y2
+        };
     }
 
-    function be$1(e3, t2) {
-        switch (e3) {
-            case "p":
-                return t2.time({
-                    width: "short"
-                });
-            case "pp":
-                return t2.time({
-                    width: "medium"
-                });
-            case "ppp":
-                return t2.time({
-                    width: "long"
-                });
-            case "pppp":
-            default:
-                return t2.time({
-                    width: "full"
-                });
+    function getLayoutRect$1(element2) {
+        var clientRect = getBoundingClientRect$1(element2);
+        var width = element2.offsetWidth;
+        var height = element2.offsetHeight;
+        if (Math.abs(clientRect.width - width) <= 1) {
+            width = clientRect.width;
+        }
+        if (Math.abs(clientRect.height - height) <= 1) {
+            height = clientRect.height;
         }
+        return {
+            x: element2.offsetLeft,
+            y: element2.offsetTop,
+            width,
+            height
+        };
     }
-    var Ce$1 = {
-            p: be$1,
-            P: function(e3, t2) {
-                var r2, n2 = e3.match(/(P+)(p+)?/) || [],
-                    o2 = n2[1],
-                    a2 = n2[2];
-                if (!a2)
-                    return ke(e3, t2);
-                switch (o2) {
-                    case "P":
-                        r2 = t2.dateTime({
-                            width: "short"
-                        });
-                        break;
-                    case "PP":
-                        r2 = t2.dateTime({
-                            width: "medium"
-                        });
-                        break;
-                    case "PPP":
-                        r2 = t2.dateTime({
-                            width: "long"
-                        });
-                        break;
-                    case "PPPP":
-                    default:
-                        r2 = t2.dateTime({
-                            width: "full"
-                        });
+
+    function contains$2(parent, child) {
+        var rootNode = child.getRootNode && child.getRootNode();
+        if (parent.contains(child)) {
+            return true;
+        } else if (rootNode && isShadowRoot(rootNode)) {
+            var next2 = child;
+            do {
+                if (next2 && parent.isSameNode(next2)) {
+                    return true;
                 }
-                return r2.replace("{{date}}", ke(o2, t2)).replace("{{time}}", be$1(a2, t2));
-            }
-        },
-        Se = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
+                next2 = next2.parentNode || next2.host;
+            } while (next2);
+        }
+        return false;
+    }
 
-    function _e$1(e3) {
-        var t2 = e3 ? "string" == typeof e3 || e3 instanceof String ? parseISO(e3) : toDate(e3) : new Date();
-        return Pe$1(t2) ? t2 : null;
+    function getComputedStyle$2(element2) {
+        return getWindow$1(element2).getComputedStyle(element2);
     }
 
-    function Me$1(e3, t2, r2, n2, o2) {
-        var a2 = null,
-            s2 = Ue(r2) || Ue(qe$1()),
-            i2 = true;
-        return Array.isArray(t2) ? (t2.forEach(function(t3) {
-            var p2 = parse$8(e3, t3, new Date(), {
-                locale: s2
-            });
-            n2 && (i2 = Pe$1(p2, o2) && e3 === Ee$1(p2, t3, r2)), Pe$1(p2, o2) && i2 && (a2 = p2);
-        }), a2) : (a2 = parse$8(e3, t2, new Date(), {
-            locale: s2
-        }), n2 ? i2 = Pe$1(a2) && e3 === Ee$1(a2, t2, r2) : Pe$1(a2) || (t2 = t2.match(Se).map(function(e4) {
-            var t3 = e4[0];
-            return "p" === t3 || "P" === t3 ? s2 ? (0, Ce$1[t3])(e4, s2.formatLong) : t3 : e4;
-        }).join(""), e3.length > 0 && (a2 = parse$8(e3, t2.slice(0, e3.length), new Date())), Pe$1(a2) || (a2 = new Date(e3))), Pe$1(a2) && i2 ? a2 : null);
+    function isTableElement$1(element2) {
+        return ["table", "td", "th"].indexOf(getNodeName$1(element2)) >= 0;
     }
 
-    function Pe$1(e3, t2) {
-        return t2 = t2 || new Date("1/1/1000"), isValid(e3) && !isBefore(e3, t2);
+    function getDocumentElement$1(element2) {
+        return ((isElement$4(element2) ? element2.ownerDocument : element2.document) || window.document).documentElement;
     }
 
-    function Ee$1(e3, t2, r2) {
-        if ("en" === r2)
-            return format$1(e3, t2, {
-                awareOfUnicodeTokens: true
-            });
-        var n2 = Ue(r2);
-        return r2 && !n2 && console.warn('A locale object was not found for the provided string ["'.concat(r2, '"].')), !n2 && qe$1() && Ue(qe$1()) && (n2 = Ue(qe$1())), format$1(e3, t2, {
-            locale: n2 || null,
-            awareOfUnicodeTokens: true
-        });
+    function getParentNode$1(element2) {
+        if (getNodeName$1(element2) === "html") {
+            return element2;
+        }
+        return element2.assignedSlot || element2.parentNode || (isShadowRoot(element2) ? element2.host : null) || getDocumentElement$1(element2);
     }
 
-    function Ne$1(e3, t2) {
-        var r2 = t2.dateFormat,
-            n2 = t2.locale;
-        return e3 && Ee$1(e3, Array.isArray(r2) ? r2[0] : r2, n2) || "";
+    function getTrueOffsetParent$1(element2) {
+        if (!isHTMLElement$1(element2) || getComputedStyle$2(element2).position === "fixed") {
+            return null;
+        }
+        return element2.offsetParent;
     }
 
-    function xe$1(e3, t2) {
-        var r2 = t2.hour,
-            n2 = void 0 === r2 ? 0 : r2,
-            o2 = t2.minute,
-            a2 = void 0 === o2 ? 0 : o2,
-            s2 = t2.second;
-        return setHours(setMinutes(setSeconds(e3, void 0 === s2 ? 0 : s2), a2), n2);
+    function getContainingBlock(element2) {
+        var isFirefox2 = /firefox/i.test(getUAString());
+        var isIE2 = /Trident/i.test(getUAString());
+        if (isIE2 && isHTMLElement$1(element2)) {
+            var elementCss = getComputedStyle$2(element2);
+            if (elementCss.position === "fixed") {
+                return null;
+            }
+        }
+        var currentNode = getParentNode$1(element2);
+        if (isShadowRoot(currentNode)) {
+            currentNode = currentNode.host;
+        }
+        while (isHTMLElement$1(currentNode) && ["html", "body"].indexOf(getNodeName$1(currentNode)) < 0) {
+            var css2 = getComputedStyle$2(currentNode);
+            if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox2 && css2.willChange === "filter" || isFirefox2 && css2.filter && css2.filter !== "none") {
+                return currentNode;
+            } else {
+                currentNode = currentNode.parentNode;
+            }
+        }
+        return null;
     }
 
-    function Ye$1(e3, t2) {
-        var r2 = t2 && Ue(t2) || qe$1() && Ue(qe$1());
-        return getISOWeek(e3, r2 ? {
-            locale: r2
-        } : null);
+    function getOffsetParent$1(element2) {
+        var window2 = getWindow$1(element2);
+        var offsetParent = getTrueOffsetParent$1(element2);
+        while (offsetParent && isTableElement$1(offsetParent) && getComputedStyle$2(offsetParent).position === "static") {
+            offsetParent = getTrueOffsetParent$1(offsetParent);
+        }
+        if (offsetParent && (getNodeName$1(offsetParent) === "html" || getNodeName$1(offsetParent) === "body" && getComputedStyle$2(offsetParent).position === "static")) {
+            return window2;
+        }
+        return offsetParent || getContainingBlock(element2) || window2;
     }
 
-    function Oe$1(e3, t2) {
-        return Ee$1(e3, "ddd", t2);
+    function getMainAxisFromPlacement$1(placement) {
+        return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
     }
 
-    function Ie$1(e3) {
-        return startOfDay(e3);
+    function within$1(min2, value, max2) {
+        return max$3(min2, min$2(value, max2));
     }
 
-    function Te(e3, t2, r2) {
-        var n2 = Ue(t2 || qe$1());
-        return startOfWeek(e3, {
-            locale: n2,
-            weekStartsOn: r2
-        });
+    function withinMaxClamp(min2, value, max2) {
+        var v2 = within$1(min2, value, max2);
+        return v2 > max2 ? max2 : v2;
     }
 
-    function Le$1(e3) {
-        return startOfMonth(e3);
+    function getFreshSideObject$1() {
+        return {
+            top: 0,
+            right: 0,
+            bottom: 0,
+            left: 0
+        };
     }
 
-    function Re$1(e3) {
-        return startOfYear(e3);
+    function mergePaddingObject$1(paddingObject) {
+        return Object.assign({}, getFreshSideObject$1(), paddingObject);
     }
 
-    function Fe$1(e3) {
-        return startOfQuarter(e3);
+    function expandToHashMap$1(value, keys2) {
+        return keys2.reduce(function(hashMap, key) {
+            hashMap[key] = value;
+            return hashMap;
+        }, {});
     }
+    var toPaddingObject = function toPaddingObject2(padding, state) {
+        padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
+            placement: state.placement
+        })) : padding;
+        return mergePaddingObject$1(typeof padding !== "number" ? padding : expandToHashMap$1(padding, basePlacements$1));
+    };
 
-    function Ae(e3, t2) {
-        return e3 && t2 ? isSameYear(e3, t2) : !e3 && !t2;
+    function arrow$2(_ref2) {
+        var _state$modifiersData$;
+        var state = _ref2.state,
+            name2 = _ref2.name,
+            options = _ref2.options;
+        var arrowElement = state.elements.arrow;
+        var popperOffsets2 = state.modifiersData.popperOffsets;
+        var basePlacement = getBasePlacement$3(state.placement);
+        var axis = getMainAxisFromPlacement$1(basePlacement);
+        var isVertical = [left$1, right$1].indexOf(basePlacement) >= 0;
+        var len = isVertical ? "height" : "width";
+        if (!arrowElement || !popperOffsets2) {
+            return;
+        }
+        var paddingObject = toPaddingObject(options.padding, state);
+        var arrowRect = getLayoutRect$1(arrowElement);
+        var minProp = axis === "y" ? top$2 : left$1;
+        var maxProp = axis === "y" ? bottom$1 : right$1;
+        var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
+        var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
+        var arrowOffsetParent = getOffsetParent$1(arrowElement);
+        var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
+        var centerToReference = endDiff / 2 - startDiff / 2;
+        var min2 = paddingObject[minProp];
+        var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
+        var center2 = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
+        var offset2 = within$1(min2, center2, max2);
+        var axisProp = axis;
+        state.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center2, _state$modifiersData$);
     }
 
-    function Be$1(e3, t2) {
-        return e3 && t2 ? isSameMonth(e3, t2) : !e3 && !t2;
+    function effect$4(_ref2) {
+        var state = _ref2.state,
+            options = _ref2.options;
+        var _options$element = options.element,
+            arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
+        if (arrowElement == null) {
+            return;
+        }
+        if (typeof arrowElement === "string") {
+            arrowElement = state.elements.popper.querySelector(arrowElement);
+            if (!arrowElement) {
+                return;
+            }
+        }
+        if (!contains$2(state.elements.popper, arrowElement)) {
+            return;
+        }
+        state.elements.arrow = arrowElement;
     }
+    const arrow$3 = {
+        name: "arrow",
+        enabled: true,
+        phase: "main",
+        fn: arrow$2,
+        effect: effect$4,
+        requires: ["popperOffsets"],
+        requiresIfExists: ["preventOverflow"]
+    };
 
-    function Ke$1(e3, t2) {
-        return e3 && t2 ? isSameQuarter(e3, t2) : !e3 && !t2;
+    function getVariation$1(placement) {
+        return placement.split("-")[1];
     }
+    var unsetSides$1 = {
+        top: "auto",
+        right: "auto",
+        bottom: "auto",
+        left: "auto"
+    };
 
-    function We$1(e3, t2) {
-        return e3 && t2 ? isSameDay(e3, t2) : !e3 && !t2;
+    function roundOffsetsByDPR(_ref2, win) {
+        var x2 = _ref2.x,
+            y2 = _ref2.y;
+        var dpr = win.devicePixelRatio || 1;
+        return {
+            x: round$2(x2 * dpr) / dpr || 0,
+            y: round$2(y2 * dpr) / dpr || 0
+        };
     }
 
-    function je$1(e3, t2) {
-        return e3 && t2 ? isEqual$2(e3, t2) : !e3 && !t2;
+    function mapToStyles$1(_ref2) {
+        var _Object$assign2;
+        var popper2 = _ref2.popper,
+            popperRect = _ref2.popperRect,
+            placement = _ref2.placement,
+            variation = _ref2.variation,
+            offsets = _ref2.offsets,
+            position2 = _ref2.position,
+            gpuAcceleration = _ref2.gpuAcceleration,
+            adaptive = _ref2.adaptive,
+            roundOffsets2 = _ref2.roundOffsets,
+            isFixed = _ref2.isFixed;
+        var _offsets$x = offsets.x,
+            x2 = _offsets$x === void 0 ? 0 : _offsets$x,
+            _offsets$y = offsets.y,
+            y2 = _offsets$y === void 0 ? 0 : _offsets$y;
+        var _ref3 = typeof roundOffsets2 === "function" ? roundOffsets2({
+            x: x2,
+            y: y2
+        }) : {
+            x: x2,
+            y: y2
+        };
+        x2 = _ref3.x;
+        y2 = _ref3.y;
+        var hasX = offsets.hasOwnProperty("x");
+        var hasY = offsets.hasOwnProperty("y");
+        var sideX = left$1;
+        var sideY = top$2;
+        var win = window;
+        if (adaptive) {
+            var offsetParent = getOffsetParent$1(popper2);
+            var heightProp = "clientHeight";
+            var widthProp = "clientWidth";
+            if (offsetParent === getWindow$1(popper2)) {
+                offsetParent = getDocumentElement$1(popper2);
+                if (getComputedStyle$2(offsetParent).position !== "static" && position2 === "absolute") {
+                    heightProp = "scrollHeight";
+                    widthProp = "scrollWidth";
+                }
+            }
+            offsetParent = offsetParent;
+            if (placement === top$2 || (placement === left$1 || placement === right$1) && variation === end$1) {
+                sideY = bottom$1;
+                var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
+                y2 -= offsetY - popperRect.height;
+                y2 *= gpuAcceleration ? 1 : -1;
+            }
+            if (placement === left$1 || (placement === top$2 || placement === bottom$1) && variation === end$1) {
+                sideX = right$1;
+                var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
+                x2 -= offsetX - popperRect.width;
+                x2 *= gpuAcceleration ? 1 : -1;
+            }
+        }
+        var commonStyles = Object.assign({
+            position: position2
+        }, adaptive && unsetSides$1);
+        var _ref4 = roundOffsets2 === true ? roundOffsetsByDPR({
+            x: x2,
+            y: y2
+        }, getWindow$1(popper2)) : {
+            x: x2,
+            y: y2
+        };
+        x2 = _ref4.x;
+        y2 = _ref4.y;
+        if (gpuAcceleration) {
+            var _Object$assign;
+            return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
+        }
+        return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
     }
 
-    function He$1(e3, t2, r2) {
-        var n2, o2 = startOfDay(t2),
-            a2 = endOfDay(r2);
-        try {
-            n2 = isWithinInterval(e3, {
-                start: o2,
-                end: a2
+    function computeStyles$2(_ref5) {
+        var state = _ref5.state,
+            options = _ref5.options;
+        var _options$gpuAccelerat = options.gpuAcceleration,
+            gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
+            _options$adaptive = options.adaptive,
+            adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
+            _options$roundOffsets = options.roundOffsets,
+            roundOffsets2 = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
+        var commonStyles = {
+            placement: getBasePlacement$3(state.placement),
+            variation: getVariation$1(state.placement),
+            popper: state.elements.popper,
+            popperRect: state.rects.popper,
+            gpuAcceleration,
+            isFixed: state.options.strategy === "fixed"
+        };
+        if (state.modifiersData.popperOffsets != null) {
+            state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles$1(Object.assign({}, commonStyles, {
+                offsets: state.modifiersData.popperOffsets,
+                position: state.options.strategy,
+                adaptive,
+                roundOffsets: roundOffsets2
+            })));
+        }
+        if (state.modifiersData.arrow != null) {
+            state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles$1(Object.assign({}, commonStyles, {
+                offsets: state.modifiersData.arrow,
+                position: "absolute",
+                adaptive: false,
+                roundOffsets: roundOffsets2
+            })));
+        }
+        state.attributes.popper = Object.assign({}, state.attributes.popper, {
+            "data-popper-placement": state.placement
+        });
+    }
+    const computeStyles$3 = {
+        name: "computeStyles",
+        enabled: true,
+        phase: "beforeWrite",
+        fn: computeStyles$2,
+        data: {}
+    };
+    var passive$1 = {
+        passive: true
+    };
+
+    function effect$3(_ref2) {
+        var state = _ref2.state,
+            instance2 = _ref2.instance,
+            options = _ref2.options;
+        var _options$scroll = options.scroll,
+            scroll = _options$scroll === void 0 ? true : _options$scroll,
+            _options$resize = options.resize,
+            resize = _options$resize === void 0 ? true : _options$resize;
+        var window2 = getWindow$1(state.elements.popper);
+        var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
+        if (scroll) {
+            scrollParents.forEach(function(scrollParent) {
+                scrollParent.addEventListener("scroll", instance2.update, passive$1);
             });
-        } catch (e4) {
-            n2 = false;
         }
-        return n2;
+        if (resize) {
+            window2.addEventListener("resize", instance2.update, passive$1);
+        }
+        return function() {
+            if (scroll) {
+                scrollParents.forEach(function(scrollParent) {
+                    scrollParent.removeEventListener("scroll", instance2.update, passive$1);
+                });
+            }
+            if (resize) {
+                window2.removeEventListener("resize", instance2.update, passive$1);
+            }
+        };
+    }
+    const eventListeners$1 = {
+        name: "eventListeners",
+        enabled: true,
+        phase: "write",
+        fn: function fn2() {},
+        effect: effect$3,
+        data: {}
+    };
+    var hash$4 = {
+        left: "right",
+        right: "left",
+        bottom: "top",
+        top: "bottom"
+    };
+
+    function getOppositePlacement$1(placement) {
+        return placement.replace(/left|right|bottom|top/g, function(matched) {
+            return hash$4[matched];
+        });
     }
+    var hash$3 = {
+        start: "end",
+        end: "start"
+    };
 
-    function qe$1() {
-        return ("undefined" != typeof window ? window : globalThis).__localeId__;
+    function getOppositeVariationPlacement$1(placement) {
+        return placement.replace(/start|end/g, function(matched) {
+            return hash$3[matched];
+        });
     }
 
-    function Ue(e3) {
-        if ("string" == typeof e3) {
-            var t2 = "undefined" != typeof window ? window : globalThis;
-            return t2.__localeData__ ? t2.__localeData__[e3] : null;
+    function getWindowScroll$1(node2) {
+        var win = getWindow$1(node2);
+        var scrollLeft = win.pageXOffset;
+        var scrollTop = win.pageYOffset;
+        return {
+            scrollLeft,
+            scrollTop
+        };
+    }
+
+    function getWindowScrollBarX$1(element2) {
+        return getBoundingClientRect$1(getDocumentElement$1(element2)).left + getWindowScroll$1(element2).scrollLeft;
+    }
+
+    function getViewportRect$1(element2, strategy) {
+        var win = getWindow$1(element2);
+        var html2 = getDocumentElement$1(element2);
+        var visualViewport = win.visualViewport;
+        var width = html2.clientWidth;
+        var height = html2.clientHeight;
+        var x2 = 0;
+        var y2 = 0;
+        if (visualViewport) {
+            width = visualViewport.width;
+            height = visualViewport.height;
+            var layoutViewport = isLayoutViewport();
+            if (layoutViewport || !layoutViewport && strategy === "fixed") {
+                x2 = visualViewport.offsetLeft;
+                y2 = visualViewport.offsetTop;
+            }
         }
-        return e3;
+        return {
+            width,
+            height,
+            x: x2 + getWindowScrollBarX$1(element2),
+            y: y2
+        };
     }
 
-    function $e$1(e3, t2) {
-        return Ee$1(setMonth(_e$1(), e3), "LLLL", t2);
+    function getDocumentRect$1(element2) {
+        var _element$ownerDocumen;
+        var html2 = getDocumentElement$1(element2);
+        var winScroll = getWindowScroll$1(element2);
+        var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
+        var width = max$3(html2.scrollWidth, html2.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
+        var height = max$3(html2.scrollHeight, html2.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
+        var x2 = -winScroll.scrollLeft + getWindowScrollBarX$1(element2);
+        var y2 = -winScroll.scrollTop;
+        if (getComputedStyle$2(body || html2).direction === "rtl") {
+            x2 += max$3(html2.clientWidth, body ? body.clientWidth : 0) - width;
+        }
+        return {
+            width,
+            height,
+            x: x2,
+            y: y2
+        };
     }
 
-    function ze$1(e3, t2) {
-        return Ee$1(setMonth(_e$1(), e3), "LLL", t2);
+    function isScrollParent$1(element2) {
+        var _getComputedStyle = getComputedStyle$2(element2),
+            overflow = _getComputedStyle.overflow,
+            overflowX = _getComputedStyle.overflowX,
+            overflowY = _getComputedStyle.overflowY;
+        return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
     }
 
-    function Ge$1(e3, t2) {
-        return Ee$1(setQuarter(_e$1(), e3), "QQQ", t2);
+    function getScrollParent$1(node2) {
+        if (["html", "body", "#document"].indexOf(getNodeName$1(node2)) >= 0) {
+            return node2.ownerDocument.body;
+        }
+        if (isHTMLElement$1(node2) && isScrollParent$1(node2)) {
+            return node2;
+        }
+        return getScrollParent$1(getParentNode$1(node2));
     }
 
-    function Je$1(e3) {
-        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
-            r2 = t2.minDate,
-            n2 = t2.maxDate,
-            o2 = t2.excludeDates,
-            a2 = t2.excludeDateIntervals,
-            s2 = t2.includeDates,
-            i2 = t2.includeDateIntervals,
-            p2 = t2.filterDate;
-        return ot(e3, {
-            minDate: r2,
-            maxDate: n2
-        }) || o2 && o2.some(function(t3) {
-            return We$1(e3, t3);
-        }) || a2 && a2.some(function(t3) {
-            var r3 = t3.start,
-                n3 = t3.end;
-            return isWithinInterval(e3, {
-                start: r3,
-                end: n3
-            });
-        }) || s2 && !s2.some(function(t3) {
-            return We$1(e3, t3);
-        }) || i2 && !i2.some(function(t3) {
-            var r3 = t3.start,
-                n3 = t3.end;
-            return isWithinInterval(e3, {
-                start: r3,
-                end: n3
-            });
-        }) || p2 && !p2(_e$1(e3)) || false;
+    function listScrollParents$1(element2, list2) {
+        var _element$ownerDocumen;
+        if (list2 === void 0) {
+            list2 = [];
+        }
+        var scrollParent = getScrollParent$1(element2);
+        var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
+        var win = getWindow$1(scrollParent);
+        var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent$1(scrollParent) ? scrollParent : []) : scrollParent;
+        var updatedList = list2.concat(target);
+        return isBody ? updatedList : updatedList.concat(listScrollParents$1(getParentNode$1(target)));
     }
 
-    function Xe(e3) {
-        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
-            r2 = t2.excludeDates,
-            n2 = t2.excludeDateIntervals;
-        return n2 && n2.length > 0 ? n2.some(function(t3) {
-            var r3 = t3.start,
-                n3 = t3.end;
-            return isWithinInterval(e3, {
-                start: r3,
-                end: n3
-            });
-        }) : r2 && r2.some(function(t3) {
-            return We$1(e3, t3);
-        }) || false;
+    function rectToClientRect$1(rect) {
+        return Object.assign({}, rect, {
+            left: rect.x,
+            top: rect.y,
+            right: rect.x + rect.width,
+            bottom: rect.y + rect.height
+        });
     }
 
-    function Ze$1(e3) {
-        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
-            r2 = t2.minDate,
-            n2 = t2.maxDate,
-            o2 = t2.excludeDates,
-            a2 = t2.includeDates,
-            s2 = t2.filterDate;
-        return ot(e3, {
-            minDate: r2,
-            maxDate: n2
-        }) || o2 && o2.some(function(t3) {
-            return Be$1(e3, t3);
-        }) || a2 && !a2.some(function(t3) {
-            return Be$1(e3, t3);
-        }) || s2 && !s2(_e$1(e3)) || false;
+    function getInnerBoundingClientRect(element2, strategy) {
+        var rect = getBoundingClientRect$1(element2, false, strategy === "fixed");
+        rect.top = rect.top + element2.clientTop;
+        rect.left = rect.left + element2.clientLeft;
+        rect.bottom = rect.top + element2.clientHeight;
+        rect.right = rect.left + element2.clientWidth;
+        rect.width = element2.clientWidth;
+        rect.height = element2.clientHeight;
+        rect.x = rect.left;
+        rect.y = rect.top;
+        return rect;
     }
 
-    function et$1(e3, t2, r2, n2) {
-        var o2 = getYear(e3),
-            a2 = getMonth(e3),
-            s2 = getYear(t2),
-            i2 = getMonth(t2),
-            p2 = getYear(n2);
-        return o2 === s2 && o2 === p2 ? a2 <= r2 && r2 <= i2 : o2 < s2 ? p2 === o2 && a2 <= r2 || p2 === s2 && i2 >= r2 || p2 < s2 && p2 > o2 : void 0;
+    function getClientRectFromMixedType$1(element2, clippingParent, strategy) {
+        return clippingParent === viewport$1 ? rectToClientRect$1(getViewportRect$1(element2, strategy)) : isElement$4(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect$1(getDocumentRect$1(getDocumentElement$1(element2)));
     }
 
-    function tt$1(e3) {
-        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
-            r2 = t2.minDate,
-            n2 = t2.maxDate,
-            o2 = t2.excludeDates,
-            a2 = t2.includeDates,
-            s2 = t2.filterDate;
-        return ot(e3, {
-            minDate: r2,
-            maxDate: n2
-        }) || o2 && o2.some(function(t3) {
-            return Ke$1(e3, t3);
-        }) || a2 && !a2.some(function(t3) {
-            return Ke$1(e3, t3);
-        }) || s2 && !s2(_e$1(e3)) || false;
+    function getClippingParents$1(element2) {
+        var clippingParents2 = listScrollParents$1(getParentNode$1(element2));
+        var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$2(element2).position) >= 0;
+        var clipperElement = canEscapeClipping && isHTMLElement$1(element2) ? getOffsetParent$1(element2) : element2;
+        if (!isElement$4(clipperElement)) {
+            return [];
+        }
+        return clippingParents2.filter(function(clippingParent) {
+            return isElement$4(clippingParent) && contains$2(clippingParent, clipperElement) && getNodeName$1(clippingParent) !== "body";
+        });
     }
 
-    function rt(e3) {
-        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
-            r2 = t2.minDate,
-            n2 = t2.maxDate,
-            o2 = new Date(e3, 0, 1);
-        return ot(o2, {
-            minDate: r2,
-            maxDate: n2
-        }) || false;
+    function getClippingRect$1(element2, boundary, rootBoundary, strategy) {
+        var mainClippingParents = boundary === "clippingParents" ? getClippingParents$1(element2) : [].concat(boundary);
+        var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
+        var firstClippingParent = clippingParents2[0];
+        var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
+            var rect = getClientRectFromMixedType$1(element2, clippingParent, strategy);
+            accRect.top = max$3(rect.top, accRect.top);
+            accRect.right = min$2(rect.right, accRect.right);
+            accRect.bottom = min$2(rect.bottom, accRect.bottom);
+            accRect.left = max$3(rect.left, accRect.left);
+            return accRect;
+        }, getClientRectFromMixedType$1(element2, firstClippingParent, strategy));
+        clippingRect.width = clippingRect.right - clippingRect.left;
+        clippingRect.height = clippingRect.bottom - clippingRect.top;
+        clippingRect.x = clippingRect.left;
+        clippingRect.y = clippingRect.top;
+        return clippingRect;
     }
 
-    function nt(e3, t2, r2, n2) {
-        var o2 = getYear(e3),
-            a2 = getQuarter(e3),
-            s2 = getYear(t2),
-            i2 = getQuarter(t2),
-            p2 = getYear(n2);
-        return o2 === s2 && o2 === p2 ? a2 <= r2 && r2 <= i2 : o2 < s2 ? p2 === o2 && a2 <= r2 || p2 === s2 && i2 >= r2 || p2 < s2 && p2 > o2 : void 0;
+    function computeOffsets$1(_ref2) {
+        var reference2 = _ref2.reference,
+            element2 = _ref2.element,
+            placement = _ref2.placement;
+        var basePlacement = placement ? getBasePlacement$3(placement) : null;
+        var variation = placement ? getVariation$1(placement) : null;
+        var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
+        var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
+        var offsets;
+        switch (basePlacement) {
+            case top$2:
+                offsets = {
+                    x: commonX,
+                    y: reference2.y - element2.height
+                };
+                break;
+            case bottom$1:
+                offsets = {
+                    x: commonX,
+                    y: reference2.y + reference2.height
+                };
+                break;
+            case right$1:
+                offsets = {
+                    x: reference2.x + reference2.width,
+                    y: commonY
+                };
+                break;
+            case left$1:
+                offsets = {
+                    x: reference2.x - element2.width,
+                    y: commonY
+                };
+                break;
+            default:
+                offsets = {
+                    x: reference2.x,
+                    y: reference2.y
+                };
+        }
+        var mainAxis = basePlacement ? getMainAxisFromPlacement$1(basePlacement) : null;
+        if (mainAxis != null) {
+            var len = mainAxis === "y" ? "height" : "width";
+            switch (variation) {
+                case start$2:
+                    offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
+                    break;
+                case end$1:
+                    offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
+                    break;
+            }
+        }
+        return offsets;
     }
 
-    function ot(e3) {
-        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
-            r2 = t2.minDate,
-            n2 = t2.maxDate;
-        return r2 && differenceInCalendarDays(e3, r2) < 0 || n2 && differenceInCalendarDays(e3, n2) > 0;
+    function detectOverflow$1(state, options) {
+        if (options === void 0) {
+            options = {};
+        }
+        var _options = options,
+            _options$placement = _options.placement,
+            placement = _options$placement === void 0 ? state.placement : _options$placement,
+            _options$strategy = _options.strategy,
+            strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
+            _options$boundary = _options.boundary,
+            boundary = _options$boundary === void 0 ? clippingParents$1 : _options$boundary,
+            _options$rootBoundary = _options.rootBoundary,
+            rootBoundary = _options$rootBoundary === void 0 ? viewport$1 : _options$rootBoundary,
+            _options$elementConte = _options.elementContext,
+            elementContext = _options$elementConte === void 0 ? popper$1 : _options$elementConte,
+            _options$altBoundary = _options.altBoundary,
+            altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
+            _options$padding = _options.padding,
+            padding = _options$padding === void 0 ? 0 : _options$padding;
+        var paddingObject = mergePaddingObject$1(typeof padding !== "number" ? padding : expandToHashMap$1(padding, basePlacements$1));
+        var altContext = elementContext === popper$1 ? reference$1 : popper$1;
+        var popperRect = state.rects.popper;
+        var element2 = state.elements[altBoundary ? altContext : elementContext];
+        var clippingClientRect = getClippingRect$1(isElement$4(element2) ? element2 : element2.contextElement || getDocumentElement$1(state.elements.popper), boundary, rootBoundary, strategy);
+        var referenceClientRect = getBoundingClientRect$1(state.elements.reference);
+        var popperOffsets2 = computeOffsets$1({
+            reference: referenceClientRect,
+            element: popperRect,
+            strategy: "absolute",
+            placement
+        });
+        var popperClientRect = rectToClientRect$1(Object.assign({}, popperRect, popperOffsets2));
+        var elementClientRect = elementContext === popper$1 ? popperClientRect : referenceClientRect;
+        var overflowOffsets = {
+            top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
+            bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
+            left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
+            right: elementClientRect.right - clippingClientRect.right + paddingObject.right
+        };
+        var offsetData = state.modifiersData.offset;
+        if (elementContext === popper$1 && offsetData) {
+            var offset2 = offsetData[placement];
+            Object.keys(overflowOffsets).forEach(function(key) {
+                var multiply = [right$1, bottom$1].indexOf(key) >= 0 ? 1 : -1;
+                var axis = [top$2, bottom$1].indexOf(key) >= 0 ? "y" : "x";
+                overflowOffsets[key] += offset2[axis] * multiply;
+            });
+        }
+        return overflowOffsets;
     }
 
-    function at(e3, t2) {
-        return t2.some(function(t3) {
-            return getHours(t3) === getHours(e3) && getMinutes(t3) === getMinutes(e3);
+    function computeAutoPlacement$1(state, options) {
+        if (options === void 0) {
+            options = {};
+        }
+        var _options = options,
+            placement = _options.placement,
+            boundary = _options.boundary,
+            rootBoundary = _options.rootBoundary,
+            padding = _options.padding,
+            flipVariations = _options.flipVariations,
+            _options$allowedAutoP = _options.allowedAutoPlacements,
+            allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements$1 : _options$allowedAutoP;
+        var variation = getVariation$1(placement);
+        var placements2 = variation ? flipVariations ? variationPlacements$1 : variationPlacements$1.filter(function(placement2) {
+            return getVariation$1(placement2) === variation;
+        }) : basePlacements$1;
+        var allowedPlacements = placements2.filter(function(placement2) {
+            return allowedAutoPlacements.indexOf(placement2) >= 0;
+        });
+        if (allowedPlacements.length === 0) {
+            allowedPlacements = placements2;
+        }
+        var overflows = allowedPlacements.reduce(function(acc, placement2) {
+            acc[placement2] = detectOverflow$1(state, {
+                placement: placement2,
+                boundary,
+                rootBoundary,
+                padding
+            })[getBasePlacement$3(placement2)];
+            return acc;
+        }, {});
+        return Object.keys(overflows).sort(function(a2, b2) {
+            return overflows[a2] - overflows[b2];
         });
     }
 
-    function st$1(e3) {
-        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
-            r2 = t2.excludeTimes,
-            n2 = t2.includeTimes,
-            o2 = t2.filterTime;
-        return r2 && at(e3, r2) || n2 && !at(e3, n2) || o2 && !o2(e3) || false;
+    function getExpandedFallbackPlacements$1(placement) {
+        if (getBasePlacement$3(placement) === auto$1) {
+            return [];
+        }
+        var oppositePlacement = getOppositePlacement$1(placement);
+        return [getOppositeVariationPlacement$1(placement), oppositePlacement, getOppositeVariationPlacement$1(oppositePlacement)];
     }
 
-    function it(e3, t2) {
-        var r2 = t2.minTime,
-            n2 = t2.maxTime;
-        if (!r2 || !n2)
-            throw new Error("Both minTime and maxTime props required");
-        var o2, a2 = _e$1(),
-            s2 = setHours(setMinutes(a2, getMinutes(e3)), getHours(e3)),
-            i2 = setHours(setMinutes(a2, getMinutes(r2)), getHours(r2)),
-            p2 = setHours(setMinutes(a2, getMinutes(n2)), getHours(n2));
-        try {
-            o2 = !isWithinInterval(s2, {
-                start: i2,
-                end: p2
+    function flip$2(_ref2) {
+        var state = _ref2.state,
+            options = _ref2.options,
+            name2 = _ref2.name;
+        if (state.modifiersData[name2]._skip) {
+            return;
+        }
+        var _options$mainAxis = options.mainAxis,
+            checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
+            _options$altAxis = options.altAxis,
+            checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
+            specifiedFallbackPlacements = options.fallbackPlacements,
+            padding = options.padding,
+            boundary = options.boundary,
+            rootBoundary = options.rootBoundary,
+            altBoundary = options.altBoundary,
+            _options$flipVariatio = options.flipVariations,
+            flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
+            allowedAutoPlacements = options.allowedAutoPlacements;
+        var preferredPlacement = state.options.placement;
+        var basePlacement = getBasePlacement$3(preferredPlacement);
+        var isBasePlacement = basePlacement === preferredPlacement;
+        var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement$1(preferredPlacement)] : getExpandedFallbackPlacements$1(preferredPlacement));
+        var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
+            return acc.concat(getBasePlacement$3(placement2) === auto$1 ? computeAutoPlacement$1(state, {
+                placement: placement2,
+                boundary,
+                rootBoundary,
+                padding,
+                flipVariations,
+                allowedAutoPlacements
+            }) : placement2);
+        }, []);
+        var referenceRect = state.rects.reference;
+        var popperRect = state.rects.popper;
+        var checksMap = /* @__PURE__ */ new Map();
+        var makeFallbackChecks = true;
+        var firstFittingPlacement = placements2[0];
+        for (var i2 = 0; i2 < placements2.length; i2++) {
+            var placement = placements2[i2];
+            var _basePlacement = getBasePlacement$3(placement);
+            var isStartVariation = getVariation$1(placement) === start$2;
+            var isVertical = [top$2, bottom$1].indexOf(_basePlacement) >= 0;
+            var len = isVertical ? "width" : "height";
+            var overflow = detectOverflow$1(state, {
+                placement,
+                boundary,
+                rootBoundary,
+                altBoundary,
+                padding
             });
-        } catch (e4) {
-            o2 = false;
+            var mainVariationSide = isVertical ? isStartVariation ? right$1 : left$1 : isStartVariation ? bottom$1 : top$2;
+            if (referenceRect[len] > popperRect[len]) {
+                mainVariationSide = getOppositePlacement$1(mainVariationSide);
+            }
+            var altVariationSide = getOppositePlacement$1(mainVariationSide);
+            var checks2 = [];
+            if (checkMainAxis) {
+                checks2.push(overflow[_basePlacement] <= 0);
+            }
+            if (checkAltAxis) {
+                checks2.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
+            }
+            if (checks2.every(function(check) {
+                    return check;
+                })) {
+                firstFittingPlacement = placement;
+                makeFallbackChecks = false;
+                break;
+            }
+            checksMap.set(placement, checks2);
+        }
+        if (makeFallbackChecks) {
+            var numberOfChecks = flipVariations ? 3 : 1;
+            var _loop = function _loop2(_i3) {
+                var fittingPlacement = placements2.find(function(placement2) {
+                    var checks3 = checksMap.get(placement2);
+                    if (checks3) {
+                        return checks3.slice(0, _i3).every(function(check) {
+                            return check;
+                        });
+                    }
+                });
+                if (fittingPlacement) {
+                    firstFittingPlacement = fittingPlacement;
+                    return "break";
+                }
+            };
+            for (var _i2 = numberOfChecks; _i2 > 0; _i2--) {
+                var _ret = _loop(_i2);
+                if (_ret === "break")
+                    break;
+            }
+        }
+        if (state.placement !== firstFittingPlacement) {
+            state.modifiersData[name2]._skip = true;
+            state.placement = firstFittingPlacement;
+            state.reset = true;
         }
-        return o2;
     }
+    const flip$3 = {
+        name: "flip",
+        enabled: true,
+        phase: "main",
+        fn: flip$2,
+        requiresIfExists: ["offset"],
+        data: {
+            _skip: false
+        }
+    };
 
-    function pt$1(e3) {
-        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
-            r2 = t2.minDate,
-            n2 = t2.includeDates,
-            o2 = subMonths(e3, 1);
-        return r2 && differenceInCalendarMonths(r2, o2) > 0 || n2 && n2.every(function(e4) {
-            return differenceInCalendarMonths(e4, o2) > 0;
-        }) || false;
+    function getSideOffsets$1(overflow, rect, preventedOffsets) {
+        if (preventedOffsets === void 0) {
+            preventedOffsets = {
+                x: 0,
+                y: 0
+            };
+        }
+        return {
+            top: overflow.top - rect.height - preventedOffsets.y,
+            right: overflow.right - rect.width + preventedOffsets.x,
+            bottom: overflow.bottom - rect.height + preventedOffsets.y,
+            left: overflow.left - rect.width - preventedOffsets.x
+        };
     }
 
-    function ct$1(e3) {
-        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
-            r2 = t2.maxDate,
-            n2 = t2.includeDates,
-            o2 = addMonths(e3, 1);
-        return r2 && differenceInCalendarMonths(o2, r2) > 0 || n2 && n2.every(function(e4) {
-            return differenceInCalendarMonths(o2, e4) > 0;
-        }) || false;
+    function isAnySideFullyClipped$1(overflow) {
+        return [top$2, right$1, bottom$1, left$1].some(function(side) {
+            return overflow[side] >= 0;
+        });
     }
 
-    function lt$1(e3) {
-        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
-            r2 = t2.minDate,
-            n2 = t2.includeDates,
-            o2 = subYears(e3, 1);
-        return r2 && differenceInCalendarYears(r2, o2) > 0 || n2 && n2.every(function(e4) {
-            return differenceInCalendarYears(e4, o2) > 0;
-        }) || false;
+    function hide$2(_ref2) {
+        var state = _ref2.state,
+            name2 = _ref2.name;
+        var referenceRect = state.rects.reference;
+        var popperRect = state.rects.popper;
+        var preventedOffsets = state.modifiersData.preventOverflow;
+        var referenceOverflow = detectOverflow$1(state, {
+            elementContext: "reference"
+        });
+        var popperAltOverflow = detectOverflow$1(state, {
+            altBoundary: true
+        });
+        var referenceClippingOffsets = getSideOffsets$1(referenceOverflow, referenceRect);
+        var popperEscapeOffsets = getSideOffsets$1(popperAltOverflow, popperRect, preventedOffsets);
+        var isReferenceHidden = isAnySideFullyClipped$1(referenceClippingOffsets);
+        var hasPopperEscaped = isAnySideFullyClipped$1(popperEscapeOffsets);
+        state.modifiersData[name2] = {
+            referenceClippingOffsets,
+            popperEscapeOffsets,
+            isReferenceHidden,
+            hasPopperEscaped
+        };
+        state.attributes.popper = Object.assign({}, state.attributes.popper, {
+            "data-popper-reference-hidden": isReferenceHidden,
+            "data-popper-escaped": hasPopperEscaped
+        });
     }
+    const hide$3 = {
+        name: "hide",
+        enabled: true,
+        phase: "main",
+        requiresIfExists: ["preventOverflow"],
+        fn: hide$2
+    };
 
-    function dt$1(e3) {
-        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
-            r2 = t2.maxDate,
-            n2 = t2.includeDates,
-            o2 = addYears(e3, 1);
-        return r2 && differenceInCalendarYears(o2, r2) > 0 || n2 && n2.every(function(e4) {
-            return differenceInCalendarYears(o2, e4) > 0;
-        }) || false;
+    function distanceAndSkiddingToXY$1(placement, rects, offset2) {
+        var basePlacement = getBasePlacement$3(placement);
+        var invertDistance = [left$1, top$2].indexOf(basePlacement) >= 0 ? -1 : 1;
+        var _ref2 = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
+                placement
+            })) : offset2,
+            skidding = _ref2[0],
+            distance = _ref2[1];
+        skidding = skidding || 0;
+        distance = (distance || 0) * invertDistance;
+        return [left$1, right$1].indexOf(basePlacement) >= 0 ? {
+            x: distance,
+            y: skidding
+        } : {
+            x: skidding,
+            y: distance
+        };
     }
 
-    function ut$1(e3) {
-        var t2 = e3.minDate,
-            r2 = e3.includeDates;
-        if (r2 && t2) {
-            var n2 = r2.filter(function(e4) {
-                return differenceInCalendarDays(e4, t2) >= 0;
-            });
-            return min$1(n2);
+    function offset$2(_ref2) {
+        var state = _ref2.state,
+            options = _ref2.options,
+            name2 = _ref2.name;
+        var _options$offset = options.offset,
+            offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
+        var data2 = placements$1.reduce(function(acc, placement) {
+            acc[placement] = distanceAndSkiddingToXY$1(placement, state.rects, offset2);
+            return acc;
+        }, {});
+        var _data$state$placement = data2[state.placement],
+            x2 = _data$state$placement.x,
+            y2 = _data$state$placement.y;
+        if (state.modifiersData.popperOffsets != null) {
+            state.modifiersData.popperOffsets.x += x2;
+            state.modifiersData.popperOffsets.y += y2;
         }
-        return r2 ? min$1(r2) : t2;
+        state.modifiersData[name2] = data2;
     }
+    const offset$3 = {
+        name: "offset",
+        enabled: true,
+        phase: "main",
+        requires: ["popperOffsets"],
+        fn: offset$2
+    };
 
-    function ht$2(e3) {
-        var t2 = e3.maxDate,
-            r2 = e3.includeDates;
-        if (r2 && t2) {
-            var n2 = r2.filter(function(e4) {
-                return differenceInCalendarDays(e4, t2) <= 0;
-            });
-            return max$2(n2);
-        }
-        return r2 ? max$2(r2) : t2;
+    function popperOffsets$2(_ref2) {
+        var state = _ref2.state,
+            name2 = _ref2.name;
+        state.modifiersData[name2] = computeOffsets$1({
+            reference: state.rects.reference,
+            element: state.rects.popper,
+            strategy: "absolute",
+            placement: state.placement
+        });
     }
+    const popperOffsets$3 = {
+        name: "popperOffsets",
+        enabled: true,
+        phase: "read",
+        fn: popperOffsets$2,
+        data: {}
+    };
 
-    function mt$1() {
-        for (var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "react-datepicker__day--highlighted", r2 = /* @__PURE__ */ new Map(), o2 = 0, a2 = e3.length; o2 < a2; o2++) {
-            var s2 = e3[o2];
-            if (isDate$1(s2)) {
-                var i2 = Ee$1(s2, "MM.dd.yyyy"),
-                    p2 = r2.get(i2) || [];
-                p2.includes(t2) || (p2.push(t2), r2.set(i2, p2));
-            } else if ("object" === ie$3(s2)) {
-                var c2 = Object.keys(s2),
-                    l2 = c2[0],
-                    d2 = s2[c2[0]];
-                if ("string" == typeof l2 && d2.constructor === Array)
-                    for (var u2 = 0, h2 = d2.length; u2 < h2; u2++) {
-                        var m2 = Ee$1(d2[u2], "MM.dd.yyyy"),
-                            f2 = r2.get(m2) || [];
-                        f2.includes(l2) || (f2.push(l2), r2.set(m2, f2));
-                    }
-            }
+    function getAltAxis$1(axis) {
+        return axis === "x" ? "y" : "x";
+    }
+
+    function preventOverflow$2(_ref2) {
+        var state = _ref2.state,
+            options = _ref2.options,
+            name2 = _ref2.name;
+        var _options$mainAxis = options.mainAxis,
+            checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
+            _options$altAxis = options.altAxis,
+            checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
+            boundary = options.boundary,
+            rootBoundary = options.rootBoundary,
+            altBoundary = options.altBoundary,
+            padding = options.padding,
+            _options$tether = options.tether,
+            tether = _options$tether === void 0 ? true : _options$tether,
+            _options$tetherOffset = options.tetherOffset,
+            tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
+        var overflow = detectOverflow$1(state, {
+            boundary,
+            rootBoundary,
+            padding,
+            altBoundary
+        });
+        var basePlacement = getBasePlacement$3(state.placement);
+        var variation = getVariation$1(state.placement);
+        var isBasePlacement = !variation;
+        var mainAxis = getMainAxisFromPlacement$1(basePlacement);
+        var altAxis = getAltAxis$1(mainAxis);
+        var popperOffsets2 = state.modifiersData.popperOffsets;
+        var referenceRect = state.rects.reference;
+        var popperRect = state.rects.popper;
+        var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
+            placement: state.placement
+        })) : tetherOffset;
+        var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
+            mainAxis: tetherOffsetValue,
+            altAxis: tetherOffsetValue
+        } : Object.assign({
+            mainAxis: 0,
+            altAxis: 0
+        }, tetherOffsetValue);
+        var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
+        var data2 = {
+            x: 0,
+            y: 0
+        };
+        if (!popperOffsets2) {
+            return;
         }
-        return r2;
+        if (checkMainAxis) {
+            var _offsetModifierState$;
+            var mainSide = mainAxis === "y" ? top$2 : left$1;
+            var altSide = mainAxis === "y" ? bottom$1 : right$1;
+            var len = mainAxis === "y" ? "height" : "width";
+            var offset2 = popperOffsets2[mainAxis];
+            var min2 = offset2 + overflow[mainSide];
+            var max2 = offset2 - overflow[altSide];
+            var additive = tether ? -popperRect[len] / 2 : 0;
+            var minLen = variation === start$2 ? referenceRect[len] : popperRect[len];
+            var maxLen = variation === start$2 ? -popperRect[len] : -referenceRect[len];
+            var arrowElement = state.elements.arrow;
+            var arrowRect = tether && arrowElement ? getLayoutRect$1(arrowElement) : {
+                width: 0,
+                height: 0
+            };
+            var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject$1();
+            var arrowPaddingMin = arrowPaddingObject[mainSide];
+            var arrowPaddingMax = arrowPaddingObject[altSide];
+            var arrowLen = within$1(0, referenceRect[len], arrowRect[len]);
+            var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
+            var maxOffset2 = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
+            var arrowOffsetParent = state.elements.arrow && getOffsetParent$1(state.elements.arrow);
+            var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
+            var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
+            var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
+            var tetherMax = offset2 + maxOffset2 - offsetModifierValue;
+            var preventedOffset = within$1(tether ? min$2(min2, tetherMin) : min2, offset2, tether ? max$3(max2, tetherMax) : max2);
+            popperOffsets2[mainAxis] = preventedOffset;
+            data2[mainAxis] = preventedOffset - offset2;
+        }
+        if (checkAltAxis) {
+            var _offsetModifierState$2;
+            var _mainSide = mainAxis === "x" ? top$2 : left$1;
+            var _altSide = mainAxis === "x" ? bottom$1 : right$1;
+            var _offset = popperOffsets2[altAxis];
+            var _len = altAxis === "y" ? "height" : "width";
+            var _min = _offset + overflow[_mainSide];
+            var _max = _offset - overflow[_altSide];
+            var isOriginSide = [top$2, left$1].indexOf(basePlacement) !== -1;
+            var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
+            var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
+            var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
+            var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within$1(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
+            popperOffsets2[altAxis] = _preventedOffset;
+            data2[altAxis] = _preventedOffset - _offset;
+        }
+        state.modifiersData[name2] = data2;
+    }
+    const preventOverflow$3 = {
+        name: "preventOverflow",
+        enabled: true,
+        phase: "main",
+        fn: preventOverflow$2,
+        requiresIfExists: ["offset"]
+    };
+
+    function getHTMLElementScroll$1(element2) {
+        return {
+            scrollLeft: element2.scrollLeft,
+            scrollTop: element2.scrollTop
+        };
     }
 
-    function ft$1(e3, t2, r2, n2, o2) {
-        for (var a2 = o2.length, p2 = [], c2 = 0; c2 < a2; c2++) {
-            var l2 = addMinutes(addHours(e3, getHours(o2[c2])), getMinutes(o2[c2])),
-                d2 = addMinutes(e3, (r2 + 1) * n2);
-            isAfter(l2, t2) && isBefore(l2, d2) && p2.push(o2[c2]);
+    function getNodeScroll$1(node2) {
+        if (node2 === getWindow$1(node2) || !isHTMLElement$1(node2)) {
+            return getWindowScroll$1(node2);
+        } else {
+            return getHTMLElementScroll$1(node2);
         }
-        return p2;
     }
 
-    function yt(e3) {
-        return e3 < 10 ? "0".concat(e3) : "".concat(e3);
+    function isElementScaled(element2) {
+        var rect = element2.getBoundingClientRect();
+        var scaleX = round$2(rect.width) / element2.offsetWidth || 1;
+        var scaleY = round$2(rect.height) / element2.offsetHeight || 1;
+        return scaleX !== 1 || scaleY !== 1;
     }
 
-    function vt(e3) {
-        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 12,
-            r2 = Math.ceil(getYear(e3) / t2) * t2,
-            n2 = r2 - (t2 - 1);
+    function getCompositeRect$1(elementOrVirtualElement, offsetParent, isFixed) {
+        if (isFixed === void 0) {
+            isFixed = false;
+        }
+        var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
+        var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
+        var documentElement = getDocumentElement$1(offsetParent);
+        var rect = getBoundingClientRect$1(elementOrVirtualElement, offsetParentIsScaled, isFixed);
+        var scroll = {
+            scrollLeft: 0,
+            scrollTop: 0
+        };
+        var offsets = {
+            x: 0,
+            y: 0
+        };
+        if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
+            if (getNodeName$1(offsetParent) !== "body" || isScrollParent$1(documentElement)) {
+                scroll = getNodeScroll$1(offsetParent);
+            }
+            if (isHTMLElement$1(offsetParent)) {
+                offsets = getBoundingClientRect$1(offsetParent, true);
+                offsets.x += offsetParent.clientLeft;
+                offsets.y += offsetParent.clientTop;
+            } else if (documentElement) {
+                offsets.x = getWindowScrollBarX$1(documentElement);
+            }
+        }
         return {
-            startPeriod: n2,
-            endPeriod: r2
+            x: rect.left + scroll.scrollLeft - offsets.x,
+            y: rect.top + scroll.scrollTop - offsets.y,
+            width: rect.width,
+            height: rect.height
         };
     }
 
-    function Dt$1(e3, t2, r2, n2) {
-        for (var o2 = [], a2 = 0; a2 < 2 * t2 + 1; a2++) {
-            var s2 = e3 + t2 - a2,
-                i2 = true;
-            r2 && (i2 = getYear(r2) <= s2), n2 && i2 && (i2 = getYear(n2) >= s2), i2 && o2.push(s2);
+    function order$1(modifiers2) {
+        var map2 = /* @__PURE__ */ new Map();
+        var visited = /* @__PURE__ */ new Set();
+        var result = [];
+        modifiers2.forEach(function(modifier) {
+            map2.set(modifier.name, modifier);
+        });
+
+        function sort(modifier) {
+            visited.add(modifier.name);
+            var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
+            requires.forEach(function(dep) {
+                if (!visited.has(dep)) {
+                    var depModifier = map2.get(dep);
+                    if (depModifier) {
+                        sort(depModifier);
+                    }
+                }
+            });
+            result.push(modifier);
         }
-        return o2;
+        modifiers2.forEach(function(modifier) {
+            if (!visited.has(modifier.name)) {
+                sort(modifier);
+            }
+        });
+        return result;
     }
-    var wt = onClickOutsideHOC(function(n2) {
-            he$1(a2, React__default.default.Component);
-            var o2 = De(a2);
 
-            function a2(r2) {
-                var n3;
-                pe$1(this, a2), de$1(ye(n3 = o2.call(this, r2)), "renderOptions", function() {
-                    var t2 = n3.props.year,
-                        r3 = n3.state.yearsList.map(function(r4) {
-                            return React__default.default.createElement("div", {
-                                className: t2 === r4 ? "react-datepicker__year-option react-datepicker__year-option--selected_year" : "react-datepicker__year-option",
-                                key: r4,
-                                onClick: n3.onChange.bind(ye(n3), r4),
-                                "aria-selected": t2 === r4 ? "true" : void 0
-                            }, t2 === r4 ? React__default.default.createElement("span", {
-                                className: "react-datepicker__year-option--selected"
-                            }, "\u2713") : "", r4);
-                        }),
-                        o3 = n3.props.minDate ? getYear(n3.props.minDate) : null,
-                        a3 = n3.props.maxDate ? getYear(n3.props.maxDate) : null;
-                    return a3 && n3.state.yearsList.find(function(e3) {
-                        return e3 === a3;
-                    }) || r3.unshift(React__default.default.createElement("div", {
-                        className: "react-datepicker__year-option",
-                        key: "upcoming",
-                        onClick: n3.incrementYears
-                    }, React__default.default.createElement("a", {
-                        className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-upcoming"
-                    }))), o3 && n3.state.yearsList.find(function(e3) {
-                        return e3 === o3;
-                    }) || r3.push(React__default.default.createElement("div", {
-                        className: "react-datepicker__year-option",
-                        key: "previous",
-                        onClick: n3.decrementYears
-                    }, React__default.default.createElement("a", {
-                        className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-previous"
-                    }))), r3;
-                }), de$1(ye(n3), "onChange", function(e3) {
-                    n3.props.onChange(e3);
-                }), de$1(ye(n3), "handleClickOutside", function() {
-                    n3.props.onCancel();
-                }), de$1(ye(n3), "shiftYears", function(e3) {
-                    var t2 = n3.state.yearsList.map(function(t3) {
-                        return t3 + e3;
-                    });
-                    n3.setState({
-                        yearsList: t2
+    function orderModifiers$1(modifiers2) {
+        var orderedModifiers = order$1(modifiers2);
+        return modifierPhases$1.reduce(function(acc, phase) {
+            return acc.concat(orderedModifiers.filter(function(modifier) {
+                return modifier.phase === phase;
+            }));
+        }, []);
+    }
+
+    function debounce$5(fn2) {
+        var pending;
+        return function() {
+            if (!pending) {
+                pending = new Promise(function(resolve2) {
+                    Promise.resolve().then(function() {
+                        pending = void 0;
+                        resolve2(fn2());
                     });
-                }), de$1(ye(n3), "incrementYears", function() {
-                    return n3.shiftYears(1);
-                }), de$1(ye(n3), "decrementYears", function() {
-                    return n3.shiftYears(-1);
                 });
-                var s2 = r2.yearDropdownItemNumber,
-                    i2 = r2.scrollableYearDropdown,
-                    p2 = s2 || (i2 ? 10 : 5);
-                return n3.state = {
-                    yearsList: Dt$1(n3.props.year, p2, n3.props.minDate, n3.props.maxDate)
-                }, n3.dropdownRef = React.createRef(), n3;
             }
-            return le$1(a2, [{
-                key: "componentDidMount",
-                value: function() {
-                    var e3 = this.dropdownRef.current;
-                    e3 && (e3.scrollTop = e3.scrollHeight / 2 - e3.clientHeight / 2);
-                }
-            }, {
-                key: "render",
-                value: function() {
-                    var t2 = r$1({
-                        "react-datepicker__year-dropdown": true,
-                        "react-datepicker__year-dropdown--scrollable": this.props.scrollableYearDropdown
-                    });
-                    return React__default.default.createElement("div", {
-                        className: t2,
-                        ref: this.dropdownRef
-                    }, this.renderOptions());
-                }
-            }]), a2;
-        }()),
-        gt = function(t2) {
-            he$1(n2, React__default.default.Component);
-            var r2 = De(n2);
+            return pending;
+        };
+    }
 
-            function n2() {
-                var t3;
-                pe$1(this, n2);
-                for (var o2 = arguments.length, a2 = new Array(o2), s2 = 0; s2 < o2; s2++)
-                    a2[s2] = arguments[s2];
-                return de$1(ye(t3 = r2.call.apply(r2, [this].concat(a2))), "state", {
-                    dropdownVisible: false
-                }), de$1(ye(t3), "renderSelectOptions", function() {
-                    for (var r3 = t3.props.minDate ? getYear(t3.props.minDate) : 1900, n3 = t3.props.maxDate ? getYear(t3.props.maxDate) : 2100, o3 = [], a3 = r3; a3 <= n3; a3++)
-                        o3.push(React__default.default.createElement("option", {
-                            key: a3,
-                            value: a3
-                        }, a3));
-                    return o3;
-                }), de$1(ye(t3), "onSelectChange", function(e3) {
-                    t3.onChange(e3.target.value);
-                }), de$1(ye(t3), "renderSelectMode", function() {
-                    return React__default.default.createElement("select", {
-                        value: t3.props.year,
-                        className: "react-datepicker__year-select",
-                        onChange: t3.onSelectChange
-                    }, t3.renderSelectOptions());
-                }), de$1(ye(t3), "renderReadView", function(r3) {
-                    return React__default.default.createElement("div", {
-                        key: "read",
-                        style: {
-                            visibility: r3 ? "visible" : "hidden"
-                        },
-                        className: "react-datepicker__year-read-view",
-                        onClick: function(e3) {
-                            return t3.toggleDropdown(e3);
-                        }
-                    }, React__default.default.createElement("span", {
-                        className: "react-datepicker__year-read-view--down-arrow"
-                    }), React__default.default.createElement("span", {
-                        className: "react-datepicker__year-read-view--selected-year"
-                    }, t3.props.year));
-                }), de$1(ye(t3), "renderDropdown", function() {
-                    return React__default.default.createElement(wt, {
-                        key: "dropdown",
-                        year: t3.props.year,
-                        onChange: t3.onChange,
-                        onCancel: t3.toggleDropdown,
-                        minDate: t3.props.minDate,
-                        maxDate: t3.props.maxDate,
-                        scrollableYearDropdown: t3.props.scrollableYearDropdown,
-                        yearDropdownItemNumber: t3.props.yearDropdownItemNumber
+    function mergeByName$1(modifiers2) {
+        var merged = modifiers2.reduce(function(merged2, current2) {
+            var existing = merged2[current2.name];
+            merged2[current2.name] = existing ? Object.assign({}, existing, current2, {
+                options: Object.assign({}, existing.options, current2.options),
+                data: Object.assign({}, existing.data, current2.data)
+            }) : current2;
+            return merged2;
+        }, {});
+        return Object.keys(merged).map(function(key) {
+            return merged[key];
+        });
+    }
+    var DEFAULT_OPTIONS$2 = {
+        placement: "bottom",
+        modifiers: [],
+        strategy: "absolute"
+    };
+
+    function areValidElements$1() {
+        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+            args[_key] = arguments[_key];
+        }
+        return !args.some(function(element2) {
+            return !(element2 && typeof element2.getBoundingClientRect === "function");
+        });
+    }
+
+    function popperGenerator$1(generatorOptions) {
+        if (generatorOptions === void 0) {
+            generatorOptions = {};
+        }
+        var _generatorOptions = generatorOptions,
+            _generatorOptions$def = _generatorOptions.defaultModifiers,
+            defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
+            _generatorOptions$def2 = _generatorOptions.defaultOptions,
+            defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS$2 : _generatorOptions$def2;
+        return function createPopper2(reference2, popper2, options) {
+            if (options === void 0) {
+                options = defaultOptions2;
+            }
+            var state = {
+                placement: "bottom",
+                orderedModifiers: [],
+                options: Object.assign({}, DEFAULT_OPTIONS$2, defaultOptions2),
+                modifiersData: {},
+                elements: {
+                    reference: reference2,
+                    popper: popper2
+                },
+                attributes: {},
+                styles: {}
+            };
+            var effectCleanupFns = [];
+            var isDestroyed = false;
+            var instance2 = {
+                state,
+                setOptions: function setOptions2(setOptionsAction) {
+                    var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
+                    cleanupModifierEffects();
+                    state.options = Object.assign({}, defaultOptions2, state.options, options2);
+                    state.scrollParents = {
+                        reference: isElement$4(reference2) ? listScrollParents$1(reference2) : reference2.contextElement ? listScrollParents$1(reference2.contextElement) : [],
+                        popper: listScrollParents$1(popper2)
+                    };
+                    var orderedModifiers = orderModifiers$1(mergeByName$1([].concat(defaultModifiers2, state.options.modifiers)));
+                    state.orderedModifiers = orderedModifiers.filter(function(m2) {
+                        return m2.enabled;
                     });
-                }), de$1(ye(t3), "renderScrollMode", function() {
-                    var e3 = t3.state.dropdownVisible,
-                        r3 = [t3.renderReadView(!e3)];
-                    return e3 && r3.unshift(t3.renderDropdown()), r3;
-                }), de$1(ye(t3), "onChange", function(e3) {
-                    t3.toggleDropdown(), e3 !== t3.props.year && t3.props.onChange(e3);
-                }), de$1(ye(t3), "toggleDropdown", function(e3) {
-                    t3.setState({
-                        dropdownVisible: !t3.state.dropdownVisible
-                    }, function() {
-                        t3.props.adjustDateOnChange && t3.handleYearChange(t3.props.date, e3);
+                    runModifierEffects();
+                    return instance2.update();
+                },
+                forceUpdate: function forceUpdate() {
+                    if (isDestroyed) {
+                        return;
+                    }
+                    var _state$elements = state.elements,
+                        reference3 = _state$elements.reference,
+                        popper3 = _state$elements.popper;
+                    if (!areValidElements$1(reference3, popper3)) {
+                        return;
+                    }
+                    state.rects = {
+                        reference: getCompositeRect$1(reference3, getOffsetParent$1(popper3), state.options.strategy === "fixed"),
+                        popper: getLayoutRect$1(popper3)
+                    };
+                    state.reset = false;
+                    state.placement = state.options.placement;
+                    state.orderedModifiers.forEach(function(modifier) {
+                        return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
                     });
-                }), de$1(ye(t3), "handleYearChange", function(e3, r3) {
-                    t3.onSelect(e3, r3), t3.setOpen();
-                }), de$1(ye(t3), "onSelect", function(e3, r3) {
-                    t3.props.onSelect && t3.props.onSelect(e3, r3);
-                }), de$1(ye(t3), "setOpen", function() {
-                    t3.props.setOpen && t3.props.setOpen(true);
-                }), t3;
-            }
-            return le$1(n2, [{
-                key: "render",
-                value: function() {
-                    var t3;
-                    switch (this.props.dropdownMode) {
-                        case "scroll":
-                            t3 = this.renderScrollMode();
-                            break;
-                        case "select":
-                            t3 = this.renderSelectMode();
+                    for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
+                        if (state.reset === true) {
+                            state.reset = false;
+                            index2 = -1;
+                            continue;
+                        }
+                        var _state$orderedModifie = state.orderedModifiers[index2],
+                            fn2 = _state$orderedModifie.fn,
+                            _state$orderedModifie2 = _state$orderedModifie.options,
+                            _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
+                            name2 = _state$orderedModifie.name;
+                        if (typeof fn2 === "function") {
+                            state = fn2({
+                                state,
+                                options: _options,
+                                name: name2,
+                                instance: instance2
+                            }) || state;
+                        }
                     }
-                    return React__default.default.createElement("div", {
-                        className: "react-datepicker__year-dropdown-container react-datepicker__year-dropdown-container--".concat(this.props.dropdownMode)
-                    }, t3);
-                }
-            }]), n2;
-        }(),
-        kt$1 = onClickOutsideHOC(function(t2) {
-            he$1(n2, React__default.default.Component);
-            var r2 = De(n2);
-
-            function n2() {
-                var t3;
-                pe$1(this, n2);
-                for (var o2 = arguments.length, a2 = new Array(o2), s2 = 0; s2 < o2; s2++)
-                    a2[s2] = arguments[s2];
-                return de$1(ye(t3 = r2.call.apply(r2, [this].concat(a2))), "isSelectedMonth", function(e3) {
-                    return t3.props.month === e3;
-                }), de$1(ye(t3), "renderOptions", function() {
-                    return t3.props.monthNames.map(function(r3, n3) {
-                        return React__default.default.createElement("div", {
-                            className: t3.isSelectedMonth(n3) ? "react-datepicker__month-option react-datepicker__month-option--selected_month" : "react-datepicker__month-option",
-                            key: r3,
-                            onClick: t3.onChange.bind(ye(t3), n3),
-                            "aria-selected": t3.isSelectedMonth(n3) ? "true" : void 0
-                        }, t3.isSelectedMonth(n3) ? React__default.default.createElement("span", {
-                            className: "react-datepicker__month-option--selected"
-                        }, "\u2713") : "", r3);
+                },
+                update: debounce$5(function() {
+                    return new Promise(function(resolve2) {
+                        instance2.forceUpdate();
+                        resolve2(state);
                     });
-                }), de$1(ye(t3), "onChange", function(e3) {
-                    return t3.props.onChange(e3);
-                }), de$1(ye(t3), "handleClickOutside", function() {
-                    return t3.props.onCancel();
-                }), t3;
+                }),
+                destroy: function destroy() {
+                    cleanupModifierEffects();
+                    isDestroyed = true;
+                }
+            };
+            if (!areValidElements$1(reference2, popper2)) {
+                return instance2;
             }
-            return le$1(n2, [{
-                key: "render",
-                value: function() {
-                    return React__default.default.createElement("div", {
-                        className: "react-datepicker__month-dropdown"
-                    }, this.renderOptions());
+            instance2.setOptions(options).then(function(state2) {
+                if (!isDestroyed && options.onFirstUpdate) {
+                    options.onFirstUpdate(state2);
                 }
-            }]), n2;
-        }()),
-        bt = function(t2) {
-            he$1(n2, React__default.default.Component);
-            var r2 = De(n2);
+            });
 
-            function n2() {
-                var t3;
-                pe$1(this, n2);
-                for (var o2 = arguments.length, a2 = new Array(o2), s2 = 0; s2 < o2; s2++)
-                    a2[s2] = arguments[s2];
-                return de$1(ye(t3 = r2.call.apply(r2, [this].concat(a2))), "state", {
-                    dropdownVisible: false
-                }), de$1(ye(t3), "renderSelectOptions", function(t4) {
-                    return t4.map(function(t5, r3) {
-                        return React__default.default.createElement("option", {
-                            key: r3,
-                            value: r3
-                        }, t5);
-                    });
-                }), de$1(ye(t3), "renderSelectMode", function(r3) {
-                    return React__default.default.createElement("select", {
-                        value: t3.props.month,
-                        className: "react-datepicker__month-select",
-                        onChange: function(e3) {
-                            return t3.onChange(e3.target.value);
-                        }
-                    }, t3.renderSelectOptions(r3));
-                }), de$1(ye(t3), "renderReadView", function(r3, n3) {
-                    return React__default.default.createElement("div", {
-                        key: "read",
-                        style: {
-                            visibility: r3 ? "visible" : "hidden"
-                        },
-                        className: "react-datepicker__month-read-view",
-                        onClick: t3.toggleDropdown
-                    }, React__default.default.createElement("span", {
-                        className: "react-datepicker__month-read-view--down-arrow"
-                    }), React__default.default.createElement("span", {
-                        className: "react-datepicker__month-read-view--selected-month"
-                    }, n3[t3.props.month]));
-                }), de$1(ye(t3), "renderDropdown", function(r3) {
-                    return React__default.default.createElement(kt$1, {
-                        key: "dropdown",
-                        month: t3.props.month,
-                        monthNames: r3,
-                        onChange: t3.onChange,
-                        onCancel: t3.toggleDropdown
-                    });
-                }), de$1(ye(t3), "renderScrollMode", function(e3) {
-                    var r3 = t3.state.dropdownVisible,
-                        n3 = [t3.renderReadView(!r3, e3)];
-                    return r3 && n3.unshift(t3.renderDropdown(e3)), n3;
-                }), de$1(ye(t3), "onChange", function(e3) {
-                    t3.toggleDropdown(), e3 !== t3.props.month && t3.props.onChange(e3);
-                }), de$1(ye(t3), "toggleDropdown", function() {
-                    return t3.setState({
-                        dropdownVisible: !t3.state.dropdownVisible
-                    });
-                }), t3;
-            }
-            return le$1(n2, [{
-                key: "render",
-                value: function() {
-                    var t3, r3 = this,
-                        n3 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(this.props.useShortMonthInDropdown ? function(e3) {
-                            return ze$1(e3, r3.props.locale);
-                        } : function(e3) {
-                            return $e$1(e3, r3.props.locale);
+            function runModifierEffects() {
+                state.orderedModifiers.forEach(function(_ref2) {
+                    var name2 = _ref2.name,
+                        _ref$options = _ref2.options,
+                        options2 = _ref$options === void 0 ? {} : _ref$options,
+                        effect2 = _ref2.effect;
+                    if (typeof effect2 === "function") {
+                        var cleanupFn = effect2({
+                            state,
+                            name: name2,
+                            instance: instance2,
+                            options: options2
                         });
-                    switch (this.props.dropdownMode) {
-                        case "scroll":
-                            t3 = this.renderScrollMode(n3);
-                            break;
-                        case "select":
-                            t3 = this.renderSelectMode(n3);
+                        var noopFn = function noopFn2() {};
+                        effectCleanupFns.push(cleanupFn || noopFn);
                     }
-                    return React__default.default.createElement("div", {
-                        className: "react-datepicker__month-dropdown-container react-datepicker__month-dropdown-container--".concat(this.props.dropdownMode)
-                    }, t3);
+                });
+            }
+
+            function cleanupModifierEffects() {
+                effectCleanupFns.forEach(function(fn2) {
+                    return fn2();
+                });
+                effectCleanupFns = [];
+            }
+            return instance2;
+        };
+    }
+    var defaultModifiers$1 = [eventListeners$1, popperOffsets$3, computeStyles$3, applyStyles$3, offset$3, flip$3, preventOverflow$3, arrow$3, hide$3];
+    var createPopper$1 = /* @__PURE__ */ popperGenerator$1({
+        defaultModifiers: defaultModifiers$1
+    });
+    var CONTENT_CLASS$1 = "tippy-content";
+    var BACKDROP_CLASS$1 = "tippy-backdrop";
+    var ARROW_CLASS$1 = "tippy-arrow";
+    var SVG_ARROW_CLASS$1 = "tippy-svg-arrow";
+    var TOUCH_OPTIONS$1 = {
+        passive: true,
+        capture: true
+    };
+
+    function getValueAtIndexOrReturn$1(value, index2, defaultValue2) {
+        if (Array.isArray(value)) {
+            var v2 = value[index2];
+            return v2 == null ? Array.isArray(defaultValue2) ? defaultValue2[index2] : defaultValue2 : v2;
+        }
+        return value;
+    }
+
+    function isType$1(value, type2) {
+        var str = {}.toString.call(value);
+        return str.indexOf("[object") === 0 && str.indexOf(type2 + "]") > -1;
+    }
+
+    function invokeWithArgsOrReturn$1(value, args) {
+        return typeof value === "function" ? value.apply(void 0, args) : value;
+    }
+
+    function debounce$4(fn2, ms2) {
+        if (ms2 === 0) {
+            return fn2;
+        }
+        var timeout2;
+        return function(arg) {
+            clearTimeout(timeout2);
+            timeout2 = setTimeout(function() {
+                fn2(arg);
+            }, ms2);
+        };
+    }
+
+    function splitBySpaces$1(value) {
+        return value.split(/\s+/).filter(Boolean);
+    }
+
+    function normalizeToArray$1(value) {
+        return [].concat(value);
+    }
+
+    function pushIfUnique$1(arr, value) {
+        if (arr.indexOf(value) === -1) {
+            arr.push(value);
+        }
+    }
+
+    function unique$1(arr) {
+        return arr.filter(function(item, index2) {
+            return arr.indexOf(item) === index2;
+        });
+    }
+
+    function getBasePlacement$2(placement) {
+        return placement.split("-")[0];
+    }
+
+    function arrayFrom$1(value) {
+        return [].slice.call(value);
+    }
+
+    function removeUndefinedProps$1(obj) {
+        return Object.keys(obj).reduce(function(acc, key) {
+            if (obj[key] !== void 0) {
+                acc[key] = obj[key];
+            }
+            return acc;
+        }, {});
+    }
+
+    function div$1() {
+        return document.createElement("div");
+    }
+
+    function isElement$3(value) {
+        return ["Element", "Fragment"].some(function(type2) {
+            return isType$1(value, type2);
+        });
+    }
+
+    function isNodeList$2(value) {
+        return isType$1(value, "NodeList");
+    }
+
+    function isMouseEvent$1(value) {
+        return isType$1(value, "MouseEvent");
+    }
+
+    function isReferenceElement$1(value) {
+        return !!(value && value._tippy && value._tippy.reference === value);
+    }
+
+    function getArrayOfElements$1(value) {
+        if (isElement$3(value)) {
+            return [value];
+        }
+        if (isNodeList$2(value)) {
+            return arrayFrom$1(value);
+        }
+        if (Array.isArray(value)) {
+            return value;
+        }
+        return arrayFrom$1(document.querySelectorAll(value));
+    }
+
+    function setTransitionDuration$1(els, value) {
+        els.forEach(function(el) {
+            if (el) {
+                el.style.transitionDuration = value + "ms";
+            }
+        });
+    }
+
+    function setVisibilityState$1(els, state) {
+        els.forEach(function(el) {
+            if (el) {
+                el.setAttribute("data-state", state);
+            }
+        });
+    }
+
+    function getOwnerDocument$1(elementOrElements) {
+        var _normalizeToArray = normalizeToArray$1(elementOrElements),
+            element2 = _normalizeToArray[0];
+        return element2 ? element2.ownerDocument || document : document;
+    }
+
+    function isCursorOutsideInteractiveBorder$1(popperTreeData, event2) {
+        var clientX = event2.clientX,
+            clientY = event2.clientY;
+        return popperTreeData.every(function(_ref2) {
+            var popperRect = _ref2.popperRect,
+                popperState = _ref2.popperState,
+                props = _ref2.props;
+            var interactiveBorder = props.interactiveBorder;
+            var basePlacement = getBasePlacement$2(popperState.placement);
+            var offsetData = popperState.modifiersData.offset;
+            if (!offsetData) {
+                return true;
+            }
+            var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
+            var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
+            var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
+            var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
+            var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
+            var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
+            var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
+            var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
+            return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
+        });
+    }
+
+    function updateTransitionEndListener$1(box, action, listener2) {
+        var method = action + "EventListener";
+        ["transitionend", "webkitTransitionEnd"].forEach(function(event2) {
+            box[method](event2, listener2);
+        });
+    }
+    var currentInput$1 = {
+        isTouch: false
+    };
+    var lastMouseMoveTime$1 = 0;
+
+    function onDocumentTouchStart$1() {
+        if (currentInput$1.isTouch) {
+            return;
+        }
+        currentInput$1.isTouch = true;
+        if (window.performance) {
+            document.addEventListener("mousemove", onDocumentMouseMove$1);
+        }
+    }
+
+    function onDocumentMouseMove$1() {
+        var now2 = performance.now();
+        if (now2 - lastMouseMoveTime$1 < 20) {
+            currentInput$1.isTouch = false;
+            document.removeEventListener("mousemove", onDocumentMouseMove$1);
+        }
+        lastMouseMoveTime$1 = now2;
+    }
+
+    function onWindowBlur$1() {
+        var activeElement = document.activeElement;
+        if (isReferenceElement$1(activeElement)) {
+            var instance2 = activeElement._tippy;
+            if (activeElement.blur && !instance2.state.isVisible) {
+                activeElement.blur();
+            }
+        }
+    }
+
+    function bindGlobalEventListeners$1() {
+        document.addEventListener("touchstart", onDocumentTouchStart$1, TOUCH_OPTIONS$1);
+        window.addEventListener("blur", onWindowBlur$1);
+    }
+    var isBrowser$3 = typeof window !== "undefined" && typeof document !== "undefined";
+    var ua$1 = isBrowser$3 ? navigator.userAgent : "";
+    var isIE$1 = /MSIE |Trident\//.test(ua$1);
+    var pluginProps$1 = {
+        animateFill: false,
+        followCursor: false,
+        inlinePositioning: false,
+        sticky: false
+    };
+    var renderProps$1 = {
+        allowHTML: false,
+        animation: "fade",
+        arrow: true,
+        content: "",
+        inertia: false,
+        maxWidth: 350,
+        role: "tooltip",
+        theme: "",
+        zIndex: 9999
+    };
+    var defaultProps$6 = Object.assign({
+        appendTo: function appendTo() {
+            return document.body;
+        },
+        aria: {
+            content: "auto",
+            expanded: "auto"
+        },
+        delay: 0,
+        duration: [300, 250],
+        getReferenceClientRect: null,
+        hideOnClick: true,
+        ignoreAttributes: false,
+        interactive: false,
+        interactiveBorder: 2,
+        interactiveDebounce: 0,
+        moveTransition: "",
+        offset: [0, 10],
+        onAfterUpdate: function onAfterUpdate() {},
+        onBeforeUpdate: function onBeforeUpdate() {},
+        onCreate: function onCreate() {},
+        onDestroy: function onDestroy() {},
+        onHidden: function onHidden() {},
+        onHide: function onHide() {},
+        onMount: function onMount() {},
+        onShow: function onShow() {},
+        onShown: function onShown() {},
+        onTrigger: function onTrigger() {},
+        onUntrigger: function onUntrigger() {},
+        onClickOutside: function onClickOutside() {},
+        placement: "top",
+        plugins: [],
+        popperOptions: {},
+        render: null,
+        showOnCreate: false,
+        touch: true,
+        trigger: "mouseenter focus",
+        triggerTarget: null
+    }, pluginProps$1, {}, renderProps$1);
+    var defaultKeys$1 = Object.keys(defaultProps$6);
+    var setDefaultProps$1 = function setDefaultProps2(partialProps) {
+        var keys2 = Object.keys(partialProps);
+        keys2.forEach(function(key) {
+            defaultProps$6[key] = partialProps[key];
+        });
+    };
+
+    function getExtendedPassedProps$1(passedProps) {
+        var plugins2 = passedProps.plugins || [];
+        var pluginProps2 = plugins2.reduce(function(acc, plugin) {
+            var name2 = plugin.name,
+                defaultValue2 = plugin.defaultValue;
+            if (name2) {
+                acc[name2] = passedProps[name2] !== void 0 ? passedProps[name2] : defaultValue2;
+            }
+            return acc;
+        }, {});
+        return Object.assign({}, passedProps, {}, pluginProps2);
+    }
+
+    function getDataAttributeProps$1(reference2, plugins2) {
+        var propKeys = plugins2 ? Object.keys(getExtendedPassedProps$1(Object.assign({}, defaultProps$6, {
+            plugins: plugins2
+        }))) : defaultKeys$1;
+        var props = propKeys.reduce(function(acc, key) {
+            var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
+            if (!valueAsString) {
+                return acc;
+            }
+            if (key === "content") {
+                acc[key] = valueAsString;
+            } else {
+                try {
+                    acc[key] = JSON.parse(valueAsString);
+                } catch (e3) {
+                    acc[key] = valueAsString;
                 }
-            }]), n2;
-        }();
+            }
+            return acc;
+        }, {});
+        return props;
+    }
 
-    function Ct(e3, t2) {
-        for (var r2 = [], n2 = Le$1(e3), o2 = Le$1(t2); !isAfter(n2, o2);)
-            r2.push(_e$1(n2)), n2 = addMonths(n2, 1);
-        return r2;
+    function evaluateProps$1(reference2, props) {
+        var out = Object.assign({}, props, {
+            content: invokeWithArgsOrReturn$1(props.content, [reference2])
+        }, props.ignoreAttributes ? {} : getDataAttributeProps$1(reference2, props.plugins));
+        out.aria = Object.assign({}, defaultProps$6.aria, {}, out.aria);
+        out.aria = {
+            expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
+            content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
+        };
+        return out;
     }
-    var St = onClickOutsideHOC(function(t2) {
-            he$1(o2, React__default.default.Component);
-            var n2 = De(o2);
 
-            function o2(t3) {
-                var r2;
-                return pe$1(this, o2), de$1(ye(r2 = n2.call(this, t3)), "renderOptions", function() {
-                    return r2.state.monthYearsList.map(function(t4) {
-                        var n3 = getTime(t4),
-                            o3 = Ae(r2.props.date, t4) && Be$1(r2.props.date, t4);
-                        return React__default.default.createElement("div", {
-                            className: o3 ? "react-datepicker__month-year-option--selected_month-year" : "react-datepicker__month-year-option",
-                            key: n3,
-                            onClick: r2.onChange.bind(ye(r2), n3),
-                            "aria-selected": o3 ? "true" : void 0
-                        }, o3 ? React__default.default.createElement("span", {
-                            className: "react-datepicker__month-year-option--selected"
-                        }, "\u2713") : "", Ee$1(t4, r2.props.dateFormat, r2.props.locale));
-                    });
-                }), de$1(ye(r2), "onChange", function(e3) {
-                    return r2.props.onChange(e3);
-                }), de$1(ye(r2), "handleClickOutside", function() {
-                    r2.props.onCancel();
-                }), r2.state = {
-                    monthYearsList: Ct(r2.props.minDate, r2.props.maxDate)
-                }, r2;
+    function getChildren$2(popper2) {
+        var box = popper2.firstElementChild;
+        var boxChildren = arrayFrom$1(box.children);
+        return {
+            box,
+            content: boxChildren.find(function(node2) {
+                return node2.classList.contains(CONTENT_CLASS$1);
+            }),
+            arrow: boxChildren.find(function(node2) {
+                return node2.classList.contains(ARROW_CLASS$1) || node2.classList.contains(SVG_ARROW_CLASS$1);
+            }),
+            backdrop: boxChildren.find(function(node2) {
+                return node2.classList.contains(BACKDROP_CLASS$1);
+            })
+        };
+    }
+    var idCounter$2 = 1;
+    var mouseMoveListeners$1 = [];
+    var mountedInstances$1 = [];
+
+    function createTippy$1(reference2, passedProps) {
+        var props = evaluateProps$1(reference2, Object.assign({}, defaultProps$6, {}, getExtendedPassedProps$1(removeUndefinedProps$1(passedProps))));
+        var showTimeout;
+        var hideTimeout;
+        var scheduleHideAnimationFrame;
+        var isVisibleFromClick = false;
+        var didHideDueToDocumentMouseDown = false;
+        var didTouchMove = false;
+        var ignoreOnFirstUpdate = false;
+        var lastTriggerEvent;
+        var currentTransitionEndListener;
+        var onFirstUpdate;
+        var listeners = [];
+        var debouncedOnMouseMove = debounce$4(onMouseMove, props.interactiveDebounce);
+        var currentTarget;
+        var doc2 = getOwnerDocument$1(props.triggerTarget || reference2);
+        var id2 = idCounter$2++;
+        var popperInstance = null;
+        var plugins2 = unique$1(props.plugins);
+        var state = {
+            isEnabled: true,
+            isVisible: false,
+            isDestroyed: false,
+            isMounted: false,
+            isShown: false
+        };
+        var instance2 = {
+            id: id2,
+            reference: reference2,
+            popper: div$1(),
+            popperInstance,
+            props,
+            state,
+            plugins: plugins2,
+            clearDelayTimeouts,
+            setProps,
+            setContent: setContent2,
+            show,
+            hide: hide2,
+            hideWithInteractivity,
+            enable,
+            disable: disable2,
+            unmount,
+            destroy
+        };
+        if (!props.render) {
+            return instance2;
+        }
+        var _props$render = props.render(instance2),
+            popper2 = _props$render.popper,
+            onUpdate = _props$render.onUpdate;
+        popper2.setAttribute("data-tippy-root", "");
+        popper2.id = "tippy-" + instance2.id;
+        instance2.popper = popper2;
+        reference2._tippy = instance2;
+        popper2._tippy = instance2;
+        var pluginsHooks = plugins2.map(function(plugin) {
+            return plugin.fn(instance2);
+        });
+        var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
+        addListeners();
+        handleAriaExpandedAttribute();
+        handleStyles();
+        invokeHook("onCreate", [instance2]);
+        if (props.showOnCreate) {
+            scheduleShow();
+        }
+        popper2.addEventListener("mouseenter", function() {
+            if (instance2.props.interactive && instance2.state.isVisible) {
+                instance2.clearDelayTimeouts();
             }
-            return le$1(o2, [{
-                key: "render",
-                value: function() {
-                    var t3 = r$1({
-                        "react-datepicker__month-year-dropdown": true,
-                        "react-datepicker__month-year-dropdown--scrollable": this.props.scrollableMonthYearDropdown
-                    });
-                    return React__default.default.createElement("div", {
-                        className: t3
-                    }, this.renderOptions());
+        });
+        popper2.addEventListener("mouseleave", function(event2) {
+            if (instance2.props.interactive && instance2.props.trigger.indexOf("mouseenter") >= 0) {
+                doc2.addEventListener("mousemove", debouncedOnMouseMove);
+                debouncedOnMouseMove(event2);
+            }
+        });
+        return instance2;
+
+        function getNormalizedTouchSettings() {
+            var touch = instance2.props.touch;
+            return Array.isArray(touch) ? touch : [touch, 0];
+        }
+
+        function getIsCustomTouchBehavior() {
+            return getNormalizedTouchSettings()[0] === "hold";
+        }
+
+        function getIsDefaultRenderFn() {
+            var _instance$props$rende;
+            return !!((_instance$props$rende = instance2.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
+        }
+
+        function getCurrentTarget() {
+            return currentTarget || reference2;
+        }
+
+        function getDefaultTemplateChildren() {
+            return getChildren$2(popper2);
+        }
+
+        function getDelay(isShow) {
+            if (instance2.state.isMounted && !instance2.state.isVisible || currentInput$1.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
+                return 0;
+            }
+            return getValueAtIndexOrReturn$1(instance2.props.delay, isShow ? 0 : 1, defaultProps$6.delay);
+        }
+
+        function handleStyles() {
+            popper2.style.pointerEvents = instance2.props.interactive && instance2.state.isVisible ? "" : "none";
+            popper2.style.zIndex = "" + instance2.props.zIndex;
+        }
+
+        function invokeHook(hook, args, shouldInvokePropsHook) {
+            if (shouldInvokePropsHook === void 0) {
+                shouldInvokePropsHook = true;
+            }
+            pluginsHooks.forEach(function(pluginHooks) {
+                if (pluginHooks[hook]) {
+                    pluginHooks[hook].apply(void 0, args);
                 }
-            }]), o2;
-        }()),
-        _t$1 = function(t2) {
-            he$1(n2, React__default.default.Component);
-            var r2 = De(n2);
+            });
+            if (shouldInvokePropsHook) {
+                var _instance$props;
+                (_instance$props = instance2.props)[hook].apply(_instance$props, args);
+            }
+        }
 
-            function n2() {
-                var t3;
-                pe$1(this, n2);
-                for (var o2 = arguments.length, a2 = new Array(o2), s2 = 0; s2 < o2; s2++)
-                    a2[s2] = arguments[s2];
-                return de$1(ye(t3 = r2.call.apply(r2, [this].concat(a2))), "state", {
-                    dropdownVisible: false
-                }), de$1(ye(t3), "renderSelectOptions", function() {
-                    for (var r3 = Le$1(t3.props.minDate), n3 = Le$1(t3.props.maxDate), o3 = []; !isAfter(r3, n3);) {
-                        var a3 = getTime(r3);
-                        o3.push(React__default.default.createElement("option", {
-                            key: a3,
-                            value: a3
-                        }, Ee$1(r3, t3.props.dateFormat, t3.props.locale))), r3 = addMonths(r3, 1);
-                    }
-                    return o3;
-                }), de$1(ye(t3), "onSelectChange", function(e3) {
-                    t3.onChange(e3.target.value);
-                }), de$1(ye(t3), "renderSelectMode", function() {
-                    return React__default.default.createElement("select", {
-                        value: getTime(Le$1(t3.props.date)),
-                        className: "react-datepicker__month-year-select",
-                        onChange: t3.onSelectChange
-                    }, t3.renderSelectOptions());
-                }), de$1(ye(t3), "renderReadView", function(r3) {
-                    var n3 = Ee$1(t3.props.date, t3.props.dateFormat, t3.props.locale);
-                    return React__default.default.createElement("div", {
-                        key: "read",
-                        style: {
-                            visibility: r3 ? "visible" : "hidden"
-                        },
-                        className: "react-datepicker__month-year-read-view",
-                        onClick: function(e3) {
-                            return t3.toggleDropdown(e3);
-                        }
-                    }, React__default.default.createElement("span", {
-                        className: "react-datepicker__month-year-read-view--down-arrow"
-                    }), React__default.default.createElement("span", {
-                        className: "react-datepicker__month-year-read-view--selected-month-year"
-                    }, n3));
-                }), de$1(ye(t3), "renderDropdown", function() {
-                    return React__default.default.createElement(St, {
-                        key: "dropdown",
-                        date: t3.props.date,
-                        dateFormat: t3.props.dateFormat,
-                        onChange: t3.onChange,
-                        onCancel: t3.toggleDropdown,
-                        minDate: t3.props.minDate,
-                        maxDate: t3.props.maxDate,
-                        scrollableMonthYearDropdown: t3.props.scrollableMonthYearDropdown,
-                        locale: t3.props.locale
-                    });
-                }), de$1(ye(t3), "renderScrollMode", function() {
-                    var e3 = t3.state.dropdownVisible,
-                        r3 = [t3.renderReadView(!e3)];
-                    return e3 && r3.unshift(t3.renderDropdown()), r3;
-                }), de$1(ye(t3), "onChange", function(e3) {
-                    t3.toggleDropdown();
-                    var r3 = _e$1(parseInt(e3));
-                    Ae(t3.props.date, r3) && Be$1(t3.props.date, r3) || t3.props.onChange(r3);
-                }), de$1(ye(t3), "toggleDropdown", function() {
-                    return t3.setState({
-                        dropdownVisible: !t3.state.dropdownVisible
-                    });
-                }), t3;
+        function handleAriaContentAttribute() {
+            var aria2 = instance2.props.aria;
+            if (!aria2.content) {
+                return;
             }
-            return le$1(n2, [{
-                key: "render",
-                value: function() {
-                    var t3;
-                    switch (this.props.dropdownMode) {
-                        case "scroll":
-                            t3 = this.renderScrollMode();
-                            break;
-                        case "select":
-                            t3 = this.renderSelectMode();
+            var attr = "aria-" + aria2.content;
+            var id3 = popper2.id;
+            var nodes = normalizeToArray$1(instance2.props.triggerTarget || reference2);
+            nodes.forEach(function(node2) {
+                var currentValue = node2.getAttribute(attr);
+                if (instance2.state.isVisible) {
+                    node2.setAttribute(attr, currentValue ? currentValue + " " + id3 : id3);
+                } else {
+                    var nextValue = currentValue && currentValue.replace(id3, "").trim();
+                    if (nextValue) {
+                        node2.setAttribute(attr, nextValue);
+                    } else {
+                        node2.removeAttribute(attr);
                     }
-                    return React__default.default.createElement("div", {
-                        className: "react-datepicker__month-year-dropdown-container react-datepicker__month-year-dropdown-container--".concat(this.props.dropdownMode)
-                    }, t3);
                 }
-            }]), n2;
-        }(),
-        Mt$1 = function(t2) {
-            he$1(o2, React__default.default.Component);
-            var n2 = De(o2);
+            });
+        }
 
-            function o2() {
-                var t3;
-                pe$1(this, o2);
-                for (var a2 = arguments.length, s2 = new Array(a2), i2 = 0; i2 < a2; i2++)
-                    s2[i2] = arguments[i2];
-                return de$1(ye(t3 = n2.call.apply(n2, [this].concat(s2))), "dayEl", React__default.default.createRef()), de$1(ye(t3), "handleClick", function(e3) {
-                    !t3.isDisabled() && t3.props.onClick && t3.props.onClick(e3);
-                }), de$1(ye(t3), "handleMouseEnter", function(e3) {
-                    !t3.isDisabled() && t3.props.onMouseEnter && t3.props.onMouseEnter(e3);
-                }), de$1(ye(t3), "handleOnKeyDown", function(e3) {
-                    " " === e3.key && (e3.preventDefault(), e3.key = "Enter"), t3.props.handleOnKeyDown(e3);
-                }), de$1(ye(t3), "isSameDay", function(e3) {
-                    return We$1(t3.props.day, e3);
-                }), de$1(ye(t3), "isKeyboardSelected", function() {
-                    return !t3.props.disabledKeyboardNavigation && !t3.isSameDay(t3.props.selected) && t3.isSameDay(t3.props.preSelection);
-                }), de$1(ye(t3), "isDisabled", function() {
-                    return Je$1(t3.props.day, t3.props);
-                }), de$1(ye(t3), "isExcluded", function() {
-                    return Xe(t3.props.day, t3.props);
-                }), de$1(ye(t3), "getHighLightedClass", function(e3) {
-                    var r2 = t3.props,
-                        n3 = r2.day,
-                        o3 = r2.highlightDates;
-                    if (!o3)
-                        return false;
-                    var a3 = Ee$1(n3, "MM.dd.yyyy");
-                    return o3.get(a3);
-                }), de$1(ye(t3), "isInRange", function() {
-                    var e3 = t3.props,
-                        r2 = e3.day,
-                        n3 = e3.startDate,
-                        o3 = e3.endDate;
-                    return !(!n3 || !o3) && He$1(r2, n3, o3);
-                }), de$1(ye(t3), "isInSelectingRange", function() {
-                    var e3, r2 = t3.props,
-                        n3 = r2.day,
-                        o3 = r2.selectsStart,
-                        a3 = r2.selectsEnd,
-                        s3 = r2.selectsRange,
-                        i3 = r2.selectsDisabledDaysInRange,
-                        p2 = r2.startDate,
-                        c2 = r2.endDate,
-                        l2 = null !== (e3 = t3.props.selectingDate) && void 0 !== e3 ? e3 : t3.props.preSelection;
-                    return !(!(o3 || a3 || s3) || !l2 || !i3 && t3.isDisabled()) && (o3 && c2 && (isBefore(l2, c2) || je$1(l2, c2)) ? He$1(n3, l2, c2) : (a3 && p2 && (isAfter(l2, p2) || je$1(l2, p2)) || !(!s3 || !p2 || c2 || !isAfter(l2, p2) && !je$1(l2, p2))) && He$1(n3, p2, l2));
-                }), de$1(ye(t3), "isSelectingRangeStart", function() {
-                    var e3;
-                    if (!t3.isInSelectingRange())
-                        return false;
-                    var r2 = t3.props,
-                        n3 = r2.day,
-                        o3 = r2.startDate,
-                        a3 = r2.selectsStart,
-                        s3 = null !== (e3 = t3.props.selectingDate) && void 0 !== e3 ? e3 : t3.props.preSelection;
-                    return We$1(n3, a3 ? s3 : o3);
-                }), de$1(ye(t3), "isSelectingRangeEnd", function() {
-                    var e3;
-                    if (!t3.isInSelectingRange())
-                        return false;
-                    var r2 = t3.props,
-                        n3 = r2.day,
-                        o3 = r2.endDate,
-                        a3 = r2.selectsEnd,
-                        s3 = null !== (e3 = t3.props.selectingDate) && void 0 !== e3 ? e3 : t3.props.preSelection;
-                    return We$1(n3, a3 ? s3 : o3);
-                }), de$1(ye(t3), "isRangeStart", function() {
-                    var e3 = t3.props,
-                        r2 = e3.day,
-                        n3 = e3.startDate,
-                        o3 = e3.endDate;
-                    return !(!n3 || !o3) && We$1(n3, r2);
-                }), de$1(ye(t3), "isRangeEnd", function() {
-                    var e3 = t3.props,
-                        r2 = e3.day,
-                        n3 = e3.startDate,
-                        o3 = e3.endDate;
-                    return !(!n3 || !o3) && We$1(o3, r2);
-                }), de$1(ye(t3), "isWeekend", function() {
-                    var e3 = getDay(t3.props.day);
-                    return 0 === e3 || 6 === e3;
-                }), de$1(ye(t3), "isAfterMonth", function() {
-                    return void 0 !== t3.props.month && (t3.props.month + 1) % 12 === getMonth(t3.props.day);
-                }), de$1(ye(t3), "isBeforeMonth", function() {
-                    return void 0 !== t3.props.month && (getMonth(t3.props.day) + 1) % 12 === t3.props.month;
-                }), de$1(ye(t3), "isCurrentDay", function() {
-                    return t3.isSameDay(_e$1());
-                }), de$1(ye(t3), "isSelected", function() {
-                    return t3.isSameDay(t3.props.selected);
-                }), de$1(ye(t3), "getClassNames", function(e3) {
-                    var n3 = t3.props.dayClassName ? t3.props.dayClassName(e3) : void 0;
-                    return r$1("react-datepicker__day", n3, "react-datepicker__day--" + Oe$1(t3.props.day), {
-                        "react-datepicker__day--disabled": t3.isDisabled(),
-                        "react-datepicker__day--excluded": t3.isExcluded(),
-                        "react-datepicker__day--selected": t3.isSelected(),
-                        "react-datepicker__day--keyboard-selected": t3.isKeyboardSelected(),
-                        "react-datepicker__day--range-start": t3.isRangeStart(),
-                        "react-datepicker__day--range-end": t3.isRangeEnd(),
-                        "react-datepicker__day--in-range": t3.isInRange(),
-                        "react-datepicker__day--in-selecting-range": t3.isInSelectingRange(),
-                        "react-datepicker__day--selecting-range-start": t3.isSelectingRangeStart(),
-                        "react-datepicker__day--selecting-range-end": t3.isSelectingRangeEnd(),
-                        "react-datepicker__day--today": t3.isCurrentDay(),
-                        "react-datepicker__day--weekend": t3.isWeekend(),
-                        "react-datepicker__day--outside-month": t3.isAfterMonth() || t3.isBeforeMonth()
-                    }, t3.getHighLightedClass("react-datepicker__day--highlighted"));
-                }), de$1(ye(t3), "getAriaLabel", function() {
-                    var e3 = t3.props,
-                        r2 = e3.day,
-                        n3 = e3.ariaLabelPrefixWhenEnabled,
-                        o3 = void 0 === n3 ? "Choose" : n3,
-                        a3 = e3.ariaLabelPrefixWhenDisabled,
-                        s3 = void 0 === a3 ? "Not available" : a3,
-                        i3 = t3.isDisabled() || t3.isExcluded() ? s3 : o3;
-                    return "".concat(i3, " ").concat(Ee$1(r2, "PPPP", t3.props.locale));
-                }), de$1(ye(t3), "getTabIndex", function(e3, r2) {
-                    var n3 = e3 || t3.props.selected,
-                        o3 = r2 || t3.props.preSelection;
-                    return t3.isKeyboardSelected() || t3.isSameDay(n3) && We$1(o3, n3) ? 0 : -1;
-                }), de$1(ye(t3), "handleFocusDay", function() {
-                    var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
-                        r2 = false;
-                    0 === t3.getTabIndex() && !e3.isInputFocused && t3.isSameDay(t3.props.preSelection) && (document.activeElement && document.activeElement !== document.body || (r2 = true), t3.props.inline && !t3.props.shouldFocusDayInline && (r2 = false), t3.props.containerRef && t3.props.containerRef.current && t3.props.containerRef.current.contains(document.activeElement) && document.activeElement.classList.contains("react-datepicker__day") && (r2 = true)), r2 && t3.dayEl.current.focus({
-                        preventScroll: true
-                    });
-                }), de$1(ye(t3), "renderDayContents", function() {
-                    return t3.props.monthShowsDuplicateDaysEnd && t3.isAfterMonth() || t3.props.monthShowsDuplicateDaysStart && t3.isBeforeMonth() ? null : t3.props.renderDayContents ? t3.props.renderDayContents(getDate(t3.props.day), t3.props.day) : getDate(t3.props.day);
-                }), de$1(ye(t3), "render", function() {
-                    return React__default.default.createElement("div", {
-                        ref: t3.dayEl,
-                        className: t3.getClassNames(t3.props.day),
-                        onKeyDown: t3.handleOnKeyDown,
-                        onClick: t3.handleClick,
-                        onMouseEnter: t3.handleMouseEnter,
-                        tabIndex: t3.getTabIndex(),
-                        "aria-label": t3.getAriaLabel(),
-                        role: "option",
-                        "aria-disabled": t3.isDisabled(),
-                        "aria-current": t3.isCurrentDay() ? "date" : void 0,
-                        "aria-selected": t3.isSelected()
-                    }, t3.renderDayContents());
-                }), t3;
+        function handleAriaExpandedAttribute() {
+            if (hasAriaExpanded || !instance2.props.aria.expanded) {
+                return;
             }
-            return le$1(o2, [{
-                key: "componentDidMount",
-                value: function() {
-                    this.handleFocusDay();
-                }
-            }, {
-                key: "componentDidUpdate",
-                value: function(e3) {
-                    this.handleFocusDay(e3);
+            var nodes = normalizeToArray$1(instance2.props.triggerTarget || reference2);
+            nodes.forEach(function(node2) {
+                if (instance2.props.interactive) {
+                    node2.setAttribute("aria-expanded", instance2.state.isVisible && node2 === getCurrentTarget() ? "true" : "false");
+                } else {
+                    node2.removeAttribute("aria-expanded");
                 }
-            }]), o2;
-        }(),
-        Pt$1 = function(t2) {
-            he$1(o2, React__default.default.Component);
-            var n2 = De(o2);
+            });
+        }
 
-            function o2() {
-                var e3;
-                pe$1(this, o2);
-                for (var t3 = arguments.length, r2 = new Array(t3), a2 = 0; a2 < t3; a2++)
-                    r2[a2] = arguments[a2];
-                return de$1(ye(e3 = n2.call.apply(n2, [this].concat(r2))), "handleClick", function(t4) {
-                    e3.props.onClick && e3.props.onClick(t4);
-                }), e3;
+        function cleanupInteractiveMouseListeners() {
+            doc2.removeEventListener("mousemove", debouncedOnMouseMove);
+            mouseMoveListeners$1 = mouseMoveListeners$1.filter(function(listener2) {
+                return listener2 !== debouncedOnMouseMove;
+            });
+        }
+
+        function onDocumentPress(event2) {
+            if (currentInput$1.isTouch) {
+                if (didTouchMove || event2.type === "mousedown") {
+                    return;
+                }
             }
-            return le$1(o2, [{
-                key: "render",
-                value: function() {
-                    var t3 = this.props,
-                        n3 = t3.weekNumber,
-                        o3 = t3.ariaLabelPrefix,
-                        a2 = void 0 === o3 ? "week " : o3,
-                        s2 = {
-                            "react-datepicker__week-number": true,
-                            "react-datepicker__week-number--clickable": !!t3.onClick
-                        };
-                    return React__default.default.createElement("div", {
-                        className: r$1(s2),
-                        "aria-label": "".concat(a2, " ").concat(this.props.weekNumber),
-                        onClick: this.handleClick
-                    }, n3);
+            if (instance2.props.interactive && popper2.contains(event2.target)) {
+                return;
+            }
+            if (getCurrentTarget().contains(event2.target)) {
+                if (currentInput$1.isTouch) {
+                    return;
                 }
-            }]), o2;
-        }(),
-        Et$1 = function(t2) {
-            he$1(n2, React__default.default.Component);
-            var r2 = De(n2);
+                if (instance2.state.isVisible && instance2.props.trigger.indexOf("click") >= 0) {
+                    return;
+                }
+            } else {
+                invokeHook("onClickOutside", [instance2, event2]);
+            }
+            if (instance2.props.hideOnClick === true) {
+                instance2.clearDelayTimeouts();
+                instance2.hide();
+                didHideDueToDocumentMouseDown = true;
+                setTimeout(function() {
+                    didHideDueToDocumentMouseDown = false;
+                });
+                if (!instance2.state.isMounted) {
+                    removeDocumentPress();
+                }
+            }
+        }
 
-            function n2() {
-                var t3;
-                pe$1(this, n2);
-                for (var o2 = arguments.length, a2 = new Array(o2), s2 = 0; s2 < o2; s2++)
-                    a2[s2] = arguments[s2];
-                return de$1(ye(t3 = r2.call.apply(r2, [this].concat(a2))), "handleDayClick", function(e3, r3) {
-                    t3.props.onDayClick && t3.props.onDayClick(e3, r3);
-                }), de$1(ye(t3), "handleDayMouseEnter", function(e3) {
-                    t3.props.onDayMouseEnter && t3.props.onDayMouseEnter(e3);
-                }), de$1(ye(t3), "handleWeekClick", function(e3, r3, n3) {
-                    "function" == typeof t3.props.onWeekSelect && t3.props.onWeekSelect(e3, r3, n3), t3.props.shouldCloseOnSelect && t3.props.setOpen(false);
-                }), de$1(ye(t3), "formatWeekNumber", function(e3) {
-                    return t3.props.formatWeekNumber ? t3.props.formatWeekNumber(e3) : Ye$1(e3);
-                }), de$1(ye(t3), "renderDays", function() {
-                    var r3 = Te(t3.props.day, t3.props.locale, t3.props.calendarStartDay),
-                        n3 = [],
-                        o3 = t3.formatWeekNumber(r3);
-                    if (t3.props.showWeekNumber) {
-                        var a3 = t3.props.onWeekSelect ? t3.handleWeekClick.bind(ye(t3), r3, o3) : void 0;
-                        n3.push(React__default.default.createElement(Pt$1, {
-                            key: "W",
-                            weekNumber: o3,
-                            onClick: a3,
-                            ariaLabelPrefix: t3.props.ariaLabelPrefix
-                        }));
-                    }
-                    return n3.concat([0, 1, 2, 3, 4, 5, 6].map(function(n4) {
-                        var o4 = addDays(r3, n4);
-                        return React__default.default.createElement(Mt$1, {
-                            ariaLabelPrefixWhenEnabled: t3.props.chooseDayAriaLabelPrefix,
-                            ariaLabelPrefixWhenDisabled: t3.props.disabledDayAriaLabelPrefix,
-                            key: o4.valueOf(),
-                            day: o4,
-                            month: t3.props.month,
-                            onClick: t3.handleDayClick.bind(ye(t3), o4),
-                            onMouseEnter: t3.handleDayMouseEnter.bind(ye(t3), o4),
-                            minDate: t3.props.minDate,
-                            maxDate: t3.props.maxDate,
-                            excludeDates: t3.props.excludeDates,
-                            excludeDateIntervals: t3.props.excludeDateIntervals,
-                            includeDates: t3.props.includeDates,
-                            includeDateIntervals: t3.props.includeDateIntervals,
-                            highlightDates: t3.props.highlightDates,
-                            selectingDate: t3.props.selectingDate,
-                            filterDate: t3.props.filterDate,
-                            preSelection: t3.props.preSelection,
-                            selected: t3.props.selected,
-                            selectsStart: t3.props.selectsStart,
-                            selectsEnd: t3.props.selectsEnd,
-                            selectsRange: t3.props.selectsRange,
-                            selectsDisabledDaysInRange: t3.props.selectsDisabledDaysInRange,
-                            startDate: t3.props.startDate,
-                            endDate: t3.props.endDate,
-                            dayClassName: t3.props.dayClassName,
-                            renderDayContents: t3.props.renderDayContents,
-                            disabledKeyboardNavigation: t3.props.disabledKeyboardNavigation,
-                            handleOnKeyDown: t3.props.handleOnKeyDown,
-                            isInputFocused: t3.props.isInputFocused,
-                            containerRef: t3.props.containerRef,
-                            inline: t3.props.inline,
-                            shouldFocusDayInline: t3.props.shouldFocusDayInline,
-                            monthShowsDuplicateDaysEnd: t3.props.monthShowsDuplicateDaysEnd,
-                            monthShowsDuplicateDaysStart: t3.props.monthShowsDuplicateDaysStart,
-                            locale: t3.props.locale
-                        });
-                    }));
-                }), t3;
+        function onTouchMove() {
+            didTouchMove = true;
+        }
+
+        function onTouchStart() {
+            didTouchMove = false;
+        }
+
+        function addDocumentPress() {
+            doc2.addEventListener("mousedown", onDocumentPress, true);
+            doc2.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS$1);
+            doc2.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS$1);
+            doc2.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS$1);
+        }
+
+        function removeDocumentPress() {
+            doc2.removeEventListener("mousedown", onDocumentPress, true);
+            doc2.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS$1);
+            doc2.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS$1);
+            doc2.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS$1);
+        }
+
+        function onTransitionedOut(duration, callback) {
+            onTransitionEnd(duration, function() {
+                if (!instance2.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
+                    callback();
+                }
+            });
+        }
+
+        function onTransitionedIn(duration, callback) {
+            onTransitionEnd(duration, callback);
+        }
+
+        function onTransitionEnd(duration, callback) {
+            var box = getDefaultTemplateChildren().box;
+
+            function listener2(event2) {
+                if (event2.target === box) {
+                    updateTransitionEndListener$1(box, "remove", listener2);
+                    callback();
+                }
             }
-            return le$1(n2, [{
-                key: "render",
-                value: function() {
-                    return React__default.default.createElement("div", {
-                        className: "react-datepicker__week"
-                    }, this.renderDays());
+            if (duration === 0) {
+                return callback();
+            }
+            updateTransitionEndListener$1(box, "remove", currentTransitionEndListener);
+            updateTransitionEndListener$1(box, "add", listener2);
+            currentTransitionEndListener = listener2;
+        }
+
+        function on(eventType, handler, options) {
+            if (options === void 0) {
+                options = false;
+            }
+            var nodes = normalizeToArray$1(instance2.props.triggerTarget || reference2);
+            nodes.forEach(function(node2) {
+                node2.addEventListener(eventType, handler, options);
+                listeners.push({
+                    node: node2,
+                    eventType,
+                    handler,
+                    options
+                });
+            });
+        }
+
+        function addListeners() {
+            if (getIsCustomTouchBehavior()) {
+                on("touchstart", onTrigger, {
+                    passive: true
+                });
+                on("touchend", onMouseLeave, {
+                    passive: true
+                });
+            }
+            splitBySpaces$1(instance2.props.trigger).forEach(function(eventType) {
+                if (eventType === "manual") {
+                    return;
                 }
-            }], [{
-                key: "defaultProps",
-                get: function() {
+                on(eventType, onTrigger);
+                switch (eventType) {
+                    case "mouseenter":
+                        on("mouseleave", onMouseLeave);
+                        break;
+                    case "focus":
+                        on(isIE$1 ? "focusout" : "blur", onBlurOrFocusOut);
+                        break;
+                    case "focusin":
+                        on("focusout", onBlurOrFocusOut);
+                        break;
+                }
+            });
+        }
+
+        function removeListeners() {
+            listeners.forEach(function(_ref2) {
+                var node2 = _ref2.node,
+                    eventType = _ref2.eventType,
+                    handler = _ref2.handler,
+                    options = _ref2.options;
+                node2.removeEventListener(eventType, handler, options);
+            });
+            listeners = [];
+        }
+
+        function onTrigger(event2) {
+            var _lastTriggerEvent;
+            var shouldScheduleClickHide = false;
+            if (!instance2.state.isEnabled || isEventListenerStopped(event2) || didHideDueToDocumentMouseDown) {
+                return;
+            }
+            var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
+            lastTriggerEvent = event2;
+            currentTarget = event2.currentTarget;
+            handleAriaExpandedAttribute();
+            if (!instance2.state.isVisible && isMouseEvent$1(event2)) {
+                mouseMoveListeners$1.forEach(function(listener2) {
+                    return listener2(event2);
+                });
+            }
+            if (event2.type === "click" && (instance2.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance2.props.hideOnClick !== false && instance2.state.isVisible) {
+                shouldScheduleClickHide = true;
+            } else {
+                scheduleShow(event2);
+            }
+            if (event2.type === "click") {
+                isVisibleFromClick = !shouldScheduleClickHide;
+            }
+            if (shouldScheduleClickHide && !wasFocused) {
+                scheduleHide(event2);
+            }
+        }
+
+        function onMouseMove(event2) {
+            var target = event2.target;
+            var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
+            if (event2.type === "mousemove" && isCursorOverReferenceOrPopper) {
+                return;
+            }
+            var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
+                var _instance$popperInsta;
+                var instance3 = popper3._tippy;
+                var state2 = (_instance$popperInsta = instance3.popperInstance) == null ? void 0 : _instance$popperInsta.state;
+                if (state2) {
                     return {
-                        shouldCloseOnSelect: true
+                        popperRect: popper3.getBoundingClientRect(),
+                        popperState: state2,
+                        props
                     };
                 }
-            }]), n2;
-        }(),
-        Nt = function(t2) {
-            he$1(o2, React__default.default.Component);
-            var n2 = De(o2);
+                return null;
+            }).filter(Boolean);
+            if (isCursorOutsideInteractiveBorder$1(popperTreeData, event2)) {
+                cleanupInteractiveMouseListeners();
+                scheduleHide(event2);
+            }
+        }
 
-            function o2() {
-                var t3;
-                pe$1(this, o2);
-                for (var a2 = arguments.length, s2 = new Array(a2), i2 = 0; i2 < a2; i2++)
-                    s2[i2] = arguments[i2];
-                return de$1(ye(t3 = n2.call.apply(n2, [this].concat(s2))), "MONTH_REFS", we$1(Array(12)).map(function() {
-                    return React__default.default.createRef();
-                })), de$1(ye(t3), "isDisabled", function(e3) {
-                    return Je$1(e3, t3.props);
-                }), de$1(ye(t3), "isExcluded", function(e3) {
-                    return Xe(e3, t3.props);
-                }), de$1(ye(t3), "handleDayClick", function(e3, r2) {
-                    t3.props.onDayClick && t3.props.onDayClick(e3, r2, t3.props.orderInDisplay);
-                }), de$1(ye(t3), "handleDayMouseEnter", function(e3) {
-                    t3.props.onDayMouseEnter && t3.props.onDayMouseEnter(e3);
-                }), de$1(ye(t3), "handleMouseLeave", function() {
-                    t3.props.onMouseLeave && t3.props.onMouseLeave();
-                }), de$1(ye(t3), "isRangeStartMonth", function(e3) {
-                    var r2 = t3.props,
-                        n3 = r2.day,
-                        o3 = r2.startDate,
-                        a3 = r2.endDate;
-                    return !(!o3 || !a3) && Be$1(setMonth(n3, e3), o3);
-                }), de$1(ye(t3), "isRangeStartQuarter", function(e3) {
-                    var r2 = t3.props,
-                        n3 = r2.day,
-                        o3 = r2.startDate,
-                        a3 = r2.endDate;
-                    return !(!o3 || !a3) && Ke$1(setQuarter(n3, e3), o3);
-                }), de$1(ye(t3), "isRangeEndMonth", function(e3) {
-                    var r2 = t3.props,
-                        n3 = r2.day,
-                        o3 = r2.startDate,
-                        a3 = r2.endDate;
-                    return !(!o3 || !a3) && Be$1(setMonth(n3, e3), a3);
-                }), de$1(ye(t3), "isRangeEndQuarter", function(e3) {
-                    var r2 = t3.props,
-                        n3 = r2.day,
-                        o3 = r2.startDate,
-                        a3 = r2.endDate;
-                    return !(!o3 || !a3) && Ke$1(setQuarter(n3, e3), a3);
-                }), de$1(ye(t3), "isWeekInMonth", function(e3) {
-                    var r2 = t3.props.day,
-                        n3 = addDays(e3, 6);
-                    return Be$1(e3, r2) || Be$1(n3, r2);
-                }), de$1(ye(t3), "isCurrentMonth", function(e3, t4) {
-                    return getYear(e3) === getYear(_e$1()) && t4 === getMonth(_e$1());
-                }), de$1(ye(t3), "isSelectedMonth", function(e3, t4, r2) {
-                    return getMonth(e3) === t4 && getYear(e3) === getYear(r2);
-                }), de$1(ye(t3), "isSelectedQuarter", function(e3, t4, r2) {
-                    return getQuarter(e3) === t4 && getYear(e3) === getYear(r2);
-                }), de$1(ye(t3), "renderWeeks", function() {
-                    for (var r2 = [], n3 = t3.props.fixedHeight, o3 = 0, a3 = false, s3 = Te(Le$1(t3.props.day), t3.props.locale, t3.props.calendarStartDay); r2.push(React__default.default.createElement(Et$1, {
-                            ariaLabelPrefix: t3.props.weekAriaLabelPrefix,
-                            chooseDayAriaLabelPrefix: t3.props.chooseDayAriaLabelPrefix,
-                            disabledDayAriaLabelPrefix: t3.props.disabledDayAriaLabelPrefix,
-                            key: o3,
-                            day: s3,
-                            month: getMonth(t3.props.day),
-                            onDayClick: t3.handleDayClick,
-                            onDayMouseEnter: t3.handleDayMouseEnter,
-                            onWeekSelect: t3.props.onWeekSelect,
-                            formatWeekNumber: t3.props.formatWeekNumber,
-                            locale: t3.props.locale,
-                            minDate: t3.props.minDate,
-                            maxDate: t3.props.maxDate,
-                            excludeDates: t3.props.excludeDates,
-                            excludeDateIntervals: t3.props.excludeDateIntervals,
-                            includeDates: t3.props.includeDates,
-                            includeDateIntervals: t3.props.includeDateIntervals,
-                            inline: t3.props.inline,
-                            shouldFocusDayInline: t3.props.shouldFocusDayInline,
-                            highlightDates: t3.props.highlightDates,
-                            selectingDate: t3.props.selectingDate,
-                            filterDate: t3.props.filterDate,
-                            preSelection: t3.props.preSelection,
-                            selected: t3.props.selected,
-                            selectsStart: t3.props.selectsStart,
-                            selectsEnd: t3.props.selectsEnd,
-                            selectsRange: t3.props.selectsRange,
-                            selectsDisabledDaysInRange: t3.props.selectsDisabledDaysInRange,
-                            showWeekNumber: t3.props.showWeekNumbers,
-                            startDate: t3.props.startDate,
-                            endDate: t3.props.endDate,
-                            dayClassName: t3.props.dayClassName,
-                            setOpen: t3.props.setOpen,
-                            shouldCloseOnSelect: t3.props.shouldCloseOnSelect,
-                            disabledKeyboardNavigation: t3.props.disabledKeyboardNavigation,
-                            renderDayContents: t3.props.renderDayContents,
-                            handleOnKeyDown: t3.props.handleOnKeyDown,
-                            isInputFocused: t3.props.isInputFocused,
-                            containerRef: t3.props.containerRef,
-                            calendarStartDay: t3.props.calendarStartDay,
-                            monthShowsDuplicateDaysEnd: t3.props.monthShowsDuplicateDaysEnd,
-                            monthShowsDuplicateDaysStart: t3.props.monthShowsDuplicateDaysStart
-                        })), !a3;) {
-                        o3++, s3 = addWeeks(s3, 1);
-                        var i3 = n3 && o3 >= 6,
-                            p2 = !n3 && !t3.isWeekInMonth(s3);
-                        if (i3 || p2) {
-                            if (!t3.props.peekNextMonth)
-                                break;
-                            a3 = true;
-                        }
-                    }
-                    return r2;
-                }), de$1(ye(t3), "onMonthClick", function(e3, r2) {
-                    t3.handleDayClick(Le$1(setMonth(t3.props.day, r2)), e3);
-                }), de$1(ye(t3), "handleMonthNavigation", function(e3, r2) {
-                    t3.isDisabled(r2) || t3.isExcluded(r2) || (t3.props.setPreSelection(r2), t3.MONTH_REFS[e3].current && t3.MONTH_REFS[e3].current.focus());
-                }), de$1(ye(t3), "onMonthKeyDown", function(e3, r2) {
-                    var n3 = e3.key;
-                    if (!t3.props.disabledKeyboardNavigation)
-                        switch (n3) {
-                            case "Enter":
-                                t3.onMonthClick(e3, r2), t3.props.setPreSelection(t3.props.selected);
-                                break;
-                            case "ArrowRight":
-                                t3.handleMonthNavigation(11 === r2 ? 0 : r2 + 1, addMonths(t3.props.preSelection, 1));
-                                break;
-                            case "ArrowLeft":
-                                t3.handleMonthNavigation(0 === r2 ? 11 : r2 - 1, subMonths(t3.props.preSelection, 1));
-                        }
-                }), de$1(ye(t3), "onQuarterClick", function(e3, r2) {
-                    t3.handleDayClick(Fe$1(setQuarter(t3.props.day, r2)), e3);
-                }), de$1(ye(t3), "getMonthClassNames", function(e3) {
-                    var n3 = t3.props,
-                        o3 = n3.day,
-                        a3 = n3.startDate,
-                        s3 = n3.endDate,
-                        i3 = n3.selected,
-                        p2 = n3.minDate,
-                        c2 = n3.maxDate,
-                        l2 = n3.preSelection,
-                        d2 = n3.monthClassName,
-                        u2 = d2 ? d2(o3) : void 0;
-                    return r$1("react-datepicker__month-text", "react-datepicker__month-".concat(e3), u2, {
-                        "react-datepicker__month--disabled": (p2 || c2) && Ze$1(setMonth(o3, e3), t3.props),
-                        "react-datepicker__month--selected": t3.isSelectedMonth(o3, e3, i3),
-                        "react-datepicker__month-text--keyboard-selected": getMonth(l2) === e3,
-                        "react-datepicker__month--in-range": et$1(a3, s3, e3, o3),
-                        "react-datepicker__month--range-start": t3.isRangeStartMonth(e3),
-                        "react-datepicker__month--range-end": t3.isRangeEndMonth(e3),
-                        "react-datepicker__month-text--today": t3.isCurrentMonth(o3, e3)
-                    });
-                }), de$1(ye(t3), "getTabIndex", function(e3) {
-                    var r2 = getMonth(t3.props.preSelection);
-                    return t3.props.disabledKeyboardNavigation || e3 !== r2 ? "-1" : "0";
-                }), de$1(ye(t3), "getAriaLabel", function(e3) {
-                    var r2 = t3.props,
-                        n3 = r2.chooseDayAriaLabelPrefix,
-                        o3 = void 0 === n3 ? "Choose" : n3,
-                        a3 = r2.disabledDayAriaLabelPrefix,
-                        s3 = void 0 === a3 ? "Not available" : a3,
-                        i3 = r2.day,
-                        p2 = setMonth(i3, e3),
-                        c2 = t3.isDisabled(p2) || t3.isExcluded(p2) ? s3 : o3;
-                    return "".concat(c2, " ").concat(Ee$1(p2, "MMMM yyyy"));
-                }), de$1(ye(t3), "getQuarterClassNames", function(e3) {
-                    var n3 = t3.props,
-                        o3 = n3.day,
-                        a3 = n3.startDate,
-                        s3 = n3.endDate,
-                        i3 = n3.selected,
-                        p2 = n3.minDate,
-                        c2 = n3.maxDate;
-                    return r$1("react-datepicker__quarter-text", "react-datepicker__quarter-".concat(e3), {
-                        "react-datepicker__quarter--disabled": (p2 || c2) && tt$1(setQuarter(o3, e3), t3.props),
-                        "react-datepicker__quarter--selected": t3.isSelectedQuarter(o3, e3, i3),
-                        "react-datepicker__quarter--in-range": nt(a3, s3, e3, o3),
-                        "react-datepicker__quarter--range-start": t3.isRangeStartQuarter(e3),
-                        "react-datepicker__quarter--range-end": t3.isRangeEndQuarter(e3)
-                    });
-                }), de$1(ye(t3), "renderMonths", function() {
-                    var r2 = t3.props,
-                        n3 = r2.showFullMonthYearPicker,
-                        o3 = r2.showTwoColumnMonthYearPicker,
-                        a3 = r2.showFourColumnMonthYearPicker,
-                        s3 = r2.locale,
-                        i3 = r2.day,
-                        p2 = r2.selected;
-                    return (a3 ? [
-                        [0, 1, 2, 3],
-                        [4, 5, 6, 7],
-                        [8, 9, 10, 11]
-                    ] : o3 ? [
-                        [0, 1],
-                        [2, 3],
-                        [4, 5],
-                        [6, 7],
-                        [8, 9],
-                        [10, 11]
-                    ] : [
-                        [0, 1, 2],
-                        [3, 4, 5],
-                        [6, 7, 8],
-                        [9, 10, 11]
-                    ]).map(function(r3, o4) {
-                        return React__default.default.createElement("div", {
-                            className: "react-datepicker__month-wrapper",
-                            key: o4
-                        }, r3.map(function(r4, o5) {
-                            return React__default.default.createElement("div", {
-                                ref: t3.MONTH_REFS[r4],
-                                key: o5,
-                                onClick: function(e3) {
-                                    t3.onMonthClick(e3, r4);
-                                },
-                                onKeyDown: function(e3) {
-                                    t3.onMonthKeyDown(e3, r4);
-                                },
-                                tabIndex: t3.getTabIndex(r4),
-                                className: t3.getMonthClassNames(r4),
-                                role: "option",
-                                "aria-label": t3.getAriaLabel(r4),
-                                "aria-current": t3.isCurrentMonth(i3, r4) ? "date" : void 0,
-                                "aria-selected": t3.isSelectedMonth(i3, r4, p2)
-                            }, n3 ? $e$1(r4, s3) : ze$1(r4, s3));
-                        }));
-                    });
-                }), de$1(ye(t3), "renderQuarters", function() {
-                    var r2 = t3.props,
-                        n3 = r2.day,
-                        o3 = r2.selected;
-                    return React__default.default.createElement("div", {
-                        className: "react-datepicker__quarter-wrapper"
-                    }, [1, 2, 3, 4].map(function(r3, a3) {
-                        return React__default.default.createElement("div", {
-                            key: a3,
-                            role: "option",
-                            onClick: function(e3) {
-                                t3.onQuarterClick(e3, r3);
-                            },
-                            className: t3.getQuarterClassNames(r3),
-                            "aria-selected": t3.isSelectedQuarter(n3, r3, o3)
-                        }, Ge$1(r3, t3.props.locale));
-                    }));
-                }), de$1(ye(t3), "getClassNames", function() {
-                    var e3 = t3.props;
-                    e3.day;
-                    var n3 = e3.selectingDate,
-                        o3 = e3.selectsStart,
-                        a3 = e3.selectsEnd,
-                        s3 = e3.showMonthYearPicker,
-                        i3 = e3.showQuarterYearPicker;
-                    return r$1("react-datepicker__month", {
-                        "react-datepicker__month--selecting-range": n3 && (o3 || a3)
-                    }, {
-                        "react-datepicker__monthPicker": s3
-                    }, {
-                        "react-datepicker__quarterPicker": i3
-                    });
-                }), t3;
+        function onMouseLeave(event2) {
+            var shouldBail = isEventListenerStopped(event2) || instance2.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
+            if (shouldBail) {
+                return;
             }
-            return le$1(o2, [{
-                key: "render",
-                value: function() {
-                    var t3 = this.props,
-                        r2 = t3.showMonthYearPicker,
-                        n3 = t3.showQuarterYearPicker,
-                        o3 = t3.day,
-                        a2 = t3.ariaLabelPrefix,
-                        s2 = void 0 === a2 ? "month " : a2;
-                    return React__default.default.createElement("div", {
-                        className: this.getClassNames(),
-                        onMouseLeave: this.handleMouseLeave,
-                        "aria-label": "".concat(s2, " ").concat(Ee$1(o3, "yyyy-MM")),
-                        role: "listbox"
-                    }, r2 ? this.renderMonths() : n3 ? this.renderQuarters() : this.renderWeeks());
-                }
-            }]), o2;
-        }(),
-        xt = function(t2) {
-            he$1(n2, React__default.default.Component);
-            var r2 = De(n2);
+            if (instance2.props.interactive) {
+                instance2.hideWithInteractivity(event2);
+                return;
+            }
+            scheduleHide(event2);
+        }
 
-            function n2() {
-                var t3;
-                pe$1(this, n2);
-                for (var o2 = arguments.length, a2 = new Array(o2), i2 = 0; i2 < o2; i2++)
-                    a2[i2] = arguments[i2];
-                return de$1(ye(t3 = r2.call.apply(r2, [this].concat(a2))), "state", {
-                    height: null
-                }), de$1(ye(t3), "handleClick", function(e3) {
-                    (t3.props.minTime || t3.props.maxTime) && it(e3, t3.props) || (t3.props.excludeTimes || t3.props.includeTimes || t3.props.filterTime) && st$1(e3, t3.props) || t3.props.onChange(e3);
-                }), de$1(ye(t3), "isSelectedTime", function(e3, r3, n3) {
-                    return t3.props.selected && r3 === getHours(e3) && n3 === getMinutes(e3);
-                }), de$1(ye(t3), "liClasses", function(e3, r3, n3) {
-                    var o3 = ["react-datepicker__time-list-item", t3.props.timeClassName ? t3.props.timeClassName(e3, r3, n3) : void 0];
-                    return t3.isSelectedTime(e3, r3, n3) && o3.push("react-datepicker__time-list-item--selected"), ((t3.props.minTime || t3.props.maxTime) && it(e3, t3.props) || (t3.props.excludeTimes || t3.props.includeTimes || t3.props.filterTime) && st$1(e3, t3.props)) && o3.push("react-datepicker__time-list-item--disabled"), t3.props.injectTimes && (60 * getHours(e3) + getMinutes(e3)) % t3.props.intervals != 0 && o3.push("react-datepicker__time-list-item--injected"), o3.join(" ");
-                }), de$1(ye(t3), "handleOnKeyDown", function(e3, r3) {
-                    " " === e3.key && (e3.preventDefault(), e3.key = "Enter"), "Enter" === e3.key && t3.handleClick(r3), t3.props.handleOnKeyDown(e3);
-                }), de$1(ye(t3), "renderTimes", function() {
-                    for (var r3 = [], n3 = t3.props.format ? t3.props.format : "p", o3 = t3.props.intervals, a3 = Ie$1(_e$1(t3.props.selected)), i3 = 1440 / o3, p2 = t3.props.injectTimes && t3.props.injectTimes.sort(function(e3, t4) {
-                            return e3 - t4;
-                        }), c2 = t3.props.selected || t3.props.openToDate || _e$1(), l2 = getHours(c2), d2 = getMinutes(c2), u2 = setHours(setMinutes(a3, d2), l2), h2 = 0; h2 < i3; h2++) {
-                        var m2 = addMinutes(a3, h2 * o3);
-                        if (r3.push(m2), p2) {
-                            var f2 = ft$1(a3, m2, h2, o3, p2);
-                            r3 = r3.concat(f2);
-                        }
-                    }
-                    return r3.map(function(r4, o4) {
-                        return React__default.default.createElement("li", {
-                            key: o4,
-                            onClick: t3.handleClick.bind(ye(t3), r4),
-                            className: t3.liClasses(r4, l2, d2),
-                            ref: function(e3) {
-                                (isBefore(r4, u2) || je$1(r4, u2)) && (t3.centerLi = e3);
-                            },
-                            onKeyDown: function(e3) {
-                                t3.handleOnKeyDown(e3, r4);
-                            },
-                            tabIndex: "0",
-                            "aria-selected": t3.isSelectedTime(r4, l2, d2) ? "true" : void 0
-                        }, Ee$1(r4, n3, t3.props.locale));
-                    });
-                }), t3;
+        function onBlurOrFocusOut(event2) {
+            if (instance2.props.trigger.indexOf("focusin") < 0 && event2.target !== getCurrentTarget()) {
+                return;
             }
-            return le$1(n2, [{
-                key: "componentDidMount",
-                value: function() {
-                    this.list.scrollTop = n2.calcCenterPosition(this.props.monthRef ? this.props.monthRef.clientHeight - this.header.clientHeight : this.list.clientHeight, this.centerLi), this.props.monthRef && this.header && this.setState({
-                        height: this.props.monthRef.clientHeight - this.header.clientHeight
-                    });
+            if (instance2.props.interactive && event2.relatedTarget && popper2.contains(event2.relatedTarget)) {
+                return;
+            }
+            scheduleHide(event2);
+        }
+
+        function isEventListenerStopped(event2) {
+            return currentInput$1.isTouch ? getIsCustomTouchBehavior() !== event2.type.indexOf("touch") >= 0 : false;
+        }
+
+        function createPopperInstance() {
+            destroyPopperInstance();
+            var _instance$props2 = instance2.props,
+                popperOptions = _instance$props2.popperOptions,
+                placement = _instance$props2.placement,
+                offset2 = _instance$props2.offset,
+                getReferenceClientRect = _instance$props2.getReferenceClientRect,
+                moveTransition = _instance$props2.moveTransition;
+            var arrow2 = getIsDefaultRenderFn() ? getChildren$2(popper2).arrow : null;
+            var computedReference = getReferenceClientRect ? {
+                getBoundingClientRect: getReferenceClientRect,
+                contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
+            } : reference2;
+            var tippyModifier = {
+                name: "$$tippy",
+                enabled: true,
+                phase: "beforeWrite",
+                requires: ["computeStyles"],
+                fn: function fn2(_ref2) {
+                    var state2 = _ref2.state;
+                    if (getIsDefaultRenderFn()) {
+                        var _getDefaultTemplateCh = getDefaultTemplateChildren(),
+                            box = _getDefaultTemplateCh.box;
+                        ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
+                            if (attr === "placement") {
+                                box.setAttribute("data-placement", state2.placement);
+                            } else {
+                                if (state2.attributes.popper["data-popper-" + attr]) {
+                                    box.setAttribute("data-" + attr, "");
+                                } else {
+                                    box.removeAttribute("data-" + attr);
+                                }
+                            }
+                        });
+                        state2.attributes.popper = {};
+                    }
+                }
+            };
+            var modifiers2 = [{
+                name: "offset",
+                options: {
+                    offset: offset2
                 }
             }, {
-                key: "render",
-                value: function() {
-                    var t3 = this,
-                        r3 = this.state.height;
-                    return React__default.default.createElement("div", {
-                        className: "react-datepicker__time-container ".concat(this.props.todayButton ? "react-datepicker__time-container--with-today-button" : "")
-                    }, React__default.default.createElement("div", {
-                        className: "react-datepicker__header react-datepicker__header--time ".concat(this.props.showTimeSelectOnly ? "react-datepicker__header--time--only" : ""),
-                        ref: function(e3) {
-                            t3.header = e3;
-                        }
-                    }, React__default.default.createElement("div", {
-                        className: "react-datepicker-time__header"
-                    }, this.props.timeCaption)), React__default.default.createElement("div", {
-                        className: "react-datepicker__time"
-                    }, React__default.default.createElement("div", {
-                        className: "react-datepicker__time-box"
-                    }, React__default.default.createElement("ul", {
-                        className: "react-datepicker__time-list",
-                        ref: function(e3) {
-                            t3.list = e3;
-                        },
-                        style: r3 ? {
-                            height: r3
-                        } : {},
-                        tabIndex: "0"
-                    }, this.renderTimes()))));
+                name: "preventOverflow",
+                options: {
+                    padding: {
+                        top: 2,
+                        bottom: 2,
+                        left: 5,
+                        right: 5
+                    }
                 }
-            }], [{
-                key: "defaultProps",
-                get: function() {
-                    return {
-                        intervals: 30,
-                        onTimeChange: function() {},
-                        todayButton: null,
-                        timeCaption: "Time"
-                    };
+            }, {
+                name: "flip",
+                options: {
+                    padding: 5
                 }
-            }]), n2;
-        }();
-    de$1(xt, "calcCenterPosition", function(e3, t2) {
-        return t2.offsetTop - (e3 / 2 - t2.clientHeight / 2);
-    });
-    var Yt$1 = function(t2) {
-            he$1(o2, React__default.default.Component);
-            var n2 = De(o2);
+            }, {
+                name: "computeStyles",
+                options: {
+                    adaptive: !moveTransition
+                }
+            }, tippyModifier];
+            if (getIsDefaultRenderFn() && arrow2) {
+                modifiers2.push({
+                    name: "arrow",
+                    options: {
+                        element: arrow2,
+                        padding: 3
+                    }
+                });
+            }
+            modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
+            instance2.popperInstance = createPopper$1(computedReference, popper2, Object.assign({}, popperOptions, {
+                placement,
+                onFirstUpdate,
+                modifiers: modifiers2
+            }));
+        }
 
-            function o2(t3) {
-                var a2;
-                return pe$1(this, o2), de$1(ye(a2 = n2.call(this, t3)), "YEAR_REFS", we$1(Array(a2.props.yearItemNumber)).map(function() {
-                    return React__default.default.createRef();
-                })), de$1(ye(a2), "isDisabled", function(e3) {
-                    return Je$1(e3, a2.props);
-                }), de$1(ye(a2), "isExcluded", function(e3) {
-                    return Xe(e3, a2.props);
-                }), de$1(ye(a2), "updateFocusOnPaginate", function(e3) {
-                    var t4 = function() {
-                        this.YEAR_REFS[e3].current.focus();
-                    }.bind(ye(a2));
-                    window.requestAnimationFrame(t4);
-                }), de$1(ye(a2), "handleYearClick", function(e3, t4) {
-                    a2.props.onDayClick && a2.props.onDayClick(e3, t4);
-                }), de$1(ye(a2), "handleYearNavigation", function(e3, t4) {
-                    var r2 = a2.props,
-                        n3 = r2.date,
-                        o3 = r2.yearItemNumber,
-                        s2 = vt(n3, o3).startPeriod;
-                    a2.isDisabled(t4) || a2.isExcluded(t4) || (a2.props.setPreSelection(t4), e3 - s2 == -1 ? a2.updateFocusOnPaginate(o3 - 1) : e3 - s2 === o3 ? a2.updateFocusOnPaginate(0) : a2.YEAR_REFS[e3 - s2].current.focus());
-                }), de$1(ye(a2), "isSameDay", function(e3, t4) {
-                    return We$1(e3, t4);
-                }), de$1(ye(a2), "isCurrentYear", function(e3) {
-                    return e3 === getYear(_e$1());
-                }), de$1(ye(a2), "isKeyboardSelected", function(e3) {
-                    var t4 = Re$1(setYear(a2.props.date, e3));
-                    return !a2.props.disabledKeyboardNavigation && !a2.props.inline && !We$1(t4, Re$1(a2.props.selected)) && We$1(t4, Re$1(a2.props.preSelection));
-                }), de$1(ye(a2), "onYearClick", function(e3, t4) {
-                    var r2 = a2.props.date;
-                    a2.handleYearClick(Re$1(setYear(r2, t4)), e3);
-                }), de$1(ye(a2), "onYearKeyDown", function(e3, t4) {
-                    var r2 = e3.key;
-                    if (!a2.props.disabledKeyboardNavigation)
-                        switch (r2) {
-                            case "Enter":
-                                a2.onYearClick(e3, t4), a2.props.setPreSelection(a2.props.selected);
-                                break;
-                            case "ArrowRight":
-                                a2.handleYearNavigation(t4 + 1, addYears(a2.props.preSelection, 1));
-                                break;
-                            case "ArrowLeft":
-                                a2.handleYearNavigation(t4 - 1, subYears(a2.props.preSelection, 1));
-                        }
-                }), de$1(ye(a2), "getYearClassNames", function(e3) {
-                    var t4 = a2.props,
-                        n3 = t4.minDate,
-                        o3 = t4.maxDate,
-                        s2 = t4.selected;
-                    return r$1("react-datepicker__year-text", {
-                        "react-datepicker__year-text--selected": e3 === getYear(s2),
-                        "react-datepicker__year-text--disabled": (n3 || o3) && rt(e3, a2.props),
-                        "react-datepicker__year-text--keyboard-selected": a2.isKeyboardSelected(e3),
-                        "react-datepicker__year-text--today": a2.isCurrentYear(e3)
-                    });
-                }), de$1(ye(a2), "getYearTabIndex", function(e3) {
-                    return a2.props.disabledKeyboardNavigation ? "-1" : e3 === getYear(a2.props.preSelection) ? "0" : "-1";
-                }), a2;
+        function destroyPopperInstance() {
+            if (instance2.popperInstance) {
+                instance2.popperInstance.destroy();
+                instance2.popperInstance = null;
             }
-            return le$1(o2, [{
-                key: "render",
-                value: function() {
-                    for (var t3 = this, r2 = [], n3 = this.props, o3 = vt(n3.date, n3.yearItemNumber), a2 = o3.startPeriod, s2 = o3.endPeriod, i2 = function(n4) {
-                            r2.push(React__default.default.createElement("div", {
-                                ref: t3.YEAR_REFS[n4 - a2],
-                                onClick: function(e3) {
-                                    t3.onYearClick(e3, n4);
-                                },
-                                onKeyDown: function(e3) {
-                                    t3.onYearKeyDown(e3, n4);
-                                },
-                                tabIndex: t3.getYearTabIndex(n4),
-                                className: t3.getYearClassNames(n4),
-                                key: n4,
-                                "aria-current": t3.isCurrentYear(n4) ? "date" : void 0
-                            }, n4));
-                        }, p2 = a2; p2 <= s2; p2++)
-                        i2(p2);
-                    return React__default.default.createElement("div", {
-                        className: "react-datepicker__year"
-                    }, React__default.default.createElement("div", {
-                        className: "react-datepicker__year-wrapper"
-                    }, r2));
-                }
-            }]), o2;
-        }(),
-        Ot = function(t2) {
-            he$1(n2, React__default.default.Component);
-            var r2 = De(n2);
+        }
 
-            function n2(t3) {
-                var o2;
-                return pe$1(this, n2), de$1(ye(o2 = r2.call(this, t3)), "onTimeChange", function(e3) {
-                    o2.setState({
-                        time: e3
-                    });
-                    var t4 = new Date();
-                    t4.setHours(e3.split(":")[0]), t4.setMinutes(e3.split(":")[1]), o2.props.onChange(t4);
-                }), de$1(ye(o2), "renderTimeInput", function() {
-                    var t4 = o2.state.time,
-                        r3 = o2.props,
-                        n3 = r3.date,
-                        a2 = r3.timeString,
-                        s2 = r3.customTimeInput;
-                    return s2 ? React__default.default.cloneElement(s2, {
-                        date: n3,
-                        value: t4,
-                        onChange: o2.onTimeChange
-                    }) : React__default.default.createElement("input", {
-                        type: "time",
-                        className: "react-datepicker-time__input",
-                        placeholder: "Time",
-                        name: "time-input",
-                        required: true,
-                        value: t4,
-                        onChange: function(e3) {
-                            o2.onTimeChange(e3.target.value || a2);
-                        }
+        function mount() {
+            var appendTo = instance2.props.appendTo;
+            var parentNode;
+            var node2 = getCurrentTarget();
+            if (instance2.props.interactive && appendTo === defaultProps$6.appendTo || appendTo === "parent") {
+                parentNode = node2.parentNode;
+            } else {
+                parentNode = invokeWithArgsOrReturn$1(appendTo, [node2]);
+            }
+            if (!parentNode.contains(popper2)) {
+                parentNode.appendChild(popper2);
+            }
+            createPopperInstance();
+        }
+
+        function getNestedPopperTree() {
+            return arrayFrom$1(popper2.querySelectorAll("[data-tippy-root]"));
+        }
+
+        function scheduleShow(event2) {
+            instance2.clearDelayTimeouts();
+            if (event2) {
+                invokeHook("onTrigger", [instance2, event2]);
+            }
+            addDocumentPress();
+            var delay = getDelay(true);
+            var _getNormalizedTouchSe = getNormalizedTouchSettings(),
+                touchValue = _getNormalizedTouchSe[0],
+                touchDelay = _getNormalizedTouchSe[1];
+            if (currentInput$1.isTouch && touchValue === "hold" && touchDelay) {
+                delay = touchDelay;
+            }
+            if (delay) {
+                showTimeout = setTimeout(function() {
+                    instance2.show();
+                }, delay);
+            } else {
+                instance2.show();
+            }
+        }
+
+        function scheduleHide(event2) {
+            instance2.clearDelayTimeouts();
+            invokeHook("onUntrigger", [instance2, event2]);
+            if (!instance2.state.isVisible) {
+                removeDocumentPress();
+                return;
+            }
+            if (instance2.props.trigger.indexOf("mouseenter") >= 0 && instance2.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event2.type) >= 0 && isVisibleFromClick) {
+                return;
+            }
+            var delay = getDelay(false);
+            if (delay) {
+                hideTimeout = setTimeout(function() {
+                    if (instance2.state.isVisible) {
+                        instance2.hide();
+                    }
+                }, delay);
+            } else {
+                scheduleHideAnimationFrame = requestAnimationFrame(function() {
+                    instance2.hide();
+                });
+            }
+        }
+
+        function enable() {
+            instance2.state.isEnabled = true;
+        }
+
+        function disable2() {
+            instance2.hide();
+            instance2.state.isEnabled = false;
+        }
+
+        function clearDelayTimeouts() {
+            clearTimeout(showTimeout);
+            clearTimeout(hideTimeout);
+            cancelAnimationFrame(scheduleHideAnimationFrame);
+        }
+
+        function setProps(partialProps) {
+            if (instance2.state.isDestroyed) {
+                return;
+            }
+            invokeHook("onBeforeUpdate", [instance2, partialProps]);
+            removeListeners();
+            var prevProps = instance2.props;
+            var nextProps = evaluateProps$1(reference2, Object.assign({}, instance2.props, {}, partialProps, {
+                ignoreAttributes: true
+            }));
+            instance2.props = nextProps;
+            addListeners();
+            if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
+                cleanupInteractiveMouseListeners();
+                debouncedOnMouseMove = debounce$4(onMouseMove, nextProps.interactiveDebounce);
+            }
+            if (prevProps.triggerTarget && !nextProps.triggerTarget) {
+                normalizeToArray$1(prevProps.triggerTarget).forEach(function(node2) {
+                    node2.removeAttribute("aria-expanded");
+                });
+            } else if (nextProps.triggerTarget) {
+                reference2.removeAttribute("aria-expanded");
+            }
+            handleAriaExpandedAttribute();
+            handleStyles();
+            if (onUpdate) {
+                onUpdate(prevProps, nextProps);
+            }
+            if (instance2.popperInstance) {
+                createPopperInstance();
+                getNestedPopperTree().forEach(function(nestedPopper) {
+                    requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
+                });
+            }
+            invokeHook("onAfterUpdate", [instance2, partialProps]);
+        }
+
+        function setContent2(content2) {
+            instance2.setProps({
+                content: content2
+            });
+        }
+
+        function show() {
+            var isAlreadyVisible = instance2.state.isVisible;
+            var isDestroyed = instance2.state.isDestroyed;
+            var isDisabled = !instance2.state.isEnabled;
+            var isTouchAndTouchDisabled = currentInput$1.isTouch && !instance2.props.touch;
+            var duration = getValueAtIndexOrReturn$1(instance2.props.duration, 0, defaultProps$6.duration);
+            if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
+                return;
+            }
+            if (getCurrentTarget().hasAttribute("disabled")) {
+                return;
+            }
+            invokeHook("onShow", [instance2], false);
+            if (instance2.props.onShow(instance2) === false) {
+                return;
+            }
+            instance2.state.isVisible = true;
+            if (getIsDefaultRenderFn()) {
+                popper2.style.visibility = "visible";
+            }
+            handleStyles();
+            addDocumentPress();
+            if (!instance2.state.isMounted) {
+                popper2.style.transition = "none";
+            }
+            if (getIsDefaultRenderFn()) {
+                var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
+                    box = _getDefaultTemplateCh2.box,
+                    content2 = _getDefaultTemplateCh2.content;
+                setTransitionDuration$1([box, content2], 0);
+            }
+            onFirstUpdate = function onFirstUpdate2() {
+                if (!instance2.state.isVisible || ignoreOnFirstUpdate) {
+                    return;
+                }
+                ignoreOnFirstUpdate = true;
+                void popper2.offsetHeight;
+                popper2.style.transition = instance2.props.moveTransition;
+                if (getIsDefaultRenderFn() && instance2.props.animation) {
+                    var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
+                        _box = _getDefaultTemplateCh3.box,
+                        _content = _getDefaultTemplateCh3.content;
+                    setTransitionDuration$1([_box, _content], duration);
+                    setVisibilityState$1([_box, _content], "visible");
+                }
+                handleAriaContentAttribute();
+                handleAriaExpandedAttribute();
+                pushIfUnique$1(mountedInstances$1, instance2);
+                instance2.state.isMounted = true;
+                invokeHook("onMount", [instance2]);
+                if (instance2.props.animation && getIsDefaultRenderFn()) {
+                    onTransitionedIn(duration, function() {
+                        instance2.state.isShown = true;
+                        invokeHook("onShown", [instance2]);
                     });
-                }), o2.state = {
-                    time: o2.props.timeString
-                }, o2;
+                }
+            };
+            mount();
+        }
+
+        function hide2() {
+            var isAlreadyHidden = !instance2.state.isVisible;
+            var isDestroyed = instance2.state.isDestroyed;
+            var isDisabled = !instance2.state.isEnabled;
+            var duration = getValueAtIndexOrReturn$1(instance2.props.duration, 1, defaultProps$6.duration);
+            if (isAlreadyHidden || isDestroyed || isDisabled) {
+                return;
             }
-            return le$1(n2, [{
-                key: "render",
-                value: function() {
-                    return React__default.default.createElement("div", {
-                        className: "react-datepicker__input-time-container"
-                    }, React__default.default.createElement("div", {
-                        className: "react-datepicker-time__caption"
-                    }, this.props.timeInputLabel), React__default.default.createElement("div", {
-                        className: "react-datepicker-time__input-container"
-                    }, React__default.default.createElement("div", {
-                        className: "react-datepicker-time__input"
-                    }, this.renderTimeInput())));
+            invokeHook("onHide", [instance2], false);
+            if (instance2.props.onHide(instance2) === false) {
+                return;
+            }
+            instance2.state.isVisible = false;
+            instance2.state.isShown = false;
+            ignoreOnFirstUpdate = false;
+            isVisibleFromClick = false;
+            if (getIsDefaultRenderFn()) {
+                popper2.style.visibility = "hidden";
+            }
+            cleanupInteractiveMouseListeners();
+            removeDocumentPress();
+            handleStyles();
+            if (getIsDefaultRenderFn()) {
+                var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
+                    box = _getDefaultTemplateCh4.box,
+                    content2 = _getDefaultTemplateCh4.content;
+                if (instance2.props.animation) {
+                    setTransitionDuration$1([box, content2], duration);
+                    setVisibilityState$1([box, content2], "hidden");
                 }
-            }], [{
-                key: "getDerivedStateFromProps",
-                value: function(e3, t3) {
-                    return e3.timeString !== t3.time ? {
-                        time: e3.timeString
-                    } : null;
+            }
+            handleAriaContentAttribute();
+            handleAriaExpandedAttribute();
+            if (instance2.props.animation) {
+                if (getIsDefaultRenderFn()) {
+                    onTransitionedOut(duration, instance2.unmount);
                 }
-            }]), n2;
-        }();
+            } else {
+                instance2.unmount();
+            }
+        }
 
-    function It(t2) {
-        var r2 = t2.className,
-            n2 = t2.children,
-            o2 = t2.showPopperArrow,
-            a2 = t2.arrowProps,
-            s2 = void 0 === a2 ? {} : a2;
-        return React__default.default.createElement("div", {
-            className: r2
-        }, o2 && React__default.default.createElement("div", ue$1({
-            className: "react-datepicker__triangle"
-        }, s2)), n2);
+        function hideWithInteractivity(event2) {
+            doc2.addEventListener("mousemove", debouncedOnMouseMove);
+            pushIfUnique$1(mouseMoveListeners$1, debouncedOnMouseMove);
+            debouncedOnMouseMove(event2);
+        }
+
+        function unmount() {
+            if (instance2.state.isVisible) {
+                instance2.hide();
+            }
+            if (!instance2.state.isMounted) {
+                return;
+            }
+            destroyPopperInstance();
+            getNestedPopperTree().forEach(function(nestedPopper) {
+                nestedPopper._tippy.unmount();
+            });
+            if (popper2.parentNode) {
+                popper2.parentNode.removeChild(popper2);
+            }
+            mountedInstances$1 = mountedInstances$1.filter(function(i2) {
+                return i2 !== instance2;
+            });
+            instance2.state.isMounted = false;
+            invokeHook("onHidden", [instance2]);
+        }
+
+        function destroy() {
+            if (instance2.state.isDestroyed) {
+                return;
+            }
+            instance2.clearDelayTimeouts();
+            instance2.unmount();
+            removeListeners();
+            delete reference2._tippy;
+            instance2.state.isDestroyed = true;
+            invokeHook("onDestroy", [instance2]);
+        }
     }
-    var Tt$1 = ["react-datepicker__year-select", "react-datepicker__month-select", "react-datepicker__month-year-select"],
-        Lt = function(t2) {
-            he$1(o2, React__default.default.Component);
-            var n2 = De(o2);
 
-            function o2(t3) {
-                var a2;
-                return pe$1(this, o2), de$1(ye(a2 = n2.call(this, t3)), "handleClickOutside", function(e3) {
-                    a2.props.onClickOutside(e3);
-                }), de$1(ye(a2), "setClickOutsideRef", function() {
-                    return a2.containerRef.current;
-                }), de$1(ye(a2), "handleDropdownFocus", function(e3) {
-                    (function() {
-                        var e4 = ((arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).className || "").split(/\s+/);
-                        return Tt$1.some(function(t4) {
-                            return e4.indexOf(t4) >= 0;
-                        });
-                    })(e3.target) && a2.props.onDropdownFocus();
-                }), de$1(ye(a2), "getDateInView", function() {
-                    var e3 = a2.props,
-                        t4 = e3.preSelection,
-                        r2 = e3.selected,
-                        n3 = e3.openToDate,
-                        o3 = ut$1(a2.props),
-                        s2 = ht$2(a2.props),
-                        i2 = _e$1(),
-                        p2 = n3 || r2 || t4;
-                    return p2 || (o3 && isBefore(i2, o3) ? o3 : s2 && isAfter(i2, s2) ? s2 : i2);
-                }), de$1(ye(a2), "increaseMonth", function() {
-                    a2.setState(function(e3) {
-                        var t4 = e3.date;
-                        return {
-                            date: addMonths(t4, 1)
-                        };
-                    }, function() {
-                        return a2.handleMonthChange(a2.state.date);
-                    });
-                }), de$1(ye(a2), "decreaseMonth", function() {
-                    a2.setState(function(e3) {
-                        var t4 = e3.date;
-                        return {
-                            date: subMonths(t4, 1)
-                        };
-                    }, function() {
-                        return a2.handleMonthChange(a2.state.date);
-                    });
-                }), de$1(ye(a2), "handleDayClick", function(e3, t4, r2) {
-                    a2.props.onSelect(e3, t4, r2), a2.props.setPreSelection && a2.props.setPreSelection(e3);
-                }), de$1(ye(a2), "handleDayMouseEnter", function(e3) {
-                    a2.setState({
-                        selectingDate: e3
-                    }), a2.props.onDayMouseEnter && a2.props.onDayMouseEnter(e3);
-                }), de$1(ye(a2), "handleMonthMouseLeave", function() {
-                    a2.setState({
-                        selectingDate: null
-                    }), a2.props.onMonthMouseLeave && a2.props.onMonthMouseLeave();
-                }), de$1(ye(a2), "handleYearChange", function(e3) {
-                    a2.props.onYearChange && a2.props.onYearChange(e3), a2.props.adjustDateOnChange && (a2.props.onSelect && a2.props.onSelect(e3), a2.props.setOpen && a2.props.setOpen(true)), a2.props.setPreSelection && a2.props.setPreSelection(e3);
-                }), de$1(ye(a2), "handleMonthChange", function(e3) {
-                    a2.props.onMonthChange && a2.props.onMonthChange(e3), a2.props.adjustDateOnChange && (a2.props.onSelect && a2.props.onSelect(e3), a2.props.setOpen && a2.props.setOpen(true)), a2.props.setPreSelection && a2.props.setPreSelection(e3);
-                }), de$1(ye(a2), "handleMonthYearChange", function(e3) {
-                    a2.handleYearChange(e3), a2.handleMonthChange(e3);
-                }), de$1(ye(a2), "changeYear", function(e3) {
-                    a2.setState(function(t4) {
-                        var r2 = t4.date;
-                        return {
-                            date: setYear(r2, e3)
-                        };
-                    }, function() {
-                        return a2.handleYearChange(a2.state.date);
-                    });
-                }), de$1(ye(a2), "changeMonth", function(e3) {
-                    a2.setState(function(t4) {
-                        var r2 = t4.date;
-                        return {
-                            date: setMonth(r2, e3)
-                        };
-                    }, function() {
-                        return a2.handleMonthChange(a2.state.date);
-                    });
-                }), de$1(ye(a2), "changeMonthYear", function(e3) {
-                    a2.setState(function(t4) {
-                        var r2 = t4.date;
-                        return {
-                            date: setYear(setMonth(r2, getMonth(e3)), getYear(e3))
-                        };
-                    }, function() {
-                        return a2.handleMonthYearChange(a2.state.date);
-                    });
-                }), de$1(ye(a2), "header", function() {
-                    var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a2.state.date,
-                        n3 = Te(t4, a2.props.locale, a2.props.calendarStartDay),
-                        o3 = [];
-                    return a2.props.showWeekNumbers && o3.push(React__default.default.createElement("div", {
-                        key: "W",
-                        className: "react-datepicker__day-name"
-                    }, a2.props.weekLabel || "#")), o3.concat([0, 1, 2, 3, 4, 5, 6].map(function(t5) {
-                        var o4 = addDays(n3, t5),
-                            s2 = a2.formatWeekday(o4, a2.props.locale),
-                            i2 = a2.props.weekDayClassName ? a2.props.weekDayClassName(o4) : void 0;
-                        return React__default.default.createElement("div", {
-                            key: t5,
-                            className: r$1("react-datepicker__day-name", i2)
-                        }, s2);
-                    }));
-                }), de$1(ye(a2), "formatWeekday", function(e3, t4) {
-                    return a2.props.formatWeekDay ? function(e4, t5, r2) {
-                        return t5(Ee$1(e4, "EEEE", r2));
-                    }(e3, a2.props.formatWeekDay, t4) : a2.props.useWeekdaysShort ? function(e4, t5) {
-                        return Ee$1(e4, "EEE", t5);
-                    }(e3, t4) : function(e4, t5) {
-                        return Ee$1(e4, "EEEEEE", t5);
-                    }(e3, t4);
-                }), de$1(ye(a2), "decreaseYear", function() {
-                    a2.setState(function(e3) {
-                        var t4 = e3.date;
-                        return {
-                            date: subYears(t4, a2.props.showYearPicker ? a2.props.yearItemNumber : 1)
-                        };
-                    }, function() {
-                        return a2.handleYearChange(a2.state.date);
-                    });
-                }), de$1(ye(a2), "renderPreviousButton", function() {
-                    if (!a2.props.renderCustomHeader) {
-                        var t4;
-                        switch (true) {
-                            case a2.props.showMonthYearPicker:
-                                t4 = lt$1(a2.state.date, a2.props);
-                                break;
-                            case a2.props.showYearPicker:
-                                t4 = function(e3) {
-                                    var t5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
-                                        r3 = t5.minDate,
-                                        n4 = t5.yearItemNumber,
-                                        o4 = void 0 === n4 ? 12 : n4,
-                                        a3 = vt(Re$1(subYears(e3, o4)), o4).endPeriod,
-                                        s3 = r3 && getYear(r3);
-                                    return s3 && s3 > a3 || false;
-                                }(a2.state.date, a2.props);
-                                break;
-                            default:
-                                t4 = pt$1(a2.state.date, a2.props);
-                        }
-                        if ((a2.props.forceShowMonthNavigation || a2.props.showDisabledMonthNavigation || !t4) && !a2.props.showTimeSelectOnly) {
-                            var r2 = ["react-datepicker__navigation", "react-datepicker__navigation--previous"],
-                                n3 = a2.decreaseMonth;
-                            (a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker || a2.props.showYearPicker) && (n3 = a2.decreaseYear), t4 && a2.props.showDisabledMonthNavigation && (r2.push("react-datepicker__navigation--previous--disabled"), n3 = null);
-                            var o3 = a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker || a2.props.showYearPicker,
-                                s2 = a2.props,
-                                i2 = s2.previousMonthButtonLabel,
-                                p2 = s2.previousYearButtonLabel,
-                                c2 = a2.props,
-                                l2 = c2.previousMonthAriaLabel,
-                                d2 = void 0 === l2 ? "string" == typeof i2 ? i2 : "Previous Month" : l2,
-                                u2 = c2.previousYearAriaLabel,
-                                h2 = void 0 === u2 ? "string" == typeof p2 ? p2 : "Previous Year" : u2;
-                            return React__default.default.createElement("button", {
-                                type: "button",
-                                className: r2.join(" "),
-                                onClick: n3,
-                                onKeyDown: a2.props.handleOnKeyDown,
-                                "aria-label": o3 ? h2 : d2
-                            }, React__default.default.createElement("span", {
-                                className: ["react-datepicker__navigation-icon", "react-datepicker__navigation-icon--previous"].join(" ")
-                            }, o3 ? a2.props.previousYearButtonLabel : a2.props.previousMonthButtonLabel));
-                        }
-                    }
-                }), de$1(ye(a2), "increaseYear", function() {
-                    a2.setState(function(e3) {
-                        var t4 = e3.date;
-                        return {
-                            date: addYears(t4, a2.props.showYearPicker ? a2.props.yearItemNumber : 1)
-                        };
-                    }, function() {
-                        return a2.handleYearChange(a2.state.date);
-                    });
-                }), de$1(ye(a2), "renderNextButton", function() {
-                    if (!a2.props.renderCustomHeader) {
-                        var t4;
-                        switch (true) {
-                            case a2.props.showMonthYearPicker:
-                                t4 = dt$1(a2.state.date, a2.props);
-                                break;
-                            case a2.props.showYearPicker:
-                                t4 = function(e3) {
-                                    var t5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
-                                        r3 = t5.maxDate,
-                                        n4 = t5.yearItemNumber,
-                                        o4 = void 0 === n4 ? 12 : n4,
-                                        a3 = vt(addYears(e3, o4), o4).startPeriod,
-                                        s3 = r3 && getYear(r3);
-                                    return s3 && s3 < a3 || false;
-                                }(a2.state.date, a2.props);
-                                break;
-                            default:
-                                t4 = ct$1(a2.state.date, a2.props);
-                        }
-                        if ((a2.props.forceShowMonthNavigation || a2.props.showDisabledMonthNavigation || !t4) && !a2.props.showTimeSelectOnly) {
-                            var r2 = ["react-datepicker__navigation", "react-datepicker__navigation--next"];
-                            a2.props.showTimeSelect && r2.push("react-datepicker__navigation--next--with-time"), a2.props.todayButton && r2.push("react-datepicker__navigation--next--with-today-button");
-                            var n3 = a2.increaseMonth;
-                            (a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker || a2.props.showYearPicker) && (n3 = a2.increaseYear), t4 && a2.props.showDisabledMonthNavigation && (r2.push("react-datepicker__navigation--next--disabled"), n3 = null);
-                            var o3 = a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker || a2.props.showYearPicker,
-                                s2 = a2.props,
-                                i2 = s2.nextMonthButtonLabel,
-                                p2 = s2.nextYearButtonLabel,
-                                c2 = a2.props,
-                                l2 = c2.nextMonthAriaLabel,
-                                u2 = void 0 === l2 ? "string" == typeof i2 ? i2 : "Next Month" : l2,
-                                h2 = c2.nextYearAriaLabel,
-                                m2 = void 0 === h2 ? "string" == typeof p2 ? p2 : "Next Year" : h2;
-                            return React__default.default.createElement("button", {
-                                type: "button",
-                                className: r2.join(" "),
-                                onClick: n3,
-                                onKeyDown: a2.props.handleOnKeyDown,
-                                "aria-label": o3 ? m2 : u2
-                            }, React__default.default.createElement("span", {
-                                className: ["react-datepicker__navigation-icon", "react-datepicker__navigation-icon--next"].join(" ")
-                            }, o3 ? a2.props.nextYearButtonLabel : a2.props.nextMonthButtonLabel));
-                        }
-                    }
-                }), de$1(ye(a2), "renderCurrentMonth", function() {
-                    var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a2.state.date,
-                        r2 = ["react-datepicker__current-month"];
-                    return a2.props.showYearDropdown && r2.push("react-datepicker__current-month--hasYearDropdown"), a2.props.showMonthDropdown && r2.push("react-datepicker__current-month--hasMonthDropdown"), a2.props.showMonthYearDropdown && r2.push("react-datepicker__current-month--hasMonthYearDropdown"), React__default.default.createElement("div", {
-                        className: r2.join(" ")
-                    }, Ee$1(t4, a2.props.dateFormat, a2.props.locale));
-                }), de$1(ye(a2), "renderYearDropdown", function() {
-                    var t4 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
-                    if (a2.props.showYearDropdown && !t4)
-                        return React__default.default.createElement(gt, {
-                            adjustDateOnChange: a2.props.adjustDateOnChange,
-                            date: a2.state.date,
-                            onSelect: a2.props.onSelect,
-                            setOpen: a2.props.setOpen,
-                            dropdownMode: a2.props.dropdownMode,
-                            onChange: a2.changeYear,
-                            minDate: a2.props.minDate,
-                            maxDate: a2.props.maxDate,
-                            year: getYear(a2.state.date),
-                            scrollableYearDropdown: a2.props.scrollableYearDropdown,
-                            yearDropdownItemNumber: a2.props.yearDropdownItemNumber
-                        });
-                }), de$1(ye(a2), "renderMonthDropdown", function() {
-                    var t4 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
-                    if (a2.props.showMonthDropdown && !t4)
-                        return React__default.default.createElement(bt, {
-                            dropdownMode: a2.props.dropdownMode,
-                            locale: a2.props.locale,
-                            onChange: a2.changeMonth,
-                            month: getMonth(a2.state.date),
-                            useShortMonthInDropdown: a2.props.useShortMonthInDropdown
-                        });
-                }), de$1(ye(a2), "renderMonthYearDropdown", function() {
-                    var t4 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
-                    if (a2.props.showMonthYearDropdown && !t4)
-                        return React__default.default.createElement(_t$1, {
-                            dropdownMode: a2.props.dropdownMode,
-                            locale: a2.props.locale,
-                            dateFormat: a2.props.dateFormat,
-                            onChange: a2.changeMonthYear,
-                            minDate: a2.props.minDate,
-                            maxDate: a2.props.maxDate,
-                            date: a2.state.date,
-                            scrollableMonthYearDropdown: a2.props.scrollableMonthYearDropdown
-                        });
-                }), de$1(ye(a2), "renderTodayButton", function() {
-                    if (a2.props.todayButton && !a2.props.showTimeSelectOnly)
-                        return React__default.default.createElement("div", {
-                            className: "react-datepicker__today-button",
-                            onClick: function(e3) {
-                                return a2.props.onSelect(startOfDay(_e$1()), e3);
-                            }
-                        }, a2.props.todayButton);
-                }), de$1(ye(a2), "renderDefaultHeader", function(t4) {
-                    var r2 = t4.monthDate,
-                        n3 = t4.i;
-                    return React__default.default.createElement("div", {
-                        className: "react-datepicker__header ".concat(a2.props.showTimeSelect ? "react-datepicker__header--has-time-select" : "")
-                    }, a2.renderCurrentMonth(r2), React__default.default.createElement("div", {
-                        className: "react-datepicker__header__dropdown react-datepicker__header__dropdown--".concat(a2.props.dropdownMode),
-                        onFocus: a2.handleDropdownFocus
-                    }, a2.renderMonthDropdown(0 !== n3), a2.renderMonthYearDropdown(0 !== n3), a2.renderYearDropdown(0 !== n3)), React__default.default.createElement("div", {
-                        className: "react-datepicker__day-names"
-                    }, a2.header(r2)));
-                }), de$1(ye(a2), "renderCustomHeader", function() {
-                    var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
-                        r2 = t4.monthDate,
-                        n3 = t4.i;
-                    if (a2.props.showTimeSelect && !a2.state.monthContainer || a2.props.showTimeSelectOnly)
-                        return null;
-                    var o3 = pt$1(a2.state.date, a2.props),
-                        s2 = ct$1(a2.state.date, a2.props),
-                        i2 = lt$1(a2.state.date, a2.props),
-                        p2 = dt$1(a2.state.date, a2.props),
-                        c2 = !a2.props.showMonthYearPicker && !a2.props.showQuarterYearPicker && !a2.props.showYearPicker;
-                    return React__default.default.createElement("div", {
-                        className: "react-datepicker__header react-datepicker__header--custom",
-                        onFocus: a2.props.onDropdownFocus
-                    }, a2.props.renderCustomHeader(se$1(se$1({}, a2.state), {}, {
-                        customHeaderCount: n3,
-                        monthDate: r2,
-                        changeMonth: a2.changeMonth,
-                        changeYear: a2.changeYear,
-                        decreaseMonth: a2.decreaseMonth,
-                        increaseMonth: a2.increaseMonth,
-                        decreaseYear: a2.decreaseYear,
-                        increaseYear: a2.increaseYear,
-                        prevMonthButtonDisabled: o3,
-                        nextMonthButtonDisabled: s2,
-                        prevYearButtonDisabled: i2,
-                        nextYearButtonDisabled: p2
-                    })), c2 && React__default.default.createElement("div", {
-                        className: "react-datepicker__day-names"
-                    }, a2.header(r2)));
-                }), de$1(ye(a2), "renderYearHeader", function() {
-                    var t4 = a2.state.date,
-                        r2 = a2.props,
-                        n3 = r2.showYearPicker,
-                        o3 = vt(t4, r2.yearItemNumber),
-                        s2 = o3.startPeriod,
-                        i2 = o3.endPeriod;
-                    return React__default.default.createElement("div", {
-                        className: "react-datepicker__header react-datepicker-year-header"
-                    }, n3 ? "".concat(s2, " - ").concat(i2) : getYear(t4));
-                }), de$1(ye(a2), "renderHeader", function(e3) {
-                    switch (true) {
-                        case void 0 !== a2.props.renderCustomHeader:
-                            return a2.renderCustomHeader(e3);
-                        case (a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker || a2.props.showYearPicker):
-                            return a2.renderYearHeader(e3);
-                        default:
-                            return a2.renderDefaultHeader(e3);
-                    }
-                }), de$1(ye(a2), "renderMonths", function() {
-                    if (!a2.props.showTimeSelectOnly && !a2.props.showYearPicker) {
-                        for (var t4 = [], r2 = a2.props.showPreviousMonths ? a2.props.monthsShown - 1 : 0, n3 = subMonths(a2.state.date, r2), o3 = 0; o3 < a2.props.monthsShown; ++o3) {
-                            var s2 = o3 - a2.props.monthSelectedIn,
-                                i2 = addMonths(n3, s2),
-                                p2 = "month-".concat(o3),
-                                c2 = o3 < a2.props.monthsShown - 1,
-                                d2 = o3 > 0;
-                            t4.push(React__default.default.createElement("div", {
-                                key: p2,
-                                ref: function(e3) {
-                                    a2.monthContainer = e3;
-                                },
-                                className: "react-datepicker__month-container"
-                            }, a2.renderHeader({
-                                monthDate: i2,
-                                i: o3
-                            }), React__default.default.createElement(Nt, {
-                                chooseDayAriaLabelPrefix: a2.props.chooseDayAriaLabelPrefix,
-                                disabledDayAriaLabelPrefix: a2.props.disabledDayAriaLabelPrefix,
-                                weekAriaLabelPrefix: a2.props.weekAriaLabelPrefix,
-                                ariaLabelPrefix: a2.props.monthAriaLabelPrefix,
-                                onChange: a2.changeMonthYear,
-                                day: i2,
-                                dayClassName: a2.props.dayClassName,
-                                calendarStartDay: a2.props.calendarStartDay,
-                                monthClassName: a2.props.monthClassName,
-                                onDayClick: a2.handleDayClick,
-                                handleOnKeyDown: a2.props.handleOnDayKeyDown,
-                                onDayMouseEnter: a2.handleDayMouseEnter,
-                                onMouseLeave: a2.handleMonthMouseLeave,
-                                onWeekSelect: a2.props.onWeekSelect,
-                                orderInDisplay: o3,
-                                formatWeekNumber: a2.props.formatWeekNumber,
-                                locale: a2.props.locale,
-                                minDate: a2.props.minDate,
-                                maxDate: a2.props.maxDate,
-                                excludeDates: a2.props.excludeDates,
-                                excludeDateIntervals: a2.props.excludeDateIntervals,
-                                highlightDates: a2.props.highlightDates,
-                                selectingDate: a2.state.selectingDate,
-                                includeDates: a2.props.includeDates,
-                                includeDateIntervals: a2.props.includeDateIntervals,
-                                inline: a2.props.inline,
-                                shouldFocusDayInline: a2.props.shouldFocusDayInline,
-                                fixedHeight: a2.props.fixedHeight,
-                                filterDate: a2.props.filterDate,
-                                preSelection: a2.props.preSelection,
-                                setPreSelection: a2.props.setPreSelection,
-                                selected: a2.props.selected,
-                                selectsStart: a2.props.selectsStart,
-                                selectsEnd: a2.props.selectsEnd,
-                                selectsRange: a2.props.selectsRange,
-                                selectsDisabledDaysInRange: a2.props.selectsDisabledDaysInRange,
-                                showWeekNumbers: a2.props.showWeekNumbers,
-                                startDate: a2.props.startDate,
-                                endDate: a2.props.endDate,
-                                peekNextMonth: a2.props.peekNextMonth,
-                                setOpen: a2.props.setOpen,
-                                shouldCloseOnSelect: a2.props.shouldCloseOnSelect,
-                                renderDayContents: a2.props.renderDayContents,
-                                disabledKeyboardNavigation: a2.props.disabledKeyboardNavigation,
-                                showMonthYearPicker: a2.props.showMonthYearPicker,
-                                showFullMonthYearPicker: a2.props.showFullMonthYearPicker,
-                                showTwoColumnMonthYearPicker: a2.props.showTwoColumnMonthYearPicker,
-                                showFourColumnMonthYearPicker: a2.props.showFourColumnMonthYearPicker,
-                                showYearPicker: a2.props.showYearPicker,
-                                showQuarterYearPicker: a2.props.showQuarterYearPicker,
-                                isInputFocused: a2.props.isInputFocused,
-                                containerRef: a2.containerRef,
-                                monthShowsDuplicateDaysEnd: c2,
-                                monthShowsDuplicateDaysStart: d2
-                            })));
-                        }
-                        return t4;
-                    }
-                }), de$1(ye(a2), "renderYears", function() {
-                    if (!a2.props.showTimeSelectOnly)
-                        return a2.props.showYearPicker ? React__default.default.createElement("div", {
-                            className: "react-datepicker__year--container"
-                        }, a2.renderHeader(), React__default.default.createElement(Yt$1, ue$1({
-                            onDayClick: a2.handleDayClick,
-                            date: a2.state.date
-                        }, a2.props))) : void 0;
-                }), de$1(ye(a2), "renderTimeSection", function() {
-                    if (a2.props.showTimeSelect && (a2.state.monthContainer || a2.props.showTimeSelectOnly))
-                        return React__default.default.createElement(xt, {
-                            selected: a2.props.selected,
-                            openToDate: a2.props.openToDate,
-                            onChange: a2.props.onTimeChange,
-                            timeClassName: a2.props.timeClassName,
-                            format: a2.props.timeFormat,
-                            includeTimes: a2.props.includeTimes,
-                            intervals: a2.props.timeIntervals,
-                            minTime: a2.props.minTime,
-                            maxTime: a2.props.maxTime,
-                            excludeTimes: a2.props.excludeTimes,
-                            filterTime: a2.props.filterTime,
-                            timeCaption: a2.props.timeCaption,
-                            todayButton: a2.props.todayButton,
-                            showMonthDropdown: a2.props.showMonthDropdown,
-                            showMonthYearDropdown: a2.props.showMonthYearDropdown,
-                            showYearDropdown: a2.props.showYearDropdown,
-                            withPortal: a2.props.withPortal,
-                            monthRef: a2.state.monthContainer,
-                            injectTimes: a2.props.injectTimes,
-                            locale: a2.props.locale,
-                            handleOnKeyDown: a2.props.handleOnKeyDown,
-                            showTimeSelectOnly: a2.props.showTimeSelectOnly
-                        });
-                }), de$1(ye(a2), "renderInputTimeSection", function() {
-                    var t4 = new Date(a2.props.selected),
-                        r2 = Pe$1(t4) && Boolean(a2.props.selected) ? "".concat(yt(t4.getHours()), ":").concat(yt(t4.getMinutes())) : "";
-                    if (a2.props.showTimeInput)
-                        return React__default.default.createElement(Ot, {
-                            date: t4,
-                            timeString: r2,
-                            timeInputLabel: a2.props.timeInputLabel,
-                            onChange: a2.props.onTimeChange,
-                            customTimeInput: a2.props.customTimeInput
-                        });
-                }), a2.containerRef = React__default.default.createRef(), a2.state = {
-                    date: a2.getDateInView(),
-                    selectingDate: null,
-                    monthContainer: null
-                }, a2;
+    function tippy$1(targets, optionalProps) {
+        if (optionalProps === void 0) {
+            optionalProps = {};
+        }
+        var plugins2 = defaultProps$6.plugins.concat(optionalProps.plugins || []);
+        bindGlobalEventListeners$1();
+        var passedProps = Object.assign({}, optionalProps, {
+            plugins: plugins2
+        });
+        var elements = getArrayOfElements$1(targets);
+        var instances = elements.reduce(function(acc, reference2) {
+            var instance2 = reference2 && createTippy$1(reference2, passedProps);
+            if (instance2) {
+                acc.push(instance2);
             }
-            return le$1(o2, [{
-                key: "componentDidMount",
-                value: function() {
-                    var e3 = this;
-                    this.props.showTimeSelect && (this.assignMonthContainer = void e3.setState({
-                        monthContainer: e3.monthContainer
-                    }));
-                }
-            }, {
-                key: "componentDidUpdate",
-                value: function(e3) {
-                    this.props.preSelection && !We$1(this.props.preSelection, e3.preSelection) ? this.setState({
-                        date: this.props.preSelection
-                    }) : this.props.openToDate && !We$1(this.props.openToDate, e3.openToDate) && this.setState({
-                        date: this.props.openToDate
-                    });
-                }
-            }, {
-                key: "render",
-                value: function() {
-                    var t3 = this.props.container || It;
-                    return React__default.default.createElement("div", {
-                        ref: this.containerRef
-                    }, React__default.default.createElement(t3, {
-                        className: r$1("react-datepicker", this.props.className, {
-                            "react-datepicker--time-only": this.props.showTimeSelectOnly
-                        }),
-                        showPopperArrow: this.props.showPopperArrow,
-                        arrowProps: this.props.arrowProps
-                    }, this.renderPreviousButton(), this.renderNextButton(), this.renderMonths(), this.renderYears(), this.renderTodayButton(), this.renderTimeSection(), this.renderInputTimeSection(), this.props.children));
-                }
-            }], [{
-                key: "defaultProps",
-                get: function() {
-                    return {
-                        onDropdownFocus: function() {},
-                        monthsShown: 1,
-                        monthSelectedIn: 0,
-                        forceShowMonthNavigation: false,
-                        timeCaption: "Time",
-                        previousYearButtonLabel: "Previous Year",
-                        nextYearButtonLabel: "Next Year",
-                        previousMonthButtonLabel: "Previous Month",
-                        nextMonthButtonLabel: "Next Month",
-                        customTimeInput: null,
-                        yearItemNumber: 12
-                    };
-                }
-            }]), o2;
-        }(),
-        Rt$1 = function(t2) {
-            he$1(n2, React__default.default.Component);
-            var r2 = De(n2);
+            return acc;
+        }, []);
+        return isElement$3(targets) ? instances[0] : instances;
+    }
+    tippy$1.defaultProps = defaultProps$6;
+    tippy$1.setDefaultProps = setDefaultProps$1;
+    tippy$1.currentInput = currentInput$1;
+    tippy$1.setDefaultProps({
+        animation: false
+    });
 
-            function n2(e3) {
-                var t3;
-                return pe$1(this, n2), (t3 = r2.call(this, e3)).el = document.createElement("div"), t3;
-            }
-            return le$1(n2, [{
-                key: "componentDidMount",
-                value: function() {
-                    this.portalRoot = (this.props.portalHost || document).getElementById(this.props.portalId), this.portalRoot || (this.portalRoot = document.createElement("div"), this.portalRoot.setAttribute("id", this.props.portalId), (this.props.portalHost || document.body).appendChild(this.portalRoot)), this.portalRoot.appendChild(this.el);
-                }
-            }, {
-                key: "componentWillUnmount",
-                value: function() {
-                    this.portalRoot.removeChild(this.el);
-                }
-            }, {
-                key: "render",
-                value: function() {
-                    return ReactDOM__default.default.createPortal(this.props.children, this.el);
-                }
-            }]), n2;
-        }(),
-        Ft$1 = function(e3) {
-            return !e3.disabled && -1 !== e3.tabIndex;
-        },
-        At$1 = function(t2) {
-            he$1(n2, React__default.default.Component);
-            var r2 = De(n2);
+    function _objectWithoutPropertiesLoose$5(source, excluded) {
+        if (source == null)
+            return {};
+        var target = {};
+        var sourceKeys = Object.keys(source);
+        var key, i2;
+        for (i2 = 0; i2 < sourceKeys.length; i2++) {
+            key = sourceKeys[i2];
+            if (excluded.indexOf(key) >= 0)
+                continue;
+            target[key] = source[key];
+        }
+        return target;
+    }
+    var isBrowser$2 = typeof window !== "undefined" && typeof document !== "undefined";
 
-            function n2(t3) {
-                var o2;
-                return pe$1(this, n2), de$1(ye(o2 = r2.call(this, t3)), "getTabChildren", function() {
-                    return Array.prototype.slice.call(o2.tabLoopRef.current.querySelectorAll("[tabindex], a, button, input, select, textarea"), 1, -1).filter(Ft$1);
-                }), de$1(ye(o2), "handleFocusStart", function(e3) {
-                    var t4 = o2.getTabChildren();
-                    t4 && t4.length > 1 && t4[t4.length - 1].focus();
-                }), de$1(ye(o2), "handleFocusEnd", function(e3) {
-                    var t4 = o2.getTabChildren();
-                    t4 && t4.length > 1 && t4[0].focus();
-                }), o2.tabLoopRef = React__default.default.createRef(), o2;
+    function preserveRef(ref2, node2) {
+        if (ref2) {
+            if (typeof ref2 === "function") {
+                ref2(node2);
             }
-            return le$1(n2, [{
-                key: "render",
-                value: function() {
-                    return this.props.enableTabLoop ? React__default.default.createElement("div", {
-                        className: "react-datepicker__tab-loop",
-                        ref: this.tabLoopRef
-                    }, React__default.default.createElement("div", {
-                        className: "react-datepicker__tab-loop__start",
-                        tabIndex: "0",
-                        onFocus: this.handleFocusStart
-                    }), this.props.children, React__default.default.createElement("div", {
-                        className: "react-datepicker__tab-loop__end",
-                        tabIndex: "0",
-                        onFocus: this.handleFocusEnd
-                    })) : this.props.children;
-                }
-            }], [{
-                key: "defaultProps",
-                get: function() {
-                    return {
-                        enableTabLoop: true
-                    };
-                }
-            }]), n2;
-        }(),
-        Bt$1 = function(t2) {
-            he$1(o2, React__default.default.Component);
-            var n2 = De(o2);
+            if ({}.hasOwnProperty.call(ref2, "current")) {
+                ref2.current = node2;
+            }
+        }
+    }
 
-            function o2() {
-                return pe$1(this, o2), n2.apply(this, arguments);
+    function ssrSafeCreateDiv() {
+        return isBrowser$2 && document.createElement("div");
+    }
+
+    function toDataAttributes(attrs2) {
+        var dataAttrs = {
+            "data-placement": attrs2.placement
+        };
+        if (attrs2.referenceHidden) {
+            dataAttrs["data-reference-hidden"] = "";
+        }
+        if (attrs2.escaped) {
+            dataAttrs["data-escaped"] = "";
+        }
+        return dataAttrs;
+    }
+
+    function deepPreserveProps(instanceProps, componentProps) {
+        var _instanceProps$popper, _componentProps$poppe;
+        return Object.assign({}, componentProps, {
+            popperOptions: Object.assign({}, instanceProps.popperOptions, componentProps.popperOptions, {
+                modifiers: [].concat((((_instanceProps$popper = instanceProps.popperOptions) == null ? void 0 : _instanceProps$popper.modifiers) || []).filter(function(modifier) {
+                    return modifier.name.indexOf("tippy") >= 0;
+                }), ((_componentProps$poppe = componentProps.popperOptions) == null ? void 0 : _componentProps$poppe.modifiers) || [])
+            })
+        });
+    }
+    var useIsomorphicLayoutEffect$4 = isBrowser$2 ? React.useLayoutEffect : React.useEffect;
+
+    function useMutableBox(initialValue) {
+        var ref2 = React.useRef();
+        if (!ref2.current) {
+            ref2.current = typeof initialValue === "function" ? initialValue() : initialValue;
+        }
+        return ref2.current;
+    }
+
+    function updateClassName(box, action, classNames) {
+        classNames.split(/\s+/).forEach(function(name2) {
+            if (name2) {
+                box.classList[action](name2);
             }
-            return le$1(o2, [{
-                key: "render",
-                value: function() {
-                    var t3, n3 = this.props,
-                        o3 = n3.className,
-                        a2 = n3.wrapperClassName,
-                        s2 = n3.hidePopper,
-                        i2 = n3.popperComponent,
-                        p2 = n3.popperModifiers,
-                        c2 = n3.popperPlacement,
-                        l2 = n3.popperProps,
-                        d2 = n3.targetComponent,
-                        u2 = n3.enableTabLoop,
-                        h2 = n3.popperOnKeyDown,
-                        m2 = n3.portalId,
-                        f2 = n3.portalHost;
-                    if (!s2) {
-                        var y2 = r$1("react-datepicker-popper", o3);
-                        t3 = React__default.default.createElement(Popper, ue$1({
-                            modifiers: p2,
-                            placement: c2
-                        }, l2), function(t4) {
-                            var r2 = t4.ref,
-                                n4 = t4.style,
-                                o4 = t4.placement,
-                                a3 = t4.arrowProps;
-                            return React__default.default.createElement(At$1, {
-                                enableTabLoop: u2
-                            }, React__default.default.createElement("div", {
-                                ref: r2,
-                                style: n4,
-                                className: y2,
-                                "data-placement": o4,
-                                onKeyDown: h2
-                            }, React__default.default.cloneElement(i2, {
-                                arrowProps: a3
-                            })));
-                        });
-                    }
-                    this.props.popperContainer && (t3 = React__default.default.createElement(this.props.popperContainer, {}, t3)), m2 && !s2 && (t3 = React__default.default.createElement(Rt$1, {
-                        portalId: m2,
-                        portalHost: f2
-                    }, t3));
-                    var v2 = r$1("react-datepicker-wrapper", a2);
-                    return React__default.default.createElement(Manager, {
-                        className: "react-datepicker-manager"
-                    }, React__default.default.createElement(Reference, null, function(t4) {
-                        var r2 = t4.ref;
-                        return React__default.default.createElement("div", {
-                            ref: r2,
-                            className: v2
-                        }, d2);
-                    }), t3);
+        });
+    }
+    var classNamePlugin = {
+        name: "className",
+        defaultValue: "",
+        fn: function fn2(instance2) {
+            var box = instance2.popper.firstElementChild;
+            var isDefaultRenderFn = function isDefaultRenderFn2() {
+                var _instance$props$rende;
+                return !!((_instance$props$rende = instance2.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
+            };
+
+            function add2() {
+                if (instance2.props.className && !isDefaultRenderFn()) {
+                    return;
                 }
-            }], [{
-                key: "defaultProps",
-                get: function() {
-                    return {
-                        hidePopper: true,
-                        popperModifiers: [],
-                        popperProps: {},
-                        popperPlacement: "bottom-start"
-                    };
+                updateClassName(box, "add", instance2.props.className);
+            }
+
+            function remove2() {
+                if (isDefaultRenderFn()) {
+                    updateClassName(box, "remove", instance2.props.className);
                 }
-            }]), o2;
-        }(),
-        Kt$1 = onClickOutsideHOC(Lt);
-    var Wt$1 = function(t2) {
-            he$1(a2, React__default.default.Component);
-            var o2 = De(a2);
+            }
+            return {
+                onCreate: add2,
+                onBeforeUpdate: remove2,
+                onAfterUpdate: add2
+            };
+        }
+    };
 
-            function a2(t3) {
-                var s2;
-                return pe$1(this, a2), de$1(ye(s2 = o2.call(this, t3)), "getPreSelection", function() {
-                    return s2.props.openToDate ? s2.props.openToDate : s2.props.selectsEnd && s2.props.startDate ? s2.props.startDate : s2.props.selectsStart && s2.props.endDate ? s2.props.endDate : _e$1();
-                }), de$1(ye(s2), "calcInitialState", function() {
-                    var e3, t4 = s2.getPreSelection(),
-                        r2 = ut$1(s2.props),
-                        n2 = ht$2(s2.props),
-                        o3 = r2 && isBefore(t4, startOfDay(r2)) ? r2 : n2 && isAfter(t4, endOfDay(n2)) ? n2 : t4;
-                    return {
-                        open: s2.props.startOpen || false,
-                        preventFocus: false,
-                        preSelection: null !== (e3 = s2.props.selectsRange ? s2.props.startDate : s2.props.selected) && void 0 !== e3 ? e3 : o3,
-                        highlightDates: mt$1(s2.props.highlightDates),
-                        focused: false,
-                        shouldFocusDayInline: false
-                    };
-                }), de$1(ye(s2), "clearPreventFocusTimeout", function() {
-                    s2.preventFocusTimeout && clearTimeout(s2.preventFocusTimeout);
-                }), de$1(ye(s2), "setFocus", function() {
-                    s2.input && s2.input.focus && s2.input.focus({
-                        preventScroll: true
-                    });
-                }), de$1(ye(s2), "setBlur", function() {
-                    s2.input && s2.input.blur && s2.input.blur(), s2.cancelFocusInput();
-                }), de$1(ye(s2), "setOpen", function(e3) {
-                    var t4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
-                    s2.setState({
-                        open: e3,
-                        preSelection: e3 && s2.state.open ? s2.state.preSelection : s2.calcInitialState().preSelection,
-                        lastPreSelectChange: Ht$1
-                    }, function() {
-                        e3 || s2.setState(function(e4) {
+    function TippyGenerator(tippy2) {
+        function Tippy2(_ref2) {
+            var children2 = _ref2.children,
+                content2 = _ref2.content,
+                visible = _ref2.visible,
+                singleton = _ref2.singleton,
+                render2 = _ref2.render,
+                reference2 = _ref2.reference,
+                _ref$disabled = _ref2.disabled,
+                disabled2 = _ref$disabled === void 0 ? false : _ref$disabled,
+                _ref$ignoreAttributes = _ref2.ignoreAttributes,
+                ignoreAttributes = _ref$ignoreAttributes === void 0 ? true : _ref$ignoreAttributes;
+            _ref2.__source;
+            _ref2.__self;
+            var restOfNativeProps = _objectWithoutPropertiesLoose$5(_ref2, ["children", "content", "visible", "singleton", "render", "reference", "disabled", "ignoreAttributes", "__source", "__self"]);
+            var isControlledMode = visible !== void 0;
+            var isSingletonMode = singleton !== void 0;
+            var _useState = React.useState(false),
+                mounted = _useState[0],
+                setMounted = _useState[1];
+            var _useState2 = React.useState({}),
+                attrs2 = _useState2[0],
+                setAttrs = _useState2[1];
+            var _useState3 = React.useState(),
+                singletonContent = _useState3[0],
+                setSingletonContent = _useState3[1];
+            var mutableBox = useMutableBox(function() {
+                return {
+                    container: ssrSafeCreateDiv(),
+                    renders: 1
+                };
+            });
+            var props = Object.assign({
+                ignoreAttributes
+            }, restOfNativeProps, {
+                content: mutableBox.container
+            });
+            if (isControlledMode) {
+                props.trigger = "manual";
+                props.hideOnClick = false;
+            }
+            if (isSingletonMode) {
+                disabled2 = true;
+            }
+            var computedProps = props;
+            var plugins2 = props.plugins || [];
+            if (render2) {
+                computedProps = Object.assign({}, props, {
+                    plugins: isSingletonMode ? [].concat(plugins2, [{
+                        fn: function fn2() {
                             return {
-                                focused: !!t4 && e4.focused
+                                onTrigger: function onTrigger(_2, event2) {
+                                    var _singleton$data$child = singleton.data.children.find(function(_ref22) {
+                                            var instance2 = _ref22.instance;
+                                            return instance2.reference === event2.currentTarget;
+                                        }),
+                                        content3 = _singleton$data$child.content;
+                                    setSingletonContent(content3);
+                                }
                             };
-                        }, function() {
-                            !t4 && s2.setBlur(), s2.setState({
-                                inputValue: null
-                            });
-                        });
-                    });
-                }), de$1(ye(s2), "inputOk", function() {
-                    return isDate$1(s2.state.preSelection);
-                }), de$1(ye(s2), "isCalendarOpen", function() {
-                    return void 0 === s2.props.open ? s2.state.open && !s2.props.disabled && !s2.props.readOnly : s2.props.open;
-                }), de$1(ye(s2), "handleFocus", function(e3) {
-                    s2.state.preventFocus || (s2.props.onFocus(e3), s2.props.preventOpenOnFocus || s2.props.readOnly || s2.setOpen(true)), s2.setState({
-                        focused: true
-                    });
-                }), de$1(ye(s2), "cancelFocusInput", function() {
-                    clearTimeout(s2.inputFocusTimeout), s2.inputFocusTimeout = null;
-                }), de$1(ye(s2), "deferFocusInput", function() {
-                    s2.cancelFocusInput(), s2.inputFocusTimeout = setTimeout(function() {
-                        return s2.setFocus();
-                    }, 1);
-                }), de$1(ye(s2), "handleDropdownFocus", function() {
-                    s2.cancelFocusInput();
-                }), de$1(ye(s2), "handleBlur", function(e3) {
-                    (!s2.state.open || s2.props.withPortal || s2.props.showTimeInput) && s2.props.onBlur(e3), s2.setState({
-                        focused: false
-                    });
-                }), de$1(ye(s2), "handleCalendarClickOutside", function(e3) {
-                    s2.props.inline || s2.setOpen(false), s2.props.onClickOutside(e3), s2.props.withPortal && e3.preventDefault();
-                }), de$1(ye(s2), "handleChange", function() {
-                    for (var e3 = arguments.length, t4 = new Array(e3), r2 = 0; r2 < e3; r2++)
-                        t4[r2] = arguments[r2];
-                    var n2 = t4[0];
-                    if (!s2.props.onChangeRaw || (s2.props.onChangeRaw.apply(ye(s2), t4), "function" == typeof n2.isDefaultPrevented && !n2.isDefaultPrevented())) {
-                        s2.setState({
-                            inputValue: n2.target.value,
-                            lastPreSelectChange: jt$1
-                        });
-                        var o3 = Me$1(n2.target.value, s2.props.dateFormat, s2.props.locale, s2.props.strictParsing, s2.props.minDate);
-                        !o3 && n2.target.value || s2.setSelected(o3, n2, true);
-                    }
-                }), de$1(ye(s2), "handleSelect", function(e3, t4, r2) {
-                    if (s2.setState({
-                            preventFocus: true
-                        }, function() {
-                            return s2.preventFocusTimeout = setTimeout(function() {
-                                return s2.setState({
-                                    preventFocus: false
-                                });
-                            }, 50), s2.preventFocusTimeout;
-                        }), s2.props.onChangeRaw && s2.props.onChangeRaw(t4), s2.setSelected(e3, t4, false, r2), !s2.props.shouldCloseOnSelect || s2.props.showTimeSelect)
-                        s2.setPreSelection(e3);
-                    else if (!s2.props.inline) {
-                        s2.props.selectsRange || s2.setOpen(false);
-                        var n2 = s2.props,
-                            o3 = n2.startDate,
-                            a3 = n2.endDate;
-                        !o3 || a3 || isBefore(e3, o3) || s2.setOpen(false);
-                    }
-                }), de$1(ye(s2), "setSelected", function(e3, t4, r2, n2) {
-                    var o3 = e3;
-                    if (null === o3 || !Je$1(o3, s2.props)) {
-                        var a3 = s2.props,
-                            i2 = a3.onChange,
-                            p2 = a3.selectsRange,
-                            c2 = a3.startDate,
-                            l2 = a3.endDate;
-                        if (!je$1(s2.props.selected, o3) || s2.props.allowSameDay || p2)
-                            if (null !== o3 && (!s2.props.selected || r2 && (s2.props.showTimeSelect || s2.props.showTimeSelectOnly || s2.props.showTimeInput) || (o3 = xe$1(o3, {
-                                    hour: getHours(s2.props.selected),
-                                    minute: getMinutes(s2.props.selected),
-                                    second: getSeconds(s2.props.selected)
-                                })), s2.props.inline || s2.setState({
-                                    preSelection: o3
-                                }), s2.props.focusSelectedMonth || s2.setState({
-                                    monthSelectedIn: n2
-                                })), p2) {
-                                var d2 = c2 && !l2,
-                                    u2 = c2 && l2;
-                                !c2 && !l2 ? i2([o3, null], t4) : d2 && (isBefore(o3, c2) ? i2([o3, null], t4) : i2([c2, o3], t4)), u2 && i2([o3, null], t4);
-                            } else
-                                i2(o3, t4);
-                        r2 || (s2.props.onSelect(o3, t4), s2.setState({
-                            inputValue: null
-                        }));
-                    }
-                }), de$1(ye(s2), "setPreSelection", function(e3) {
-                    var t4 = void 0 !== s2.props.minDate,
-                        r2 = void 0 !== s2.props.maxDate,
-                        n2 = true;
-                    if (e3) {
-                        var o3 = startOfDay(e3);
-                        if (t4 && r2)
-                            n2 = He$1(e3, s2.props.minDate, s2.props.maxDate);
-                        else if (t4) {
-                            var a3 = startOfDay(s2.props.minDate);
-                            n2 = isAfter(e3, a3) || je$1(o3, a3);
-                        } else if (r2) {
-                            var i2 = endOfDay(s2.props.maxDate);
-                            n2 = isBefore(e3, i2) || je$1(o3, i2);
-                        }
-                    }
-                    n2 && s2.setState({
-                        preSelection: e3
-                    });
-                }), de$1(ye(s2), "handleTimeChange", function(e3) {
-                    var t4 = xe$1(s2.props.selected ? s2.props.selected : s2.getPreSelection(), {
-                        hour: getHours(e3),
-                        minute: getMinutes(e3)
-                    });
-                    s2.setState({
-                        preSelection: t4
-                    }), s2.props.onChange(t4), s2.props.shouldCloseOnSelect && s2.setOpen(false), s2.props.showTimeInput && s2.setOpen(true), s2.setState({
-                        inputValue: null
-                    });
-                }), de$1(ye(s2), "onInputClick", function() {
-                    s2.props.disabled || s2.props.readOnly || s2.setOpen(true), s2.props.onInputClick();
-                }), de$1(ye(s2), "onInputKeyDown", function(e3) {
-                    s2.props.onKeyDown(e3);
-                    var t4 = e3.key;
-                    if (s2.state.open || s2.props.inline || s2.props.preventOpenOnFocus) {
-                        if (s2.state.open) {
-                            if ("ArrowDown" === t4 || "ArrowUp" === t4) {
-                                e3.preventDefault();
-                                var r2 = s2.calendar.componentNode && s2.calendar.componentNode.querySelector('.react-datepicker__day[tabindex="0"]');
-                                return void(r2 && r2.focus({
-                                    preventScroll: true
-                                }));
-                            }
-                            var n2 = _e$1(s2.state.preSelection);
-                            "Enter" === t4 ? (e3.preventDefault(), s2.inputOk() && s2.state.lastPreSelectChange === Ht$1 ? (s2.handleSelect(n2, e3), !s2.props.shouldCloseOnSelect && s2.setPreSelection(n2)) : s2.setOpen(false)) : "Escape" === t4 && (e3.preventDefault(), s2.setOpen(false)), s2.inputOk() || s2.props.onInputError({
-                                code: 1,
-                                msg: "Date input not valid."
-                            });
-                        }
-                    } else
-                        "ArrowDown" !== t4 && "ArrowUp" !== t4 && "Enter" !== t4 || s2.onInputClick();
-                }), de$1(ye(s2), "onDayKeyDown", function(e3) {
-                    s2.props.onKeyDown(e3);
-                    var t4 = e3.key,
-                        r2 = _e$1(s2.state.preSelection);
-                    if ("Enter" === t4)
-                        e3.preventDefault(), s2.handleSelect(r2, e3), !s2.props.shouldCloseOnSelect && s2.setPreSelection(r2);
-                    else if ("Escape" === t4)
-                        e3.preventDefault(), s2.setOpen(false), s2.inputOk() || s2.props.onInputError({
-                            code: 1,
-                            msg: "Date input not valid."
-                        });
-                    else if (!s2.props.disabledKeyboardNavigation) {
-                        var n2;
-                        switch (t4) {
-                            case "ArrowLeft":
-                                n2 = subDays(r2, 1);
-                                break;
-                            case "ArrowRight":
-                                n2 = addDays(r2, 1);
-                                break;
-                            case "ArrowUp":
-                                n2 = subWeeks(r2, 1);
-                                break;
-                            case "ArrowDown":
-                                n2 = addWeeks(r2, 1);
-                                break;
-                            case "PageUp":
-                                n2 = subMonths(r2, 1);
-                                break;
-                            case "PageDown":
-                                n2 = addMonths(r2, 1);
-                                break;
-                            case "Home":
-                                n2 = subYears(r2, 1);
-                                break;
-                            case "End":
-                                n2 = addYears(r2, 1);
-                        }
-                        if (!n2)
-                            return void(s2.props.onInputError && s2.props.onInputError({
-                                code: 1,
-                                msg: "Date input not valid."
-                            }));
-                        if (e3.preventDefault(), s2.setState({
-                                lastPreSelectChange: Ht$1
-                            }), s2.props.adjustDateOnChange && s2.setSelected(n2), s2.setPreSelection(n2), s2.props.inline) {
-                            var o3 = getMonth(r2),
-                                a3 = getMonth(n2),
-                                i2 = getYear(r2),
-                                y2 = getYear(n2);
-                            o3 !== a3 || i2 !== y2 ? s2.setState({
-                                shouldFocusDayInline: true
-                            }) : s2.setState({
-                                shouldFocusDayInline: false
-                            });
                         }
+                    }]) : plugins2,
+                    render: function render3() {
+                        return {
+                            popper: mutableBox.container
+                        };
                     }
-                }), de$1(ye(s2), "onPopperKeyDown", function(e3) {
-                    "Escape" === e3.key && (e3.preventDefault(), s2.setState({
-                        preventFocus: true
-                    }, function() {
-                        s2.setOpen(false), setTimeout(function() {
-                            s2.setFocus(), s2.setState({
-                                preventFocus: false
-                            });
-                        });
-                    }));
-                }), de$1(ye(s2), "onClearClick", function(e3) {
-                    e3 && e3.preventDefault && e3.preventDefault(), s2.props.selectsRange ? s2.props.onChange([null, null], e3) : s2.props.onChange(null, e3), s2.setState({
-                        inputValue: null
-                    });
-                }), de$1(ye(s2), "clear", function() {
-                    s2.onClearClick();
-                }), de$1(ye(s2), "onScroll", function(e3) {
-                    "boolean" == typeof s2.props.closeOnScroll && s2.props.closeOnScroll ? e3.target !== document && e3.target !== document.documentElement && e3.target !== document.body || s2.setOpen(false) : "function" == typeof s2.props.closeOnScroll && s2.props.closeOnScroll(e3) && s2.setOpen(false);
-                }), de$1(ye(s2), "renderCalendar", function() {
-                    return s2.props.inline || s2.isCalendarOpen() ? React__default.default.createElement(Kt$1, {
-                        ref: function(e3) {
-                            s2.calendar = e3;
-                        },
-                        locale: s2.props.locale,
-                        calendarStartDay: s2.props.calendarStartDay,
-                        chooseDayAriaLabelPrefix: s2.props.chooseDayAriaLabelPrefix,
-                        disabledDayAriaLabelPrefix: s2.props.disabledDayAriaLabelPrefix,
-                        weekAriaLabelPrefix: s2.props.weekAriaLabelPrefix,
-                        monthAriaLabelPrefix: s2.props.monthAriaLabelPrefix,
-                        adjustDateOnChange: s2.props.adjustDateOnChange,
-                        setOpen: s2.setOpen,
-                        shouldCloseOnSelect: s2.props.shouldCloseOnSelect,
-                        dateFormat: s2.props.dateFormatCalendar,
-                        useWeekdaysShort: s2.props.useWeekdaysShort,
-                        formatWeekDay: s2.props.formatWeekDay,
-                        dropdownMode: s2.props.dropdownMode,
-                        selected: s2.props.selected,
-                        preSelection: s2.state.preSelection,
-                        onSelect: s2.handleSelect,
-                        onWeekSelect: s2.props.onWeekSelect,
-                        openToDate: s2.props.openToDate,
-                        minDate: s2.props.minDate,
-                        maxDate: s2.props.maxDate,
-                        selectsStart: s2.props.selectsStart,
-                        selectsEnd: s2.props.selectsEnd,
-                        selectsRange: s2.props.selectsRange,
-                        startDate: s2.props.startDate,
-                        endDate: s2.props.endDate,
-                        excludeDates: s2.props.excludeDates,
-                        excludeDateIntervals: s2.props.excludeDateIntervals,
-                        filterDate: s2.props.filterDate,
-                        onClickOutside: s2.handleCalendarClickOutside,
-                        formatWeekNumber: s2.props.formatWeekNumber,
-                        highlightDates: s2.state.highlightDates,
-                        includeDates: s2.props.includeDates,
-                        includeDateIntervals: s2.props.includeDateIntervals,
-                        includeTimes: s2.props.includeTimes,
-                        injectTimes: s2.props.injectTimes,
-                        inline: s2.props.inline,
-                        shouldFocusDayInline: s2.state.shouldFocusDayInline,
-                        peekNextMonth: s2.props.peekNextMonth,
-                        showMonthDropdown: s2.props.showMonthDropdown,
-                        showPreviousMonths: s2.props.showPreviousMonths,
-                        useShortMonthInDropdown: s2.props.useShortMonthInDropdown,
-                        showMonthYearDropdown: s2.props.showMonthYearDropdown,
-                        showWeekNumbers: s2.props.showWeekNumbers,
-                        showYearDropdown: s2.props.showYearDropdown,
-                        withPortal: s2.props.withPortal,
-                        forceShowMonthNavigation: s2.props.forceShowMonthNavigation,
-                        showDisabledMonthNavigation: s2.props.showDisabledMonthNavigation,
-                        scrollableYearDropdown: s2.props.scrollableYearDropdown,
-                        scrollableMonthYearDropdown: s2.props.scrollableMonthYearDropdown,
-                        todayButton: s2.props.todayButton,
-                        weekLabel: s2.props.weekLabel,
-                        outsideClickIgnoreClass: "react-datepicker-ignore-onclickoutside",
-                        fixedHeight: s2.props.fixedHeight,
-                        monthsShown: s2.props.monthsShown,
-                        monthSelectedIn: s2.state.monthSelectedIn,
-                        onDropdownFocus: s2.handleDropdownFocus,
-                        onMonthChange: s2.props.onMonthChange,
-                        onYearChange: s2.props.onYearChange,
-                        dayClassName: s2.props.dayClassName,
-                        weekDayClassName: s2.props.weekDayClassName,
-                        monthClassName: s2.props.monthClassName,
-                        timeClassName: s2.props.timeClassName,
-                        showTimeSelect: s2.props.showTimeSelect,
-                        showTimeSelectOnly: s2.props.showTimeSelectOnly,
-                        onTimeChange: s2.handleTimeChange,
-                        timeFormat: s2.props.timeFormat,
-                        timeIntervals: s2.props.timeIntervals,
-                        minTime: s2.props.minTime,
-                        maxTime: s2.props.maxTime,
-                        excludeTimes: s2.props.excludeTimes,
-                        filterTime: s2.props.filterTime,
-                        timeCaption: s2.props.timeCaption,
-                        className: s2.props.calendarClassName,
-                        container: s2.props.calendarContainer,
-                        yearItemNumber: s2.props.yearItemNumber,
-                        yearDropdownItemNumber: s2.props.yearDropdownItemNumber,
-                        previousMonthAriaLabel: s2.props.previousMonthAriaLabel,
-                        previousMonthButtonLabel: s2.props.previousMonthButtonLabel,
-                        nextMonthAriaLabel: s2.props.nextMonthAriaLabel,
-                        nextMonthButtonLabel: s2.props.nextMonthButtonLabel,
-                        previousYearAriaLabel: s2.props.previousYearAriaLabel,
-                        previousYearButtonLabel: s2.props.previousYearButtonLabel,
-                        nextYearAriaLabel: s2.props.nextYearAriaLabel,
-                        nextYearButtonLabel: s2.props.nextYearButtonLabel,
-                        timeInputLabel: s2.props.timeInputLabel,
-                        disabledKeyboardNavigation: s2.props.disabledKeyboardNavigation,
-                        renderCustomHeader: s2.props.renderCustomHeader,
-                        popperProps: s2.props.popperProps,
-                        renderDayContents: s2.props.renderDayContents,
-                        onDayMouseEnter: s2.props.onDayMouseEnter,
-                        onMonthMouseLeave: s2.props.onMonthMouseLeave,
-                        selectsDisabledDaysInRange: s2.props.selectsDisabledDaysInRange,
-                        showTimeInput: s2.props.showTimeInput,
-                        showMonthYearPicker: s2.props.showMonthYearPicker,
-                        showFullMonthYearPicker: s2.props.showFullMonthYearPicker,
-                        showTwoColumnMonthYearPicker: s2.props.showTwoColumnMonthYearPicker,
-                        showFourColumnMonthYearPicker: s2.props.showFourColumnMonthYearPicker,
-                        showYearPicker: s2.props.showYearPicker,
-                        showQuarterYearPicker: s2.props.showQuarterYearPicker,
-                        showPopperArrow: s2.props.showPopperArrow,
-                        excludeScrollbar: s2.props.excludeScrollbar,
-                        handleOnKeyDown: s2.props.onKeyDown,
-                        handleOnDayKeyDown: s2.onDayKeyDown,
-                        isInputFocused: s2.state.focused,
-                        customTimeInput: s2.props.customTimeInput,
-                        setPreSelection: s2.setPreSelection
-                    }, s2.props.children) : null;
-                }), de$1(ye(s2), "renderDateInput", function() {
-                    var t4, n2 = r$1(s2.props.className, de$1({}, "react-datepicker-ignore-onclickoutside", s2.state.open)),
-                        o3 = s2.props.customInput || React__default.default.createElement("input", {
-                            type: "text"
-                        }),
-                        a3 = s2.props.customInputRef || "ref",
-                        i2 = "string" == typeof s2.props.value ? s2.props.value : "string" == typeof s2.state.inputValue ? s2.state.inputValue : s2.props.selectsRange ? function(e3, t5, r2) {
-                            if (!e3)
-                                return "";
-                            var n3 = Ne$1(e3, r2),
-                                o4 = t5 ? Ne$1(t5, r2) : "";
-                            return "".concat(n3, " - ").concat(o4);
-                        }(s2.props.startDate, s2.props.endDate, s2.props) : Ne$1(s2.props.selected, s2.props);
-                    return React__default.default.cloneElement(o3, (de$1(t4 = {}, a3, function(e3) {
-                        s2.input = e3;
-                    }), de$1(t4, "value", i2), de$1(t4, "onBlur", s2.handleBlur), de$1(t4, "onChange", s2.handleChange), de$1(t4, "onClick", s2.onInputClick), de$1(t4, "onFocus", s2.handleFocus), de$1(t4, "onKeyDown", s2.onInputKeyDown), de$1(t4, "id", s2.props.id), de$1(t4, "name", s2.props.name), de$1(t4, "autoFocus", s2.props.autoFocus), de$1(t4, "placeholder", s2.props.placeholderText), de$1(t4, "disabled", s2.props.disabled), de$1(t4, "autoComplete", s2.props.autoComplete), de$1(t4, "className", r$1(o3.props.className, n2)), de$1(t4, "title", s2.props.title), de$1(t4, "readOnly", s2.props.readOnly), de$1(t4, "required", s2.props.required), de$1(t4, "tabIndex", s2.props.tabIndex), de$1(t4, "aria-describedby", s2.props.ariaDescribedBy), de$1(t4, "aria-invalid", s2.props.ariaInvalid), de$1(t4, "aria-labelledby", s2.props.ariaLabelledBy), de$1(t4, "aria-required", s2.props.ariaRequired), t4));
-                }), de$1(ye(s2), "renderClearButton", function() {
-                    var t4 = s2.props,
-                        r2 = t4.isClearable,
-                        n2 = t4.selected,
-                        o3 = t4.startDate,
-                        a3 = t4.endDate,
-                        i2 = t4.clearButtonTitle,
-                        p2 = t4.clearButtonClassName,
-                        c2 = void 0 === p2 ? "" : p2,
-                        l2 = t4.ariaLabelClose,
-                        d2 = void 0 === l2 ? "Close" : l2;
-                    return !r2 || null == n2 && null == o3 && null == a3 ? null : React__default.default.createElement("button", {
-                        type: "button",
-                        className: "react-datepicker__close-icon ".concat(c2).trim(),
-                        "aria-label": d2,
-                        onClick: s2.onClearClick,
-                        title: i2,
-                        tabIndex: -1
-                    });
-                }), s2.state = s2.calcInitialState(), s2;
+                });
             }
-            return le$1(a2, [{
-                key: "componentDidMount",
-                value: function() {
-                    window.addEventListener("scroll", this.onScroll, true);
+            var deps = [reference2].concat(children2 ? [children2.type] : []);
+            useIsomorphicLayoutEffect$4(function() {
+                var element2 = reference2;
+                if (reference2 && reference2.hasOwnProperty("current")) {
+                    element2 = reference2.current;
                 }
-            }, {
-                key: "componentDidUpdate",
-                value: function(e3, t3) {
-                    var r2, n2;
-                    e3.inline && (r2 = e3.selected, n2 = this.props.selected, r2 && n2 ? getMonth(r2) !== getMonth(n2) || getYear(r2) !== getYear(n2) : r2 !== n2) && this.setPreSelection(this.props.selected), void 0 !== this.state.monthSelectedIn && e3.monthsShown !== this.props.monthsShown && this.setState({
-                        monthSelectedIn: 0
-                    }), e3.highlightDates !== this.props.highlightDates && this.setState({
-                        highlightDates: mt$1(this.props.highlightDates)
-                    }), t3.focused || je$1(e3.selected, this.props.selected) || this.setState({
-                        inputValue: null
-                    }), t3.open !== this.state.open && (false === t3.open && true === this.state.open && this.props.onCalendarOpen(), true === t3.open && false === this.state.open && this.props.onCalendarClose());
+                var instance2 = tippy2(element2 || mutableBox.ref || ssrSafeCreateDiv(), Object.assign({}, computedProps, {
+                    plugins: [classNamePlugin].concat(props.plugins || [])
+                }));
+                mutableBox.instance = instance2;
+                if (disabled2) {
+                    instance2.disable();
                 }
-            }, {
-                key: "componentWillUnmount",
-                value: function() {
-                    this.clearPreventFocusTimeout(), window.removeEventListener("scroll", this.onScroll, true);
+                if (visible) {
+                    instance2.show();
                 }
-            }, {
-                key: "renderInputContainer",
-                value: function() {
-                    return React__default.default.createElement("div", {
-                        className: "react-datepicker__input-container"
-                    }, this.renderDateInput(), this.renderClearButton());
+                if (isSingletonMode) {
+                    singleton.hook({
+                        instance: instance2,
+                        content: content2,
+                        props: computedProps
+                    });
                 }
-            }, {
-                key: "render",
-                value: function() {
-                    var t3 = this.renderCalendar();
-                    if (this.props.inline)
-                        return t3;
-                    if (this.props.withPortal) {
-                        var r2 = this.state.open ? React__default.default.createElement("div", {
-                            className: "react-datepicker__portal"
-                        }, t3) : null;
-                        return this.state.open && this.props.portalId && (r2 = React__default.default.createElement(Rt$1, {
-                            portalId: this.props.portalId,
-                            portalHost: this.props.portalHost
-                        }, r2)), React__default.default.createElement("div", null, this.renderInputContainer(), r2);
+                setMounted(true);
+                return function() {
+                    instance2.destroy();
+                    singleton == null ? void 0 : singleton.cleanup(instance2);
+                };
+            }, deps);
+            useIsomorphicLayoutEffect$4(function() {
+                if (mutableBox.renders === 1) {
+                    mutableBox.renders++;
+                    return;
+                }
+                var instance2 = mutableBox.instance;
+                instance2.setProps(deepPreserveProps(instance2.props, computedProps));
+                if (disabled2) {
+                    instance2.disable();
+                } else {
+                    instance2.enable();
+                }
+                if (isControlledMode) {
+                    if (visible) {
+                        instance2.show();
+                    } else {
+                        instance2.hide();
                     }
-                    return React__default.default.createElement(Bt$1, {
-                        className: this.props.popperClassName,
-                        wrapperClassName: this.props.wrapperClassName,
-                        hidePopper: !this.isCalendarOpen(),
-                        portalId: this.props.portalId,
-                        portalHost: this.props.portalHost,
-                        popperModifiers: this.props.popperModifiers,
-                        targetComponent: this.renderInputContainer(),
-                        popperContainer: this.props.popperContainer,
-                        popperComponent: t3,
-                        popperPlacement: this.props.popperPlacement,
-                        popperProps: this.props.popperProps,
-                        popperOnKeyDown: this.onPopperKeyDown,
-                        enableTabLoop: this.props.enableTabLoop
+                }
+                if (isSingletonMode) {
+                    singleton.hook({
+                        instance: instance2,
+                        content: content2,
+                        props: computedProps
                     });
                 }
-            }], [{
-                key: "defaultProps",
-                get: function() {
-                    return {
-                        allowSameDay: false,
-                        dateFormat: "MM/dd/yyyy",
-                        dateFormatCalendar: "LLLL yyyy",
-                        onChange: function() {},
-                        disabled: false,
-                        disabledKeyboardNavigation: false,
-                        dropdownMode: "scroll",
-                        onFocus: function() {},
-                        onBlur: function() {},
-                        onKeyDown: function() {},
-                        onInputClick: function() {},
-                        onSelect: function() {},
-                        onClickOutside: function() {},
-                        onMonthChange: function() {},
-                        onCalendarOpen: function() {},
-                        onCalendarClose: function() {},
-                        preventOpenOnFocus: false,
-                        onYearChange: function() {},
-                        onInputError: function() {},
-                        monthsShown: 1,
-                        readOnly: false,
-                        withPortal: false,
-                        selectsDisabledDaysInRange: false,
-                        shouldCloseOnSelect: true,
-                        showTimeSelect: false,
-                        showTimeInput: false,
-                        showPreviousMonths: false,
-                        showMonthYearPicker: false,
-                        showFullMonthYearPicker: false,
-                        showTwoColumnMonthYearPicker: false,
-                        showFourColumnMonthYearPicker: false,
-                        showYearPicker: false,
-                        showQuarterYearPicker: false,
-                        strictParsing: false,
-                        timeIntervals: 30,
-                        timeCaption: "Time",
-                        previousMonthAriaLabel: "Previous Month",
-                        previousMonthButtonLabel: "Previous Month",
-                        nextMonthAriaLabel: "Next Month",
-                        nextMonthButtonLabel: "Next Month",
-                        previousYearAriaLabel: "Previous Year",
-                        previousYearButtonLabel: "Previous Year",
-                        nextYearAriaLabel: "Next Year",
-                        nextYearButtonLabel: "Next Year",
-                        timeInputLabel: "Time",
-                        enableTabLoop: true,
-                        yearItemNumber: 12,
-                        renderDayContents: function(e3) {
-                            return e3;
-                        },
-                        focusSelectedMonth: false,
-                        showPopperArrow: true,
-                        excludeScrollbar: true,
-                        customTimeInput: null,
-                        calendarStartDay: void 0
-                    };
+            });
+            useIsomorphicLayoutEffect$4(function() {
+                var _instance$props$poppe;
+                if (!render2) {
+                    return;
                 }
-            }]), a2;
-        }(),
-        jt$1 = "input",
-        Ht$1 = "navigate";
-    const reactDatepicker = "";
-    var __rest$a = globalThis && globalThis.__rest || function(s2, e3) {
-        var t2 = {};
-        for (var p2 in s2)
-            if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
-                t2[p2] = s2[p2];
-        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
-            for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
-                if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
-                    t2[p2[i2]] = s2[p2[i2]];
-            }
-        return t2;
-    };
-    const {
-        stateChangeTypes: stateChangeTypes$2
-    } = useSelect;
-    const SelectedItem$1 = styled__default.default.div`
-    width: 100%;
-    font-size: ${(props) => props.size ? `${props.size}rem` : props.theme.font.size};
-    font-weight: 300;
-`;
-    const Wrapper$9 = styled__default.default.div`
-    display: inline-flex;
-    width: 6.25rem;
-    height: 1.5rem;
-    border-radius: 0.25rem;
-
-    ${(props) => {
-    if (props.isDisabled) {
-      return `
-                border: 1px solid ${props.theme.colors.grey1};
-                cursor: not-allowed;
-            `;
+                var instance2 = mutableBox.instance;
+                instance2.setProps({
+                    popperOptions: Object.assign({}, instance2.props.popperOptions, {
+                        modifiers: [].concat(((_instance$props$poppe = instance2.props.popperOptions) == null ? void 0 : _instance$props$poppe.modifiers) || [], [{
+                            name: "$$tippyReact",
+                            enabled: true,
+                            phase: "beforeWrite",
+                            requires: ["computeStyles"],
+                            fn: function fn2(_ref3) {
+                                var _state$modifiersData;
+                                var state = _ref3.state;
+                                var hideData = (_state$modifiersData = state.modifiersData) == null ? void 0 : _state$modifiersData.hide;
+                                if (attrs2.placement !== state.placement || attrs2.referenceHidden !== (hideData == null ? void 0 : hideData.isReferenceHidden) || attrs2.escaped !== (hideData == null ? void 0 : hideData.hasPopperEscaped)) {
+                                    setAttrs({
+                                        placement: state.placement,
+                                        referenceHidden: hideData == null ? void 0 : hideData.isReferenceHidden,
+                                        escaped: hideData == null ? void 0 : hideData.hasPopperEscaped
+                                    });
+                                }
+                                state.attributes.popper = {};
+                            }
+                        }])
+                    })
+                });
+            }, [attrs2.placement, attrs2.referenceHidden, attrs2.escaped].concat(deps));
+            return /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, children2 ? /* @__PURE__ */ React.cloneElement(children2, {
+                ref: function ref2(node2) {
+                    mutableBox.ref = node2;
+                    preserveRef(children2.ref, node2);
+                }
+            }) : null, mounted && /* @__PURE__ */ ReactDOM.createPortal(render2 ? render2(toDataAttributes(attrs2), singletonContent) : content2, mutableBox.container));
+        }
+        return Tippy2;
     }
-    if (props.isErrored) {
-      return `
-    border: 1 px solid $ {
-        props.theme.colors.error
+    var forwardRef = function(Tippy2, defaultProps2) {
+        return /* @__PURE__ */ React.forwardRef(function TippyWrapper(_ref2, _ref22) {
+            var children2 = _ref2.children,
+                props = _objectWithoutPropertiesLoose$5(_ref2, ["children"]);
+            return /* @__PURE__ */ React__default.default.createElement(Tippy2, Object.assign({}, defaultProps2, props), children2 ? /* @__PURE__ */ React.cloneElement(children2, {
+                ref: function ref2(node2) {
+                    preserveRef(_ref22, node2);
+                    preserveRef(children2.ref, node2);
+                }
+            }) : null);
+        });
     };
-    `;
-    }
-    return `
-    border: 1 px solid $ {
-        props.theme.colors.grey1
+    var headless = /* @__PURE__ */ forwardRef( /* @__PURE__ */ TippyGenerator(tippy$1), {
+        render: function render2() {
+            return "";
+        }
+    });
+    const Tippy = headless;
+    var BOX_CLASS = "tippy-box";
+    var CONTENT_CLASS = "tippy-content";
+    var BACKDROP_CLASS = "tippy-backdrop";
+    var ARROW_CLASS = "tippy-arrow";
+    var SVG_ARROW_CLASS = "tippy-svg-arrow";
+    var TOUCH_OPTIONS = {
+        passive: true,
+        capture: true
     };
-    `;
-  }}
-`;
-    const SelectButton$1 = styled__default.default.button`
-    cursor: pointer;
-
-    display: inline-flex;
-    flex: 1 1 auto;
-    align-items: center;
-    justify-content: space-between;
 
-    width: 100%;
-    height: 100%;
-    padding: 0 0.5rem 0 1rem;
+    function getValueAtIndexOrReturn(value, index2, defaultValue2) {
+        if (Array.isArray(value)) {
+            var v2 = value[index2];
+            return v2 == null ? Array.isArray(defaultValue2) ? defaultValue2[index2] : defaultValue2 : v2;
+        }
+        return value;
+    }
 
-    font-size: ${(props) => props.theme.font.size};
+    function isType(value, type2) {
+        var str = {}.toString.call(value);
+        return str.indexOf("[object") === 0 && str.indexOf(type2 + "]") > -1;
+    }
 
-    border: none;
-    outline: 0;
+    function invokeWithArgsOrReturn(value, args) {
+        return typeof value === "function" ? value.apply(void 0, args) : value;
+    }
 
-    :not(:enabled) {
-        cursor: not-allowed;
+    function debounce$3(fn2, ms2) {
+        if (ms2 === 0) {
+            return fn2;
+        }
+        var timeout2;
+        return function(arg) {
+            clearTimeout(timeout2);
+            timeout2 = setTimeout(function() {
+                fn2(arg);
+            }, ms2);
+        };
     }
-`;
-    const SelectButtonPrimary = styled__default.default(SelectButton$1)`
-    justify-content: start;
 
-    width: 100%;
-    padding: 0 0.25rem;
+    function splitBySpaces(value) {
+        return value.split(/\s+/).filter(Boolean);
+    }
 
-    font-size: 0.875rem;
-    color: ${(props) => props.theme.colors.text};
+    function normalizeToArray(value) {
+        return [].concat(value);
+    }
 
-    background-color: ${(props) => props.theme.colors.grey1};
-    border-radius: 0.25rem;
+    function pushIfUnique(arr, value) {
+        if (arr.indexOf(value) === -1) {
+            arr.push(value);
+        }
+    }
 
-    :hover:enabled {
-        background-color: ${(props) => props.theme.colors.grey2};
+    function unique(arr) {
+        return arr.filter(function(item, index2) {
+            return arr.indexOf(item) === index2;
+        });
     }
 
-    svg {
-        width: 1rem !important;
-        height: 0.8rem;
-        margin-left: 0.5rem !important;
+    function getBasePlacement$1(placement) {
+        return placement.split("-")[0];
     }
 
-    :disabled {
-        color: ${(props) => props.theme.colors.grey2};
+    function arrayFrom(value) {
+        return [].slice.call(value);
+    }
 
-        svg {
-            color: ${(props) => props.theme.colors.grey2};
-        }
+    function removeUndefinedProps(obj) {
+        return Object.keys(obj).reduce(function(acc, key) {
+            if (obj[key] !== void 0) {
+                acc[key] = obj[key];
+            }
+            return acc;
+        }, {});
     }
-`;
-    const DatepickerListItem = styled__default.default.span`
-    cursor: pointer;
-    user-select: none;
 
-    overflow: hidden;
-    display: flex;
-    align-items: center;
+    function div() {
+        return document.createElement("div");
+    }
 
-    width: 100%;
-    min-height: 2rem;
-    padding: 0.25rem 1.5rem;
+    function isElement$2(value) {
+        return ["Element", "Fragment"].some(function(type2) {
+            return isType(value, type2);
+        });
+    }
 
-    font-size: ${(props) => props.size ? `${props.size}rem` : props.theme.font.size};
-    font-weight: 300;
-    color: ${(props) => props.isSelected ? "#FFF" : props.theme.colors.text};
-    text-overflow: ellipsis;
-    white-space: nowrap;
+    function isNodeList$1(value) {
+        return isType(value, "NodeList");
+    }
 
-    background-color: ${(props) => {
-    if (props.isSelected) {
-      return props.theme.colors.primary;
+    function isMouseEvent(value) {
+        return isType(value, "MouseEvent");
     }
-    if (props.hovered) {
-      return props.theme.colors.grey2;
+
+    function isReferenceElement(value) {
+        return !!(value && value._tippy && value._tippy.reference === value);
     }
-    return props.theme.colors.grey1;
-  }};
 
-    :active {
-        background-color: ${(props) => props.theme.colors.grey1};
+    function getArrayOfElements(value) {
+        if (isElement$2(value)) {
+            return [value];
+        }
+        if (isNodeList$1(value)) {
+            return arrayFrom(value);
+        }
+        if (Array.isArray(value)) {
+            return value;
+        }
+        return arrayFrom(document.querySelectorAll(value));
     }
 
-    &:last-child {
-        border-bottom: none;
+    function setTransitionDuration(els, value) {
+        els.forEach(function(el) {
+            if (el) {
+                el.style.transitionDuration = value + "ms";
+            }
+        });
     }
-`;
-    const DropdownList$2 = styled__default.default.div`
-    overflow-y: auto;
-    display: ${(props) => props.isOpen ? "flex" : "none"};
-    flex-direction: column;
-    gap: 0.125rem;
 
-    max-height: calc(${(props) => (props.maxItems || 5) * 2}em + 2px);
-    margin-left: ${(props) => props.displacement}rem;
+    function setVisibilityState(els, state) {
+        els.forEach(function(el) {
+            if (el) {
+                el.setAttribute("data-state", state);
+            }
+        });
+    }
 
-    background-color: ${(props) => props.theme.colors.grey1};
-    border: none;
-    outline: 0;
-`;
+    function getOwnerDocument(elementOrElements) {
+        var _normalizeToArray = normalizeToArray(elementOrElements),
+            element2 = _normalizeToArray[0];
+        return element2 ? element2.ownerDocument || document : document;
+    }
 
-    function DatepickerSelect(props) {
-        var _a3, _b, _c;
-        const referenceElement = React.useRef(null);
-        const popperElement = React.useRef(null);
-        const {
-            styles: styles2,
-            attributes: attributes2,
-            update: update2
-        } = usePopper$1(referenceElement.current, popperElement.current, {
-            modifiers: [sameWidthModifier],
-            placement: props.placement || "bottom-start"
-        });
-        const [pendingHighlight, setPendingHighlight] = React.useState(null);
-        const {
-            isOpen,
-            selectedItem,
-            getToggleButtonProps,
-            getMenuProps,
-            highlightedIndex,
-            getItemProps,
-            setHighlightedIndex
-        } = useSelect(Object.assign({
-            initialSelectedItem: props.initialValue,
-            itemToString: (item) => item.label,
-            items: props.items,
-            onSelectedItemChange: (changes) => {
-                const selected = changes.selectedItem;
-                if (props.onSelect) {
-                    props.onSelect(selected);
-                }
-            },
-            stateReducer: (state, {
-                changes,
-                type: type2
-            }) => {
-                if (type2 === stateChangeTypes$2.ToggleButtonClick) {
-                    setPendingHighlight(changes.selectedItem ? props.items.findIndex((i2) => i2.value === changes.selectedItem.value) : 0);
-                }
-                return changes;
-            }
-        }, props.selectedItem && {
-            selectedItem: props.selectedItem
-        }));
-        React.useEffect(() => {
-            if (isOpen && pendingHighlight !== null) {
-                setHighlightedIndex(pendingHighlight);
-                setPendingHighlight(null);
-            }
-        }, [isOpen, pendingHighlight, setHighlightedIndex]);
-        React.useEffect(() => {
-            if (isOpen && update2) {
-                update2();
+    function isCursorOutsideInteractiveBorder(popperTreeData, event2) {
+        var clientX = event2.clientX,
+            clientY = event2.clientY;
+        return popperTreeData.every(function(_ref2) {
+            var popperRect = _ref2.popperRect,
+                popperState = _ref2.popperState,
+                props = _ref2.props;
+            var interactiveBorder = props.interactiveBorder;
+            var basePlacement = getBasePlacement$1(popperState.placement);
+            var offsetData = popperState.modifiersData.offset;
+            if (!offsetData) {
+                return true;
             }
-        }, [isOpen, update2]);
-        const buttonProps = getToggleButtonProps({
-            disabled: props.disabled
+            var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
+            var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
+            var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
+            var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
+            var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
+            var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
+            var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
+            var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
+            return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
         });
-        const setButtonRef = buttonProps.ref;
-        delete buttonProps.ref;
-        const setButtonReference = (value) => {
-            setButtonRef(value);
-            referenceElement.current = value;
-        };
-        const menuProps = getMenuProps();
-        const setMenuRef = menuProps.ref;
-        delete menuProps.ref;
-        const setMenuReference = (value) => {
-            var _a4;
-            setMenuRef(value);
-            popperElement.current = value;
-            (_a4 = props.dropdownRef) === null || _a4 === void 0 ? void 0 : _a4.call(props, value);
-        };
-        return jsxRuntime.exports.jsx(Tooltip$1, {
-            content: props.errorMsg,
-            disabled: !props.errorMsg,
-            styling: "error",
-            children: jsxRuntime.exports.jsxs(Wrapper$9, {
-                className: props.className,
-                isDisabled: props.disabled,
-                isErrored: !!props.errorMsg,
-                onClick: props.onClick,
-                style: props.style,
-                children: [jsxRuntime.exports.jsxs(SelectButtonPrimary, Object.assign({
-                    disabled: props.disabled
-                }, buttonProps, {
-                    ref: setButtonReference,
-                    type: "button",
-                    children: [jsxRuntime.exports.jsx(SelectedItem$1, {
-                        size: props.size,
-                        children: selectedItem ? selectedItem.label : "Select"
-                    }), jsxRuntime.exports.jsx(Chevron$2, {
-                        disabled: props.disabled,
-                        isOpen
-                    })]
-                })), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(DropdownList$2, Object.assign({}, menuProps, attributes2.popper, {
-                    className: `${(_a3 = menuProps === null || menuProps === void 0 ? void 0 : menuProps.className) !== null && _a3 !== void 0 ? _a3 : ""} ${(_c = (_b = attributes2 === null || attributes2 === void 0 ? void 0 : attributes2.popper) === null || _b === void 0 ? void 0 : _b.className) !== null && _c !== void 0 ? _c : ""} ${props.itemClass}`,
-                    displacement: props.displacement,
-                    isOpen,
-                    maxItems: 7,
-                    ref: setMenuReference,
-                    style: Object.assign(Object.assign({}, styles2.popper), {
-                        marginTop: `0.8rem`,
-                        width: "16.25rem",
-                        zIndex: 9999
-                    }),
-                    children: props.items.map((item, index2) => {
-                        const _a4 = getItemProps({
-                                index: index2,
-                                item
-                            }),
-                            {
-                                itemClassName
-                            } = _a4,
-                            itemProps = __rest$a(_a4, ["itemClassName"]);
-                        return React.createElement(DatepickerListItem, Object.assign({}, itemProps, {
-                            "aria-selected": selectedItem.label === item.label,
-                            className: `${itemClassName} ${props.itemClass}`,
-                            hovered: index2 === highlightedIndex,
-                            isSelected: selectedItem.label === item.label,
-                            key: `item-${index2}`,
-                            size: props.size,
-                            title: item.label
-                        }), item.label);
-                    })
-                })), document.body)]
-            })
+    }
+
+    function updateTransitionEndListener(box, action, listener2) {
+        var method = action + "EventListener";
+        ["transitionend", "webkitTransitionEnd"].forEach(function(event2) {
+            box[method](event2, listener2);
         });
     }
+    var currentInput = {
+        isTouch: false
+    };
+    var lastMouseMoveTime = 0;
 
-    function getMonths() {
-        const months = [];
-        for (let i2 = 0; i2 < 12; i2++) {
-            months.push({
-                label: enGB.localize.month(i2),
-                value: i2
-            });
+    function onDocumentTouchStart() {
+        if (currentInput.isTouch) {
+            return;
+        }
+        currentInput.isTouch = true;
+        if (window.performance) {
+            document.addEventListener("mousemove", onDocumentMouseMove);
         }
-        return months;
     }
 
-    function getYears(minDate, maxDate) {
-        var _a3, _b;
-        const minYear = (_a3 = minDate === null || minDate === void 0 ? void 0 : minDate.getFullYear()) !== null && _a3 !== void 0 ? _a3 : 1900;
-        const maxYear = (_b = maxDate === null || maxDate === void 0 ? void 0 : maxDate.getFullYear()) !== null && _b !== void 0 ? _b : 2100;
-        return lodash$1.exports.range(minYear, maxYear + 1, 1).map((val) => ({
-            label: val.toString(),
-            value: val
-        }));
+    function onDocumentMouseMove() {
+        var now2 = performance.now();
+        if (now2 - lastMouseMoveTime < 20) {
+            currentInput.isTouch = false;
+            document.removeEventListener("mousemove", onDocumentMouseMove);
+        }
+        lastMouseMoveTime = now2;
     }
-    const IGNORE_CLASSNAME = "react-datepicker-ignore-onclickoutside";
-    const DatepickerWrapper$1 = styled__default.default.div`
-    /* stylelint-disable selector-class-pattern */
-    display: flex;
-    flex-direction: ${(props) => props.inline ? "column" : "row"};
-    align-items: ${(props) => props.inline ? "baseline" : "center"};
 
-    width: 8.5rem;
+    function onWindowBlur() {
+        var activeElement = document.activeElement;
+        if (isReferenceElement(activeElement)) {
+            var instance2 = activeElement._tippy;
+            if (activeElement.blur && !instance2.state.isVisible) {
+                activeElement.blur();
+            }
+        }
+    }
 
-    color: ${(props) => props.theme.colors.text};
+    function bindGlobalEventListeners() {
+        document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
+        window.addEventListener("blur", onWindowBlur);
+    }
+    var isBrowser$1 = typeof window !== "undefined" && typeof document !== "undefined";
+    var ua = isBrowser$1 ? navigator.userAgent : "";
+    var isIE = /MSIE |Trident\//.test(ua);
+    var pluginProps = {
+        animateFill: false,
+        followCursor: false,
+        inlinePositioning: false,
+        sticky: false
+    };
+    var renderProps = {
+        allowHTML: false,
+        animation: "fade",
+        arrow: true,
+        content: "",
+        inertia: false,
+        maxWidth: 350,
+        role: "tooltip",
+        theme: "",
+        zIndex: 9999
+    };
+    var defaultProps$5 = Object.assign({
+        appendTo: function appendTo() {
+            return document.body;
+        },
+        aria: {
+            content: "auto",
+            expanded: "auto"
+        },
+        delay: 0,
+        duration: [300, 250],
+        getReferenceClientRect: null,
+        hideOnClick: true,
+        ignoreAttributes: false,
+        interactive: false,
+        interactiveBorder: 2,
+        interactiveDebounce: 0,
+        moveTransition: "",
+        offset: [0, 10],
+        onAfterUpdate: function onAfterUpdate() {},
+        onBeforeUpdate: function onBeforeUpdate() {},
+        onCreate: function onCreate() {},
+        onDestroy: function onDestroy() {},
+        onHidden: function onHidden() {},
+        onHide: function onHide() {},
+        onMount: function onMount() {},
+        onShow: function onShow() {},
+        onShown: function onShown() {},
+        onTrigger: function onTrigger() {},
+        onUntrigger: function onUntrigger() {},
+        onClickOutside: function onClickOutside() {},
+        placement: "top",
+        plugins: [],
+        popperOptions: {},
+        render: null,
+        showOnCreate: false,
+        touch: true,
+        trigger: "mouseenter focus",
+        triggerTarget: null
+    }, pluginProps, {}, renderProps);
+    var defaultKeys = Object.keys(defaultProps$5);
+    var setDefaultProps = function setDefaultProps2(partialProps) {
+        var keys2 = Object.keys(partialProps);
+        keys2.forEach(function(key) {
+            defaultProps$5[key] = partialProps[key];
+        });
+    };
 
-    .react-datepicker-popper {
-        z-index: 5;
-        width: 16.45rem;
-        height: 18.5rem;
+    function getExtendedPassedProps(passedProps) {
+        var plugins2 = passedProps.plugins || [];
+        var pluginProps2 = plugins2.reduce(function(acc, plugin) {
+            var name2 = plugin.name,
+                defaultValue2 = plugin.defaultValue;
+            if (name2) {
+                acc[name2] = passedProps[name2] !== void 0 ? passedProps[name2] : defaultValue2;
+            }
+            return acc;
+        }, {});
+        return Object.assign({}, passedProps, {}, pluginProps2);
     }
 
-    .react-datepicker-wrapper {
-        width: auto;
-        margin-top: 1rem;
-        margin-left: -8.5rem;
+    function getDataAttributeProps(reference2, plugins2) {
+        var propKeys = plugins2 ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps$5, {
+            plugins: plugins2
+        }))) : defaultKeys;
+        var props = propKeys.reduce(function(acc, key) {
+            var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
+            if (!valueAsString) {
+                return acc;
+            }
+            if (key === "content") {
+                acc[key] = valueAsString;
+            } else {
+                try {
+                    acc[key] = JSON.parse(valueAsString);
+                } catch (e3) {
+                    acc[key] = valueAsString;
+                }
+            }
+            return acc;
+        }, {});
+        return props;
+    }
 
-        ${(props) => {
-    if (props.showsRange && props.showsTime) {
-      return `margin-left: -19.045rem;
-                margin-top: 3rem;`;
+    function evaluateProps(reference2, props) {
+        var out = Object.assign({}, props, {
+            content: invokeWithArgsOrReturn(props.content, [reference2])
+        }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
+        out.aria = Object.assign({}, defaultProps$5.aria, {}, out.aria);
+        out.aria = {
+            expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
+            content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
+        };
+        return out;
     }
-    if (props.showsRange) {
-      return `
-    margin - left: -19.045 rem;
-    `;
+    var innerHTML = function innerHTML2() {
+        return "innerHTML";
+    };
+
+    function dangerouslySetInnerHTML(element2, html2) {
+        element2[innerHTML()] = html2;
     }
-    if (props.showsTime) {
-      return `
-    margin - left: -14 rem;
-    `;
+
+    function createArrowElement(value) {
+        var arrow2 = div();
+        if (value === true) {
+            arrow2.className = ARROW_CLASS;
+        } else {
+            arrow2.className = SVG_ARROW_CLASS;
+            if (isElement$2(value)) {
+                arrow2.appendChild(value);
+            } else {
+                dangerouslySetInnerHTML(arrow2, value);
+            }
+        }
+        return arrow2;
     }
-  }}
+
+    function setContent(content2, props) {
+        if (isElement$2(props.content)) {
+            dangerouslySetInnerHTML(content2, "");
+            content2.appendChild(props.content);
+        } else if (typeof props.content !== "function") {
+            if (props.allowHTML) {
+                dangerouslySetInnerHTML(content2, props.content);
+            } else {
+                content2.textContent = props.content;
+            }
+        }
     }
 
-    .react-datepicker {
-        width: 16.45rem;
-        height: 18.5rem;
+    function getChildren$1(popper2) {
+        var box = popper2.firstElementChild;
+        var boxChildren = arrayFrom(box.children);
+        return {
+            box,
+            content: boxChildren.find(function(node2) {
+                return node2.classList.contains(CONTENT_CLASS);
+            }),
+            arrow: boxChildren.find(function(node2) {
+                return node2.classList.contains(ARROW_CLASS) || node2.classList.contains(SVG_ARROW_CLASS);
+            }),
+            backdrop: boxChildren.find(function(node2) {
+                return node2.classList.contains(BACKDROP_CLASS);
+            })
+        };
+    }
 
-        font-family: Manrope, sans-serif;
-        font-size: 0.75rem;
+    function render(instance2) {
+        var popper2 = div();
+        var box = div();
+        box.className = BOX_CLASS;
+        box.setAttribute("data-state", "hidden");
+        box.setAttribute("tabindex", "-1");
+        var content2 = div();
+        content2.className = CONTENT_CLASS;
+        content2.setAttribute("data-state", "hidden");
+        setContent(content2, instance2.props);
+        popper2.appendChild(box);
+        box.appendChild(content2);
+        onUpdate(instance2.props, instance2.props);
 
-        background-color: ${(props) => props.theme.colors.grey1};
-        border: 1px solid ${(props) => props.theme.colors.grey1};
-        box-shadow: ${(props) => props.theme.shadow.light};
+        function onUpdate(prevProps, nextProps) {
+            var _getChildren = getChildren$1(popper2),
+                box2 = _getChildren.box,
+                content3 = _getChildren.content,
+                arrow2 = _getChildren.arrow;
+            if (nextProps.theme) {
+                box2.setAttribute("data-theme", nextProps.theme);
+            } else {
+                box2.removeAttribute("data-theme");
+            }
+            if (typeof nextProps.animation === "string") {
+                box2.setAttribute("data-animation", nextProps.animation);
+            } else {
+                box2.removeAttribute("data-animation");
+            }
+            if (nextProps.inertia) {
+                box2.setAttribute("data-inertia", "");
+            } else {
+                box2.removeAttribute("data-inertia");
+            }
+            box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
+            if (nextProps.role) {
+                box2.setAttribute("role", nextProps.role);
+            } else {
+                box2.removeAttribute("role");
+            }
+            if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
+                setContent(content3, instance2.props);
+            }
+            if (nextProps.arrow) {
+                if (!arrow2) {
+                    box2.appendChild(createArrowElement(nextProps.arrow));
+                } else if (prevProps.arrow !== nextProps.arrow) {
+                    box2.removeChild(arrow2);
+                    box2.appendChild(createArrowElement(nextProps.arrow));
+                }
+            } else if (arrow2) {
+                box2.removeChild(arrow2);
+            }
+        }
+        return {
+            popper: popper2,
+            onUpdate
+        };
+    }
+    render.$$tippy = true;
+    var idCounter$1 = 1;
+    var mouseMoveListeners = [];
+    var mountedInstances = [];
 
-        svg {
-            cursor: pointer;
+    function createTippy(reference2, passedProps) {
+        var props = evaluateProps(reference2, Object.assign({}, defaultProps$5, {}, getExtendedPassedProps(removeUndefinedProps(passedProps))));
+        var showTimeout;
+        var hideTimeout;
+        var scheduleHideAnimationFrame;
+        var isVisibleFromClick = false;
+        var didHideDueToDocumentMouseDown = false;
+        var didTouchMove = false;
+        var ignoreOnFirstUpdate = false;
+        var lastTriggerEvent;
+        var currentTransitionEndListener;
+        var onFirstUpdate;
+        var listeners = [];
+        var debouncedOnMouseMove = debounce$3(onMouseMove, props.interactiveDebounce);
+        var currentTarget;
+        var doc2 = getOwnerDocument(props.triggerTarget || reference2);
+        var id2 = idCounter$1++;
+        var popperInstance = null;
+        var plugins2 = unique(props.plugins);
+        var state = {
+            isEnabled: true,
+            isVisible: false,
+            isDestroyed: false,
+            isMounted: false,
+            isShown: false
+        };
+        var instance2 = {
+            id: id2,
+            reference: reference2,
+            popper: div(),
+            popperInstance,
+            props,
+            state,
+            plugins: plugins2,
+            clearDelayTimeouts,
+            setProps,
+            setContent: setContent2,
+            show,
+            hide: hide2,
+            hideWithInteractivity,
+            enable,
+            disable: disable2,
+            unmount,
+            destroy
+        };
+        if (!props.render) {
+            return instance2;
+        }
+        var _props$render = props.render(instance2),
+            popper2 = _props$render.popper,
+            onUpdate = _props$render.onUpdate;
+        popper2.setAttribute("data-tippy-root", "");
+        popper2.id = "tippy-" + instance2.id;
+        instance2.popper = popper2;
+        reference2._tippy = instance2;
+        popper2._tippy = instance2;
+        var pluginsHooks = plugins2.map(function(plugin) {
+            return plugin.fn(instance2);
+        });
+        var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
+        addListeners();
+        handleAriaExpandedAttribute();
+        handleStyles();
+        invokeHook("onCreate", [instance2]);
+        if (props.showOnCreate) {
+            scheduleShow();
         }
+        popper2.addEventListener("mouseenter", function() {
+            if (instance2.props.interactive && instance2.state.isVisible) {
+                instance2.clearDelayTimeouts();
+            }
+        });
+        popper2.addEventListener("mouseleave", function(event2) {
+            if (instance2.props.interactive && instance2.props.trigger.indexOf("mouseenter") >= 0) {
+                doc2.addEventListener("mousemove", debouncedOnMouseMove);
+                debouncedOnMouseMove(event2);
+            }
+        });
+        return instance2;
 
-        .react-datepicker__triangle {
-            visibility: hidden;
+        function getNormalizedTouchSettings() {
+            var touch = instance2.props.touch;
+            return Array.isArray(touch) ? touch : [touch, 0];
         }
 
-        .react-datepicker__input-time-container {
-            position: absolute;
-            top: -51px;
-            left: 150px;
+        function getIsCustomTouchBehavior() {
+            return getNormalizedTouchSettings()[0] === "hold";
+        }
 
-            float: none;
+        function getIsDefaultRenderFn() {
+            var _instance$props$rende;
+            return !!((_instance$props$rende = instance2.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
+        }
 
-            margin: 0;
+        function getCurrentTarget() {
+            return currentTarget || reference2;
+        }
 
-            color: ${(props) => props.theme.colors.text};
+        function getDefaultTemplateChildren() {
+            return getChildren$1(popper2);
+        }
 
-            .react-datepicker-time__caption {
-                display: none;
+        function getDelay(isShow) {
+            if (instance2.state.isMounted && !instance2.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
+                return 0;
             }
+            return getValueAtIndexOrReturn(instance2.props.delay, isShow ? 0 : 1, defaultProps$5.delay);
         }
 
-        .react-datepicker__month-container {
-            .react-datepicker__header {
-                margin-right: 3px;
-                margin-left: 3px;
-                padding: 1.25em 0.75em 0;
+        function handleStyles() {
+            popper2.style.pointerEvents = instance2.props.interactive && instance2.state.isVisible ? "" : "none";
+            popper2.style.zIndex = "" + instance2.props.zIndex;
+        }
 
-                color: ${(props) => props.theme.colors.text};
+        function invokeHook(hook, args, shouldInvokePropsHook) {
+            if (shouldInvokePropsHook === void 0) {
+                shouldInvokePropsHook = true;
+            }
+            pluginsHooks.forEach(function(pluginHooks) {
+                if (pluginHooks[hook]) {
+                    pluginHooks[hook].apply(void 0, args);
+                }
+            });
+            if (shouldInvokePropsHook) {
+                var _instance$props;
+                (_instance$props = instance2.props)[hook].apply(_instance$props, args);
+            }
+        }
 
-                background-color: ${(props) => props.theme.colors.grey1};
-                border: none;
+        function handleAriaContentAttribute() {
+            var aria2 = instance2.props.aria;
+            if (!aria2.content) {
+                return;
+            }
+            var attr = "aria-" + aria2.content;
+            var id3 = popper2.id;
+            var nodes = normalizeToArray(instance2.props.triggerTarget || reference2);
+            nodes.forEach(function(node2) {
+                var currentValue = node2.getAttribute(attr);
+                if (instance2.state.isVisible) {
+                    node2.setAttribute(attr, currentValue ? currentValue + " " + id3 : id3);
+                } else {
+                    var nextValue = currentValue && currentValue.replace(id3, "").trim();
+                    if (nextValue) {
+                        node2.setAttribute(attr, nextValue);
+                    } else {
+                        node2.removeAttribute(attr);
+                    }
+                }
+            });
+        }
 
-                .react-datepicker__day-names {
-                    display: flex;
-                    gap: 0.125rem;
-                    justify-content: space-around;
-                    margin-bottom: 0;
+        function handleAriaExpandedAttribute() {
+            if (hasAriaExpanded || !instance2.props.aria.expanded) {
+                return;
+            }
+            var nodes = normalizeToArray(instance2.props.triggerTarget || reference2);
+            nodes.forEach(function(node2) {
+                if (instance2.props.interactive) {
+                    node2.setAttribute("aria-expanded", instance2.state.isVisible && node2 === getCurrentTarget() ? "true" : "false");
+                } else {
+                    node2.removeAttribute("aria-expanded");
+                }
+            });
+        }
 
-                    .react-datepicker__day-name {
-                        width: 2rem;
-                        height: 2rem;
-                        margin: 0;
+        function cleanupInteractiveMouseListeners() {
+            doc2.removeEventListener("mousemove", debouncedOnMouseMove);
+            mouseMoveListeners = mouseMoveListeners.filter(function(listener2) {
+                return listener2 !== debouncedOnMouseMove;
+            });
+        }
 
-                        line-height: 2rem;
-                        color: ${(props) => props.theme.colors.text};
-                    }
+        function onDocumentPress(event2) {
+            if (currentInput.isTouch) {
+                if (didTouchMove || event2.type === "mousedown") {
+                    return;
+                }
+            }
+            if (instance2.props.interactive && popper2.contains(event2.target)) {
+                return;
+            }
+            if (getCurrentTarget().contains(event2.target)) {
+                if (currentInput.isTouch) {
+                    return;
+                }
+                if (instance2.state.isVisible && instance2.props.trigger.indexOf("click") >= 0) {
+                    return;
+                }
+            } else {
+                invokeHook("onClickOutside", [instance2, event2]);
+            }
+            if (instance2.props.hideOnClick === true) {
+                instance2.clearDelayTimeouts();
+                instance2.hide();
+                didHideDueToDocumentMouseDown = true;
+                setTimeout(function() {
+                    didHideDueToDocumentMouseDown = false;
+                });
+                if (!instance2.state.isMounted) {
+                    removeDocumentPress();
                 }
             }
+        }
 
-            .react-datepicker__month {
-                display: grid;
-                gap: 0.125rem;
+        function onTouchMove() {
+            didTouchMove = true;
+        }
 
-                /* Switch default margin to padding so it applies background color completely */
-                margin: 0;
-                padding: 0.125rem 0.75rem 0;
+        function onTouchStart() {
+            didTouchMove = false;
+        }
 
-                color: ${(props) => props.theme.colors.text};
+        function addDocumentPress() {
+            doc2.addEventListener("mousedown", onDocumentPress, true);
+            doc2.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
+            doc2.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
+            doc2.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
+        }
 
-                background-color: ${(props) => props.theme.colors.grey1};
+        function removeDocumentPress() {
+            doc2.removeEventListener("mousedown", onDocumentPress, true);
+            doc2.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
+            doc2.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
+            doc2.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
+        }
 
-                .react-datepicker__week {
-                    display: flex;
-                    gap: 0.125rem;
+        function onTransitionedOut(duration, callback) {
+            onTransitionEnd(duration, function() {
+                if (!instance2.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
+                    callback();
                 }
+            });
+        }
 
-                .react-datepicker__day {
-                    width: 2rem;
-                    height: 2rem;
-                    margin: 0;
-
-                    line-height: 2rem;
-                    color: ${(props) => props.theme.colors.text};
+        function onTransitionedIn(duration, callback) {
+            onTransitionEnd(duration, callback);
+        }
 
-                    :hover {
-                        background-color: ${(props) => props.theme.colors.grey2};
-                    }
+        function onTransitionEnd(duration, callback) {
+            var box = getDefaultTemplateChildren().box;
 
-                    &.react-datepicker__day--outside-month {
-                        color: ${(props) => props.theme.colors.grey4};
-                    }
+            function listener2(event2) {
+                if (event2.target === box) {
+                    updateTransitionEndListener(box, "remove", listener2);
+                    callback();
+                }
+            }
+            if (duration === 0) {
+                return callback();
+            }
+            updateTransitionEndListener(box, "remove", currentTransitionEndListener);
+            updateTransitionEndListener(box, "add", listener2);
+            currentTransitionEndListener = listener2;
+        }
 
-                    &.react-datepicker__day--selected {
-                        color: ${(props) => props.theme.colors.blue1};
-                        background-color: ${(props) => props.theme.colors.primary};
+        function on(eventType, handler, options) {
+            if (options === void 0) {
+                options = false;
+            }
+            var nodes = normalizeToArray(instance2.props.triggerTarget || reference2);
+            nodes.forEach(function(node2) {
+                node2.addEventListener(eventType, handler, options);
+                listeners.push({
+                    node: node2,
+                    eventType,
+                    handler,
+                    options
+                });
+            });
+        }
 
-                        :hover {
-                            background-color: ${(props) => props.theme.colors.primaryHover};
-                        }
-                    }
+        function addListeners() {
+            if (getIsCustomTouchBehavior()) {
+                on("touchstart", onTrigger, {
+                    passive: true
+                });
+                on("touchend", onMouseLeave, {
+                    passive: true
+                });
+            }
+            splitBySpaces(instance2.props.trigger).forEach(function(eventType) {
+                if (eventType === "manual") {
+                    return;
+                }
+                on(eventType, onTrigger);
+                switch (eventType) {
+                    case "mouseenter":
+                        on("mouseleave", onMouseLeave);
+                        break;
+                    case "focus":
+                        on(isIE ? "focusout" : "blur", onBlurOrFocusOut);
+                        break;
+                    case "focusin":
+                        on("focusout", onBlurOrFocusOut);
+                        break;
+                }
+            });
+        }
 
-                    &.react-datepicker__day--keyboard-selected {
-                        color: ${(props) => props.theme.colors.text};
-                        background-color: ${(props) => curriedTransparentize$2(0.8, props.theme.colors.primary)};
-                        border: 1px solid ${(props) => props.theme.colors.primary}
+        function removeListeners() {
+            listeners.forEach(function(_ref2) {
+                var node2 = _ref2.node,
+                    eventType = _ref2.eventType,
+                    handler = _ref2.handler,
+                    options = _ref2.options;
+                node2.removeEventListener(eventType, handler, options);
+            });
+            listeners = [];
+        }
 
-                        :hover {
-                            background-color: ${(props) => curriedTransparentize$2(0.6, props.theme.colors.primary)};
-                        }
-                    }
+        function onTrigger(event2) {
+            var _lastTriggerEvent;
+            var shouldScheduleClickHide = false;
+            if (!instance2.state.isEnabled || isEventListenerStopped(event2) || didHideDueToDocumentMouseDown) {
+                return;
+            }
+            var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
+            lastTriggerEvent = event2;
+            currentTarget = event2.currentTarget;
+            handleAriaExpandedAttribute();
+            if (!instance2.state.isVisible && isMouseEvent(event2)) {
+                mouseMoveListeners.forEach(function(listener2) {
+                    return listener2(event2);
+                });
+            }
+            if (event2.type === "click" && (instance2.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance2.props.hideOnClick !== false && instance2.state.isVisible) {
+                shouldScheduleClickHide = true;
+            } else {
+                scheduleShow(event2);
+            }
+            if (event2.type === "click") {
+                isVisibleFromClick = !shouldScheduleClickHide;
+            }
+            if (shouldScheduleClickHide && !wasFocused) {
+                scheduleHide(event2);
+            }
+        }
 
-                    &.react-datepicker__day--in-range {
-                        color: ${(props) => props.theme.colors.blue1};
-                        background-color: ${(props) => curriedTransparentize$2(0.2, props.theme.colors.primary)};
-                    }
+        function onMouseMove(event2) {
+            var target = event2.target;
+            var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
+            if (event2.type === "mousemove" && isCursorOverReferenceOrPopper) {
+                return;
+            }
+            var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
+                var _instance$popperInsta;
+                var instance3 = popper3._tippy;
+                var state2 = (_instance$popperInsta = instance3.popperInstance) == null ? void 0 : _instance$popperInsta.state;
+                if (state2) {
+                    return {
+                        popperRect: popper3.getBoundingClientRect(),
+                        popperState: state2,
+                        props
+                    };
+                }
+                return null;
+            }).filter(Boolean);
+            if (isCursorOutsideInteractiveBorder(popperTreeData, event2)) {
+                cleanupInteractiveMouseListeners();
+                scheduleHide(event2);
+            }
+        }
 
-                    &.react-datepicker__day--in-selecting-range {
-                        color: ${(props) => props.theme.colors.blue1};
-                        background-color: ${(props) => props.theme.colors.primary};
-                    }
+        function onMouseLeave(event2) {
+            var shouldBail = isEventListenerStopped(event2) || instance2.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
+            if (shouldBail) {
+                return;
+            }
+            if (instance2.props.interactive) {
+                instance2.hideWithInteractivity(event2);
+                return;
+            }
+            scheduleHide(event2);
+        }
 
-                    &.react-datepicker__day--selecting-range-end {
-                        font-weight: normal;
-                        color: ${(props) => props.theme.colors.blue1};
-                        background-color: ${(props) => props.theme.colors.primary};
-                    }
+        function onBlurOrFocusOut(event2) {
+            if (instance2.props.trigger.indexOf("focusin") < 0 && event2.target !== getCurrentTarget()) {
+                return;
+            }
+            if (instance2.props.interactive && event2.relatedTarget && popper2.contains(event2.relatedTarget)) {
+                return;
+            }
+            scheduleHide(event2);
+        }
 
-                    &.react-datepicker__day--disabled {
-                        color: ${(props) => props.theme.colors.grey3};
+        function isEventListenerStopped(event2) {
+            return currentInput.isTouch ? getIsCustomTouchBehavior() !== event2.type.indexOf("touch") >= 0 : false;
+        }
 
-                        :hover {
-                            background-color: ${(props) => props.theme.colors.grey1};
-                        }
+        function createPopperInstance() {
+            destroyPopperInstance();
+            var _instance$props2 = instance2.props,
+                popperOptions = _instance$props2.popperOptions,
+                placement = _instance$props2.placement,
+                offset2 = _instance$props2.offset,
+                getReferenceClientRect = _instance$props2.getReferenceClientRect,
+                moveTransition = _instance$props2.moveTransition;
+            var arrow2 = getIsDefaultRenderFn() ? getChildren$1(popper2).arrow : null;
+            var computedReference = getReferenceClientRect ? {
+                getBoundingClientRect: getReferenceClientRect,
+                contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
+            } : reference2;
+            var tippyModifier = {
+                name: "$$tippy",
+                enabled: true,
+                phase: "beforeWrite",
+                requires: ["computeStyles"],
+                fn: function fn2(_ref2) {
+                    var state2 = _ref2.state;
+                    if (getIsDefaultRenderFn()) {
+                        var _getDefaultTemplateCh = getDefaultTemplateChildren(),
+                            box = _getDefaultTemplateCh.box;
+                        ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
+                            if (attr === "placement") {
+                                box.setAttribute("data-placement", state2.placement);
+                            } else {
+                                if (state2.attributes.popper["data-popper-" + attr]) {
+                                    box.setAttribute("data-" + attr, "");
+                                } else {
+                                    box.removeAttribute("data-" + attr);
+                                }
+                            }
+                        });
+                        state2.attributes.popper = {};
+                    }
+                }
+            };
+            var modifiers2 = [{
+                name: "offset",
+                options: {
+                    offset: offset2
+                }
+            }, {
+                name: "preventOverflow",
+                options: {
+                    padding: {
+                        top: 2,
+                        bottom: 2,
+                        left: 5,
+                        right: 5
                     }
                 }
+            }, {
+                name: "flip",
+                options: {
+                    padding: 5
+                }
+            }, {
+                name: "computeStyles",
+                options: {
+                    adaptive: !moveTransition
+                }
+            }, tippyModifier];
+            if (getIsDefaultRenderFn() && arrow2) {
+                modifiers2.push({
+                    name: "arrow",
+                    options: {
+                        element: arrow2,
+                        padding: 3
+                    }
+                });
             }
+            modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
+            instance2.popperInstance = createPopper$1(computedReference, popper2, Object.assign({}, popperOptions, {
+                placement,
+                onFirstUpdate,
+                modifiers: modifiers2
+            }));
         }
-    }
-    /* stylelint-enable selector-class-pattern */
-`;
-    const DatepickerInputs = styled__default.default.div`
-    display: flex;
-    gap: 0.5rem;
-`;
-    const HeaderWrapper = styled__default.default.div`
-    display: flex;
-    flex-direction: column;
-    align-items: center;
-    padding-bottom: 0.75rem;
-`;
-    const MonthNavigation = styled__default.default.div`
-    display: flex;
-    align-items: center;
-    justify-content: space-between;
-`;
-    const DropdownsWrapper = styled__default.default.div`
-    display: flex;
-    align-items: center;
-    justify-content: center;
-`;
-    const MonthButton = styled__default.default(Button$3)`
-    min-width: 0;
-    height: 1.5rem;
-    margin: 0;
-    padding: 0.75rem 0.37rem;
-
-    svg {
-        width: 0.75rem;
-        height: 0.75rem;
-        color: ${(props) => props.theme.colors.grey5};
-    }
 
-    :hover:not(:disabled) {
-        svg {
-            color: ${(props) => props.theme.colors.text};
+        function destroyPopperInstance() {
+            if (instance2.popperInstance) {
+                instance2.popperInstance.destroy();
+                instance2.popperInstance = null;
+            }
         }
-    }
-`;
-    const MonthSelect = styled__default.default(DatepickerSelect)`
-    width: 6.25rem;
-    margin-right: 0.55em;
-    font-size: 0.875rem;
-`;
-    const YearSelect = styled__default.default(DatepickerSelect)`
-    width: 3.75rem;
-    margin-right: 0.8em;
-`;
-    const EndDateInputWrapper = styled__default.default.div`
-    display: flex;
-    gap: 0.5rem;
-    align-items: center;
-`;
-    const DateTimeWrapper = styled__default.default.div`
-    display: flex;
-    flex-direction: ${(props) => props.isRange ? "column" : "row"};
-    gap: ${(props) => props.isRange ? "none" : "0.5rem"};
-`;
-    const DateInput = styled__default.default.input`
-    display: flex;
-    align-items: center;
-
-    width: 8.5rem;
-    height: 2.5rem;
-    padding: 0 1rem;
-
-    font-size: 1rem;
-    color: ${(props) => props.disabled ? props.theme.colors.grey2 : props.theme.colors.text};
-    text-align: center;
-
-    background-color: ${(props) => props.theme.colors.grey1};
-    border: 1px solid ${(props) => props.theme.colors.grey1};
-    border-radius: 0.25rem;
-    border-radius: ${(props) => props.isTimeRange ? "0.25rem 0.25rem 0rem 0rem" : "0.25rem"};
-    outline: 0;
-
-    :focus:not(:disabled) {
-        border: 1px solid ${(props) => props.theme.colors.grey3};
-    }
-
-    :hover:not(:disabled) {
-        background-color: ${(props) => props.theme.colors.grey2};
-    }
-
-    :disabled {
-        cursor: not-allowed;
-    }
-
-    ::placeholder {
-        font-style: italic;
-    }
-
-    ::-webkit-calendar-picker-indicator {
-        display: none;
-        background: none;
-    }
-`;
-    const TimeInput = styled__default.default(Input$3)`
-    width: ${(props) => props.isRange ? "8.5rem" : "5rem"};
-
-    input {
-        position: relative;
-
-        display: flex;
-        justify-content: center;
-
-        padding: 0.5rem;
-
-        font-size: 1rem;
-        color: ${(props) => props.theme.colors.text};
-        text-align: center;
-
-        border-radius: ${(props) => props.isRange ? "0rem 0rem 0.25rem 0.25rem" : "0.25rem"};
 
-        :focus:not(:disabled) {
-            border: 1px solid ${(props) => props.theme.colors.grey3};
+        function mount() {
+            var appendTo = instance2.props.appendTo;
+            var parentNode;
+            var node2 = getCurrentTarget();
+            if (instance2.props.interactive && appendTo === defaultProps$5.appendTo || appendTo === "parent") {
+                parentNode = node2.parentNode;
+            } else {
+                parentNode = invokeWithArgsOrReturn(appendTo, [node2]);
+            }
+            if (!parentNode.contains(popper2)) {
+                parentNode.appendChild(popper2);
+            }
+            createPopperInstance();
         }
 
-        ::-webkit-calendar-picker-indicator {
-            display: none;
-            background: none;
+        function getNestedPopperTree() {
+            return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
         }
 
-        ::after {
-            content: '';
-
-            position: absolute;
-            top: 0;
-            left: 1.2rem;
-
-            display: block;
-
-            width: 6rem;
-
-            border-top: ${(props) => props.isRange ? `1px solid ${props.theme.colors.grey2}` : "none"};
+        function scheduleShow(event2) {
+            instance2.clearDelayTimeouts();
+            if (event2) {
+                invokeHook("onTrigger", [instance2, event2]);
+            }
+            addDocumentPress();
+            var delay = getDelay(true);
+            var _getNormalizedTouchSe = getNormalizedTouchSettings(),
+                touchValue = _getNormalizedTouchSe[0],
+                touchDelay = _getNormalizedTouchSe[1];
+            if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
+                delay = touchDelay;
+            }
+            if (delay) {
+                showTimeout = setTimeout(function() {
+                    instance2.show();
+                }, delay);
+            } else {
+                instance2.show();
+            }
         }
-    }
-`;
 
-    function DatePickerHeader({
-        date,
-        changeMonth,
-        changeYear,
-        decreaseMonth,
-        increaseMonth,
-        selectItemClass,
-        portalsRef,
-        minDate,
-        maxDate
-    }) {
-        const months = React.useMemo(() => getMonths(), []);
-        const years = React.useMemo(() => getYears(minDate, maxDate), [minDate, maxDate]);
-        const selectedMonth = React.useMemo(() => {
-            return {
-                label: enGB.localize.month(date.getMonth()),
-                value: date.getMonth()
-            };
-        }, [date]);
-        const selectedYear = React.useMemo(() => ({
-            label: date.getFullYear().toString(),
-            value: date.getFullYear()
-        }), [date]);
-        return jsxRuntime.exports.jsx(HeaderWrapper, {
-            children: jsxRuntime.exports.jsxs(DropdownsWrapper, {
-                children: [jsxRuntime.exports.jsx(MonthSelect, {
-                    displacement: -1.1,
-                    dropdownRef: (element2) => {
-                        if (portalsRef) {
-                            portalsRef.current[0] = element2;
-                        }
-                    },
-                    itemClass: `${IGNORE_CLASSNAME} ${selectItemClass}`,
-                    items: months,
-                    onSelect: (item) => changeMonth(item.value),
-                    selectedItem: selectedMonth,
-                    size: 0.875
-                }), jsxRuntime.exports.jsx(YearSelect, {
-                    displacement: -7.8,
-                    dropdownRef: (element2) => {
-                        if (portalsRef) {
-                            portalsRef.current[1] = element2;
-                        }
-                    },
-                    itemClass: `${IGNORE_CLASSNAME} ${selectItemClass}`,
-                    items: years,
-                    onSelect: (item) => changeYear(item.value),
-                    selectedItem: selectedYear,
-                    size: 0.875
-                }), jsxRuntime.exports.jsxs(MonthNavigation, {
-                    children: [jsxRuntime.exports.jsx(MonthButton, {
-                        onClick: decreaseMonth,
-                        styling: "ghost",
-                        children: jsxRuntime.exports.jsx(ChevronLeft, {})
-                    }), jsxRuntime.exports.jsx(MonthButton, {
-                        onClick: increaseMonth,
-                        styling: "ghost",
-                        children: jsxRuntime.exports.jsx(ChevronRight, {})
-                    })]
-                })]
-            })
-        });
-    }
+        function scheduleHide(event2) {
+            instance2.clearDelayTimeouts();
+            invokeHook("onUntrigger", [instance2, event2]);
+            if (!instance2.state.isVisible) {
+                removeDocumentPress();
+                return;
+            }
+            if (instance2.props.trigger.indexOf("mouseenter") >= 0 && instance2.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event2.type) >= 0 && isVisibleFromClick) {
+                return;
+            }
+            var delay = getDelay(false);
+            if (delay) {
+                hideTimeout = setTimeout(function() {
+                    if (instance2.state.isVisible) {
+                        instance2.hide();
+                    }
+                }, delay);
+            } else {
+                scheduleHideAnimationFrame = requestAnimationFrame(function() {
+                    instance2.hide();
+                });
+            }
+        }
 
-    function getTimeFormatted(time) {
-        const timeString = String(time);
-        if (timeString.length > 1) {
-            return timeString;
+        function enable() {
+            instance2.state.isEnabled = true;
         }
-        return `0${timeString}`;
-    }
 
-    function getInitialTime(initialDate, isRange) {
-        if (!initialDate) {
-            if (isRange) {
-                return ["00:00", "00:00"];
-            }
-            return "00:00";
+        function disable2() {
+            instance2.hide();
+            instance2.state.isEnabled = false;
         }
-        if (Array.isArray(initialDate)) {
-            return [
-                `${getTimeFormatted(initialDate[0].getHours())}:${getTimeFormatted(initialDate[0].getMinutes())}`,
-                `${getTimeFormatted(initialDate[1].getHours())}:${getTimeFormatted(initialDate[1].getMinutes())}`
-            ];
+
+        function clearDelayTimeouts() {
+            clearTimeout(showTimeout);
+            clearTimeout(hideTimeout);
+            cancelAnimationFrame(scheduleHideAnimationFrame);
         }
-        return `${getTimeFormatted(initialDate.getHours())}:${getTimeFormatted(initialDate.getMinutes())}`;
-    }
 
-    function getInitialDate(initialDate, formatToApply, isStart) {
-        let formattedDate = "";
-        if (initialDate) {
-            if (Array.isArray(initialDate)) {
-                formattedDate = format$2(initialDate[isStart ? 0 : 1], formatToApply);
-            } else {
-                formattedDate = format$2(initialDate, formatToApply);
+        function setProps(partialProps) {
+            if (instance2.state.isDestroyed) {
+                return;
+            }
+            invokeHook("onBeforeUpdate", [instance2, partialProps]);
+            removeListeners();
+            var prevProps = instance2.props;
+            var nextProps = evaluateProps(reference2, Object.assign({}, instance2.props, {}, partialProps, {
+                ignoreAttributes: true
+            }));
+            instance2.props = nextProps;
+            addListeners();
+            if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
+                cleanupInteractiveMouseListeners();
+                debouncedOnMouseMove = debounce$3(onMouseMove, nextProps.interactiveDebounce);
+            }
+            if (prevProps.triggerTarget && !nextProps.triggerTarget) {
+                normalizeToArray(prevProps.triggerTarget).forEach(function(node2) {
+                    node2.removeAttribute("aria-expanded");
+                });
+            } else if (nextProps.triggerTarget) {
+                reference2.removeAttribute("aria-expanded");
+            }
+            handleAriaExpandedAttribute();
+            handleStyles();
+            if (onUpdate) {
+                onUpdate(prevProps, nextProps);
+            }
+            if (instance2.popperInstance) {
+                createPopperInstance();
+                getNestedPopperTree().forEach(function(nestedPopper) {
+                    requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
+                });
             }
+            invokeHook("onAfterUpdate", [instance2, partialProps]);
         }
-        return formattedDate;
-    }
 
-    function getNewDatetime(date, time) {
-        var _a3, _b, _c, _d, _e2;
-        if (!Array.isArray(date) && !Array.isArray(time)) {
-            const [hours, minutes] = (_a3 = time === null || time === void 0 ? void 0 : time.split(":")) !== null && _a3 !== void 0 ? _a3 : ["00", "00"];
-            const newDate = date ? new Date(date.setHours(Number(hours), Number(minutes))) : null;
-            return newDate;
+        function setContent2(content2) {
+            instance2.setProps({
+                content: content2
+            });
         }
-        const [startHours, startMinutes] = (_c = (_b = time[0]) === null || _b === void 0 ? void 0 : _b.split(":")) !== null && _c !== void 0 ? _c : ["00", "00"];
-        const [endHours, endMinutes] = (_e2 = (_d = time[1]) === null || _d === void 0 ? void 0 : _d.split(":")) !== null && _e2 !== void 0 ? _e2 : ["00", "00"];
-        const dates = date;
-        const startDate = dates[0] ? new Date(dates[0].setHours(Number(startHours), Number(startMinutes))) : null;
-        const endDate = dates[1] ? new Date(dates[1].setHours(Number(endHours), Number(endMinutes))) : null;
-        return [startDate, endDate];
-    }
 
-    function DatePicker(props) {
-        var _a3, _b, _c;
-        const value = (_a3 = props.value) !== null && _a3 !== void 0 ? _a3 : props.initialValue;
-        const [selectedDate, setSelectedDate] = React.useState(value || (props.selectsRange ? [null, null] : null));
-        const [selectedTime, setSelectedTime] = React.useState(() => getInitialTime(value, props.selectsRange));
-        const formatToApply = (_b = props.dateFormat) !== null && _b !== void 0 ? _b : "dd/MM/yyyy";
-        const [startDate, setStartDate] = React.useState(() => getInitialDate(value, formatToApply, true));
-        const [endDate, setEndDate] = React.useState(() => getInitialDate(value, formatToApply, false));
-        const [isSelectingStart, setIsSelectingStart] = React.useState(null);
-        const selectedDateRef = React.useRef(selectedDate);
-        selectedDateRef.current = selectedDate;
-        const datepickerRef = React.useRef(null);
-        const extraProps = React.useMemo(() => {
-            if (props.selectsRange) {
-                const selectedDates = selectedDate !== null && selectedDate !== void 0 ? selectedDate : [null, null];
-                let {
-                    minDate
-                } = props;
-                if (!isSelectingStart) {
-                    const [currentStartDate] = selectedDates;
-                    minDate = currentStartDate;
-                }
-                return {
-                    endDate: selectedDates[1],
-                    minDate,
-                    startDate: selectedDates[0]
-                };
+        function show() {
+            var isAlreadyVisible = instance2.state.isVisible;
+            var isDestroyed = instance2.state.isDestroyed;
+            var isDisabled = !instance2.state.isEnabled;
+            var isTouchAndTouchDisabled = currentInput.isTouch && !instance2.props.touch;
+            var duration = getValueAtIndexOrReturn(instance2.props.duration, 0, defaultProps$5.duration);
+            if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
+                return;
             }
-            let date = selectedDate;
-            if (Array.isArray(selectedDate)) {
-                [date] = selectedDate;
+            if (getCurrentTarget().hasAttribute("disabled")) {
+                return;
             }
-            return {
-                selected: date
-            };
-        }, [selectedDate, isSelectingStart, props]);
-        const onChangeDate = (date) => {
-            var _a4;
-            if (props.shouldCloseOnSelect) {
-                (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.setOpen(false);
+            invokeHook("onShow", [instance2], false);
+            if (instance2.props.onShow(instance2) === false) {
+                return;
             }
-            if (props.selectsRange) {
-                let currentStartDate;
-                let currentEndDate;
-                if (isSelectingStart) {
-                    currentStartDate = date;
-                    currentEndDate = Array.isArray(selectedDate) ? selectedDate[1] : null;
-                    currentEndDate = currentEndDate && currentEndDate > date ? currentEndDate : date;
-                } else {
-                    currentStartDate = Array.isArray(selectedDate) ? selectedDate[0] : null;
-                    currentEndDate = date;
-                }
-                setStartDate(format$2(currentStartDate, formatToApply));
-                setEndDate(format$2(currentEndDate, formatToApply));
-                setSelectedDate([currentStartDate, currentEndDate]);
-            } else {
-                setSelectedDate(date);
-                setStartDate(format$2(date, formatToApply));
+            instance2.state.isVisible = true;
+            if (getIsDefaultRenderFn()) {
+                popper2.style.visibility = "visible";
             }
-        };
-        const onChangeDateInput = (isStartDate, e3) => {
-            var _a4;
-            const target = e3.target;
-            const newDate = parse$9(target.value, formatToApply, new Date());
-            if (newDate instanceof Date && !Number.isNaN(newDate.valueOf()) && !(newDate < props.minDate) && !(newDate > props.maxDate)) {
-                (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.setState({
-                    preSelection: newDate
-                });
-                if (Array.isArray(selectedDate)) {
-                    if (isStartDate) {
-                        let end2 = selectedDate[1];
-                        if (newDate > end2) {
-                            end2 = newDate;
-                            setEndDate(target.value);
-                        }
-                        setSelectedDate([newDate, end2]);
-                        setStartDate(target.value);
-                        return;
-                    }
-                    let start2 = selectedDate[0];
-                    if (newDate < start2) {
-                        start2 = newDate;
-                        setStartDate(target.value);
-                    }
-                    setSelectedDate([start2, newDate]);
-                    setEndDate(target.value);
+            handleStyles();
+            addDocumentPress();
+            if (!instance2.state.isMounted) {
+                popper2.style.transition = "none";
+            }
+            if (getIsDefaultRenderFn()) {
+                var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
+                    box = _getDefaultTemplateCh2.box,
+                    content2 = _getDefaultTemplateCh2.content;
+                setTransitionDuration([box, content2], 0);
+            }
+            onFirstUpdate = function onFirstUpdate2() {
+                if (!instance2.state.isVisible || ignoreOnFirstUpdate) {
                     return;
                 }
-                setSelectedDate(newDate);
+                ignoreOnFirstUpdate = true;
+                void popper2.offsetHeight;
+                popper2.style.transition = instance2.props.moveTransition;
+                if (getIsDefaultRenderFn() && instance2.props.animation) {
+                    var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
+                        _box = _getDefaultTemplateCh3.box,
+                        _content = _getDefaultTemplateCh3.content;
+                    setTransitionDuration([_box, _content], duration);
+                    setVisibilityState([_box, _content], "visible");
+                }
+                handleAriaContentAttribute();
+                handleAriaExpandedAttribute();
+                pushIfUnique(mountedInstances, instance2);
+                instance2.state.isMounted = true;
+                invokeHook("onMount", [instance2]);
+                if (instance2.props.animation && getIsDefaultRenderFn()) {
+                    onTransitionedIn(duration, function() {
+                        instance2.state.isShown = true;
+                        invokeHook("onShown", [instance2]);
+                    });
+                }
+            };
+            mount();
+        }
+
+        function hide2() {
+            var isAlreadyHidden = !instance2.state.isVisible;
+            var isDestroyed = instance2.state.isDestroyed;
+            var isDisabled = !instance2.state.isEnabled;
+            var duration = getValueAtIndexOrReturn(instance2.props.duration, 1, defaultProps$5.duration);
+            if (isAlreadyHidden || isDestroyed || isDisabled) {
+                return;
             }
-            if (!isStartDate) {
-                setEndDate(target.value);
+            invokeHook("onHide", [instance2], false);
+            if (instance2.props.onHide(instance2) === false) {
                 return;
             }
-            setStartDate(target.value);
-        };
-        const onChangeTime = (time, isStartTime) => {
-            if (time) {
-                if (Array.isArray(selectedTime)) {
-                    if (isStartTime) {
-                        setSelectedTime([time, selectedTime[1]]);
-                        return;
-                    }
-                    setSelectedTime([selectedTime[0], time]);
-                    return;
+            instance2.state.isVisible = false;
+            instance2.state.isShown = false;
+            ignoreOnFirstUpdate = false;
+            isVisibleFromClick = false;
+            if (getIsDefaultRenderFn()) {
+                popper2.style.visibility = "hidden";
+            }
+            cleanupInteractiveMouseListeners();
+            removeDocumentPress();
+            handleStyles();
+            if (getIsDefaultRenderFn()) {
+                var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
+                    box = _getDefaultTemplateCh4.box,
+                    content2 = _getDefaultTemplateCh4.content;
+                if (instance2.props.animation) {
+                    setTransitionDuration([box, content2], duration);
+                    setVisibilityState([box, content2], "hidden");
                 }
-                setSelectedTime(time);
             }
-        };
-        React.useEffect(() => {
-            var _a4;
-            const newValue = (_a4 = props.value) !== null && _a4 !== void 0 ? _a4 : props.initialValue;
-            const newDate = newValue || (props.selectsRange ? [null, null] : null);
-            if (JSON.stringify(newDate) === JSON.stringify(selectedDateRef.current)) {
+            handleAriaContentAttribute();
+            handleAriaExpandedAttribute();
+            if (instance2.props.animation) {
+                if (getIsDefaultRenderFn()) {
+                    onTransitionedOut(duration, instance2.unmount);
+                }
+            } else {
+                instance2.unmount();
+            }
+        }
+
+        function hideWithInteractivity(event2) {
+            doc2.addEventListener("mousemove", debouncedOnMouseMove);
+            pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
+            debouncedOnMouseMove(event2);
+        }
+
+        function unmount() {
+            if (instance2.state.isVisible) {
+                instance2.hide();
+            }
+            if (!instance2.state.isMounted) {
                 return;
             }
-            setSelectedDate(newDate);
-            const newTime = getInitialTime(newValue, props.selectsRange);
-            setSelectedTime(newTime);
-            const newStartDate = getInitialDate(newValue, formatToApply, true);
-            setStartDate(newStartDate);
-            const newEndDate = getInitialDate(newValue, formatToApply, false);
-            setEndDate(newEndDate);
-        }, [props.value, props.initialValue]);
-        React.useEffect(() => {
-            var _a4;
-            let time = selectedTime;
-            if (props.selectsRange && !Array.isArray(selectedTime)) {
-                time = [selectedTime, "00:00"];
-                setSelectedTime([selectedTime, "00:00"]);
+            destroyPopperInstance();
+            getNestedPopperTree().forEach(function(nestedPopper) {
+                nestedPopper._tippy.unmount();
+            });
+            if (popper2.parentNode) {
+                popper2.parentNode.removeChild(popper2);
             }
-            const newDateTime = getNewDatetime(selectedDate, time);
-            (_a4 = props.onChange) === null || _a4 === void 0 ? void 0 : _a4.call(props, newDateTime);
-        }, [selectedDate, selectedTime]);
-        return jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, {
-            children: jsxRuntime.exports.jsx(Tooltip$1, {
-                content: props.errorMsg,
-                disabled: !props.errorMsg,
-                styling: "error",
-                children: jsxRuntime.exports.jsxs(DatepickerWrapper$1, {
-                    inline: props.inline,
-                    showsRange: props.selectsRange,
-                    showsTime: props.showTimeInput,
-                    children: [jsxRuntime.exports.jsxs(DatepickerInputs, {
-                        children: [jsxRuntime.exports.jsxs(DateTimeWrapper, {
-                            isRange: props.selectsRange,
-                            children: [jsxRuntime.exports.jsx(DateInput, {
-                                isTimeRange: props.selectsRange && props.showTimeInput,
-                                onChange: (e3) => {
-                                    onChangeDateInput(true, e3);
-                                },
-                                onClick: () => {
-                                    var _a4;
-                                    setIsSelectingStart(true);
-                                    (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.setOpen(true);
-                                },
-                                onFocus: () => {
-                                    var _a4;
-                                    setIsSelectingStart(true);
-                                    (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.setOpen(true);
-                                },
-                                onKeyDown: (e3) => {
-                                    var _a4;
-                                    (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.onInputKeyDown(e3);
-                                },
-                                placeholder: formatToApply,
-                                value: startDate
-                            }), props.showTimeInput && jsxRuntime.exports.jsx(TimeInput, {
-                                isRange: props.selectsRange,
-                                onChange: (e3) => {
-                                    onChangeTime(e3, true);
-                                },
-                                type: "time",
-                                value: Array.isArray(selectedTime) ? selectedTime[0] : selectedTime
-                            })]
-                        }), props.selectsRange && jsxRuntime.exports.jsxs(EndDateInputWrapper, {
-                            children: ["\u2192", jsxRuntime.exports.jsxs(DateTimeWrapper, {
-                                isRange: true,
-                                children: [jsxRuntime.exports.jsx(DateInput, {
-                                    isTimeRange: props.showTimeInput,
-                                    onChange: (e3) => {
-                                        onChangeDateInput(false, e3);
-                                    },
-                                    onClick: () => {
-                                        var _a4;
-                                        setIsSelectingStart(false);
-                                        (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.setOpen(true);
-                                    },
-                                    onFocus: () => {
-                                        var _a4;
-                                        setIsSelectingStart(false);
-                                        (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.setOpen(true);
-                                    },
-                                    onKeyDown: (e3) => {
-                                        var _a4;
-                                        (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.onInputKeyDown(e3);
-                                    },
-                                    placeholder: formatToApply,
-                                    value: endDate
-                                }), props.showTimeInput && jsxRuntime.exports.jsx(TimeInput, {
-                                    isRange: true,
-                                    onChange: (e3) => {
-                                        onChangeTime(e3, false);
-                                    },
-                                    type: "time",
-                                    value: selectedTime[1]
-                                })]
-                            })]
-                        })]
-                    }), jsxRuntime.exports.jsx(Wt$1, Object.assign({
-                        className: props.className,
-                        customInput: jsxRuntime.exports.jsx("div", {}),
-                        disabled: props.disabled,
-                        inline: props.inline,
-                        maxDate: props.maxDate,
-                        onChange: onChangeDate,
-                        ref: datepickerRef,
-                        selectsEnd: !isSelectingStart,
-                        selectsStart: isSelectingStart,
-                        shouldCloseOnSelect: props.shouldCloseOnSelect
-                    }, extraProps, {
-                        popperProps: {
-                            strategy: (_c = props.popperStrategy) !== null && _c !== void 0 ? _c : "absolute"
-                        },
-                        renderCustomHeader: (headerProps) => jsxRuntime.exports.jsx(DatePickerHeader, Object.assign({}, headerProps, {
-                            maxDate: props.maxDate,
-                            minDate: props.minDate,
-                            portalsRef: props.portalsRef,
-                            selectItemClass: props.selectItemClass
-                        }))
-                    }))]
-                })
-            })
-        });
-    }
-    var COMMON_MIME_TYPES = /* @__PURE__ */ new Map([
-        ["avi", "video/avi"],
-        ["gif", "image/gif"],
-        ["ico", "image/x-icon"],
-        ["jpeg", "image/jpeg"],
-        ["jpg", "image/jpeg"],
-        ["mkv", "video/x-matroska"],
-        ["mov", "video/quicktime"],
-        ["mp4", "video/mp4"],
-        ["pdf", "application/pdf"],
-        ["png", "image/png"],
-        ["zip", "application/zip"],
-        ["doc", "application/msword"],
-        ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"]
-    ]);
-
-    function toFileWithPath(file, path2) {
-        var f2 = withMimeType(file);
-        if (typeof f2.path !== "string") {
-            var webkitRelativePath = file.webkitRelativePath;
-            Object.defineProperty(f2, "path", {
-                value: typeof path2 === "string" ? path2 : typeof webkitRelativePath === "string" && webkitRelativePath.length > 0 ? webkitRelativePath : file.name,
-                writable: false,
-                configurable: false,
-                enumerable: true
+            mountedInstances = mountedInstances.filter(function(i2) {
+                return i2 !== instance2;
             });
+            instance2.state.isMounted = false;
+            invokeHook("onHidden", [instance2]);
         }
-        return f2;
-    }
 
-    function withMimeType(file) {
-        var name2 = file.name;
-        var hasExtension = name2 && name2.lastIndexOf(".") !== -1;
-        if (hasExtension && !file.type) {
-            var ext = name2.split(".").pop().toLowerCase();
-            var type2 = COMMON_MIME_TYPES.get(ext);
-            if (type2) {
-                Object.defineProperty(file, "type", {
-                    value: type2,
-                    writable: false,
-                    configurable: false,
-                    enumerable: true
-                });
+        function destroy() {
+            if (instance2.state.isDestroyed) {
+                return;
             }
+            instance2.clearDelayTimeouts();
+            instance2.unmount();
+            removeListeners();
+            delete reference2._tippy;
+            instance2.state.isDestroyed = true;
+            invokeHook("onDestroy", [instance2]);
         }
-        return file;
     }
-    var FILES_TO_IGNORE = [
-        ".DS_Store",
-        "Thumbs.db"
-    ];
 
-    function fromEvent(evt) {
-        return __awaiter$2(this, void 0, void 0, function() {
-            return __generator(this, function(_a3) {
-                return [2, isDragEvt(evt) && evt.dataTransfer ? getDataTransferFiles(evt.dataTransfer, evt.type) : getInputFiles(evt)];
-            });
+    function tippy(targets, optionalProps) {
+        if (optionalProps === void 0) {
+            optionalProps = {};
+        }
+        var plugins2 = defaultProps$5.plugins.concat(optionalProps.plugins || []);
+        bindGlobalEventListeners();
+        var passedProps = Object.assign({}, optionalProps, {
+            plugins: plugins2
         });
+        var elements = getArrayOfElements(targets);
+        var instances = elements.reduce(function(acc, reference2) {
+            var instance2 = reference2 && createTippy(reference2, passedProps);
+            if (instance2) {
+                acc.push(instance2);
+            }
+            return acc;
+        }, []);
+        return isElement$2(targets) ? instances[0] : instances;
     }
+    tippy.defaultProps = defaultProps$5;
+    tippy.setDefaultProps = setDefaultProps;
+    tippy.currentInput = currentInput;
+    var mouseCoords = {
+        clientX: 0,
+        clientY: 0
+    };
+    var activeInstances = [];
 
-    function isDragEvt(value) {
-        return !!value.dataTransfer;
+    function storeMouseCoords(_ref2) {
+        var clientX = _ref2.clientX,
+            clientY = _ref2.clientY;
+        mouseCoords = {
+            clientX,
+            clientY
+        };
     }
 
-    function getInputFiles(evt) {
-        var files = isInput(evt.target) ? evt.target.files ? fromList(evt.target.files) : [] : [];
-        return files.map(function(file) {
-            return toFileWithPath(file);
-        });
+    function addMouseCoordsListener(doc2) {
+        doc2.addEventListener("mousemove", storeMouseCoords);
     }
 
-    function isInput(value) {
-        return value !== null;
+    function removeMouseCoordsListener(doc2) {
+        doc2.removeEventListener("mousemove", storeMouseCoords);
     }
+    var followCursor = {
+        name: "followCursor",
+        defaultValue: false,
+        fn: function fn2(instance2) {
+            var reference2 = instance2.reference;
+            var doc2 = getOwnerDocument(instance2.props.triggerTarget || reference2);
+            var isInternalUpdate = false;
+            var wasFocusEvent = false;
+            var isUnmounted = true;
+            var prevProps = instance2.props;
 
-    function getDataTransferFiles(dt2, type2) {
-        return __awaiter$2(this, void 0, void 0, function() {
-            var items, files;
-            return __generator(this, function(_a3) {
-                switch (_a3.label) {
-                    case 0:
-                        if (!dt2.items)
-                            return [3, 2];
-                        items = fromList(dt2.items).filter(function(item) {
-                            return item.kind === "file";
-                        });
-                        if (type2 !== "drop") {
-                            return [2, items];
+            function getIsInitialBehavior() {
+                return instance2.props.followCursor === "initial" && instance2.state.isVisible;
+            }
+
+            function addListener() {
+                doc2.addEventListener("mousemove", onMouseMove);
+            }
+
+            function removeListener() {
+                doc2.removeEventListener("mousemove", onMouseMove);
+            }
+
+            function unsetGetReferenceClientRect() {
+                isInternalUpdate = true;
+                instance2.setProps({
+                    getReferenceClientRect: null
+                });
+                isInternalUpdate = false;
+            }
+
+            function onMouseMove(event2) {
+                var isCursorOverReference = event2.target ? reference2.contains(event2.target) : true;
+                var followCursor2 = instance2.props.followCursor;
+                var clientX = event2.clientX,
+                    clientY = event2.clientY;
+                var rect = reference2.getBoundingClientRect();
+                var relativeX = clientX - rect.left;
+                var relativeY = clientY - rect.top;
+                if (isCursorOverReference || !instance2.props.interactive) {
+                    instance2.setProps({
+                        getReferenceClientRect: function getReferenceClientRect() {
+                            var rect2 = reference2.getBoundingClientRect();
+                            var x2 = clientX;
+                            var y2 = clientY;
+                            if (followCursor2 === "initial") {
+                                x2 = rect2.left + relativeX;
+                                y2 = rect2.top + relativeY;
+                            }
+                            var top2 = followCursor2 === "horizontal" ? rect2.top : y2;
+                            var right2 = followCursor2 === "vertical" ? rect2.right : x2;
+                            var bottom2 = followCursor2 === "horizontal" ? rect2.bottom : y2;
+                            var left2 = followCursor2 === "vertical" ? rect2.left : x2;
+                            return {
+                                width: right2 - left2,
+                                height: bottom2 - top2,
+                                top: top2,
+                                right: right2,
+                                bottom: bottom2,
+                                left: left2
+                            };
                         }
-                        return [4, Promise.all(items.map(toFilePromises))];
-                    case 1:
-                        files = _a3.sent();
-                        return [2, noIgnoredFiles(flatten$1(files))];
-                    case 2:
-                        return [2, noIgnoredFiles(fromList(dt2.files).map(function(file) {
-                            return toFileWithPath(file);
-                        }))];
+                    });
                 }
-            });
-        });
-    }
+            }
 
-    function noIgnoredFiles(files) {
-        return files.filter(function(file) {
-            return FILES_TO_IGNORE.indexOf(file.name) === -1;
-        });
-    }
+            function create2() {
+                if (instance2.props.followCursor) {
+                    activeInstances.push({
+                        instance: instance2,
+                        doc: doc2
+                    });
+                    addMouseCoordsListener(doc2);
+                }
+            }
 
-    function fromList(items) {
-        var files = [];
-        for (var i2 = 0; i2 < items.length; i2++) {
-            var file = items[i2];
-            files.push(file);
+            function destroy() {
+                activeInstances = activeInstances.filter(function(data2) {
+                    return data2.instance !== instance2;
+                });
+                if (activeInstances.filter(function(data2) {
+                        return data2.doc === doc2;
+                    }).length === 0) {
+                    removeMouseCoordsListener(doc2);
+                }
+            }
+            return {
+                onCreate: create2,
+                onDestroy: destroy,
+                onBeforeUpdate: function onBeforeUpdate() {
+                    prevProps = instance2.props;
+                },
+                onAfterUpdate: function onAfterUpdate(_2, _ref2) {
+                    var followCursor2 = _ref2.followCursor;
+                    if (isInternalUpdate) {
+                        return;
+                    }
+                    if (followCursor2 !== void 0 && prevProps.followCursor !== followCursor2) {
+                        destroy();
+                        if (followCursor2) {
+                            create2();
+                            if (instance2.state.isMounted && !wasFocusEvent && !getIsInitialBehavior()) {
+                                addListener();
+                            }
+                        } else {
+                            removeListener();
+                            unsetGetReferenceClientRect();
+                        }
+                    }
+                },
+                onMount: function onMount() {
+                    if (instance2.props.followCursor && !wasFocusEvent) {
+                        if (isUnmounted) {
+                            onMouseMove(mouseCoords);
+                            isUnmounted = false;
+                        }
+                        if (!getIsInitialBehavior()) {
+                            addListener();
+                        }
+                    }
+                },
+                onTrigger: function onTrigger(_2, event2) {
+                    if (isMouseEvent(event2)) {
+                        mouseCoords = {
+                            clientX: event2.clientX,
+                            clientY: event2.clientY
+                        };
+                    }
+                    wasFocusEvent = event2.type === "focus";
+                },
+                onHidden: function onHidden() {
+                    if (instance2.props.followCursor) {
+                        unsetGetReferenceClientRect();
+                        removeListener();
+                        isUnmounted = true;
+                    }
+                }
+            };
         }
-        return files;
-    }
+    };
+    tippy.setDefaultProps({
+        render
+    });
+    const TooltipWrapper = styled__default.default.div`
+    position: relative;
 
-    function toFilePromises(item) {
-        if (typeof item.webkitGetAsEntry !== "function") {
-            return fromDataTransferItem(item);
-        }
-        var entry = item.webkitGetAsEntry();
-        if (entry && entry.isDirectory) {
-            return fromDirEntry(entry);
-        }
-        return fromDataTransferItem(item);
-    }
+    display: block;
 
-    function flatten$1(items) {
-        return items.reduce(function(acc, files) {
-            return __spread(acc, Array.isArray(files) ? flatten$1(files) : [files]);
-        }, []);
-    }
+    max-width: 15rem;
+    padding: 0.75rem 1rem;
 
-    function fromDataTransferItem(item) {
-        var file = item.getAsFile();
-        if (!file) {
-            return Promise.reject(item + " is not a File");
-        }
-        var fwp = toFileWithPath(file);
-        return Promise.resolve(fwp);
-    }
+    word-break: break-word;
 
-    function fromEntry(entry) {
-        return __awaiter$2(this, void 0, void 0, function() {
-            return __generator(this, function(_a3) {
-                return [2, entry.isDirectory ? fromDirEntry(entry) : fromFileEntry(entry)];
-            });
-        });
-    }
+    border-radius: 0.25rem;
 
-    function fromDirEntry(entry) {
-        var reader = entry.createReader();
-        return new Promise(function(resolve2, reject) {
-            var entries = [];
+    transition: opacity 150ms ease-in-out;
 
-            function readEntries() {
-                var _this = this;
-                reader.readEntries(function(batch) {
-                    return __awaiter$2(_this, void 0, void 0, function() {
-                        var files, err_1, items;
-                        return __generator(this, function(_a3) {
-                            switch (_a3.label) {
-                                case 0:
-                                    if (!!batch.length)
-                                        return [3, 5];
-                                    _a3.label = 1;
-                                case 1:
-                                    _a3.trys.push([1, 3, , 4]);
-                                    return [4, Promise.all(entries)];
-                                case 2:
-                                    files = _a3.sent();
-                                    resolve2(files);
-                                    return [3, 4];
-                                case 3:
-                                    err_1 = _a3.sent();
-                                    reject(err_1);
-                                    return [3, 4];
-                                case 4:
-                                    return [3, 6];
-                                case 5:
-                                    items = Promise.all(batch.map(fromEntry));
-                                    entries.push(items);
-                                    readEntries();
-                                    _a3.label = 6;
-                                case 6:
-                                    return [2];
-                            }
-                        });
-                    });
-                }, function(err) {
-                    reject(err);
-                });
-            }
-            readEntries();
-        });
-    }
+    ${(props) => {
+    if (!props.$hidden) {
+      return `
+            color: ${props.styling === "default" ? props.theme.colors.grey5 : props.theme.colors.blue1};
+            font-size: ${props.theme.font.size};
+            border: 1px solid ${props.styling === "default" ? props.theme.colors.grey5 : props.theme.colors.errorDown};
 
-    function fromFileEntry(entry) {
-        return __awaiter$2(this, void 0, void 0, function() {
-            return __generator(this, function(_a3) {
-                return [2, new Promise(function(resolve2, reject) {
-                    entry.file(function(file) {
-                        var fwp = toFileWithPath(file, entry.fullPath);
-                        resolve2(fwp);
-                    }, function(err) {
-                        reject(err);
-                    });
-                })];
-            });
-        });
+            background-color: ${props.styling === "default" ? props.theme.colors.grey2 : props.theme.colors.error};
+            `;
     }
-    var _default$2 = function(file, acceptedFiles) {
-        if (file && acceptedFiles) {
-            var acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
-            var fileName = file.name || "";
-            var mimeType = (file.type || "").toLowerCase();
-            var baseMimeType = mimeType.replace(/\/.*$/, "");
-            return acceptedFilesArray.some(function(type2) {
-                var validType = type2.trim().toLowerCase();
-                if (validType.charAt(0) === ".") {
-                    return fileName.toLowerCase().endsWith(validType);
-                } else if (validType.endsWith("/*")) {
-                    return baseMimeType === validType.replace(/\/.*$/, "");
-                }
-                return mimeType === validType;
-            });
-        }
-        return true;
-    };
+  }};
+`;
+    const Arrow = styled__default.default.span`
+    position: absolute;
 
-    function _slicedToArray$9(arr, i2) {
-        return _arrayWithHoles$9(arr) || _iterableToArrayLimit$9(arr, i2) || _nonIterableRest$9();
+    ${(props) => {
+    switch (props.placement) {
+      case "top":
+        return "bottom: 3px; left: -3px !important;";
+      case "bottom":
+        return "top: -5px;";
+      case "left":
+        return "right: 3px;";
+      case "right":
+        return "left: -5px;";
+      default:
+        return "display: none;";
     }
+  }}
 
-    function _nonIterableRest$9() {
-        throw new TypeError("Invalid attempt to destructure non-iterable instance");
+    ${(props) => {
+    if (props.$hidden) {
+      return "display: none;";
     }
+  }}
 
-    function _iterableToArrayLimit$9(arr, i2) {
-        if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
-            return;
-        }
-        var _arr = [];
-        var _n2 = true;
-        var _d = false;
-        var _e2 = void 0;
-        try {
-            for (var _i2 = arr[Symbol.iterator](), _s; !(_n2 = (_s = _i2.next()).done); _n2 = true) {
-                _arr.push(_s.value);
-                if (i2 && _arr.length === i2)
-                    break;
-            }
-        } catch (err) {
-            _d = true;
-            _e2 = err;
-        } finally {
-            try {
-                if (!_n2 && _i2["return"] != null)
-                    _i2["return"]();
-            } finally {
-                if (_d)
-                    throw _e2;
-            }
-        }
-        return _arr;
+    &::before {
+        content: '';
+
+        position: absolute;
+
+        ${(props) => {
+    switch (props.placement) {
+      case "top":
+      case "bottom":
+        return "transform: rotate(45deg);";
+      case "left":
+        return "transform: rotate(135deg);";
+      case "right":
+        return "transform: rotate(-45deg);";
+      default:
+        return "display: none;";
     }
+  }}
 
-    function _arrayWithHoles$9(arr) {
-        if (Array.isArray(arr))
-            return arr;
+        width: 0.5rem;
+        height: 0.5rem;
+
+        background: ${(props) => {
+    return props.styling === "default" ? props.theme.colors.grey2 : props.theme.colors.error;
+  }};
+        ${(props) => {
+    if (props.placement === "top") {
+      return `border-bottom: 1px solid ${props.styling === "default" ? props.theme.colors.grey5 : props.theme.colors.errorDown};
+                        border-right: 1px solid ${props.styling === "default" ? props.theme.colors.grey5 : props.theme.colors.errorDown};`;
     }
-    var FILE_INVALID_TYPE = "file-invalid-type";
-    var FILE_TOO_LARGE = "file-too-large";
-    var FILE_TOO_SMALL = "file-too-small";
-    var TOO_MANY_FILES = "too-many-files";
-    var getInvalidTypeRejectionErr = function getInvalidTypeRejectionErr2(accept) {
-        accept = Array.isArray(accept) && accept.length === 1 ? accept[0] : accept;
-        var messageSuffix = Array.isArray(accept) ? "one of ".concat(accept.join(", ")) : accept;
-        return {
-            code: FILE_INVALID_TYPE,
-            message: "File type must be ".concat(messageSuffix)
-        };
-    };
-    var getTooLargeRejectionErr = function getTooLargeRejectionErr2(maxSize) {
-        return {
-            code: FILE_TOO_LARGE,
-            message: "File is larger than ".concat(maxSize, " bytes")
-        };
-    };
-    var getTooSmallRejectionErr = function getTooSmallRejectionErr2(minSize) {
-        return {
-            code: FILE_TOO_SMALL,
-            message: "File is smaller than ".concat(minSize, " bytes")
-        };
+    return `
+    border - top: 1 px solid $ {
+        props.styling === "default" ? props.theme.colors.grey5 : props.theme.colors.errorDown
     };
-    var TOO_MANY_FILES_REJECTION = {
-        code: TOO_MANY_FILES,
-        message: "Too many files"
+    border - left: 1 px solid $ {
+        props.styling === "default" ? props.theme.colors.grey5 : props.theme.colors.errorDown
     };
-
-    function fileAccepted(file, accept) {
-        var isAcceptable = file.type === "application/x-moz-file" || _default$2(file, accept);
-        return [isAcceptable, isAcceptable ? null : getInvalidTypeRejectionErr(accept)];
+    `;
+  }}
     }
+`;
 
-    function fileMatchSize(file, minSize, maxSize) {
-        if (isDefined(file.size)) {
-            if (isDefined(minSize) && isDefined(maxSize)) {
-                if (file.size > maxSize)
-                    return [false, getTooLargeRejectionErr(maxSize)];
-                if (file.size < minSize)
-                    return [false, getTooSmallRejectionErr(minSize)];
-            } else if (isDefined(minSize) && file.size < minSize)
-                return [false, getTooSmallRejectionErr(minSize)];
-            else if (isDefined(maxSize) && file.size > maxSize)
-                return [false, getTooLargeRejectionErr(maxSize)];
-        }
-        return [true, null];
+    function Tooltip$1({
+        appendTo = document.body,
+        getReferenceClientRect,
+        children: children2,
+        className,
+        content: content2,
+        disabled: disabled2,
+        hideOnClick = true,
+        interactive,
+        visible,
+        placement = "auto",
+        styling = "default",
+        followCursor: followCursor$1 = false,
+        hidden = false,
+        style: style2,
+        delay = 0,
+        onClickOutside = () => false
+    }) {
+        return jsxRuntime.exports.jsx(Tippy, {
+            appendTo,
+            arrow: true,
+            delay,
+            disabled: disabled2,
+            followCursor: followCursor$1,
+            getReferenceClientRect,
+            hideOnClick: visible !== void 0 ? void 0 : hideOnClick,
+            interactive,
+            onClickOutside,
+            placement,
+            plugins: [followCursor],
+            render: (attrs2) => jsxRuntime.exports.jsxs(TooltipWrapper, Object.assign({
+                "$hidden": hidden,
+                className,
+                style: style2,
+                styling
+            }, attrs2, {
+                children: [content2, jsxRuntime.exports.jsx(Arrow, {
+                    "$hidden": hidden,
+                    "data-popper-arrow": "",
+                    placement: attrs2["data-placement"],
+                    styling
+                })]
+            })),
+            visible,
+            zIndex: 9998,
+            children: children2
+        });
     }
+    const InteractiveIcons = styled__default.default.div`
+    position: absolute;
+    top: 0.75rem;
+    left: 236px;
 
-    function isDefined(value) {
-        return value !== void 0 && value !== null;
-    }
+    display: none;
+    gap: 0.5rem;
 
-    function allFilesAccepted(_ref2) {
-        var files = _ref2.files,
-            accept = _ref2.accept,
-            minSize = _ref2.minSize,
-            maxSize = _ref2.maxSize,
-            multiple = _ref2.multiple;
-        if (!multiple && files.length > 1) {
-            return false;
-        }
-        return files.every(function(file) {
-            var _fileAccepted = fileAccepted(file, accept),
-                _fileAccepted2 = _slicedToArray$9(_fileAccepted, 1),
-                accepted = _fileAccepted2[0];
-            var _fileMatchSize = fileMatchSize(file, minSize, maxSize),
-                _fileMatchSize2 = _slicedToArray$9(_fileMatchSize, 1),
-                sizeMatch = _fileMatchSize2[0];
-            return accepted && sizeMatch;
-        });
-    }
+    padding: 0.3rem;
 
-    function isPropagationStopped(event2) {
-        if (typeof event2.isPropagationStopped === "function") {
-            return event2.isPropagationStopped();
-        } else if (typeof event2.cancelBubble !== "undefined") {
-            return event2.cancelBubble;
-        }
-        return false;
-    }
+    background-color: ${(props) => props.theme.colors.blue1};
+    border-radius: 0.25rem;
+    box-shadow: ${(props) => props.theme.shadow.medium};
+`;
+    const MessageWrapper = styled__default.default.div`
+    position: relative;
 
-    function isEvtWithFiles(event2) {
-        if (!event2.dataTransfer) {
-            return !!event2.target && !!event2.target.files;
-        }
-        return Array.prototype.some.call(event2.dataTransfer.types, function(type2) {
-            return type2 === "Files" || type2 === "application/x-moz-file";
-        });
-    }
+    gap: 0.5rem;
 
-    function onDocumentDragOver(event2) {
-        event2.preventDefault();
-    }
+    width: 100%;
+    padding: 1rem;
 
-    function isIe(userAgent2) {
-        return userAgent2.indexOf("MSIE") !== -1 || userAgent2.indexOf("Trident/") !== -1;
-    }
+    background-color: ${(props) => props.theme.colors.blue1};
+    border-radius: 0.25rem;
+    box-shadow: ${(props) => props.theme.shadow.medium};
 
-    function isEdge(userAgent2) {
-        return userAgent2.indexOf("Edge/") !== -1;
+    :hover ${InteractiveIcons} {
+        display: flex;
     }
+`;
+    const MessageTop = styled__default.default.div`
+    display: flex;
+    justify-content: space-between;
+    width: 100%;
+    font-size: 0.875rem;
+`;
+    const MessageTimestamp = styled__default.default.span`
+    font-size: 0.75rem;
+    color: ${(props) => props.theme.colors.grey5};
+`;
+    const MessageBody = styled__default.default.span`
+    width: 100%;
+    color: ${(props) => props.theme.colors.text};
+    overflow-wrap: break-word;
+`;
+    const EditedText = styled__default.default.span`
+    align-self: end;
+    font-size: 0.8rem;
+    color: ${(props) => props.theme.colors.grey4};
+`;
+    const DeleteIcon = styled__default.default(Trash)`
+    height: 0.8rem;
+    color: ${(props) => props.theme.colors.secondary};
 
-    function isIeOrEdge() {
-        var userAgent2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.navigator.userAgent;
-        return isIe(userAgent2) || isEdge(userAgent2);
+    :hover {
+        color: ${(props) => props.theme.colors.secondaryHover}CC;
     }
 
-    function composeEventHandlers() {
-        for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
-            fns[_key] = arguments[_key];
-        }
-        return function(event2) {
-            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
-                args[_key2 - 1] = arguments[_key2];
-            }
-            return fns.some(function(fn2) {
-                if (!isPropagationStopped(event2) && fn2) {
-                    fn2.apply(void 0, [event2].concat(args));
-                }
-                return isPropagationStopped(event2);
-            });
-        };
+    :active {
+        color: ${(props) => props.theme.colors.secondaryDown}99;
     }
+`;
+    const EditIcon = styled__default.default(PenToSquare)`
+    height: 0.8rem;
+    color: ${(props) => props.theme.colors.secondary};
 
-    function _toConsumableArray$2(arr) {
-        return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _nonIterableSpread$2();
+    :hover {
+        color: ${(props) => props.theme.colors.secondaryHover}CC;
     }
 
-    function _nonIterableSpread$2() {
-        throw new TypeError("Invalid attempt to spread non-iterable instance");
+    :active {
+        color: ${(props) => props.theme.colors.secondaryDown}99;
     }
+`;
+    const EditButtons = styled__default.default.div`
+    display: flex;
+    gap: 1rem;
+    justify-content: flex-end;
+`;
+    const UserInfoWrapper = styled__default.default.div`
+    display: flex;
+    gap: 0.5rem;
+    align-items: center;
+`;
+    const AvatarIcon = styled__default.default.div`
+    display: flex;
+    align-items: center;
+    justify-content: center;
 
-    function _iterableToArray$2(iter2) {
-        if (Symbol.iterator in Object(iter2) || Object.prototype.toString.call(iter2) === "[object Arguments]")
-            return Array.from(iter2);
+    width: 2rem;
+    height: 2rem;
+
+    font-weight: 700;
+    color: white;
+
+    border-radius: 50%;
+`;
+
+    function getFormattedTimestamp(date) {
+        return format$2(parseISO$1(date), "HH:mm dd/MM/yyyy");
     }
 
-    function _arrayWithoutHoles$2(arr) {
-        if (Array.isArray(arr)) {
-            for (var i2 = 0, arr2 = new Array(arr.length); i2 < arr.length; i2++) {
-                arr2[i2] = arr[i2];
-            }
-            return arr2;
+    function selectColor(name2, colors2) {
+        const lowerCaseName = name2.toLowerCase();
+        let asciiSum = 0;
+        for (const char of lowerCaseName) {
+            asciiSum += char.charCodeAt(0);
         }
+        const colorIndex = asciiSum % colors2.length;
+        return colors2[colorIndex];
     }
 
-    function _slicedToArray$8(arr, i2) {
-        return _arrayWithHoles$8(arr) || _iterableToArrayLimit$8(arr, i2) || _nonIterableRest$8();
+    function getInitials(name2) {
+        const parts = name2.trim().split(/\s+/);
+        let initials = parts[0][0];
+        if (parts.length > 1) {
+            initials += parts[parts.length - 1][0];
+        }
+        return initials.toUpperCase();
     }
 
-    function _nonIterableRest$8() {
-        throw new TypeError("Invalid attempt to destructure non-iterable instance");
+    function processText(text2) {
+        return text2.replace(/\n/g, "\n\n");
     }
 
-    function _iterableToArrayLimit$8(arr, i2) {
-        if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
-            return;
+    function MessageComponent(props) {
+        const theme2 = useClTheme();
+        const [editMode, setEditMode] = React__namespace.useState(false);
+        const [editMessage, setEditMessage] = React__namespace.useState(props.value.message);
+        const [localMessage, setLocalMessage] = React__namespace.useState(props.value);
+        if (props.value && !lodash$1.exports.isEqual(props.value, localMessage)) {
+            setLocalMessage(props.value);
         }
-        var _arr = [];
-        var _n2 = true;
-        var _d = false;
-        var _e2 = void 0;
-        try {
-            for (var _i2 = arr[Symbol.iterator](), _s; !(_n2 = (_s = _i2.next()).done); _n2 = true) {
-                _arr.push(_s.value);
-                if (i2 && _arr.length === i2)
-                    break;
+        const tokenColors = [
+            theme2.colors.secondary,
+            theme2.colors.violet,
+            theme2.colors.turquoise,
+            theme2.colors.purple,
+            theme2.colors.teal,
+            theme2.colors.orange,
+            theme2.colors.plum
+        ];
+        const onAccept = () => {
+            if (editMessage === localMessage.message) {
+                setEditMode(false);
+                return;
             }
-        } catch (err) {
-            _d = true;
-            _e2 = err;
-        } finally {
-            try {
-                if (!_n2 && _i2["return"] != null)
-                    _i2["return"]();
-            } finally {
-                if (_d)
-                    throw _e2;
+            const newMessage = Object.assign(Object.assign({}, localMessage), {
+                message: editMessage.trim(),
+                updated_at: new Date().toISOString()
+            });
+            props === null || props === void 0 ? void 0 : props.onChange(newMessage);
+            setLocalMessage(newMessage);
+            setEditMessage(newMessage.message);
+            setEditMode(false);
+        };
+        const onDelete = () => {
+            if (props.onDelete) {
+                props.onDelete(props.value.id);
             }
-        }
-        return _arr;
+        };
+        return jsxRuntime.exports.jsxs(MessageWrapper, {
+            className: props.className,
+            style: props.style,
+            children: [jsxRuntime.exports.jsxs(MessageTop, {
+                children: [jsxRuntime.exports.jsxs(UserInfoWrapper, {
+                    children: [jsxRuntime.exports.jsx(AvatarIcon, {
+                        style: {
+                            backgroundColor: selectColor(localMessage.user.name, tokenColors)
+                        },
+                        children: getInitials(localMessage.user.name)
+                    }), jsxRuntime.exports.jsxs("div", {
+                        style: {
+                            display: "flex",
+                            flexDirection: "column"
+                        },
+                        children: [localMessage.user.name, jsxRuntime.exports.jsx(MessageTimestamp, {
+                            children: getFormattedTimestamp(props.value.created_at)
+                        })]
+                    }), localMessage.updated_at !== localMessage.created_at && jsxRuntime.exports.jsx(Tooltip$1, {
+                        content: getFormattedTimestamp(props.value.updated_at),
+                        children: jsxRuntime.exports.jsx(EditedText, {
+                            children: " (edited)"
+                        })
+                    })]
+                }), !editMode && props.isEditable && jsxRuntime.exports.jsxs(InteractiveIcons, {
+                    children: [jsxRuntime.exports.jsx(EditIcon, {
+                        "data-testid": "message-edit-button",
+                        onClick: () => setEditMode(true),
+                        role: "button"
+                    }), jsxRuntime.exports.jsx(DeleteIcon, {
+                        "data-testid": "message-delete-button",
+                        onClick: onDelete,
+                        role: "button"
+                    })]
+                })]
+            }), editMode && jsxRuntime.exports.jsxs("div", {
+                style: {
+                    display: "flex",
+                    flexDirection: "column",
+                    gap: "1rem"
+                },
+                children: [jsxRuntime.exports.jsx(TextArea, {
+                    onChange: setEditMessage,
+                    resize: "vertical",
+                    value: editMessage
+                }), jsxRuntime.exports.jsxs(EditButtons, {
+                    children: [jsxRuntime.exports.jsx(Button$3, {
+                        onClick: () => setEditMode(false),
+                        outline: true,
+                        children: "Cancel"
+                    }), jsxRuntime.exports.jsx(Button$3, {
+                        onClick: onAccept,
+                        children: "Save"
+                    })]
+                })]
+            }), !editMode && jsxRuntime.exports.jsx(MessageBody, {
+                children: jsxRuntime.exports.jsx(Markdown$1, {
+                    markdown: processText(localMessage.message)
+                })
+            })]
+        });
     }
+    const ChatWrapper$1 = styled__default.default.div`
+    overflow-y: auto;
+    display: flex;
+    flex-direction: column;
+    gap: 1rem;
 
-    function _arrayWithHoles$8(arr) {
-        if (Array.isArray(arr))
-            return arr;
-    }
+    width: 350px;
+    height: calc(100vh - 2rem);
+    margin: 1rem;
+    padding: 1.5rem;
 
-    function ownKeys$6(object2, enumerableOnly) {
-        var keys2 = Object.keys(object2);
-        if (Object.getOwnPropertySymbols) {
-            var symbols = Object.getOwnPropertySymbols(object2);
-            if (enumerableOnly)
-                symbols = symbols.filter(function(sym) {
-                    return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
-                });
-            keys2.push.apply(keys2, symbols);
-        }
-        return keys2;
-    }
+    background-color: ${(props) => props.theme.colors.background}e6;
+    border-radius: 0.4rem;
+    box-shadow: ${(props) => props.theme.shadow.medium};
+`;
+    const ReplyWrapper = styled__default.default.div`
+    display: flex;
+    flex-direction: column;
+    gap: 1rem;
+    justify-self: flex-end;
 
-    function _objectSpread$5(target) {
-        for (var i2 = 1; i2 < arguments.length; i2++) {
-            var source = arguments[i2] != null ? arguments[i2] : {};
-            if (i2 % 2) {
-                ownKeys$6(source, true).forEach(function(key) {
-                    _defineProperty$n(target, key, source[key]);
-                });
-            } else if (Object.getOwnPropertyDescriptors) {
-                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
-            } else {
-                ownKeys$6(source).forEach(function(key) {
-                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
-                });
-            }
-        }
-        return target;
+    height: 8.6rem;
+    margin-top: auto;
+`;
+    const ReplyButtons = styled__default.default.div`
+    display: flex;
+    gap: 1rem;
+    justify-content: flex-end;
+`;
+    const ChatBody = styled__default.default.div`
+    overflow-y: auto;
+    display: flex;
+    flex-direction: column;
+    gap: 1rem;
+
+    max-height: calc(100% - 10.225rem);
+    margin: -0.25rem;
+    padding: 0.25rem;
+`;
+    const ChatTop = styled__default.default.div`
+    display: flex;
+    align-items: center;
+    justify-content: space-between;
+
+    width: 100%;
+    height: 1.625rem;
+
+    font-size: 1.2rem;
+`;
+    const CloseIcon = styled__default.default(Xmark)`
+    height: 1.2rem;
+    color: ${(props) => props.theme.colors.grey4};
+
+    :hover {
+        color: ${(props) => props.theme.colors.grey5};
     }
 
-    function _defineProperty$n(obj, key, value) {
-        if (key in obj) {
-            Object.defineProperty(obj, key, {
-                value,
-                enumerable: true,
-                configurable: true,
-                writable: true
-            });
-        } else {
-            obj[key] = value;
-        }
-        return obj;
+    :active {
+        color: ${(props) => props.theme.colors.grey6};
     }
+`;
 
-    function _objectWithoutProperties$1(source, excluded) {
-        if (source == null)
-            return {};
-        var target = _objectWithoutPropertiesLoose$2(source, excluded);
-        var key, i2;
-        if (Object.getOwnPropertySymbols) {
-            var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
-            for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
-                key = sourceSymbolKeys[i2];
-                if (excluded.indexOf(key) >= 0)
-                    continue;
-                if (!Object.prototype.propertyIsEnumerable.call(source, key))
-                    continue;
-                target[key] = source[key];
+    function scrollToBottom(node2) {
+        setTimeout(() => {
+            if (node2) {
+                node2.scrollTop = node2.scrollHeight;
             }
+        }, 100);
+    }
+
+    function didUserWriteMessage(message, user) {
+        var _a3;
+        if (user === null || user === void 0 ? void 0 : user.id) {
+            return ((_a3 = message.user) === null || _a3 === void 0 ? void 0 : _a3.id) === user.id;
         }
-        return target;
+        return message.user.name === user.name;
     }
 
-    function _objectWithoutPropertiesLoose$2(source, excluded) {
-        if (source == null)
-            return {};
-        var target = {};
-        var sourceKeys = Object.keys(source);
-        var key, i2;
-        for (i2 = 0; i2 < sourceKeys.length; i2++) {
-            key = sourceKeys[i2];
-            if (excluded.indexOf(key) >= 0)
-                continue;
-            target[key] = source[key];
+    function Chat$1(props) {
+        var _a3;
+        const [reply, setReply] = React__namespace.useState("");
+        const [localMessages, setLocalMessages] = React__namespace.useState((_a3 = props.value) !== null && _a3 !== void 0 ? _a3 : []);
+        if (props.value && !lodash$1.exports.isEqual(props.value, localMessages)) {
+            setLocalMessages(props.value);
         }
-        return target;
-    }
-    var Dropzone$1 = React.forwardRef(function(_ref2, ref2) {
-        var children2 = _ref2.children,
-            params = _objectWithoutProperties$1(_ref2, ["children"]);
-        var _useDropzone = useDropzone(params),
-            open = _useDropzone.open,
-            props = _objectWithoutProperties$1(_useDropzone, ["open"]);
-        React.useImperativeHandle(ref2, function() {
-            return {
-                open
-            };
-        }, [open]);
-        return React__default.default.createElement(React.Fragment, null, children2(_objectSpread$5({}, props, {
-            open
-        })));
-    });
-    Dropzone$1.displayName = "Dropzone";
-    Dropzone$1.propTypes = {
-        children: propTypes.exports.func,
-        accept: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.arrayOf(propTypes.exports.string)]),
-        multiple: propTypes.exports.bool,
-        preventDropOnDocument: propTypes.exports.bool,
-        noClick: propTypes.exports.bool,
-        noKeyboard: propTypes.exports.bool,
-        noDrag: propTypes.exports.bool,
-        noDragEventsBubbling: propTypes.exports.bool,
-        minSize: propTypes.exports.number,
-        maxSize: propTypes.exports.number,
-        disabled: propTypes.exports.bool,
-        getFilesFromEvent: propTypes.exports.func,
-        onFileDialogCancel: propTypes.exports.func,
-        onDragEnter: propTypes.exports.func,
-        onDragLeave: propTypes.exports.func,
-        onDragOver: propTypes.exports.func,
-        onDrop: propTypes.exports.func,
-        onDropAccepted: propTypes.exports.func,
-        onDropRejected: propTypes.exports.func
-    };
-    var initialState$2 = {
-        isFocused: false,
-        isFileDialogActive: false,
-        isDragActive: false,
-        isDragAccept: false,
-        isDragReject: false,
-        draggedFiles: [],
-        acceptedFiles: [],
-        fileRejections: []
-    };
-
-    function useDropzone() {
-        var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
-            accept = _ref2.accept,
-            _ref2$disabled = _ref2.disabled,
-            disabled2 = _ref2$disabled === void 0 ? false : _ref2$disabled,
-            _ref2$getFilesFromEve = _ref2.getFilesFromEvent,
-            getFilesFromEvent = _ref2$getFilesFromEve === void 0 ? fromEvent : _ref2$getFilesFromEve,
-            _ref2$maxSize = _ref2.maxSize,
-            maxSize = _ref2$maxSize === void 0 ? Infinity : _ref2$maxSize,
-            _ref2$minSize = _ref2.minSize,
-            minSize = _ref2$minSize === void 0 ? 0 : _ref2$minSize,
-            _ref2$multiple = _ref2.multiple,
-            multiple = _ref2$multiple === void 0 ? true : _ref2$multiple,
-            onDragEnter = _ref2.onDragEnter,
-            onDragLeave = _ref2.onDragLeave,
-            onDragOver = _ref2.onDragOver,
-            onDrop = _ref2.onDrop,
-            onDropAccepted = _ref2.onDropAccepted,
-            onDropRejected = _ref2.onDropRejected,
-            onFileDialogCancel = _ref2.onFileDialogCancel,
-            _ref2$preventDropOnDo = _ref2.preventDropOnDocument,
-            preventDropOnDocument = _ref2$preventDropOnDo === void 0 ? true : _ref2$preventDropOnDo,
-            _ref2$noClick = _ref2.noClick,
-            noClick = _ref2$noClick === void 0 ? false : _ref2$noClick,
-            _ref2$noKeyboard = _ref2.noKeyboard,
-            noKeyboard = _ref2$noKeyboard === void 0 ? false : _ref2$noKeyboard,
-            _ref2$noDrag = _ref2.noDrag,
-            noDrag = _ref2$noDrag === void 0 ? false : _ref2$noDrag,
-            _ref2$noDragEventsBub = _ref2.noDragEventsBubbling,
-            noDragEventsBubbling = _ref2$noDragEventsBub === void 0 ? false : _ref2$noDragEventsBub;
-        var rootRef = React.useRef(null);
-        var inputRef = React.useRef(null);
-        var _useReducer = React.useReducer(reducer, initialState$2),
-            _useReducer2 = _slicedToArray$8(_useReducer, 2),
-            state = _useReducer2[0],
-            dispatch2 = _useReducer2[1];
-        var isFocused = state.isFocused,
-            isFileDialogActive = state.isFileDialogActive,
-            draggedFiles = state.draggedFiles;
-        var openFileDialog = React.useCallback(function() {
-            if (inputRef.current) {
-                dispatch2({
-                    type: "openDialog"
-                });
-                inputRef.current.value = null;
-                inputRef.current.click();
-            }
-        }, [dispatch2]);
-        var onWindowFocus = function onWindowFocus2() {
-            if (isFileDialogActive) {
-                setTimeout(function() {
-                    if (inputRef.current) {
-                        var files = inputRef.current.files;
-                        if (!files.length) {
-                            dispatch2({
-                                type: "closeDialog"
-                            });
-                            if (typeof onFileDialogCancel === "function") {
-                                onFileDialogCancel();
-                            }
-                        }
-                    }
-                }, 300);
+        const chatBodyRef = React__namespace.useRef(null);
+        const onChangeReply = (text2) => {
+            if (!text2.startsWith("\n")) {
+                setReply(text2);
             }
         };
-        React.useEffect(function() {
-            window.addEventListener("focus", onWindowFocus, false);
-            return function() {
-                window.removeEventListener("focus", onWindowFocus, false);
-            };
-        }, [inputRef, isFileDialogActive, onFileDialogCancel]);
-        var onKeyDownCb = React.useCallback(function(event2) {
-            if (!rootRef.current || !rootRef.current.isEqualNode(event2.target)) {
-                return;
-            }
-            if (event2.keyCode === 32 || event2.keyCode === 13) {
-                event2.preventDefault();
-                openFileDialog();
-            }
-        }, [rootRef, inputRef]);
-        var onFocusCb = React.useCallback(function() {
-            dispatch2({
-                type: "focus"
-            });
-        }, []);
-        var onBlurCb = React.useCallback(function() {
-            dispatch2({
-                type: "blur"
-            });
-        }, []);
-        var onClickCb = React.useCallback(function() {
-            if (noClick) {
-                return;
-            }
-            if (isIeOrEdge()) {
-                setTimeout(openFileDialog, 0);
-            } else {
-                openFileDialog();
-            }
-        }, [inputRef, noClick]);
-        var dragTargetsRef = React.useRef([]);
-        var onDocumentDrop = function onDocumentDrop2(event2) {
-            if (rootRef.current && rootRef.current.contains(event2.target)) {
-                return;
+        const onSubmitMessage = () => {
+            var _a4;
+            if (reply) {
+                const timestamp = new Date().toISOString();
+                const newMessage = {
+                    id: nanoid(),
+                    message: reply.trim(),
+                    created_at: timestamp,
+                    updated_at: timestamp,
+                    user: props.activeUser
+                };
+                const newMessages = [...localMessages, newMessage];
+                (_a4 = props.onUpdate) === null || _a4 === void 0 ? void 0 : _a4.call(props, newMessages);
+                setLocalMessages(newMessages);
+                setReply("");
+                scrollToBottom(chatBodyRef === null || chatBodyRef === void 0 ? void 0 : chatBodyRef.current);
             }
-            event2.preventDefault();
-            dragTargetsRef.current = [];
         };
-        React.useEffect(function() {
-            if (preventDropOnDocument) {
-                document.addEventListener("dragover", onDocumentDragOver, false);
-                document.addEventListener("drop", onDocumentDrop, false);
-            }
-            return function() {
-                if (preventDropOnDocument) {
-                    document.removeEventListener("dragover", onDocumentDragOver);
-                    document.removeEventListener("drop", onDocumentDrop);
+        const onEditMessage = (message) => {
+            var _a4;
+            const newMessages = localMessages.map((m2) => {
+                if (m2.id === message.id) {
+                    return message;
                 }
-            };
-        }, [rootRef, preventDropOnDocument]);
-        var onDragEnterCb = React.useCallback(function(event2) {
-            event2.preventDefault();
-            event2.persist();
-            stopPropagation(event2);
-            dragTargetsRef.current = [].concat(_toConsumableArray$2(dragTargetsRef.current), [event2.target]);
-            if (isEvtWithFiles(event2)) {
-                Promise.resolve(getFilesFromEvent(event2)).then(function(draggedFiles2) {
-                    if (isPropagationStopped(event2) && !noDragEventsBubbling) {
-                        return;
-                    }
-                    dispatch2({
-                        draggedFiles: draggedFiles2,
-                        isDragActive: true,
-                        type: "setDraggedFiles"
-                    });
-                    if (onDragEnter) {
-                        onDragEnter(event2);
-                    }
-                });
-            }
-        }, [getFilesFromEvent, onDragEnter, noDragEventsBubbling]);
-        var onDragOverCb = React.useCallback(function(event2) {
-            event2.preventDefault();
-            event2.persist();
-            stopPropagation(event2);
-            if (event2.dataTransfer) {
-                try {
-                    event2.dataTransfer.dropEffect = "copy";
-                } catch (_unused) {}
-            }
-            if (isEvtWithFiles(event2) && onDragOver) {
-                onDragOver(event2);
-            }
-            return false;
-        }, [onDragOver, noDragEventsBubbling]);
-        var onDragLeaveCb = React.useCallback(function(event2) {
-            event2.preventDefault();
-            event2.persist();
-            stopPropagation(event2);
-            var targets = dragTargetsRef.current.filter(function(target) {
-                return rootRef.current && rootRef.current.contains(target);
-            });
-            var targetIdx = targets.indexOf(event2.target);
-            if (targetIdx !== -1) {
-                targets.splice(targetIdx, 1);
-            }
-            dragTargetsRef.current = targets;
-            if (targets.length > 0) {
-                return;
-            }
-            dispatch2({
-                isDragActive: false,
-                type: "setDraggedFiles",
-                draggedFiles: []
-            });
-            if (isEvtWithFiles(event2) && onDragLeave) {
-                onDragLeave(event2);
-            }
-        }, [rootRef, onDragLeave, noDragEventsBubbling]);
-        var onDropCb = React.useCallback(function(event2) {
-            event2.preventDefault();
-            event2.persist();
-            stopPropagation(event2);
-            dragTargetsRef.current = [];
-            if (isEvtWithFiles(event2)) {
-                Promise.resolve(getFilesFromEvent(event2)).then(function(files) {
-                    if (isPropagationStopped(event2) && !noDragEventsBubbling) {
-                        return;
-                    }
-                    var acceptedFiles = [];
-                    var fileRejections = [];
-                    files.forEach(function(file) {
-                        var _fileAccepted = fileAccepted(file, accept),
-                            _fileAccepted2 = _slicedToArray$8(_fileAccepted, 2),
-                            accepted = _fileAccepted2[0],
-                            acceptError = _fileAccepted2[1];
-                        var _fileMatchSize = fileMatchSize(file, minSize, maxSize),
-                            _fileMatchSize2 = _slicedToArray$8(_fileMatchSize, 2),
-                            sizeMatch = _fileMatchSize2[0],
-                            sizeError = _fileMatchSize2[1];
-                        if (accepted && sizeMatch) {
-                            acceptedFiles.push(file);
-                        } else {
-                            var errors = [acceptError, sizeError].filter(function(e3) {
-                                return e3;
-                            });
-                            fileRejections.push({
-                                file,
-                                errors
-                            });
-                        }
-                    });
-                    if (!multiple && acceptedFiles.length > 1) {
-                        acceptedFiles.forEach(function(file) {
-                            fileRejections.push({
-                                file,
-                                errors: [TOO_MANY_FILES_REJECTION]
-                            });
-                        });
-                        acceptedFiles.splice(0);
-                    }
-                    dispatch2({
-                        acceptedFiles,
-                        fileRejections,
-                        type: "setFiles"
-                    });
-                    if (onDrop) {
-                        onDrop(acceptedFiles, fileRejections, event2);
-                    }
-                    if (fileRejections.length > 0 && onDropRejected) {
-                        onDropRejected(fileRejections, event2);
-                    }
-                    if (acceptedFiles.length > 0 && onDropAccepted) {
-                        onDropAccepted(acceptedFiles, event2);
-                    }
-                });
-            }
-            dispatch2({
-                type: "reset"
+                return m2;
             });
-        }, [multiple, accept, minSize, maxSize, getFilesFromEvent, onDrop, onDropAccepted, onDropRejected, noDragEventsBubbling]);
-        var composeHandler = function composeHandler2(fn2) {
-            return disabled2 ? null : fn2;
-        };
-        var composeKeyboardHandler = function composeKeyboardHandler2(fn2) {
-            return noKeyboard ? null : composeHandler(fn2);
-        };
-        var composeDragHandler = function composeDragHandler2(fn2) {
-            return noDrag ? null : composeHandler(fn2);
+            (_a4 = props.onUpdate) === null || _a4 === void 0 ? void 0 : _a4.call(props, newMessages);
+            setLocalMessages(newMessages);
         };
-        var stopPropagation = function stopPropagation2(event2) {
-            if (noDragEventsBubbling) {
-                event2.stopPropagation();
-            }
+        const onDeleteMessage = (id2) => {
+            var _a4;
+            const newMessages = localMessages.filter((message) => message.id !== id2);
+            (_a4 = props.onUpdate) === null || _a4 === void 0 ? void 0 : _a4.call(props, newMessages);
+            setLocalMessages(newMessages);
         };
-        var getRootProps = React.useMemo(function() {
-            return function() {
-                var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
-                    _ref3$refKey = _ref3.refKey,
-                    refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey,
-                    onKeyDown = _ref3.onKeyDown,
-                    onFocus = _ref3.onFocus,
-                    onBlur = _ref3.onBlur,
-                    onClick = _ref3.onClick,
-                    onDragEnter2 = _ref3.onDragEnter,
-                    onDragOver2 = _ref3.onDragOver,
-                    onDragLeave2 = _ref3.onDragLeave,
-                    onDrop2 = _ref3.onDrop,
-                    rest = _objectWithoutProperties$1(_ref3, ["refKey", "onKeyDown", "onFocus", "onBlur", "onClick", "onDragEnter", "onDragOver", "onDragLeave", "onDrop"]);
-                return _objectSpread$5(_defineProperty$n({
-                    onKeyDown: composeKeyboardHandler(composeEventHandlers(onKeyDown, onKeyDownCb)),
-                    onFocus: composeKeyboardHandler(composeEventHandlers(onFocus, onFocusCb)),
-                    onBlur: composeKeyboardHandler(composeEventHandlers(onBlur, onBlurCb)),
-                    onClick: composeHandler(composeEventHandlers(onClick, onClickCb)),
-                    onDragEnter: composeDragHandler(composeEventHandlers(onDragEnter2, onDragEnterCb)),
-                    onDragOver: composeDragHandler(composeEventHandlers(onDragOver2, onDragOverCb)),
-                    onDragLeave: composeDragHandler(composeEventHandlers(onDragLeave2, onDragLeaveCb)),
-                    onDrop: composeDragHandler(composeEventHandlers(onDrop2, onDropCb))
-                }, refKey, rootRef), !disabled2 && !noKeyboard ? {
-                    tabIndex: 0
-                } : {}, {}, rest);
-            };
-        }, [rootRef, onKeyDownCb, onFocusCb, onBlurCb, onClickCb, onDragEnterCb, onDragOverCb, onDragLeaveCb, onDropCb, noKeyboard, noDrag, disabled2]);
-        var onInputElementClick = React.useCallback(function(event2) {
-            event2.stopPropagation();
+        React__namespace.useLayoutEffect(() => {
+            scrollToBottom(chatBodyRef === null || chatBodyRef === void 0 ? void 0 : chatBodyRef.current);
         }, []);
-        var getInputProps = React.useMemo(function() {
-            return function() {
-                var _ref4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
-                    _ref4$refKey = _ref4.refKey,
-                    refKey = _ref4$refKey === void 0 ? "ref" : _ref4$refKey,
-                    onChange2 = _ref4.onChange,
-                    onClick = _ref4.onClick,
-                    rest = _objectWithoutProperties$1(_ref4, ["refKey", "onChange", "onClick"]);
-                var inputProps = _defineProperty$n({
-                    accept,
-                    multiple,
-                    type: "file",
-                    style: {
-                        display: "none"
-                    },
-                    onChange: composeHandler(composeEventHandlers(onChange2, onDropCb)),
-                    onClick: composeHandler(composeEventHandlers(onClick, onInputElementClick)),
-                    autoComplete: "off",
-                    tabIndex: -1
-                }, refKey, inputRef);
-                return _objectSpread$5({}, inputProps, {}, rest);
-            };
-        }, [inputRef, accept, multiple, onDropCb, disabled2]);
-        var fileCount = draggedFiles.length;
-        var isDragAccept = fileCount > 0 && allFilesAccepted({
-            files: draggedFiles,
-            accept,
-            minSize,
-            maxSize,
-            multiple
-        });
-        var isDragReject = fileCount > 0 && !isDragAccept;
-        return _objectSpread$5({}, state, {
-            isDragAccept,
-            isDragReject,
-            isFocused: isFocused && !disabled2,
-            getRootProps,
-            getInputProps,
-            rootRef,
-            inputRef,
-            open: composeHandler(openFileDialog)
+        return jsxRuntime.exports.jsxs(ChatWrapper$1, {
+            className: props.className,
+            style: props.style,
+            children: [jsxRuntime.exports.jsxs(ChatTop, {
+                children: [jsxRuntime.exports.jsx("span", {
+                    children: "Chat"
+                }), jsxRuntime.exports.jsx(CloseIcon, {
+                    onClick: props.onClose
+                })]
+            }), jsxRuntime.exports.jsx(ChatBody, {
+                ref: chatBodyRef,
+                children: localMessages.map((message) => jsxRuntime.exports.jsx(MessageComponent, {
+                    onChange: onEditMessage,
+                    onDelete: onDeleteMessage,
+                    value: message,
+                    isEditable: didUserWriteMessage(message, props.activeUser)
+                }, message.id))
+            }), jsxRuntime.exports.jsxs(ReplyWrapper, {
+                children: [jsxRuntime.exports.jsx(TextArea, {
+                    onChange: onChangeReply,
+                    onComplete: onSubmitMessage,
+                    placeholder: "Add a comment",
+                    resize: "none",
+                    value: reply
+                }), jsxRuntime.exports.jsx(ReplyButtons, {
+                    children: jsxRuntime.exports.jsx(Button$3, {
+                        disabled: !(reply.trim().length > 0),
+                        onClick: onSubmitMessage,
+                        children: "Send"
+                    })
+                })]
+            })]
         });
     }
+    const CheckboxWrapper$1 = styled__default.default.label`
+    cursor: ${(props) => props.disabled ? "not-allowed" : "pointer"};
+    user-select: none;
+
+    position: relative;
 
-    function reducer(state, action) {
-        switch (action.type) {
-            case "focus":
-                return _objectSpread$5({}, state, {
-                    isFocused: true
-                });
-            case "blur":
-                return _objectSpread$5({}, state, {
-                    isFocused: false
-                });
-            case "openDialog":
-                return _objectSpread$5({}, state, {
-                    isFileDialogActive: true
-                });
-            case "closeDialog":
-                return _objectSpread$5({}, state, {
-                    isFileDialogActive: false
-                });
-            case "setDraggedFiles":
-                var isDragActive = action.isDragActive,
-                    draggedFiles = action.draggedFiles;
-                return _objectSpread$5({}, state, {
-                    draggedFiles,
-                    isDragActive
-                });
-            case "setFiles":
-                return _objectSpread$5({}, state, {
-                    acceptedFiles: action.acceptedFiles,
-                    fileRejections: action.fileRejections
-                });
-            case "reset":
-                return _objectSpread$5({}, state, {
-                    isFileDialogActive: false,
-                    isDragActive: false,
-                    draggedFiles: [],
-                    acceptedFiles: [],
-                    fileRejections: []
-                });
-            default:
-                return state;
-        }
-    }
-    const DROPZONE_ALLOWED_MIME_TYPES = ".csv, text/csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel, application/csv, text/x-csv, application/x-csv, text/comma-separated-values, text/x-comma-separated-values";
-    const Dropzone = styled__default.default.div`
     display: flex;
-    flex: 1 1 auto;
     align-items: center;
-    justify-content: center;
 
-    margin-top: 20px;
+    width: ${(props) => props.isListStyle ? "100%" : "fit-content"};
+    padding: 0.5625rem 0 0.5625rem 2rem;
 
-    color: ${(props) => props.theme.colors.text};
+    font-size: 1rem;
 
-    border: 1px dashed ${(props) => props.isDragActive ? props.theme.colors.primary : props.theme.colors.grey3};
     border-radius: 0.25rem;
 
-    :hover {
-        background-color: ${(props) => props.theme.colors.grey1};
-    }
-
-    :active,
-    :focus {
-        background-color: ${(props) => props.theme.colors.grey2};
-    }
-`;
-    const DropzoneMessage = styled__default.default.span`
-    max-width: 400px;
-    padding: 1.5rem;
+    ${(props) => {
+    if (props.isListStyle && !props.disabled) {
+      return `
+                :hover {
+                    background-color: ${props.theme.colors.grey1};
 
-    font-family: Manrope, sans-serif;
-    font-weight: 300;
-    text-align: center;
-`;
+                    span {
+                        border: 1px solid ${props.theme.colors.grey4};
+                    }
+                }
 
-    function UploadDropzone$1(props) {
-        var _a3;
-        React.useEffect(() => {
-            if (!props.enablePaste) {
-                return;
-            }
-            const handlePaste = (ev) => {
-                const blob = new Blob([ev.clipboardData.getData("Text")], {
-                    type: "text/plain"
-                });
-                const file = new File([blob], "pasted_data", {
-                    type: "text/plain"
-                });
-                props.onDrop([file]);
-            };
-            document.addEventListener("paste", handlePaste);
-            return () => document.removeEventListener("paste", handlePaste);
-        }, [props]);
-        const {
-            getRootProps,
-            getInputProps,
-            isDragActive
-        } = useDropzone({
-            accept: (_a3 = props.accept) !== null && _a3 !== void 0 ? _a3 : DROPZONE_ALLOWED_MIME_TYPES,
-            multiple: false,
-            onDrop: props.onDrop
-        });
-        return jsxRuntime.exports.jsxs(Dropzone, Object.assign({}, getRootProps(), {
-            className: props.className,
-            isDragActive,
-            style: props.style,
-            children: [jsxRuntime.exports.jsx("input", Object.assign({}, getInputProps())), jsxRuntime.exports.jsxs(DropzoneMessage, {
-                children: ["Drop your file, ", jsxRuntime.exports.jsx("br", {}), "paste it ", jsxRuntime.exports.jsx("br", {}), "or click here to upload"]
-            })]
-        }));
+                :active {
+                    background-color: ${props.theme.colors.grey2};
+                }
+        `;
     }
-    styled__default.default.div`
-    display: flex;
-    flex-direction: column;
-
-    width: 100%;
-    padding: 1rem;
-
-    color: ${(props) => props.theme.colors.error};
-
-    background-color: ${(props) => props.theme.colors.background};
-`;
-    styled__default.default.div`
-    overflow: scroll;
-    display: flex;
-    flex-direction: column;
-
-    width: 100%;
-    max-height: 125px;
-    margin: 2rem 0;
-    padding: 0.5rem;
-
-    color: ${(props) => props.theme.colors.background};
-
-    background-color: ${(props) => props.theme.colors.errorHover};
-`;
-    styled__default.default.p`
-    color: ${(props) => props.theme.colors.error};
-`;
-    const NodeContent = styled__default.default.li`
-    margin-left: 0.35rem;
-    border-left: thin solid ${(props) => props.theme.colors.grey6};
-
-    &::before {
-        content: '';
-
-        display: inline-block;
+  }}
 
-        width: 0.9rem;
-        height: 0.8rem;
-        margin-right: 0.1rem;
+    /* sets checkmark indicator */
+    span::after {
+        top: 0.05rem;
+        left: 0.3rem;
+        transform: rotate(45deg);
 
-        vertical-align: top;
+        width: 0.3125rem;
+        height: 0.625rem;
 
-        border-bottom: thin solid ${(props) => props.theme.colors.grey6};
+        border: solid ${(props) => props.theme.colors.grey5};
+        border-width: 0 2px 2px 0;
     }
 
-    &:last-child {
-        border-left: none;
+    /* Show the checkmark when checked */
+    input:checked ~ span::after {
+        display: block;
+    }
 
-        &::before {
-            border-left: thin solid ${(props) => props.theme.colors.grey6};
-        }
+    :hover {
+        span,
+        input:checked ~ span {
+            background-color: ${(props) => {
+    if (props.disabled) {
+      return props.theme.colors.grey3;
     }
-`;
-    const Cell$1 = styled__default.default.span`
-    cursor: ${(props) => props.selectionAllowed ? "pointer" : "normal"};
-    font-weight: ${(props) => props.isLeaf ? 300 : 400};
-    color: ${(props) => {
-    if (props.selected) {
-      return props.theme.colors.primary;
+    if (props.isListStyle) {
+      return props.theme.colors.blue1;
     }
-    return props.isLeaf ? props.theme.colors.grey6 : props.theme.colors.grey5;
+    return props.theme.colors.grey1;
   }};
-`;
-    const CircleIcon = styled__default.default(Circle$1)`
-    width: 0.5rem;
-    height: 0.5rem;
-    margin-right: 0.4rem;
-
-    color: ${(props) => props.selected ? props.theme.colors.primary : props.theme.colors.grey6};
-    vertical-align: middle;
-`;
-    const grow = styled.keyframes`
-    0% {
-        transform: scaleY(0);
-        opacity: 0;
+            border: 1px solid ${(props) => props.theme.colors.grey4};
+        }
     }
-    100% {
-        transform: scaleY(1);
-        opacity: 1;
+
+    /* stylelint-disable -- messy specificity ordering */
+    :active {
+        span,
+        input:checked ~ span {
+            background-color: ${(props) => {
+    if (props.disabled) {
+      return props.theme.colors.grey3;
     }
-`;
-    const contract = styled.keyframes`
-    100% {
-        transform: scaleY(1);
-        opacity: 1;
+    if (props.isListStyle) {
+      return props.theme.colors.blue1;
     }
-    0% {
-        transform: scaleY(0);
-        opacity: 0;
+    return props.theme.colors.grey2;
+  }};
+        }
     }
 `;
-    const NodeWrapper = styled__default.default.ul`
-    transform-origin: top center;
+    const StyledCheckbox$1 = styled__default.default.input`
+    cursor: pointer;
 
-    display: ${(props) => props.open ? "block" : "none"};
+    /* Hide the browser's default checkbox */
+    position: absolute;
 
-    margin: 0;
-    margin-left: 1rem;
-    padding: 0;
-    padding-bottom: 1rem;
+    width: 0;
+    height: 0;
 
-    list-style: none;
+    opacity: 0;
 
-    animation: ${(props) => props.open ? grow : contract} 300ms
-        ${(props) => props.open ? "ease-out forwards" : "ease-in forwards"};
+    :checked ~ span {
+        background-color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.blue1};
+    }
 `;
+    const StyledCheckmark$1 = styled__default.default.span`
+    position: absolute;
+    left: 0.5rem;
 
-    function Branch(props) {
-        const theme2 = useClTheme();
-        const [open, setOpen] = React.useState(props.open || false);
-        const toggle = () => {
-            if (props.content) {
-                setOpen(!open);
-            }
-        };
-        const select = () => {
-            props.selectNode(props.content.id);
-        };
-        const selectionAllowed = props.allowSelectCategory && props.content.children && props.content.children.length > 0 || props.allowSelectLeaf && (!props.content.children || props.content.children.length === 0);
-        return jsxRuntime.exports.jsxs(NodeContent, {
-            className: props.className,
-            style: props.style,
-            children: [jsxRuntime.exports.jsx(CircleIcon, {
-                selected: props.content.id === props.selectedNodeId
-            }), jsxRuntime.exports.jsx(Cell$1, {
-                isLeaf: !props.content.children || props.content.children.length === 0,
-                onClick: selectionAllowed ? select : toggle,
-                selected: props.content.id === props.selectedNodeId,
-                selectionAllowed,
-                children: props.content.label
-            }), props.content.children && props.content.children.length > 0 && jsxRuntime.exports.jsx(Chevron$2, {
-                isOpen: open,
-                onClick: toggle,
-                style: {
-                    color: theme2.colors.grey5,
-                    cursor: "pointer",
-                    height: "0.8rem",
-                    marginLeft: "0.5rem",
-                    verticalAlign: "middle",
-                    width: "0.8rem"
-                }
-            }), jsxRuntime.exports.jsx(NodeWrapper, {
-                open,
-                children: props.content.children && props.content.children.length > 0 && props.content.children.map((nodeObj) => jsxRuntime.exports.jsx(Branch, {
-                    allowSelectCategory: props.allowSelectCategory,
-                    allowSelectLeaf: props.allowSelectLeaf,
-                    content: nodeObj,
-                    selectCategory: props.selectCategory,
-                    selectNode: props.selectNode,
-                    selectedNodeId: props.selectedNodeId
-                }, nodeObj.id))
-            })]
-        });
+    width: 1rem;
+    height: 1rem;
+
+    background-color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.blue1};
+    border: 1px solid ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.grey4};
+    border-radius: 0.25rem;
+
+    // hidden checkmark indicator
+    :after {
+        content: '';
+        position: absolute;
+        display: none;
     }
-    const Wrapper$8 = styled__default.default.div`
-    overflow: scroll;
-`;
-    const Root = styled__default.default.div`
-    cursor: pointer;
-    margin-left: 1rem;
 `;
 
-    function HierarchySelector$1(props) {
-        const theme2 = useClTheme();
-        const [rootOpen, setRootOpen] = React.useState(props.rootOpen || false);
-        const [selectedNodeId, setSelectedNodeId] = React.useState(props.selected);
+    function Checkbox(props) {
+        const [checked, setChecked] = React.useState(props.selected || props.initialValue);
         React.useEffect(() => {
-            if (props.selected) {
-                setSelectedNodeId(props.selected);
+            if (props.selected !== void 0) {
+                setChecked(props.selected);
             }
         }, [props.selected]);
-        const toggle = () => {
-            setRootOpen(!rootOpen);
-        };
-        const selectNode = (nodeId) => {
-            var _a3;
-            setSelectedNodeId(nodeId);
-            (_a3 = props.onSelect) === null || _a3 === void 0 ? void 0 : _a3.call(props, nodeId);
+        const onClick = (e3) => {
+            if (props.disabled) {
+                return;
+            }
+            if (props.selected === void 0) {
+                setChecked(!checked);
+            }
+            if (props.onChange) {
+                props.onChange(!checked, e3);
+            }
         };
-        const {
-            label,
-            id: id2,
-            children: children2
-        } = props.rootNode;
-        return jsxRuntime.exports.jsxs(Wrapper$8, {
+        return jsxRuntime.exports.jsxs(CheckboxWrapper$1, {
             className: props.className,
-            style: props.style,
-            children: [jsxRuntime.exports.jsxs(Root, {
-                children: [jsxRuntime.exports.jsx(CircleIcon, {
-                    selected: id2 === selectedNodeId
-                }), jsxRuntime.exports.jsx(Cell$1, {
-                    onClick: props.allowSelectCategory || children2.length === 0 ? () => selectNode(id2) : toggle,
-                    selected: id2 === selectedNodeId,
-                    children: label
-                }), children2.length > 0 && jsxRuntime.exports.jsx(Chevron$2, {
-                    isOpen: rootOpen,
-                    onClick: toggle,
-                    style: {
-                        color: theme2.colors.grey5,
-                        cursor: "pointer",
-                        height: "0.8rem",
-                        marginLeft: "0.5rem",
-                        verticalAlign: "middle",
-                        width: "0.8rem"
-                    }
-                })]
-            }), jsxRuntime.exports.jsx(NodeWrapper, {
-                open: rootOpen,
-                children: children2 && children2.map((nodeObj) => jsxRuntime.exports.jsx(Branch, {
-                    allowSelectCategory: props.allowSelectCategory,
-                    allowSelectLeaf: props.allowSelectLeaf,
-                    content: nodeObj,
-                    open: rootOpen,
-                    selectNode,
-                    selectedNodeId
-                }, nodeObj.id))
+            disabled: props.disabled,
+            isListStyle: props.isListStyle,
+            children: [props.label, jsxRuntime.exports.jsx(StyledCheckbox$1, {
+                "aria-disabled": props.disabled,
+                checked: props.selected,
+                disabled: props.disabled,
+                isListStyle: props.isListStyle,
+                onChange: (e3) => onClick(e3),
+                onClick: props.onClick,
+                type: "checkbox",
+                value: props.id
+            }), jsxRuntime.exports.jsx(StyledCheckmark$1, {
+                disabled: props.disabled,
+                isListStyle: props.isListStyle
             })]
         });
     }
-    const Background$1 = styled__default.default.div`
-    position: fixed;
-    z-index: 2000;
-    top: 0;
-    left: 0;
-
+    const CheckboxWrapper = styled__default.default.div`
+    user-select: none;
     display: flex;
-    align-items: center;
-    justify-content: center;
-
     width: 100%;
-    height: 100%;
-
-    opacity: ${(props) => props.render ? 1 : 0};
-    background-color: ${(props) => props.theme.colors.modalBg};
-
-    transition: opacity ease-in 0.1s;
-`;
-    const ModalWrapper = styled__default.default.div`
-    overflow: hidden;
-    display: inline-flex;
-    flex-direction: column;
-
-    min-width: 20rem;
-    max-width: 80vw;
-    min-height: 10rem;
-    max-height: 80vh;
-    margin-top: ${(props) => props.render ? 0 : "-50px"};
-    padding: 1.75rem;
-
-    font-size: ${(props) => props.theme.font.size};
-
-    background-color: ${(props) => props.theme.colors.grey1};
-    border-radius: 0.25rem;
-    box-shadow: ${(props) => props.theme.shadow.medium};
-
-    transition: margin-top ease-in 0.1s;
+    border: none;
 `;
-    styled__default.default.div`
-    display: flex;
-    flex: 0 0 auto;
-    justify-content: space-between;
-    margin-top: 1rem;
+    const CheckboxGroupWrapper = styled__default.default.div`
+    color: ${(props) => props.theme.colors.text};
 `;
-    styled__default.default.div`
-    display: flex;
-    flex: 0 0 auto;
-    flex-direction: ${(props) => props.flexDirection || "column"};
-    justify-content: space-between;
-
-    margin-bottom: 1rem;
+    const CheckboxInfo = styled__default.default.p`
+    font-size: 0.75rem;
+    color: ${(props) => props.theme.colors.grey4};
 `;
 
-    function Modal$1(props) {
-        var _a3;
-        const [mounted, setMounted] = React.useState(false);
-        const [renderModal, setRenderModal] = React.useState(false);
-        React.useEffect(() => {
-            setRenderModal(props.render);
-        }, [props.render]);
-        React.useEffect(() => {
-            if (renderModal) {
-                const keyHandler = (e3) => {
-                    if (e3.key === Key.ESCAPE && props.onAttemptClose) {
-                        props.onAttemptClose();
-                    }
-                };
-                document.addEventListener("keydown", keyHandler);
-                return () => {
-                    document.removeEventListener("keydown", keyHandler);
-                };
-            }
-        }, [renderModal, props.onAttemptClose]);
-        if (!props.render && !mounted) {
-            return null;
+    function getInitialValue$3(initialValue) {
+        if (Array.isArray(initialValue)) {
+            return initialValue;
         }
-        const onTransitionEnd = () => {
-            setMounted(props.render);
-            if (!props.render && props.onClosed) {
-                props.onClosed();
-            }
-        };
-        const stopPropagation = (e3) => {
-            e3.stopPropagation();
-        };
-        return ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(Background$1, {
-            id: props.id,
-            onClick: props.onAttemptClose,
-            onTransitionEnd,
-            render: renderModal,
-            children: jsxRuntime.exports.jsx(ModalWrapper, {
-                className: `cl-modal-content ${(_a3 = props.className) !== null && _a3 !== void 0 ? _a3 : ""}`,
-                onClick: stopPropagation,
-                render: renderModal,
-                style: props.style,
-                children: props.children
-            })
-        }), document.body);
-    }
-    var __rest$9 = globalThis && globalThis.__rest || function(s2, e3) {
-        var t2 = {};
-        for (var p2 in s2)
-            if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
-                t2[p2] = s2[p2];
-        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
-            for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
-                if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
-                    t2[p2[i2]] = s2[p2[i2]];
-            }
-        return t2;
-    };
-    const {
-        stateChangeTypes: stateChangeTypes$1
-    } = useCombobox;
-    const tagHeight = 2;
-    const tagTopMargin = 0.5;
-    const Wrapper$7 = styled__default.default.div`
-    display: inline-flex;
-    ${(props) => {
-    if (props.isDisabled) {
-      return `
-                cursor: not-allowed;
-            `;
-    }
-  }}
-
-    width: 100%;
-    max-width: ${(props) => props.maxWidth};
-    max-height: ${(props) => props.maxRows * (tagHeight + tagTopMargin)}rem;
-
-    border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0rem 0rem" : "0.25rem"};
-`;
-    const InputWrapper$3 = styled__default.default.div`
-    display: flex;
-    flex: 1 1 auto;
-    align-items: center;
-    justify-content: space-between;
-
-    width: 100%;
-    min-width: 10rem;
-    min-height: 2.5rem;
-    margin-right: 0.25rem;
-    padding: 0.25rem 0.5rem 0.25rem 1rem;
-
-    color: ${(props) => props.isDisabled ? props.theme.colors.grey2 : props.theme.colors.text};
-
-    background-color: ${(props) => props.theme.colors.grey1};
-    border: none;
-    border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0rem 0rem" : "0.25rem"};
-
-    :hover {
-        background-color: ${(props) => props.isDisabled ? props.theme.colors.grey1 : props.theme.colors.grey2};
-    }
-
-    svg {
-        height: 0.8rem;
-    }
-
-    ${(props) => {
-    if (props.isDisabled) {
-      return `
-                border: 1px solid ${props.theme.colors.grey1};
-
-                svg {
-                    color: ${props.theme.colors.grey2};
-                    cursor: not-allowed;
-                }
-            `;
-    }
-    if (props.isErrored) {
-      return `
-    border: 1 px solid $ {
-        props.theme.colors.error
-    };
-    `;
-    }
-    return `
-    border: 1 px solid $ {
-        props.isOpen ? props.theme.colors.grey3 : props.theme.colors.grey1
-    };: hover {
-        border: 1 px solid $ {
-            props.theme.colors.grey3
-        };
-
-    }
-    `;
-  }}
-`;
-    const Input$1 = styled__default.default.input`
-    overflow: hidden;
-    flex: 1 1 auto;
-
-    margin-right: 0.5rem;
-    padding: 0;
-
-    font-size: ${(props) => props.size ? `${props.size}rem` : props.theme.font.size};
-    font-weight: 300;
-    color: ${(props) => props.theme.colors.grey6};
-    text-align: left;
-    text-overflow: ellipsis;
-    white-space: nowrap;
-
-    background-color: transparent;
-    border: none;
-    outline: 0;
-
-    :disabled {
-        cursor: not-allowed;
+        if (initialValue) {
+            return [initialValue];
+        }
+        return [];
     }
-`;
-    const TagWrapper = styled__default.default.div`
-    overflow: auto;
-    display: flex;
-    flex-wrap: wrap;
-    gap: 0.5rem;
-    align-items: center;
-
-    width: 100%;
-    height: 100%;
-    max-height: ${(props) => props.maxRows * (tagHeight + tagTopMargin) - 0.25}rem;
-`;
-    const Tag$1 = styled__default.default.span`
-    overflow: hidden;
-    display: flex;
-    align-items: center;
-
-    height: ${tagHeight}rem;
-    padding: 0 0.75rem;
-
-    font-size: 0.875rem;
-    color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.text};
 
-    background-color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.blue3};
-    border: 1px solid ${(props) => props.theme.colors.primary};
-    border-radius: 1rem;
-
-    svg {
-        width: 0.85rem;
-        height: 0.85rem;
-        margin-left: 0.25rem;
-        color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.text};
-
-        :hover {
-            color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.primary};
+    function getInitialCheckedState(items, initialValues) {
+        if (initialValues) {
+            return items.map((item) => ({
+                state: initialValues.includes(item.value),
+                value: item.value
+            }));
         }
+        return items.map((item) => ({
+            state: initialValues.includes(item.value),
+            value: false
+        }));
     }
-`;
-    const TagText = styled__default.default.span`
-    overflow: hidden;
-    text-overflow: ellipsis;
-    white-space: nowrap;
-`;
-    const NoItemsLabel = styled__default.default.span`
-    display: flex;
-    flex: 1 1 auto;
-    align-items: center;
-    justify-content: center;
-
-    height: 2rem;
-
-    font-size: 1rem;
-    color: ${(props) => props.theme.colors.grey4};
-
-    background-color: ${(props) => props.theme.colors.blue1};
-`;
-    const DropdownList$1 = styled__default.default(List)`
-    border-radius: 0 0 0.25rem 0.25rem;
-    outline: 0;
-    box-shadow: ${(props) => props.theme.shadow.light};
-`;
-    const ChevronButton = styled__default.default(Button$3).attrs((attrs2) => Object.assign(Object.assign({}, attrs2), {
-        styling: "ghost"
-    }))`
-    min-width: 0;
-    height: auto;
-    margin: 0;
-    padding: 0 0.25rem;
-
-    background-color: transparent !important;
-`;
 
-    function MultiSelect(_a3) {
-        var _b, _c;
-        var {
-            maxWidth = "100%", maxRows = 3
-        } = _a3, props = __rest$9(_a3, ["maxWidth", "maxRows"]);
-        const referenceElement = React.useRef(null);
-        const popperElement = React.useRef(null);
-        const {
-            styles: styles2,
-            attributes: attributes2,
-            update: update2
-        } = usePopper$1(referenceElement.current, popperElement.current, {
-            modifiers: [sameWidthModifier],
-            placement: "bottom-start"
-        });
-        const [inputValue, setInputValue] = React.useState("");
-        const {
-            getSelectedItemProps,
-            getDropdownProps,
-            addSelectedItem,
-            removeSelectedItem,
-            selectedItems
-        } = useMultipleSelection(Object.assign({
-            initialSelectedItems: (_b = props.initialValue) !== null && _b !== void 0 ? _b : [],
-            onSelectedItemsChange: (changes) => {
-                if (props.onSelect) {
-                    props.onSelect(changes.selectedItems);
-                }
-                update2();
+    function CheckboxGroup$1(props) {
+        const [values, setValues] = React.useState(() => getInitialValue$3(props.values || props.initialValue));
+        const [checkedState, setCheckedState] = React.useState(() => getInitialCheckedState(props.items, values));
+        const isSelectPermitted = React.useMemo(() => {
+            if (!props.selectMax || values.length < props.selectMax) {
+                return true;
             }
-        }, "selectedItems" in props && {
-            selectedItems: props.selectedItems
-        }));
-        const onTermChange = React.useCallback(
-            (term) => {
-                setInputValue(term);
-                if (props.onTermChange) {
-                    props.onTermChange(term);
-                }
-            },
-            [props.onTermChange]
-        );
-        const filteredItems = props.onTermChange ? props.items : props.items.filter((item) => {
-            var _a4;
-            return !selectedItems.includes(item) && ((_a4 = item.label) === null || _a4 === void 0 ? void 0 : _a4.toLowerCase().includes(inputValue.toLowerCase()));
-        });
-        const {
-            isOpen,
-            getMenuProps,
-            getInputProps,
-            highlightedIndex,
-            getItemProps,
-            openMenu,
-            getToggleButtonProps
-        } = useCombobox({
-            defaultHighlightedIndex: -1,
-            initialIsOpen: props.initialIsOpen,
-            inputValue,
-            itemToString: (item) => (item === null || item === void 0 ? void 0 : item.label) || "",
-            items: filteredItems,
-            onStateChange: ({
-                inputValue: internalInputVal,
-                selectedItem,
-                type: type2
-            }) => {
-                if (type2 === stateChangeTypes$1.InputChange) {
-                    onTermChange(internalInputVal);
-                }
-                if ([
-                        stateChangeTypes$1.InputKeyDownEnter,
-                        stateChangeTypes$1.ItemClick,
-                        stateChangeTypes$1.InputBlur
-                    ].includes(type2)) {
-                    if (selectedItem) {
-                        onTermChange("");
-                        addSelectedItem(selectedItem);
-                    }
-                }
-            },
-            selectedItem: null,
-            stateReducer: (state, {
-                changes,
-                type: type2
-            }) => {
-                if (type2 === stateChangeTypes$1.ItemClick || type2 === stateChangeTypes$1.InputKeyDownEnter) {
-                    return Object.assign(Object.assign({}, changes), {
-                        isOpen: true
-                    });
+            return false;
+        }, [values, props.selectMax]);
+        const infoMessage = React.useMemo(() => {
+            if (props.selectMax && props.selectMin) {
+                return `You can select from ${props.selectMin} to ${props.selectMax} options`;
+            }
+            if (props.selectMax) {
+                return `You can select up to ${props.selectMax} options`;
+            }
+            if (props.selectMin) {
+                return `You should select at least ${props.selectMin} options`;
+            }
+        }, [props.selectMax, props.selectMin]);
+        const onChangeValue = (event2) => {
+            var _a3;
+            const target = event2.target;
+            const chosenIndex = Number(target.value);
+            const chosenValue = props.items[chosenIndex].value;
+            let newValues = [...values];
+            if (values.includes(chosenValue)) {
+                newValues = newValues.filter((value) => value !== chosenValue);
+            } else {
+                newValues.push(chosenValue);
+            }
+            if (newValues.length > props.selectMax && checkedState[chosenIndex] || newValues.length <= props.selectMax || !props.selectMax) {
+                const indexToUpdate = checkedState.findIndex((item) => item.value === chosenValue);
+                checkedState[indexToUpdate].state = !checkedState[indexToUpdate].state;
+                setCheckedState(checkedState);
+                setValues(newValues);
+                if (!props.selectMin || newValues.length >= props.selectMin) {
+                    (_a3 = props.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, props.items.filter((item) => newValues.includes(item.value)), event2);
                 }
-                return changes;
             }
-        });
+        };
         React.useEffect(() => {
-            if (isOpen && update2) {
-                update2();
+            if (props.values) {
+                const valuesArray = props.values.map((value) => value.value);
+                setCheckedState(props.items.map((item) => ({
+                    state: valuesArray.includes(item.value),
+                    value: item.value
+                })));
+                setValues(valuesArray);
             }
-        }, [isOpen, update2]);
-        const menuProps = getMenuProps();
-        const setMenuRef = menuProps.ref;
-        delete menuProps.ref;
-        const setMenuReference = (value) => {
-            setMenuRef(value);
-            popperElement.current = value;
-        };
-        return jsxRuntime.exports.jsxs(Wrapper$7, {
+        }, [props.values, props.items]);
+        return jsxRuntime.exports.jsxs(CheckboxGroupWrapper, {
             className: props.className,
-            isDisabled: props.disabled,
-            isOpen,
-            maxRows,
-            maxWidth,
             style: props.style,
-            children: [jsxRuntime.exports.jsx(Tooltip$1, {
-                content: props.errorMsg,
-                disabled: !props.errorMsg,
-                styling: "error",
-                children: jsxRuntime.exports.jsxs(InputWrapper$3, {
-                    isDisabled: props.disabled,
-                    isOpen,
-                    ref: referenceElement,
-                    children: [jsxRuntime.exports.jsxs(TagWrapper, {
-                        maxRows,
-                        children: [selectedItems.map((selectedItem, index2) => jsxRuntime.exports.jsxs(Tag$1, Object.assign({
-                            disabled: props.disabled
-                        }, getSelectedItemProps({
-                            index: index2,
-                            selectedItem
-                        }), {
-                            children: [jsxRuntime.exports.jsx(TagText, {
-                                children: selectedItem.label
-                            }), jsxRuntime.exports.jsx(Cross$1, {
-                                asButton: true,
-                                onClick: (e3) => {
-                                    e3.stopPropagation();
-                                    return removeSelectedItem(selectedItem);
-                                }
-                            })]
-                        }), selectedItem.value)), jsxRuntime.exports.jsx(Input$1, Object.assign({}, getInputProps(getDropdownProps({
-                            preventKeyAction: isOpen
-                        })), {
-                            disabled: props.disabled,
-                            onFocus: openMenu,
-                            placeholder: props.placeholder,
-                            size: props.size,
-                            style: {
-                                flex: "1 1 5ch"
-                            }
-                        }))]
-                    }), jsxRuntime.exports.jsx(ChevronButton, Object.assign({}, getToggleButtonProps(), {
-                        children: jsxRuntime.exports.jsx(Chevron$2, {
-                            disabled: props.disabled,
-                            isOpen
-                        })
-                    }))]
-                })
-            }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsxs(DropdownList$1, Object.assign({}, menuProps, attributes2.popper, {
-                isOpen,
-                ref: setMenuReference,
-                style: Object.assign(Object.assign({}, styles2.popper), {
-                    width: parseFloat((_c = styles2.popper) === null || _c === void 0 ? void 0 : _c.width),
-                    zIndex: 9999
-                }),
-                children: [filteredItems.length > 0 && filteredItems.map((item, index2) => React.createElement(ListItem, Object.assign({}, getItemProps({
-                    index: index2,
-                    item
-                }), {
-                    hovered: index2 === highlightedIndex,
-                    key: `item-${index2}`,
-                    size: props.size,
-                    title: item.label
-                }), item.label)), filteredItems.length === 0 && jsxRuntime.exports.jsx(NoItemsLabel, {
-                    children: "No Items"
-                })]
-            })), document.body)]
+            children: [(props.selectMax || props.selectMin) && jsxRuntime.exports.jsx(CheckboxInfo, {
+                children: infoMessage
+            }), props.items.map((item, index2) => {
+                var _a3, _b;
+                return jsxRuntime.exports.jsx(CheckboxWrapper, {
+                    "aria-disabled": props.disabled,
+                    children: jsxRuntime.exports.jsx(Checkbox, {
+                        disabled: isSelectPermitted ? props.disabled : ((_a3 = checkedState.find((option) => option.value === item.value)) === null || _a3 === void 0 ? void 0 : _a3.state) === false,
+                        id: index2,
+                        isListStyle: props.isListStyle,
+                        label: item.label ? item.label : item.value,
+                        onChange: (checked, e3) => onChangeValue(e3),
+                        selected: (_b = checkedState.find((option) => option.value === item.value)) === null || _b === void 0 ? void 0 : _b.state
+                    })
+                }, `item-${index2}`);
+            })]
         });
     }
-    var __rest$8 = globalThis && globalThis.__rest || function(s2, e3) {
+    var __rest$b = globalThis && globalThis.__rest || function(s2, e3) {
         var t2 = {};
         for (var p2 in s2)
             if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
                 t2[p2] = s2[p2];
         if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
             for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
                 if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
                     t2[p2[i2]] = s2[p2[i2]];
             }
         return t2;
     };
-    const SelectedItem = styled__default.default.div`
-    overflow: hidden;
-
-    /* The space available is that of the wrapper minus of the chevron */
-    width: calc(100% - 1rem);
-    margin-right: 0.5rem;
-
-    font-size: ${(props) => props.size ? `${props.size}rem` : "1rem"};
-    font-weight: 300;
-    text-align: left;
-    text-overflow: ellipsis;
-    white-space: nowrap;
-`;
-    const Wrapper$6 = styled__default.default.div`
-    display: inline-flex;
-
-    width: 100%;
-    min-width: 4rem;
-    height: 2.5rem;
-
-    border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0rem 0rem" : "0.25rem"};
-
-    ${(props) => {
-    if (props.isDisabled) {
-      return `
-                border: 1px solid ${props.theme.colors.grey1};
-                cursor: not-allowed;
-            `;
-    }
-    if (props.isErrored) {
-      return `
-    border: 1 px solid $ {
-        props.theme.colors.error
-    };
-    `;
-    }
-    return `
-    border: 1 px solid $ {
-        props.isOpen ? props.theme.colors.grey3 : props.theme.colors.grey1
-    };: hover {
-        border: 1 px solid $ {
-            props.theme.colors.grey3
-        };
-
-    }
-    `;
-  }}
-`;
-    const SelectButton = styled__default.default.button`
-    display: inline-flex;
-    flex: 1 1 auto;
+    const PrimaryInput = styled__default.default.input`
+    display: flex;
     align-items: center;
-    justify-content: space-between;
 
     width: 100%;
     height: 100%;
-    padding: 0 0.5rem 0 1rem;
+    padding: 0 1rem;
 
     font-size: 1rem;
-    color: ${(props) => props.theme.colors.text};
+    color: ${(props) => props.disabled ? props.theme.colors.grey2 : props.theme.colors.text};
 
     background-color: ${(props) => props.theme.colors.grey1};
-    border: none;
-    border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0rem 0rem" : "0.25rem"};
+    border: 1px solid ${(props) => props.isErrored ? props.theme.colors.error : props.theme.colors.grey1};
+    border-radius: 0.25rem;
     outline: 0;
 
-    :not(:enabled) {
-        cursor: not-allowed;
+    :active:not(:disabled),
+    :focus:not(:disabled) {
+        border: 1px solid ${(props) => props.isErrored ? props.theme.colors.error : props.theme.colors.grey3};
     }
 
-    :hover:enabled {
+    :hover:not(:disabled) {
         background-color: ${(props) => props.theme.colors.grey2};
     }
 
-    svg {
-        width: 1rem !important;
-        height: 0.8rem;
-    }
-
     :disabled {
-        color: ${(props) => props.theme.colors.grey2};
-        background-color: ${(props) => props.theme.colors.grey1};
-
-        svg {
-            color: ${(props) => props.theme.colors.grey2};
-        }
-    }
-`;
-    const DropdownList = styled__default.default(List)`
-    margin-left: -1px;
-    border-radius: 0 0 0.25rem 0.25rem;
-    outline: 0;
-    box-shadow: ${(props) => props.theme.shadow.light};
-`;
-
-    function Select$1(props) {
-        var _a3, _b, _c, _d, _e2, _f;
-        const referenceElement = React.useRef(null);
-        const popperElement = React.useRef(null);
-        const {
-            styles: styles2,
-            attributes: attributes2,
-            update: update2
-        } = usePopper$1(referenceElement.current, popperElement.current, {
-            modifiers: props.applySameWidthModifier === false ? [] : [sameWidthModifier],
-            placement: props.placement || "bottom-start"
-        });
-        const {
-            isOpen,
-            selectedItem,
-            getToggleButtonProps,
-            getMenuProps,
-            highlightedIndex,
-            getItemProps
-        } = useSelect(Object.assign({
-            initialIsOpen: props.initialIsOpen,
-            initialSelectedItem: props.initialValue,
-            itemToString: (item) => item.label,
-            items: props.items,
-            onSelectedItemChange: (changes) => {
-                var _a4;
-                const selected = changes.selectedItem;
-                (_a4 = props.onSelect) === null || _a4 === void 0 ? void 0 : _a4.call(props, selected);
-            }
-        }, "selectedItem" in props && {
-            selectedItem: props.selectedItem
-        }));
-        React.useEffect(() => {
-            if (isOpen && update2) {
-                update2();
-            }
-        }, [isOpen, update2]);
-        const buttonProps = getToggleButtonProps({
-            disabled: props.disabled
-        });
-        const setButtonRef = buttonProps.ref;
-        delete buttonProps.ref;
-        const setButtonReference = (value) => {
-            setButtonRef(value);
-            referenceElement.current = value;
-        };
-        const menuProps = getMenuProps();
-        const setMenuRef = menuProps.ref;
-        delete menuProps.ref;
-        const setMenuReference = (value) => {
-            var _a4;
-            setMenuRef(value);
-            popperElement.current = value;
-            (_a4 = props.dropdownRef) === null || _a4 === void 0 ? void 0 : _a4.call(props, value);
-        };
-        return jsxRuntime.exports.jsx(Tooltip$1, {
-            content: props.errorMsg,
-            disabled: !props.errorMsg,
-            styling: "error",
-            children: jsxRuntime.exports.jsxs(Wrapper$6, {
-                className: props.className,
-                isDisabled: props.disabled,
-                isErrored: !!props.errorMsg,
-                isOpen,
-                onClick: props.onClick,
-                style: props.style,
-                children: [jsxRuntime.exports.jsxs(SelectButton, Object.assign({
-                    disabled: props.disabled,
-                    isOpen
-                }, buttonProps, {
-                    ref: setButtonReference,
-                    type: "button",
-                    children: [jsxRuntime.exports.jsx(SelectedItem, {
-                        size: props.size,
-                        children: (_b = (_a3 = selectedItem === null ? props.placeholder : selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.label) !== null && _a3 !== void 0 ? _a3 : props.placeholder) !== null && _b !== void 0 ? _b : "Select"
-                    }), jsxRuntime.exports.jsx(Chevron$2, {
-                        disabled: props.disabled,
-                        isOpen
-                    })]
-                })), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(DropdownList, Object.assign({}, menuProps, attributes2.popper, {
-                    className: `${(_c = menuProps === null || menuProps === void 0 ? void 0 : menuProps.className) !== null && _c !== void 0 ? _c : ""} ${(_e2 = (_d = attributes2 === null || attributes2 === void 0 ? void 0 : attributes2.popper) === null || _d === void 0 ? void 0 : _d.className) !== null && _e2 !== void 0 ? _e2 : ""} ${props.itemClass}`,
-                    isOpen,
-                    maxItems: props.maxItems,
-                    ref: setMenuReference,
-                    style: Object.assign(Object.assign({}, styles2.popper), {
-                        width: props.applySameWidthModifier === false ? void 0 : parseFloat((_f = styles2.popper) === null || _f === void 0 ? void 0 : _f.width) + 2,
-                        zIndex: 9999
-                    }),
-                    children: props.items.map((item, index2) => {
-                        const _a4 = getItemProps({
-                                index: index2,
-                                item
-                            }),
-                            {
-                                itemClassName
-                            } = _a4,
-                            itemProps = __rest$8(_a4, ["itemClassName"]);
-                        return React.createElement(ListItem, Object.assign({}, itemProps, {
-                            className: `${itemClassName} ${props.itemClass}`,
-                            hovered: index2 === highlightedIndex,
-                            key: `item-${index2}`,
-                            size: props.size,
-                            title: item.label
-                        }), item.label);
-                    })
-                })), document.body)]
-            })
-        });
+        cursor: not-allowed;
     }
-    const StyledSelect$2 = styled__default.default(Select$1)`
-    margin: 1px solid ${(props) => props.theme.colors.background};
-
-    button {
-        background-color: ${(props) => props.theme.colors.background};
 
-        :hover:enabled {
-            background-color: ${(props) => props.theme.colors.background};
-        }
+    ::placeholder {
+        font-style: italic;
     }
 `;
-    const InputsWrapper = styled__default.default.div`
-    display: flex;
-    gap: 5px;
-    align-items: center;
-`;
-    const FilterHeader = styled__default.default.div`
-    display: flex;
-    flex-direction: column;
-    gap: 0.25rem;
-    padding: 0 0.5rem;
-`;
-    const StyledInput$3 = styled__default.default(Input$3)`
-    width: ${(props) => props.showTwoInputs ? "106px" : "100%"};
-
-    input {
-        width: ${(props) => props.showTwoInputs ? "106px" : "100%"};
-        background-color: ${(props) => props.theme.colors.background};
-        border: 1px solid ${(props) => props.showError ? props.theme.colors.error : props.theme.colors.background};
-
-        :hover:not(:disabled) {
-            background-color: ${(props) => props.theme.colors.background};
-            border: 1px solid ${(props) => props.showError ? props.theme.colors.error : props.theme.colors.grey3};
-        }
-
-        :active:not(:disabled),
-        :focus:not(:disabled) {
-            border: 1px solid ${(props) => props.showError ? props.theme.colors.error : props.theme.colors.grey3};
-        }
-    }
+    const InputWrapper$5 = styled__default.default.div`
+    width: 22ch;
+    max-width: 100%;
+    height: 2.5rem;
 `;
-    const ErrorMessage = styled__default.default.span`
-    user-select: none;
-    font-size: 0.7rem;
+    const ErrorMessage$1 = styled__default.default.span`
+    margin-left: 1rem;
+    font-size: 0.75rem;
     color: ${(props) => props.theme.colors.error};
 `;
-    const NumericFilterItems = [{
-        label: "None",
-        value: "None"
-    }, {
-        label: "Greater than",
-        value: "Greater than"
-    }, {
-        label: "Less than",
-        value: "Less tha"
-    }, {
-        label: "Equal to",
-        value: "Equal to"
-    }, {
-        label: "Not equal to",
-        value: "Not equal to"
-    }, {
-        label: "Between",
-        value: "Between"
-    }];
-
-    function NumericFilter(props) {
-        const [selected, setSelected] = React.useState(null);
-        const [firstInput, setFirstInput] = React.useState(null);
-        const [secondInput, setSecondInput] = React.useState(null);
-        const filteredValues = React.useMemo(() => {
-            if ((selected === null || selected === void 0 ? void 0 : selected.label) === "None") {
-                return {
-                    selected: selected === null || selected === void 0 ? void 0 : selected.label,
-                    value: null
-                };
+    const Input$3 = React.forwardRef((_a3, ref2) => {
+        var {
+            type: type2 = "text"
+        } = _a3, props = __rest$b(_a3, ["type"]);
+        const onChange2 = (e3) => {
+            const target = e3.target;
+            if (props.onChange) {
+                props.onChange(target.value, e3);
             }
-            if ((selected === null || selected === void 0 ? void 0 : selected.label) === "Between") {
-                return {
-                    selected: selected === null || selected === void 0 ? void 0 : selected.label,
-                    value: [firstInput, secondInput]
-                };
+        };
+        const onKeyDown = (e3) => {
+            if (props.onKeyDown) {
+                props.onKeyDown(e3);
             }
-            return {
-                selected: selected === null || selected === void 0 ? void 0 : selected.label,
-                value: firstInput
-            };
-        }, [firstInput, secondInput, selected]);
-        const [previousFilter, setPreviousFilter] = React.useState(filteredValues);
-        const showError = React.useMemo(() => {
-            if (secondInput && firstInput && secondInput < firstInput && (selected === null || selected === void 0 ? void 0 : selected.label) === "Between") {
-                return true;
+            if (props.keydownFilter && !props.keydownFilter(e3)) {
+                e3.preventDefault();
             }
-            return false;
-        }, [firstInput, secondInput, selected]);
-        const disableApply = React.useMemo(() => {
-            if (props.disabled || previousFilter === filteredValues || showError) {
-                return true;
+            if (e3.key === Key.ENTER && props.onComplete) {
+                props.onComplete();
             }
-            if (firstInput === null && (selected === null || selected === void 0 ? void 0 : selected.label) !== "None") {
-                return true;
+        };
+        const addOptionalItems = () => {
+            const result = {};
+            if (props.minValue) {
+                result.minValue = props.minValue;
             }
-            if (secondInput === null && (selected === null || selected === void 0 ? void 0 : selected.label) === "Between") {
-                return true;
+            if (props.maxValue) {
+                result.maxValue = props.minValue;
             }
-            return false;
-        }, [props.disabled, firstInput, secondInput, previousFilter, filteredValues, showError, selected]);
-        return jsxRuntime.exports.jsxs(FilterWrapper, {
+            return result;
+        };
+        return jsxRuntime.exports.jsxs(InputWrapper$5, {
             className: props.className,
-            children: [jsxRuntime.exports.jsxs(FilterHeader, {
-                children: [jsxRuntime.exports.jsx(StyledSelect$2, {
-                    dropdownRef: (element2) => {
-                        if (props.portalsRef) {
-                            props.portalsRef.current[0] = element2;
-                        }
-                    },
-                    initialValue: {
-                        label: "None",
-                        value: "None"
-                    },
-                    items: NumericFilterItems,
-                    maxItems: 6,
-                    onSelect: setSelected
-                }), selected && (selected === null || selected === void 0 ? void 0 : selected.label) !== "None" && jsxRuntime.exports.jsxs(InputsWrapper, {
-                    children: [jsxRuntime.exports.jsx(StyledInput$3, {
-                        onChange: (v2) => setFirstInput(Number(v2)),
-                        showError,
-                        showTwoInputs: (selected === null || selected === void 0 ? void 0 : selected.label) === "Between",
-                        type: "number"
-                    }), (selected === null || selected === void 0 ? void 0 : selected.label) === "Between" && jsxRuntime.exports.jsxs(InputsWrapper, {
-                        children: ["and", jsxRuntime.exports.jsx(StyledInput$3, {
-                            onChange: (v2) => setSecondInput(Number(v2)),
-                            showError,
-                            type: "number",
-                            value: String(secondInput)
-                        })]
-                    })]
-                })]
-            }), showError && jsxRuntime.exports.jsx(ErrorMessage, {
-                children: "Input range not valid"
-            }), jsxRuntime.exports.jsx(ApplyButton, {
-                disabled: disableApply,
-                onClick: (e3) => {
-                    var _a3, _b;
-                    (_a3 = props.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, filteredValues, e3);
-                    (_b = props === null || props === void 0 ? void 0 : props.column) === null || _b === void 0 ? void 0 : _b.setFilter(filteredValues || void 0);
-                    setPreviousFilter(filteredValues);
-                },
-                children: "Apply"
+            style: props.style,
+            children: [jsxRuntime.exports.jsx(PrimaryInput, Object.assign({
+                autoFocus: props.autoFocus,
+                defaultValue: props.initialValue,
+                disabled: props.disabled,
+                isErrored: !!props.errorMsg,
+                maxLength: props.maxLength,
+                onBlur: props.onBlur,
+                onChange: onChange2,
+                onClick: props.onClick,
+                onKeyDown,
+                placeholder: props.placeholder,
+                ref: ref2,
+                type: type2,
+                value: props.value
+            }, addOptionalItems())), props.errorMsg && jsxRuntime.exports.jsxs(ErrorMessage$1, {
+                children: [props.errorMsg, " "]
             })]
         });
-    }
-    const StepperWrapper = styled__default.default.div`
-    cursor: ${(props) => props.disabled ? "not-allowed" : "pointer"};
-
+    });
+    Input$3.displayName = "Input";
+    const Wrapper$b = styled__default.default.div`
     display: flex;
-    flex-direction: column;
-    justify-content: space-around;
-
-    box-sizing: border-box;
-    padding: 0.25rem 0;
-
-    border-radius: 0 0.25rem 0.25rem 0;
+    margin: 0 0.5rem;
 `;
-    const StepperButton = styled__default.default(Button$3)`
-    min-width: 0.75rem;
-    height: max-content;
-    padding: 0;
-    background-color: transparent !important;
-
-    svg {
-        cursor: ${(props) => props.disabled ? "not-allowed" : "pointer"};
-        width: 0.75rem;
-        height: 0.75rem;
-        color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.grey4};
+    const SearchBarComponent = styled__default.default(Input$3)`
+    input {
+        padding-right: 2.25rem;
     }
 
     :hover:not(:disabled) {
-        svg {
-            color: ${(props) => props.theme.colors.grey5};
+        input {
+            border: 1px solid ${(props) => props.theme.colors.grey3};
         }
     }
+`;
+    const SearchBarIcon = styled__default.default(MagnifyingGlass)`
+    position: relative;
+    top: 0.625rem;
+    right: 1.75rem;
 
-    :active:not(:disabled) {
-        svg {
-            transform: scale(0.75);
-        }
-    }
+    height: 1.25rem;
+
+    color: ${(props) => props.theme.colors.grey4};
 `;
-    const InputStepper = ({
-        disabled: disabled2,
-        step: step2,
-        stepSkip
-    }) => {
-        const amountToStep = Math.abs(stepSkip !== null && stepSkip !== void 0 ? stepSkip : 1);
-        const stepUp = () => step2(amountToStep);
-        const stepDown = () => step2(amountToStep * -1);
-        return jsxRuntime.exports.jsxs(StepperWrapper, {
-            disabled: disabled2,
-            children: [jsxRuntime.exports.jsx(StepperButton, {
-                disabled: disabled2,
-                onClick: stepUp,
-                styling: "ghost",
-                tabIndex: -1,
-                children: jsxRuntime.exports.jsx(ChevronUp, {})
-            }), jsxRuntime.exports.jsx(StepperButton, {
-                disabled: disabled2,
-                onClick: stepDown,
-                styling: "ghost",
-                tabIndex: -1,
-                children: jsxRuntime.exports.jsx(ChevronDown, {})
-            })]
+
+    function SearchBar(props) {
+        var _a3;
+        return jsxRuntime.exports.jsxs(Wrapper$b, {
+            children: [jsxRuntime.exports.jsx(SearchBarComponent, {
+                className: props.className,
+                disabled: props.disabled,
+                maxLength: props.maxLength,
+                onChange: props.onChange,
+                placeholder: (_a3 = props.placeholder) !== null && _a3 !== void 0 ? _a3 : "Search",
+                style: props.style,
+                value: props.value
+            }), jsxRuntime.exports.jsx(SearchBarIcon, {})]
         });
-    };
-    const InputWrapper$2 = styled__default.default.div`
+    }
+    const FilterWrapper = styled__default.default.div`
     display: flex;
-    flex-direction: row;
+    flex-direction: column;
+    gap: 0.5rem;
 
-    width: 22ch;
-    height: 2.5rem;
-    padding-right: 0.5rem;
+    width: 17.5rem;
+    padding: 1.25rem 0.5rem;
 
     background-color: ${(props) => props.theme.colors.grey1};
-    border: 1px solid ${(props) => props.errorMsg ? props.theme.colors.error : props.theme.colors.grey1};
+    border-radius: 0.25rem;
+    box-shadow: ${(props) => props.theme.shadow.light};
+`;
+    const StyledSearchBar = styled__default.default(SearchBar)`
+    width: 15.5rem;
+    background-color: ${(props) => props.theme.colors.blue1};
+    border: 1px solid ${(props) => props.theme.colors.blue1};
     border-radius: 0.25rem;
 
     input {
-        height: calc(2.5rem - 2px);
-        border: none;
-        border-radius: 0.25rem;
-    }
-
-    div {
+        width: 15.5rem;
+        background-color: ${(props) => props.theme.colors.blue1};
         border: none;
-        border-radius: 0.25rem;
 
-        div {
+        :active:not(:disabled),
+        :focus:not(:disabled) {
             border: none;
-            border-radius: 0.25rem;
-        }
-    }
-
-    :hover {
-        background-color: ${(props) => props.disabled ? props.theme.colors.grey1 : props.theme.colors.grey2};
-        /* stylelint-disable -- fails to parse the statement */
-        border: 1px solid
-            ${(props) => {
-    if (props.disabled) {
-      return props.theme.colors.grey1;
-    }
-    if (props.errorMsg) {
-      return props.theme.colors.error;
-    }
-    return props.theme.colors.grey2;
-  }};
-        /* stylelint-enable */
-
-        input {
-            background-color: ${(props) => props.disabled ? props.theme.colors.grey1 : props.theme.colors.grey2};
-        }
-
-        div {
-            background-color: ${(props) => props.disabled ? props.theme.colors.grey1 : props.theme.colors.grey2};
         }
     }
 
-    :focus-within:not(:disabled) {
-        border: 1px solid ${(props) => props.errorMsg ? props.theme.colors.error : props.theme.colors.grey3};
+    :hover:not(:disabled) {
+        background-color: ${(props) => props.theme.colors.blue1};
+        border: 1px solid ${(props) => props.theme.colors.grey2};
 
         input {
+            background-color: ${(props) => props.theme.colors.blue1};
             border: none;
         }
     }
-
-    /* Fix: Overrides the 22ch default width of the nested regular input */
-    > div:first-child {
-        width: 100%;
-        height: auto;
-    }
-`;
-    const numericFilter = (integerOnly) => (e3) => {
-        if (parseInt(e3.key) || parseInt(e3.key) === 0) {
-            return true;
-        }
-        if (CONTROL_KEYS.includes(e3.key)) {
-            return true;
-        }
-        const target = e3.target;
-        if (!integerOnly && e3.key === Key.PERIOD && !target.value.includes(Key.PERIOD)) {
-            return true;
-        }
-        if (e3.key === Key.MINUS && !e3.shiftKey && target.selectionStart === 0 && !target.value.includes(Key.MINUS)) {
-            return true;
-        }
-        return false;
-    };
-    const getInitialValue = (value, initialValue) => {
-        if (Number.isFinite(value)) {
-            return String(value);
-        }
-        if (Number.isFinite(initialValue)) {
-            return String(initialValue);
-        }
-        return "";
-    };
-    const NumericInput = React__namespace.forwardRef((props, ref2) => {
-        const keydownFilter = React.useMemo(() => numericFilter(props.integerOnly), [props.integerOnly]);
-        const [input, setInput] = React.useState(getInitialValue(props.value, props.initialValue));
-        const step2 = (value) => {
-            var _a3;
-            if (!input || input === "-") {
-                return;
-            }
-            const isFloat = input.includes(".");
-            const parsedValue = isFloat ? parseFloat(input) : parseInt(input);
-            let nextValueNumber = parsedValue + value;
-            let nextValueStr = String(nextValueNumber);
-            if (isFloat) {
-                const decimals = input.split(".")[1];
-                if (decimals) {
-                    nextValueStr = (parsedValue + value / Math.pow(10, decimals.length)).toFixed(decimals.length);
-                    nextValueNumber = parseFloat(nextValueStr);
-                }
-            }
-            if (props.value !== void 0) {
-                (_a3 = props.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, nextValueNumber, {
-                    target: {
-                        value: nextValueStr
-                    }
-                });
-            } else {
-                setInput(nextValueStr);
-            }
-        };
-        const onKeyDown = (e3) => {
-            var _a3, _b;
-            (_a3 = props.onKeyDown) === null || _a3 === void 0 ? void 0 : _a3.call(props, e3);
-            if (!props.stepper) {
-                return;
-            }
-            const stepSkip = Math.abs((_b = props.stepSkip) !== null && _b !== void 0 ? _b : 1);
-            if (e3.key === Key.UP) {
-                step2(stepSkip);
-            }
-            if (e3.key === Key.DOWN) {
-                step2(stepSkip * -1);
-            }
-        };
-        const onChange2 = React.useCallback(
-            (value, e3) => {
-                var _a3, _b;
-                const parsed = props.integerOnly ? parseInt(value) : parseFloat(value);
-                if (props.value === void 0) {
-                    setInput(value);
-                    (_a3 = props.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, parsed, e3);
-                    return;
-                }
-                if (value.endsWith(".")) {
-                    setInput(value);
-                    return;
-                }
-                if (value.includes(".") && value.endsWith("0")) {
-                    setInput(value);
-                    return;
-                }
-                if (value === "-") {
-                    setInput(value);
-                    return;
-                }
-                (_b = props.onChange) === null || _b === void 0 ? void 0 : _b.call(props, parsed, e3);
-            },
-            [props.integerOnly, props.value, props.onChange]
-        );
-        React.useEffect(() => {
-            setInput(getInitialValue(props.value, props.initialValue));
-        }, [props.value]);
-        return jsxRuntime.exports.jsxs("div", {
-            children: [jsxRuntime.exports.jsxs(InputWrapper$2, {
-                disabled: props.disabled,
-                errorMsg: props.errorMsg,
-                stepper: props.stepper,
-                style: props.style,
-                children: [jsxRuntime.exports.jsx(Input$3, {
-                    autoFocus: props.autoFocus,
-                    className: props.className,
-                    disabled: props.disabled,
-                    keydownFilter,
-                    maxValue: props.maxValue,
-                    minValue: props.minValue,
-                    onBlur: props.onBlur,
-                    onChange: onChange2,
-                    onComplete: props.onComplete,
-                    onKeyDown,
-                    placeholder: props.placeholder,
-                    ref: ref2,
-                    value: input
-                }), props.stepper && jsxRuntime.exports.jsx(InputStepper, {
-                    disabled: props.disabled,
-                    step: step2,
-                    stepSkip: props.stepSkip
-                })]
-            }), props.errorMsg && jsxRuntime.exports.jsx(ErrorMessage$1, {
-                children: props.errorMsg
-            })]
-        });
-    });
-    Input$3.displayName = "NumericInput";
-    var isArray$b = isArray_1;
-
-    function castArray() {
-        if (!arguments.length) {
-            return [];
-        }
-        var value = arguments[0];
-        return isArray$b(value) ? value : [value];
-    }
-    var castArray_1 = castArray;
-    const Wrapper$5 = styled__default.default.div`
-    overflow: auto;
-    display: grid;
-    grid-template-columns: repeat(${(props) => props.itemsPerRow}, 1fr);
-
-    max-height: 100%;
-    margin: 2rem;
-    padding: 1rem;
-
-    color: ${(props) => props.theme.colors.text};
-
-    background-color: ${(props) => props.theme.colors.grey1};
-    border-radius: 0.25rem;
 `;
-    const Card$2 = styled__default.default.div`
-    cursor: pointer;
-
-    position: relative;
-
-    display: flex;
-    flex-direction: column;
-    align-items: center;
-    justify-content: center;
-
-    margin: 1rem;
-    padding: 1rem;
-
-    text-align: center;
+    const FilterButtons = styled__default.default.button`
+    font-size: 0.75rem;
+    font-weight: 400;
+    color: ${(props) => props.theme.colors.primary};
 
-    background-color: ${(props) => props.theme.colors.blue1};
-    border: ${(props) => `2px solid ${props.selected ? props.theme.colors.primary : "transparent"}`};
-    border-radius: 0.25rem;
+    background-color: inherit;
+    border: none;
 
     :hover {
-        border: ${(props) => `2px solid ${props.selected ? props.theme.colors.primary : props.theme.colors.grey3}`};
+        cursor: pointer;
+        color: ${(props) => props.theme.colors.primaryHover};
     }
-`;
-    const CardTitle = styled__default.default.h2`
-    margin-top: 1rem;
-`;
-    const CardSubtitle = styled__default.default.h4`
-    margin-top: 1rem;
-    color: ${(props) => props.theme.colors.grey6};
-`;
-    const StyledCheckSquare = styled__default.default(CheckSquare)`
-    cursor: pointer;
 
-    position: absolute;
-    z-index: 3;
-    top: 10px;
-    right: 10px;
+    :active {
+        color: ${(props) => props.theme.colors.primaryDown};
+    }
 
-    color: ${(props) => props.theme.colors.primary};
+    :disabled {
+        cursor: not-allowed;
+        color: ${(props) => props.theme.colors.grey2};
+    }
 `;
-    const ComponentWrapper = styled__default.default.div`
-    cursor: pointer;
-    display: flex;
-    width: 100%;
+    const OptionsWrapper = styled__default.default.div`
+    overflow-y: auto;
+    height: 10rem;
 `;
-
-    function getSelectedIndex(selectedItems, item) {
-        return selectedItems.findIndex((selectedItem) => selectedItem === item.title);
+    const StyledCheckboxGroup = styled__default.default(CheckboxGroup$1)`
+    div {
+        height: 2rem;
+        padding: 0 0.75rem;
     }
 
-    function updateSelectedItems(prevSelections, item, multiSelect) {
-        const selectedIndex = getSelectedIndex(prevSelections, item);
-        if (selectedIndex > -1) {
-            return prevSelections.filter((_2, index2) => index2 !== selectedIndex);
-        }
-        if (multiSelect) {
-            return [...prevSelections, item.title];
+    label {
+        font-size: 0.75rem;
+
+        :hover {
+            background: ${(props) => props.theme.colors.grey2} !important;
         }
-        return [item.title];
-    }
 
-    function ComponentSelectList$1(props) {
-        const [selectedCards, setSelectedCards] = React.useState(props.selectedItems ? castArray_1(props.selectedItems) : []);
-        React.useEffect(() => {
-            setSelectedCards(props.selectedItems ? castArray_1(props.selectedItems) : []);
-        }, [props.selectedItems]);
-        const onClick = React.useCallback(
-            (index2) => {
-                var _a3;
-                const updatedSelectedCards = updateSelectedItems(selectedCards, props.items[index2], props.multiSelect);
-                setSelectedCards(updatedSelectedCards);
-                (_a3 = props.onSelect) === null || _a3 === void 0 ? void 0 : _a3.call(props, updatedSelectedCards);
-            },
-            [props.items, props.multiSelect, selectedCards, setSelectedCards]
-        );
-        return jsxRuntime.exports.jsx(Wrapper$5, {
-            className: props.className,
-            itemsPerRow: props.itemsPerRow && props.itemsPerRow > 0 ? props.itemsPerRow : 3,
-            style: props.style,
-            children: props.items.map((item, index2) => jsxRuntime.exports.jsxs(Card$2, {
-                onClick: () => onClick(index2),
-                selected: getSelectedIndex(selectedCards, item) > -1,
-                children: [getSelectedIndex(selectedCards, item) > -1 && jsxRuntime.exports.jsx(StyledCheckSquare, {
-                    size: "2x"
-                }), jsxRuntime.exports.jsx(ComponentWrapper, {
-                    children: item.component
-                }), jsxRuntime.exports.jsx(CardTitle, {
-                    children: item.title
-                }), item.subtitle && jsxRuntime.exports.jsx(CardSubtitle, {
-                    children: item.subtitle
-                })]
-            }, `${item.title}-${index2}`))
-        });
+        :active {
+            background: ${(props) => props.theme.colors.grey3} !important;
+        }
     }
-    const Track$1 = styled__default.default.div`
-    position: relative;
-
-    overflow: hidden;
-    display: flex;
-
-    width: 100%;
-    height: ${(props) => props.small ? "0.5rem" : "1rem"};
-
-    background-color: ${(props) => props.theme.colors.grey2};
-    border-radius: ${(props) => props.small ? "0.25rem" : "0.5rem"};
-`;
-    const Bar = styled__default.default.div`
-    position: absolute;
-
-    overflow: ${(props) => props.multi ? "hidden" : "visible"};
-
-    height: 100%;
-
-    background-color: ${(props) => props.color ? props.color : props.theme.colors.primary};
-    border-radius: ${(props) => props.small ? "0.25rem" : "0.5rem"};
 `;
-    const Text$3 = styled__default.default.span`
-    position: absolute;
-    right: 0.5rem;
-    bottom: 0.05rem;
-    left: 0.5rem;
+    const ApplyButton = styled__default.default(FilterButtons)`
+    align-self: center;
 
-    height: 100%;
+    width: fit-content;
+    height: 2rem;
+    padding: 0.5rem;
 
-    font-size: 0.75rem;
-    color: ${(props) => props.theme.colors.blue1};
-    text-align: end;
+    font-size: 0.875rem;
 `;
-    const defaultColors = [theme$3.colors.primary, theme$3.colors.success, theme$3.colors.warning, theme$3.colors.error];
-    const arrayify = (input, defaultInput) => {
-        if (typeof input === "undefined") {
-            return defaultInput;
-        }
-        if (Array.isArray(input)) {
-            return input;
-        }
-        return [input];
-    };
 
-    function ProgressBar$1(props) {
-        const progresses = typeof props.progress === "number" ? [{
-            index: 0,
-            value: props.progress
-        }] : lodash$1.exports.sortBy([...props.progress.map((x2, i2) => ({
-            index: i2,
-            value: x2
-        }))], "value").reverse();
-        const colors2 = arrayify(props.color, defaultColors.slice(0, progresses.length));
-        const labels = arrayify(props.label, progresses.map((x2) => `${x2.value}%`));
-        return jsxRuntime.exports.jsx(Track$1, {
+    function CategoricalFilter(props) {
+        var _a3;
+        const [inputValue, setInputValue] = React.useState("");
+        const [filterValue, setFilterValue] = React.useState((_a3 = props.values) !== null && _a3 !== void 0 ? _a3 : []);
+        const [previousFilter, setPreviousFilter] = React.useState(props.values);
+        const filteredItems = props.items.filter((item) => {
+            var _a4;
+            return inputValue ? (_a4 = item.label) === null || _a4 === void 0 ? void 0 : _a4.toLowerCase().includes(inputValue === null || inputValue === void 0 ? void 0 : inputValue.toLowerCase()) : true;
+        });
+        return jsxRuntime.exports.jsxs(FilterWrapper, {
             className: props.className,
-            multi: typeof props.progress !== "number",
-            small: props.small,
-            style: props.style,
-            children: progresses.map((progress, index2) => jsxRuntime.exports.jsx(Bar, {
-                color: colors2[progress.index],
-                multi: typeof props.progress !== "number",
-                small: props.small,
+            children: [jsxRuntime.exports.jsx(StyledSearchBar, {
+                onChange: (change) => setInputValue(change)
+            }), jsxRuntime.exports.jsxs("div", {
                 style: {
-                    width: `${progress.value}%`
+                    display: "flex",
+                    height: "2rem",
+                    margin: "0rem 0.75rem -0.5rem 0.75rem"
                 },
-                children: !props.small && jsxRuntime.exports.jsx(Text$3, {
-                    progress: progress.value,
-                    children: labels[progress.index]
+                children: [jsxRuntime.exports.jsx(FilterButtons, {
+                    onClick: () => setFilterValue(filteredItems),
+                    children: "Select all"
+                }), jsxRuntime.exports.jsx(FilterButtons, {
+                    onClick: () => setFilterValue([]),
+                    children: "Clear"
+                })]
+            }), jsxRuntime.exports.jsx(OptionsWrapper, {
+                children: jsxRuntime.exports.jsx(StyledCheckboxGroup, {
+                    isListStyle: true,
+                    items: filteredItems,
+                    onChange: (v2) => {
+                        var _a4, _b;
+                        const selectedFilteredItems = Array.isArray(v2) ? v2 : [v2];
+                        const unchecked = (_a4 = filterValue === null || filterValue === void 0 ? void 0 : filterValue.filter((value) => selectedFilteredItems.every((item) => !isEqual_1(value, item)) && filteredItems.some((item) => isEqual_1(value, item)))) !== null && _a4 !== void 0 ? _a4 : [];
+                        const newlyChecked = selectedFilteredItems.filter((value) => filterValue === null || filterValue === void 0 ? void 0 : filterValue.every((item) => !isEqual_1(value, item)));
+                        const stillChecked = (_b = filterValue === null || filterValue === void 0 ? void 0 : filterValue.filter((value) => !unchecked.some((item) => isEqual_1(value, item)))) !== null && _b !== void 0 ? _b : [];
+                        setFilterValue([...stillChecked, ...newlyChecked]);
+                    },
+                    values: filterValue
                 })
-            }, index2))
+            }), jsxRuntime.exports.jsx(ApplyButton, {
+                disabled: props.disabled || previousFilter === filterValue,
+                onClick: (e3) => {
+                    var _a4, _b;
+                    (_a4 = props.onChange) === null || _a4 === void 0 ? void 0 : _a4.call(props, filterValue, e3);
+                    (_b = props === null || props === void 0 ? void 0 : props.column) === null || _b === void 0 ? void 0 : _b.setFilter(filterValue || void 0);
+                    setPreviousFilter(filterValue);
+                },
+                children: "Apply"
+            })]
         });
     }
-    const RadioGroupWrapper = styled__default.default.div`
-    display: ${(props) => props.isHorizontal ? "flex" : "block"};
-    gap: ${(props) => props.isHorizontal ? "1.25rem" : "0rem"};
-`;
-    const RadioWrapper = styled__default.default.label`
-    cursor: ${(props) => props["aria-disabled"] ? "not-allowed" : "pointer"};
-    user-select: none;
-
-    display: flex;
-    gap: 0.5rem;
-    align-items: center;
-    justify-content: flex-start;
-
-    width: ${(props) => props.isListStyle ? "auto" : "fit-content"};
-    height: 2.5rem;
-    padding: 0 0.5rem;
-
-    color: ${(props) => props["aria-disabled"] ? props.theme.colors.grey3 : props.theme.colors.text};
-
-    border: none;
-    border-radius: 0.25rem;
-
-    /* sets checkmark indicator */
-    span::after {
-        top: calc(0.25rem - 1px);
-        left: calc(0.25rem - 1px);
-
-        width: 0.5rem;
-        height: 0.5rem;
 
-        background-color: ${(props) => props["aria-disabled"] ? props.theme.colors.grey3 : props.theme.colors.grey5};
-        border-radius: 50%;
+    function _objectWithoutPropertiesLoose$4(source, excluded) {
+        if (source == null)
+            return {};
+        var target = {};
+        var sourceKeys = Object.keys(source);
+        var key, i2;
+        for (i2 = 0; i2 < sourceKeys.length; i2++) {
+            key = sourceKeys[i2];
+            if (excluded.indexOf(key) >= 0)
+                continue;
+            target[key] = source[key];
+        }
+        return target;
     }
-
-    /* Show the checkmark when checked */
-    input:checked ~ span::after {
-        display: block;
+    var reactIs = {
+        exports: {}
+    };
+    var reactIs_production_min = {};
+    /** @license React v17.0.2
+     * react-is.production.min.js
+     *
+     * Copyright (c) Facebook, Inc. and its affiliates.
+     *
+     * This source code is licensed under the MIT license found in the
+     * LICENSE file in the root directory of this source tree.
+     */
+    var b$3 = 60103,
+        c$4 = 60106,
+        d$1 = 60107,
+        e$2 = 60108,
+        f$2 = 60114,
+        g$2 = 60109,
+        h$2 = 60110,
+        k$2 = 60112,
+        l$2 = 60113,
+        m$2 = 60120,
+        n$2 = 60115,
+        p$2 = 60116,
+        q$2 = 60121,
+        r$2 = 60122,
+        u$1 = 60117,
+        v$2 = 60129,
+        w$3 = 60131;
+    if ("function" === typeof Symbol && Symbol.for) {
+        var x$3 = Symbol.for;
+        b$3 = x$3("react.element");
+        c$4 = x$3("react.portal");
+        d$1 = x$3("react.fragment");
+        e$2 = x$3("react.strict_mode");
+        f$2 = x$3("react.profiler");
+        g$2 = x$3("react.provider");
+        h$2 = x$3("react.context");
+        k$2 = x$3("react.forward_ref");
+        l$2 = x$3("react.suspense");
+        m$2 = x$3("react.suspense_list");
+        n$2 = x$3("react.memo");
+        p$2 = x$3("react.lazy");
+        q$2 = x$3("react.block");
+        r$2 = x$3("react.server.block");
+        u$1 = x$3("react.fundamental");
+        v$2 = x$3("react.debug_trace_mode");
+        w$3 = x$3("react.legacy_hidden");
     }
 
-    /* Controls background color change depending on style */
-    ${(props) => {
-    if (props.isListStyle) {
-      return `:hover {
-                        background-color: ${props["aria-disabled"] ? "none" : props.theme.colors.grey1}
+    function y$5(a2) {
+        if ("object" === typeof a2 && null !== a2) {
+            var t2 = a2.$$typeof;
+            switch (t2) {
+                case b$3:
+                    switch (a2 = a2.type, a2) {
+                        case d$1:
+                        case f$2:
+                        case e$2:
+                        case l$2:
+                        case m$2:
+                            return a2;
+                        default:
+                            switch (a2 = a2 && a2.$$typeof, a2) {
+                                case h$2:
+                                case k$2:
+                                case p$2:
+                                case n$2:
+                                case g$2:
+                                    return a2;
+                                default:
+                                    return t2;
+                            }
+                    }
+                case c$4:
+                    return t2;
             }
-            :active {
-                background-color: ${props["aria-disabled"] ? "none" : props.theme.colors.grey2}
-    }`;
+        }
     }
-    return `: hover {
-            span {
-                background - color: $ {
-                    props["aria-disabled"] ? "none" : props.theme.colors.grey1
-                };
+    var z$2 = g$2,
+        A$2 = b$3,
+        B$1 = k$2,
+        C$3 = d$1,
+        D$2 = p$2,
+        E$1 = n$2,
+        F$3 = c$4,
+        G$1 = f$2,
+        H$3 = e$2,
+        I$1 = l$2;
+    reactIs_production_min.ContextConsumer = h$2;
+    reactIs_production_min.ContextProvider = z$2;
+    reactIs_production_min.Element = A$2;
+    reactIs_production_min.ForwardRef = B$1;
+    reactIs_production_min.Fragment = C$3;
+    reactIs_production_min.Lazy = D$2;
+    reactIs_production_min.Memo = E$1;
+    reactIs_production_min.Portal = F$3;
+    reactIs_production_min.Profiler = G$1;
+    reactIs_production_min.StrictMode = H$3;
+    reactIs_production_min.Suspense = I$1;
+    reactIs_production_min.isAsyncMode = function() {
+        return false;
+    };
+    reactIs_production_min.isConcurrentMode = function() {
+        return false;
+    };
+    reactIs_production_min.isContextConsumer = function(a2) {
+        return y$5(a2) === h$2;
+    };
+    reactIs_production_min.isContextProvider = function(a2) {
+        return y$5(a2) === g$2;
+    };
+    reactIs_production_min.isElement = function(a2) {
+        return "object" === typeof a2 && null !== a2 && a2.$$typeof === b$3;
+    };
+    reactIs_production_min.isForwardRef = function(a2) {
+        return y$5(a2) === k$2;
+    };
+    reactIs_production_min.isFragment = function(a2) {
+        return y$5(a2) === d$1;
+    };
+    reactIs_production_min.isLazy = function(a2) {
+        return y$5(a2) === p$2;
+    };
+    reactIs_production_min.isMemo = function(a2) {
+        return y$5(a2) === n$2;
+    };
+    reactIs_production_min.isPortal = function(a2) {
+        return y$5(a2) === c$4;
+    };
+    reactIs_production_min.isProfiler = function(a2) {
+        return y$5(a2) === f$2;
+    };
+    reactIs_production_min.isStrictMode = function(a2) {
+        return y$5(a2) === e$2;
+    };
+    reactIs_production_min.isSuspense = function(a2) {
+        return y$5(a2) === l$2;
+    };
+    reactIs_production_min.isValidElementType = function(a2) {
+        return "string" === typeof a2 || "function" === typeof a2 || a2 === d$1 || a2 === f$2 || a2 === v$2 || a2 === e$2 || a2 === l$2 || a2 === m$2 || a2 === w$3 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === p$2 || a2.$$typeof === n$2 || a2.$$typeof === g$2 || a2.$$typeof === h$2 || a2.$$typeof === k$2 || a2.$$typeof === u$1 || a2.$$typeof === q$2 || a2[0] === r$2) ? true : false;
+    };
+    reactIs_production_min.typeOf = y$5;
+    (function(module2) {
+        {
+            module2.exports = reactIs_production_min;
+        }
+    })(reactIs);
+    let e$1 = (e3) => "object" == typeof e3 && null != e3 && 1 === e3.nodeType,
+        t$2 = (e3, t2) => (!t2 || "hidden" !== e3) && ("visible" !== e3 && "clip" !== e3),
+        n$1 = (e3, n2) => {
+            if (e3.clientHeight < e3.scrollHeight || e3.clientWidth < e3.scrollWidth) {
+                let l2 = getComputedStyle(e3, null);
+                return t$2(l2.overflowY, n2) || t$2(l2.overflowX, n2) || ((e4) => {
+                    let t2 = ((e6) => {
+                        if (!e6.ownerDocument || !e6.ownerDocument.defaultView)
+                            return null;
+                        try {
+                            return e6.ownerDocument.defaultView.frameElement;
+                        } catch (e7) {
+                            return null;
+                        }
+                    })(e4);
+                    return !!t2 && (t2.clientHeight < e4.scrollHeight || t2.clientWidth < e4.scrollWidth);
+                })(e3);
+            }
+            return false;
+        },
+        l$1 = (e3, t2, n2, l2, i2, o2, r2, d2) => o2 < e3 && r2 > t2 || o2 > e3 && r2 < t2 ? 0 : o2 <= e3 && d2 <= n2 || r2 >= t2 && d2 >= n2 ? o2 - e3 - l2 : r2 > t2 && d2 < n2 || o2 < e3 && d2 > n2 ? r2 - t2 + i2 : 0,
+        i$4 = (e3) => {
+            let t2 = e3.parentElement;
+            return null == t2 ? e3.getRootNode().host || null : t2;
+        };
+    var o$3 = (t2, o2) => {
+        var r2, d2, h2, f2, u2, s2;
+        if ("undefined" == typeof document)
+            return [];
+        let {
+            scrollMode: a2,
+            block: c2,
+            inline: g2,
+            boundary: m2,
+            skipOverflowHiddenElements: p2
+        } = o2, w2 = "function" == typeof m2 ? m2 : (e3) => e3 !== m2;
+        if (!e$1(t2))
+            throw new TypeError("Invalid target");
+        let W2 = document.scrollingElement || document.documentElement,
+            H2 = [],
+            b2 = t2;
+        for (; e$1(b2) && w2(b2);) {
+            if (b2 = i$4(b2), b2 === W2) {
+                H2.push(b2);
+                break;
             }
+            null != b2 && b2 === document.body && n$1(b2) && !n$1(document.documentElement) || null != b2 && n$1(b2, p2) && H2.push(b2);
         }
-
-        : active {
-            span {
-                background - color: $ {
-                    props["aria-disabled"] ? "none" : props.theme.colors.grey2
-                };
+        let v2 = null != (d2 = null == (r2 = window.visualViewport) ? void 0 : r2.width) ? d2 : innerWidth,
+            y2 = null != (f2 = null == (h2 = window.visualViewport) ? void 0 : h2.height) ? f2 : innerHeight,
+            E2 = null != (u2 = window.scrollX) ? u2 : pageXOffset,
+            M2 = null != (s2 = window.scrollY) ? s2 : pageYOffset,
+            {
+                height: x2,
+                width: I2,
+                top: C2,
+                right: R2,
+                bottom: T2,
+                left: V2
+            } = t2.getBoundingClientRect(),
+            k2 = "start" === c2 || "nearest" === c2 ? C2 : "end" === c2 ? T2 : C2 + x2 / 2,
+            B2 = "center" === g2 ? V2 + I2 / 2 : "end" === g2 ? R2 : V2,
+            D2 = [];
+        for (let e3 = 0; e3 < H2.length; e3++) {
+            let t3 = H2[e3],
+                {
+                    height: n2,
+                    width: i2,
+                    top: o3,
+                    right: r3,
+                    bottom: d3,
+                    left: h3
+                } = t3.getBoundingClientRect();
+            if ("if-needed" === a2 && C2 >= 0 && V2 >= 0 && T2 <= y2 && R2 <= v2 && C2 >= o3 && T2 <= d3 && V2 >= h3 && R2 <= r3)
+                return D2;
+            let f3 = getComputedStyle(t3),
+                u3 = parseInt(f3.borderLeftWidth, 10),
+                s3 = parseInt(f3.borderTopWidth, 10),
+                m3 = parseInt(f3.borderRightWidth, 10),
+                p3 = parseInt(f3.borderBottomWidth, 10),
+                w3 = 0,
+                b3 = 0,
+                O2 = "offsetWidth" in t3 ? t3.offsetWidth - t3.clientWidth - u3 - m3 : 0,
+                X2 = "offsetHeight" in t3 ? t3.offsetHeight - t3.clientHeight - s3 - p3 : 0,
+                Y2 = "offsetWidth" in t3 ? 0 === t3.offsetWidth ? 0 : i2 / t3.offsetWidth : 0,
+                L2 = "offsetHeight" in t3 ? 0 === t3.offsetHeight ? 0 : n2 / t3.offsetHeight : 0;
+            if (W2 === t3)
+                w3 = "start" === c2 ? k2 : "end" === c2 ? k2 - y2 : "nearest" === c2 ? l$1(M2, M2 + y2, y2, s3, p3, M2 + k2, M2 + k2 + x2, x2) : k2 - y2 / 2, b3 = "start" === g2 ? B2 : "center" === g2 ? B2 - v2 / 2 : "end" === g2 ? B2 - v2 : l$1(E2, E2 + v2, v2, u3, m3, E2 + B2, E2 + B2 + I2, I2), w3 = Math.max(0, w3 + M2), b3 = Math.max(0, b3 + E2);
+            else {
+                w3 = "start" === c2 ? k2 - o3 - s3 : "end" === c2 ? k2 - d3 + p3 + X2 : "nearest" === c2 ? l$1(o3, d3, n2, s3, p3 + X2, k2, k2 + x2, x2) : k2 - (o3 + n2 / 2) + X2 / 2, b3 = "start" === g2 ? B2 - h3 - u3 : "center" === g2 ? B2 - (h3 + i2 / 2) + O2 / 2 : "end" === g2 ? B2 - r3 + m3 + O2 : l$1(h3, r3, i2, u3, m3 + O2, B2, B2 + I2, I2);
+                let {
+                    scrollLeft: e4,
+                    scrollTop: f4
+                } = t3;
+                w3 = Math.max(0, Math.min(f4 + w3 / L2, t3.scrollHeight - n2 / L2 + X2)), b3 = Math.max(0, Math.min(e4 + b3 / Y2, t3.scrollWidth - i2 / Y2 + O2)), k2 += f4 - w3, B2 += e4 - b3;
             }
+            D2.push({
+                el: t3,
+                top: w3,
+                left: b3
+            });
         }
-    `;
-  }}
-
-    /* Sets the outer rim color of radio button */
-    :hover {
-        span {
-            border: 1px solid
-                ${(props) => props["aria-disabled"] ? props.theme.colors.grey2 : props.theme.colors.grey4};
+        return D2;
+    };
+    var extendStatics = function(d2, b2) {
+        extendStatics = Object.setPrototypeOf || {
+            __proto__: []
         }
-    }
+        instanceof Array && function(d3, b3) {
+            d3.__proto__ = b3;
+        } || function(d3, b3) {
+            for (var p2 in b3)
+                if (Object.prototype.hasOwnProperty.call(b3, p2))
+                    d3[p2] = b3[p2];
+        };
+        return extendStatics(d2, b2);
+    };
 
-    :active {
-        span {
-            border: 1px solid
-                ${(props) => props["aria-disabled"] ? props.theme.colors.grey2 : props.theme.colors.grey4};
+    function __extends(d2, b2) {
+        if (typeof b2 !== "function" && b2 !== null)
+            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
+        extendStatics(d2, b2);
+
+        function __() {
+            this.constructor = d2;
         }
+        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
     }
-`;
-    const RadioButton = styled__default.default.input`
-    position: absolute;
-    opacity: 0;
-`;
-    const StyledCheckmark = styled__default.default.span`
-    position: relative;
-    top: 0;
-    left: 0;
-
-    width: 1rem;
-    height: 1rem;
+    var __assign = function() {
+        __assign = Object.assign || function __assign2(t2) {
+            for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
+                s2 = arguments[i2];
+                for (var p2 in s2)
+                    if (Object.prototype.hasOwnProperty.call(s2, p2))
+                        t2[p2] = s2[p2];
+            }
+            return t2;
+        };
+        return __assign.apply(this, arguments);
+    };
 
-    background-color: ${(props) => props.disabled ? props.theme.colors.grey1 : props.theme.colors.blue1};
-    border: 1px solid ${(props) => props.disabled ? props.theme.colors.grey2 : props.theme.colors.grey3};
-    border-radius: 50%;
+    function __awaiter$2(thisArg, _arguments, P2, generator) {
+        function adopt(value) {
+            return value instanceof P2 ? value : new P2(function(resolve2) {
+                resolve2(value);
+            });
+        }
+        return new(P2 || (P2 = Promise))(function(resolve2, reject) {
+            function fulfilled(value) {
+                try {
+                    step2(generator.next(value));
+                } catch (e3) {
+                    reject(e3);
+                }
+            }
 
-    ::after {
-        content: '';
-        position: relative;
-        display: none;
-    }
-`;
+            function rejected(value) {
+                try {
+                    step2(generator["throw"](value));
+                } catch (e3) {
+                    reject(e3);
+                }
+            }
 
-    function RadioGroup$1(props) {
-        const [currentSelected, setCurrentSelected] = React.useState(props.items.findIndex((item) => props.value !== void 0 ? isEqual_1(item.value, props.value) : isEqual_1(item.value, props.initialValue)));
-        const uuid2 = React.useRef(null);
-        if (uuid2.current === null) {
-            uuid2.current = nanoid();
-        }
-        const onChangeValue = (event2) => {
-            var _a3;
-            const target = event2.target;
-            const chosenIndex = Number(target.value);
-            if (props.value !== void 0) {
-                (_a3 = props.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, props.items[chosenIndex], event2);
-            } else {
-                setCurrentSelected(chosenIndex);
+            function step2(result) {
+                result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
             }
-        };
-        React.useEffect(() => {
-            setCurrentSelected(props.items.findIndex((item) => props.value !== void 0 ? isEqual_1(item.value, props.value) : isEqual_1(item.value, props.initialValue)));
-        }, [props.value]);
-        return jsxRuntime.exports.jsx(RadioGroupWrapper, {
-            className: props.className,
-            isHorizontal: props.direction === "horizontal",
-            style: props.style,
-            children: props.items.map((item, index2) => {
-                var _a3;
-                return jsxRuntime.exports.jsxs(RadioWrapper, {
-                    "aria-disabled": props.disabled,
-                    isListStyle: props.isListStyle,
-                    children: [jsxRuntime.exports.jsx(RadioButton, {
-                        checked: isEqual_1((_a3 = props.value) === null || _a3 === void 0 ? void 0 : _a3.value, item.value) || currentSelected === index2,
-                        disabled: props.disabled,
-                        name: uuid2.current,
-                        onChange: (e3) => onChangeValue(e3),
-                        type: "radio",
-                        value: index2
-                    }), jsxRuntime.exports.jsx(StyledCheckmark, {
-                        disabled: props.disabled
-                    }), item.label ? item.label : item.value]
-                }, `item-${index2}`);
-            })
+            step2((generator = generator.apply(thisArg, _arguments || [])).next());
         });
     }
-    const {
-        stateChangeTypes
-    } = useCombobox;
-    const ListWrapper = styled__default.default(List)`
-    margin-left: -1px;
-    border-radius: 0 0 0.25rem 0.25rem;
-    box-shadow: ${(props) => props.theme.shadow.light};
-`;
-    const getTextColor = (heading2, selected, theme2) => {
-        if (heading2) {
-            return theme2.colors.text;
-        }
-        if (selected) {
-            return theme2.colors.primary;
-        }
-        return theme2.colors.text;
-    };
-    const ListItemSpan = styled__default.default(ListItem)`
-    cursor: ${(props) => (props === null || props === void 0 ? void 0 : props.heading) ? "text" : "pointer"};
-    user-select: ${(props) => (props === null || props === void 0 ? void 0 : props.heading) ? "text" : "none"};
-
-    display: flex;
-    align-items: center;
-    justify-content: space-between;
 
-    padding: ${(props) => (props === null || props === void 0 ? void 0 : props.heading) || !props.section ? "0 0.7rem" : "0 1.5rem"};
-    padding-right: 0.7rem;
+    function __generator(thisArg, body) {
+        var _2 = {
+                label: 0,
+                sent: function() {
+                    if (t2[0] & 1)
+                        throw t2[1];
+                    return t2[1];
+                },
+                trys: [],
+                ops: []
+            },
+            f2, y2, t2, g2;
+        return g2 = {
+            next: verb(0),
+            "throw": verb(1),
+            "return": verb(2)
+        }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
+            return this;
+        }), g2;
 
-    font-weight: ${(props) => (props === null || props === void 0 ? void 0 : props.heading) ? "bold" : "normal"};
-    color: ${(props) => getTextColor(props === null || props === void 0 ? void 0 : props.heading, props.selected, props.theme)};
+        function verb(n2) {
+            return function(v2) {
+                return step2([n2, v2]);
+            };
+        }
 
-    ${(props) => {
-    if (props.heading) {
-      return `
-                :hover {
-                    background-color: ${props.theme.colors.background};
-                    color: ${props.theme.colors.text};
+        function step2(op) {
+            if (f2)
+                throw new TypeError("Generator is already executing.");
+            while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
+                try {
+                    if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
+                        return t2;
+                    if (y2 = 0, t2)
+                        op = [op[0] & 2, t2.value];
+                    switch (op[0]) {
+                        case 0:
+                        case 1:
+                            t2 = op;
+                            break;
+                        case 4:
+                            _2.label++;
+                            return {
+                                value: op[1], done: false
+                            };
+                        case 5:
+                            _2.label++;
+                            y2 = op[1];
+                            op = [0];
+                            continue;
+                        case 7:
+                            op = _2.ops.pop();
+                            _2.trys.pop();
+                            continue;
+                        default:
+                            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
+                                _2 = 0;
+                                continue;
+                            }
+                            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
+                                _2.label = op[1];
+                                break;
+                            }
+                            if (op[0] === 6 && _2.label < t2[1]) {
+                                _2.label = t2[1];
+                                t2 = op;
+                                break;
+                            }
+                            if (t2 && _2.label < t2[2]) {
+                                _2.label = t2[2];
+                                _2.ops.push(op);
+                                break;
+                            }
+                            if (t2[2])
+                                _2.ops.pop();
+                            _2.trys.pop();
+                            continue;
+                    }
+                    op = body.call(thisArg, _2);
+                } catch (e3) {
+                    op = [6, e3];
+                    y2 = 0;
+                } finally {
+                    f2 = t2 = 0;
                 }
-            `;
+            if (op[0] & 5)
+                throw op[1];
+            return {
+                value: op[0] ? op[1] : void 0,
+                done: true
+            };
+        }
     }
-  }}
-`;
 
-    function instanceOfSectionItem(item) {
-        return "items" in item;
+    function __values(o2) {
+        var s2 = typeof Symbol === "function" && Symbol.iterator,
+            m2 = s2 && o2[s2],
+            i2 = 0;
+        if (m2)
+            return m2.call(o2);
+        if (o2 && typeof o2.length === "number")
+            return {
+                next: function() {
+                    if (o2 && i2 >= o2.length)
+                        o2 = void 0;
+                    return {
+                        value: o2 && o2[i2++],
+                        done: !o2
+                    };
+                }
+            };
+        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
     }
 
-    function unpackSectionedList(listItems) {
-        return listItems.reduce((acc, item) => {
-            if (instanceOfSectionItem(item)) {
-                const sectionHeading = {
-                    heading: true,
-                    label: item.label,
-                    value: item.label
-                };
-                const sectionItems = item.items.map((sectionItem) => Object.assign(Object.assign({}, sectionItem), {
-                    section: item.label
-                }));
-                return [...acc, sectionHeading, ...sectionItems];
+    function __read(o2, n2) {
+        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
+        if (!m2)
+            return o2;
+        var i2 = m2.call(o2),
+            r2, ar = [],
+            e3;
+        try {
+            while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
+                ar.push(r2.value);
+        } catch (error2) {
+            e3 = {
+                error: error2
+            };
+        } finally {
+            try {
+                if (r2 && !r2.done && (m2 = i2["return"]))
+                    m2.call(i2);
+            } finally {
+                if (e3)
+                    throw e3.error;
             }
-            return [...acc, item];
-        }, []);
+        }
+        return ar;
     }
 
-    function SectionedList(props) {
-        var _a3, _b, _c, _d;
-        const theme2 = useClTheme();
-        const referenceElement = React.useRef(null);
-        const popperElement = React.useRef(null);
-        const {
-            styles: styles2,
-            attributes: attributes2,
-            update: update2
-        } = usePopper$1(referenceElement.current, popperElement.current, {
-            modifiers: [sameWidthModifier],
-            placement: "bottom-start"
-        });
-        const unpackedItems = React.useMemo(() => unpackSectionedList(props.items), [props.items]);
-        const [pendingHighlight, setPendingHighlight] = React.useState(null);
-        const [items, setItems] = React.useState(unpackedItems);
-        const [inputValue, setInputValue] = React.useState((_b = (_a3 = props.selectedItem) === null || _a3 === void 0 ? void 0 : _a3.label) !== null && _b !== void 0 ? _b : "");
-        const {
-            selectedItem,
-            isOpen,
-            getMenuProps,
-            getInputProps,
-            getToggleButtonProps,
-            highlightedIndex,
-            getItemProps,
-            setHighlightedIndex
-        } = useCombobox(Object.assign({
-            initialIsOpen: false,
-            initialSelectedItem: (_c = props.initialValue) !== null && _c !== void 0 ? _c : props.selectedItem,
-            itemToString: (item) => item ? item.label : "",
-            items,
-            onInputValueChange: (change) => {
-                setInputValue(change.inputValue);
-                if (!change.inputValue) {
-                    setItems(unpackedItems);
-                    return;
-                }
-                const counts = {};
-                const filteredItems = unpackedItems.filter((item) => {
-                    const lowercaseInput = change.inputValue.toLowerCase();
-                    const lowercaseLabel = item.label.toLowerCase();
-                    if (!item.heading && lowercaseLabel.includes(lowercaseInput)) {
-                        counts[item.label] = counts[item.label] ? counts[item.label] + 1 : 1;
-                        return true;
-                    }
-                    if (item.heading) {
-                        const listSections = props.items.filter((propItem) => propItem.items.find((subItem) => subItem.label.toLowerCase().includes(lowercaseInput)));
-                        if (listSections.length) {
-                            listSections.forEach((section) => {
-                                counts[section.label] = counts[section.label] ? counts[section.label] + 1 : 1;
-                            });
-                            return true;
-                        }
-                    }
-                    return false;
-                });
-                setItems(filteredItems.filter((item) => counts[item.label] > 0));
-            },
-            onSelectedItemChange: (changes) => {
-                var _a4, _b2;
-                if (props.onSelect) {
-                    if (props.selectedItem && ((_a4 = changes.selectedItem) === null || _a4 === void 0 ? void 0 : _a4.value) !== ((_b2 = props.selectedItem) === null || _b2 === void 0 ? void 0 : _b2.value) || !props.selectedItem) {
-                        props.onSelect(changes.selectedItem);
-                    }
-                }
-            },
-            stateReducer: (state, {
-                changes,
-                type: type2
-            }) => {
-                var _a4, _b2, _c2;
-                if (type2 === stateChangeTypes.ControlledPropUpdatedSelectedItem) {
-                    return Object.assign(Object.assign({}, changes), {
-                        inputValue: ""
-                    });
-                }
-                if (type2 === stateChangeTypes.InputFocus || type2 === stateChangeTypes.ToggleButtonClick && changes.isOpen) {
-                    setPendingHighlight(changes.selectedItem ? props.items.findIndex((i2) => i2.value === changes.selectedItem.value) : 0);
-                    return Object.assign(Object.assign({}, changes), {
-                        inputValue: ""
-                    });
-                }
-                if ([
-                        stateChangeTypes.InputKeyDownEnter,
-                        stateChangeTypes.ItemClick,
-                        stateChangeTypes.InputBlur,
-                        stateChangeTypes.InputKeyDownEscape,
-                        stateChangeTypes.ToggleButtonClick
-                    ].includes(type2)) {
-                    return Object.assign(Object.assign({}, changes), {
-                        inputValue: ((_a4 = changes.selectedItem) === null || _a4 === void 0 ? void 0 : _a4.label) || ""
-                    });
-                }
-                if (type2 === stateChangeTypes.InputKeyDownArrowUp && ((_b2 = items[changes.highlightedIndex]) === null || _b2 === void 0 ? void 0 : _b2.heading)) {
-                    return Object.assign(Object.assign({}, changes), {
-                        highlightedIndex: changes.highlightedIndex - 1 < 0 ? items.length - 1 : changes.highlightedIndex - 1
-                    });
-                }
-                if (type2 === stateChangeTypes.InputKeyDownArrowDown && ((_c2 = items[changes.highlightedIndex]) === null || _c2 === void 0 ? void 0 : _c2.heading)) {
-                    return Object.assign(Object.assign({}, changes), {
-                        highlightedIndex: changes.highlightedIndex + 1 === items.length ? 0 : changes.highlightedIndex + 1
-                    });
+    function __spread() {
+        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
+            ar = ar.concat(__read(arguments[i2]));
+        return ar;
+    }
+
+    function __spreadArray(to2, from, pack) {
+        if (pack || arguments.length === 2)
+            for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
+                if (ar || !(i2 in from)) {
+                    if (!ar)
+                        ar = Array.prototype.slice.call(from, 0, i2);
+                    ar[i2] = from[i2];
                 }
-                return changes;
-            }
-        }, "selectedItem" in props && {
-            selectedItem: props.selectedItem
-        }));
-        React.useEffect(() => {
-            if (isOpen && pendingHighlight !== null) {
-                setHighlightedIndex(pendingHighlight);
-                setPendingHighlight(null);
-            }
-        }, [isOpen, pendingHighlight, setHighlightedIndex]);
-        React.useEffect(() => {
-            if (props.selectedItem === null) {
-                setInputValue("");
-            }
-        }, [props.selectedItem]);
-        React.useEffect(() => {
-            if (isOpen && update2) {
-                update2();
             }
-        }, [isOpen, update2]);
-        const menuProps = getMenuProps();
-        const setMenuRef = menuProps.ref;
-        delete menuProps.ref;
-        const setMenuReference = (value) => {
-            setMenuRef(value);
-            popperElement.current = value;
-        };
-        return jsxRuntime.exports.jsxs(Wrapper$a, {
-            className: props.className,
-            isDisabled: props.disabled,
-            isErrored: false,
-            isOpen,
-            style: props.style,
-            children: [jsxRuntime.exports.jsxs(InputWrapper$4, {
-                disabled: props.disabled,
-                isOpen,
-                ref: referenceElement,
-                children: [jsxRuntime.exports.jsx(Input$2, Object.assign({}, getInputProps({
-                    value: inputValue
-                }))), jsxRuntime.exports.jsx(ChevronButton$1, Object.assign({}, getToggleButtonProps(), {
-                    children: jsxRuntime.exports.jsx(Chevron$2, {
-                        disabled: props.disabled,
-                        isOpen
-                    })
-                }))]
-            }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsxs(ListWrapper, Object.assign({}, menuProps, attributes2.popper, {
-                isOpen,
-                ref: setMenuReference,
-                style: Object.assign(Object.assign({}, styles2.popper), {
-                    width: parseFloat((_d = styles2.popper) === null || _d === void 0 ? void 0 : _d.width) + 2,
-                    zIndex: 9999
-                }),
-                children: [items.length > 0 && items.map((item, index2) => {
-                    const itemProps = getItemProps({
-                        index: index2,
-                        item
-                    });
-                    if (item.heading) {
-                        delete itemProps.onClick;
-                    }
-                    return React.createElement(
-                        ListItemSpan,
-                        Object.assign({}, itemProps, {
-                            heading: item.heading,
-                            hovered: index2 === highlightedIndex,
-                            key: `item-${index2}`,
-                            section: item.section,
-                            selected: item.value === (selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.value),
-                            title: item.label
-                        }),
-                        item.label || item.section,
-                        item.badge && jsxRuntime.exports.jsx(Badge, {
-                            color: item.badge.color || theme2.colors.primary,
-                            children: item.badge.label
-                        })
-                    );
-                }), items.length === 0 && jsxRuntime.exports.jsx(NoItemsLabel$1, {
-                    children: "No Items"
-                })]
-            })), document.body)]
-        });
+        return to2.concat(ar || Array.prototype.slice.call(from));
     }
-    var toNumber$1 = toNumber_1;
-    var INFINITY$2 = 1 / 0,
-        MAX_INTEGER = 17976931348623157e292;
+    typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
+        var e3 = new Error(message);
+        return e3.name = "SuppressedError", e3.error = error2, e3.suppressed = suppressed, e3;
+    };
+    var idCounter = 0;
 
-    function toFinite$1(value) {
-        if (!value) {
-            return value === 0 ? value : 0;
-        }
-        value = toNumber$1(value);
-        if (value === INFINITY$2 || value === -INFINITY$2) {
-            var sign2 = value < 0 ? -1 : 1;
-            return sign2 * MAX_INTEGER;
-        }
-        return value === value ? value : 0;
-    }
-    var toFinite_1 = toFinite$1;
-    var toFinite = toFinite_1;
+    function noop$6() {}
 
-    function toInteger$1(value) {
-        var result = toFinite(value),
-            remainder = result % 1;
-        return result === result ? remainder ? result - remainder : result : 0;
+    function scrollIntoView$1(node2, menuNode) {
+        if (!node2) {
+            return;
+        }
+        var actions = o$3(node2, {
+            boundary: menuNode,
+            block: "nearest",
+            scrollMode: "if-needed"
+        });
+        actions.forEach(function(_ref2) {
+            var el = _ref2.el,
+                top2 = _ref2.top,
+                left2 = _ref2.left;
+            el.scrollTop = top2;
+            el.scrollLeft = left2;
+        });
     }
-    var toInteger_1 = toInteger$1;
 
-    function arrayMap$2(array2, iteratee) {
-        var index2 = -1,
-            length = array2 == null ? 0 : array2.length,
-            result = Array(length);
-        while (++index2 < length) {
-            result[index2] = iteratee(array2[index2], index2, array2);
-        }
+    function isOrContainsNode(parent, child, environment) {
+        var result = parent === child || child instanceof environment.Node && parent.contains && parent.contains(child);
         return result;
     }
-    var _arrayMap = arrayMap$2;
-    var Symbol$2 = _Symbol,
-        arrayMap$1 = _arrayMap,
-        isArray$a = isArray_1,
-        isSymbol$4 = isSymbol_1;
-    var INFINITY$1 = 1 / 0;
-    var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0,
-        symbolToString$1 = symbolProto$1 ? symbolProto$1.toString : void 0;
 
-    function baseToString$1(value) {
-        if (typeof value == "string") {
-            return value;
-        }
-        if (isArray$a(value)) {
-            return arrayMap$1(value, baseToString$1) + "";
-        }
-        if (isSymbol$4(value)) {
-            return symbolToString$1 ? symbolToString$1.call(value) : "";
+    function debounce$2(fn2, time) {
+        var timeoutId;
+
+        function cancel() {
+            if (timeoutId) {
+                clearTimeout(timeoutId);
+            }
         }
-        var result = value + "";
-        return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
-    }
-    var _baseToString = baseToString$1;
-    var baseToString = _baseToString;
 
-    function toString$6(value) {
-        return value == null ? "" : baseToString(value);
+        function wrapper() {
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            cancel();
+            timeoutId = setTimeout(function() {
+                timeoutId = null;
+                fn2.apply(void 0, args);
+            }, time);
+        }
+        wrapper.cancel = cancel;
+        return wrapper;
     }
-    var toString_1 = toString$6;
-    var root$5 = _root,
-        toInteger = toInteger_1,
-        toNumber = toNumber_1,
-        toString$5 = toString_1;
-    var nativeIsFinite = root$5.isFinite,
-        nativeMin = Math.min;
 
-    function createRound$1(methodName) {
-        var func = Math[methodName];
-        return function(number2, precision2) {
-            number2 = toNumber(number2);
-            precision2 = precision2 == null ? 0 : nativeMin(toInteger(precision2), 292);
-            if (precision2 && nativeIsFinite(number2)) {
-                var pair2 = (toString$5(number2) + "e").split("e"),
-                    value = func(pair2[0] + "e" + (+pair2[1] + precision2));
-                pair2 = (toString$5(value) + "e").split("e");
-                return +(pair2[0] + "e" + (+pair2[1] - precision2));
+    function callAllEventHandlers() {
+        for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
+            fns[_key2] = arguments[_key2];
+        }
+        return function(event2) {
+            for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
+                args[_key3 - 1] = arguments[_key3];
             }
-            return func(number2);
+            return fns.some(function(fn2) {
+                if (fn2) {
+                    fn2.apply(void 0, [event2].concat(args));
+                }
+                return event2.preventDownshiftDefault || event2.hasOwnProperty("nativeEvent") && event2.nativeEvent.preventDownshiftDefault;
+            });
         };
     }
-    var _createRound = createRound$1;
-    var createRound = _createRound;
-    var round$1 = createRound("round");
-    var round_1 = round$1;
 
-    function _classCallCheck$f(instance2, Constructor) {
-        if (!(instance2 instanceof Constructor)) {
-            throw new TypeError("Cannot call a class as a function");
+    function handleRefs() {
+        for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
+            refs[_key4] = arguments[_key4];
         }
+        return function(node2) {
+            refs.forEach(function(ref2) {
+                if (typeof ref2 === "function") {
+                    ref2(node2);
+                } else if (ref2) {
+                    ref2.current = node2;
+                }
+            });
+        };
     }
 
-    function _defineProperties$f(target, props) {
-        for (var i2 = 0; i2 < props.length; i2++) {
-            var descriptor = props[i2];
-            descriptor.enumerable = descriptor.enumerable || false;
-            descriptor.configurable = true;
-            if ("value" in descriptor)
-                descriptor.writable = true;
-            Object.defineProperty(target, descriptor.key, descriptor);
+    function generateId() {
+        return String(idCounter++);
+    }
+
+    function getA11yStatusMessage$1(_ref2) {
+        var isOpen = _ref2.isOpen,
+            resultCount = _ref2.resultCount,
+            previousResultCount = _ref2.previousResultCount;
+        if (!isOpen) {
+            return "";
+        }
+        if (!resultCount) {
+            return "No results are available.";
         }
+        if (resultCount !== previousResultCount) {
+            return resultCount + " result" + (resultCount === 1 ? " is" : "s are") + " available, use up and down arrow keys to navigate. Press Enter key to select.";
+        }
+        return "";
     }
 
-    function _createClass$f(Constructor, protoProps, staticProps) {
-        if (protoProps)
-            _defineProperties$f(Constructor.prototype, protoProps);
-        if (staticProps)
-            _defineProperties$f(Constructor, staticProps);
-        return Constructor;
+    function getState(state, props) {
+        return Object.keys(state).reduce(function(prevState, key) {
+            prevState[key] = isControlledProp(props, key) ? props[key] : state[key];
+            return prevState;
+        }, {});
     }
 
-    function _defineProperty$m(obj, key, value) {
-        if (key in obj) {
-            Object.defineProperty(obj, key, {
-                value,
-                enumerable: true,
-                configurable: true,
-                writable: true
-            });
-        } else {
-            obj[key] = value;
-        }
-        return obj;
+    function isControlledProp(props, key) {
+        return props[key] !== void 0;
     }
 
-    function ownKeys$5(object2, enumerableOnly) {
-        var keys2 = Object.keys(object2);
-        if (Object.getOwnPropertySymbols) {
-            var symbols = Object.getOwnPropertySymbols(object2);
-            if (enumerableOnly)
-                symbols = symbols.filter(function(sym) {
-                    return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
-                });
-            keys2.push.apply(keys2, symbols);
+    function normalizeArrowKey(event2) {
+        var key = event2.key,
+            keyCode = event2.keyCode;
+        if (keyCode >= 37 && keyCode <= 40 && key.indexOf("Arrow") !== 0) {
+            return "Arrow" + key;
         }
-        return keys2;
+        return key;
     }
 
-    function _objectSpread2(target) {
-        for (var i2 = 1; i2 < arguments.length; i2++) {
-            var source = arguments[i2] != null ? arguments[i2] : {};
-            if (i2 % 2) {
-                ownKeys$5(Object(source), true).forEach(function(key) {
-                    _defineProperty$m(target, key, source[key]);
-                });
-            } else if (Object.getOwnPropertyDescriptors) {
-                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
-            } else {
-                ownKeys$5(Object(source)).forEach(function(key) {
-                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
-                });
-            }
+    function getNextWrappingIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular2) {
+        if (circular2 === void 0) {
+            circular2 = true;
         }
-        return target;
+        if (itemCount === 0) {
+            return -1;
+        }
+        var itemsLastIndex = itemCount - 1;
+        if (typeof baseIndex !== "number" || baseIndex < 0 || baseIndex >= itemCount) {
+            baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;
+        }
+        var newIndex = baseIndex + moveAmount;
+        if (newIndex < 0) {
+            newIndex = circular2 ? itemsLastIndex : 0;
+        } else if (newIndex > itemsLastIndex) {
+            newIndex = circular2 ? 0 : itemsLastIndex;
+        }
+        var nonDisabledNewIndex = getNextNonDisabledIndex(moveAmount, newIndex, itemCount, getItemNodeFromIndex, circular2);
+        if (nonDisabledNewIndex === -1) {
+            return baseIndex >= itemCount ? -1 : baseIndex;
+        }
+        return nonDisabledNewIndex;
     }
 
-    function _inherits(subClass, superClass) {
-        if (typeof superClass !== "function" && superClass !== null) {
-            throw new TypeError("Super expression must either be null or a function");
+    function getNextNonDisabledIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular2) {
+        var currentElementNode = getItemNodeFromIndex(baseIndex);
+        if (!currentElementNode || !currentElementNode.hasAttribute("disabled")) {
+            return baseIndex;
         }
-        subClass.prototype = Object.create(superClass && superClass.prototype, {
-            constructor: {
-                value: subClass,
-                writable: true,
-                configurable: true
+        if (moveAmount > 0) {
+            for (var index2 = baseIndex + 1; index2 < itemCount; index2++) {
+                if (!getItemNodeFromIndex(index2).hasAttribute("disabled")) {
+                    return index2;
+                }
             }
-        });
-        if (superClass)
-            _setPrototypeOf$1(subClass, superClass);
-    }
-
-    function _getPrototypeOf$1(o2) {
-        _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
-            return o3.__proto__ || Object.getPrototypeOf(o3);
-        };
-        return _getPrototypeOf$1(o2);
-    }
-
-    function _setPrototypeOf$1(o2, p2) {
-        _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
-            o3.__proto__ = p3;
-            return o3;
-        };
-        return _setPrototypeOf$1(o2, p2);
+        } else {
+            for (var _index = baseIndex - 1; _index >= 0; _index--) {
+                if (!getItemNodeFromIndex(_index).hasAttribute("disabled")) {
+                    return _index;
+                }
+            }
+        }
+        if (circular2) {
+            return moveAmount > 0 ? getNextNonDisabledIndex(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex(-1, itemCount - 1, itemCount, getItemNodeFromIndex, false);
+        }
+        return -1;
     }
 
-    function _isNativeReflectConstruct$1() {
-        if (typeof Reflect === "undefined" || !Reflect.construct)
-            return false;
-        if (Reflect.construct.sham)
-            return false;
-        if (typeof Proxy === "function")
-            return true;
-        try {
-            Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
-            return true;
-        } catch (e3) {
-            return false;
+    function targetWithinDownshift(target, downshiftElements, environment, checkActiveElement) {
+        if (checkActiveElement === void 0) {
+            checkActiveElement = true;
         }
+        return downshiftElements.some(function(contextNode) {
+            return contextNode && (isOrContainsNode(contextNode, target, environment) || checkActiveElement && isOrContainsNode(contextNode, environment.document.activeElement, environment));
+        });
     }
+    var cleanupStatus = debounce$2(function(documentProp) {
+        getStatusDiv(documentProp).textContent = "";
+    }, 500);
 
-    function _assertThisInitialized$1(self2) {
-        if (self2 === void 0) {
-            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
+    function setStatus(status2, documentProp) {
+        var div2 = getStatusDiv(documentProp);
+        if (!status2) {
+            return;
         }
-        return self2;
+        div2.textContent = status2;
+        cleanupStatus(documentProp);
     }
 
-    function _possibleConstructorReturn(self2, call2) {
-        if (call2 && (typeof call2 === "object" || typeof call2 === "function")) {
-            return call2;
+    function getStatusDiv(documentProp) {
+        if (documentProp === void 0) {
+            documentProp = document;
         }
-        return _assertThisInitialized$1(self2);
+        var statusDiv = documentProp.getElementById("a11y-status-message");
+        if (statusDiv) {
+            return statusDiv;
+        }
+        statusDiv = documentProp.createElement("div");
+        statusDiv.setAttribute("id", "a11y-status-message");
+        statusDiv.setAttribute("role", "status");
+        statusDiv.setAttribute("aria-live", "polite");
+        statusDiv.setAttribute("aria-relevant", "additions text");
+        Object.assign(statusDiv.style, {
+            border: "0",
+            clip: "rect(0 0 0 0)",
+            height: "1px",
+            margin: "-1px",
+            overflow: "hidden",
+            padding: "0",
+            position: "absolute",
+            width: "1px"
+        });
+        documentProp.body.appendChild(statusDiv);
+        return statusDiv;
     }
+    var _excluded$3 = ["isInitialMount", "highlightedIndex", "items", "environment"];
+    var dropdownDefaultStateValues = {
+        highlightedIndex: -1,
+        isOpen: false,
+        selectedItem: null,
+        inputValue: ""
+    };
 
-    function _createSuper(Derived) {
-        var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
-        return function _createSuperInternal() {
-            var Super = _getPrototypeOf$1(Derived),
-                result;
-            if (hasNativeReflectConstruct) {
-                var NewTarget = _getPrototypeOf$1(this).constructor;
-                result = Reflect.construct(Super, arguments, NewTarget);
-            } else {
-                result = Super.apply(this, arguments);
+    function callOnChangeProps(action, state, newState) {
+        var props = action.props,
+            type2 = action.type;
+        var changes = {};
+        Object.keys(state).forEach(function(key) {
+            invokeOnChangeHandler(key, action, state, newState);
+            if (newState[key] !== state[key]) {
+                changes[key] = newState[key];
             }
-            return _possibleConstructorReturn(this, result);
-        };
-    }
-
-    function _slicedToArray$7(arr, i2) {
-        return _arrayWithHoles$7(arr) || _iterableToArrayLimit$7(arr, i2) || _unsupportedIterableToArray$8(arr, i2) || _nonIterableRest$7();
+        });
+        if (props.onStateChange && Object.keys(changes).length) {
+            props.onStateChange(_extends$3({
+                type: type2
+            }, changes));
+        }
     }
 
-    function _toConsumableArray$1(arr) {
-        return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$8(arr) || _nonIterableSpread$1();
+    function invokeOnChangeHandler(key, action, state, newState) {
+        var props = action.props,
+            type2 = action.type;
+        var handler = "on" + capitalizeString(key) + "Change";
+        if (props[handler] && newState[key] !== void 0 && newState[key] !== state[key]) {
+            props[handler](_extends$3({
+                type: type2
+            }, newState));
+        }
     }
 
-    function _arrayWithoutHoles$1(arr) {
-        if (Array.isArray(arr))
-            return _arrayLikeToArray$8(arr);
+    function stateReducer(s2, a2) {
+        return a2.changes;
     }
 
-    function _arrayWithHoles$7(arr) {
-        if (Array.isArray(arr))
-            return arr;
+    function getA11ySelectionMessage(selectionParameters) {
+        var selectedItem = selectionParameters.selectedItem,
+            itemToStringLocal = selectionParameters.itemToString;
+        return selectedItem ? itemToStringLocal(selectedItem) + " has been selected." : "";
     }
+    var updateA11yStatus = debounce$2(function(getA11yMessage, document2) {
+        setStatus(getA11yMessage(), document2);
+    }, 200);
+    var useIsomorphicLayoutEffect$3 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? React.useLayoutEffect : React.useEffect;
 
-    function _iterableToArray$1(iter2) {
-        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter2))
-            return Array.from(iter2);
+    function useElementIds(_ref2) {
+        var _ref$id = _ref2.id,
+            id2 = _ref$id === void 0 ? "downshift-" + generateId() : _ref$id,
+            labelId = _ref2.labelId,
+            menuId = _ref2.menuId,
+            getItemId = _ref2.getItemId,
+            toggleButtonId = _ref2.toggleButtonId,
+            inputId = _ref2.inputId;
+        var elementIdsRef = React.useRef({
+            labelId: labelId || id2 + "-label",
+            menuId: menuId || id2 + "-menu",
+            getItemId: getItemId || function(index2) {
+                return id2 + "-item-" + index2;
+            },
+            toggleButtonId: toggleButtonId || id2 + "-toggle-button",
+            inputId: inputId || id2 + "-input"
+        });
+        return elementIdsRef.current;
     }
 
-    function _iterableToArrayLimit$7(arr, i2) {
-        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
-            return;
-        var _arr = [];
-        var _n2 = true;
-        var _d = false;
-        var _e2 = void 0;
-        try {
-            for (var _i2 = arr[Symbol.iterator](), _s; !(_n2 = (_s = _i2.next()).done); _n2 = true) {
-                _arr.push(_s.value);
-                if (i2 && _arr.length === i2)
-                    break;
-            }
-        } catch (err) {
-            _d = true;
-            _e2 = err;
-        } finally {
-            try {
-                if (!_n2 && _i2["return"] != null)
-                    _i2["return"]();
-            } finally {
-                if (_d)
-                    throw _e2;
+    function getItemAndIndex(itemProp, indexProp, items, errorMessage) {
+        var item, index2;
+        if (itemProp === void 0) {
+            if (indexProp === void 0) {
+                throw new Error(errorMessage);
             }
+            item = items[indexProp];
+            index2 = indexProp;
+        } else {
+            index2 = indexProp === void 0 ? items.indexOf(itemProp) : indexProp;
+            item = itemProp;
         }
-        return _arr;
+        return [item, index2];
     }
 
-    function _unsupportedIterableToArray$8(o2, minLen) {
-        if (!o2)
-            return;
-        if (typeof o2 === "string")
-            return _arrayLikeToArray$8(o2, minLen);
-        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
-        if (n2 === "Object" && o2.constructor)
-            n2 = o2.constructor.name;
-        if (n2 === "Map" || n2 === "Set")
-            return Array.from(o2);
-        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
-            return _arrayLikeToArray$8(o2, minLen);
+    function itemToString(item) {
+        return item ? String(item) : "";
     }
 
-    function _arrayLikeToArray$8(arr, len) {
-        if (len == null || len > arr.length)
-            len = arr.length;
-        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
-            arr2[i2] = arr[i2];
-        return arr2;
+    function isAcceptedCharacterKey(key) {
+        return /^\S{1}$/.test(key);
     }
 
-    function _nonIterableSpread$1() {
-        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
+    function capitalizeString(string2) {
+        return "" + string2.slice(0, 1).toUpperCase() + string2.slice(1);
     }
 
-    function _nonIterableRest$7() {
-        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
+    function useLatestRef(val) {
+        var ref2 = React.useRef(val);
+        ref2.current = val;
+        return ref2;
     }
 
-    function getSortByVal() {
-        var reversed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
-        return function sortByVal(a2, b2) {
-            if (a2.val > b2.val) {
-                return reversed ? -1 : 1;
-            }
-            if (b2.val > a2.val) {
-                return reversed ? 1 : -1;
+    function useEnhancedReducer(reducer2, initialState2, props) {
+        var prevStateRef = React.useRef();
+        var actionRef = React.useRef();
+        var enhancedReducer = React.useCallback(function(state2, action2) {
+            actionRef.current = action2;
+            state2 = getState(state2, action2.props);
+            var changes = reducer2(state2, action2);
+            var newState = action2.props.stateReducer(state2, _extends$3({}, action2, {
+                changes
+            }));
+            return newState;
+        }, [reducer2]);
+        var _useReducer = React.useReducer(enhancedReducer, initialState2),
+            state = _useReducer[0],
+            dispatch2 = _useReducer[1];
+        var propsRef = useLatestRef(props);
+        var dispatchWithProps = React.useCallback(function(action2) {
+            return dispatch2(_extends$3({
+                props: propsRef.current
+            }, action2));
+        }, [propsRef]);
+        var action = actionRef.current;
+        React.useEffect(function() {
+            if (action && prevStateRef.current && prevStateRef.current !== state) {
+                callOnChangeProps(action, getState(prevStateRef.current, action.props), state);
             }
-            return 0;
-        };
+            prevStateRef.current = state;
+        }, [state, props, action]);
+        return [state, dispatchWithProps];
     }
 
-    function getUpdatedHandles(handles, updateKey, updateValue) {
-        var reversed = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
-        var index2 = handles.findIndex(function(v2) {
-            return v2.key === updateKey;
-        });
-        if (index2 !== -1) {
-            var _handles$index = handles[index2],
-                key = _handles$index.key,
-                val = _handles$index.val;
-            if (val === updateValue) {
-                return handles;
-            }
-            return [].concat(_toConsumableArray$1(handles.slice(0, index2)), [{
-                key,
-                val: updateValue
-            }], _toConsumableArray$1(handles.slice(index2 + 1))).sort(getSortByVal(reversed));
+    function useControlledReducer$1(reducer2, initialState2, props) {
+        var _useEnhancedReducer = useEnhancedReducer(reducer2, initialState2, props),
+            state = _useEnhancedReducer[0],
+            dispatch2 = _useEnhancedReducer[1];
+        return [getState(state, props), dispatch2];
+    }
+    var defaultProps$3 = {
+        itemToString,
+        stateReducer,
+        getA11ySelectionMessage,
+        scrollIntoView: scrollIntoView$1,
+        environment: typeof window === "undefined" ? {} : window
+    };
+
+    function getDefaultValue$1(props, propKey, defaultStateValues2) {
+        if (defaultStateValues2 === void 0) {
+            defaultStateValues2 = dropdownDefaultStateValues;
         }
-        return handles;
+        var defaultValue2 = props["default" + capitalizeString(propKey)];
+        if (defaultValue2 !== void 0) {
+            return defaultValue2;
+        }
+        return defaultStateValues2[propKey];
     }
 
-    function getSliderDomain(slider, vertical) {
-        if (!slider) {
-            return [0, 0];
+    function getInitialValue$1(props, propKey, defaultStateValues2) {
+        if (defaultStateValues2 === void 0) {
+            defaultStateValues2 = dropdownDefaultStateValues;
         }
-        var s2 = slider.getBoundingClientRect();
-        var d0 = vertical ? s2.top : s2.left;
-        var d1 = vertical ? s2.bottom : s2.right;
-        return [d0, d1];
+        var value = props[propKey];
+        if (value !== void 0) {
+            return value;
+        }
+        var initialValue = props["initial" + capitalizeString(propKey)];
+        if (initialValue !== void 0) {
+            return initialValue;
+        }
+        return getDefaultValue$1(props, propKey, defaultStateValues2);
     }
 
-    function isNotValidTouch(_ref2) {
-        var _ref$type = _ref2.type,
-            type2 = _ref$type === void 0 ? "" : _ref$type,
-            touches = _ref2.touches;
-        return !touches || touches.length > 1 || type2.toLowerCase() === "touchend" && touches.length > 0;
+    function getInitialState$2(props) {
+        var selectedItem = getInitialValue$1(props, "selectedItem");
+        var isOpen = getInitialValue$1(props, "isOpen");
+        var highlightedIndex = getInitialValue$1(props, "highlightedIndex");
+        var inputValue = getInitialValue$1(props, "inputValue");
+        return {
+            highlightedIndex: highlightedIndex < 0 && selectedItem && isOpen ? props.items.indexOf(selectedItem) : highlightedIndex,
+            isOpen,
+            selectedItem,
+            inputValue
+        };
     }
 
-    function getTouchPosition(vertical, e3) {
-        return vertical ? e3.touches[0].clientY : e3.touches[0].pageX;
+    function getHighlightedIndexOnOpen(props, state, offset2) {
+        var items = props.items,
+            initialHighlightedIndex = props.initialHighlightedIndex,
+            defaultHighlightedIndex = props.defaultHighlightedIndex;
+        var selectedItem = state.selectedItem,
+            highlightedIndex = state.highlightedIndex;
+        if (items.length === 0) {
+            return -1;
+        }
+        if (initialHighlightedIndex !== void 0 && highlightedIndex === initialHighlightedIndex) {
+            return initialHighlightedIndex;
+        }
+        if (defaultHighlightedIndex !== void 0) {
+            return defaultHighlightedIndex;
+        }
+        if (selectedItem) {
+            return items.indexOf(selectedItem);
+        }
+        if (offset2 === 0) {
+            return -1;
+        }
+        return offset2 < 0 ? items.length - 1 : 0;
     }
 
-    function getHandles() {
-        var values = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
-        var reversed = arguments.length > 1 ? arguments[1] : void 0;
-        var valueToStep = arguments.length > 2 ? arguments[2] : void 0;
-        var changes = 0;
-        var handles = values.map(function(x2) {
-            var val = valueToStep.getValue(x2);
-            if (x2 !== val) {
-                changes += 1;
+    function useMouseAndTouchTracker(isOpen, downshiftElementRefs, environment, handleBlur) {
+        var mouseAndTouchTrackersRef = React.useRef({
+            isMouseDown: false,
+            isTouchMove: false
+        });
+        React.useEffect(function() {
+            if ((environment == null ? void 0 : environment.addEventListener) == null) {
+                return;
             }
-            return val;
-        }).map(function(val, i2) {
-            return {
-                key: "$$-".concat(i2),
-                val
+            var onMouseDown = function onMouseDown2() {
+                mouseAndTouchTrackersRef.current.isMouseDown = true;
             };
-        }).sort(getSortByVal(reversed));
-        return {
-            handles,
-            changes
-        };
+            var onMouseUp = function onMouseUp2(event2) {
+                mouseAndTouchTrackersRef.current.isMouseDown = false;
+                if (isOpen && !targetWithinDownshift(event2.target, downshiftElementRefs.map(function(ref2) {
+                        return ref2.current;
+                    }), environment)) {
+                    handleBlur();
+                }
+            };
+            var onTouchStart = function onTouchStart2() {
+                mouseAndTouchTrackersRef.current.isTouchMove = false;
+            };
+            var onTouchMove = function onTouchMove2() {
+                mouseAndTouchTrackersRef.current.isTouchMove = true;
+            };
+            var onTouchEnd = function onTouchEnd2(event2) {
+                if (isOpen && !mouseAndTouchTrackersRef.current.isTouchMove && !targetWithinDownshift(event2.target, downshiftElementRefs.map(function(ref2) {
+                        return ref2.current;
+                    }), environment, false)) {
+                    handleBlur();
+                }
+            };
+            environment.addEventListener("mousedown", onMouseDown);
+            environment.addEventListener("mouseup", onMouseUp);
+            environment.addEventListener("touchstart", onTouchStart);
+            environment.addEventListener("touchmove", onTouchMove);
+            environment.addEventListener("touchend", onTouchEnd);
+            return function cleanup() {
+                environment.removeEventListener("mousedown", onMouseDown);
+                environment.removeEventListener("mouseup", onMouseUp);
+                environment.removeEventListener("touchstart", onTouchStart);
+                environment.removeEventListener("touchmove", onTouchMove);
+                environment.removeEventListener("touchend", onTouchEnd);
+            };
+        }, [isOpen, environment]);
+        return mouseAndTouchTrackersRef;
     }
+    var useGetterPropsCalledChecker = function useGetterPropsCalledChecker2() {
+        return noop$6;
+    };
 
-    function mode1(_2, next2) {
-        return next2;
+    function useA11yMessageSetter(getA11yMessage, dependencyArray, _ref2) {
+        var isInitialMount = _ref2.isInitialMount,
+            highlightedIndex = _ref2.highlightedIndex,
+            items = _ref2.items,
+            environment = _ref2.environment,
+            rest = _objectWithoutPropertiesLoose$4(_ref2, _excluded$3);
+        React.useEffect(function() {
+            if (isInitialMount || false) {
+                return;
+            }
+            updateA11yStatus(function() {
+                return getA11yMessage(_extends$3({
+                    highlightedIndex,
+                    highlightedItem: items[highlightedIndex],
+                    resultCount: items.length
+                }, rest));
+            }, environment.document);
+        }, dependencyArray);
     }
 
-    function mode2(curr, next2) {
-        for (var i2 = 0; i2 < curr.length; i2++) {
-            if (curr[i2].key !== next2[i2].key) {
-                return curr;
+    function useScrollIntoView(_ref3) {
+        var highlightedIndex = _ref3.highlightedIndex,
+            isOpen = _ref3.isOpen,
+            itemRefs = _ref3.itemRefs,
+            getItemNodeFromIndex = _ref3.getItemNodeFromIndex,
+            menuElement = _ref3.menuElement,
+            scrollIntoViewProp = _ref3.scrollIntoView;
+        var shouldScrollRef = React.useRef(true);
+        useIsomorphicLayoutEffect$3(function() {
+            if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {
+                return;
             }
-            if (next2[i2 + 1] && next2[i2].val === next2[i2 + 1].val) {
-                return curr;
+            if (shouldScrollRef.current === false) {
+                shouldScrollRef.current = true;
+            } else {
+                scrollIntoViewProp(getItemNodeFromIndex(highlightedIndex), menuElement);
             }
-        }
-        return next2;
+        }, [highlightedIndex]);
+        return shouldScrollRef;
     }
+    var useControlPropsValidator = noop$6;
 
-    function mode3(curr, next2, step2, reversed, getValue2) {
-        var indexForMovingHandle = -1;
-        var handleMoveIsPositive = true;
-        for (var i2 = 0; i2 < curr.length; i2++) {
-            var c2 = curr[i2];
-            var n2 = next2[i2];
-            if (!n2 || n2.key !== c2.key) {
-                return curr;
-            } else if (n2.val !== c2.val) {
-                indexForMovingHandle = i2;
-                handleMoveIsPositive = n2.val - c2.val > 0;
-            }
-        }
-        if (indexForMovingHandle === -1) {
-            return curr;
-        } else {
-            var increment2 = handleMoveIsPositive ? step2 : -step2;
-            for (var _i2 = 0; _i2 < next2.length; _i2++) {
-                var n0 = next2[_i2];
-                var n1 = next2[_i2 + 1];
-                if (n1 && n0.val === n1.val) {
-                    if (_i2 === indexForMovingHandle) {
-                        var newStep = n1.val + increment2;
-                        if (getValue2(newStep) === newStep) {
-                            var clone2 = getUpdatedHandles(next2, n1.key, n1.val + increment2, reversed);
-                            var check = mode3(next2, clone2, step2, reversed, getValue2);
-                            if (check === next2) {
-                                return curr;
-                            } else {
-                                return check;
-                            }
-                        } else {
-                            return curr;
-                        }
-                    } else {
-                        var _newStep = n0.val + increment2;
-                        if (getValue2(_newStep) === _newStep) {
-                            var _clone = getUpdatedHandles(next2, n0.key, n0.val + increment2, reversed);
-                            var _check = mode3(next2, _clone, step2, reversed, getValue2);
-                            if (_check === next2) {
-                                return curr;
-                            } else {
-                                return _check;
-                            }
-                        } else {
-                            return curr;
-                        }
-                    }
-                }
-            }
+    function getChangesOnSelection(props, highlightedIndex, inputValue) {
+        var _props$items;
+        if (inputValue === void 0) {
+            inputValue = true;
         }
-        return next2;
+        var shouldSelect = ((_props$items = props.items) == null ? void 0 : _props$items.length) && highlightedIndex >= 0;
+        return _extends$3({
+            isOpen: false,
+            highlightedIndex: -1
+        }, shouldSelect && _extends$3({
+            selectedItem: props.items[highlightedIndex],
+            isOpen: getDefaultValue$1(props, "isOpen"),
+            highlightedIndex: getDefaultValue$1(props, "highlightedIndex")
+        }, inputValue && {
+            inputValue: props.itemToString(props.items[highlightedIndex])
+        }));
     }
 
-    function callAll() {
-        for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
-            fns[_key] = arguments[_key];
+    function downshiftCommonReducer(state, action, stateChangeTypes2) {
+        var type2 = action.type,
+            props = action.props;
+        var changes;
+        switch (type2) {
+            case stateChangeTypes2.ItemMouseMove:
+                changes = {
+                    highlightedIndex: action.disabled ? -1 : action.index
+                };
+                break;
+            case stateChangeTypes2.MenuMouseLeave:
+                changes = {
+                    highlightedIndex: -1
+                };
+                break;
+            case stateChangeTypes2.ToggleButtonClick:
+            case stateChangeTypes2.FunctionToggleMenu:
+                changes = {
+                    isOpen: !state.isOpen,
+                    highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)
+                };
+                break;
+            case stateChangeTypes2.FunctionOpenMenu:
+                changes = {
+                    isOpen: true,
+                    highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)
+                };
+                break;
+            case stateChangeTypes2.FunctionCloseMenu:
+                changes = {
+                    isOpen: false
+                };
+                break;
+            case stateChangeTypes2.FunctionSetHighlightedIndex:
+                changes = {
+                    highlightedIndex: action.highlightedIndex
+                };
+                break;
+            case stateChangeTypes2.FunctionSetInputValue:
+                changes = {
+                    inputValue: action.inputValue
+                };
+                break;
+            case stateChangeTypes2.FunctionReset:
+                changes = {
+                    highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
+                    isOpen: getDefaultValue$1(props, "isOpen"),
+                    selectedItem: getDefaultValue$1(props, "selectedItem"),
+                    inputValue: getDefaultValue$1(props, "inputValue")
+                };
+                break;
+            default:
+                throw new Error("Reducer called without proper action type.");
         }
-        return function(e3) {
-            return fns.forEach(function(fn2) {
-                return fn2 && fn2(e3);
-            });
-        };
+        return _extends$3({}, state, changes);
     }
-    var NOOP = function NOOP2() {
-        return {
-            value: 0,
-            percent: 0
-        };
-    };
-    var Rail = /* @__PURE__ */ function(_Component) {
-        _inherits(Rail2, _Component);
-        var _super = _createSuper(Rail2);
 
-        function Rail2() {
-            var _this;
-            _classCallCheck$f(this, Rail2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+    function getItemIndexByCharacterKey(_a3) {
+        var keysSoFar = _a3.keysSoFar,
+            highlightedIndex = _a3.highlightedIndex,
+            items = _a3.items,
+            itemToString2 = _a3.itemToString,
+            getItemNodeFromIndex = _a3.getItemNodeFromIndex;
+        var lowerCasedKeysSoFar = keysSoFar.toLowerCase();
+        for (var index2 = 0; index2 < items.length; index2++) {
+            var offsetIndex = (index2 + highlightedIndex + (keysSoFar.length < 2 ? 1 : 0)) % items.length;
+            var item = items[offsetIndex];
+            if (item !== void 0 && itemToString2(item).toLowerCase().startsWith(lowerCasedKeysSoFar)) {
+                var element2 = getItemNodeFromIndex(offsetIndex);
+                if (!(element2 === null || element2 === void 0 ? void 0 : element2.hasAttribute("disabled"))) {
+                    return offsetIndex;
+                }
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _this.getRailProps = function() {
-                var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
-                var _this$props = _this.props,
-                    emitMouse = _this$props.emitMouse,
-                    emitTouch = _this$props.emitTouch;
-                return _objectSpread2(_objectSpread2({}, props), {}, {
-                    onMouseDown: callAll(props && props.onMouseDown, emitMouse),
-                    onTouchStart: callAll(props && props.onTouchStart, emitTouch)
-                });
-            };
-            return _this;
         }
-        _createClass$f(Rail2, [{
-            key: "render",
-            value: function render2() {
-                var getRailProps = this.getRailProps,
-                    _this$props2 = this.props,
-                    getEventData = _this$props2.getEventData,
-                    _this$props2$activeHa = _this$props2.activeHandleID,
-                    activeHandleID = _this$props2$activeHa === void 0 ? "" : _this$props2$activeHa,
-                    children2 = _this$props2.children;
-                var renderedChildren = children2({
-                    getEventData: getEventData || NOOP,
-                    activeHandleID,
-                    getRailProps
-                });
-                return renderedChildren && React__default.default.Children.only(renderedChildren);
-            }
-        }]);
-        return Rail2;
-    }(React.Component);
-    var Handles = /* @__PURE__ */ function(_Component) {
-        _inherits(Handles2, _Component);
-        var _super = _createSuper(Handles2);
+        return highlightedIndex;
+    }
+    ({
+        items: propTypes.exports.array.isRequired,
+        itemToString: propTypes.exports.func,
+        getA11yStatusMessage: propTypes.exports.func,
+        getA11ySelectionMessage: propTypes.exports.func,
+        highlightedIndex: propTypes.exports.number,
+        defaultHighlightedIndex: propTypes.exports.number,
+        initialHighlightedIndex: propTypes.exports.number,
+        isOpen: propTypes.exports.bool,
+        defaultIsOpen: propTypes.exports.bool,
+        initialIsOpen: propTypes.exports.bool,
+        selectedItem: propTypes.exports.any,
+        initialSelectedItem: propTypes.exports.any,
+        defaultSelectedItem: propTypes.exports.any,
+        id: propTypes.exports.string,
+        labelId: propTypes.exports.string,
+        menuId: propTypes.exports.string,
+        getItemId: propTypes.exports.func,
+        toggleButtonId: propTypes.exports.string,
+        stateReducer: propTypes.exports.func,
+        onSelectedItemChange: propTypes.exports.func,
+        onHighlightedIndexChange: propTypes.exports.func,
+        onStateChange: propTypes.exports.func,
+        onIsOpenChange: propTypes.exports.func,
+        environment: propTypes.exports.shape({
+            addEventListener: propTypes.exports.func,
+            removeEventListener: propTypes.exports.func,
+            document: propTypes.exports.shape({
+                getElementById: propTypes.exports.func,
+                activeElement: propTypes.exports.any,
+                body: propTypes.exports.any
+            })
+        })
+    });
 
-        function Handles2() {
-            var _this;
-            _classCallCheck$f(this, Handles2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
-            }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _this.autofocus = function(e3) {
-                if (e3.target instanceof HTMLElement) {
-                    e3.target.focus();
-                }
-            };
-            _this.getHandleProps = function(id2) {
-                var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
-                var _this$props = _this.props,
-                    emitKeyboard = _this$props.emitKeyboard,
-                    emitMouse = _this$props.emitMouse,
-                    emitTouch = _this$props.emitTouch;
-                return _objectSpread2(_objectSpread2({}, props), {}, {
-                    onKeyDown: callAll(props && props.onKeyDown, function(e3) {
-                        return emitKeyboard && emitKeyboard(e3, id2);
-                    }),
-                    onMouseDown: callAll(props && props.onMouseDown, _this.autofocus, function(e3) {
-                        return emitMouse && emitMouse(e3, id2);
-                    }),
-                    onTouchStart: callAll(props && props.onTouchStart, function(e3) {
-                        return emitTouch && emitTouch(e3, id2);
-                    })
-                });
-            };
-            return _this;
+    function getA11yStatusMessage(_a3) {
+        var isOpen = _a3.isOpen,
+            resultCount = _a3.resultCount,
+            previousResultCount = _a3.previousResultCount;
+        if (!isOpen) {
+            return "";
         }
-        _createClass$f(Handles2, [{
-            key: "render",
-            value: function render2() {
-                var getHandleProps = this.getHandleProps,
-                    _this$props2 = this.props,
-                    _this$props2$activeHa = _this$props2.activeHandleID,
-                    activeHandleID = _this$props2$activeHa === void 0 ? "" : _this$props2$activeHa,
-                    children2 = _this$props2.children,
-                    _this$props2$handles = _this$props2.handles,
-                    handles = _this$props2$handles === void 0 ? [] : _this$props2$handles;
-                var renderedChildren = children2({
-                    handles,
-                    activeHandleID,
-                    getHandleProps
+        if (!resultCount) {
+            return "No results are available.";
+        }
+        if (resultCount !== previousResultCount) {
+            return "".concat(resultCount, " result").concat(resultCount === 1 ? " is" : "s are", " available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.");
+        }
+        return "";
+    }
+    var defaultProps$2 = __assign(__assign({}, defaultProps$3), {
+        getA11yStatusMessage
+    });
+    var ToggleButtonClick$1 = 0;
+    var ToggleButtonKeyDownArrowDown = 1;
+    var ToggleButtonKeyDownArrowUp = 2;
+    var ToggleButtonKeyDownCharacter = 3;
+    var ToggleButtonKeyDownEscape = 4;
+    var ToggleButtonKeyDownHome = 5;
+    var ToggleButtonKeyDownEnd = 6;
+    var ToggleButtonKeyDownEnter = 7;
+    var ToggleButtonKeyDownSpaceButton = 8;
+    var ToggleButtonKeyDownPageUp = 9;
+    var ToggleButtonKeyDownPageDown = 10;
+    var ToggleButtonBlur = 11;
+    var MenuMouseLeave$1 = 12;
+    var ItemMouseMove$1 = 13;
+    var ItemClick$1 = 14;
+    var FunctionToggleMenu$1 = 15;
+    var FunctionOpenMenu$1 = 16;
+    var FunctionCloseMenu$1 = 17;
+    var FunctionSetHighlightedIndex$1 = 18;
+    var FunctionSelectItem$1 = 19;
+    var FunctionSetInputValue$1 = 20;
+    var FunctionReset$2 = 21;
+    var stateChangeTypes$2$1 = /* @__PURE__ */ Object.freeze({
+        __proto__: null,
+        ToggleButtonClick: ToggleButtonClick$1,
+        ToggleButtonKeyDownArrowDown,
+        ToggleButtonKeyDownArrowUp,
+        ToggleButtonKeyDownCharacter,
+        ToggleButtonKeyDownEscape,
+        ToggleButtonKeyDownHome,
+        ToggleButtonKeyDownEnd,
+        ToggleButtonKeyDownEnter,
+        ToggleButtonKeyDownSpaceButton,
+        ToggleButtonKeyDownPageUp,
+        ToggleButtonKeyDownPageDown,
+        ToggleButtonBlur,
+        MenuMouseLeave: MenuMouseLeave$1,
+        ItemMouseMove: ItemMouseMove$1,
+        ItemClick: ItemClick$1,
+        FunctionToggleMenu: FunctionToggleMenu$1,
+        FunctionOpenMenu: FunctionOpenMenu$1,
+        FunctionCloseMenu: FunctionCloseMenu$1,
+        FunctionSetHighlightedIndex: FunctionSetHighlightedIndex$1,
+        FunctionSelectItem: FunctionSelectItem$1,
+        FunctionSetInputValue: FunctionSetInputValue$1,
+        FunctionReset: FunctionReset$2
+    });
+
+    function downshiftSelectReducer(state, action) {
+        var _props$items;
+        var type2 = action.type,
+            props = action.props,
+            altKey = action.altKey;
+        var changes;
+        switch (type2) {
+            case ItemClick$1:
+                changes = {
+                    isOpen: getDefaultValue$1(props, "isOpen"),
+                    highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
+                    selectedItem: props.items[action.index]
+                };
+                break;
+            case ToggleButtonKeyDownCharacter: {
+                var lowercasedKey = action.key;
+                var inputValue = "" + state.inputValue + lowercasedKey;
+                var prevHighlightedIndex = !state.isOpen && state.selectedItem ? props.items.indexOf(state.selectedItem) : state.highlightedIndex;
+                var highlightedIndex = getItemIndexByCharacterKey({
+                    keysSoFar: inputValue,
+                    highlightedIndex: prevHighlightedIndex,
+                    items: props.items,
+                    itemToString: props.itemToString,
+                    getItemNodeFromIndex: action.getItemNodeFromIndex
                 });
-                return renderedChildren && React__default.default.Children.only(renderedChildren);
+                changes = {
+                    inputValue,
+                    highlightedIndex,
+                    isOpen: true
+                };
             }
-        }]);
-        return Handles2;
-    }(React.Component);
-    var LinearScale = /* @__PURE__ */ function() {
-        function LinearScale2() {
-            _classCallCheck$f(this, LinearScale2);
-            this.interpolator = void 0;
-            this.domain = [0, 1];
-            this.range = [0, 1];
-            this.domain = [0, 1];
-            this.range = [0, 1];
-            this.interpolator = null;
-        }
-        _createClass$f(LinearScale2, [{
-            key: "createInterpolator",
-            value: function createInterpolator(domain2, range2) {
-                var _this = this;
-                var d0 = domain2[0];
-                var d1 = domain2[1];
-                var r0 = range2[0];
-                var r1 = range2[1];
-                if (d1 < d0) {
-                    return function(x2) {
-                        return _this.interpolateValue(r1, r0)(_this.deinterpolateValue(d1, d0)(x2));
-                    };
+            break;
+            case ToggleButtonKeyDownArrowDown: {
+                var _highlightedIndex = state.isOpen ? getNextWrappingIndex(1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, false) : altKey && state.selectedItem == null ? -1 : getHighlightedIndexOnOpen(props, state, 1);
+                changes = {
+                    highlightedIndex: _highlightedIndex,
+                    isOpen: true
+                };
+            }
+            break;
+            case ToggleButtonKeyDownArrowUp:
+                if (state.isOpen && altKey) {
+                    changes = getChangesOnSelection(props, state.highlightedIndex, false);
                 } else {
-                    return function(x2) {
-                        return _this.interpolateValue(r0, r1)(_this.deinterpolateValue(d0, d1)(x2));
+                    var _highlightedIndex2 = state.isOpen ? getNextWrappingIndex(-1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, false) : getHighlightedIndexOnOpen(props, state, -1);
+                    changes = {
+                        highlightedIndex: _highlightedIndex2,
+                        isOpen: true
                     };
                 }
-            }
-        }, {
-            key: "interpolateValue",
-            value: function interpolateValue(a2, b2) {
-                return a2 = +a2, b2 -= a2,
-                    function i2(t2) {
-                        return a2 + b2 * t2;
-                    };
-            }
-        }, {
-            key: "deinterpolateValue",
-            value: function deinterpolateValue(a2, b2) {
-                return (b2 -= a2 = +a2) ? function(x2) {
-                    return (x2 - a2) / b2;
-                } : function() {
-                    return b2;
+                break;
+            case ToggleButtonKeyDownEnter:
+            case ToggleButtonKeyDownSpaceButton:
+                changes = getChangesOnSelection(props, state.highlightedIndex, false);
+                break;
+            case ToggleButtonKeyDownHome:
+                changes = {
+                    highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false),
+                    isOpen: true
                 };
+                break;
+            case ToggleButtonKeyDownEnd:
+                changes = {
+                    highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false),
+                    isOpen: true
+                };
+                break;
+            case ToggleButtonKeyDownPageUp:
+                changes = {
+                    highlightedIndex: getNextWrappingIndex(-10, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, false)
+                };
+                break;
+            case ToggleButtonKeyDownPageDown:
+                changes = {
+                    highlightedIndex: getNextWrappingIndex(10, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, false)
+                };
+                break;
+            case ToggleButtonKeyDownEscape:
+                changes = {
+                    isOpen: false,
+                    highlightedIndex: -1
+                };
+                break;
+            case ToggleButtonBlur:
+                changes = _extends$3({
+                    isOpen: false,
+                    highlightedIndex: -1
+                }, state.highlightedIndex >= 0 && ((_props$items = props.items) == null ? void 0 : _props$items.length) && {
+                    selectedItem: props.items[state.highlightedIndex]
+                });
+                break;
+            case FunctionSelectItem$1:
+                changes = {
+                    selectedItem: action.selectedItem
+                };
+                break;
+            default:
+                return downshiftCommonReducer(state, action, stateChangeTypes$2$1);
+        }
+        return _extends$3({}, state, changes);
+    }
+    var _excluded$2 = ["onMouseLeave", "refKey", "onKeyDown", "onBlur", "ref"],
+        _excluded2$2 = ["onBlur", "onClick", "onPress", "onKeyDown", "refKey", "ref"],
+        _excluded3$1 = ["item", "index", "onMouseMove", "onClick", "onPress", "refKey", "ref", "disabled"];
+    useSelect.stateChangeTypes = stateChangeTypes$2$1;
+
+    function useSelect(userProps) {
+        if (userProps === void 0) {
+            userProps = {};
+        }
+        var props = _extends$3({}, defaultProps$2, userProps);
+        var items = props.items,
+            scrollIntoView2 = props.scrollIntoView,
+            environment = props.environment,
+            itemToString2 = props.itemToString,
+            getA11ySelectionMessage2 = props.getA11ySelectionMessage,
+            getA11yStatusMessage2 = props.getA11yStatusMessage;
+        var initialState2 = getInitialState$2(props);
+        var _useControlledReducer = useControlledReducer$1(downshiftSelectReducer, initialState2, props),
+            state = _useControlledReducer[0],
+            dispatch2 = _useControlledReducer[1];
+        var isOpen = state.isOpen,
+            highlightedIndex = state.highlightedIndex,
+            selectedItem = state.selectedItem,
+            inputValue = state.inputValue;
+        var toggleButtonRef = React.useRef(null);
+        var menuRef = React.useRef(null);
+        var itemRefs = React.useRef({});
+        var clearTimeoutRef = React.useRef(null);
+        var elementIds = useElementIds(props);
+        var previousResultCountRef = React.useRef();
+        var isInitialMountRef = React.useRef(true);
+        var latest2 = useLatestRef({
+            state,
+            props
+        });
+        var getItemNodeFromIndex = React.useCallback(function(index2) {
+            return itemRefs.current[elementIds.getItemId(index2)];
+        }, [elementIds]);
+        useA11yMessageSetter(getA11yStatusMessage2, [isOpen, highlightedIndex, inputValue, items], _extends$3({
+            isInitialMount: isInitialMountRef.current,
+            previousResultCount: previousResultCountRef.current,
+            items,
+            environment,
+            itemToString: itemToString2
+        }, state));
+        useA11yMessageSetter(getA11ySelectionMessage2, [selectedItem], _extends$3({
+            isInitialMount: isInitialMountRef.current,
+            previousResultCount: previousResultCountRef.current,
+            items,
+            environment,
+            itemToString: itemToString2
+        }, state));
+        var shouldScrollRef = useScrollIntoView({
+            menuElement: menuRef.current,
+            highlightedIndex,
+            isOpen,
+            itemRefs,
+            scrollIntoView: scrollIntoView2,
+            getItemNodeFromIndex
+        });
+        React.useEffect(function() {
+            clearTimeoutRef.current = debounce$2(function(outerDispatch) {
+                outerDispatch({
+                    type: FunctionSetInputValue$1,
+                    inputValue: ""
+                });
+            }, 500);
+            return function() {
+                clearTimeoutRef.current.cancel();
+            };
+        }, []);
+        React.useEffect(function() {
+            if (!inputValue) {
+                return;
             }
-        }, {
-            key: "rescale",
-            value: function rescale() {
-                this.interpolator = null;
-                return this;
-            }
-        }, {
-            key: "getValue",
-            value: function getValue2(x2) {
-                var domain2 = this.domain,
-                    range2 = this.range;
-                return (this.interpolator || (this.interpolator = this.createInterpolator(domain2, range2)))(+x2);
-            }
-        }, {
-            key: "setDomain",
-            value: function setDomain(val) {
-                this.domain = [val[0], val[1]];
-                this.rescale();
-                return this;
-            }
-        }, {
-            key: "getDomain",
-            value: function getDomain() {
-                return this.domain;
+            clearTimeoutRef.current(dispatch2);
+        }, [dispatch2, inputValue]);
+        useControlPropsValidator({
+            isInitialMount: isInitialMountRef.current,
+            props,
+            state
+        });
+        React.useEffect(function() {
+            if (isInitialMountRef.current) {
+                return;
             }
-        }, {
-            key: "setRange",
-            value: function setRange(val) {
-                this.range = [val[0], val[1]];
-                return this;
+            previousResultCountRef.current = items.length;
+        });
+        var mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [menuRef, toggleButtonRef], environment, function() {
+            dispatch2({
+                type: ToggleButtonBlur
+            });
+        });
+        var setGetterPropCallInfo = useGetterPropsCalledChecker();
+        React.useEffect(function() {
+            isInitialMountRef.current = false;
+            return function() {
+                isInitialMountRef.current = true;
+            };
+        }, []);
+        React.useEffect(function() {
+            if (!isOpen) {
+                itemRefs.current = {};
             }
-        }, {
-            key: "getTicks",
-            value: function getTicks(count2) {
-                var d2 = this.domain;
-                return ticks(d2[0], d2[d2.length - 1], count2 ? count2 : 10);
+        }, [isOpen]);
+        var toggleButtonKeyDownHandlers = React.useMemo(function() {
+            return {
+                ArrowDown: function ArrowDown2(event2) {
+                    event2.preventDefault();
+                    dispatch2({
+                        type: ToggleButtonKeyDownArrowDown,
+                        getItemNodeFromIndex,
+                        altKey: event2.altKey
+                    });
+                },
+                ArrowUp: function ArrowUp2(event2) {
+                    event2.preventDefault();
+                    dispatch2({
+                        type: ToggleButtonKeyDownArrowUp,
+                        getItemNodeFromIndex,
+                        altKey: event2.altKey
+                    });
+                },
+                Home: function Home(event2) {
+                    event2.preventDefault();
+                    dispatch2({
+                        type: ToggleButtonKeyDownHome,
+                        getItemNodeFromIndex
+                    });
+                },
+                End: function End(event2) {
+                    event2.preventDefault();
+                    dispatch2({
+                        type: ToggleButtonKeyDownEnd,
+                        getItemNodeFromIndex
+                    });
+                },
+                Escape: function Escape2() {
+                    if (latest2.current.state.isOpen) {
+                        dispatch2({
+                            type: ToggleButtonKeyDownEscape
+                        });
+                    }
+                },
+                Enter: function Enter(event2) {
+                    event2.preventDefault();
+                    dispatch2({
+                        type: latest2.current.state.isOpen ? ToggleButtonKeyDownEnter : ToggleButtonClick$1
+                    });
+                },
+                PageUp: function PageUp(event2) {
+                    if (latest2.current.state.isOpen) {
+                        event2.preventDefault();
+                        dispatch2({
+                            type: ToggleButtonKeyDownPageUp,
+                            getItemNodeFromIndex
+                        });
+                    }
+                },
+                PageDown: function PageDown(event2) {
+                    if (latest2.current.state.isOpen) {
+                        event2.preventDefault();
+                        dispatch2({
+                            type: ToggleButtonKeyDownPageDown,
+                            getItemNodeFromIndex
+                        });
+                    }
+                },
+                " ": function _2(event2) {
+                    event2.preventDefault();
+                    var currentState = latest2.current.state;
+                    if (!currentState.isOpen) {
+                        dispatch2({
+                            type: ToggleButtonClick$1
+                        });
+                        return;
+                    }
+                    if (currentState.inputValue) {
+                        dispatch2({
+                            type: ToggleButtonKeyDownCharacter,
+                            key: " ",
+                            getItemNodeFromIndex
+                        });
+                    } else {
+                        dispatch2({
+                            type: ToggleButtonKeyDownSpaceButton
+                        });
+                    }
+                }
+            };
+        }, [dispatch2, getItemNodeFromIndex, latest2]);
+        var toggleMenu = React.useCallback(function() {
+            dispatch2({
+                type: FunctionToggleMenu$1
+            });
+        }, [dispatch2]);
+        var closeMenu = React.useCallback(function() {
+            dispatch2({
+                type: FunctionCloseMenu$1
+            });
+        }, [dispatch2]);
+        var openMenu = React.useCallback(function() {
+            dispatch2({
+                type: FunctionOpenMenu$1
+            });
+        }, [dispatch2]);
+        var setHighlightedIndex = React.useCallback(function(newHighlightedIndex) {
+            dispatch2({
+                type: FunctionSetHighlightedIndex$1,
+                highlightedIndex: newHighlightedIndex
+            });
+        }, [dispatch2]);
+        var selectItem = React.useCallback(function(newSelectedItem) {
+            dispatch2({
+                type: FunctionSelectItem$1,
+                selectedItem: newSelectedItem
+            });
+        }, [dispatch2]);
+        var reset2 = React.useCallback(function() {
+            dispatch2({
+                type: FunctionReset$2
+            });
+        }, [dispatch2]);
+        var setInputValue = React.useCallback(function(newInputValue) {
+            dispatch2({
+                type: FunctionSetInputValue$1,
+                inputValue: newInputValue
+            });
+        }, [dispatch2]);
+        var getLabelProps = React.useCallback(function(labelProps) {
+            return _extends$3({
+                id: elementIds.labelId,
+                htmlFor: elementIds.toggleButtonId
+            }, labelProps);
+        }, [elementIds]);
+        var getMenuProps = React.useCallback(function(_temp, _temp2) {
+            var _extends2;
+            var _ref2 = _temp === void 0 ? {} : _temp,
+                onMouseLeave = _ref2.onMouseLeave,
+                _ref$refKey = _ref2.refKey,
+                refKey = _ref$refKey === void 0 ? "ref" : _ref$refKey;
+            _ref2.onKeyDown;
+            _ref2.onBlur;
+            var ref2 = _ref2.ref,
+                rest = _objectWithoutPropertiesLoose$4(_ref2, _excluded$2);
+            var _ref22 = _temp2 === void 0 ? {} : _temp2;
+            _ref22.suppressRefError;
+            var menuHandleMouseLeave = function menuHandleMouseLeave2() {
+                dispatch2({
+                    type: MenuMouseLeave$1
+                });
+            };
+            return _extends$3((_extends2 = {}, _extends2[refKey] = handleRefs(ref2, function(menuNode) {
+                menuRef.current = menuNode;
+            }), _extends2.id = elementIds.menuId, _extends2.role = "listbox", _extends2["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : "" + elementIds.labelId, _extends2.onMouseLeave = callAllEventHandlers(onMouseLeave, menuHandleMouseLeave), _extends2), rest);
+        }, [dispatch2, setGetterPropCallInfo, elementIds]);
+        var getToggleButtonProps = React.useCallback(function(_temp3, _temp4) {
+            var _extends3;
+            var _ref3 = _temp3 === void 0 ? {} : _temp3,
+                onBlur = _ref3.onBlur,
+                onClick = _ref3.onClick;
+            _ref3.onPress;
+            var onKeyDown = _ref3.onKeyDown,
+                _ref3$refKey = _ref3.refKey,
+                refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey,
+                ref2 = _ref3.ref,
+                rest = _objectWithoutPropertiesLoose$4(_ref3, _excluded2$2);
+            var _ref4 = _temp4 === void 0 ? {} : _temp4;
+            _ref4.suppressRefError;
+            var latestState = latest2.current.state;
+            var toggleButtonHandleClick = function toggleButtonHandleClick2() {
+                dispatch2({
+                    type: ToggleButtonClick$1
+                });
+            };
+            var toggleButtonHandleBlur = function toggleButtonHandleBlur2() {
+                if (latestState.isOpen && !mouseAndTouchTrackersRef.current.isMouseDown) {
+                    dispatch2({
+                        type: ToggleButtonBlur
+                    });
+                }
+            };
+            var toggleButtonHandleKeyDown = function toggleButtonHandleKeyDown2(event2) {
+                var key = normalizeArrowKey(event2);
+                if (key && toggleButtonKeyDownHandlers[key]) {
+                    toggleButtonKeyDownHandlers[key](event2);
+                } else if (isAcceptedCharacterKey(key)) {
+                    dispatch2({
+                        type: ToggleButtonKeyDownCharacter,
+                        key,
+                        getItemNodeFromIndex
+                    });
+                }
+            };
+            var toggleProps = _extends$3((_extends3 = {}, _extends3[refKey] = handleRefs(ref2, function(toggleButtonNode) {
+                toggleButtonRef.current = toggleButtonNode;
+            }), _extends3["aria-activedescendant"] = latestState.isOpen && latestState.highlightedIndex > -1 ? elementIds.getItemId(latestState.highlightedIndex) : "", _extends3["aria-controls"] = elementIds.menuId, _extends3["aria-expanded"] = latest2.current.state.isOpen, _extends3["aria-haspopup"] = "listbox", _extends3["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : "" + elementIds.labelId, _extends3.id = elementIds.toggleButtonId, _extends3.role = "combobox", _extends3.tabIndex = 0, _extends3.onBlur = callAllEventHandlers(onBlur, toggleButtonHandleBlur), _extends3), rest);
+            if (!rest.disabled) {
+                {
+                    toggleProps.onClick = callAllEventHandlers(onClick, toggleButtonHandleClick);
+                    toggleProps.onKeyDown = callAllEventHandlers(onKeyDown, toggleButtonHandleKeyDown);
+                }
             }
-        }]);
-        return LinearScale2;
-    }();
-    var defaultGetEventData = function defaultGetEventData2() {
-        return {
-            value: 0,
-            percent: 0
-        };
-    };
-    var Ticks = /* @__PURE__ */ function(_Component) {
-        _inherits(Ticks2, _Component);
-        var _super = _createSuper(Ticks2);
-
-        function Ticks2() {
-            _classCallCheck$f(this, Ticks2);
-            return _super.apply(this, arguments);
-        }
-        _createClass$f(Ticks2, [{
-            key: "render",
-            value: function render2() {
-                var _this$props = this.props,
-                    children2 = _this$props.children,
-                    values = _this$props.values,
-                    _this$props$scale = _this$props.scale,
-                    scale = _this$props$scale === void 0 ? new LinearScale() : _this$props$scale,
-                    _this$props$count = _this$props.count,
-                    count2 = _this$props$count === void 0 ? 10 : _this$props$count,
-                    _this$props$getEventD = _this$props.getEventData,
-                    getEventData = _this$props$getEventD === void 0 ? defaultGetEventData : _this$props$getEventD,
-                    _this$props$activeHan = _this$props.activeHandleID,
-                    activeHandleID = _this$props$activeHan === void 0 ? "" : _this$props$activeHan;
-                var ticks2 = (values ? values : scale.getTicks(count2)).map(function(value) {
-                    return {
-                        id: "$$-".concat(value),
-                        value,
-                        percent: scale.getValue(value)
-                    };
+            return toggleProps;
+        }, [latest2, elementIds, setGetterPropCallInfo, dispatch2, mouseAndTouchTrackersRef, toggleButtonKeyDownHandlers, getItemNodeFromIndex]);
+        var getItemProps = React.useCallback(function(_temp5) {
+            var _extends4;
+            var _ref5 = _temp5 === void 0 ? {} : _temp5,
+                itemProp = _ref5.item,
+                indexProp = _ref5.index,
+                onMouseMove = _ref5.onMouseMove,
+                onClick = _ref5.onClick;
+            _ref5.onPress;
+            var _ref5$refKey = _ref5.refKey,
+                refKey = _ref5$refKey === void 0 ? "ref" : _ref5$refKey,
+                ref2 = _ref5.ref,
+                disabled2 = _ref5.disabled,
+                rest = _objectWithoutPropertiesLoose$4(_ref5, _excluded3$1);
+            var _latest$current = latest2.current,
+                latestState = _latest$current.state,
+                latestProps = _latest$current.props;
+            var _getItemAndIndex = getItemAndIndex(itemProp, indexProp, latestProps.items, "Pass either item or index to getItemProps!"),
+                item = _getItemAndIndex[0],
+                index2 = _getItemAndIndex[1];
+            var itemHandleMouseMove = function itemHandleMouseMove2() {
+                if (index2 === latestState.highlightedIndex) {
+                    return;
+                }
+                shouldScrollRef.current = false;
+                dispatch2({
+                    type: ItemMouseMove$1,
+                    index: index2,
+                    disabled: disabled2
                 });
-                var renderedChildren = children2({
-                    getEventData,
-                    activeHandleID,
-                    ticks: ticks2
+            };
+            var itemHandleClick = function itemHandleClick2() {
+                dispatch2({
+                    type: ItemClick$1,
+                    index: index2
                 });
-                return renderedChildren && React__default.default.Children.only(renderedChildren);
+            };
+            var itemProps = _extends$3((_extends4 = {
+                disabled: disabled2,
+                role: "option",
+                "aria-selected": "" + (item === selectedItem),
+                id: elementIds.getItemId(index2)
+            }, _extends4[refKey] = handleRefs(ref2, function(itemNode) {
+                if (itemNode) {
+                    itemRefs.current[elementIds.getItemId(index2)] = itemNode;
+                }
+            }), _extends4), rest);
+            if (!disabled2) {
+                {
+                    itemProps.onClick = callAllEventHandlers(onClick, itemHandleClick);
+                }
             }
-        }]);
-        return Ticks2;
-    }(React.Component);
-    var defaultGetEventData$1 = function defaultGetEventData2() {
+            itemProps.onMouseMove = callAllEventHandlers(onMouseMove, itemHandleMouseMove);
+            return itemProps;
+        }, [latest2, selectedItem, elementIds, shouldScrollRef, dispatch2]);
         return {
-            value: 0,
-            percent: 0
+            getToggleButtonProps,
+            getLabelProps,
+            getMenuProps,
+            getItemProps,
+            toggleMenu,
+            openMenu,
+            closeMenu,
+            setHighlightedIndex,
+            selectItem,
+            reset: reset2,
+            setInputValue,
+            highlightedIndex,
+            isOpen,
+            selectedItem,
+            inputValue
         };
-    };
-    var Tracks = /* @__PURE__ */ function(_Component) {
-        _inherits(Tracks2, _Component);
-        var _super = _createSuper(Tracks2);
+    }
+    var InputKeyDownArrowDown = 0;
+    var InputKeyDownArrowUp = 1;
+    var InputKeyDownEscape = 2;
+    var InputKeyDownHome = 3;
+    var InputKeyDownEnd = 4;
+    var InputKeyDownPageUp = 5;
+    var InputKeyDownPageDown = 6;
+    var InputKeyDownEnter = 7;
+    var InputChange = 8;
+    var InputBlur = 9;
+    var InputFocus = 10;
+    var MenuMouseLeave = 11;
+    var ItemMouseMove = 12;
+    var ItemClick = 13;
+    var ToggleButtonClick = 14;
+    var FunctionToggleMenu = 15;
+    var FunctionOpenMenu = 16;
+    var FunctionCloseMenu = 17;
+    var FunctionSetHighlightedIndex = 18;
+    var FunctionSelectItem = 19;
+    var FunctionSetInputValue = 20;
+    var FunctionReset$1 = 21;
+    var ControlledPropUpdatedSelectedItem = 22;
+    var stateChangeTypes$1$1 = /* @__PURE__ */ Object.freeze({
+        __proto__: null,
+        InputKeyDownArrowDown,
+        InputKeyDownArrowUp,
+        InputKeyDownEscape,
+        InputKeyDownHome,
+        InputKeyDownEnd,
+        InputKeyDownPageUp,
+        InputKeyDownPageDown,
+        InputKeyDownEnter,
+        InputChange,
+        InputBlur,
+        InputFocus,
+        MenuMouseLeave,
+        ItemMouseMove,
+        ItemClick,
+        ToggleButtonClick,
+        FunctionToggleMenu,
+        FunctionOpenMenu,
+        FunctionCloseMenu,
+        FunctionSetHighlightedIndex,
+        FunctionSelectItem,
+        FunctionSetInputValue,
+        FunctionReset: FunctionReset$1,
+        ControlledPropUpdatedSelectedItem
+    });
 
-        function Tracks2() {
-            var _this;
-            _classCallCheck$f(this, Tracks2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+    function getInitialState$1(props) {
+        var initialState2 = getInitialState$2(props);
+        var selectedItem = initialState2.selectedItem;
+        var inputValue = initialState2.inputValue;
+        if (inputValue === "" && selectedItem && props.defaultInputValue === void 0 && props.initialInputValue === void 0 && props.inputValue === void 0) {
+            inputValue = props.itemToString(selectedItem);
+        }
+        return _extends$3({}, initialState2, {
+            inputValue
+        });
+    }
+    ({
+        items: propTypes.exports.array.isRequired,
+        itemToString: propTypes.exports.func,
+        selectedItemChanged: propTypes.exports.func,
+        getA11yStatusMessage: propTypes.exports.func,
+        getA11ySelectionMessage: propTypes.exports.func,
+        highlightedIndex: propTypes.exports.number,
+        defaultHighlightedIndex: propTypes.exports.number,
+        initialHighlightedIndex: propTypes.exports.number,
+        isOpen: propTypes.exports.bool,
+        defaultIsOpen: propTypes.exports.bool,
+        initialIsOpen: propTypes.exports.bool,
+        selectedItem: propTypes.exports.any,
+        initialSelectedItem: propTypes.exports.any,
+        defaultSelectedItem: propTypes.exports.any,
+        inputValue: propTypes.exports.string,
+        defaultInputValue: propTypes.exports.string,
+        initialInputValue: propTypes.exports.string,
+        id: propTypes.exports.string,
+        labelId: propTypes.exports.string,
+        menuId: propTypes.exports.string,
+        getItemId: propTypes.exports.func,
+        inputId: propTypes.exports.string,
+        toggleButtonId: propTypes.exports.string,
+        stateReducer: propTypes.exports.func,
+        onSelectedItemChange: propTypes.exports.func,
+        onHighlightedIndexChange: propTypes.exports.func,
+        onStateChange: propTypes.exports.func,
+        onIsOpenChange: propTypes.exports.func,
+        onInputValueChange: propTypes.exports.func,
+        environment: propTypes.exports.shape({
+            addEventListener: propTypes.exports.func,
+            removeEventListener: propTypes.exports.func,
+            document: propTypes.exports.shape({
+                getElementById: propTypes.exports.func,
+                activeElement: propTypes.exports.any,
+                body: propTypes.exports.any
+            })
+        })
+    });
+
+    function useControlledReducer(reducer2, initialState2, props) {
+        var previousSelectedItemRef = React.useRef();
+        var _useEnhancedReducer = useEnhancedReducer(reducer2, initialState2, props),
+            state = _useEnhancedReducer[0],
+            dispatch2 = _useEnhancedReducer[1];
+        React.useEffect(function() {
+            if (!isControlledProp(props, "selectedItem")) {
+                return;
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _this.getTrackProps = function(props) {
-                var _this$props = _this.props,
-                    emitMouse = _this$props.emitMouse,
-                    emitTouch = _this$props.emitTouch;
-                return _objectSpread2(_objectSpread2({}, props || {}), {}, {
-                    onMouseDown: callAll(props && props.onMouseDown, emitMouse),
-                    onTouchStart: callAll(props && props.onTouchStart, emitTouch)
+            if (props.selectedItemChanged(previousSelectedItemRef.current, props.selectedItem)) {
+                dispatch2({
+                    type: ControlledPropUpdatedSelectedItem,
+                    inputValue: props.itemToString(props.selectedItem)
                 });
-            };
-            return _this;
-        }
-        _createClass$f(Tracks2, [{
-            key: "render",
-            value: function render2() {
-                var getTrackProps = this.getTrackProps,
-                    _this$props2 = this.props,
-                    children2 = _this$props2.children,
-                    _this$props2$left = _this$props2.left,
-                    left2 = _this$props2$left === void 0 ? true : _this$props2$left,
-                    _this$props2$right = _this$props2.right,
-                    right2 = _this$props2$right === void 0 ? true : _this$props2$right,
-                    _this$props2$scale = _this$props2.scale,
-                    scale = _this$props2$scale === void 0 ? new LinearScale() : _this$props2$scale,
-                    _this$props2$handles = _this$props2.handles,
-                    handles = _this$props2$handles === void 0 ? [] : _this$props2$handles,
-                    _this$props2$getEvent = _this$props2.getEventData,
-                    getEventData = _this$props2$getEvent === void 0 ? defaultGetEventData$1 : _this$props2$getEvent,
-                    _this$props2$activeHa = _this$props2.activeHandleID,
-                    activeHandleID = _this$props2$activeHa === void 0 ? "" : _this$props2$activeHa;
-                var domain2 = scale.getDomain();
-                var tracks = [];
-                for (var i2 = 0; i2 < handles.length + 1; i2++) {
-                    var source = handles[i2 - 1];
-                    var target = handles[i2];
-                    if (i2 === 0 && left2 === true) {
-                        source = {
-                            id: "$",
-                            value: domain2[0],
-                            percent: 0
-                        };
-                    } else if (i2 === handles.length && right2 === true) {
-                        target = {
-                            id: "$",
-                            value: domain2[1],
-                            percent: 100
+            }
+            previousSelectedItemRef.current = state.selectedItem === previousSelectedItemRef.current ? props.selectedItem : state.selectedItem;
+        }, [state.selectedItem, props.selectedItem]);
+        return [getState(state, props), dispatch2];
+    }
+    var defaultProps$1 = _extends$3({}, defaultProps$3, {
+        selectedItemChanged: function selectedItemChanged(prevItem, item) {
+            return prevItem !== item;
+        },
+        getA11yStatusMessage: getA11yStatusMessage$1
+    });
+
+    function downshiftUseComboboxReducer(state, action) {
+        var _props$items;
+        var type2 = action.type,
+            props = action.props,
+            altKey = action.altKey;
+        var changes;
+        switch (type2) {
+            case ItemClick:
+                changes = {
+                    isOpen: getDefaultValue$1(props, "isOpen"),
+                    highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
+                    selectedItem: props.items[action.index],
+                    inputValue: props.itemToString(props.items[action.index])
+                };
+                break;
+            case InputKeyDownArrowDown:
+                if (state.isOpen) {
+                    changes = {
+                        highlightedIndex: getNextWrappingIndex(1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, true)
+                    };
+                } else {
+                    changes = {
+                        highlightedIndex: altKey && state.selectedItem == null ? -1 : getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),
+                        isOpen: props.items.length >= 0
+                    };
+                }
+                break;
+            case InputKeyDownArrowUp:
+                if (state.isOpen) {
+                    if (altKey) {
+                        changes = getChangesOnSelection(props, state.highlightedIndex);
+                    } else {
+                        changes = {
+                            highlightedIndex: getNextWrappingIndex(-1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, true)
                         };
                     }
-                    if (source && target) {
-                        tracks.push({
-                            id: "".concat(source.id, "-").concat(target.id),
-                            source,
-                            target
-                        });
-                    }
+                } else {
+                    changes = {
+                        highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),
+                        isOpen: props.items.length >= 0
+                    };
                 }
-                var renderedChildren = children2({
-                    getEventData,
-                    activeHandleID,
-                    tracks,
-                    getTrackProps
+                break;
+            case InputKeyDownEnter:
+                changes = getChangesOnSelection(props, state.highlightedIndex);
+                break;
+            case InputKeyDownEscape:
+                changes = _extends$3({
+                    isOpen: false,
+                    highlightedIndex: -1
+                }, !state.isOpen && {
+                    selectedItem: null,
+                    inputValue: ""
                 });
-                return renderedChildren && React__default.default.Children.only(renderedChildren);
-            }
-        }]);
-        return Tracks2;
-    }(React.Component);
-
-    function clamp(value, min2, max2) {
-        return Math.min(Math.max(value, min2), max2);
-    }
-    var DiscreteScale = function DiscreteScale2() {
-        var _this = this;
-        _classCallCheck$f(this, DiscreteScale2);
-        this.step = 1;
-        this.domain = [0, 1];
-        this.range = [0, 1];
-        this.setDomain = function(val) {
-            _this.domain = [val[0], val[1]];
-            return _this;
-        };
-        this.setRange = function(val) {
-            _this.range = [val[0], val[1]];
-            return _this;
-        };
-        this.setStep = function(val) {
-            _this.step = val;
-            return _this;
-        };
-        this.getValue = function(x2) {
-            var _this$domain = _slicedToArray$7(_this.domain, 2),
-                d0 = _this$domain[0],
-                d1 = _this$domain[1],
-                _this$range = _slicedToArray$7(_this.range, 2),
-                r0 = _this$range[0],
-                r1 = _this$range[1],
-                step2 = _this.step;
-            var p2 = (clamp(x2, d0, d1) - d0) / (d1 - d0);
-            var b2 = step2 * Math.round(p2 * (r1 - r0) / step2) + r0;
-            return clamp(b2, r0 < r1 ? r0 : r1, r1 > r0 ? r1 : r0);
-        };
-    };
-    var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
-    var noop$5 = function noop2() {};
-    var compare$1 = function compare2(b2) {
-        return function(m2, d2, i2) {
-            return m2 && b2[i2] === d2;
-        };
-    };
-    var equal = function equal2(a2, b2) {
-        return a2 === b2 || a2.length === b2.length && a2.reduce(compare$1(b2), true);
-    };
-    var isRCSComponent = function isRCSComponent2(item) {
-        if (! /* @__PURE__ */ React.isValidElement(item)) {
-            return false;
+                break;
+            case InputKeyDownPageUp:
+                changes = {
+                    highlightedIndex: getNextWrappingIndex(-10, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, false)
+                };
+                break;
+            case InputKeyDownPageDown:
+                changes = {
+                    highlightedIndex: getNextWrappingIndex(10, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, false)
+                };
+                break;
+            case InputKeyDownHome:
+                changes = {
+                    highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)
+                };
+                break;
+            case InputKeyDownEnd:
+                changes = {
+                    highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)
+                };
+                break;
+            case InputBlur:
+                changes = _extends$3({
+                    isOpen: false,
+                    highlightedIndex: -1
+                }, state.highlightedIndex >= 0 && ((_props$items = props.items) == null ? void 0 : _props$items.length) && action.selectItem && {
+                    selectedItem: props.items[state.highlightedIndex],
+                    inputValue: props.itemToString(props.items[state.highlightedIndex])
+                });
+                break;
+            case InputChange:
+                changes = {
+                    isOpen: true,
+                    highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
+                    inputValue: action.inputValue
+                };
+                break;
+            case InputFocus:
+                changes = {
+                    isOpen: true,
+                    highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)
+                };
+                break;
+            case FunctionSelectItem:
+                changes = {
+                    selectedItem: action.selectedItem,
+                    inputValue: props.itemToString(action.selectedItem)
+                };
+                break;
+            case ControlledPropUpdatedSelectedItem:
+                changes = {
+                    inputValue: action.inputValue
+                };
+                break;
+            default:
+                return downshiftCommonReducer(state, action, stateChangeTypes$1$1);
         }
-        var type2 = item.type;
-        var name2 = type2 ? type2.name : "";
-        return name2 === Handles.name || name2 === Rail.name || name2 === Ticks.name || name2 === Tracks.name;
-    };
-    var getNextValue = function getNextValue2(curr, step2, domain2, reversed) {
-        var newVal = reversed ? curr - step2 : curr + step2;
-        return reversed ? Math.max(domain2[0], newVal) : Math.min(domain2[1], newVal);
-    };
-    var getPrevValue = function getPrevValue2(curr, step2, domain2, reversed) {
-        var newVal = reversed ? curr + step2 : curr - step2;
-        return reversed ? Math.min(domain2[1], newVal) : Math.max(domain2[0], newVal);
-    };
-    var Slider$2 = /* @__PURE__ */ function(_PureComponent) {
-        _inherits(Slider2, _PureComponent);
-        var _super = _createSuper(Slider2);
+        return _extends$3({}, state, changes);
+    }
+    var _excluded$1$1 = ["onMouseLeave", "refKey", "ref"],
+        _excluded2$1 = ["item", "index", "refKey", "ref", "onMouseMove", "onMouseDown", "onClick", "onPress", "disabled"],
+        _excluded3 = ["onClick", "onPress", "refKey", "ref"],
+        _excluded4 = ["onKeyDown", "onChange", "onInput", "onFocus", "onBlur", "onChangeText", "refKey", "ref"];
+    useCombobox.stateChangeTypes = stateChangeTypes$1$1;
 
-        function Slider2() {
-            var _this;
-            _classCallCheck$f(this, Slider2);
-            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+    function useCombobox(userProps) {
+        if (userProps === void 0) {
+            userProps = {};
+        }
+        var props = _extends$3({}, defaultProps$1, userProps);
+        var initialIsOpen = props.initialIsOpen,
+            defaultIsOpen = props.defaultIsOpen,
+            items = props.items,
+            scrollIntoView2 = props.scrollIntoView,
+            environment = props.environment,
+            getA11yStatusMessage2 = props.getA11yStatusMessage,
+            getA11ySelectionMessage2 = props.getA11ySelectionMessage,
+            itemToString2 = props.itemToString;
+        var initialState2 = getInitialState$1(props);
+        var _useControlledReducer = useControlledReducer(downshiftUseComboboxReducer, initialState2, props),
+            state = _useControlledReducer[0],
+            dispatch2 = _useControlledReducer[1];
+        var isOpen = state.isOpen,
+            highlightedIndex = state.highlightedIndex,
+            selectedItem = state.selectedItem,
+            inputValue = state.inputValue;
+        var menuRef = React.useRef(null);
+        var itemRefs = React.useRef({});
+        var inputRef = React.useRef(null);
+        var toggleButtonRef = React.useRef(null);
+        var isInitialMountRef = React.useRef(true);
+        var elementIds = useElementIds(props);
+        var previousResultCountRef = React.useRef();
+        var latest2 = useLatestRef({
+            state,
+            props
+        });
+        var getItemNodeFromIndex = React.useCallback(function(index2) {
+            return itemRefs.current[elementIds.getItemId(index2)];
+        }, [elementIds]);
+        useA11yMessageSetter(getA11yStatusMessage2, [isOpen, highlightedIndex, inputValue, items], _extends$3({
+            isInitialMount: isInitialMountRef.current,
+            previousResultCount: previousResultCountRef.current,
+            items,
+            environment,
+            itemToString: itemToString2
+        }, state));
+        useA11yMessageSetter(getA11ySelectionMessage2, [selectedItem], _extends$3({
+            isInitialMount: isInitialMountRef.current,
+            previousResultCount: previousResultCountRef.current,
+            items,
+            environment,
+            itemToString: itemToString2
+        }, state));
+        var shouldScrollRef = useScrollIntoView({
+            menuElement: menuRef.current,
+            highlightedIndex,
+            isOpen,
+            itemRefs,
+            scrollIntoView: scrollIntoView2,
+            getItemNodeFromIndex
+        });
+        useControlPropsValidator({
+            isInitialMount: isInitialMountRef.current,
+            props,
+            state
+        });
+        React.useEffect(function() {
+            var focusOnOpen = initialIsOpen || defaultIsOpen || isOpen;
+            if (focusOnOpen && inputRef.current) {
+                inputRef.current.focus();
             }
-            _this = _super.call.apply(_super, [this].concat(args));
-            _this.state = {
-                step: 0.1,
-                values: [],
-                domain: [0, 100],
-                handles: [],
-                reversed: false,
-                activeHandleID: "",
-                valueToPerc: null,
-                valueToStep: null,
-                pixelToStep: null
+        }, []);
+        React.useEffect(function() {
+            if (isInitialMountRef.current) {
+                return;
+            }
+            previousResultCountRef.current = items.length;
+        });
+        var mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [inputRef, menuRef, toggleButtonRef], environment, function() {
+            dispatch2({
+                type: InputBlur,
+                selectItem: false
+            });
+        });
+        var setGetterPropCallInfo = useGetterPropsCalledChecker();
+        React.useEffect(function() {
+            isInitialMountRef.current = false;
+            return function() {
+                isInitialMountRef.current = true;
             };
-            _this.slider = /* @__PURE__ */ React__default.default.createRef();
-            _this.onKeyDown = function(e3, handleID) {
-                var validUpKeys = ["ArrowRight", "ArrowUp"];
-                var validDownKeys = ["ArrowDown", "ArrowLeft"];
-                var _assertThisInitialize = _assertThisInitialized$1(_this),
-                    handles = _assertThisInitialize.state.handles,
-                    _assertThisInitialize2 = _assertThisInitialize.props,
-                    _assertThisInitialize3 = _assertThisInitialize2.step,
-                    step2 = _assertThisInitialize3 === void 0 ? 0.1 : _assertThisInitialize3,
-                    _assertThisInitialize4 = _assertThisInitialize2.reversed,
-                    reversed = _assertThisInitialize4 === void 0 ? false : _assertThisInitialize4,
-                    _assertThisInitialize5 = _assertThisInitialize2.vertical,
-                    vertical = _assertThisInitialize5 === void 0 ? false : _assertThisInitialize5,
-                    _assertThisInitialize6 = _assertThisInitialize2.domain,
-                    domain2 = _assertThisInitialize6 === void 0 ? [0, 100] : _assertThisInitialize6;
-                var key = e3.key || "".concat(e3.keyCode);
-                if (!validUpKeys.concat(validDownKeys).includes(key)) {
-                    return;
-                }
-                if (vertical) {
-                    var _ref2 = [validDownKeys, validUpKeys];
-                    validUpKeys = _ref2[0];
-                    validDownKeys = _ref2[1];
+        }, []);
+        React.useEffect(function() {
+            var _environment$document;
+            if (!isOpen) {
+                itemRefs.current = {};
+            } else if (((_environment$document = environment.document) == null ? void 0 : _environment$document.activeElement) !== inputRef.current) {
+                var _inputRef$current;
+                inputRef == null || (_inputRef$current = inputRef.current) == null ? void 0 : _inputRef$current.focus();
+            }
+        }, [isOpen, environment]);
+        var inputKeyDownHandlers = React.useMemo(function() {
+            return {
+                ArrowDown: function ArrowDown2(event2) {
+                    event2.preventDefault();
+                    dispatch2({
+                        type: InputKeyDownArrowDown,
+                        altKey: event2.altKey,
+                        getItemNodeFromIndex
+                    });
+                },
+                ArrowUp: function ArrowUp2(event2) {
+                    event2.preventDefault();
+                    dispatch2({
+                        type: InputKeyDownArrowUp,
+                        altKey: event2.altKey,
+                        getItemNodeFromIndex
+                    });
+                },
+                Home: function Home(event2) {
+                    if (!latest2.current.state.isOpen) {
+                        return;
+                    }
+                    event2.preventDefault();
+                    dispatch2({
+                        type: InputKeyDownHome,
+                        getItemNodeFromIndex
+                    });
+                },
+                End: function End(event2) {
+                    if (!latest2.current.state.isOpen) {
+                        return;
+                    }
+                    event2.preventDefault();
+                    dispatch2({
+                        type: InputKeyDownEnd,
+                        getItemNodeFromIndex
+                    });
+                },
+                Escape: function Escape2(event2) {
+                    var latestState = latest2.current.state;
+                    if (latestState.isOpen || latestState.inputValue || latestState.selectedItem || latestState.highlightedIndex > -1) {
+                        event2.preventDefault();
+                        dispatch2({
+                            type: InputKeyDownEscape
+                        });
+                    }
+                },
+                Enter: function Enter(event2) {
+                    var latestState = latest2.current.state;
+                    if (!latestState.isOpen || event2.which === 229) {
+                        return;
+                    }
+                    event2.preventDefault();
+                    dispatch2({
+                        type: InputKeyDownEnter,
+                        getItemNodeFromIndex
+                    });
+                },
+                PageUp: function PageUp(event2) {
+                    if (latest2.current.state.isOpen) {
+                        event2.preventDefault();
+                        dispatch2({
+                            type: InputKeyDownPageUp,
+                            getItemNodeFromIndex
+                        });
+                    }
+                },
+                PageDown: function PageDown(event2) {
+                    if (latest2.current.state.isOpen) {
+                        event2.preventDefault();
+                        dispatch2({
+                            type: InputKeyDownPageDown,
+                            getItemNodeFromIndex
+                        });
+                    }
                 }
-                e3.stopPropagation && e3.stopPropagation();
-                e3.preventDefault && e3.preventDefault();
-                var found = handles.find(function(value) {
-                    return value.key === handleID;
+            };
+        }, [dispatch2, latest2, getItemNodeFromIndex]);
+        var getLabelProps = React.useCallback(function(labelProps) {
+            return _extends$3({
+                id: elementIds.labelId,
+                htmlFor: elementIds.inputId
+            }, labelProps);
+        }, [elementIds]);
+        var getMenuProps = React.useCallback(function(_temp, _temp2) {
+            var _extends2;
+            var _ref2 = _temp === void 0 ? {} : _temp,
+                onMouseLeave = _ref2.onMouseLeave,
+                _ref$refKey = _ref2.refKey,
+                refKey = _ref$refKey === void 0 ? "ref" : _ref$refKey,
+                ref2 = _ref2.ref,
+                rest = _objectWithoutPropertiesLoose$4(_ref2, _excluded$1$1);
+            var _ref22 = _temp2 === void 0 ? {} : _temp2;
+            _ref22.suppressRefError;
+            return _extends$3((_extends2 = {}, _extends2[refKey] = handleRefs(ref2, function(menuNode) {
+                menuRef.current = menuNode;
+            }), _extends2.id = elementIds.menuId, _extends2.role = "listbox", _extends2["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : "" + elementIds.labelId, _extends2.onMouseLeave = callAllEventHandlers(onMouseLeave, function() {
+                dispatch2({
+                    type: MenuMouseLeave
                 });
-                if (!found) {
+            }), _extends2), rest);
+        }, [dispatch2, setGetterPropCallInfo, elementIds]);
+        var getItemProps = React.useCallback(function(_temp3) {
+            var _extends3, _ref4;
+            var _ref3 = _temp3 === void 0 ? {} : _temp3,
+                itemProp = _ref3.item,
+                indexProp = _ref3.index,
+                _ref3$refKey = _ref3.refKey,
+                refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey,
+                ref2 = _ref3.ref,
+                onMouseMove = _ref3.onMouseMove,
+                onMouseDown = _ref3.onMouseDown,
+                onClick = _ref3.onClick;
+            _ref3.onPress;
+            var disabled2 = _ref3.disabled,
+                rest = _objectWithoutPropertiesLoose$4(_ref3, _excluded2$1);
+            var _latest$current = latest2.current,
+                latestProps = _latest$current.props,
+                latestState = _latest$current.state;
+            var _getItemAndIndex = getItemAndIndex(itemProp, indexProp, latestProps.items, "Pass either item or index to getItemProps!"),
+                index2 = _getItemAndIndex[1];
+            var onSelectKey = "onClick";
+            var customClickHandler = onClick;
+            var itemHandleMouseMove = function itemHandleMouseMove2() {
+                if (index2 === latestState.highlightedIndex) {
                     return;
                 }
-                var currVal = found.val;
-                var newVal = currVal;
-                if (validUpKeys.includes(key)) {
-                    newVal = getNextValue(currVal, step2, domain2, reversed);
-                } else if (validDownKeys.includes(key)) {
-                    newVal = getPrevValue(currVal, step2, domain2, reversed);
-                }
-                var nextHandles = handles.map(function(v2) {
-                    return v2.key === handleID ? {
-                        key: v2.key,
-                        val: newVal
-                    } : v2;
+                shouldScrollRef.current = false;
+                dispatch2({
+                    type: ItemMouseMove,
+                    index: index2,
+                    disabled: disabled2
                 });
-                _this.submitUpdate(nextHandles, true);
             };
-            _this.onMouseDown = function(e3, handleID) {
-                _this.onStart(e3, handleID, false);
+            var itemHandleClick = function itemHandleClick2() {
+                dispatch2({
+                    type: ItemClick,
+                    index: index2
+                });
             };
-            _this.onTouchStart = function(e3, handleID) {
-                if (isNotValidTouch(e3)) {
-                    return;
-                }
-                _this.onStart(e3, handleID, true);
+            var itemHandleMouseDown = function itemHandleMouseDown2(e3) {
+                return e3.preventDefault();
             };
-            _this.getEventData = function(e3, isTouch) {
-                var _assertThisInitialize7 = _assertThisInitialized$1(_this),
-                    _assertThisInitialize8 = _assertThisInitialize7.state,
-                    pixelToStep = _assertThisInitialize8.pixelToStep,
-                    valueToPerc = _assertThisInitialize8.valueToPerc,
-                    vertical = _assertThisInitialize7.props.vertical;
-                pixelToStep.setDomain(getSliderDomain(_this.slider.current, vertical));
-                var value;
-                if (isTouch && e3 instanceof TouchEvent) {
-                    value = pixelToStep.getValue(getTouchPosition(vertical, e3));
-                } else if (e3 instanceof MouseEvent) {
-                    value = pixelToStep.getValue(vertical ? e3.clientY : e3.pageX);
+            return _extends$3((_extends3 = {}, _extends3[refKey] = handleRefs(ref2, function(itemNode) {
+                if (itemNode) {
+                    itemRefs.current[elementIds.getItemId(index2)] = itemNode;
                 }
-                return {
-                    value,
-                    percent: valueToPerc.getValue(value)
-                };
-            };
-            _this.onMouseMove = function(e3) {
-                var _assertThisInitialize9 = _assertThisInitialized$1(_this),
-                    _assertThisInitialize10 = _assertThisInitialize9.state,
-                    curr = _assertThisInitialize10.handles,
-                    pixelToStep = _assertThisInitialize10.pixelToStep,
-                    _assertThisInitialize11 = _assertThisInitialize10.activeHandleID,
-                    activeHandleID = _assertThisInitialize11 === void 0 ? "" : _assertThisInitialize11,
-                    _assertThisInitialize12 = _assertThisInitialize9.props,
-                    vertical = _assertThisInitialize12.vertical,
-                    _assertThisInitialize13 = _assertThisInitialize12.reversed,
-                    reversed = _assertThisInitialize13 === void 0 ? false : _assertThisInitialize13;
-                pixelToStep.setDomain(getSliderDomain(_this.slider.current, vertical));
-                var updateValue = pixelToStep.getValue(vertical ? e3.clientY : e3.pageX);
-                var nextHandles = getUpdatedHandles(curr, activeHandleID, updateValue, reversed);
-                _this.submitUpdate(nextHandles);
+            }), _extends3.disabled = disabled2, _extends3.role = "option", _extends3["aria-selected"] = "" + (index2 === latestState.highlightedIndex), _extends3.id = elementIds.getItemId(index2), _extends3), !disabled2 && (_ref4 = {}, _ref4[onSelectKey] = callAllEventHandlers(customClickHandler, itemHandleClick), _ref4), {
+                onMouseMove: callAllEventHandlers(onMouseMove, itemHandleMouseMove),
+                onMouseDown: callAllEventHandlers(onMouseDown, itemHandleMouseDown)
+            }, rest);
+        }, [dispatch2, latest2, shouldScrollRef, elementIds]);
+        var getToggleButtonProps = React.useCallback(function(_temp4) {
+            var _extends4;
+            var _ref5 = _temp4 === void 0 ? {} : _temp4,
+                onClick = _ref5.onClick;
+            _ref5.onPress;
+            var _ref5$refKey = _ref5.refKey,
+                refKey = _ref5$refKey === void 0 ? "ref" : _ref5$refKey,
+                ref2 = _ref5.ref,
+                rest = _objectWithoutPropertiesLoose$4(_ref5, _excluded3);
+            var latestState = latest2.current.state;
+            var toggleButtonHandleClick = function toggleButtonHandleClick2() {
+                dispatch2({
+                    type: ToggleButtonClick
+                });
             };
-            _this.onTouchMove = function(e3) {
-                var _assertThisInitialize14 = _assertThisInitialized$1(_this),
-                    _assertThisInitialize15 = _assertThisInitialize14.state,
-                    curr = _assertThisInitialize15.handles,
-                    pixelToStep = _assertThisInitialize15.pixelToStep,
-                    activeHandleID = _assertThisInitialize15.activeHandleID,
-                    _assertThisInitialize16 = _assertThisInitialize14.props,
-                    vertical = _assertThisInitialize16.vertical,
-                    reversed = _assertThisInitialize16.reversed;
-                if (pixelToStep === null || isNotValidTouch(e3)) {
-                    return;
+            return _extends$3((_extends4 = {}, _extends4[refKey] = handleRefs(ref2, function(toggleButtonNode) {
+                toggleButtonRef.current = toggleButtonNode;
+            }), _extends4["aria-controls"] = elementIds.menuId, _extends4["aria-expanded"] = latestState.isOpen, _extends4.id = elementIds.toggleButtonId, _extends4.tabIndex = -1, _extends4), !rest.disabled && _extends$3({}, {
+                onClick: callAllEventHandlers(onClick, toggleButtonHandleClick)
+            }), rest);
+        }, [dispatch2, latest2, elementIds]);
+        var getInputProps = React.useCallback(function(_temp5, _temp6) {
+            var _extends5;
+            var _ref6 = _temp5 === void 0 ? {} : _temp5,
+                onKeyDown = _ref6.onKeyDown,
+                onChange2 = _ref6.onChange,
+                onInput = _ref6.onInput,
+                onFocus = _ref6.onFocus,
+                onBlur = _ref6.onBlur;
+            _ref6.onChangeText;
+            var _ref6$refKey = _ref6.refKey,
+                refKey = _ref6$refKey === void 0 ? "ref" : _ref6$refKey,
+                ref2 = _ref6.ref,
+                rest = _objectWithoutPropertiesLoose$4(_ref6, _excluded4);
+            var _ref7 = _temp6 === void 0 ? {} : _temp6;
+            _ref7.suppressRefError;
+            var latestState = latest2.current.state;
+            var inputHandleKeyDown = function inputHandleKeyDown2(event2) {
+                var key = normalizeArrowKey(event2);
+                if (key && inputKeyDownHandlers[key]) {
+                    inputKeyDownHandlers[key](event2);
                 }
-                pixelToStep.setDomain(getSliderDomain(_this.slider.current, vertical));
-                var updateValue = pixelToStep.getValue(getTouchPosition(vertical, e3));
-                var nextHandles = getUpdatedHandles(curr, activeHandleID, updateValue, reversed);
-                _this.submitUpdate(nextHandles);
             };
-            _this.onMouseUp = function() {
-                var _assertThisInitialize17 = _assertThisInitialized$1(_this),
-                    _assertThisInitialize18 = _assertThisInitialize17.state,
-                    _assertThisInitialize19 = _assertThisInitialize18.handles,
-                    handles = _assertThisInitialize19 === void 0 ? [] : _assertThisInitialize19,
-                    activeHandleID = _assertThisInitialize18.activeHandleID,
-                    _assertThisInitialize20 = _assertThisInitialize17.props,
-                    _assertThisInitialize21 = _assertThisInitialize20.onChange,
-                    onChange2 = _assertThisInitialize21 === void 0 ? noop$5 : _assertThisInitialize21,
-                    _assertThisInitialize22 = _assertThisInitialize20.onSlideEnd,
-                    onSlideEnd = _assertThisInitialize22 === void 0 ? noop$5 : _assertThisInitialize22;
-                onChange2(handles.map(function(d2) {
-                    return d2.val;
-                }));
-                onSlideEnd(handles.map(function(d2) {
-                    return d2.val;
-                }), {
-                    activeHandleID
-                });
-                _this.setState({
-                    activeHandleID: ""
+            var inputHandleChange = function inputHandleChange2(event2) {
+                dispatch2({
+                    type: InputChange,
+                    inputValue: event2.target.value
                 });
-                if (isBrowser) {
-                    document.removeEventListener("mousemove", _this.onMouseMove);
-                    document.removeEventListener("mouseup", _this.onMouseUp);
+            };
+            var inputHandleBlur = function inputHandleBlur2(event2) {
+                if (latestState.isOpen && !mouseAndTouchTrackersRef.current.isMouseDown) {
+                    var isBlurByTabChange = event2.relatedTarget === null && environment.document.activeElement !== environment.document.body;
+                    dispatch2({
+                        type: InputBlur,
+                        selectItem: !isBlurByTabChange
+                    });
                 }
             };
-            _this.onTouchEnd = function() {
-                var _assertThisInitialize23 = _assertThisInitialized$1(_this),
-                    _assertThisInitialize24 = _assertThisInitialize23.state,
-                    handles = _assertThisInitialize24.handles,
-                    activeHandleID = _assertThisInitialize24.activeHandleID,
-                    _assertThisInitialize25 = _assertThisInitialize23.props,
-                    _assertThisInitialize26 = _assertThisInitialize25.onChange,
-                    onChange2 = _assertThisInitialize26 === void 0 ? noop$5 : _assertThisInitialize26,
-                    _assertThisInitialize27 = _assertThisInitialize25.onSlideEnd,
-                    onSlideEnd = _assertThisInitialize27 === void 0 ? noop$5 : _assertThisInitialize27;
-                onChange2(handles.map(function(d2) {
-                    return d2.val;
-                }));
-                onSlideEnd(handles.map(function(d2) {
-                    return d2.val;
-                }), {
-                    activeHandleID
-                });
-                _this.setState({
-                    activeHandleID: ""
-                });
-                if (isBrowser) {
-                    document.removeEventListener("touchmove", _this.onTouchMove);
-                    document.removeEventListener("touchend", _this.onTouchEnd);
+            var inputHandleFocus = function inputHandleFocus2() {
+                if (!latestState.isOpen) {
+                    dispatch2({
+                        type: InputFocus
+                    });
                 }
             };
-            return _this;
-        }
-        _createClass$f(Slider2, [{
-            key: "componentDidMount",
-            value: function componentDidMount() {
-                var pixelToStep = this.state.pixelToStep;
-                var vertical = this.props.vertical;
-                pixelToStep.setDomain(getSliderDomain(this.slider.current, vertical));
-            }
-        }, {
-            key: "componentWillUnmount",
-            value: function componentWillUnmount() {
-                this.removeListeners();
+            var onChangeKey = "onChange";
+            var eventHandlers = {};
+            if (!rest.disabled) {
+                var _eventHandlers;
+                eventHandlers = (_eventHandlers = {}, _eventHandlers[onChangeKey] = callAllEventHandlers(onChange2, onInput, inputHandleChange), _eventHandlers.onKeyDown = callAllEventHandlers(onKeyDown, inputHandleKeyDown), _eventHandlers.onBlur = callAllEventHandlers(onBlur, inputHandleBlur), _eventHandlers.onFocus = callAllEventHandlers(onFocus, inputHandleFocus), _eventHandlers);
             }
-        }, {
-            key: "removeListeners",
-            value: function removeListeners() {
-                if (isBrowser) {
-                    document.removeEventListener("mousemove", this.onMouseMove);
-                    document.removeEventListener("mouseup", this.onMouseUp);
-                    document.removeEventListener("touchmove", this.onTouchMove);
-                    document.removeEventListener("touchend", this.onTouchEnd);
+            return _extends$3((_extends5 = {}, _extends5[refKey] = handleRefs(ref2, function(inputNode) {
+                inputRef.current = inputNode;
+            }), _extends5["aria-activedescendant"] = latestState.isOpen && latestState.highlightedIndex > -1 ? elementIds.getItemId(latestState.highlightedIndex) : "", _extends5["aria-autocomplete"] = "list", _extends5["aria-controls"] = elementIds.menuId, _extends5["aria-expanded"] = latestState.isOpen, _extends5["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : "" + elementIds.labelId, _extends5.autoComplete = "off", _extends5.id = elementIds.inputId, _extends5.role = "combobox", _extends5.value = latestState.inputValue, _extends5), eventHandlers, rest);
+        }, [setGetterPropCallInfo, latest2, elementIds, inputKeyDownHandlers, dispatch2, mouseAndTouchTrackersRef, environment]);
+        var toggleMenu = React.useCallback(function() {
+            dispatch2({
+                type: FunctionToggleMenu
+            });
+        }, [dispatch2]);
+        var closeMenu = React.useCallback(function() {
+            dispatch2({
+                type: FunctionCloseMenu
+            });
+        }, [dispatch2]);
+        var openMenu = React.useCallback(function() {
+            dispatch2({
+                type: FunctionOpenMenu
+            });
+        }, [dispatch2]);
+        var setHighlightedIndex = React.useCallback(function(newHighlightedIndex) {
+            dispatch2({
+                type: FunctionSetHighlightedIndex,
+                highlightedIndex: newHighlightedIndex
+            });
+        }, [dispatch2]);
+        var selectItem = React.useCallback(function(newSelectedItem) {
+            dispatch2({
+                type: FunctionSelectItem,
+                selectedItem: newSelectedItem
+            });
+        }, [dispatch2]);
+        var setInputValue = React.useCallback(function(newInputValue) {
+            dispatch2({
+                type: FunctionSetInputValue,
+                inputValue: newInputValue
+            });
+        }, [dispatch2]);
+        var reset2 = React.useCallback(function() {
+            dispatch2({
+                type: FunctionReset$1
+            });
+        }, [dispatch2]);
+        return {
+            getItemProps,
+            getLabelProps,
+            getMenuProps,
+            getInputProps,
+            getToggleButtonProps,
+            toggleMenu,
+            openMenu,
+            closeMenu,
+            setHighlightedIndex,
+            setInputValue,
+            selectItem,
+            reset: reset2,
+            highlightedIndex,
+            isOpen,
+            selectedItem,
+            inputValue
+        };
+    }
+    var defaultStateValues = {
+        activeIndex: -1,
+        selectedItems: []
+    };
+
+    function getInitialValue$2(props, propKey) {
+        return getInitialValue$1(props, propKey, defaultStateValues);
+    }
+
+    function getDefaultValue(props, propKey) {
+        return getDefaultValue$1(props, propKey, defaultStateValues);
+    }
+
+    function getInitialState(props) {
+        var activeIndex = getInitialValue$2(props, "activeIndex");
+        var selectedItems = getInitialValue$2(props, "selectedItems");
+        return {
+            activeIndex,
+            selectedItems
+        };
+    }
+
+    function isKeyDownOperationPermitted(event2) {
+        if (event2.shiftKey || event2.metaKey || event2.ctrlKey || event2.altKey) {
+            return false;
+        }
+        var element2 = event2.target;
+        if (element2 instanceof HTMLInputElement && element2.value !== "" && (element2.selectionStart !== 0 || element2.selectionEnd !== 0)) {
+            return false;
+        }
+        return true;
+    }
+
+    function getA11yRemovalMessage(selectionParameters) {
+        var removedSelectedItem = selectionParameters.removedSelectedItem,
+            itemToStringLocal = selectionParameters.itemToString;
+        return itemToStringLocal(removedSelectedItem) + " has been removed.";
+    }
+    ({
+        selectedItems: propTypes.exports.array,
+        initialSelectedItems: propTypes.exports.array,
+        defaultSelectedItems: propTypes.exports.array,
+        itemToString: propTypes.exports.func,
+        getA11yRemovalMessage: propTypes.exports.func,
+        stateReducer: propTypes.exports.func,
+        activeIndex: propTypes.exports.number,
+        initialActiveIndex: propTypes.exports.number,
+        defaultActiveIndex: propTypes.exports.number,
+        onActiveIndexChange: propTypes.exports.func,
+        onSelectedItemsChange: propTypes.exports.func,
+        keyNavigationNext: propTypes.exports.string,
+        keyNavigationPrevious: propTypes.exports.string,
+        environment: propTypes.exports.shape({
+            addEventListener: propTypes.exports.func,
+            removeEventListener: propTypes.exports.func,
+            document: propTypes.exports.shape({
+                getElementById: propTypes.exports.func,
+                activeElement: propTypes.exports.any,
+                body: propTypes.exports.any
+            })
+        })
+    });
+    var defaultProps$4 = {
+        itemToString: defaultProps$3.itemToString,
+        stateReducer: defaultProps$3.stateReducer,
+        environment: defaultProps$3.environment,
+        getA11yRemovalMessage,
+        keyNavigationNext: "ArrowRight",
+        keyNavigationPrevious: "ArrowLeft"
+    };
+    var SelectedItemClick = 0;
+    var SelectedItemKeyDownDelete = 1;
+    var SelectedItemKeyDownBackspace = 2;
+    var SelectedItemKeyDownNavigationNext = 3;
+    var SelectedItemKeyDownNavigationPrevious = 4;
+    var DropdownKeyDownNavigationPrevious = 5;
+    var DropdownKeyDownBackspace = 6;
+    var DropdownClick = 7;
+    var FunctionAddSelectedItem = 8;
+    var FunctionRemoveSelectedItem = 9;
+    var FunctionSetSelectedItems = 10;
+    var FunctionSetActiveIndex = 11;
+    var FunctionReset = 12;
+    var stateChangeTypes$4 = /* @__PURE__ */ Object.freeze({
+        __proto__: null,
+        SelectedItemClick,
+        SelectedItemKeyDownDelete,
+        SelectedItemKeyDownBackspace,
+        SelectedItemKeyDownNavigationNext,
+        SelectedItemKeyDownNavigationPrevious,
+        DropdownKeyDownNavigationPrevious,
+        DropdownKeyDownBackspace,
+        DropdownClick,
+        FunctionAddSelectedItem,
+        FunctionRemoveSelectedItem,
+        FunctionSetSelectedItems,
+        FunctionSetActiveIndex,
+        FunctionReset
+    });
+
+    function downshiftMultipleSelectionReducer(state, action) {
+        var type2 = action.type,
+            index2 = action.index,
+            props = action.props,
+            selectedItem = action.selectedItem;
+        var activeIndex = state.activeIndex,
+            selectedItems = state.selectedItems;
+        var changes;
+        switch (type2) {
+            case SelectedItemClick:
+                changes = {
+                    activeIndex: index2
+                };
+                break;
+            case SelectedItemKeyDownNavigationPrevious:
+                changes = {
+                    activeIndex: activeIndex - 1 < 0 ? 0 : activeIndex - 1
+                };
+                break;
+            case SelectedItemKeyDownNavigationNext:
+                changes = {
+                    activeIndex: activeIndex + 1 >= selectedItems.length ? -1 : activeIndex + 1
+                };
+                break;
+            case SelectedItemKeyDownBackspace:
+            case SelectedItemKeyDownDelete: {
+                if (activeIndex < 0) {
+                    break;
                 }
-            }
-        }, {
-            key: "onStart",
-            value: function onStart(e3, handleID, isTouch) {
-                var handles = this.state.handles,
-                    _this$props$onSlideSt = this.props.onSlideStart,
-                    onSlideStart = _this$props$onSlideSt === void 0 ? noop$5 : _this$props$onSlideSt;
-                if (!isTouch) {
-                    e3.preventDefault && e3.preventDefault();
+                var newActiveIndex = activeIndex;
+                if (selectedItems.length === 1) {
+                    newActiveIndex = -1;
+                } else if (activeIndex === selectedItems.length - 1) {
+                    newActiveIndex = selectedItems.length - 2;
                 }
-                e3.stopPropagation && e3.stopPropagation();
-                var found = handles.find(function(value) {
-                    return value.key === handleID;
+                changes = _extends$3({
+                    selectedItems: [].concat(selectedItems.slice(0, activeIndex), selectedItems.slice(activeIndex + 1))
+                }, {
+                    activeIndex: newActiveIndex
                 });
-                if (found) {
-                    this.setState({
-                        activeHandleID: handleID
-                    });
-                    onSlideStart(handles.map(function(d2) {
-                        return d2.val;
-                    }), {
-                        activeHandleID: handleID
-                    });
-                    isTouch ? this.addTouchEvents() : this.addMouseEvents();
-                } else {
-                    this.setState({
-                        activeHandleID: ""
-                    });
-                    this.handleRailAndTrackClicks(e3, isTouch);
-                }
+                break;
             }
-        }, {
-            key: "handleRailAndTrackClicks",
-            value: function handleRailAndTrackClicks(e3, isTouch) {
-                var _this2 = this;
-                var _this$state = this.state,
-                    curr = _this$state.handles,
-                    pixelToStep = _this$state.pixelToStep,
-                    _this$props = this.props,
-                    vertical = _this$props.vertical,
-                    _this$props$reversed = _this$props.reversed,
-                    reversed = _this$props$reversed === void 0 ? false : _this$props$reversed;
-                var slider = this.slider;
-                pixelToStep.setDomain(getSliderDomain(slider.current, vertical));
-                var updateValue;
-                if (isTouch) {
-                    updateValue = pixelToStep.getValue(getTouchPosition(vertical, e3));
-                } else {
-                    updateValue = pixelToStep.getValue(vertical ? e3.clientY : e3.pageX);
+            case DropdownKeyDownNavigationPrevious:
+                changes = {
+                    activeIndex: selectedItems.length - 1
+                };
+                break;
+            case DropdownKeyDownBackspace:
+                changes = {
+                    selectedItems: selectedItems.slice(0, selectedItems.length - 1)
+                };
+                break;
+            case FunctionAddSelectedItem:
+                changes = {
+                    selectedItems: [].concat(selectedItems, [selectedItem])
+                };
+                break;
+            case DropdownClick:
+                changes = {
+                    activeIndex: -1
+                };
+                break;
+            case FunctionRemoveSelectedItem: {
+                var _newActiveIndex = activeIndex;
+                var selectedItemIndex = selectedItems.indexOf(selectedItem);
+                if (selectedItemIndex < 0) {
+                    break;
                 }
-                var updateKey = "";
-                var minDiff = Infinity;
-                for (var i2 = 0; i2 < curr.length; i2++) {
-                    var _curr$i = curr[i2],
-                        key = _curr$i.key,
-                        val = _curr$i.val;
-                    var diff = Math.abs(val - updateValue);
-                    if (diff < minDiff) {
-                        updateKey = key;
-                        minDiff = diff;
-                    }
+                if (selectedItems.length === 1) {
+                    _newActiveIndex = -1;
+                } else if (selectedItemIndex === selectedItems.length - 1) {
+                    _newActiveIndex = selectedItems.length - 2;
                 }
-                var nextHandles = getUpdatedHandles(curr, updateKey, updateValue, reversed);
-                this.setState({
-                    activeHandleID: updateKey
-                }, function() {
-                    _this2.submitUpdate(nextHandles, true);
-                    isTouch ? _this2.addTouchEvents() : _this2.addMouseEvents();
-                });
+                changes = {
+                    selectedItems: [].concat(selectedItems.slice(0, selectedItemIndex), selectedItems.slice(selectedItemIndex + 1)),
+                    activeIndex: _newActiveIndex
+                };
+                break;
             }
-        }, {
-            key: "addMouseEvents",
-            value: function addMouseEvents() {
-                if (isBrowser) {
-                    document.addEventListener("mousemove", this.onMouseMove);
-                    document.addEventListener("mouseup", this.onMouseUp);
-                }
+            case FunctionSetSelectedItems: {
+                var newSelectedItems = action.selectedItems;
+                changes = {
+                    selectedItems: newSelectedItems
+                };
+                break;
             }
-        }, {
-            key: "addTouchEvents",
-            value: function addTouchEvents() {
-                if (isBrowser) {
-                    document.addEventListener("touchmove", this.onTouchMove);
-                    document.addEventListener("touchend", this.onTouchEnd);
-                }
+            case FunctionSetActiveIndex: {
+                var _newActiveIndex2 = action.activeIndex;
+                changes = {
+                    activeIndex: _newActiveIndex2
+                };
+                break;
             }
-        }, {
-            key: "submitUpdate",
-            value: function submitUpdate(next2) {
-                var callOnChange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
-                var _this$props2 = this.props,
-                    _this$props2$mode = _this$props2.mode,
-                    mode = _this$props2$mode === void 0 ? 1 : _this$props2$mode,
-                    _this$props2$step = _this$props2.step,
-                    step2 = _this$props2$step === void 0 ? 0.1 : _this$props2$step,
-                    _this$props2$onUpdate = _this$props2.onUpdate,
-                    onUpdate = _this$props2$onUpdate === void 0 ? noop$5 : _this$props2$onUpdate,
-                    _this$props2$onChange = _this$props2.onChange,
-                    onChange2 = _this$props2$onChange === void 0 ? noop$5 : _this$props2$onChange,
-                    _this$props2$reversed = _this$props2.reversed,
-                    reversed = _this$props2$reversed === void 0 ? false : _this$props2$reversed;
-                var getValue2 = this.state.valueToStep.getValue;
-                this.setState(function(_ref2) {
-                    var curr = _ref2.handles;
-                    var handles = [];
-                    if (typeof mode === "function") {
-                        handles = mode(curr, next2, step2, reversed, getValue2);
-                    } else {
-                        switch (mode) {
-                            case 1:
-                                handles = mode1(curr, next2);
-                                break;
-                            case 2:
-                                handles = mode2(curr, next2);
-                                break;
-                            case 3:
-                                handles = mode3(curr, next2, step2, reversed, getValue2);
-                                break;
-                            default:
-                                handles = next2;
-                        }
-                    }
-                    onUpdate(handles.map(function(d2) {
-                        return d2.val;
-                    }));
-                    if (callOnChange) {
-                        onChange2(handles.map(function(d2) {
-                            return d2.val;
-                        }));
-                    }
-                    return {
-                        handles
-                    };
+            case FunctionReset:
+                changes = {
+                    activeIndex: getDefaultValue(props, "activeIndex"),
+                    selectedItems: getDefaultValue(props, "selectedItems")
+                };
+                break;
+            default:
+                throw new Error("Reducer called without proper action type.");
+        }
+        return _extends$3({}, state, changes);
+    }
+    var _excluded$4 = ["refKey", "ref", "onClick", "onKeyDown", "selectedItem", "index"],
+        _excluded2$3 = ["refKey", "ref", "onKeyDown", "onClick", "preventKeyAction"];
+    useMultipleSelection.stateChangeTypes = stateChangeTypes$4;
+
+    function useMultipleSelection(userProps) {
+        if (userProps === void 0) {
+            userProps = {};
+        }
+        var props = _extends$3({}, defaultProps$4, userProps);
+        var getA11yRemovalMessage2 = props.getA11yRemovalMessage,
+            itemToString2 = props.itemToString,
+            environment = props.environment,
+            keyNavigationNext = props.keyNavigationNext,
+            keyNavigationPrevious = props.keyNavigationPrevious;
+        var _useControlledReducer = useControlledReducer$1(downshiftMultipleSelectionReducer, getInitialState(props), props),
+            state = _useControlledReducer[0],
+            dispatch2 = _useControlledReducer[1];
+        var activeIndex = state.activeIndex,
+            selectedItems = state.selectedItems;
+        var isInitialMountRef = React.useRef(true);
+        var dropdownRef = React.useRef(null);
+        var previousSelectedItemsRef = React.useRef(selectedItems);
+        var selectedItemRefs = React.useRef();
+        selectedItemRefs.current = [];
+        var latest2 = useLatestRef({
+            state,
+            props
+        });
+        React.useEffect(function() {
+            if (isInitialMountRef.current || false) {
+                return;
+            }
+            if (selectedItems.length < previousSelectedItemsRef.current.length) {
+                var removedSelectedItem = previousSelectedItemsRef.current.find(function(item) {
+                    return selectedItems.indexOf(item) < 0;
                 });
+                setStatus(getA11yRemovalMessage2({
+                    itemToString: itemToString2,
+                    resultCount: selectedItems.length,
+                    removedSelectedItem,
+                    activeIndex,
+                    activeSelectedItem: selectedItems[activeIndex]
+                }), environment.document);
             }
-        }, {
-            key: "render",
-            value: function render2() {
-                var _this3 = this;
-                var _this$state2 = this.state,
-                    handles = _this$state2.handles,
-                    valueToPerc = _this$state2.valueToPerc,
-                    activeHandleID = _this$state2.activeHandleID,
-                    _this$props3 = this.props,
-                    className = _this$props3.className,
-                    _this$props3$rootStyl = _this$props3.rootStyle,
-                    rootStyle = _this$props3$rootStyl === void 0 ? {} : _this$props3$rootStyl,
-                    _this$props3$rootProp = _this$props3.rootProps,
-                    rootProps = _this$props3$rootProp === void 0 ? {} : _this$props3$rootProp,
-                    _this$props3$componen = _this$props3.component,
-                    Comp = _this$props3$componen === void 0 ? "div" : _this$props3$componen,
-                    _this$props3$disabled = _this$props3.disabled,
-                    disabled2 = _this$props3$disabled === void 0 ? false : _this$props3$disabled,
-                    _this$props3$flatten = _this$props3.flatten,
-                    flatten2 = _this$props3$flatten === void 0 ? false : _this$props3$flatten;
-                var mappedHandles = handles.map(function(_ref3) {
-                    var key = _ref3.key,
-                        val = _ref3.val;
-                    return {
-                        id: key,
-                        value: val,
-                        percent: valueToPerc.getValue(val)
-                    };
+            previousSelectedItemsRef.current = selectedItems;
+        }, [selectedItems.length]);
+        React.useEffect(function() {
+            if (isInitialMountRef.current) {
+                return;
+            }
+            if (activeIndex === -1 && dropdownRef.current) {
+                dropdownRef.current.focus();
+            } else if (selectedItemRefs.current[activeIndex]) {
+                selectedItemRefs.current[activeIndex].focus();
+            }
+        }, [activeIndex]);
+        useControlPropsValidator({
+            isInitialMount: isInitialMountRef.current,
+            props,
+            state
+        });
+        var setGetterPropCallInfo = useGetterPropsCalledChecker();
+        React.useEffect(function() {
+            isInitialMountRef.current = false;
+            return function() {
+                isInitialMountRef.current = true;
+            };
+        }, []);
+        var selectedItemKeyDownHandlers = React.useMemo(function() {
+            var _ref2;
+            return _ref2 = {}, _ref2[keyNavigationPrevious] = function() {
+                dispatch2({
+                    type: SelectedItemKeyDownNavigationPrevious
                 });
-                var children2 = React__default.default.Children.map(this.props.children, function(child) {
-                    if (isRCSComponent(child) === true) {
-                        return /* @__PURE__ */ React__default.default.cloneElement(child, {
-                            scale: valueToPerc,
-                            handles: mappedHandles,
-                            activeHandleID,
-                            getEventData: _this3.getEventData,
-                            emitKeyboard: disabled2 ? noop$5 : _this3.onKeyDown,
-                            emitMouse: disabled2 ? noop$5 : _this3.onMouseDown,
-                            emitTouch: disabled2 ? noop$5 : _this3.onTouchStart
-                        });
-                    } else {
-                        return child;
-                    }
+            }, _ref2[keyNavigationNext] = function() {
+                dispatch2({
+                    type: SelectedItemKeyDownNavigationNext
                 });
-                return flatten2 ? /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, /* @__PURE__ */ React__default.default.createElement(Comp, _objectSpread2(_objectSpread2({}, rootProps), {}, {
-                    style: rootStyle,
-                    className,
-                    ref: this.slider
-                })), children2) : /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, /* @__PURE__ */ React__default.default.createElement(Comp, _objectSpread2(_objectSpread2({}, rootProps), {}, {
-                    style: rootStyle,
-                    className,
-                    ref: this.slider
-                }), children2));
-            }
-        }], [{
-            key: "getDerivedStateFromProps",
-            value: function getDerivedStateFromProps(nextProps, prevState) {
-                var _nextProps$step = nextProps.step,
-                    step2 = _nextProps$step === void 0 ? 0.1 : _nextProps$step,
-                    values = nextProps.values,
-                    _nextProps$domain = nextProps.domain,
-                    domain2 = _nextProps$domain === void 0 ? [0, 100] : _nextProps$domain,
-                    _nextProps$reversed = nextProps.reversed,
-                    reversed = _nextProps$reversed === void 0 ? false : _nextProps$reversed,
-                    _nextProps$onUpdate = nextProps.onUpdate,
-                    onUpdate = _nextProps$onUpdate === void 0 ? noop$5 : _nextProps$onUpdate,
-                    _nextProps$onChange = nextProps.onChange,
-                    onChange2 = _nextProps$onChange === void 0 ? noop$5 : _nextProps$onChange,
-                    _nextProps$warnOnChan = nextProps.warnOnChanges,
-                    warnOnChanges = _nextProps$warnOnChan === void 0 ? false : _nextProps$warnOnChan;
-                var valueToPerc = prevState.valueToPerc;
-                var valueToStep = prevState.valueToStep;
-                var pixelToStep = prevState.pixelToStep;
-                var nextState = {};
-                if (!valueToPerc || !valueToStep || !pixelToStep) {
-                    valueToPerc = new LinearScale();
-                    valueToStep = new DiscreteScale();
-                    pixelToStep = new DiscreteScale();
-                    nextState.valueToPerc = valueToPerc;
-                    nextState.valueToStep = valueToStep;
-                    nextState.pixelToStep = pixelToStep;
+            }, _ref2.Delete = function Delete() {
+                dispatch2({
+                    type: SelectedItemKeyDownDelete
+                });
+            }, _ref2.Backspace = function Backspace() {
+                dispatch2({
+                    type: SelectedItemKeyDownBackspace
+                });
+            }, _ref2;
+        }, [dispatch2, keyNavigationNext, keyNavigationPrevious]);
+        var dropdownKeyDownHandlers = React.useMemo(function() {
+            var _ref2;
+            return _ref2 = {}, _ref2[keyNavigationPrevious] = function(event2) {
+                if (isKeyDownOperationPermitted(event2)) {
+                    dispatch2({
+                        type: DropdownKeyDownNavigationPrevious
+                    });
                 }
-                if (prevState.step === null || prevState.domain === null || prevState.reversed === null || step2 !== prevState.step || domain2[0] !== prevState.domain[0] || domain2[1] !== prevState.domain[1] || reversed !== prevState.reversed) {
-                    var _domain = _slicedToArray$7(domain2, 2),
-                        min2 = _domain[0],
-                        max2 = _domain[1];
-                    valueToStep.setStep(step2).setRange([min2, max2]).setDomain([min2, max2]);
-                    if (reversed === true) {
-                        valueToPerc.setDomain([min2, max2]).setRange([100, 0]);
-                        pixelToStep.setStep(step2).setRange([max2, min2]);
-                    } else {
-                        valueToPerc.setDomain([min2, max2]).setRange([0, 100]);
-                        pixelToStep.setStep(step2).setRange([min2, max2]);
-                    }
-                    var _getHandles = getHandles(values || prevState.values, reversed, valueToStep, warnOnChanges),
-                        handles = _getHandles.handles,
-                        changes = _getHandles.changes;
-                    if (changes || values === void 0 || values === prevState.values) {
-                        onUpdate(handles.map(function(d2) {
-                            return d2.val;
-                        }));
-                        onChange2(handles.map(function(d2) {
-                            return d2.val;
-                        }));
-                    }
-                    nextState.step = step2;
-                    nextState.values = values;
-                    nextState.domain = domain2;
-                    nextState.handles = handles;
-                    nextState.reversed = reversed;
-                } else if (!equal(values, prevState.values)) {
-                    var _getHandles2 = getHandles(values, reversed, valueToStep, warnOnChanges),
-                        _handles = _getHandles2.handles,
-                        _changes = _getHandles2.changes;
-                    if (_changes) {
-                        onUpdate(_handles.map(function(d2) {
-                            return d2.val;
-                        }));
-                        onChange2(_handles.map(function(d2) {
-                            return d2.val;
-                        }));
-                    }
-                    nextState.values = values;
-                    nextState.handles = _handles;
+            }, _ref2.Backspace = function Backspace(event2) {
+                if (isKeyDownOperationPermitted(event2)) {
+                    dispatch2({
+                        type: DropdownKeyDownBackspace
+                    });
                 }
-                if (Object.keys(nextState).length) {
-                    return nextState;
+            }, _ref2;
+        }, [dispatch2, keyNavigationPrevious]);
+        var getSelectedItemProps = React.useCallback(function(_temp) {
+            var _extends2;
+            var _ref3 = _temp === void 0 ? {} : _temp,
+                _ref3$refKey = _ref3.refKey,
+                refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey,
+                ref2 = _ref3.ref,
+                onClick = _ref3.onClick,
+                onKeyDown = _ref3.onKeyDown,
+                selectedItemProp = _ref3.selectedItem,
+                indexProp = _ref3.index,
+                rest = _objectWithoutPropertiesLoose$4(_ref3, _excluded$4);
+            var latestState = latest2.current.state;
+            var _getItemAndIndex = getItemAndIndex(selectedItemProp, indexProp, latestState.selectedItems, "Pass either item or index to getSelectedItemProps!"),
+                index2 = _getItemAndIndex[1];
+            var isFocusable = index2 > -1 && index2 === latestState.activeIndex;
+            var selectedItemHandleClick = function selectedItemHandleClick2() {
+                dispatch2({
+                    type: SelectedItemClick,
+                    index: index2
+                });
+            };
+            var selectedItemHandleKeyDown = function selectedItemHandleKeyDown2(event2) {
+                var key = normalizeArrowKey(event2);
+                if (key && selectedItemKeyDownHandlers[key]) {
+                    selectedItemKeyDownHandlers[key](event2);
                 }
-                return null;
-            }
-        }]);
-        return Slider2;
-    }(React.PureComponent);
-    const InputWrapper$1 = styled__default.default.div`
-    position: relative;
-    display: flex;
-    flex: 1 1 auto;
-    height: 3rem;
+            };
+            return _extends$3((_extends2 = {}, _extends2[refKey] = handleRefs(ref2, function(selectedItemNode) {
+                if (selectedItemNode) {
+                    selectedItemRefs.current.push(selectedItemNode);
+                }
+            }), _extends2.tabIndex = isFocusable ? 0 : -1, _extends2.onClick = callAllEventHandlers(onClick, selectedItemHandleClick), _extends2.onKeyDown = callAllEventHandlers(onKeyDown, selectedItemHandleKeyDown), _extends2), rest);
+        }, [dispatch2, latest2, selectedItemKeyDownHandlers]);
+        var getDropdownProps = React.useCallback(function(_temp2, _temp3) {
+            var _extends3;
+            var _ref4 = _temp2 === void 0 ? {} : _temp2,
+                _ref4$refKey = _ref4.refKey,
+                refKey = _ref4$refKey === void 0 ? "ref" : _ref4$refKey,
+                ref2 = _ref4.ref,
+                onKeyDown = _ref4.onKeyDown,
+                onClick = _ref4.onClick,
+                _ref4$preventKeyActio = _ref4.preventKeyAction,
+                preventKeyAction = _ref4$preventKeyActio === void 0 ? false : _ref4$preventKeyActio,
+                rest = _objectWithoutPropertiesLoose$4(_ref4, _excluded2$3);
+            var _ref5 = _temp3 === void 0 ? {} : _temp3;
+            _ref5.suppressRefError;
+            var dropdownHandleKeyDown = function dropdownHandleKeyDown2(event2) {
+                var key = normalizeArrowKey(event2);
+                if (key && dropdownKeyDownHandlers[key]) {
+                    dropdownKeyDownHandlers[key](event2);
+                }
+            };
+            var dropdownHandleClick = function dropdownHandleClick2() {
+                dispatch2({
+                    type: DropdownClick
+                });
+            };
+            return _extends$3((_extends3 = {}, _extends3[refKey] = handleRefs(ref2, function(dropdownNode) {
+                if (dropdownNode) {
+                    dropdownRef.current = dropdownNode;
+                }
+            }), _extends3), !preventKeyAction && {
+                onKeyDown: callAllEventHandlers(onKeyDown, dropdownHandleKeyDown),
+                onClick: callAllEventHandlers(onClick, dropdownHandleClick)
+            }, rest);
+        }, [dispatch2, dropdownKeyDownHandlers, setGetterPropCallInfo]);
+        var addSelectedItem = React.useCallback(function(selectedItem) {
+            dispatch2({
+                type: FunctionAddSelectedItem,
+                selectedItem
+            });
+        }, [dispatch2]);
+        var removeSelectedItem = React.useCallback(function(selectedItem) {
+            dispatch2({
+                type: FunctionRemoveSelectedItem,
+                selectedItem
+            });
+        }, [dispatch2]);
+        var setSelectedItems = React.useCallback(function(newSelectedItems) {
+            dispatch2({
+                type: FunctionSetSelectedItems,
+                selectedItems: newSelectedItems
+            });
+        }, [dispatch2]);
+        var setActiveIndex = React.useCallback(function(newActiveIndex) {
+            dispatch2({
+                type: FunctionSetActiveIndex,
+                activeIndex: newActiveIndex
+            });
+        }, [dispatch2]);
+        var reset2 = React.useCallback(function() {
+            dispatch2({
+                type: FunctionReset
+            });
+        }, [dispatch2]);
+        return {
+            getSelectedItemProps,
+            getDropdownProps,
+            addSelectedItem,
+            removeSelectedItem,
+            setSelectedItems,
+            setActiveIndex,
+            reset: reset2,
+            selectedItems,
+            activeIndex
+        };
+    }
+    var fromEntries$1 = function fromEntries2(entries) {
+        return entries.reduce(function(acc, _ref2) {
+            var key = _ref2[0],
+                value = _ref2[1];
+            acc[key] = value;
+            return acc;
+        }, {});
+    };
+    var useIsomorphicLayoutEffect$2 = typeof window !== "undefined" && window.document && window.document.createElement ? React__namespace.useLayoutEffect : React__namespace.useEffect;
 
-    div {
-        flex: 1 1 auto;
+    function getBoundingClientRect(element2) {
+        var rect = element2.getBoundingClientRect();
+        return {
+            width: rect.width,
+            height: rect.height,
+            top: rect.top,
+            right: rect.right,
+            bottom: rect.bottom,
+            left: rect.left,
+            x: rect.left,
+            y: rect.top
+        };
     }
 
-    input {
-        height: 100%;
+    function getWindow(node2) {
+        if (node2.toString() !== "[object Window]") {
+            var ownerDocument = node2.ownerDocument;
+            return ownerDocument ? ownerDocument.defaultView : window;
+        }
+        return node2;
+    }
 
-        ::before {
-            content: ' ';
+    function getWindowScroll(node2) {
+        var win = getWindow(node2);
+        var scrollLeft = win.pageXOffset;
+        var scrollTop = win.pageYOffset;
+        return {
+            scrollLeft,
+            scrollTop
+        };
+    }
 
-            position: sticky;
-            top: 0;
-            left: 0;
+    function isElement$1(node2) {
+        var OwnElement = getWindow(node2).Element;
+        return node2 instanceof OwnElement || node2 instanceof Element;
+    }
 
-            width: ${(props) => !props.firstInputVisible ? "8px" : 0};
-            height: 2.5rem;
+    function isHTMLElement(node2) {
+        var OwnElement = getWindow(node2).HTMLElement;
+        return node2 instanceof OwnElement || node2 instanceof HTMLElement;
+    }
+
+    function getHTMLElementScroll(element2) {
+        return {
+            scrollLeft: element2.scrollLeft,
+            scrollTop: element2.scrollTop
+        };
+    }
+
+    function getNodeScroll(node2) {
+        if (node2 === getWindow(node2) || !isHTMLElement(node2)) {
+            return getWindowScroll(node2);
+        } else {
+            return getHTMLElementScroll(node2);
         }
+    }
 
-        ::after {
-            content: '';
+    function getNodeName(element2) {
+        return element2 ? (element2.nodeName || "").toLowerCase() : null;
+    }
 
-            position: sticky;
-            top: 0;
-            right: 0;
+    function getDocumentElement(element2) {
+        return (isElement$1(element2) ? element2.ownerDocument : element2.document).documentElement;
+    }
 
-            width: ${(props) => !props.lastInputVisible ? "8px" : 0};
-            height: 2.5rem;
-        }
+    function getWindowScrollBarX(element2) {
+        return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
     }
-`;
-    const SliderInputs = ({
-        getErrorMsg,
-        sliderValues,
-        setSliderValues,
-        domain: domain2
-    }) => {
-        const firstInputRef = React.useRef();
-        const lastInputRef = React.useRef();
-        const firstInputVisible = useIntersectionObserver(firstInputRef, "0px", 0.5);
-        const lastInputVisible = useIntersectionObserver(lastInputRef, "0px", 0.5);
-        const onInputChange = React.useCallback((value, index2) => {
-            setSliderValues((currSliderValues) => {
-                const updatedValues = [...currSliderValues];
-                updatedValues[index2] = Number.isNaN(value) ? domain2[0] : value;
-                return updatedValues;
-            });
-        }, [domain2, setSliderValues]);
-        return jsxRuntime.exports.jsx(InputWrapper$1, {
-            firstInputVisible,
-            lastInputVisible,
-            children: sliderValues.map((value, index2) => {
-                let inputRef = null;
-                if (index2 === 0) {
-                    inputRef = firstInputRef;
-                }
-                if (index2 === sliderValues.length - 1) {
-                    inputRef = lastInputRef;
-                }
-                return jsxRuntime.exports.jsx("div", {
-                    ref: inputRef,
-                    children: jsxRuntime.exports.jsx(NumericInput, {
-                        errorMsg: getErrorMsg(value, index2),
-                        onChange: (val) => onInputChange(val, index2),
-                        style: {
-                            height: "2rem",
-                            margin: "0.25rem 0.5rem"
-                        },
-                        value
-                    })
-                }, index2);
-            })
-        });
-    };
 
-    function computeStep(difference) {
-        const log3 = Math.floor(Math.log10(difference));
-        const step2 = Math.pow(10, Math.floor(log3)) / 10;
-        if (log3 < 0) {
-            const precisionString = step2.toFixed(Math.abs(log3) + 1);
-            return parseFloat(precisionString);
-        }
-        return step2;
+    function getComputedStyle$1(element2) {
+        return getWindow(element2).getComputedStyle(element2);
     }
 
-    function mapToClosestStep(value, step2) {
-        const stepsNumber = parseFloat((value / step2).toFixed(1));
-        const mappedRaw = Math.floor(stepsNumber) * step2;
-        const fractionDigits = Math.abs(Math.floor(Math.log10(step2)));
-        return parseFloat(mappedRaw.toFixed(fractionDigits));
+    function isScrollParent(element2) {
+        var _getComputedStyle = getComputedStyle$1(element2),
+            overflow = _getComputedStyle.overflow,
+            overflowX = _getComputedStyle.overflowX,
+            overflowY = _getComputedStyle.overflowY;
+        return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
     }
-    const SliderWrapper = styled__default.default.div`
-    display: flex;
-    width: 100%;
-`;
-    const SliderInner = styled__default.default.div`
-    overflow: hidden;
-    display: flex;
-    width: 100%;
-`;
-    const StyledSlider$1 = styled__default.default(Slider$2)`
-    position: relative;
 
-    display: inline-flex;
-    flex-direction: column;
-    justify-content: center;
+    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
+        if (isFixed === void 0) {
+            isFixed = false;
+        }
+        var documentElement = getDocumentElement(offsetParent);
+        var rect = getBoundingClientRect(elementOrVirtualElement);
+        var scroll = {
+            scrollLeft: 0,
+            scrollTop: 0
+        };
+        var offsets = {
+            x: 0,
+            y: 0
+        };
+        if (!isFixed) {
+            if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
+                scroll = getNodeScroll(offsetParent);
+            }
+            if (isHTMLElement(offsetParent)) {
+                offsets = getBoundingClientRect(offsetParent);
+                offsets.x += offsetParent.clientLeft;
+                offsets.y += offsetParent.clientTop;
+            } else if (documentElement) {
+                offsets.x = getWindowScrollBarX(documentElement);
+            }
+        }
+        return {
+            x: rect.left + scroll.scrollLeft - offsets.x,
+            y: rect.top + scroll.scrollTop - offsets.y,
+            width: rect.width,
+            height: rect.height
+        };
+    }
 
-    width: 100%;
-    height: 3rem;
-    margin: 0 1rem;
-`;
-    const SliderRail = styled__default.default.div`
-    cursor: pointer;
+    function getLayoutRect(element2) {
+        return {
+            x: element2.offsetLeft,
+            y: element2.offsetTop,
+            width: element2.offsetWidth,
+            height: element2.offsetHeight
+        };
+    }
 
-    width: 100%;
-    height: 0.25rem;
-    padding: 0 0.3rem;
+    function getParentNode(element2) {
+        if (getNodeName(element2) === "html") {
+            return element2;
+        }
+        return element2.assignedSlot || element2.parentNode || element2.host || getDocumentElement(element2);
+    }
 
-    background-color: ${(props) => props.theme.colors.grey2};
-    border-radius: 0.125rem;
-`;
-    const Handle = styled__default.default.span`
-    cursor: pointer;
+    function getScrollParent(node2) {
+        if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
+            return node2.ownerDocument.body;
+        }
+        if (isHTMLElement(node2) && isScrollParent(node2)) {
+            return node2;
+        }
+        return getScrollParent(getParentNode(node2));
+    }
 
-    position: absolute;
-    z-index: 2;
+    function listScrollParents(element2, list2) {
+        if (list2 === void 0) {
+            list2 = [];
+        }
+        var scrollParent = getScrollParent(element2);
+        var isBody = getNodeName(scrollParent) === "body";
+        var win = getWindow(scrollParent);
+        var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
+        var updatedList = list2.concat(target);
+        return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
+    }
 
-    width: 1rem;
-    height: 1rem;
-    margin-top: ${(props) => props.hasTicks ? "-0.5rem" : "0"};
-    margin-left: -0.6rem;
+    function isTableElement(element2) {
+        return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
+    }
 
-    background-color: ${(props) => props.theme.colors.primary};
-    border-radius: 50%;
-`;
-    const Track = styled__default.default.span`
-    position: absolute;
+    function getTrueOffsetParent(element2) {
+        if (!isHTMLElement(element2) || getComputedStyle$1(element2).position === "fixed") {
+            return null;
+        }
+        return element2.offsetParent;
+    }
 
-    height: 0.25rem;
-    margin-top: ${(props) => props.hasTicks ? "-0.5rem" : "0"};
+    function getOffsetParent(element2) {
+        var window2 = getWindow(element2);
+        var offsetParent = getTrueOffsetParent(element2);
+        while (offsetParent && isTableElement(offsetParent)) {
+            offsetParent = getTrueOffsetParent(offsetParent);
+        }
+        if (offsetParent && getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static") {
+            return window2;
+        }
+        return offsetParent || window2;
+    }
+    var top$1 = "top";
+    var bottom = "bottom";
+    var right = "right";
+    var left = "left";
+    var auto = "auto";
+    var basePlacements = [top$1, bottom, right, left];
+    var start$1 = "start";
+    var end = "end";
+    var clippingParents = "clippingParents";
+    var viewport = "viewport";
+    var popper = "popper";
+    var reference = "reference";
+    var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
+        return acc.concat([placement + "-" + start$1, placement + "-" + end]);
+    }, []);
+    var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
+        return acc.concat([placement, placement + "-" + start$1, placement + "-" + end]);
+    }, []);
+    var beforeRead = "beforeRead";
+    var read = "read";
+    var afterRead = "afterRead";
+    var beforeMain = "beforeMain";
+    var main = "main";
+    var afterMain = "afterMain";
+    var beforeWrite = "beforeWrite";
+    var write = "write";
+    var afterWrite = "afterWrite";
+    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
 
-    background-color: ${(props) => props.theme.colors.primary};
-    border-radius: 0.125rem;
-`;
-    const TrackLabel = styled__default.default.span`
-    position: absolute;
-    z-index: 1;
-    top: -0.3rem;
-    color: ${(props) => props.theme.colors.grey6};
-`;
-    const LabelInner = styled__default.default.span`
-    margin-left: -50%;
-    line-height: 1.5rem;
-`;
-    const SliderTicks = styled__default.default.div`
-    position: relative;
-    margin-top: 0.5rem;
-`;
-    const Tick = styled__default.default.span`
-    position: absolute;
-    font-size: 0.875rem;
-    color: ${(props) => props.theme.colors.grey6};
+    function order(modifiers2) {
+        var map2 = /* @__PURE__ */ new Map();
+        var visited = /* @__PURE__ */ new Set();
+        var result = [];
+        modifiers2.forEach(function(modifier) {
+            map2.set(modifier.name, modifier);
+        });
 
-    &${(props) => props.showLine ? "" : ":not(:first-child):not(:last-child)"}::before {
-        content: '';
+        function sort(modifier) {
+            visited.add(modifier.name);
+            var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
+            requires.forEach(function(dep) {
+                if (!visited.has(dep)) {
+                    var depModifier = map2.get(dep);
+                    if (depModifier) {
+                        sort(depModifier);
+                    }
+                }
+            });
+            result.push(modifier);
+        }
+        modifiers2.forEach(function(modifier) {
+            if (!visited.has(modifier.name)) {
+                sort(modifier);
+            }
+        });
+        return result;
+    }
 
-        position: absolute;
-        z-index: 1;
-        left: 50%;
+    function orderModifiers(modifiers2) {
+        var orderedModifiers = order(modifiers2);
+        return modifierPhases.reduce(function(acc, phase) {
+            return acc.concat(orderedModifiers.filter(function(modifier) {
+                return modifier.phase === phase;
+            }));
+        }, []);
+    }
 
-        display: block;
+    function debounce$1(fn2) {
+        var pending;
+        return function() {
+            if (!pending) {
+                pending = new Promise(function(resolve2) {
+                    Promise.resolve().then(function() {
+                        pending = void 0;
+                        resolve2(fn2());
+                    });
+                });
+            }
+            return pending;
+        };
+    }
 
-        width: 0.125rem;
-        height: 0.125rem;
-        margin-top: -0.685rem;
+    function getBasePlacement(placement) {
+        return placement.split("-")[0];
+    }
 
-        background-color: ${(props) => props.theme.colors.grey3};
-        border-radius: 50%;
+    function mergeByName(modifiers2) {
+        var merged = modifiers2.reduce(function(merged2, current2) {
+            var existing = merged2[current2.name];
+            merged2[current2.name] = existing ? Object.assign({}, existing, {}, current2, {
+                options: Object.assign({}, existing.options, {}, current2.options),
+                data: Object.assign({}, existing.data, {}, current2.data)
+            }) : current2;
+            return merged2;
+        }, {});
+        return Object.keys(merged).map(function(key) {
+            return merged[key];
+        });
     }
-`;
-    const SwapButtonWrapper = styled__default.default.div`
-    display: flex;
-    height: fit-content;
-    margin-top: 0.3rem;
-`;
+    var DEFAULT_OPTIONS$1 = {
+        placement: "bottom",
+        modifiers: [],
+        strategy: "absolute"
+    };
 
-    function getTickTransform(idx, length) {
-        if (idx === 0) {
-            return "translateX(-0.7rem)";
+    function areValidElements() {
+        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+            args[_key] = arguments[_key];
         }
-        return idx === length - 1 ? "translateX(-100%) translateX(0.7rem)" : "translateX(-50%)";
+        return !args.some(function(element2) {
+            return !(element2 && typeof element2.getBoundingClientRect === "function");
+        });
     }
 
-    function BaseSlider({
-        domain: domain2,
-        getValueLabel,
-        initialValue,
-        onChange: onChange2,
-        step: step2,
-        style: style2,
-        ticks: ticks2 = 5,
-        trackLabels,
-        trackToStart = true,
-        trackToEnd = false,
-        disableInputAlternative = false,
-        values,
-        className
-    }) {
-        const adjustedStep = React.useMemo(() => {
-            if (step2) {
-                return step2;
+    function popperGenerator(generatorOptions) {
+        if (generatorOptions === void 0) {
+            generatorOptions = {};
+        }
+        var _generatorOptions = generatorOptions,
+            _generatorOptions$def = _generatorOptions.defaultModifiers,
+            defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
+            _generatorOptions$def2 = _generatorOptions.defaultOptions,
+            defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS$1 : _generatorOptions$def2;
+        return function createPopper2(reference2, popper2, options) {
+            if (options === void 0) {
+                options = defaultOptions2;
             }
-            return computeStep(domain2[1] - domain2[0]);
-        }, [domain2, step2]);
-        const [sliderValues, setSliderValues] = React.useState((values === null || values === void 0 ? void 0 : values.map((v2) => mapToClosestStep(v2, adjustedStep))) || (initialValue === null || initialValue === void 0 ? void 0 : initialValue.map((v2) => mapToClosestStep(v2, adjustedStep))) || [domain2[0]]);
-        const currSliderValues = React.useRef(sliderValues);
-        currSliderValues.current = sliderValues;
-        const isFirstRender = React.useRef(true);
-        React.useEffect(() => {
-            if (values !== void 0) {
-                const mappedValues = values.map((v2) => mapToClosestStep(v2, adjustedStep));
-                if (!isEqual_1(mappedValues, currSliderValues.current)) {
-                    setSliderValues(mappedValues);
+            var state = {
+                placement: "bottom",
+                orderedModifiers: [],
+                options: Object.assign({}, DEFAULT_OPTIONS$1, {}, defaultOptions2),
+                modifiersData: {},
+                elements: {
+                    reference: reference2,
+                    popper: popper2
+                },
+                attributes: {},
+                styles: {}
+            };
+            var effectCleanupFns = [];
+            var isDestroyed = false;
+            var instance2 = {
+                state,
+                setOptions: function setOptions2(options2) {
+                    cleanupModifierEffects();
+                    state.options = Object.assign({}, defaultOptions2, {}, state.options, {}, options2);
+                    state.scrollParents = {
+                        reference: isElement$1(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
+                        popper: listScrollParents(popper2)
+                    };
+                    var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
+                    state.orderedModifiers = orderedModifiers.filter(function(m2) {
+                        return m2.enabled;
+                    });
+                    runModifierEffects();
+                    return instance2.update();
+                },
+                forceUpdate: function forceUpdate() {
+                    if (isDestroyed) {
+                        return;
+                    }
+                    var _state$elements = state.elements,
+                        reference3 = _state$elements.reference,
+                        popper3 = _state$elements.popper;
+                    if (!areValidElements(reference3, popper3)) {
+                        return;
+                    }
+                    state.rects = {
+                        reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
+                        popper: getLayoutRect(popper3)
+                    };
+                    state.reset = false;
+                    state.placement = state.options.placement;
+                    state.orderedModifiers.forEach(function(modifier) {
+                        return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
+                    });
+                    for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
+                        if (state.reset === true) {
+                            state.reset = false;
+                            index2 = -1;
+                            continue;
+                        }
+                        var _state$orderedModifie = state.orderedModifiers[index2],
+                            fn2 = _state$orderedModifie.fn,
+                            _state$orderedModifie2 = _state$orderedModifie.options,
+                            _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
+                            name2 = _state$orderedModifie.name;
+                        if (typeof fn2 === "function") {
+                            state = fn2({
+                                state,
+                                options: _options,
+                                name: name2,
+                                instance: instance2
+                            }) || state;
+                        }
+                    }
+                },
+                update: debounce$1(function() {
+                    return new Promise(function(resolve2) {
+                        instance2.forceUpdate();
+                        resolve2(state);
+                    });
+                }),
+                destroy: function destroy() {
+                    cleanupModifierEffects();
+                    isDestroyed = true;
                 }
+            };
+            if (!areValidElements(reference2, popper2)) {
+                return instance2;
             }
-        }, [adjustedStep, values]);
-        const [showInputs, setShowInputs] = React.useState(false);
-        const precision2 = React.useMemo(() => Math.floor(adjustedStep) === adjustedStep ? 0 : adjustedStep.toString().split(".")[1].length || 0, [adjustedStep]);
-        const getErrorMsg = React.useCallback((value, index2) => {
-            if (Number.isNaN(value)) {
-                return "Value should not be left blank";
+            instance2.setOptions(options).then(function(state2) {
+                if (!isDestroyed && options.onFirstUpdate) {
+                    options.onFirstUpdate(state2);
+                }
+            });
+
+            function runModifierEffects() {
+                state.orderedModifiers.forEach(function(_ref3) {
+                    var name2 = _ref3.name,
+                        _ref3$options = _ref3.options,
+                        options2 = _ref3$options === void 0 ? {} : _ref3$options,
+                        effect2 = _ref3.effect;
+                    if (typeof effect2 === "function") {
+                        var cleanupFn = effect2({
+                            state,
+                            name: name2,
+                            instance: instance2,
+                            options: options2
+                        });
+                        var noopFn = function noopFn2() {};
+                        effectCleanupFns.push(cleanupFn || noopFn);
+                    }
+                });
             }
-            if (value < domain2[0] || value > domain2[1]) {
-                return `Value out of allowed range of ${domain2[0]} - ${domain2[1]}`;
+
+            function cleanupModifierEffects() {
+                effectCleanupFns.forEach(function(fn2) {
+                    return fn2();
+                });
+                effectCleanupFns = [];
             }
-            if (index2 > 0 && value < sliderValues[index2 - 1] || index2 < sliderValues.length - 1 && value > sliderValues[index2 + 1]) {
-                return "Values have to be in ascending order";
+            return instance2;
+        };
+    }
+    var passive = {
+        passive: true
+    };
+
+    function effect$2(_ref2) {
+        var state = _ref2.state,
+            instance2 = _ref2.instance,
+            options = _ref2.options;
+        var _options$scroll = options.scroll,
+            scroll = _options$scroll === void 0 ? true : _options$scroll,
+            _options$resize = options.resize,
+            resize = _options$resize === void 0 ? true : _options$resize;
+        var window2 = getWindow(state.elements.popper);
+        var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
+        if (scroll) {
+            scrollParents.forEach(function(scrollParent) {
+                scrollParent.addEventListener("scroll", instance2.update, passive);
+            });
+        }
+        if (resize) {
+            window2.addEventListener("resize", instance2.update, passive);
+        }
+        return function() {
+            if (scroll) {
+                scrollParents.forEach(function(scrollParent) {
+                    scrollParent.removeEventListener("scroll", instance2.update, passive);
+                });
             }
-            return "";
-        }, [domain2, sliderValues]);
-        const validateValues = React.useCallback((value) => {
-            for (let index2 = 0; index2 < value.length; index2++) {
-                if (getErrorMsg(value[index2], index2) !== "") {
-                    return false;
-                }
+            if (resize) {
+                window2.removeEventListener("resize", instance2.update, passive);
             }
-            return true;
-        }, [getErrorMsg]);
-        React.useEffect(
-            () => {
-                if (isFirstRender.current) {
-                    isFirstRender.current = false;
-                    return;
-                }
-                if (validateValues(sliderValues)) {
-                    const formattedValues = sliderValues.map(getValueLabel);
-                    onChange2 === null || onChange2 === void 0 ? void 0 : onChange2(formattedValues);
-                }
-            },
-            useDeepCompare([sliderValues])
-        );
-        const onSliderChange = React.useCallback((value) => {
-            setSliderValues(value.map((val) => parseFloat(val.toFixed(precision2))));
-        }, [precision2]);
-        const tickProps = typeof ticks2 === "number" ? {
-            count: ticks2
-        } : {
-            values: ticks2
         };
-        return jsxRuntime.exports.jsxs(SliderWrapper, {
-            className,
-            children: [jsxRuntime.exports.jsx(SliderInner, {
-                children: showInputs ? jsxRuntime.exports.jsx(SliderInputs, {
-                    domain: domain2,
-                    getErrorMsg,
-                    setSliderValues,
-                    sliderValues
-                }) : jsxRuntime.exports.jsxs(StyledSlider$1, {
-                    domain: domain2,
-                    onChange: onSliderChange,
-                    rootStyle: style2,
-                    step: adjustedStep,
-                    values: sliderValues,
-                    children: [jsxRuntime.exports.jsx(Rail, {
-                        children: ({
-                            getRailProps
-                        }) => jsxRuntime.exports.jsx(SliderRail, Object.assign({}, getRailProps(), {
-                            "data-testid": "rail"
-                        }))
-                    }), jsxRuntime.exports.jsx(Handles, {
-                        children: ({
-                            handles,
-                            getHandleProps
-                        }) => jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, {
-                            children: handles.map((handle2, idx) => jsxRuntime.exports.jsx(Tooltip$1, {
-                                content: getValueLabel(handle2.value),
-                                hideOnClick: false,
-                                interactive: true,
-                                placement: "top",
-                                children: jsxRuntime.exports.jsx(Handle, Object.assign({}, getHandleProps(handle2.id), {
-                                    "data-testid": `handle-${idx}`,
-                                    hasTicks: !!ticks2,
-                                    style: {
-                                        left: `${handle2.percent}%`
-                                    }
-                                }))
-                            }, handle2.id))
-                        })
-                    }), jsxRuntime.exports.jsx(Tracks, {
-                        left: trackToStart,
-                        right: trackToEnd,
-                        children: ({
-                            tracks,
-                            getTrackProps
-                        }) => jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, {
-                            children: tracks.map(({
-                                id: id2,
-                                source,
-                                target
-                            }, idx) => jsxRuntime.exports.jsxs(React.Fragment, {
-                                children: [jsxRuntime.exports.jsx(Track, Object.assign({
-                                    hasTicks: !!ticks2
-                                }, getTrackProps(), {
-                                    "data-testid": `track-${idx}`,
-                                    style: {
-                                        left: `${source.percent}%`,
-                                        width: `${target.percent - source.percent}%`
-                                    }
-                                }), id2), trackLabels && trackLabels.length > 0 && jsxRuntime.exports.jsx(TrackLabel, {
-                                    "data-testid": `track-label-${idx}`,
-                                    style: {
-                                        display: target.percent - source.percent === 0 ? "none" : "flex",
-                                        left: `${(target.percent - source.percent) / 2 + source.percent}%`
-                                    },
-                                    children: jsxRuntime.exports.jsx(LabelInner, {
-                                        children: trackLabels[idx]
-                                    })
-                                }, `label_${id2}`)]
-                            }, id2))
-                        })
-                    }), ticks2 && jsxRuntime.exports.jsx(Ticks, Object.assign({}, tickProps, {
-                        children: ({
-                            ticks: sliderTicks
-                        }) => jsxRuntime.exports.jsx(SliderTicks, {
-                            children: sliderTicks.map((tick, idx) => jsxRuntime.exports.jsx(Tick, {
-                                "data-testid": `tick-${idx}`,
-                                showLine: tick.value !== domain2[0] && tick.value !== domain2[1],
-                                style: {
-                                    left: `${tick.percent}%`,
-                                    transform: getTickTransform(idx, sliderTicks.length)
-                                },
-                                children: getValueLabel(tick.value)
-                            }, tick.id))
-                        })
-                    }))]
-                })
-            }), !disableInputAlternative && sliderValues && jsxRuntime.exports.jsx(Tooltip$1, {
-                content: showInputs ? "Use Slider?" : "Use Input Alternative?",
-                placement: "top",
-                children: jsxRuntime.exports.jsx(SwapButtonWrapper, {
-                    children: jsxRuntime.exports.jsx(SwapHorizontal, {
-                        asButton: true,
-                        onClick: () => setShowInputs(!showInputs),
-                        size: "2x"
-                    })
-                })
-            })]
-        });
     }
+    const eventListeners = {
+        name: "eventListeners",
+        enabled: true,
+        phase: "write",
+        fn: function fn2() {},
+        effect: effect$2,
+        data: {}
+    };
 
-    function Slider$1(props) {
-        return jsxRuntime.exports.jsx(BaseSlider, Object.assign({
-            disableInputAlternative: props.disableInputAlternative
-        }, props, {
-            getValueLabel: (val) => round_1(val, 4)
-        }));
+    function getVariation(placement) {
+        return placement.split("-")[1];
     }
 
-    function Sun() {
-        const theme2 = useClTheme();
-        return jsxRuntime.exports.jsx("div", {
-            style: {
-                display: "flex",
-                height: "1rem",
-                width: "1rem"
-            },
-            children: jsxRuntime.exports.jsxs("svg", {
-                fill: "none",
-                viewBox: "0 0 200 200",
-                xmlns: "http://www.w3.org/2000/svg",
-                children: [jsxRuntime.exports.jsx("path", {
-                    d: "M138 100C138 120.987 120.987 138 100 138C79.0132 138 62 120.987 62 100C62 79.0132 79.0132 62 100 62C120.987 62 138 79.0132 138 100Z",
-                    fill: theme2.colors.background
-                }), jsxRuntime.exports.jsx("path", {
-                    d: "M87 13C87 5.8203 92.8203 0 100 0C107.18 0 113 5.8203 113 13V31C113 38.1797 107.18 44 100 44C92.8203 44 87 38.1797 87 31V13Z",
-                    fill: theme2.colors.background
-                }), jsxRuntime.exports.jsx("path", {
-                    d: "M87 169C87 161.82 92.8203 156 100 156C107.18 156 113 161.82 113 169V187C113 194.18 107.18 200 100 200C92.8203 200 87 194.18 87 187V169Z",
-                    fill: theme2.colors.background
-                }), jsxRuntime.exports.jsx("path", {
-                    d: "M169 113C161.82 113 156 107.18 156 100C156 92.8203 161.82 87 169 87H187C194.18 87 200 92.8203 200 100C200 107.18 194.18 113 187 113H169Z",
-                    fill: theme2.colors.background
-                }), jsxRuntime.exports.jsx("path", {
-                    d: "M13 113C5.8203 113 0 107.18 0 100C0 92.8203 5.8203 87 13 87H31C38.1797 87 44 92.8203 44 100C44 107.18 38.1797 113 31 113H13Z",
-                    fill: theme2.colors.background
-                }), jsxRuntime.exports.jsx("path", {
-                    d: "M28.1924 46.5772C23.1156 41.5003 23.1156 33.2692 28.1924 28.1924C33.2692 23.1156 41.5003 23.1156 46.5772 28.1924L59.3051 40.9203C64.3819 45.9971 64.3819 54.2283 59.3051 59.3051C54.2283 64.3819 45.9971 64.3819 40.9203 59.3051L28.1924 46.5772Z",
-                    fill: theme2.colors.background
-                }), jsxRuntime.exports.jsx("path", {
-                    d: "M159.579 59.3051C154.502 64.3819 146.271 64.3819 141.194 59.3051C136.118 54.2283 136.118 45.9972 141.194 40.9203L153.922 28.1924C158.999 23.1156 167.23 23.1156 172.307 28.1924C177.384 33.2692 177.384 41.5004 172.307 46.5772L159.579 59.3051Z",
-                    fill: theme2.colors.background
-                }), jsxRuntime.exports.jsx("path", {
-                    d: "M141.192 159.577C136.116 154.5 136.116 146.269 141.192 141.192C146.269 136.116 154.5 136.116 159.577 141.192L172.305 153.92C177.382 158.997 177.382 167.228 172.305 172.305C167.228 177.382 158.997 177.382 153.92 172.305L141.192 159.577Z",
-                    fill: theme2.colors.background
-                }), jsxRuntime.exports.jsx("path", {
-                    d: "M40.9209 141.192C45.9977 136.116 54.2289 136.116 59.3057 141.192C64.3825 146.269 64.3825 154.5 59.3057 159.577L46.5777 172.305C41.5009 177.382 33.2698 177.382 28.193 172.305C23.1162 167.228 23.1162 158.997 28.193 153.92L40.9209 141.192Z",
-                    fill: theme2.colors.background
-                })]
-            })
-        });
+    function getMainAxisFromPlacement(placement) {
+        return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
     }
-    const SwitchWrapper = styled__default.default.div`
-    cursor: pointer;
-
-    position: relative;
-
-    display: flex;
-    align-items: center;
-    justify-content: ${(props) => props.enabled ? "flex-start" : "flex-end"};
-
-    width: max-content;
-    height: 1.5rem;
-    padding: 0;
-    padding-right: ${(props) => props.enabled ? "1.75rem" : "0.5rem"};
-    padding-left: ${(props) => props.enabled ? "0.5rem" : "1.75rem"};
-
-    font-size: ${(props) => props.theme.font.size};
-    color: ${(props) => props.theme.colors.blue1};
-
-    background-color: ${(props) => props.enabled ? props.theme.colors.primary : props.theme.colors.secondary};
-    border-radius: 12px;
 
-    svg {
-        color: ${(props) => props.theme.colors.blue1};
+    function computeOffsets(_ref2) {
+        var reference2 = _ref2.reference,
+            element2 = _ref2.element,
+            placement = _ref2.placement;
+        var basePlacement = placement ? getBasePlacement(placement) : null;
+        var variation = placement ? getVariation(placement) : null;
+        var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
+        var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
+        var offsets;
+        switch (basePlacement) {
+            case top$1:
+                offsets = {
+                    x: commonX,
+                    y: reference2.y - element2.height
+                };
+                break;
+            case bottom:
+                offsets = {
+                    x: commonX,
+                    y: reference2.y + reference2.height
+                };
+                break;
+            case right:
+                offsets = {
+                    x: reference2.x + reference2.width,
+                    y: commonY
+                };
+                break;
+            case left:
+                offsets = {
+                    x: reference2.x - element2.width,
+                    y: commonY
+                };
+                break;
+            default:
+                offsets = {
+                    x: reference2.x,
+                    y: reference2.y
+                };
+        }
+        var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
+        if (mainAxis != null) {
+            var len = mainAxis === "y" ? "height" : "width";
+            switch (variation) {
+                case start$1:
+                    offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference2[len] / 2 - element2[len] / 2);
+                    break;
+                case end:
+                    offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference2[len] / 2 - element2[len] / 2);
+                    break;
+            }
+        }
+        return offsets;
     }
-`;
-    const SwitchHandle = styled__default.default.span`
-    position: absolute;
-    top: 2px;
-    left: ${(props) => props.enabled ? "calc(100% - 1.375rem)" : "0.125rem"};
-
-    display: inline-block;
 
-    width: 1.25rem;
-    height: 1.25rem;
-
-    background-color: ${(props) => props.theme.colors.blue1};
-    border-radius: 0.625rem;
+    function popperOffsets(_ref2) {
+        var state = _ref2.state,
+            name2 = _ref2.name;
+        state.modifiersData[name2] = computeOffsets({
+            reference: state.rects.reference,
+            element: state.rects.popper,
+            strategy: "absolute",
+            placement: state.placement
+        });
+    }
+    const popperOffsets$1 = {
+        name: "popperOffsets",
+        enabled: true,
+        phase: "read",
+        fn: popperOffsets,
+        data: {}
+    };
+    var unsetSides = {
+        top: "auto",
+        right: "auto",
+        bottom: "auto",
+        left: "auto"
+    };
 
-    transition: left 100ms linear;
-`;
+    function roundOffsets(_ref2) {
+        var x2 = _ref2.x,
+            y2 = _ref2.y;
+        var win = window;
+        var dpr = win.devicePixelRatio || 1;
+        return {
+            x: Math.round(x2 * dpr) / dpr || 0,
+            y: Math.round(y2 * dpr) / dpr || 0
+        };
+    }
 
-    function Switch$1({
-        className,
-        initialValue = false,
-        labels = {
-            off: "OFF",
-            on: "ON"
-        },
-        lightDark = false,
-        onChange: onChange2,
-        style: style2,
-        value
-    }, ref2) {
-        const [enabled, setEnabled] = React.useState(value || initialValue);
-        const labelIconToShow = React.useMemo(() => {
-            if (lightDark) {
-                return enabled ? jsxRuntime.exports.jsx(Sun, {}) : jsxRuntime.exports.jsx(Moon, {});
+    function mapToStyles(_ref2) {
+        var _Object$assign2;
+        var popper2 = _ref2.popper,
+            popperRect = _ref2.popperRect,
+            placement = _ref2.placement,
+            offsets = _ref2.offsets,
+            position2 = _ref2.position,
+            gpuAcceleration = _ref2.gpuAcceleration,
+            adaptive = _ref2.adaptive;
+        var _roundOffsets = roundOffsets(offsets),
+            x2 = _roundOffsets.x,
+            y2 = _roundOffsets.y;
+        var hasX = offsets.hasOwnProperty("x");
+        var hasY = offsets.hasOwnProperty("y");
+        var sideX = left;
+        var sideY = top$1;
+        var win = window;
+        if (adaptive) {
+            var offsetParent = getOffsetParent(popper2);
+            if (offsetParent === getWindow(popper2)) {
+                offsetParent = getDocumentElement(popper2);
             }
-            return enabled ? labels.on : labels.off;
-        }, [labels, lightDark, enabled]);
-        React.useEffect(() => {
-            if (value !== void 0) {
-                setEnabled(value);
+            if (placement === top$1) {
+                sideY = bottom;
+                y2 -= offsetParent.clientHeight - popperRect.height;
+                y2 *= gpuAcceleration ? 1 : -1;
             }
-        }, [value]);
-        const onClick = () => {
-            if (value === void 0) {
-                setEnabled(!enabled);
+            if (placement === left) {
+                sideX = right;
+                x2 -= offsetParent.clientWidth - popperRect.width;
+                x2 *= gpuAcceleration ? 1 : -1;
             }
-            onChange2 === null || onChange2 === void 0 ? void 0 : onChange2(!enabled);
-        };
-        return jsxRuntime.exports.jsxs(SwitchWrapper, {
-            className,
-            "data-testid": "wrapper",
-            enabled,
-            onClick,
-            ref: ref2,
-            style: style2,
-            children: [jsxRuntime.exports.jsx(SwitchHandle, {
-                "data-testid": "handle",
-                enabled
-            }), jsxRuntime.exports.jsx("div", {
-                style: {
-                    userSelect: "none"
-                },
-                children: labelIconToShow
-            })]
-        });
+        }
+        var commonStyles = Object.assign({
+            position: position2
+        }, adaptive && unsetSides);
+        if (gpuAcceleration) {
+            var _Object$assign;
+            return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
+        }
+        return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
     }
-    const UISwitch = React.forwardRef(Switch$1);
-    var safeIsNaN$1 = Number.isNaN || function ponyfill(value) {
-        return typeof value === "number" && value !== value;
-    };
 
-    function isEqual$1(first, second) {
-        if (first === second) {
-            return true;
+    function computeStyles(_ref3) {
+        var state = _ref3.state,
+            options = _ref3.options;
+        var _options$gpuAccelerat = options.gpuAcceleration,
+            gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
+            _options$adaptive = options.adaptive,
+            adaptive = _options$adaptive === void 0 ? true : _options$adaptive;
+        var commonStyles = {
+            placement: getBasePlacement(state.placement),
+            popper: state.elements.popper,
+            popperRect: state.rects.popper,
+            gpuAcceleration
+        };
+        if (state.modifiersData.popperOffsets != null) {
+            state.styles.popper = Object.assign({}, state.styles.popper, {}, mapToStyles(Object.assign({}, commonStyles, {
+                offsets: state.modifiersData.popperOffsets,
+                position: state.options.strategy,
+                adaptive
+            })));
         }
-        if (safeIsNaN$1(first) && safeIsNaN$1(second)) {
-            return true;
+        if (state.modifiersData.arrow != null) {
+            state.styles.arrow = Object.assign({}, state.styles.arrow, {}, mapToStyles(Object.assign({}, commonStyles, {
+                offsets: state.modifiersData.arrow,
+                position: "absolute",
+                adaptive: false
+            })));
         }
-        return false;
+        state.attributes.popper = Object.assign({}, state.attributes.popper, {
+            "data-popper-placement": state.placement
+        });
     }
+    const computeStyles$1 = {
+        name: "computeStyles",
+        enabled: true,
+        phase: "beforeWrite",
+        fn: computeStyles,
+        data: {}
+    };
 
-    function areInputsEqual$1(newInputs, lastInputs) {
-        if (newInputs.length !== lastInputs.length) {
-            return false;
-        }
-        for (var i2 = 0; i2 < newInputs.length; i2++) {
-            if (!isEqual$1(newInputs[i2], lastInputs[i2])) {
-                return false;
+    function applyStyles(_ref2) {
+        var state = _ref2.state;
+        Object.keys(state.elements).forEach(function(name2) {
+            var style2 = state.styles[name2] || {};
+            var attributes2 = state.attributes[name2] || {};
+            var element2 = state.elements[name2];
+            if (!isHTMLElement(element2) || !getNodeName(element2)) {
+                return;
             }
-        }
-        return true;
+            Object.assign(element2.style, style2);
+            Object.keys(attributes2).forEach(function(name3) {
+                var value = attributes2[name3];
+                if (value === false) {
+                    element2.removeAttribute(name3);
+                } else {
+                    element2.setAttribute(name3, value === true ? "" : value);
+                }
+            });
+        });
     }
 
-    function memoizeOne$1(resultFn, isEqual2) {
-        if (isEqual2 === void 0) {
-            isEqual2 = areInputsEqual$1;
+    function effect$1(_ref2) {
+        var state = _ref2.state;
+        var initialStyles = {
+            popper: {
+                position: state.options.strategy,
+                left: "0",
+                top: "0",
+                margin: "0"
+            },
+            arrow: {
+                position: "absolute"
+            },
+            reference: {}
+        };
+        Object.assign(state.elements.popper.style, initialStyles.popper);
+        if (state.elements.arrow) {
+            Object.assign(state.elements.arrow.style, initialStyles.arrow);
         }
-        var cache2 = null;
+        return function() {
+            Object.keys(state.elements).forEach(function(name2) {
+                var element2 = state.elements[name2];
+                var attributes2 = state.attributes[name2] || {};
+                var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
+                var style2 = styleProperties.reduce(function(style3, property) {
+                    style3[property] = "";
+                    return style3;
+                }, {});
+                if (!isHTMLElement(element2) || !getNodeName(element2)) {
+                    return;
+                }
+                Object.assign(element2.style, style2);
+                Object.keys(attributes2).forEach(function(attribute) {
+                    element2.removeAttribute(attribute);
+                });
+            });
+        };
+    }
+    const applyStyles$1 = {
+        name: "applyStyles",
+        enabled: true,
+        phase: "write",
+        fn: applyStyles,
+        effect: effect$1,
+        requires: ["computeStyles"]
+    };
 
-        function memoized() {
-            var newArgs = [];
-            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
-                newArgs[_i2] = arguments[_i2];
-            }
-            if (cache2 && cache2.lastThis === this && isEqual2(newArgs, cache2.lastArgs)) {
-                return cache2.lastResult;
-            }
-            var lastResult = resultFn.apply(this, newArgs);
-            cache2 = {
-                lastResult,
-                lastArgs: newArgs,
-                lastThis: this
-            };
-            return lastResult;
-        }
-        memoized.clear = function clear() {
-            cache2 = null;
+    function distanceAndSkiddingToXY(placement, rects, offset2) {
+        var basePlacement = getBasePlacement(placement);
+        var invertDistance = [left, top$1].indexOf(basePlacement) >= 0 ? -1 : 1;
+        var _ref2 = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
+                placement
+            })) : offset2,
+            skidding = _ref2[0],
+            distance = _ref2[1];
+        skidding = skidding || 0;
+        distance = (distance || 0) * invertDistance;
+        return [left, right].indexOf(basePlacement) >= 0 ? {
+            x: distance,
+            y: skidding
+        } : {
+            x: skidding,
+            y: distance
         };
-        return memoized;
     }
-    var reactTable = {
-        exports: {}
+
+    function offset(_ref2) {
+        var state = _ref2.state,
+            options = _ref2.options,
+            name2 = _ref2.name;
+        var _options$offset = options.offset,
+            offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
+        var data2 = placements.reduce(function(acc, placement) {
+            acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
+            return acc;
+        }, {});
+        var _data$state$placement = data2[state.placement],
+            x2 = _data$state$placement.x,
+            y2 = _data$state$placement.y;
+        if (state.modifiersData.popperOffsets != null) {
+            state.modifiersData.popperOffsets.x += x2;
+            state.modifiersData.popperOffsets.y += y2;
+        }
+        state.modifiersData[name2] = data2;
+    }
+    const offset$1 = {
+        name: "offset",
+        enabled: true,
+        phase: "main",
+        requires: ["popperOffsets"],
+        fn: offset
     };
-    var reactTable_production_min = {
-        exports: {}
+    var hash$2 = {
+        left: "right",
+        right: "left",
+        bottom: "top",
+        top: "bottom"
     };
-    (function(module2, exports3) {
-        ! function(e3, t2) {
-            t2(exports3, React__default.default);
-        }(commonjsGlobal, function(e3, t2) {
-            function n2(e4, t3, n3, o3, r3, i3, u3) {
-                try {
-                    var l3 = e4[i3](u3),
-                        s3 = l3.value;
-                } catch (e6) {
-                    return void n3(e6);
-                }
-                l3.done ? t3(s3) : Promise.resolve(s3).then(o3, r3);
-            }
 
-            function o2(e4) {
-                return function() {
-                    var t3 = this,
-                        o3 = arguments;
-                    return new Promise(function(r3, i3) {
-                        var u3 = e4.apply(t3, o3);
+    function getOppositePlacement(placement) {
+        return placement.replace(/left|right|bottom|top/g, function(matched) {
+            return hash$2[matched];
+        });
+    }
+    var hash$1 = {
+        start: "end",
+        end: "start"
+    };
 
-                        function l3(e6) {
-                            n2(u3, r3, i3, l3, s3, "next", e6);
-                        }
+    function getOppositeVariationPlacement(placement) {
+        return placement.replace(/start|end/g, function(matched) {
+            return hash$1[matched];
+        });
+    }
 
-                        function s3(e6) {
-                            n2(u3, r3, i3, l3, s3, "throw", e6);
-                        }
-                        l3(void 0);
-                    });
-                };
-            }
+    function getViewportRect(element2) {
+        var win = getWindow(element2);
+        var visualViewport = win.visualViewport;
+        var width = win.innerWidth;
+        var height = win.innerHeight;
+        if (visualViewport && /iPhone|iPod|iPad/.test(navigator.platform)) {
+            width = visualViewport.width;
+            height = visualViewport.height;
+        }
+        return {
+            width,
+            height,
+            x: 0,
+            y: 0
+        };
+    }
 
-            function r2() {
-                return (r2 = Object.assign || function(e4) {
-                    for (var t3 = 1; t3 < arguments.length; t3++) {
-                        var n3 = arguments[t3];
-                        for (var o3 in n3)
-                            Object.prototype.hasOwnProperty.call(n3, o3) && (e4[o3] = n3[o3]);
-                    }
-                    return e4;
-                }).apply(this, arguments);
-            }
+    function getDocumentRect(element2) {
+        var win = getWindow(element2);
+        var winScroll = getWindowScroll(element2);
+        var documentRect = getCompositeRect(getDocumentElement(element2), win);
+        documentRect.height = Math.max(documentRect.height, win.innerHeight);
+        documentRect.width = Math.max(documentRect.width, win.innerWidth);
+        documentRect.x = -winScroll.scrollLeft;
+        documentRect.y = -winScroll.scrollTop;
+        return documentRect;
+    }
 
-            function i2(e4, t3) {
-                if (null == e4)
-                    return {};
-                var n3, o3, r3 = {},
-                    i3 = Object.keys(e4);
-                for (o3 = 0; o3 < i3.length; o3++)
-                    n3 = i3[o3], t3.indexOf(n3) >= 0 || (r3[n3] = e4[n3]);
-                return r3;
-            }
+    function toNumber$2(cssValue) {
+        return parseFloat(cssValue) || 0;
+    }
 
-            function u2(e4) {
-                var t3 = function(e6, t4) {
-                    if ("object" != typeof e6 || null === e6)
-                        return e6;
-                    var n3 = e6[Symbol.toPrimitive];
-                    if (void 0 !== n3) {
-                        var o3 = n3.call(e6, t4 || "default");
-                        if ("object" != typeof o3)
-                            return o3;
-                        throw new TypeError("@@toPrimitive must return a primitive value.");
-                    }
-                    return ("string" === t4 ? String : Number)(e6);
-                }(e4, "string");
-                return "symbol" == typeof t3 ? t3 : String(t3);
-            }
-            t2 = t2 && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
-            var l2 = {
-                    init: "init"
-                },
-                s2 = function(e4) {
-                    var t3 = e4.value;
-                    return void 0 === t3 ? "" : t3;
-                },
-                a2 = function() {
-                    return t2.createElement(t2.Fragment, null, "\xA0");
-                },
-                c2 = {
-                    Cell: s2,
-                    width: 150,
-                    minWidth: 0,
-                    maxWidth: Number.MAX_SAFE_INTEGER
-                };
+    function getBorders(element2) {
+        var computedStyle = isHTMLElement(element2) ? getComputedStyle$1(element2) : {};
+        return {
+            top: toNumber$2(computedStyle.borderTopWidth),
+            right: toNumber$2(computedStyle.borderRightWidth),
+            bottom: toNumber$2(computedStyle.borderBottomWidth),
+            left: toNumber$2(computedStyle.borderLeftWidth)
+        };
+    }
 
-            function d2() {
-                for (var e4 = arguments.length, t3 = new Array(e4), n3 = 0; n3 < e4; n3++)
-                    t3[n3] = arguments[n3];
-                return t3.reduce(function(e6, t4) {
-                    var n4 = t4.style,
-                        o3 = t4.className;
-                    return e6 = r2({}, e6, {}, i2(t4, ["style", "className"])), n4 && (e6.style = e6.style ? r2({}, e6.style || {}, {}, n4 || {}) : n4), o3 && (e6.className = e6.className ? e6.className + " " + o3 : o3), "" === e6.className && delete e6.className, e6;
-                }, {});
-            }
-            var f2 = function(e4, t3) {
-                    return void 0 === t3 && (t3 = {}),
-                        function(n3) {
-                            return void 0 === n3 && (n3 = {}), [].concat(e4, [n3]).reduce(function(e6, o3) {
-                                return function e7(t4, n4, o4) {
-                                    return "function" == typeof n4 ? e7({}, n4(t4, o4)) : Array.isArray(n4) ? d2.apply(void 0, [t4].concat(n4)) : d2(t4, n4);
-                                }(e6, o3, r2({}, t3, {
-                                    userProps: n3
-                                }));
-                            }, {});
-                        };
-                },
-                p2 = function(e4, t3, n3, o3) {
-                    return void 0 === n3 && (n3 = {}), e4.reduce(function(e6, t4) {
-                        return t4(e6, n3);
-                    }, t3);
-                },
-                g2 = function(e4, t3, n3) {
-                    return void 0 === n3 && (n3 = {}), e4.forEach(function(e6) {
-                        e6(t3, n3);
-                    });
-                };
+    function getDecorations(element2) {
+        var win = getWindow(element2);
+        var borders = getBorders(element2);
+        var isHTML = getNodeName(element2) === "html";
+        var winScrollBarX = getWindowScrollBarX(element2);
+        var x2 = element2.clientWidth + borders.right;
+        var y2 = element2.clientHeight + borders.bottom;
+        if (isHTML && win.innerHeight - element2.clientHeight > 50) {
+            y2 = win.innerHeight - borders.bottom;
+        }
+        return {
+            top: isHTML ? 0 : element2.clientTop,
+            right: element2.clientLeft > borders.left ? borders.right : isHTML ? win.innerWidth - x2 - winScrollBarX : element2.offsetWidth - x2,
+            bottom: isHTML ? win.innerHeight - y2 : element2.offsetHeight - y2,
+            left: isHTML ? winScrollBarX : element2.clientLeft
+        };
+    }
 
-            function v2(e4, t3, n3, o3) {
-                e4.findIndex(function(e6) {
-                    return e6.pluginName === n3;
-                });
-                t3.forEach(function(t4) {
-                    e4.findIndex(function(e6) {
-                        return e6.pluginName === t4;
-                    });
-                });
-            }
+    function contains$1(parent, child) {
+        var isShadow = Boolean(child.getRootNode && child.getRootNode().host);
+        if (parent.contains(child)) {
+            return true;
+        } else if (isShadow) {
+            var next2 = child;
+            do {
+                if (next2 && parent.isSameNode(next2)) {
+                    return true;
+                }
+                next2 = next2.parentNode || next2.host;
+            } while (next2);
+        }
+        return false;
+    }
 
-            function m2(e4, t3) {
-                return "function" == typeof e4 ? e4(t3) : e4;
-            }
+    function rectToClientRect(rect) {
+        return Object.assign({}, rect, {
+            left: rect.x,
+            top: rect.y,
+            right: rect.x + rect.width,
+            bottom: rect.y + rect.height
+        });
+    }
 
-            function h2(e4) {
-                var n3 = t2.useRef();
-                return n3.current = e4, t2.useCallback(function() {
-                    return n3.current;
-                }, []);
-            }
-            var y2 = "undefined" != typeof document ? t2.useLayoutEffect : t2.useEffect;
+    function getClientRectFromMixedType(element2, clippingParent) {
+        return clippingParent === viewport ? rectToClientRect(getViewportRect(element2)) : isHTMLElement(clippingParent) ? getBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
+    }
 
-            function w2(e4, n3) {
-                var o3 = t2.useRef(false);
-                y2(function() {
-                    o3.current && e4(), o3.current = true;
-                }, n3);
-            }
+    function getClippingParents(element2) {
+        var clippingParents2 = listScrollParents(element2);
+        var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element2).position) >= 0;
+        var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
+        if (!isElement$1(clipperElement)) {
+            return [];
+        }
+        return clippingParents2.filter(function(clippingParent) {
+            return isElement$1(clippingParent) && contains$1(clippingParent, clipperElement);
+        });
+    }
 
-            function R2(e4, t3, n3) {
-                return void 0 === n3 && (n3 = {}),
-                    function(o3, i3) {
-                        void 0 === i3 && (i3 = {});
-                        var u3 = "string" == typeof o3 ? t3[o3] : o3;
-                        if (void 0 === u3)
-                            throw console.info(t3), new Error("Renderer Error \u261D\uFE0F");
-                        return b2(u3, r2({}, e4, {
-                            column: t3
-                        }, n3, {}, i3));
-                    };
-            }
+    function getClippingRect(element2, boundary, rootBoundary) {
+        var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
+        var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
+        var firstClippingParent = clippingParents2[0];
+        var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
+            var rect = getClientRectFromMixedType(element2, clippingParent);
+            var decorations2 = getDecorations(isHTMLElement(clippingParent) ? clippingParent : getDocumentElement(element2));
+            accRect.top = Math.max(rect.top + decorations2.top, accRect.top);
+            accRect.right = Math.min(rect.right - decorations2.right, accRect.right);
+            accRect.bottom = Math.min(rect.bottom - decorations2.bottom, accRect.bottom);
+            accRect.left = Math.max(rect.left + decorations2.left, accRect.left);
+            return accRect;
+        }, getClientRectFromMixedType(element2, firstClippingParent));
+        clippingRect.width = clippingRect.right - clippingRect.left;
+        clippingRect.height = clippingRect.bottom - clippingRect.top;
+        clippingRect.x = clippingRect.left;
+        clippingRect.y = clippingRect.top;
+        return clippingRect;
+    }
 
-            function b2(e4, n3) {
-                return function(e6) {
-                    return "function" == typeof e6 && ((t3 = Object.getPrototypeOf(e6)).prototype && t3.prototype.isReactComponent);
-                    var t3;
-                }(o3 = e4) || "function" == typeof o3 || function(e6) {
-                    return "object" == typeof e6 && "symbol" == typeof e6.$$typeof && ["react.memo", "react.forward_ref"].includes(e6.$$typeof.description);
-                }(o3) ? t2.createElement(e4, n3) : e4;
-                var o3;
-            }
+    function getFreshSideObject() {
+        return {
+            top: 0,
+            right: 0,
+            bottom: 0,
+            left: 0
+        };
+    }
 
-            function S2(e4, t3, n3) {
-                return void 0 === n3 && (n3 = 0), e4.map(function(e6) {
-                    return x2(e6 = r2({}, e6, {
-                        parent: t3,
-                        depth: n3
-                    })), e6.columns && (e6.columns = S2(e6.columns, e6, n3 + 1)), e6;
-                });
-            }
+    function mergePaddingObject(paddingObject) {
+        return Object.assign({}, getFreshSideObject(), {}, paddingObject);
+    }
 
-            function C2(e4) {
-                return G2(e4, "columns");
-            }
+    function expandToHashMap(value, keys2) {
+        return keys2.reduce(function(hashMap, key) {
+            hashMap[key] = value;
+            return hashMap;
+        }, {});
+    }
 
-            function x2(e4) {
-                var t3 = e4.id,
-                    n3 = e4.accessor,
-                    o3 = e4.Header;
-                if ("string" == typeof n3) {
-                    t3 = t3 || n3;
-                    var r3 = n3.split(".");
-                    n3 = function(e6) {
-                        return function(e7, t4, n4) {
-                            if (!t4)
-                                return e7;
-                            var o4, r4 = "function" == typeof t4 ? t4 : JSON.stringify(t4),
-                                i3 = E2.get(r4) || function() {
-                                    var e8 = function(e9) {
-                                        return function e11(t5, n5) {
-                                            void 0 === n5 && (n5 = []);
-                                            if (Array.isArray(t5))
-                                                for (var o5 = 0; o5 < t5.length; o5 += 1)
-                                                    e11(t5[o5], n5);
-                                            else
-                                                n5.push(t5);
-                                            return n5;
-                                        }(e9).map(function(e11) {
-                                            return String(e11).replace(".", "_");
-                                        }).join(".").replace(W2, ".").replace(O2, "").split(".");
-                                    }(t4);
-                                    return E2.set(r4, e8), e8;
-                                }();
-                            try {
-                                o4 = i3.reduce(function(e8, t5) {
-                                    return e8[t5];
-                                }, e7);
-                            } catch (e8) {}
-                            return void 0 !== o4 ? o4 : n4;
-                        }(e6, r3);
-                    };
-                }
-                if (!t3 && "string" == typeof o3 && o3 && (t3 = o3), !t3 && e4.columns)
-                    throw console.error(e4), new Error('A column ID (or unique "Header" value) is required!');
-                if (!t3)
-                    throw console.error(e4), new Error("A column ID (or string accessor) is required!");
-                return Object.assign(e4, {
-                    id: t3,
-                    accessor: n3
-                }), e4;
-            }
+    function detectOverflow(state, options) {
+        if (options === void 0) {
+            options = {};
+        }
+        var _options = options,
+            _options$placement = _options.placement,
+            placement = _options$placement === void 0 ? state.placement : _options$placement,
+            _options$boundary = _options.boundary,
+            boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
+            _options$rootBoundary = _options.rootBoundary,
+            rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
+            _options$elementConte = _options.elementContext,
+            elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
+            _options$altBoundary = _options.altBoundary,
+            altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
+            _options$padding = _options.padding,
+            padding = _options$padding === void 0 ? 0 : _options$padding;
+        var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
+        var altContext = elementContext === popper ? reference : popper;
+        var referenceElement = state.elements.reference;
+        var popperRect = state.rects.popper;
+        var element2 = state.elements[altBoundary ? altContext : elementContext];
+        var clippingClientRect = getClippingRect(isElement$1(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
+        var referenceClientRect = getBoundingClientRect(referenceElement);
+        var popperOffsets2 = computeOffsets({
+            reference: referenceClientRect,
+            element: popperRect,
+            strategy: "absolute",
+            placement
+        });
+        var popperClientRect = rectToClientRect(Object.assign({}, popperRect, {}, popperOffsets2));
+        var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
+        var overflowOffsets = {
+            top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
+            bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
+            left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
+            right: elementClientRect.right - clippingClientRect.right + paddingObject.right
+        };
+        var offsetData = state.modifiersData.offset;
+        if (elementContext === popper && offsetData) {
+            var offset2 = offsetData[placement];
+            Object.keys(overflowOffsets).forEach(function(key) {
+                var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
+                var axis = [top$1, bottom].indexOf(key) >= 0 ? "y" : "x";
+                overflowOffsets[key] += offset2[axis] * multiply;
+            });
+        }
+        return overflowOffsets;
+    }
 
-            function P2(e4, t3) {
-                if (!t3)
-                    throw new Error();
-                return Object.assign(e4, r2({
-                    Header: a2,
-                    Footer: a2
-                }, c2, {}, t3, {}, e4)), Object.assign(e4, {
-                    originalWidth: e4.width
-                }), e4;
-            }
+    function computeAutoPlacement(state, options) {
+        if (options === void 0) {
+            options = {};
+        }
+        var _options = options,
+            placement = _options.placement,
+            boundary = _options.boundary,
+            rootBoundary = _options.rootBoundary,
+            padding = _options.padding,
+            flipVariations = _options.flipVariations,
+            _options$allowedAutoP = _options.allowedAutoPlacements,
+            allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
+        var variation = getVariation(placement);
+        var placements$12 = (variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
+            return getVariation(placement2) === variation;
+        }) : basePlacements).filter(function(placement2) {
+            return allowedAutoPlacements.indexOf(placement2) >= 0;
+        });
+        var overflows = placements$12.reduce(function(acc, placement2) {
+            acc[placement2] = detectOverflow(state, {
+                placement: placement2,
+                boundary,
+                rootBoundary,
+                padding
+            })[getBasePlacement(placement2)];
+            return acc;
+        }, {});
+        return Object.keys(overflows).sort(function(a2, b2) {
+            return overflows[a2] - overflows[b2];
+        });
+    }
 
-            function B2(e4, t3, n3) {
-                void 0 === n3 && (n3 = function() {
-                    return {};
-                });
-                for (var o3 = [], i3 = e4, u3 = 0, l3 = function() {
-                        return u3++;
-                    }, s3 = function() {
-                        var e6 = {
-                                headers: []
-                            },
-                            u4 = [],
-                            s4 = i3.some(function(e7) {
-                                return e7.parent;
-                            });
-                        i3.forEach(function(o4) {
-                            var i4, a3 = [].concat(u4).reverse()[0];
-                            if (s4) {
-                                if (o4.parent)
-                                    i4 = r2({}, o4.parent, {
-                                        originalId: o4.parent.id,
-                                        id: o4.parent.id + "_" + l3(),
-                                        headers: [o4]
-                                    }, n3(o4));
-                                else
-                                    i4 = P2(r2({
-                                        originalId: o4.id + "_placeholder",
-                                        id: o4.id + "_placeholder_" + l3(),
-                                        placeholderOf: o4,
-                                        headers: [o4]
-                                    }, n3(o4)), t3);
-                                a3 && a3.originalId === i4.originalId ? a3.headers.push(o4) : u4.push(i4);
-                            }
-                            e6.headers.push(o4);
-                        }), o3.push(e6), i3 = u4;
-                    }; i3.length;)
-                    s3();
-                return o3.reverse();
-            }
-            var E2 = /* @__PURE__ */ new Map();
+    function getExpandedFallbackPlacements(placement) {
+        if (getBasePlacement(placement) === auto) {
+            return [];
+        }
+        var oppositePlacement = getOppositePlacement(placement);
+        return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
+    }
 
-            function I2() {
-                for (var e4 = arguments.length, t3 = new Array(e4), n3 = 0; n3 < e4; n3++)
-                    t3[n3] = arguments[n3];
-                for (var o3 = 0; o3 < t3.length; o3 += 1)
-                    if (void 0 !== t3[o3])
-                        return t3[o3];
+    function flip(_ref2) {
+        var state = _ref2.state,
+            options = _ref2.options,
+            name2 = _ref2.name;
+        if (state.modifiersData[name2]._skip) {
+            return;
+        }
+        var _options$mainAxis = options.mainAxis,
+            checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
+            _options$altAxis = options.altAxis,
+            checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
+            specifiedFallbackPlacements = options.fallbackPlacements,
+            padding = options.padding,
+            boundary = options.boundary,
+            rootBoundary = options.rootBoundary,
+            altBoundary = options.altBoundary,
+            _options$flipVariatio = options.flipVariations,
+            flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
+            allowedAutoPlacements = options.allowedAutoPlacements;
+        var preferredPlacement = state.options.placement;
+        var basePlacement = getBasePlacement(preferredPlacement);
+        var isBasePlacement = basePlacement === preferredPlacement;
+        var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
+        var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
+            return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
+                placement: placement2,
+                boundary,
+                rootBoundary,
+                padding,
+                flipVariations,
+                allowedAutoPlacements
+            }) : placement2);
+        }, []);
+        var referenceRect = state.rects.reference;
+        var popperRect = state.rects.popper;
+        var checksMap = /* @__PURE__ */ new Map();
+        var makeFallbackChecks = true;
+        var firstFittingPlacement = placements2[0];
+        for (var i2 = 0; i2 < placements2.length; i2++) {
+            var placement = placements2[i2];
+            var _basePlacement = getBasePlacement(placement);
+            var isStartVariation = getVariation(placement) === start$1;
+            var isVertical = [top$1, bottom].indexOf(_basePlacement) >= 0;
+            var len = isVertical ? "width" : "height";
+            var overflow = detectOverflow(state, {
+                placement,
+                boundary,
+                rootBoundary,
+                altBoundary,
+                padding
+            });
+            var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top$1;
+            if (referenceRect[len] > popperRect[len]) {
+                mainVariationSide = getOppositePlacement(mainVariationSide);
             }
-
-            function F2(e4) {
-                if ("function" == typeof e4)
-                    return e4;
+            var altVariationSide = getOppositePlacement(mainVariationSide);
+            var checks2 = [];
+            if (checkMainAxis) {
+                checks2.push(overflow[_basePlacement] <= 0);
             }
-
-            function G2(e4, t3) {
-                var n3 = [];
-                return function e6(o3) {
-                    o3.forEach(function(o4) {
-                        o4[t3] ? e6(o4[t3]) : n3.push(o4);
-                    });
-                }(e4), n3;
+            if (checkAltAxis) {
+                checks2.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
             }
-
-            function A2(e4, t3) {
-                var n3 = t3.manualExpandedKey,
-                    o3 = t3.expanded,
-                    r3 = t3.expandSubRows,
-                    i3 = void 0 === r3 || r3,
-                    u3 = [];
-                return e4.forEach(function(e6) {
-                    return function e7(t4, r4) {
-                        void 0 === r4 && (r4 = true), t4.isExpanded = t4.original && t4.original[n3] || o3[t4.id], t4.canExpand = t4.subRows && !!t4.subRows.length, r4 && u3.push(t4), t4.subRows && t4.subRows.length && t4.isExpanded && t4.subRows.forEach(function(t5) {
-                            return e7(t5, i3);
+            if (checks2.every(function(check) {
+                    return check;
+                })) {
+                firstFittingPlacement = placement;
+                makeFallbackChecks = false;
+                break;
+            }
+            checksMap.set(placement, checks2);
+        }
+        if (makeFallbackChecks) {
+            var numberOfChecks = flipVariations ? 3 : 1;
+            var _loop = function _loop2(_i3) {
+                var fittingPlacement = placements2.find(function(placement2) {
+                    var checks3 = checksMap.get(placement2);
+                    if (checks3) {
+                        return checks3.slice(0, _i3).every(function(check) {
+                            return check;
                         });
-                    }(e6);
-                }), u3;
+                    }
+                });
+                if (fittingPlacement) {
+                    firstFittingPlacement = fittingPlacement;
+                    return "break";
+                }
+            };
+            for (var _i2 = numberOfChecks; _i2 > 0; _i2--) {
+                var _ret = _loop(_i2);
+                if (_ret === "break")
+                    break;
             }
+        }
+        if (state.placement !== firstFittingPlacement) {
+            state.modifiersData[name2]._skip = true;
+            state.placement = firstFittingPlacement;
+            state.reset = true;
+        }
+    }
+    const flip$1 = {
+        name: "flip",
+        enabled: true,
+        phase: "main",
+        fn: flip,
+        requiresIfExists: ["offset"],
+        data: {
+            _skip: false
+        }
+    };
 
-            function k2(e4, t3, n3) {
-                return F2(e4) || t3[e4] || n3[e4] || n3.text;
-            }
+    function getAltAxis(axis) {
+        return axis === "x" ? "y" : "x";
+    }
 
-            function H2(e4, t3, n3) {
-                return e4 ? e4(t3, n3) : void 0 === t3;
-            }
+    function within(min2, value, max2) {
+        return Math.max(min2, Math.min(value, max2));
+    }
 
-            function T2() {
-                throw new Error("React-Table: You have not called prepareRow(row) one or more rows you are attempting to render.");
-            }
-            var z2 = null;
-            var W2 = /\[/g,
-                O2 = /\]/g;
-            var M2 = function(e4) {
-                    return r2({
-                        role: "table"
-                    }, e4);
-                },
-                j2 = function(e4) {
-                    return r2({
-                        role: "rowgroup"
-                    }, e4);
-                },
-                N2 = function(e4, t3) {
-                    var n3 = t3.column;
-                    return r2({
-                        key: "header_" + n3.id,
-                        colSpan: n3.totalVisibleHeaderCount,
-                        role: "columnheader"
-                    }, e4);
-                },
-                L2 = function(e4, t3) {
-                    var n3 = t3.column;
-                    return r2({
-                        key: "footer_" + n3.id,
-                        colSpan: n3.totalVisibleHeaderCount
-                    }, e4);
-                },
-                D2 = function(e4, t3) {
-                    return r2({
-                        key: "headerGroup_" + t3.index,
-                        role: "row"
-                    }, e4);
-                },
-                V2 = function(e4, t3) {
-                    return r2({
-                        key: "footerGroup_" + t3.index
-                    }, e4);
-                },
-                _2 = function(e4, t3) {
-                    return r2({
-                        key: "row_" + t3.row.id,
-                        role: "row"
-                    }, e4);
-                },
-                X2 = function(e4, t3) {
-                    var n3 = t3.cell;
-                    return r2({
-                        key: "cell_" + n3.row.id + "_" + n3.column.id,
-                        role: "cell"
-                    }, e4);
-                };
+    function preventOverflow(_ref2) {
+        var state = _ref2.state,
+            options = _ref2.options,
+            name2 = _ref2.name;
+        var _options$mainAxis = options.mainAxis,
+            checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
+            _options$altAxis = options.altAxis,
+            checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
+            boundary = options.boundary,
+            rootBoundary = options.rootBoundary,
+            altBoundary = options.altBoundary,
+            padding = options.padding,
+            _options$tether = options.tether,
+            tether = _options$tether === void 0 ? true : _options$tether,
+            _options$tetherOffset = options.tetherOffset,
+            tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
+        var overflow = detectOverflow(state, {
+            boundary,
+            rootBoundary,
+            padding,
+            altBoundary
+        });
+        var basePlacement = getBasePlacement(state.placement);
+        var variation = getVariation(state.placement);
+        var isBasePlacement = !variation;
+        var mainAxis = getMainAxisFromPlacement(basePlacement);
+        var altAxis = getAltAxis(mainAxis);
+        var popperOffsets2 = state.modifiersData.popperOffsets;
+        var referenceRect = state.rects.reference;
+        var popperRect = state.rects.popper;
+        var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
+            placement: state.placement
+        })) : tetherOffset;
+        var data2 = {
+            x: 0,
+            y: 0
+        };
+        if (!popperOffsets2) {
+            return;
+        }
+        if (checkMainAxis) {
+            var mainSide = mainAxis === "y" ? top$1 : left;
+            var altSide = mainAxis === "y" ? bottom : right;
+            var len = mainAxis === "y" ? "height" : "width";
+            var offset2 = popperOffsets2[mainAxis];
+            var min2 = popperOffsets2[mainAxis] + overflow[mainSide];
+            var max2 = popperOffsets2[mainAxis] - overflow[altSide];
+            var additive = tether ? -popperRect[len] / 2 : 0;
+            var minLen = variation === start$1 ? referenceRect[len] : popperRect[len];
+            var maxLen = variation === start$1 ? -popperRect[len] : -referenceRect[len];
+            var arrowElement = state.elements.arrow;
+            var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
+                width: 0,
+                height: 0
+            };
+            var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
+            var arrowPaddingMin = arrowPaddingObject[mainSide];
+            var arrowPaddingMax = arrowPaddingObject[altSide];
+            var arrowLen = within(0, referenceRect[len], arrowRect[len]);
+            var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
+            var maxOffset2 = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
+            var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
+            var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
+            var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
+            var tetherMin = popperOffsets2[mainAxis] + minOffset - offsetModifierValue - clientOffset;
+            var tetherMax = popperOffsets2[mainAxis] + maxOffset2 - offsetModifierValue;
+            var preventedOffset = within(tether ? Math.min(min2, tetherMin) : min2, offset2, tether ? Math.max(max2, tetherMax) : max2);
+            popperOffsets2[mainAxis] = preventedOffset;
+            data2[mainAxis] = preventedOffset - offset2;
+        }
+        if (checkAltAxis) {
+            var _mainSide = mainAxis === "x" ? top$1 : left;
+            var _altSide = mainAxis === "x" ? bottom : right;
+            var _offset = popperOffsets2[altAxis];
+            var _min = _offset + overflow[_mainSide];
+            var _max = _offset - overflow[_altSide];
+            var _preventedOffset = within(_min, _offset, _max);
+            popperOffsets2[altAxis] = _preventedOffset;
+            data2[altAxis] = _preventedOffset - _offset;
+        }
+        state.modifiersData[name2] = data2;
+    }
+    const preventOverflow$1 = {
+        name: "preventOverflow",
+        enabled: true,
+        phase: "main",
+        fn: preventOverflow,
+        requiresIfExists: ["offset"]
+    };
 
-            function q2() {
-                return {
-                    useOptions: [],
-                    stateReducers: [],
-                    useControlledState: [],
-                    columns: [],
-                    columnsDeps: [],
-                    allColumns: [],
-                    allColumnsDeps: [],
-                    accessValue: [],
-                    materializedColumns: [],
-                    materializedColumnsDeps: [],
-                    useInstanceAfterData: [],
-                    visibleColumns: [],
-                    visibleColumnsDeps: [],
-                    headerGroups: [],
-                    headerGroupsDeps: [],
-                    useInstanceBeforeDimensions: [],
-                    useInstance: [],
-                    prepareRow: [],
-                    getTableProps: [M2],
-                    getTableBodyProps: [j2],
-                    getHeaderGroupProps: [D2],
-                    getFooterGroupProps: [V2],
-                    getHeaderProps: [N2],
-                    getFooterProps: [L2],
-                    getRowProps: [_2],
-                    getCellProps: [X2],
-                    useFinalInstance: []
-                };
+    function arrow(_ref2) {
+        var _state$modifiersData$;
+        var state = _ref2.state,
+            name2 = _ref2.name;
+        var arrowElement = state.elements.arrow;
+        var popperOffsets2 = state.modifiersData.popperOffsets;
+        var basePlacement = getBasePlacement(state.placement);
+        var axis = getMainAxisFromPlacement(basePlacement);
+        var isVertical = [left, right].indexOf(basePlacement) >= 0;
+        var len = isVertical ? "height" : "width";
+        if (!arrowElement || !popperOffsets2) {
+            return;
+        }
+        var paddingObject = state.modifiersData[name2 + "#persistent"].padding;
+        var arrowRect = getLayoutRect(arrowElement);
+        var minProp = axis === "y" ? top$1 : left;
+        var maxProp = axis === "y" ? bottom : right;
+        var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
+        var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
+        var arrowOffsetParent = getOffsetParent(arrowElement);
+        var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
+        var centerToReference = endDiff / 2 - startDiff / 2;
+        var min2 = paddingObject[minProp];
+        var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
+        var center2 = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
+        var offset2 = within(min2, center2, max2);
+        var axisProp = axis;
+        state.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center2, _state$modifiersData$);
+    }
+
+    function effect(_ref2) {
+        var state = _ref2.state,
+            options = _ref2.options,
+            name2 = _ref2.name;
+        var _options$element = options.element,
+            arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element,
+            _options$padding = options.padding,
+            padding = _options$padding === void 0 ? 0 : _options$padding;
+        if (arrowElement == null) {
+            return;
+        }
+        if (typeof arrowElement === "string") {
+            arrowElement = state.elements.popper.querySelector(arrowElement);
+            if (!arrowElement) {
+                return;
             }
-            l2.resetHiddenColumns = "resetHiddenColumns", l2.toggleHideColumn = "toggleHideColumn", l2.setHiddenColumns = "setHiddenColumns", l2.toggleHideAllColumns = "toggleHideAllColumns";
-            var K2 = function(e4) {
-                e4.getToggleHiddenProps = [U2], e4.getToggleHideAllColumnsProps = [$2], e4.stateReducers.push(J2), e4.useInstanceBeforeDimensions.push(Y2), e4.headerGroupsDeps.push(function(e6, t3) {
-                    var n3 = t3.instance;
-                    return [].concat(e6, [n3.state.hiddenColumns]);
-                }), e4.useInstance.push(Q2);
+        }
+        if (!contains$1(state.elements.popper, arrowElement)) {
+            return;
+        }
+        state.elements.arrow = arrowElement;
+        state.modifiersData[name2 + "#persistent"] = {
+            padding: mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements))
+        };
+    }
+    const arrow$1 = {
+        name: "arrow",
+        enabled: true,
+        phase: "main",
+        fn: arrow,
+        effect,
+        requires: ["popperOffsets"],
+        requiresIfExists: ["preventOverflow"]
+    };
+
+    function getSideOffsets(overflow, rect, preventedOffsets) {
+        if (preventedOffsets === void 0) {
+            preventedOffsets = {
+                x: 0,
+                y: 0
             };
-            K2.pluginName = "useColumnVisibility";
-            var U2 = function(e4, t3) {
-                    var n3 = t3.column;
-                    return [e4, {
-                        onChange: function(e6) {
-                            n3.toggleHidden(!e6.target.checked);
-                        },
-                        style: {
-                            cursor: "pointer"
-                        },
-                        checked: n3.isVisible,
-                        title: "Toggle Column Visible"
-                    }];
-                },
-                $2 = function(e4, t3) {
-                    var n3 = t3.instance;
-                    return [e4, {
-                        onChange: function(e6) {
-                            n3.toggleHideAllColumns(!e6.target.checked);
-                        },
-                        style: {
-                            cursor: "pointer"
-                        },
-                        checked: !n3.allColumnsHidden && !n3.state.hiddenColumns.length,
-                        title: "Toggle All Columns Hidden",
-                        indeterminate: !n3.allColumnsHidden && n3.state.hiddenColumns.length
-                    }];
-                };
+        }
+        return {
+            top: overflow.top - rect.height - preventedOffsets.y,
+            right: overflow.right - rect.width + preventedOffsets.x,
+            bottom: overflow.bottom - rect.height + preventedOffsets.y,
+            left: overflow.left - rect.width - preventedOffsets.x
+        };
+    }
 
-            function J2(e4, t3, n3, o3) {
-                if (t3.type === l2.init)
-                    return r2({
-                        hiddenColumns: []
-                    }, e4);
-                if (t3.type === l2.resetHiddenColumns)
-                    return r2({}, e4, {
-                        hiddenColumns: o3.initialState.hiddenColumns || []
-                    });
-                if (t3.type === l2.toggleHideColumn) {
-                    var i3 = (void 0 !== t3.value ? t3.value : !e4.hiddenColumns.includes(t3.columnId)) ? [].concat(e4.hiddenColumns, [t3.columnId]) : e4.hiddenColumns.filter(function(e6) {
-                        return e6 !== t3.columnId;
-                    });
-                    return r2({}, e4, {
-                        hiddenColumns: i3
-                    });
-                }
-                return t3.type === l2.setHiddenColumns ? r2({}, e4, {
-                    hiddenColumns: m2(t3.value, e4.hiddenColumns)
-                }) : t3.type === l2.toggleHideAllColumns ? r2({}, e4, {
-                    hiddenColumns: (void 0 !== t3.value ? t3.value : !e4.hiddenColumns.length) ? o3.allColumns.map(function(e6) {
-                        return e6.id;
-                    }) : []
-                }) : void 0;
-            }
+    function isAnySideFullyClipped(overflow) {
+        return [top$1, right, bottom, left].some(function(side) {
+            return overflow[side] >= 0;
+        });
+    }
 
-            function Y2(e4) {
-                var n3 = e4.headers,
-                    o3 = e4.state.hiddenColumns;
-                t2.useRef(false).current;
-                var r3 = 0;
-                n3.forEach(function(e6) {
-                    return r3 += function e7(t3, n4) {
-                        t3.isVisible = n4 && !o3.includes(t3.id);
-                        var r4 = 0;
-                        return t3.headers && t3.headers.length ? t3.headers.forEach(function(n5) {
-                            return r4 += e7(n5, t3.isVisible);
-                        }) : r4 = t3.isVisible ? 1 : 0, t3.totalVisibleHeaderCount = r4, r4;
-                    }(e6, true);
-                });
-            }
+    function hide(_ref2) {
+        var state = _ref2.state,
+            name2 = _ref2.name;
+        var referenceRect = state.rects.reference;
+        var popperRect = state.rects.popper;
+        var preventedOffsets = state.modifiersData.preventOverflow;
+        var referenceOverflow = detectOverflow(state, {
+            elementContext: "reference"
+        });
+        var popperAltOverflow = detectOverflow(state, {
+            altBoundary: true
+        });
+        var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
+        var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
+        var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
+        var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
+        state.modifiersData[name2] = {
+            referenceClippingOffsets,
+            popperEscapeOffsets,
+            isReferenceHidden,
+            hasPopperEscaped
+        };
+        state.attributes.popper = Object.assign({}, state.attributes.popper, {
+            "data-popper-reference-hidden": isReferenceHidden,
+            "data-popper-escaped": hasPopperEscaped
+        });
+    }
+    const hide$1 = {
+        name: "hide",
+        enabled: true,
+        phase: "main",
+        requiresIfExists: ["preventOverflow"],
+        fn: hide
+    };
+    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
+    var createPopper = /* @__PURE__ */ popperGenerator({
+        defaultModifiers
+    });
+    var hasElementType = typeof Element !== "undefined";
+    var hasMap$1 = typeof Map === "function";
+    var hasSet$1 = typeof Set === "function";
+    var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
 
-            function Q2(e4) {
-                var n3 = e4.columns,
-                    o3 = e4.flatHeaders,
-                    r3 = e4.dispatch,
-                    i3 = e4.allColumns,
-                    u3 = e4.getHooks,
-                    s3 = e4.state.hiddenColumns,
-                    a3 = e4.autoResetHiddenColumns,
-                    c3 = void 0 === a3 || a3,
-                    d3 = h2(e4),
-                    p3 = i3.length === s3.length,
-                    g3 = t2.useCallback(function(e6, t3) {
-                        return r3({
-                            type: l2.toggleHideColumn,
-                            columnId: e6,
-                            value: t3
-                        });
-                    }, [r3]),
-                    v3 = t2.useCallback(function(e6) {
-                        return r3({
-                            type: l2.setHiddenColumns,
-                            value: e6
-                        });
-                    }, [r3]),
-                    m3 = t2.useCallback(function(e6) {
-                        return r3({
-                            type: l2.toggleHideAllColumns,
-                            value: e6
-                        });
-                    }, [r3]),
-                    y3 = f2(u3().getToggleHideAllColumnsProps, {
-                        instance: d3()
-                    });
-                o3.forEach(function(e6) {
-                    e6.toggleHidden = function(t3) {
-                        r3({
-                            type: l2.toggleHideColumn,
-                            columnId: e6.id,
-                            value: t3
-                        });
-                    }, e6.getToggleHiddenProps = f2(u3().getToggleHiddenProps, {
-                        instance: d3(),
-                        column: e6
-                    });
-                });
-                var R3 = h2(c3);
-                w2(function() {
-                    R3() && r3({
-                        type: l2.resetHiddenColumns
-                    });
-                }, [r3, n3]), Object.assign(e4, {
-                    allColumnsHidden: p3,
-                    toggleHideColumn: g3,
-                    setHiddenColumns: v3,
-                    toggleHideAllColumns: m3,
-                    getToggleHideAllColumnsProps: y3
-                });
+    function equal$1(a2, b2) {
+        if (a2 === b2)
+            return true;
+        if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
+            if (a2.constructor !== b2.constructor)
+                return false;
+            var length, i2, keys2;
+            if (Array.isArray(a2)) {
+                length = a2.length;
+                if (length != b2.length)
+                    return false;
+                for (i2 = length; i2-- !== 0;)
+                    if (!equal$1(a2[i2], b2[i2]))
+                        return false;
+                return true;
             }
-            var Z2 = {},
-                ee = {},
-                te2 = function(e4, t3, n3) {
-                    return e4;
-                },
-                ne = function(e4, t3) {
-                    return e4.subRows || [];
-                },
-                oe2 = function(e4, t3, n3) {
-                    return "" + (n3 ? [n3.id, t3].join(".") : t3);
-                },
-                re2 = function(e4) {
-                    return e4;
-                };
-
-            function ie2(e4) {
-                var t3 = e4.initialState,
-                    n3 = void 0 === t3 ? Z2 : t3,
-                    o3 = e4.defaultColumn,
-                    u3 = void 0 === o3 ? ee : o3,
-                    l3 = e4.getSubRows,
-                    s3 = void 0 === l3 ? ne : l3,
-                    a3 = e4.getRowId,
-                    c3 = void 0 === a3 ? oe2 : a3,
-                    d3 = e4.stateReducer,
-                    f3 = void 0 === d3 ? te2 : d3,
-                    p3 = e4.useControlledState,
-                    g3 = void 0 === p3 ? re2 : p3;
-                return r2({}, i2(e4, ["initialState", "defaultColumn", "getSubRows", "getRowId", "stateReducer", "useControlledState"]), {
-                    initialState: n3,
-                    defaultColumn: u3,
-                    getSubRows: s3,
-                    getRowId: c3,
-                    stateReducer: f3,
-                    useControlledState: g3
-                });
+            var it2;
+            if (hasMap$1 && a2 instanceof Map && b2 instanceof Map) {
+                if (a2.size !== b2.size)
+                    return false;
+                it2 = a2.entries();
+                while (!(i2 = it2.next()).done)
+                    if (!b2.has(i2.value[0]))
+                        return false;
+                it2 = a2.entries();
+                while (!(i2 = it2.next()).done)
+                    if (!equal$1(i2.value[1], b2.get(i2.value[0])))
+                        return false;
+                return true;
             }
-
-            function ue2(e4, t3) {
-                void 0 === t3 && (t3 = 0);
-                var n3 = 0,
-                    o3 = 0,
-                    r3 = 0,
-                    i3 = 0;
-                return e4.forEach(function(e6) {
-                    var u3 = e6.headers;
-                    if (e6.totalLeft = t3, u3 && u3.length) {
-                        var l3 = ue2(u3, t3),
-                            s3 = l3[0],
-                            a3 = l3[1],
-                            c3 = l3[2],
-                            d3 = l3[3];
-                        e6.totalMinWidth = s3, e6.totalWidth = a3, e6.totalMaxWidth = c3, e6.totalFlexWidth = d3;
-                    } else
-                        e6.totalMinWidth = e6.minWidth, e6.totalWidth = Math.min(Math.max(e6.minWidth, e6.width), e6.maxWidth), e6.totalMaxWidth = e6.maxWidth, e6.totalFlexWidth = e6.canResize ? e6.totalWidth : 0;
-                    e6.isVisible && (t3 += e6.totalWidth, n3 += e6.totalMinWidth, o3 += e6.totalWidth, r3 += e6.totalMaxWidth, i3 += e6.totalFlexWidth);
-                }), [n3, o3, r3, i3];
+            if (hasSet$1 && a2 instanceof Set && b2 instanceof Set) {
+                if (a2.size !== b2.size)
+                    return false;
+                it2 = a2.entries();
+                while (!(i2 = it2.next()).done)
+                    if (!b2.has(i2.value[0]))
+                        return false;
+                return true;
             }
-
-            function le2(e4) {
-                var t3 = e4.data,
-                    n3 = e4.rows,
-                    o3 = e4.flatRows,
-                    r3 = e4.rowsById,
-                    i3 = e4.column,
-                    u3 = e4.getRowId,
-                    l3 = e4.getSubRows,
-                    s3 = e4.accessValueHooks,
-                    a3 = e4.getInstance;
-                t3.forEach(function(e6, c3) {
-                    return function e7(n4, c4, d3, f3, g3) {
-                        void 0 === d3 && (d3 = 0);
-                        var v3 = n4,
-                            m3 = u3(n4, c4, f3),
-                            h3 = r3[m3];
-                        if (h3)
-                            h3.subRows && h3.originalSubRows.forEach(function(t4, n5) {
-                                return e7(t4, n5, d3 + 1, h3);
-                            });
-                        else if ((h3 = {
-                                id: m3,
-                                original: v3,
-                                index: c4,
-                                depth: d3,
-                                cells: [{}]
-                            }).cells.map = T2, h3.cells.filter = T2, h3.cells.forEach = T2, h3.cells[0].getCellProps = T2, h3.values = {}, g3.push(h3), o3.push(h3), r3[m3] = h3, h3.originalSubRows = l3(n4, c4), h3.originalSubRows) {
-                            var y3 = [];
-                            h3.originalSubRows.forEach(function(t4, n5) {
-                                return e7(t4, n5, d3 + 1, h3, y3);
-                            }), h3.subRows = y3;
-                        }
-                        i3.accessor && (h3.values[i3.id] = i3.accessor(n4, c4, h3, g3, t3)), h3.values[i3.id] = p2(s3, h3.values[i3.id], {
-                            row: h3,
-                            column: i3,
-                            instance: a3()
-                        });
-                    }(e6, c3, 0, void 0, n3);
-                });
+            if (hasArrayBuffer && ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
+                length = a2.length;
+                if (length != b2.length)
+                    return false;
+                for (i2 = length; i2-- !== 0;)
+                    if (a2[i2] !== b2[i2])
+                        return false;
+                return true;
             }
-            l2.resetExpanded = "resetExpanded", l2.toggleRowExpanded = "toggleRowExpanded", l2.toggleAllRowsExpanded = "toggleAllRowsExpanded";
-            var se2 = function(e4) {
-                e4.getToggleAllRowsExpandedProps = [ae2], e4.getToggleRowExpandedProps = [ce2], e4.stateReducers.push(de2), e4.useInstance.push(fe2), e4.prepareRow.push(pe2);
-            };
-            se2.pluginName = "useExpanded";
-            var ae2 = function(e4, t3) {
-                    var n3 = t3.instance;
-                    return [e4, {
-                        onClick: function(e6) {
-                            n3.toggleAllRowsExpanded();
-                        },
-                        style: {
-                            cursor: "pointer"
-                        },
-                        title: "Toggle All Rows Expanded"
-                    }];
-                },
-                ce2 = function(e4, t3) {
-                    var n3 = t3.row;
-                    return [e4, {
-                        onClick: function() {
-                            n3.toggleRowExpanded();
-                        },
-                        style: {
-                            cursor: "pointer"
-                        },
-                        title: "Toggle Row Expanded"
-                    }];
-                };
-
-            function de2(e4, t3, n3, o3) {
-                if (t3.type === l2.init)
-                    return r2({
-                        expanded: {}
-                    }, e4);
-                if (t3.type === l2.resetExpanded)
-                    return r2({}, e4, {
-                        expanded: o3.initialState.expanded || {}
-                    });
-                if (t3.type === l2.toggleAllRowsExpanded) {
-                    var s3 = t3.value,
-                        a3 = o3.isAllRowsExpanded,
-                        c3 = o3.rowsById;
-                    if (void 0 !== s3 ? s3 : !a3) {
-                        var d3 = {};
-                        return Object.keys(c3).forEach(function(e6) {
-                            d3[e6] = true;
-                        }), r2({}, e4, {
-                            expanded: d3
-                        });
-                    }
-                    return r2({}, e4, {
-                        expanded: {}
-                    });
-                }
-                if (t3.type === l2.toggleRowExpanded) {
-                    var f3, p3 = t3.id,
-                        g3 = t3.value,
-                        v3 = e4.expanded[p3],
-                        m3 = void 0 !== g3 ? g3 : !v3;
-                    if (!v3 && m3)
-                        return r2({}, e4, {
-                            expanded: r2({}, e4.expanded, (f3 = {}, f3[p3] = true, f3))
-                        });
-                    if (v3 && !m3) {
-                        var h3 = e4.expanded;
-                        h3[p3];
-                        return r2({}, e4, {
-                            expanded: i2(h3, [p3].map(u2))
-                        });
-                    }
-                    return e4;
+            if (a2.constructor === RegExp)
+                return a2.source === b2.source && a2.flags === b2.flags;
+            if (a2.valueOf !== Object.prototype.valueOf && typeof a2.valueOf === "function" && typeof b2.valueOf === "function")
+                return a2.valueOf() === b2.valueOf();
+            if (a2.toString !== Object.prototype.toString && typeof a2.toString === "function" && typeof b2.toString === "function")
+                return a2.toString() === b2.toString();
+            keys2 = Object.keys(a2);
+            length = keys2.length;
+            if (length !== Object.keys(b2).length)
+                return false;
+            for (i2 = length; i2-- !== 0;)
+                if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2]))
+                    return false;
+            if (hasElementType && a2 instanceof Element)
+                return false;
+            for (i2 = length; i2-- !== 0;) {
+                if ((keys2[i2] === "_owner" || keys2[i2] === "__v" || keys2[i2] === "__o") && a2.$$typeof) {
+                    continue;
                 }
+                if (!equal$1(a2[keys2[i2]], b2[keys2[i2]]))
+                    return false;
             }
-
-            function fe2(e4) {
-                var n3 = e4.data,
-                    o3 = e4.rows,
-                    r3 = e4.rowsById,
-                    i3 = e4.manualExpandedKey,
-                    u3 = void 0 === i3 ? "expanded" : i3,
-                    s3 = e4.paginateExpandedRows,
-                    a3 = void 0 === s3 || s3,
-                    c3 = e4.expandSubRows,
-                    d3 = void 0 === c3 || c3,
-                    p3 = e4.autoResetExpanded,
-                    g3 = void 0 === p3 || p3,
-                    m3 = e4.getHooks,
-                    y3 = e4.plugins,
-                    R3 = e4.state.expanded,
-                    b3 = e4.dispatch;
-                v2(y3, ["useSortBy", "useGroupBy", "usePivotColumns", "useGlobalFilter"], "useExpanded");
-                var S3 = h2(g3),
-                    C3 = Boolean(Object.keys(r3).length && Object.keys(R3).length);
-                C3 && Object.keys(r3).some(function(e6) {
-                    return !R3[e6];
-                }) && (C3 = false), w2(function() {
-                    S3() && b3({
-                        type: l2.resetExpanded
-                    });
-                }, [b3, n3]);
-                var x3 = t2.useCallback(function(e6, t3) {
-                        b3({
-                            type: l2.toggleRowExpanded,
-                            id: e6,
-                            value: t3
-                        });
-                    }, [b3]),
-                    P3 = t2.useCallback(function(e6) {
-                        return b3({
-                            type: l2.toggleAllRowsExpanded,
-                            value: e6
-                        });
-                    }, [b3]),
-                    B3 = t2.useMemo(function() {
-                        return a3 ? A2(o3, {
-                            manualExpandedKey: u3,
-                            expanded: R3,
-                            expandSubRows: d3
-                        }) : o3;
-                    }, [a3, o3, u3, R3, d3]),
-                    E3 = t2.useMemo(function() {
-                        return function(e6) {
-                            var t3 = 0;
-                            return Object.keys(e6).forEach(function(e7) {
-                                var n4 = e7.split(".");
-                                t3 = Math.max(t3, n4.length);
-                            }), t3;
-                        }(R3);
-                    }, [R3]),
-                    I3 = h2(e4),
-                    F3 = f2(m3().getToggleAllRowsExpandedProps, {
-                        instance: I3()
-                    });
-                Object.assign(e4, {
-                    preExpandedRows: o3,
-                    expandedRows: B3,
-                    rows: B3,
-                    expandedDepth: E3,
-                    isAllRowsExpanded: C3,
-                    toggleRowExpanded: x3,
-                    toggleAllRowsExpanded: P3,
-                    getToggleAllRowsExpandedProps: F3
-                });
-            }
-
-            function pe2(e4, t3) {
-                var n3 = t3.instance.getHooks,
-                    o3 = t3.instance;
-                e4.toggleRowExpanded = function(t4) {
-                    return o3.toggleRowExpanded(e4.id, t4);
-                }, e4.getToggleRowExpandedProps = f2(n3().getToggleRowExpandedProps, {
-                    instance: o3,
-                    row: e4
-                });
+            return true;
+        }
+        return a2 !== a2 && b2 !== b2;
+    }
+    var reactFastCompare = function isEqual2(a2, b2) {
+        try {
+            return equal$1(a2, b2);
+        } catch (error2) {
+            if ((error2.message || "").match(/stack|recursion/i)) {
+                console.warn("react-fast-compare cannot handle circular refs");
+                return false;
             }
-            var ge2 = function(e4, t3, n3) {
-                return e4 = e4.filter(function(e6) {
-                    return t3.some(function(t4) {
-                        var o3 = e6.values[t4];
-                        return String(o3).toLowerCase().includes(String(n3).toLowerCase());
-                    });
-                });
-            };
-            ge2.autoRemove = function(e4) {
-                return !e4;
-            };
-            var ve2 = function(e4, t3, n3) {
-                return e4.filter(function(e6) {
-                    return t3.some(function(t4) {
-                        var o3 = e6.values[t4];
-                        return void 0 === o3 || String(o3).toLowerCase() === String(n3).toLowerCase();
-                    });
-                });
-            };
-            ve2.autoRemove = function(e4) {
-                return !e4;
-            };
-            var me2 = function(e4, t3, n3) {
-                return e4.filter(function(e6) {
-                    return t3.some(function(t4) {
-                        var o3 = e6.values[t4];
-                        return void 0 === o3 || String(o3) === String(n3);
-                    });
-                });
-            };
-            me2.autoRemove = function(e4) {
-                return !e4;
-            };
-            var he2 = function(e4, t3, n3) {
-                return e4.filter(function(e6) {
-                    return t3.some(function(t4) {
-                        return e6.values[t4].includes(n3);
-                    });
-                });
-            };
-            he2.autoRemove = function(e4) {
-                return !e4 || !e4.length;
-            };
-            var ye2 = function(e4, t3, n3) {
-                return e4.filter(function(e6) {
-                    return t3.some(function(t4) {
-                        var o3 = e6.values[t4];
-                        return o3 && o3.length && n3.every(function(e7) {
-                            return o3.includes(e7);
-                        });
-                    });
-                });
-            };
-            ye2.autoRemove = function(e4) {
-                return !e4 || !e4.length;
-            };
-            var we2 = function(e4, t3, n3) {
-                return e4.filter(function(e6) {
-                    return t3.some(function(t4) {
-                        var o3 = e6.values[t4];
-                        return o3 && o3.length && n3.some(function(e7) {
-                            return o3.includes(e7);
+            throw error2;
+        }
+    };
+    var EMPTY_MODIFIERS$2 = [];
+    var usePopper$1 = function usePopper2(referenceElement, popperElement, options) {
+        if (options === void 0) {
+            options = {};
+        }
+        var prevOptions = React__namespace.useRef(null);
+        var optionsWithDefaults = {
+            onFirstUpdate: options.onFirstUpdate,
+            placement: options.placement || "bottom",
+            strategy: options.strategy || "absolute",
+            modifiers: options.modifiers || EMPTY_MODIFIERS$2
+        };
+        var _React$useState = React__namespace.useState({
+                styles: {
+                    popper: {
+                        position: optionsWithDefaults.strategy,
+                        left: "0",
+                        top: "0"
+                    },
+                    arrow: {
+                        position: "absolute"
+                    }
+                },
+                attributes: {}
+            }),
+            state = _React$useState[0],
+            setState = _React$useState[1];
+        var updateStateModifier = React__namespace.useMemo(function() {
+            return {
+                name: "updateState",
+                enabled: true,
+                phase: "write",
+                fn: function fn2(_ref2) {
+                    var state2 = _ref2.state;
+                    var elements = Object.keys(state2.elements);
+                    ReactDOM__namespace.flushSync(function() {
+                        setState({
+                            styles: fromEntries$1(elements.map(function(element2) {
+                                return [element2, state2.styles[element2] || {}];
+                            })),
+                            attributes: fromEntries$1(elements.map(function(element2) {
+                                return [element2, state2.attributes[element2]];
+                            }))
                         });
                     });
-                });
-            };
-            we2.autoRemove = function(e4) {
-                return !e4 || !e4.length;
-            };
-            var Re2 = function(e4, t3, n3) {
-                return e4.filter(function(e6) {
-                    return t3.some(function(t4) {
-                        var o3 = e6.values[t4];
-                        return n3.includes(o3);
-                    });
-                });
-            };
-            Re2.autoRemove = function(e4) {
-                return !e4 || !e4.length;
-            };
-            var be2 = function(e4, t3, n3) {
-                return e4.filter(function(e6) {
-                    return t3.some(function(t4) {
-                        return e6.values[t4] === n3;
-                    });
-                });
-            };
-            be2.autoRemove = function(e4) {
-                return void 0 === e4;
-            };
-            var Se2 = function(e4, t3, n3) {
-                return e4.filter(function(e6) {
-                    return t3.some(function(t4) {
-                        return e6.values[t4] == n3;
-                    });
-                });
-            };
-            Se2.autoRemove = function(e4) {
-                return null == e4;
-            };
-            var Ce2 = function(e4, t3, n3) {
-                var o3 = n3 || [],
-                    r3 = o3[0],
-                    i3 = o3[1];
-                if ((r3 = "number" == typeof r3 ? r3 : -1 / 0) > (i3 = "number" == typeof i3 ? i3 : 1 / 0)) {
-                    var u3 = r3;
-                    r3 = i3, i3 = u3;
-                }
-                return e4.filter(function(e6) {
-                    return t3.some(function(t4) {
-                        var n4 = e6.values[t4];
-                        return n4 >= r3 && n4 <= i3;
-                    });
-                });
-            };
-            Ce2.autoRemove = function(e4) {
-                return !e4 || "number" != typeof e4[0] && "number" != typeof e4[1];
+                },
+                requires: ["computeStyles"]
             };
-            var xe2 = Object.freeze({
-                __proto__: null,
-                text: ge2,
-                exactText: ve2,
-                exactTextCase: me2,
-                includes: he2,
-                includesAll: ye2,
-                includesSome: we2,
-                includesValue: Re2,
-                exact: be2,
-                equals: Se2,
-                between: Ce2
-            });
-            l2.resetFilters = "resetFilters", l2.setFilter = "setFilter", l2.setAllFilters = "setAllFilters";
-            var Pe2 = function(e4) {
-                e4.stateReducers.push(Be2), e4.useInstance.push(Ee2);
+        }, []);
+        var popperOptions = React__namespace.useMemo(function() {
+            var newOptions = {
+                onFirstUpdate: optionsWithDefaults.onFirstUpdate,
+                placement: optionsWithDefaults.placement,
+                strategy: optionsWithDefaults.strategy,
+                modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
+                    name: "applyStyles",
+                    enabled: false
+                }])
             };
-
-            function Be2(e4, t3, n3, o3) {
-                if (t3.type === l2.init)
-                    return r2({
-                        filters: []
-                    }, e4);
-                if (t3.type === l2.resetFilters)
-                    return r2({}, e4, {
-                        filters: o3.initialState.filters || []
-                    });
-                if (t3.type === l2.setFilter) {
-                    var i3 = t3.columnId,
-                        u3 = t3.filterValue,
-                        s3 = o3.allColumns,
-                        a3 = o3.filterTypes,
-                        c3 = s3.find(function(e6) {
-                            return e6.id === i3;
-                        });
-                    if (!c3)
-                        throw new Error("React-Table: Could not find a column with id: " + i3);
-                    var d3 = k2(c3.filter, a3 || {}, xe2),
-                        f3 = e4.filters.find(function(e6) {
-                            return e6.id === i3;
-                        }),
-                        p3 = m2(u3, f3 && f3.value);
-                    return H2(d3.autoRemove, p3, c3) ? r2({}, e4, {
-                        filters: e4.filters.filter(function(e6) {
-                            return e6.id !== i3;
-                        })
-                    }) : r2({}, e4, f3 ? {
-                        filters: e4.filters.map(function(e6) {
-                            return e6.id === i3 ? {
-                                id: i3,
-                                value: p3
-                            } : e6;
-                        })
-                    } : {
-                        filters: [].concat(e4.filters, [{
-                            id: i3,
-                            value: p3
-                        }])
-                    });
-                }
-                if (t3.type === l2.setAllFilters) {
-                    var g3 = t3.filters,
-                        v3 = o3.allColumns,
-                        h3 = o3.filterTypes;
-                    return r2({}, e4, {
-                        filters: m2(g3, e4.filters).filter(function(e6) {
-                            var t4 = v3.find(function(t5) {
-                                return t5.id === e6.id;
-                            });
-                            return !H2(k2(t4.filter, h3 || {}, xe2).autoRemove, e6.value, t4);
-                        })
-                    });
-                }
+            if (reactFastCompare(prevOptions.current, newOptions)) {
+                return prevOptions.current || newOptions;
+            } else {
+                prevOptions.current = newOptions;
+                return newOptions;
             }
-
-            function Ee2(e4) {
-                var n3 = e4.data,
-                    o3 = e4.rows,
-                    r3 = e4.flatRows,
-                    i3 = e4.rowsById,
-                    u3 = e4.allColumns,
-                    s3 = e4.filterTypes,
-                    a3 = e4.manualFilters,
-                    c3 = e4.defaultCanFilter,
-                    d3 = void 0 !== c3 && c3,
-                    f3 = e4.disableFilters,
-                    p3 = e4.state.filters,
-                    g3 = e4.dispatch,
-                    v3 = e4.autoResetFilters,
-                    m3 = void 0 === v3 || v3,
-                    y3 = t2.useCallback(function(e6, t3) {
-                        g3({
-                            type: l2.setFilter,
-                            columnId: e6,
-                            filterValue: t3
-                        });
-                    }, [g3]),
-                    R3 = t2.useCallback(function(e6) {
-                        g3({
-                            type: l2.setAllFilters,
-                            filters: e6
-                        });
-                    }, [g3]);
-                u3.forEach(function(e6) {
-                    var t3 = e6.id,
-                        n4 = e6.accessor,
-                        o4 = e6.defaultCanFilter,
-                        r4 = e6.disableFilters;
-                    e6.canFilter = n4 ? I2(true !== r4 && void 0, true !== f3 && void 0, true) : I2(o4, d3, false), e6.setFilter = function(t4) {
-                        return y3(e6.id, t4);
-                    };
-                    var i4 = p3.find(function(e7) {
-                        return e7.id === t3;
-                    });
-                    e6.filterValue = i4 && i4.value;
-                });
-                var b3 = t2.useMemo(function() {
-                        if (a3 || !p3.length)
-                            return [o3, r3, i3];
-                        var e6 = [],
-                            t3 = {};
-                        return [function n4(o4, r4) {
-                            void 0 === r4 && (r4 = 0);
-                            var i4 = o4;
-                            return (i4 = p3.reduce(function(e7, t4) {
-                                var n5 = t4.id,
-                                    o5 = t4.value,
-                                    i5 = u3.find(function(e8) {
-                                        return e8.id === n5;
-                                    });
-                                if (!i5)
-                                    return e7;
-                                0 === r4 && (i5.preFilteredRows = e7);
-                                var l3 = k2(i5.filter, s3 || {}, xe2);
-                                return l3 ? (i5.filteredRows = l3(e7, [n5], o5), i5.filteredRows) : (console.warn("Could not find a valid 'column.filter' for column with the ID: " + i5.id + "."), e7);
-                            }, o4)).forEach(function(o5) {
-                                e6.push(o5), t3[o5.id] = o5, o5.subRows && (o5.subRows = o5.subRows && o5.subRows.length > 0 ? n4(o5.subRows, r4 + 1) : o5.subRows);
-                            }), i4;
-                        }(o3), e6, t3];
-                    }, [a3, p3, o3, r3, i3, u3, s3]),
-                    S3 = b3[0],
-                    C3 = b3[1],
-                    x3 = b3[2];
-                t2.useMemo(function() {
-                    u3.filter(function(e6) {
-                        return !p3.find(function(t3) {
-                            return t3.id === e6.id;
-                        });
-                    }).forEach(function(e6) {
-                        e6.preFilteredRows = S3, e6.filteredRows = S3;
-                    });
-                }, [S3, p3, u3]);
-                var P3 = h2(m3);
-                w2(function() {
-                    P3() && g3({
-                        type: l2.resetFilters
-                    });
-                }, [g3, a3 ? null : n3]), Object.assign(e4, {
-                    preFilteredRows: o3,
-                    preFilteredFlatRows: r3,
-                    preFilteredRowsById: i3,
-                    filteredRows: S3,
-                    filteredFlatRows: C3,
-                    filteredRowsById: x3,
-                    rows: S3,
-                    flatRows: C3,
-                    rowsById: x3,
-                    setFilter: y3,
-                    setAllFilters: R3
-                });
+        }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
+        var popperInstanceRef = React__namespace.useRef();
+        useIsomorphicLayoutEffect$2(function() {
+            if (popperInstanceRef.current) {
+                popperInstanceRef.current.setOptions(popperOptions);
             }
-            Pe2.pluginName = "useFilters", l2.resetGlobalFilter = "resetGlobalFilter", l2.setGlobalFilter = "setGlobalFilter";
-            var Ie2 = function(e4) {
-                e4.stateReducers.push(Fe2), e4.useInstance.push(Ge2);
+        }, [popperOptions]);
+        useIsomorphicLayoutEffect$2(function() {
+            if (referenceElement == null || popperElement == null) {
+                return;
+            }
+            var createPopper$12 = options.createPopper || createPopper;
+            var popperInstance = createPopper$12(referenceElement, popperElement, popperOptions);
+            popperInstanceRef.current = popperInstance;
+            return function() {
+                popperInstance.destroy();
+                popperInstanceRef.current = null;
             };
+        }, [referenceElement, popperElement, options.createPopper]);
+        return {
+            state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
+            styles: state.styles,
+            attributes: state.attributes,
+            update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
+            forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
+        };
+    };
+    const {
+        stateChangeTypes: stateChangeTypes$3
+    } = useCombobox;
+    const Wrapper$a = styled__default.default.div`
+    display: inline-flex;
 
-            function Fe2(e4, t3, n3, o3) {
-                if (t3.type === l2.resetGlobalFilter)
-                    return r2({}, e4, {
-                        globalFilter: o3.initialState.globalFilter || void 0
-                    });
-                if (t3.type === l2.setGlobalFilter) {
-                    var u3 = t3.filterValue,
-                        s3 = o3.userFilterTypes,
-                        a3 = k2(o3.globalFilter, s3 || {}, xe2),
-                        c3 = m2(u3, e4.globalFilter);
-                    if (H2(a3.autoRemove, c3)) {
-                        e4.globalFilter;
-                        return i2(e4, ["globalFilter"]);
-                    }
-                    return r2({}, e4, {
-                        globalFilter: c3
-                    });
-                }
-            }
+    width: 100%;
+    min-width: 4rem;
+    height: 2.5rem;
 
-            function Ge2(e4) {
-                var n3 = e4.data,
-                    o3 = e4.rows,
-                    r3 = e4.flatRows,
-                    i3 = e4.rowsById,
-                    u3 = e4.allColumns,
-                    s3 = e4.filterTypes,
-                    a3 = e4.globalFilter,
-                    c3 = e4.manualGlobalFilter,
-                    d3 = e4.state.globalFilter,
-                    f3 = e4.dispatch,
-                    p3 = e4.autoResetGlobalFilter,
-                    g3 = void 0 === p3 || p3,
-                    v3 = e4.disableGlobalFilter,
-                    m3 = t2.useCallback(function(e6) {
-                        f3({
-                            type: l2.setGlobalFilter,
-                            filterValue: e6
-                        });
-                    }, [f3]),
-                    y3 = t2.useMemo(function() {
-                        if (c3 || void 0 === d3)
-                            return [o3, r3, i3];
-                        var e6 = [],
-                            t3 = {},
-                            n4 = k2(a3, s3 || {}, xe2);
-                        if (!n4)
-                            return console.warn("Could not find a valid 'globalFilter' option."), o3;
-                        u3.forEach(function(e7) {
-                            var t4 = e7.disableGlobalFilter;
-                            e7.canFilter = I2(true !== t4 && void 0, true !== v3 && void 0, true);
-                        });
-                        var l3 = u3.filter(function(e7) {
-                            return true === e7.canFilter;
-                        });
-                        return [function o4(r4) {
-                            return (r4 = n4(r4, l3.map(function(e7) {
-                                return e7.id;
-                            }), d3)).forEach(function(n5) {
-                                e6.push(n5), t3[n5.id] = n5, n5.subRows = n5.subRows && n5.subRows.length ? o4(n5.subRows) : n5.subRows;
-                            }), r4;
-                        }(o3), e6, t3];
-                    }, [c3, d3, a3, s3, u3, o3, r3, i3, v3]),
-                    R3 = y3[0],
-                    b3 = y3[1],
-                    S3 = y3[2],
-                    C3 = h2(g3);
-                w2(function() {
-                    C3() && f3({
-                        type: l2.resetGlobalFilter
-                    });
-                }, [f3, c3 ? null : n3]), Object.assign(e4, {
-                    preGlobalFilteredRows: o3,
-                    preGlobalFilteredFlatRows: r3,
-                    preGlobalFilteredRowsById: i3,
-                    globalFilteredRows: R3,
-                    globalFilteredFlatRows: b3,
-                    globalFilteredRowsById: S3,
-                    rows: R3,
-                    flatRows: b3,
-                    rowsById: S3,
-                    setGlobalFilter: m3,
-                    disableGlobalFilter: v3
-                });
-            }
+    border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0px 0px" : "0.25rem"};
 
-            function Ae2(e4, t3) {
-                return t3.reduce(function(e6, t4) {
-                    return e6 + ("number" == typeof t4 ? t4 : 0);
-                }, 0);
-            }
-            Ie2.pluginName = "useGlobalFilter";
-            var ke2 = Object.freeze({
-                    __proto__: null,
-                    sum: Ae2,
-                    min: function(e4) {
-                        var t3 = e4[0] || 0;
-                        return e4.forEach(function(e6) {
-                            "number" == typeof e6 && (t3 = Math.min(t3, e6));
-                        }), t3;
-                    },
-                    max: function(e4) {
-                        var t3 = e4[0] || 0;
-                        return e4.forEach(function(e6) {
-                            "number" == typeof e6 && (t3 = Math.max(t3, e6));
-                        }), t3;
-                    },
-                    minMax: function(e4) {
-                        var t3 = e4[0] || 0,
-                            n3 = e4[0] || 0;
-                        return e4.forEach(function(e6) {
-                            "number" == typeof e6 && (t3 = Math.min(t3, e6), n3 = Math.max(n3, e6));
-                        }), t3 + ".." + n3;
-                    },
-                    average: function(e4) {
-                        return Ae2(0, e4) / e4.length;
-                    },
-                    median: function(e4) {
-                        if (!e4.length)
-                            return null;
-                        var t3 = Math.floor(e4.length / 2),
-                            n3 = [].concat(e4).sort(function(e6, t4) {
-                                return e6 - t4;
-                            });
-                        return e4.length % 2 != 0 ? n3[t3] : (n3[t3 - 1] + n3[t3]) / 2;
-                    },
-                    unique: function(e4) {
-                        return Array.from(new Set(e4).values());
-                    },
-                    uniqueCount: function(e4) {
-                        return new Set(e4).size;
-                    },
-                    count: function(e4) {
-                        return e4.length;
-                    }
-                }),
-                He2 = [],
-                Te2 = {};
-            l2.resetGroupBy = "resetGroupBy", l2.setGroupBy = "setGroupBy", l2.toggleGroupBy = "toggleGroupBy";
-            var ze2 = function(e4) {
-                e4.getGroupByToggleProps = [We2], e4.stateReducers.push(Oe2), e4.visibleColumnsDeps.push(function(e6, t3) {
-                    var n3 = t3.instance;
-                    return [].concat(e6, [n3.state.groupBy]);
-                }), e4.visibleColumns.push(Me2), e4.useInstance.push(Ne2), e4.prepareRow.push(Le2);
-            };
-            ze2.pluginName = "useGroupBy";
-            var We2 = function(e4, t3) {
-                var n3 = t3.header;
-                return [e4, {
-                    onClick: n3.canGroupBy ? function(e6) {
-                        e6.persist(), n3.toggleGroupBy();
-                    } : void 0,
-                    style: {
-                        cursor: n3.canGroupBy ? "pointer" : void 0
-                    },
-                    title: "Toggle GroupBy"
-                }];
-            };
+    ${(props) => {
+    if (props.isDisabled) {
+      return `
+                border: 1px solid ${props.theme.colors.grey2};
 
-            function Oe2(e4, t3, n3, o3) {
-                if (t3.type === l2.init)
-                    return r2({
-                        groupBy: []
-                    }, e4);
-                if (t3.type === l2.resetGroupBy)
-                    return r2({}, e4, {
-                        groupBy: o3.initialState.groupBy || []
-                    });
-                if (t3.type === l2.setGroupBy)
-                    return r2({}, e4, {
-                        groupBy: t3.value
-                    });
-                if (t3.type === l2.toggleGroupBy) {
-                    var i3 = t3.columnId,
-                        u3 = t3.value,
-                        s3 = void 0 !== u3 ? u3 : !e4.groupBy.includes(i3);
-                    return r2({}, e4, s3 ? {
-                        groupBy: [].concat(e4.groupBy, [i3])
-                    } : {
-                        groupBy: e4.groupBy.filter(function(e6) {
-                            return e6 !== i3;
-                        })
-                    });
+                svg {
+                    color: ${props.theme.colors.grey2};
                 }
-            }
+            `;
+    }
+    if (props.isErrored) {
+      return `
+    border: 1 px solid $ {
+        props.theme.colors.error
+    };
+    `;
+    }
+    return `
+    border: 1 px solid $ {
+        props.isOpen ? props.theme.colors.grey3 : props.theme.colors.grey1
+    };: hover {
+        border: 1 px solid $ {
+            props.theme.colors.grey3
+        };
 
-            function Me2(e4, t3) {
-                var n3 = t3.instance.state.groupBy,
-                    o3 = n3.map(function(t4) {
-                        return e4.find(function(e6) {
-                            return e6.id === t4;
-                        });
-                    }).filter(Boolean),
-                    r3 = e4.filter(function(e6) {
-                        return !n3.includes(e6.id);
-                    });
-                return (e4 = [].concat(o3, r3)).forEach(function(e6) {
-                    e6.isGrouped = n3.includes(e6.id), e6.groupedIndex = n3.indexOf(e6.id);
-                }), e4;
-            }
-            var je2 = {};
+    }
+    `;
+  }}
+`;
+    const InputWrapper$4 = styled__default.default.div`
+    display: flex;
+    flex: 1 1 auto;
+    align-items: center;
+    justify-content: space-between;
 
-            function Ne2(e4) {
-                var n3 = e4.data,
-                    o3 = e4.rows,
-                    r3 = e4.flatRows,
-                    i3 = e4.rowsById,
-                    u3 = e4.allColumns,
-                    s3 = e4.flatHeaders,
-                    a3 = e4.groupByFn,
-                    c3 = void 0 === a3 ? De2 : a3,
-                    d3 = e4.manualGroupBy,
-                    p3 = e4.aggregations,
-                    g3 = void 0 === p3 ? je2 : p3,
-                    m3 = e4.plugins,
-                    y3 = e4.state.groupBy,
-                    R3 = e4.dispatch,
-                    b3 = e4.autoResetGroupBy,
-                    S3 = void 0 === b3 || b3,
-                    C3 = e4.disableGroupBy,
-                    x3 = e4.defaultCanGroupBy,
-                    P3 = e4.getHooks;
-                v2(m3, ["useColumnOrder", "useFilters"], "useGroupBy");
-                var B3 = h2(e4);
-                u3.forEach(function(t3) {
-                    var n4 = t3.accessor,
-                        o4 = t3.defaultGroupBy,
-                        r4 = t3.disableGroupBy;
-                    t3.canGroupBy = n4 ? I2(t3.canGroupBy, true !== r4 && void 0, true !== C3 && void 0, true) : I2(t3.canGroupBy, o4, x3, false), t3.canGroupBy && (t3.toggleGroupBy = function() {
-                        return e4.toggleGroupBy(t3.id);
-                    }), t3.Aggregated = t3.Aggregated || t3.Cell;
-                });
-                var E3 = t2.useCallback(function(e6, t3) {
-                        R3({
-                            type: l2.toggleGroupBy,
-                            columnId: e6,
-                            value: t3
-                        });
-                    }, [R3]),
-                    F3 = t2.useCallback(function(e6) {
-                        R3({
-                            type: l2.setGroupBy,
-                            value: e6
-                        });
-                    }, [R3]);
-                s3.forEach(function(e6) {
-                    e6.getGroupByToggleProps = f2(P3().getGroupByToggleProps, {
-                        instance: B3(),
-                        header: e6
-                    });
-                });
-                var A3 = t2.useMemo(function() {
-                        if (d3 || !y3.length)
-                            return [o3, r3, i3, He2, Te2, r3, i3];
-                        var e6 = y3.filter(function(e7) {
-                                return u3.find(function(t4) {
-                                    return t4.id === e7;
-                                });
-                            }),
-                            t3 = [],
-                            n4 = {},
-                            l3 = [],
-                            s4 = {},
-                            a4 = [],
-                            f3 = {},
-                            p4 = function o4(r4, i4, d4) {
-                                if (void 0 === i4 && (i4 = 0), i4 === e6.length)
-                                    return r4;
-                                var p5 = e6[i4],
-                                    v3 = c3(r4, p5);
-                                return Object.entries(v3).map(function(r5, c4) {
-                                    var v4 = r5[0],
-                                        m4 = r5[1],
-                                        h3 = p5 + ":" + v4,
-                                        y4 = o4(m4, i4 + 1, h3 = d4 ? d4 + ">" + h3 : h3),
-                                        w3 = i4 ? G2(m4, "leafRows") : m4,
-                                        R4 = function(t4, n5, o5) {
-                                            var r6 = {};
-                                            return u3.forEach(function(i5) {
-                                                if (e6.includes(i5.id))
-                                                    r6[i5.id] = n5[0] ? n5[0].values[i5.id] : null;
-                                                else {
-                                                    var u4 = "function" == typeof i5.aggregate ? i5.aggregate : g3[i5.aggregate] || ke2[i5.aggregate];
-                                                    if (u4) {
-                                                        var l4 = n5.map(function(e7) {
-                                                                return e7.values[i5.id];
-                                                            }),
-                                                            s5 = t4.map(function(e7) {
-                                                                var t5 = e7.values[i5.id];
-                                                                if (!o5 && i5.aggregateValue) {
-                                                                    var n6 = "function" == typeof i5.aggregateValue ? i5.aggregateValue : g3[i5.aggregateValue] || ke2[i5.aggregateValue];
-                                                                    if (!n6)
-                                                                        throw console.info({
-                                                                            column: i5
-                                                                        }), new Error("React Table: Invalid column.aggregateValue option for column listed above");
-                                                                    t5 = n6(t5, e7, i5);
-                                                                }
-                                                                return t5;
-                                                            });
-                                                        r6[i5.id] = u4(s5, l4);
-                                                    } else {
-                                                        if (i5.aggregate)
-                                                            throw console.info({
-                                                                column: i5
-                                                            }), new Error("React Table: Invalid column.aggregate option for column listed above");
-                                                        r6[i5.id] = null;
-                                                    }
-                                                }
-                                            }), r6;
-                                        }(w3, m4, i4),
-                                        b4 = {
-                                            id: h3,
-                                            isGrouped: true,
-                                            groupByID: p5,
-                                            groupByVal: v4,
-                                            values: R4,
-                                            subRows: y4,
-                                            leafRows: w3,
-                                            depth: i4,
-                                            index: c4
-                                        };
-                                    return y4.forEach(function(e7) {
-                                        t3.push(e7), n4[e7.id] = e7, e7.isGrouped ? (l3.push(e7), s4[e7.id] = e7) : (a4.push(e7), f3[e7.id] = e7);
-                                    }), b4;
-                                });
-                            }(o3);
-                        return p4.forEach(function(e7) {
-                            t3.push(e7), n4[e7.id] = e7, e7.isGrouped ? (l3.push(e7), s4[e7.id] = e7) : (a4.push(e7), f3[e7.id] = e7);
-                        }), [p4, t3, n4, l3, s4, a4, f3];
-                    }, [d3, y3, o3, r3, i3, u3, g3, c3]),
-                    k3 = A3[0],
-                    H3 = A3[1],
-                    T3 = A3[2],
-                    z3 = A3[3],
-                    W3 = A3[4],
-                    O3 = A3[5],
-                    M3 = A3[6],
-                    j3 = h2(S3);
-                w2(function() {
-                    j3() && R3({
-                        type: l2.resetGroupBy
-                    });
-                }, [R3, d3 ? null : n3]), Object.assign(e4, {
-                    preGroupedRows: o3,
-                    preGroupedFlatRow: r3,
-                    preGroupedRowsById: i3,
-                    groupedRows: k3,
-                    groupedFlatRows: H3,
-                    groupedRowsById: T3,
-                    onlyGroupedFlatRows: z3,
-                    onlyGroupedRowsById: W3,
-                    nonGroupedFlatRows: O3,
-                    nonGroupedRowsById: M3,
-                    rows: k3,
-                    flatRows: H3,
-                    rowsById: T3,
-                    toggleGroupBy: E3,
-                    setGroupBy: F3
-                });
-            }
+    width: calc(100% - 1rem);
+    height: 100%;
+    padding: 0 0.25rem 0 1rem;
 
-            function Le2(e4) {
-                e4.allCells.forEach(function(t3) {
-                    var n3;
-                    t3.isGrouped = t3.column.isGrouped && t3.column.id === e4.groupByID, t3.isPlaceholder = !t3.isGrouped && t3.column.isGrouped, t3.isAggregated = !t3.isGrouped && !t3.isPlaceholder && (null == (n3 = e4.subRows) ? void 0 : n3.length);
-                });
-            }
+    color: ${(props) => props.disabled ? props.theme.colors.grey2 : props.theme.colors.text};
 
-            function De2(e4, t3) {
-                return e4.reduce(function(e6, n3, o3) {
-                    var r3 = "" + n3.values[t3];
-                    return e6[r3] = Array.isArray(e6[r3]) ? e6[r3] : [], e6[r3].push(n3), e6;
-                }, {});
-            }
-            var Ve2 = /([0-9]+)/gm;
+    background-color: ${(props) => props.theme.colors.grey1};
+    border: none;
+    border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0px 0px" : "0.25rem"};
 
-            function _e2(e4, t3) {
-                return e4 === t3 ? 0 : e4 > t3 ? 1 : -1;
-            }
+    :hover {
+        background-color: ${(props) => props.disabled ? props.theme.colors.grey1 : props.theme.colors.grey2};
+    }
 
-            function Xe2(e4, t3, n3) {
-                return [e4.values[n3], t3.values[n3]];
-            }
+    svg {
+        height: 0.8rem;
+    }
+`;
+    const Input$2 = styled__default.default.input`
+    overflow: hidden;
+    flex: 1 1 auto;
 
-            function qe2(e4) {
-                return "number" == typeof e4 ? isNaN(e4) || e4 === 1 / 0 || e4 === -1 / 0 ? "" : String(e4) : "string" == typeof e4 ? e4 : "";
-            }
-            var Ke2 = Object.freeze({
-                __proto__: null,
-                alphanumeric: function(e4, t3, n3) {
-                    var o3 = Xe2(e4, t3, n3),
-                        r3 = o3[0],
-                        i3 = o3[1];
-                    for (r3 = qe2(r3), i3 = qe2(i3), r3 = r3.split(Ve2).filter(Boolean), i3 = i3.split(Ve2).filter(Boolean); r3.length && i3.length;) {
-                        var u3 = r3.shift(),
-                            l3 = i3.shift(),
-                            s3 = parseInt(u3, 10),
-                            a3 = parseInt(l3, 10),
-                            c3 = [s3, a3].sort();
-                        if (isNaN(c3[0])) {
-                            if (u3 > l3)
-                                return 1;
-                            if (l3 > u3)
-                                return -1;
-                        } else {
-                            if (isNaN(c3[1]))
-                                return isNaN(s3) ? -1 : 1;
-                            if (s3 > a3)
-                                return 1;
-                            if (a3 > s3)
-                                return -1;
-                        }
-                    }
-                    return r3.length - i3.length;
-                },
-                datetime: function(e4, t3, n3) {
-                    var o3 = Xe2(e4, t3, n3),
-                        r3 = o3[0],
-                        i3 = o3[1];
-                    return _e2(r3 = r3.getTime(), i3 = i3.getTime());
-                },
-                basic: function(e4, t3, n3) {
-                    var o3 = Xe2(e4, t3, n3);
-                    return _e2(o3[0], o3[1]);
-                },
-                string: function(e4, t3, n3) {
-                    var o3 = Xe2(e4, t3, n3),
-                        r3 = o3[0],
-                        i3 = o3[1];
-                    for (r3 = r3.split("").filter(Boolean), i3 = i3.split("").filter(Boolean); r3.length && i3.length;) {
-                        var u3 = r3.shift(),
-                            l3 = i3.shift(),
-                            s3 = u3.toLowerCase(),
-                            a3 = l3.toLowerCase();
-                        if (s3 > a3)
-                            return 1;
-                        if (a3 > s3)
-                            return -1;
-                        if (u3 > l3)
-                            return 1;
-                        if (l3 > u3)
-                            return -1;
+    height: 100%;
+    margin-right: 0.5rem;
+    padding: 0;
+
+    font-size: ${(props) => props.size ? `${props.size}rem` : props.theme.font.size};
+    font-weight: 300;
+    color: ${(props) => props.theme.colors.text};
+    text-align: left;
+    text-overflow: ellipsis;
+    white-space: nowrap;
+
+    background-color: transparent;
+    border: none;
+    outline: 0;
+
+    :disabled {
+        cursor: not-allowed;
+        color: ${(props) => props.theme.colors.grey2};
+    }
+`;
+    const NoItemsLabel$1 = styled__default.default.span`
+    display: flex;
+    flex: 1 1 auto;
+    align-items: center;
+    justify-content: center;
+
+    height: 2rem;
+
+    font-size: 1rem;
+    color: ${(props) => props.theme.colors.text};
+
+    background-color: ${(props) => props.theme.colors.blue1};
+`;
+    const DropdownList$3 = styled__default.default(List)`
+    margin-left: -1px;
+    border-radius: 0 0 0.25rem 0.25rem;
+    box-shadow: ${(props) => props.theme.shadow.light};
+`;
+    const ChevronButton$1 = styled__default.default(Button$3).attrs((attrs2) => Object.assign(Object.assign({}, attrs2), {
+        styling: "ghost"
+    }))`
+    min-width: 0;
+    height: auto;
+    margin: 0;
+    padding: 0 0.25rem;
+
+    background-color: transparent !important;
+`;
+
+    function ComboBox(props) {
+        var _a3, _b, _c, _d, _e2, _f, _g;
+        const referenceElement = React.useRef(null);
+        const popperElement = React.useRef(null);
+        const {
+            styles: styles2,
+            attributes: attributes2,
+            update: update2
+        } = usePopper$1(referenceElement.current, popperElement.current, {
+            modifiers: [sameWidthModifier],
+            placement: "bottom-start"
+        });
+        const [inputValue, setInputValue] = React.useState((_d = (_b = (_a3 = props.initialValue) === null || _a3 === void 0 ? void 0 : _a3.label) !== null && _b !== void 0 ? _b : (_c = props.selectedItem) === null || _c === void 0 ? void 0 : _c.label) !== null && _d !== void 0 ? _d : "");
+        const [pendingHighlight, setPendingHighlight] = React.useState(null);
+        const filteredItems = props.items.filter((item) => {
+            var _a4;
+            return inputValue ? (_a4 = item.label) === null || _a4 === void 0 ? void 0 : _a4.toLowerCase().includes(inputValue === null || inputValue === void 0 ? void 0 : inputValue.toLowerCase()) : true;
+        });
+        const {
+            selectedItem,
+            isOpen,
+            getMenuProps,
+            getInputProps,
+            getToggleButtonProps,
+            highlightedIndex,
+            getItemProps,
+            setHighlightedIndex
+        } = useCombobox(Object.assign({
+            initialIsOpen: props.initialIsOpen,
+            initialSelectedItem: (_e2 = props.initialValue) !== null && _e2 !== void 0 ? _e2 : props.selectedItem,
+            itemToString: (item) => item ? item.label : "",
+            items: filteredItems,
+            onInputValueChange: (change) => {
+                setInputValue(change.inputValue);
+            },
+            onSelectedItemChange: (changes) => {
+                var _a4, _b2;
+                if (props.onSelect) {
+                    if (props.selectedItem && ((_a4 = changes.selectedItem) === null || _a4 === void 0 ? void 0 : _a4.value) !== ((_b2 = props.selectedItem) === null || _b2 === void 0 ? void 0 : _b2.value) || !props.selectedItem) {
+                        props.onSelect(changes.selectedItem);
                     }
-                    return r3.length - i3.length;
-                },
-                number: function(e4, t3, n3) {
-                    var o3 = Xe2(e4, t3, n3),
-                        r3 = o3[0],
-                        i3 = o3[1],
-                        u3 = /[^0-9.]/gi;
-                    return _e2(r3 = Number(String(r3).replace(u3, "")), i3 = Number(String(i3).replace(u3, "")));
                 }
-            });
-            l2.resetSortBy = "resetSortBy", l2.setSortBy = "setSortBy", l2.toggleSortBy = "toggleSortBy", l2.clearSortBy = "clearSortBy", c2.sortType = "alphanumeric", c2.sortDescFirst = false;
-            var Ue2 = function(e4) {
-                e4.getSortByToggleProps = [$e2], e4.stateReducers.push(Je2), e4.useInstance.push(Ye2);
-            };
-            Ue2.pluginName = "useSortBy";
-            var $e2 = function(e4, t3) {
-                var n3 = t3.instance,
-                    o3 = t3.column,
-                    r3 = n3.isMultiSortEvent,
-                    i3 = void 0 === r3 ? function(e6) {
-                        return e6.shiftKey;
-                    } : r3;
-                return [e4, {
-                    onClick: o3.canSort ? function(e6) {
-                        e6.persist(), o3.toggleSortBy(void 0, !n3.disableMultiSort && i3(e6));
-                    } : void 0,
-                    style: {
-                        cursor: o3.canSort ? "pointer" : void 0
-                    },
-                    title: o3.canSort ? "Toggle SortBy" : void 0
-                }];
-            };
-
-            function Je2(e4, t3, n3, o3) {
-                if (t3.type === l2.init)
-                    return r2({
-                        sortBy: []
-                    }, e4);
-                if (t3.type === l2.resetSortBy)
-                    return r2({}, e4, {
-                        sortBy: o3.initialState.sortBy || []
-                    });
-                if (t3.type === l2.clearSortBy)
-                    return r2({}, e4, {
-                        sortBy: e4.sortBy.filter(function(e6) {
-                            return e6.id !== t3.columnId;
-                        })
-                    });
-                if (t3.type === l2.setSortBy)
-                    return r2({}, e4, {
-                        sortBy: t3.sortBy
+            },
+            stateReducer: (state, {
+                changes,
+                type: type2
+            }) => {
+                var _a4;
+                if (type2 === stateChangeTypes$3.InputFocus || type2 === stateChangeTypes$3.ToggleButtonClick && changes.isOpen || type2 === stateChangeTypes$3.ControlledPropUpdatedSelectedItem && changes.isOpen) {
+                    setPendingHighlight(changes.selectedItem ? props.items.findIndex((i2) => i2.value === changes.selectedItem.value) : 0);
+                    return Object.assign(Object.assign({}, changes), {
+                        inputValue: ""
                     });
-                if (t3.type === l2.toggleSortBy) {
-                    var i3, u3 = t3.columnId,
-                        s3 = t3.desc,
-                        a3 = t3.multi,
-                        c3 = o3.allColumns,
-                        d3 = o3.disableMultiSort,
-                        f3 = o3.disableSortRemove,
-                        p3 = o3.disableMultiRemove,
-                        g3 = o3.maxMultiSortColCount,
-                        v3 = void 0 === g3 ? Number.MAX_SAFE_INTEGER : g3,
-                        m3 = e4.sortBy,
-                        h3 = c3.find(function(e6) {
-                            return e6.id === u3;
-                        }).sortDescFirst,
-                        y3 = m3.find(function(e6) {
-                            return e6.id === u3;
-                        }),
-                        w3 = m3.findIndex(function(e6) {
-                            return e6.id === u3;
-                        }),
-                        R3 = null != s3,
-                        b3 = [];
-                    return "toggle" !== (i3 = !d3 && a3 ? y3 ? "toggle" : "add" : w3 !== m3.length - 1 || 1 !== m3.length ? "replace" : y3 ? "toggle" : "replace") || f3 || R3 || a3 && p3 || !(y3 && y3.desc && !h3 || !y3.desc && h3) || (i3 = "remove"), "replace" === i3 ? b3 = [{
-                        id: u3,
-                        desc: R3 ? s3 : h3
-                    }] : "add" === i3 ? (b3 = [].concat(m3, [{
-                        id: u3,
-                        desc: R3 ? s3 : h3
-                    }])).splice(0, b3.length - v3) : "toggle" === i3 ? b3 = m3.map(function(e6) {
-                        return e6.id === u3 ? r2({}, e6, {
-                            desc: R3 ? s3 : !y3.desc
-                        }) : e6;
-                    }) : "remove" === i3 && (b3 = m3.filter(function(e6) {
-                        return e6.id !== u3;
-                    })), r2({}, e4, {
-                        sortBy: b3
+                }
+                if ([
+                        stateChangeTypes$3.InputKeyDownEnter,
+                        stateChangeTypes$3.ItemClick,
+                        stateChangeTypes$3.InputBlur,
+                        stateChangeTypes$3.InputKeyDownEscape,
+                        stateChangeTypes$3.ToggleButtonClick
+                    ].includes(type2)) {
+                    return Object.assign(Object.assign({}, changes), {
+                        inputValue: ((_a4 = changes.selectedItem) === null || _a4 === void 0 ? void 0 : _a4.label) || ""
                     });
                 }
+                return changes;
             }
-
-            function Ye2(e4) {
-                var n3 = e4.data,
-                    o3 = e4.rows,
-                    r3 = e4.flatRows,
-                    i3 = e4.allColumns,
-                    u3 = e4.orderByFn,
-                    s3 = void 0 === u3 ? Qe2 : u3,
-                    a3 = e4.sortTypes,
-                    c3 = e4.manualSortBy,
-                    d3 = e4.defaultCanSort,
-                    p3 = e4.disableSortBy,
-                    g3 = e4.flatHeaders,
-                    m3 = e4.state.sortBy,
-                    y3 = e4.dispatch,
-                    R3 = e4.plugins,
-                    b3 = e4.getHooks,
-                    S3 = e4.autoResetSortBy,
-                    C3 = void 0 === S3 || S3;
-                v2(R3, ["useFilters", "useGlobalFilter", "useGroupBy", "usePivotColumns"], "useSortBy");
-                var x3 = t2.useCallback(function(e6) {
-                        y3({
-                            type: l2.setSortBy,
-                            sortBy: e6
-                        });
-                    }, [y3]),
-                    P3 = t2.useCallback(function(e6, t3, n4) {
-                        y3({
-                            type: l2.toggleSortBy,
-                            columnId: e6,
-                            desc: t3,
-                            multi: n4
-                        });
-                    }, [y3]),
-                    B3 = h2(e4);
-                g3.forEach(function(e6) {
-                    var t3 = e6.accessor,
-                        n4 = e6.canSort,
-                        o4 = e6.disableSortBy,
-                        r4 = e6.id,
-                        i4 = t3 ? I2(true !== o4 && void 0, true !== p3 && void 0, true) : I2(d3, n4, false);
-                    e6.canSort = i4, e6.canSort && (e6.toggleSortBy = function(t4, n5) {
-                        return P3(e6.id, t4, n5);
-                    }, e6.clearSortBy = function() {
-                        y3({
-                            type: l2.clearSortBy,
-                            columnId: e6.id
-                        });
-                    }), e6.getSortByToggleProps = f2(b3().getSortByToggleProps, {
-                        instance: B3(),
-                        column: e6
-                    });
-                    var u4 = m3.find(function(e7) {
-                        return e7.id === r4;
-                    });
-                    e6.isSorted = !!u4, e6.sortedIndex = m3.findIndex(function(e7) {
-                        return e7.id === r4;
-                    }), e6.isSortedDesc = e6.isSorted ? u4.desc : void 0;
-                });
-                var E3 = t2.useMemo(function() {
-                        if (c3 || !m3.length)
-                            return [o3, r3];
-                        var e6 = [],
-                            t3 = m3.filter(function(e7) {
-                                return i3.find(function(t4) {
-                                    return t4.id === e7.id;
-                                });
-                            });
-                        return [function n4(o4) {
-                            var r4 = s3(o4, t3.map(function(e7) {
-                                var t4 = i3.find(function(t5) {
-                                    return t5.id === e7.id;
-                                });
-                                if (!t4)
-                                    throw new Error("React-Table: Could not find a column with id: " + e7.id + " while sorting");
-                                var n5 = t4.sortType,
-                                    o5 = F2(n5) || (a3 || {})[n5] || Ke2[n5];
-                                if (!o5)
-                                    throw new Error("React-Table: Could not find a valid sortType of '" + n5 + "' for column '" + e7.id + "'.");
-                                return function(t5, n6) {
-                                    return o5(t5, n6, e7.id, e7.desc);
-                                };
-                            }), t3.map(function(e7) {
-                                var t4 = i3.find(function(t5) {
-                                    return t5.id === e7.id;
-                                });
-                                return t4 && t4.sortInverted ? e7.desc : !e7.desc;
-                            }));
-                            return r4.forEach(function(t4) {
-                                e6.push(t4), t4.subRows && 0 !== t4.subRows.length && (t4.subRows = n4(t4.subRows));
-                            }), r4;
-                        }(o3), e6];
-                    }, [c3, m3, o3, r3, i3, s3, a3]),
-                    G3 = E3[0],
-                    A3 = E3[1],
-                    k3 = h2(C3);
-                w2(function() {
-                    k3() && y3({
-                        type: l2.resetSortBy
-                    });
-                }, [c3 ? null : n3]), Object.assign(e4, {
-                    preSortedRows: o3,
-                    preSortedFlatRows: r3,
-                    sortedRows: G3,
-                    sortedFlatRows: A3,
-                    rows: G3,
-                    flatRows: A3,
-                    setSortBy: x3,
-                    toggleSortBy: P3
-                });
+        }, "selectedItem" in props && {
+            selectedItem: props.selectedItem
+        }));
+        React.useEffect(() => {
+            if (isOpen && pendingHighlight !== null) {
+                setHighlightedIndex(pendingHighlight);
+                setPendingHighlight(null);
+            }
+        }, [isOpen, pendingHighlight, setHighlightedIndex]);
+        React.useEffect(() => {
+            if (props.selectedItem === null) {
+                setInputValue("");
+            }
+        }, [props.selectedItem]);
+        React.useEffect(() => {
+            if (isOpen && update2) {
+                update2();
             }
+        }, [isOpen, update2]);
+        const menuProps = getMenuProps();
+        const setMenuRef = menuProps.ref;
+        delete menuProps.ref;
+        const setMenuReference = (value) => {
+            setMenuRef(value);
+            popperElement.current = value;
+        };
+        return jsxRuntime.exports.jsx(Tooltip$1, {
+            content: props.errorMsg,
+            disabled: !props.errorMsg,
+            styling: "error",
+            children: jsxRuntime.exports.jsxs(Wrapper$a, {
+                className: props.className,
+                isDisabled: props.disabled,
+                isErrored: !!props.errorMsg,
+                isOpen,
+                style: props.style,
+                children: [jsxRuntime.exports.jsxs(InputWrapper$4, {
+                    disabled: props.disabled,
+                    isOpen,
+                    ref: referenceElement,
+                    children: [jsxRuntime.exports.jsx(Input$2, Object.assign({}, getInputProps({
+                        disabled: props.disabled
+                    }), {
+                        placeholder: (_f = selectedItem === null ? props.placeholder : selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.label) !== null && _f !== void 0 ? _f : props.placeholder,
+                        size: props.size
+                    })), jsxRuntime.exports.jsx(ChevronButton$1, Object.assign({}, getToggleButtonProps(), {
+                        children: jsxRuntime.exports.jsx(Chevron$2, {
+                            disabled: props.disabled,
+                            isOpen
+                        })
+                    }))]
+                }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsxs(DropdownList$3, Object.assign({}, menuProps, attributes2.popper, {
+                    isOpen,
+                    ref: setMenuReference,
+                    style: Object.assign(Object.assign({}, styles2.popper), {
+                        width: parseFloat((_g = styles2.popper) === null || _g === void 0 ? void 0 : _g.width) + 2,
+                        zIndex: 9999
+                    }),
+                    children: [filteredItems.length > 0 && filteredItems.map((item, index2) => React.createElement(ListItem, Object.assign({}, getItemProps({
+                        index: index2,
+                        item
+                    }), {
+                        hovered: index2 === highlightedIndex,
+                        key: `item-${index2}`,
+                        size: props.size,
+                        title: item.label
+                    }), item.label)), filteredItems.length === 0 && jsxRuntime.exports.jsx(NoItemsLabel$1, {
+                        children: "No Items"
+                    })]
+                })), document.body)]
+            })
+        });
+    }
+    styled__default.default(List)`
+    overflow-y: auto;
+    box-shadow: ${(props) => props.theme.shadow.light};
+`;
+    var dateFormats$1 = {
+        full: "EEEE, d MMMM yyyy",
+        long: "d MMMM yyyy",
+        medium: "d MMM yyyy",
+        short: "dd/MM/yyyy"
+    };
+    var timeFormats$1 = {
+        full: "HH:mm:ss zzzz",
+        long: "HH:mm:ss z",
+        medium: "HH:mm:ss",
+        short: "HH:mm"
+    };
+    var dateTimeFormats$1 = {
+        full: "{{date}} 'at' {{time}}",
+        long: "{{date}} 'at' {{time}}",
+        medium: "{{date}}, {{time}}",
+        short: "{{date}}, {{time}}"
+    };
+    var formatLong$2 = {
+        date: buildFormatLongFn$1({
+            formats: dateFormats$1,
+            defaultWidth: "full"
+        }),
+        time: buildFormatLongFn$1({
+            formats: timeFormats$1,
+            defaultWidth: "full"
+        }),
+        dateTime: buildFormatLongFn$1({
+            formats: dateTimeFormats$1,
+            defaultWidth: "full"
+        })
+    };
+    const formatLong$3 = formatLong$2;
+    var locale$1 = {
+        code: "en-GB",
+        formatDistance: formatDistance$2,
+        formatLong: formatLong$3,
+        formatRelative: formatRelative$2,
+        localize: localize$3,
+        match: match$4,
+        options: {
+            weekStartsOn: 1,
+            firstWeekContainsDate: 4
+        }
+    };
+    const enGB = locale$1;
+    var classnames = {
+        exports: {}
+    };
+    /*!
+    	Copyright (c) 2018 Jed Watson.
+    	Licensed under the MIT License (MIT), see
+    	http://jedwatson.github.io/classnames
+    */
+    (function(module2) {
+        (function() {
+            var hasOwn2 = {}.hasOwnProperty;
 
-            function Qe2(e4, t3, n3) {
-                return [].concat(e4).sort(function(e6, o3) {
-                    for (var r3 = 0; r3 < t3.length; r3 += 1) {
-                        var i3 = t3[r3],
-                            u3 = false === n3[r3] || "desc" === n3[r3],
-                            l3 = i3(e6, o3);
-                        if (0 !== l3)
-                            return u3 ? -l3 : l3;
+            function classNames() {
+                var classes = "";
+                for (var i2 = 0; i2 < arguments.length; i2++) {
+                    var arg = arguments[i2];
+                    if (arg) {
+                        classes = appendClass(classes, parseValue(arg));
                     }
-                    return n3[0] ? e6.index - o3.index : o3.index - e6.index;
-                });
+                }
+                return classes;
             }
-            l2.resetPage = "resetPage", l2.gotoPage = "gotoPage", l2.setPageSize = "setPageSize";
-            var Ze2 = function(e4) {
-                e4.stateReducers.push(et2), e4.useInstance.push(tt2);
-            };
 
-            function et2(e4, t3, n3, o3) {
-                if (t3.type === l2.init)
-                    return r2({
-                        pageSize: 10,
-                        pageIndex: 0
-                    }, e4);
-                if (t3.type === l2.resetPage)
-                    return r2({}, e4, {
-                        pageIndex: o3.initialState.pageIndex || 0
-                    });
-                if (t3.type === l2.gotoPage) {
-                    var i3 = o3.pageCount,
-                        u3 = o3.page,
-                        s3 = m2(t3.pageIndex, e4.pageIndex),
-                        a3 = false;
-                    return s3 > e4.pageIndex ? a3 = -1 === i3 ? u3.length >= e4.pageSize : s3 < i3 : s3 < e4.pageIndex && (a3 = s3 > -1), a3 ? r2({}, e4, {
-                        pageIndex: s3
-                    }) : e4;
+            function parseValue(arg) {
+                if (typeof arg === "string" || typeof arg === "number") {
+                    return arg;
                 }
-                if (t3.type === l2.setPageSize) {
-                    var c3 = t3.pageSize,
-                        d3 = e4.pageSize * e4.pageIndex;
-                    return r2({}, e4, {
-                        pageIndex: Math.floor(d3 / c3),
-                        pageSize: c3
-                    });
+                if (typeof arg !== "object") {
+                    return "";
                 }
+                if (Array.isArray(arg)) {
+                    return classNames.apply(null, arg);
+                }
+                if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
+                    return arg.toString();
+                }
+                var classes = "";
+                for (var key in arg) {
+                    if (hasOwn2.call(arg, key) && arg[key]) {
+                        classes = appendClass(classes, key);
+                    }
+                }
+                return classes;
             }
 
-            function tt2(e4) {
-                var n3 = e4.rows,
-                    o3 = e4.autoResetPage,
-                    r3 = void 0 === o3 || o3,
-                    i3 = e4.manualExpandedKey,
-                    u3 = void 0 === i3 ? "expanded" : i3,
-                    s3 = e4.plugins,
-                    a3 = e4.pageCount,
-                    c3 = e4.paginateExpandedRows,
-                    d3 = void 0 === c3 || c3,
-                    f3 = e4.expandSubRows,
-                    p3 = void 0 === f3 || f3,
-                    g3 = e4.state,
-                    m3 = g3.pageSize,
-                    y3 = g3.pageIndex,
-                    R3 = g3.expanded,
-                    b3 = g3.globalFilter,
-                    S3 = g3.filters,
-                    C3 = g3.groupBy,
-                    x3 = g3.sortBy,
-                    P3 = e4.dispatch,
-                    B3 = e4.data,
-                    E3 = e4.manualPagination;
-                v2(s3, ["useGlobalFilter", "useFilters", "useGroupBy", "useSortBy", "useExpanded"], "usePagination");
-                var I3 = h2(r3);
-                w2(function() {
-                    I3() && P3({
-                        type: l2.resetPage
-                    });
-                }, [P3, E3 ? null : B3, b3, S3, C3, x3]);
-                var F3 = E3 ? a3 : Math.ceil(n3.length / m3),
-                    G3 = t2.useMemo(function() {
-                        return F3 > 0 ? [].concat(new Array(F3)).fill(null).map(function(e6, t3) {
-                            return t3;
-                        }) : [];
-                    }, [F3]),
-                    k3 = t2.useMemo(function() {
-                        var e6;
-                        if (E3)
-                            e6 = n3;
-                        else {
-                            var t3 = m3 * y3,
-                                o4 = t3 + m3;
-                            e6 = n3.slice(t3, o4);
-                        }
-                        return d3 ? e6 : A2(e6, {
-                            manualExpandedKey: u3,
-                            expanded: R3,
-                            expandSubRows: p3
-                        });
-                    }, [p3, R3, u3, E3, y3, m3, d3, n3]),
-                    H3 = y3 > 0,
-                    T3 = -1 === F3 ? k3.length >= m3 : y3 < F3 - 1,
-                    z3 = t2.useCallback(function(e6) {
-                        P3({
-                            type: l2.gotoPage,
-                            pageIndex: e6
-                        });
-                    }, [P3]),
-                    W3 = t2.useCallback(function() {
-                        return z3(function(e6) {
-                            return e6 - 1;
-                        });
-                    }, [z3]),
-                    O3 = t2.useCallback(function() {
-                        return z3(function(e6) {
-                            return e6 + 1;
-                        });
-                    }, [z3]),
-                    M3 = t2.useCallback(function(e6) {
-                        P3({
-                            type: l2.setPageSize,
-                            pageSize: e6
-                        });
-                    }, [P3]);
-                Object.assign(e4, {
-                    pageOptions: G3,
-                    pageCount: F3,
-                    page: k3,
-                    canPreviousPage: H3,
-                    canNextPage: T3,
-                    gotoPage: z3,
-                    previousPage: W3,
-                    nextPage: O3,
-                    setPageSize: M3
-                });
-            }
-            Ze2.pluginName = "usePagination", l2.resetPivot = "resetPivot", l2.togglePivot = "togglePivot";
-            var nt2 = function(e4) {
-                e4.getPivotToggleProps = [rt2], e4.stateReducers.push(it2), e4.useInstanceAfterData.push(ut2), e4.allColumns.push(lt2), e4.accessValue.push(st2), e4.materializedColumns.push(at2), e4.materializedColumnsDeps.push(ct2), e4.visibleColumns.push(dt2), e4.visibleColumnsDeps.push(ft2), e4.useInstance.push(pt2), e4.prepareRow.push(gt2);
-            };
-            nt2.pluginName = "usePivotColumns";
-            var ot2 = [],
-                rt2 = function(e4, t3) {
-                    var n3 = t3.header;
-                    return [e4, {
-                        onClick: n3.canPivot ? function(e6) {
-                            e6.persist(), n3.togglePivot();
-                        } : void 0,
-                        style: {
-                            cursor: n3.canPivot ? "pointer" : void 0
-                        },
-                        title: "Toggle Pivot"
-                    }];
-                };
-
-            function it2(e4, t3, n3, o3) {
-                if (t3.type === l2.init)
-                    return r2({
-                        pivotColumns: ot2
-                    }, e4);
-                if (t3.type === l2.resetPivot)
-                    return r2({}, e4, {
-                        pivotColumns: o3.initialState.pivotColumns || ot2
-                    });
-                if (t3.type === l2.togglePivot) {
-                    var i3 = t3.columnId,
-                        u3 = t3.value,
-                        s3 = void 0 !== u3 ? u3 : !e4.pivotColumns.includes(i3);
-                    return r2({}, e4, s3 ? {
-                        pivotColumns: [].concat(e4.pivotColumns, [i3])
-                    } : {
-                        pivotColumns: e4.pivotColumns.filter(function(e6) {
-                            return e6 !== i3;
-                        })
-                    });
+            function appendClass(value, newClass) {
+                if (!newClass) {
+                    return value;
+                }
+                if (value) {
+                    return value + " " + newClass;
                 }
+                return value + newClass;
             }
-
-            function ut2(e4) {
-                e4.allColumns.forEach(function(t3) {
-                    t3.isPivotSource = e4.state.pivotColumns.includes(t3.id);
-                });
+            if (module2.exports) {
+                classNames.default = classNames;
+                module2.exports = classNames;
+            } else {
+                window.classNames = classNames;
             }
+        })();
+    })(classnames);
+    const r$1 = classnames.exports;
 
-            function lt2(e4, t3) {
-                var n3 = t3.instance;
-                return e4.forEach(function(e6) {
-                    e6.isPivotSource = n3.state.pivotColumns.includes(e6.id), e6.uniqueValues = /* @__PURE__ */ new Set();
-                }), e4;
-            }
+    function _typeof$5(o2) {
+        "@babel/helpers - typeof";
+        return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
+            return typeof o3;
+        } : function(o3) {
+            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
+        }, _typeof$5(o2);
+    }
 
-            function st2(e4, t3) {
-                var n3 = t3.column;
-                return n3.uniqueValues && void 0 !== e4 && n3.uniqueValues.add(e4), e4;
-            }
+    function requiredArgs(required2, args) {
+        if (args.length < required2) {
+            throw new TypeError(required2 + " argument" + (required2 > 1 ? "s" : "") + " required, but only " + args.length + " present");
+        }
+    }
 
-            function at2(e4, t3) {
-                var n3 = t3.instance,
-                    o3 = n3.allColumns,
-                    i3 = n3.state;
-                if (!i3.pivotColumns.length || !i3.groupBy || !i3.groupBy.length)
-                    return e4;
-                var u3 = i3.pivotColumns.map(function(e6) {
-                        return o3.find(function(t4) {
-                            return t4.id === e6;
-                        });
-                    }).filter(Boolean),
-                    l3 = o3.filter(function(e6) {
-                        return !e6.isPivotSource && !i3.groupBy.includes(e6.id) && !i3.pivotColumns.includes(e6.id);
-                    }),
-                    s3 = C2(function e6(t4, n4, o4) {
-                        void 0 === t4 && (t4 = 0), void 0 === o4 && (o4 = []);
-                        var i4 = u3[t4];
-                        return i4 ? Array.from(i4.uniqueValues).sort().map(function(u4) {
-                            var l4 = r2({}, i4, {
-                                Header: i4.PivotHeader || "string" == typeof i4.header ? i4.Header + ": " + u4 : u4,
-                                isPivotGroup: true,
-                                parent: n4,
-                                depth: t4,
-                                id: n4 ? n4.id + "." + i4.id + "." + u4 : i4.id + "." + u4,
-                                pivotValue: u4
-                            });
-                            return l4.columns = e6(t4 + 1, l4, [].concat(o4, [function(e7) {
-                                return e7.values[i4.id] === u4;
-                            }])), l4;
-                        }) : l3.map(function(e7) {
-                            return r2({}, e7, {
-                                canPivot: false,
-                                isPivoted: true,
-                                parent: n4,
-                                depth: t4,
-                                id: "" + (n4 ? n4.id + "." + e7.id : e7.id),
-                                accessor: function(t5, n5, r3) {
-                                    if (o4.every(function(e8) {
-                                            return e8(r3);
-                                        }))
-                                        return r3.values[e7.id];
-                                }
-                            });
-                        });
-                    }());
-                return [].concat(e4, s3);
-            }
+    function isDate$1(value) {
+        requiredArgs(1, arguments);
+        return value instanceof Date || _typeof$5(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
+    }
 
-            function ct2(e4, t3) {
-                var n3 = t3.instance.state,
-                    o3 = n3.pivotColumns,
-                    r3 = n3.groupBy;
-                return [].concat(e4, [o3, r3]);
+    function toDate(argument) {
+        requiredArgs(1, arguments);
+        var argStr = Object.prototype.toString.call(argument);
+        if (argument instanceof Date || _typeof$5(argument) === "object" && argStr === "[object Date]") {
+            return new Date(argument.getTime());
+        } else if (typeof argument === "number" || argStr === "[object Number]") {
+            return new Date(argument);
+        } else {
+            if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
+                console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
+                console.warn(new Error().stack);
             }
+            return new Date(NaN);
+        }
+    }
 
-            function dt2(e4, t3) {
-                var n3 = t3.instance.state;
-                return e4 = e4.filter(function(e6) {
-                    return !e6.isPivotSource;
-                }), n3.pivotColumns.length && n3.groupBy && n3.groupBy.length && (e4 = e4.filter(function(e6) {
-                    return e6.isGrouped || e6.isPivoted;
-                })), e4;
-            }
+    function isValid(dirtyDate) {
+        requiredArgs(1, arguments);
+        if (!isDate$1(dirtyDate) && typeof dirtyDate !== "number") {
+            return false;
+        }
+        var date = toDate(dirtyDate);
+        return !isNaN(Number(date));
+    }
 
-            function ft2(e4, t3) {
-                var n3 = t3.instance;
-                return [].concat(e4, [n3.state.pivotColumns, n3.state.groupBy]);
-            }
+    function toInteger$2(dirtyNumber) {
+        if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
+            return NaN;
+        }
+        var number2 = Number(dirtyNumber);
+        if (isNaN(number2)) {
+            return number2;
+        }
+        return number2 < 0 ? Math.ceil(number2) : Math.floor(number2);
+    }
 
-            function pt2(e4) {
-                var t3 = e4.columns,
-                    n3 = e4.allColumns,
-                    o3 = e4.flatHeaders,
-                    r3 = e4.getHooks,
-                    i3 = e4.plugins,
-                    u3 = e4.dispatch,
-                    s3 = e4.autoResetPivot,
-                    a3 = void 0 === s3 || s3,
-                    c3 = e4.manaulPivot,
-                    d3 = e4.disablePivot,
-                    p3 = e4.defaultCanPivot;
-                v2(i3, ["useGroupBy"], "usePivotColumns");
-                var g3 = h2(e4);
-                n3.forEach(function(t4) {
-                    var n4 = t4.accessor,
-                        o4 = t4.defaultPivot,
-                        r4 = t4.disablePivot;
-                    t4.canPivot = n4 ? I2(t4.canPivot, true !== r4 && void 0, true !== d3 && void 0, true) : I2(t4.canPivot, o4, p3, false), t4.canPivot && (t4.togglePivot = function() {
-                        return e4.togglePivot(t4.id);
-                    }), t4.Aggregated = t4.Aggregated || t4.Cell;
-                });
-                o3.forEach(function(e6) {
-                    e6.getPivotToggleProps = f2(r3().getPivotToggleProps, {
-                        instance: g3(),
-                        header: e6
+    function addMilliseconds(dirtyDate, dirtyAmount) {
+        requiredArgs(2, arguments);
+        var timestamp = toDate(dirtyDate).getTime();
+        var amount = toInteger$2(dirtyAmount);
+        return new Date(timestamp + amount);
+    }
+
+    function subMilliseconds(dirtyDate, dirtyAmount) {
+        requiredArgs(2, arguments);
+        var amount = toInteger$2(dirtyAmount);
+        return addMilliseconds(dirtyDate, -amount);
+    }
+    var MILLISECONDS_IN_DAY$1 = 864e5;
+
+    function getUTCDayOfYear(dirtyDate) {
+        requiredArgs(1, arguments);
+        var date = toDate(dirtyDate);
+        var timestamp = date.getTime();
+        date.setUTCMonth(0, 1);
+        date.setUTCHours(0, 0, 0, 0);
+        var startOfYearTimestamp = date.getTime();
+        var difference = timestamp - startOfYearTimestamp;
+        return Math.floor(difference / MILLISECONDS_IN_DAY$1) + 1;
+    }
+
+    function startOfUTCISOWeek(dirtyDate) {
+        requiredArgs(1, arguments);
+        var weekStartsOn = 1;
+        var date = toDate(dirtyDate);
+        var day = date.getUTCDay();
+        var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
+        date.setUTCDate(date.getUTCDate() - diff);
+        date.setUTCHours(0, 0, 0, 0);
+        return date;
+    }
+
+    function getUTCISOWeekYear(dirtyDate) {
+        requiredArgs(1, arguments);
+        var date = toDate(dirtyDate);
+        var year = date.getUTCFullYear();
+        var fourthOfJanuaryOfNextYear = new Date(0);
+        fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
+        fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
+        var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
+        var fourthOfJanuaryOfThisYear = new Date(0);
+        fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
+        fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
+        var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
+        if (date.getTime() >= startOfNextYear.getTime()) {
+            return year + 1;
+        } else if (date.getTime() >= startOfThisYear.getTime()) {
+            return year;
+        } else {
+            return year - 1;
+        }
+    }
+
+    function startOfUTCISOWeekYear(dirtyDate) {
+        requiredArgs(1, arguments);
+        var year = getUTCISOWeekYear(dirtyDate);
+        var fourthOfJanuary = new Date(0);
+        fourthOfJanuary.setUTCFullYear(year, 0, 4);
+        fourthOfJanuary.setUTCHours(0, 0, 0, 0);
+        var date = startOfUTCISOWeek(fourthOfJanuary);
+        return date;
+    }
+    var MILLISECONDS_IN_WEEK$2 = 6048e5;
+
+    function getUTCISOWeek(dirtyDate) {
+        requiredArgs(1, arguments);
+        var date = toDate(dirtyDate);
+        var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
+        return Math.round(diff / MILLISECONDS_IN_WEEK$2) + 1;
+    }
+    var defaultOptions = {};
+
+    function getDefaultOptions() {
+        return defaultOptions;
+    }
+
+    function startOfUTCWeek(dirtyDate, options) {
+        var _ref2, _ref22, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
+        requiredArgs(1, arguments);
+        var defaultOptions2 = getDefaultOptions();
+        var weekStartsOn = toInteger$2((_ref2 = (_ref22 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : 0);
+        if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
+            throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
+        }
+        var date = toDate(dirtyDate);
+        var day = date.getUTCDay();
+        var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
+        date.setUTCDate(date.getUTCDate() - diff);
+        date.setUTCHours(0, 0, 0, 0);
+        return date;
+    }
+
+    function getUTCWeekYear(dirtyDate, options) {
+        var _ref2, _ref22, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
+        requiredArgs(1, arguments);
+        var date = toDate(dirtyDate);
+        var year = date.getUTCFullYear();
+        var defaultOptions2 = getDefaultOptions();
+        var firstWeekContainsDate = toInteger$2((_ref2 = (_ref22 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
+        if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
+            throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
+        }
+        var firstWeekOfNextYear = new Date(0);
+        firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
+        firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
+        var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
+        var firstWeekOfThisYear = new Date(0);
+        firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
+        firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
+        var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
+        if (date.getTime() >= startOfNextYear.getTime()) {
+            return year + 1;
+        } else if (date.getTime() >= startOfThisYear.getTime()) {
+            return year;
+        } else {
+            return year - 1;
+        }
+    }
+
+    function startOfUTCWeekYear(dirtyDate, options) {
+        var _ref2, _ref22, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
+        requiredArgs(1, arguments);
+        var defaultOptions2 = getDefaultOptions();
+        var firstWeekContainsDate = toInteger$2((_ref2 = (_ref22 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
+        var year = getUTCWeekYear(dirtyDate, options);
+        var firstWeek = new Date(0);
+        firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
+        firstWeek.setUTCHours(0, 0, 0, 0);
+        var date = startOfUTCWeek(firstWeek, options);
+        return date;
+    }
+    var MILLISECONDS_IN_WEEK$1 = 6048e5;
+
+    function getUTCWeek(dirtyDate, options) {
+        requiredArgs(1, arguments);
+        var date = toDate(dirtyDate);
+        var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
+        return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
+    }
+
+    function addLeadingZeros(number2, targetLength) {
+        var sign2 = number2 < 0 ? "-" : "";
+        var output2 = Math.abs(number2).toString();
+        while (output2.length < targetLength) {
+            output2 = "0" + output2;
+        }
+        return sign2 + output2;
+    }
+    var formatters$2 = {
+        y: function y2(date, token) {
+            var signedYear = date.getUTCFullYear();
+            var year = signedYear > 0 ? signedYear : 1 - signedYear;
+            return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
+        },
+        M: function M2(date, token) {
+            var month = date.getUTCMonth();
+            return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
+        },
+        d: function d2(date, token) {
+            return addLeadingZeros(date.getUTCDate(), token.length);
+        },
+        a: function a2(date, token) {
+            var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
+            switch (token) {
+                case "a":
+                case "aa":
+                    return dayPeriodEnumValue.toUpperCase();
+                case "aaa":
+                    return dayPeriodEnumValue;
+                case "aaaaa":
+                    return dayPeriodEnumValue[0];
+                case "aaaa":
+                default:
+                    return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
+            }
+        },
+        h: function h2(date, token) {
+            return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
+        },
+        H: function H2(date, token) {
+            return addLeadingZeros(date.getUTCHours(), token.length);
+        },
+        m: function m2(date, token) {
+            return addLeadingZeros(date.getUTCMinutes(), token.length);
+        },
+        s: function s2(date, token) {
+            return addLeadingZeros(date.getUTCSeconds(), token.length);
+        },
+        S: function S2(date, token) {
+            var numberOfDigits = token.length;
+            var milliseconds = date.getUTCMilliseconds();
+            var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
+            return addLeadingZeros(fractionalSeconds, token.length);
+        }
+    };
+    const lightFormatters = formatters$2;
+    var dayPeriodEnum = {
+        am: "am",
+        pm: "pm",
+        midnight: "midnight",
+        noon: "noon",
+        morning: "morning",
+        afternoon: "afternoon",
+        evening: "evening",
+        night: "night"
+    };
+    var formatters = {
+        G: function G2(date, token, localize2) {
+            var era = date.getUTCFullYear() > 0 ? 1 : 0;
+            switch (token) {
+                case "G":
+                case "GG":
+                case "GGG":
+                    return localize2.era(era, {
+                        width: "abbreviated"
                     });
-                });
-                var m3 = h2(a3);
-                w2(function() {
-                    m3() && u3({
-                        type: l2.resetPivot
+                case "GGGGG":
+                    return localize2.era(era, {
+                        width: "narrow"
                     });
-                }, [u3, c3 ? null : t3]), Object.assign(e4, {
-                    togglePivot: function(e6, t4) {
-                        u3({
-                            type: l2.togglePivot,
-                            columnId: e6,
-                            value: t4
-                        });
-                    }
+                case "GGGG":
+                default:
+                    return localize2.era(era, {
+                        width: "wide"
+                    });
+            }
+        },
+        y: function y2(date, token, localize2) {
+            if (token === "yo") {
+                var signedYear = date.getUTCFullYear();
+                var year = signedYear > 0 ? signedYear : 1 - signedYear;
+                return localize2.ordinalNumber(year, {
+                    unit: "year"
                 });
             }
-
-            function gt2(e4) {
-                e4.allCells.forEach(function(e6) {
-                    e6.isPivoted = e6.column.isPivoted;
+            return lightFormatters.y(date, token);
+        },
+        Y: function Y2(date, token, localize2, options) {
+            var signedWeekYear = getUTCWeekYear(date, options);
+            var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
+            if (token === "YY") {
+                var twoDigitYear = weekYear % 100;
+                return addLeadingZeros(twoDigitYear, 2);
+            }
+            if (token === "Yo") {
+                return localize2.ordinalNumber(weekYear, {
+                    unit: "year"
                 });
             }
-            l2.resetSelectedRows = "resetSelectedRows", l2.toggleAllRowsSelected = "toggleAllRowsSelected", l2.toggleRowSelected = "toggleRowSelected", l2.toggleAllPageRowsSelected = "toggleAllPageRowsSelected";
-            var vt2 = function(e4) {
-                e4.getToggleRowSelectedProps = [mt2], e4.getToggleAllRowsSelectedProps = [ht2], e4.getToggleAllPageRowsSelectedProps = [yt2], e4.stateReducers.push(wt2), e4.useInstance.push(Rt2), e4.prepareRow.push(bt2);
-            };
-            vt2.pluginName = "useRowSelect";
-            var mt2 = function(e4, t3) {
-                    var n3 = t3.instance,
-                        o3 = t3.row,
-                        r3 = n3.manualRowSelectedKey,
-                        i3 = void 0 === r3 ? "isSelected" : r3;
-                    return [e4, {
-                        onChange: function(e6) {
-                            o3.toggleRowSelected(e6.target.checked);
-                        },
-                        style: {
-                            cursor: "pointer"
-                        },
-                        checked: !(!o3.original || !o3.original[i3]) || o3.isSelected,
-                        title: "Toggle Row Selected",
-                        indeterminate: o3.isSomeSelected
-                    }];
-                },
-                ht2 = function(e4, t3) {
-                    var n3 = t3.instance;
-                    return [e4, {
-                        onChange: function(e6) {
-                            n3.toggleAllRowsSelected(e6.target.checked);
-                        },
-                        style: {
-                            cursor: "pointer"
-                        },
-                        checked: n3.isAllRowsSelected,
-                        title: "Toggle All Rows Selected",
-                        indeterminate: Boolean(!n3.isAllRowsSelected && Object.keys(n3.state.selectedRowIds).length)
-                    }];
-                },
-                yt2 = function(e4, t3) {
-                    var n3 = t3.instance;
-                    return [e4, {
-                        onChange: function(e6) {
-                            n3.toggleAllPageRowsSelected(e6.target.checked);
-                        },
-                        style: {
-                            cursor: "pointer"
-                        },
-                        checked: n3.isAllPageRowsSelected,
-                        title: "Toggle All Current Page Rows Selected",
-                        indeterminate: Boolean(!n3.isAllPageRowsSelected && n3.page.some(function(e6) {
-                            var t4 = e6.id;
-                            return n3.state.selectedRowIds[t4];
-                        }))
-                    }];
-                };
-
-            function wt2(e4, t3, n3, o3) {
-                if (t3.type === l2.init)
-                    return r2({
-                        selectedRowIds: {}
-                    }, e4);
-                if (t3.type === l2.resetSelectedRows)
-                    return r2({}, e4, {
-                        selectedRowIds: o3.initialState.selectedRowIds || {}
+            return addLeadingZeros(weekYear, token.length);
+        },
+        R: function R2(date, token) {
+            var isoWeekYear = getUTCISOWeekYear(date);
+            return addLeadingZeros(isoWeekYear, token.length);
+        },
+        u: function u2(date, token) {
+            var year = date.getUTCFullYear();
+            return addLeadingZeros(year, token.length);
+        },
+        Q: function Q2(date, token, localize2) {
+            var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
+            switch (token) {
+                case "Q":
+                    return String(quarter);
+                case "QQ":
+                    return addLeadingZeros(quarter, 2);
+                case "Qo":
+                    return localize2.ordinalNumber(quarter, {
+                        unit: "quarter"
                     });
-                if (t3.type === l2.toggleAllRowsSelected) {
-                    var i3 = t3.value,
-                        u3 = o3.isAllRowsSelected,
-                        s3 = o3.rowsById,
-                        a3 = o3.nonGroupedRowsById,
-                        c3 = void 0 === a3 ? s3 : a3,
-                        d3 = void 0 !== i3 ? i3 : !u3,
-                        f3 = Object.assign({}, e4.selectedRowIds);
-                    return d3 ? Object.keys(c3).forEach(function(e6) {
-                        f3[e6] = true;
-                    }) : Object.keys(c3).forEach(function(e6) {
-                        delete f3[e6];
-                    }), r2({}, e4, {
-                        selectedRowIds: f3
+                case "QQQ":
+                    return localize2.quarter(quarter, {
+                        width: "abbreviated",
+                        context: "formatting"
                     });
-                }
-                if (t3.type === l2.toggleRowSelected) {
-                    var p3 = t3.id,
-                        g3 = t3.value,
-                        v3 = o3.rowsById,
-                        m3 = o3.selectSubRows,
-                        h3 = void 0 === m3 || m3,
-                        y3 = o3.getSubRows,
-                        w3 = e4.selectedRowIds[p3],
-                        R3 = void 0 !== g3 ? g3 : !w3;
-                    if (w3 === R3)
-                        return e4;
-                    var b3 = r2({}, e4.selectedRowIds);
-                    return function e6(t4) {
-                        var n4 = v3[t4];
-                        if (n4.isGrouped || (R3 ? b3[t4] = true : delete b3[t4]), h3 && y3(n4))
-                            return y3(n4).forEach(function(t5) {
-                                return e6(t5.id);
-                            });
-                    }(p3), r2({}, e4, {
-                        selectedRowIds: b3
+                case "QQQQQ":
+                    return localize2.quarter(quarter, {
+                        width: "narrow",
+                        context: "formatting"
                     });
-                }
-                if (t3.type === l2.toggleAllPageRowsSelected) {
-                    var S3 = t3.value,
-                        C3 = o3.page,
-                        x3 = o3.rowsById,
-                        P3 = o3.selectSubRows,
-                        B3 = void 0 === P3 || P3,
-                        E3 = o3.isAllPageRowsSelected,
-                        I3 = o3.getSubRows,
-                        F3 = void 0 !== S3 ? S3 : !E3,
-                        G3 = r2({}, e4.selectedRowIds);
-                    return C3.forEach(function(e6) {
-                        return function e7(t4) {
-                            var n4 = x3[t4];
-                            if (n4.isGrouped || (F3 ? G3[t4] = true : delete G3[t4]), B3 && I3(n4))
-                                return I3(n4).forEach(function(t5) {
-                                    return e7(t5.id);
-                                });
-                        }(e6.id);
-                    }), r2({}, e4, {
-                        selectedRowIds: G3
+                case "QQQQ":
+                default:
+                    return localize2.quarter(quarter, {
+                        width: "wide",
+                        context: "formatting"
                     });
-                }
-                return e4;
             }
-
-            function Rt2(e4) {
-                var n3 = e4.data,
-                    o3 = e4.rows,
-                    r3 = e4.getHooks,
-                    i3 = e4.plugins,
-                    u3 = e4.rowsById,
-                    s3 = e4.nonGroupedRowsById,
-                    a3 = void 0 === s3 ? u3 : s3,
-                    c3 = e4.autoResetSelectedRows,
-                    d3 = void 0 === c3 || c3,
-                    p3 = e4.state.selectedRowIds,
-                    g3 = e4.selectSubRows,
-                    m3 = void 0 === g3 || g3,
-                    y3 = e4.dispatch,
-                    R3 = e4.page,
-                    b3 = e4.getSubRows;
-                v2(i3, ["useFilters", "useGroupBy", "useSortBy", "useExpanded", "usePagination"], "useRowSelect");
-                var S3 = t2.useMemo(function() {
-                        var e6 = [];
-                        return o3.forEach(function(t3) {
-                            var n4 = m3 ? function e7(t4, n5, o4) {
-                                if (n5[t4.id])
-                                    return true;
-                                var r4 = o4(t4);
-                                if (r4 && r4.length) {
-                                    var i4 = true,
-                                        u4 = false;
-                                    return r4.forEach(function(t5) {
-                                        u4 && !i4 || (e7(t5, n5, o4) ? u4 = true : i4 = false);
-                                    }), !!i4 || !!u4 && null;
-                                }
-                                return false;
-                            }(t3, p3, b3) : !!p3[t3.id];
-                            t3.isSelected = !!n4, t3.isSomeSelected = null === n4, n4 && e6.push(t3);
-                        }), e6;
-                    }, [o3, m3, p3, b3]),
-                    C3 = Boolean(Object.keys(a3).length && Object.keys(p3).length),
-                    x3 = C3;
-                C3 && Object.keys(a3).some(function(e6) {
-                    return !p3[e6];
-                }) && (C3 = false), C3 || R3 && R3.length && R3.some(function(e6) {
-                    var t3 = e6.id;
-                    return !p3[t3];
-                }) && (x3 = false);
-                var P3 = h2(d3);
-                w2(function() {
-                    P3() && y3({
-                        type: l2.resetSelectedRows
+        },
+        q: function q2(date, token, localize2) {
+            var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
+            switch (token) {
+                case "q":
+                    return String(quarter);
+                case "qq":
+                    return addLeadingZeros(quarter, 2);
+                case "qo":
+                    return localize2.ordinalNumber(quarter, {
+                        unit: "quarter"
                     });
-                }, [y3, n3]);
-                var B3 = t2.useCallback(function(e6) {
-                        return y3({
-                            type: l2.toggleAllRowsSelected,
-                            value: e6
-                        });
-                    }, [y3]),
-                    E3 = t2.useCallback(function(e6) {
-                        return y3({
-                            type: l2.toggleAllPageRowsSelected,
-                            value: e6
-                        });
-                    }, [y3]),
-                    I3 = t2.useCallback(function(e6, t3) {
-                        return y3({
-                            type: l2.toggleRowSelected,
-                            id: e6,
-                            value: t3
-                        });
-                    }, [y3]),
-                    F3 = h2(e4),
-                    G3 = f2(r3().getToggleAllRowsSelectedProps, {
-                        instance: F3()
-                    }),
-                    A3 = f2(r3().getToggleAllPageRowsSelectedProps, {
-                        instance: F3()
+                case "qqq":
+                    return localize2.quarter(quarter, {
+                        width: "abbreviated",
+                        context: "standalone"
+                    });
+                case "qqqqq":
+                    return localize2.quarter(quarter, {
+                        width: "narrow",
+                        context: "standalone"
+                    });
+                case "qqqq":
+                default:
+                    return localize2.quarter(quarter, {
+                        width: "wide",
+                        context: "standalone"
                     });
-                Object.assign(e4, {
-                    selectedFlatRows: S3,
-                    isAllRowsSelected: C3,
-                    isAllPageRowsSelected: x3,
-                    toggleRowSelected: I3,
-                    toggleAllRowsSelected: B3,
-                    getToggleAllRowsSelectedProps: G3,
-                    getToggleAllPageRowsSelectedProps: A3,
-                    toggleAllPageRowsSelected: E3
-                });
-            }
-
-            function bt2(e4, t3) {
-                var n3 = t3.instance;
-                e4.toggleRowSelected = function(t4) {
-                    return n3.toggleRowSelected(e4.id, t4);
-                }, e4.getToggleRowSelectedProps = f2(n3.getHooks().getToggleRowSelectedProps, {
-                    instance: n3,
-                    row: e4
-                });
             }
-            var St2 = function(e4) {
-                    return {};
-                },
-                Ct2 = function(e4) {
-                    return {};
-                };
-            l2.setRowState = "setRowState", l2.setCellState = "setCellState", l2.resetRowState = "resetRowState";
-            var xt2 = function(e4) {
-                e4.stateReducers.push(Pt2), e4.useInstance.push(Bt2), e4.prepareRow.push(Et2);
-            };
-
-            function Pt2(e4, t3, n3, o3) {
-                var i3 = o3.initialRowStateAccessor,
-                    u3 = void 0 === i3 ? St2 : i3,
-                    s3 = o3.initialCellStateAccessor,
-                    a3 = void 0 === s3 ? Ct2 : s3,
-                    c3 = o3.rowsById;
-                if (t3.type === l2.init)
-                    return r2({
-                        rowState: {}
-                    }, e4);
-                if (t3.type === l2.resetRowState)
-                    return r2({}, e4, {
-                        rowState: o3.initialState.rowState || {}
+        },
+        M: function M2(date, token, localize2) {
+            var month = date.getUTCMonth();
+            switch (token) {
+                case "M":
+                case "MM":
+                    return lightFormatters.M(date, token);
+                case "Mo":
+                    return localize2.ordinalNumber(month + 1, {
+                        unit: "month"
                     });
-                if (t3.type === l2.setRowState) {
-                    var d3, f3 = t3.rowId,
-                        p3 = t3.value,
-                        g3 = void 0 !== e4.rowState[f3] ? e4.rowState[f3] : u3(c3[f3]);
-                    return r2({}, e4, {
-                        rowState: r2({}, e4.rowState, (d3 = {}, d3[f3] = m2(p3, g3), d3))
+                case "MMM":
+                    return localize2.month(month, {
+                        width: "abbreviated",
+                        context: "formatting"
                     });
-                }
-                if (t3.type === l2.setCellState) {
-                    var v3, h3, y3, w3, R3, b3 = t3.rowId,
-                        S3 = t3.columnId,
-                        C3 = t3.value,
-                        x3 = void 0 !== e4.rowState[b3] ? e4.rowState[b3] : u3(c3[b3]),
-                        P3 = void 0 !== (null == x3 ? void 0 : null == (v3 = x3.cellState) ? void 0 : v3[S3]) ? x3.cellState[S3] : a3(null == (h3 = c3[b3]) ? void 0 : null == (y3 = h3.cells) ? void 0 : y3.find(function(e6) {
-                            return e6.column.id === S3;
-                        }));
-                    return r2({}, e4, {
-                        rowState: r2({}, e4.rowState, (R3 = {}, R3[b3] = r2({}, x3, {
-                            cellState: r2({}, x3.cellState || {}, (w3 = {}, w3[S3] = m2(C3, P3), w3))
-                        }), R3))
+                case "MMMMM":
+                    return localize2.month(month, {
+                        width: "narrow",
+                        context: "formatting"
+                    });
+                case "MMMM":
+                default:
+                    return localize2.month(month, {
+                        width: "wide",
+                        context: "formatting"
                     });
-                }
             }
-
-            function Bt2(e4) {
-                var n3 = e4.autoResetRowState,
-                    o3 = void 0 === n3 || n3,
-                    r3 = e4.data,
-                    i3 = e4.dispatch,
-                    u3 = t2.useCallback(function(e6, t3) {
-                        return i3({
-                            type: l2.setRowState,
-                            rowId: e6,
-                            value: t3
-                        });
-                    }, [i3]),
-                    s3 = t2.useCallback(function(e6, t3, n4) {
-                        return i3({
-                            type: l2.setCellState,
-                            rowId: e6,
-                            columnId: t3,
-                            value: n4
-                        });
-                    }, [i3]),
-                    a3 = h2(o3);
-                w2(function() {
-                    a3() && i3({
-                        type: l2.resetRowState
+        },
+        L: function L2(date, token, localize2) {
+            var month = date.getUTCMonth();
+            switch (token) {
+                case "L":
+                    return String(month + 1);
+                case "LL":
+                    return addLeadingZeros(month + 1, 2);
+                case "Lo":
+                    return localize2.ordinalNumber(month + 1, {
+                        unit: "month"
                     });
-                }, [r3]), Object.assign(e4, {
-                    setRowState: u3,
-                    setCellState: s3
+                case "LLL":
+                    return localize2.month(month, {
+                        width: "abbreviated",
+                        context: "standalone"
+                    });
+                case "LLLLL":
+                    return localize2.month(month, {
+                        width: "narrow",
+                        context: "standalone"
+                    });
+                case "LLLL":
+                default:
+                    return localize2.month(month, {
+                        width: "wide",
+                        context: "standalone"
+                    });
+            }
+        },
+        w: function w2(date, token, localize2, options) {
+            var week = getUTCWeek(date, options);
+            if (token === "wo") {
+                return localize2.ordinalNumber(week, {
+                    unit: "week"
                 });
             }
-
-            function Et2(e4, t3) {
-                var n3 = t3.instance,
-                    o3 = n3.initialRowStateAccessor,
-                    r3 = void 0 === o3 ? St2 : o3,
-                    i3 = n3.initialCellStateAccessor,
-                    u3 = void 0 === i3 ? Ct2 : i3,
-                    l3 = n3.state.rowState;
-                e4 && (e4.state = void 0 !== l3[e4.id] ? l3[e4.id] : r3(e4), e4.setState = function(t4) {
-                    return n3.setRowState(e4.id, t4);
-                }, e4.cells.forEach(function(t4) {
-                    e4.state.cellState || (e4.state.cellState = {}), t4.state = void 0 !== e4.state.cellState[t4.column.id] ? e4.state.cellState[t4.column.id] : u3(t4), t4.setState = function(o4) {
-                        return n3.setCellState(e4.id, t4.column.id, o4);
-                    };
-                }));
+            return addLeadingZeros(week, token.length);
+        },
+        I: function I2(date, token, localize2) {
+            var isoWeek = getUTCISOWeek(date);
+            if (token === "Io") {
+                return localize2.ordinalNumber(isoWeek, {
+                    unit: "week"
+                });
             }
-            xt2.pluginName = "useRowState", l2.resetColumnOrder = "resetColumnOrder", l2.setColumnOrder = "setColumnOrder";
-            var It2 = function(e4) {
-                e4.stateReducers.push(Ft2), e4.visibleColumnsDeps.push(function(e6, t3) {
-                    var n3 = t3.instance;
-                    return [].concat(e6, [n3.state.columnOrder]);
-                }), e4.visibleColumns.push(Gt2), e4.useInstance.push(At2);
-            };
-
-            function Ft2(e4, t3, n3, o3) {
-                return t3.type === l2.init ? r2({
-                    columnOrder: []
-                }, e4) : t3.type === l2.resetColumnOrder ? r2({}, e4, {
-                    columnOrder: o3.initialState.columnOrder || []
-                }) : t3.type === l2.setColumnOrder ? r2({}, e4, {
-                    columnOrder: m2(t3.columnOrder, e4.columnOrder)
-                }) : void 0;
+            return addLeadingZeros(isoWeek, token.length);
+        },
+        d: function d2(date, token, localize2) {
+            if (token === "do") {
+                return localize2.ordinalNumber(date.getUTCDate(), {
+                    unit: "date"
+                });
             }
-
-            function Gt2(e4, t3) {
-                var n3 = t3.instance.state.columnOrder;
-                if (!n3 || !n3.length)
-                    return e4;
-                for (var o3 = [].concat(n3), r3 = [].concat(e4), i3 = [], u3 = function() {
-                        var e6 = o3.shift(),
-                            t4 = r3.findIndex(function(t5) {
-                                return t5.id === e6;
-                            });
-                        t4 > -1 && i3.push(r3.splice(t4, 1)[0]);
-                    }; r3.length && o3.length;)
-                    u3();
-                return [].concat(i3, r3);
+            return lightFormatters.d(date, token);
+        },
+        D: function D2(date, token, localize2) {
+            var dayOfYear = getUTCDayOfYear(date);
+            if (token === "Do") {
+                return localize2.ordinalNumber(dayOfYear, {
+                    unit: "dayOfYear"
+                });
             }
-
-            function At2(e4) {
-                var n3 = e4.dispatch;
-                e4.setColumnOrder = t2.useCallback(function(e6) {
-                    return n3({
-                        type: l2.setColumnOrder,
-                        columnOrder: e6
+            return addLeadingZeros(dayOfYear, token.length);
+        },
+        E: function E2(date, token, localize2) {
+            var dayOfWeek = date.getUTCDay();
+            switch (token) {
+                case "E":
+                case "EE":
+                case "EEE":
+                    return localize2.day(dayOfWeek, {
+                        width: "abbreviated",
+                        context: "formatting"
                     });
-                }, [n3]);
-            }
-            It2.pluginName = "useColumnOrder", c2.canResize = true, l2.columnStartResizing = "columnStartResizing", l2.columnResizing = "columnResizing", l2.columnDoneResizing = "columnDoneResizing", l2.resetResize = "resetResize";
-            var kt2 = function(e4) {
-                    e4.getResizerProps = [Ht2], e4.getHeaderProps.push({
-                        style: {
-                            position: "relative"
-                        }
-                    }), e4.stateReducers.push(Tt2), e4.useInstance.push(Wt2), e4.useInstanceBeforeDimensions.push(zt2);
-                },
-                Ht2 = function(e4, t3) {
-                    var n3 = t3.instance,
-                        o3 = t3.header,
-                        r3 = n3.dispatch,
-                        i3 = function(e6, t4) {
-                            var n4 = false;
-                            if ("touchstart" === e6.type) {
-                                if (e6.touches && e6.touches.length > 1)
-                                    return;
-                                n4 = true;
-                            }
-                            var o4 = function(e7) {
-                                    var t5 = [];
-                                    return function e8(n5) {
-                                        n5.columns && n5.columns.length && n5.columns.map(e8);
-                                        t5.push(n5);
-                                    }(e7), t5;
-                                }(t4).map(function(e7) {
-                                    return [e7.id, e7.totalWidth];
-                                }),
-                                i4 = n4 ? Math.round(e6.touches[0].clientX) : e6.clientX,
-                                u3 = function(e7) {
-                                    r3({
-                                        type: l2.columnResizing,
-                                        clientX: e7
-                                    });
-                                },
-                                s3 = function() {
-                                    return r3({
-                                        type: l2.columnDoneResizing
-                                    });
-                                },
-                                a3 = {
-                                    mouse: {
-                                        moveEvent: "mousemove",
-                                        moveHandler: function(e7) {
-                                            return u3(e7.clientX);
-                                        },
-                                        upEvent: "mouseup",
-                                        upHandler: function(e7) {
-                                            document.removeEventListener("mousemove", a3.mouse.moveHandler), document.removeEventListener("mouseup", a3.mouse.upHandler), s3();
-                                        }
-                                    },
-                                    touch: {
-                                        moveEvent: "touchmove",
-                                        moveHandler: function(e7) {
-                                            return e7.cancelable && (e7.preventDefault(), e7.stopPropagation()), u3(e7.touches[0].clientX), false;
-                                        },
-                                        upEvent: "touchend",
-                                        upHandler: function(e7) {
-                                            document.removeEventListener(a3.touch.moveEvent, a3.touch.moveHandler), document.removeEventListener(a3.touch.upEvent, a3.touch.moveHandler), s3();
-                                        }
-                                    }
-                                },
-                                c3 = n4 ? a3.touch : a3.mouse,
-                                d3 = !! function() {
-                                    if ("boolean" == typeof z2)
-                                        return z2;
-                                    var e7 = false;
-                                    try {
-                                        var t5 = {
-                                            get passive() {
-                                                return e7 = true, false;
-                                            }
-                                        };
-                                        window.addEventListener("test", null, t5), window.removeEventListener("test", null, t5);
-                                    } catch (t6) {
-                                        e7 = false;
-                                    }
-                                    return z2 = e7;
-                                }() && {
-                                    passive: false
-                                };
-                            document.addEventListener(c3.moveEvent, c3.moveHandler, d3), document.addEventListener(c3.upEvent, c3.upHandler, d3), r3({
-                                type: l2.columnStartResizing,
-                                columnId: t4.id,
-                                columnWidth: t4.totalWidth,
-                                headerIdWidths: o4,
-                                clientX: i4
-                            });
-                        };
-                    return [e4, {
-                        onMouseDown: function(e6) {
-                            return e6.persist() || i3(e6, o3);
-                        },
-                        onTouchStart: function(e6) {
-                            return e6.persist() || i3(e6, o3);
-                        },
-                        style: {
-                            cursor: "col-resize"
-                        },
-                        draggable: false,
-                        role: "separator"
-                    }];
-                };
-
-            function Tt2(e4, t3) {
-                if (t3.type === l2.init)
-                    return r2({
-                        columnResizing: {
-                            columnWidths: {}
-                        }
-                    }, e4);
-                if (t3.type === l2.resetResize)
-                    return r2({}, e4, {
-                        columnResizing: {
-                            columnWidths: {}
-                        }
+                case "EEEEE":
+                    return localize2.day(dayOfWeek, {
+                        width: "narrow",
+                        context: "formatting"
                     });
-                if (t3.type === l2.columnStartResizing) {
-                    var n3 = t3.clientX,
-                        o3 = t3.columnId,
-                        i3 = t3.columnWidth,
-                        u3 = t3.headerIdWidths;
-                    return r2({}, e4, {
-                        columnResizing: r2({}, e4.columnResizing, {
-                            startX: n3,
-                            headerIdWidths: u3,
-                            columnWidth: i3,
-                            isResizingColumn: o3
-                        })
+                case "EEEEEE":
+                    return localize2.day(dayOfWeek, {
+                        width: "short",
+                        context: "formatting"
                     });
-                }
-                if (t3.type === l2.columnResizing) {
-                    var s3 = t3.clientX,
-                        a3 = e4.columnResizing,
-                        c3 = a3.startX,
-                        d3 = a3.columnWidth,
-                        f3 = a3.headerIdWidths,
-                        p3 = (s3 - c3) / d3,
-                        g3 = {};
-                    return (void 0 === f3 ? [] : f3).forEach(function(e6) {
-                        var t4 = e6[0],
-                            n4 = e6[1];
-                        g3[t4] = Math.max(n4 + n4 * p3, 0);
-                    }), r2({}, e4, {
-                        columnResizing: r2({}, e4.columnResizing, {
-                            columnWidths: r2({}, e4.columnResizing.columnWidths, {}, g3)
-                        })
+                case "EEEE":
+                default:
+                    return localize2.day(dayOfWeek, {
+                        width: "wide",
+                        context: "formatting"
                     });
-                }
-                return t3.type === l2.columnDoneResizing ? r2({}, e4, {
-                    columnResizing: r2({}, e4.columnResizing, {
-                        startX: null,
-                        isResizingColumn: null
-                    })
-                }) : void 0;
             }
-            kt2.pluginName = "useResizeColumns";
-            var zt2 = function(e4) {
-                var t3 = e4.flatHeaders,
-                    n3 = e4.disableResizing,
-                    o3 = e4.getHooks,
-                    r3 = e4.state.columnResizing,
-                    i3 = h2(e4);
-                t3.forEach(function(e6) {
-                    var t4 = I2(true !== e6.disableResizing && void 0, true !== n3 && void 0, true);
-                    e6.canResize = t4, e6.width = r3.columnWidths[e6.id] || e6.originalWidth || e6.width, e6.isResizing = r3.isResizingColumn === e6.id, t4 && (e6.getResizerProps = f2(o3().getResizerProps, {
-                        instance: i3(),
-                        header: e6
-                    }));
-                });
-            };
-
-            function Wt2(e4) {
-                var n3 = e4.plugins,
-                    o3 = e4.dispatch,
-                    r3 = e4.autoResetResize,
-                    i3 = void 0 === r3 || r3,
-                    u3 = e4.columns;
-                v2(n3, ["useAbsoluteLayout"], "useResizeColumns");
-                var s3 = h2(i3);
-                w2(function() {
-                    s3() && o3({
-                        type: l2.resetResize
+        },
+        e: function e3(date, token, localize2, options) {
+            var dayOfWeek = date.getUTCDay();
+            var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
+            switch (token) {
+                case "e":
+                    return String(localDayOfWeek);
+                case "ee":
+                    return addLeadingZeros(localDayOfWeek, 2);
+                case "eo":
+                    return localize2.ordinalNumber(localDayOfWeek, {
+                        unit: "day"
                     });
-                }, [u3]);
-                var a3 = t2.useCallback(function() {
-                    return o3({
-                        type: l2.resetResize
+                case "eee":
+                    return localize2.day(dayOfWeek, {
+                        width: "abbreviated",
+                        context: "formatting"
                     });
-                }, [o3]);
-                Object.assign(e4, {
-                    resetResizing: a3
-                });
-            }
-            var Ot2 = {
-                    position: "absolute",
-                    top: 0
-                },
-                Mt2 = function(e4) {
-                    e4.getTableBodyProps.push(jt2), e4.getRowProps.push(jt2), e4.getHeaderGroupProps.push(jt2), e4.getFooterGroupProps.push(jt2), e4.getHeaderProps.push(function(e6, t3) {
-                        var n3 = t3.column;
-                        return [e6, {
-                            style: r2({}, Ot2, {
-                                left: n3.totalLeft + "px",
-                                width: n3.totalWidth + "px"
-                            })
-                        }];
-                    }), e4.getCellProps.push(function(e6, t3) {
-                        var n3 = t3.cell;
-                        return [e6, {
-                            style: r2({}, Ot2, {
-                                left: n3.column.totalLeft + "px",
-                                width: n3.column.totalWidth + "px"
-                            })
-                        }];
-                    }), e4.getFooterProps.push(function(e6, t3) {
-                        var n3 = t3.column;
-                        return [e6, {
-                            style: r2({}, Ot2, {
-                                left: n3.totalLeft + "px",
-                                width: n3.totalWidth + "px"
-                            })
-                        }];
+                case "eeeee":
+                    return localize2.day(dayOfWeek, {
+                        width: "narrow",
+                        context: "formatting"
                     });
-                };
-            Mt2.pluginName = "useAbsoluteLayout";
-            var jt2 = function(e4, t3) {
-                    return [e4, {
-                        style: {
-                            position: "relative",
-                            width: t3.instance.totalColumnsWidth + "px"
-                        }
-                    }];
-                },
-                Nt2 = {
-                    display: "inline-block",
-                    boxSizing: "border-box"
-                },
-                Lt2 = function(e4, t3) {
-                    return [e4, {
-                        style: {
-                            display: "flex",
-                            width: t3.instance.totalColumnsWidth + "px"
-                        }
-                    }];
-                },
-                Dt2 = function(e4) {
-                    e4.getRowProps.push(Lt2), e4.getHeaderGroupProps.push(Lt2), e4.getFooterGroupProps.push(Lt2), e4.getHeaderProps.push(function(e6, t3) {
-                        var n3 = t3.column;
-                        return [e6, {
-                            style: r2({}, Nt2, {
-                                width: n3.totalWidth + "px"
-                            })
-                        }];
-                    }), e4.getCellProps.push(function(e6, t3) {
-                        var n3 = t3.cell;
-                        return [e6, {
-                            style: r2({}, Nt2, {
-                                width: n3.column.totalWidth + "px"
-                            })
-                        }];
-                    }), e4.getFooterProps.push(function(e6, t3) {
-                        var n3 = t3.column;
-                        return [e6, {
-                            style: r2({}, Nt2, {
-                                width: n3.totalWidth + "px"
-                            })
-                        }];
+                case "eeeeee":
+                    return localize2.day(dayOfWeek, {
+                        width: "short",
+                        context: "formatting"
+                    });
+                case "eeee":
+                default:
+                    return localize2.day(dayOfWeek, {
+                        width: "wide",
+                        context: "formatting"
                     });
-                };
-
-            function Vt2(e4) {
-                e4.getTableProps.push(_t2), e4.getRowProps.push(Xt2), e4.getHeaderGroupProps.push(Xt2), e4.getFooterGroupProps.push(Xt2), e4.getHeaderProps.push(qt2), e4.getCellProps.push(Kt2), e4.getFooterProps.push(Ut2);
             }
-            Dt2.pluginName = "useBlockLayout", Vt2.pluginName = "useFlexLayout";
-            var _t2 = function(e4, t3) {
-                    return [e4, {
-                        style: {
-                            minWidth: t3.instance.totalColumnsMinWidth + "px"
-                        }
-                    }];
-                },
-                Xt2 = function(e4, t3) {
-                    return [e4, {
-                        style: {
-                            display: "flex",
-                            flex: "1 0 auto",
-                            minWidth: t3.instance.totalColumnsMinWidth + "px"
-                        }
-                    }];
-                },
-                qt2 = function(e4, t3) {
-                    var n3 = t3.column;
-                    return [e4, {
-                        style: {
-                            boxSizing: "border-box",
-                            flex: n3.totalFlexWidth ? n3.totalFlexWidth + " 0 auto" : void 0,
-                            minWidth: n3.totalMinWidth + "px",
-                            width: n3.totalWidth + "px"
-                        }
-                    }];
-                },
-                Kt2 = function(e4, t3) {
-                    var n3 = t3.cell;
-                    return [e4, {
-                        style: {
-                            boxSizing: "border-box",
-                            flex: n3.column.totalFlexWidth + " 0 auto",
-                            minWidth: n3.column.totalMinWidth + "px",
-                            width: n3.column.totalWidth + "px"
-                        }
-                    }];
-                },
-                Ut2 = function(e4, t3) {
-                    var n3 = t3.column;
-                    return [e4, {
-                        style: {
-                            boxSizing: "border-box",
-                            flex: n3.totalFlexWidth ? n3.totalFlexWidth + " 0 auto" : void 0,
-                            minWidth: n3.totalMinWidth + "px",
-                            width: n3.totalWidth + "px"
-                        }
-                    }];
-                };
-
-            function $t2(e4) {
-                e4.stateReducers.push(Qt2), e4.getTableProps.push(Jt), e4.getHeaderProps.push(Yt2);
+        },
+        c: function c2(date, token, localize2, options) {
+            var dayOfWeek = date.getUTCDay();
+            var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
+            switch (token) {
+                case "c":
+                    return String(localDayOfWeek);
+                case "cc":
+                    return addLeadingZeros(localDayOfWeek, token.length);
+                case "co":
+                    return localize2.ordinalNumber(localDayOfWeek, {
+                        unit: "day"
+                    });
+                case "ccc":
+                    return localize2.day(dayOfWeek, {
+                        width: "abbreviated",
+                        context: "standalone"
+                    });
+                case "ccccc":
+                    return localize2.day(dayOfWeek, {
+                        width: "narrow",
+                        context: "standalone"
+                    });
+                case "cccccc":
+                    return localize2.day(dayOfWeek, {
+                        width: "short",
+                        context: "standalone"
+                    });
+                case "cccc":
+                default:
+                    return localize2.day(dayOfWeek, {
+                        width: "wide",
+                        context: "standalone"
+                    });
             }
-            $t2.pluginName = "useGridLayout";
-            var Jt = function(e4, t3) {
-                    return [e4, {
-                        style: {
-                            display: "grid",
-                            gridTemplateColumns: t3.instance.state.gridLayout.columnWidths.map(function(e6) {
-                                return e6;
-                            }).join(" ")
-                        }
-                    }];
-                },
-                Yt2 = function(e4, t3) {
-                    return [e4, {
-                        id: "header-cell-" + t3.column.id,
-                        style: {
-                            position: "sticky"
-                        }
-                    }];
-                };
-
-            function Qt2(e4, t3, n3, o3) {
-                if ("init" === t3.type)
-                    return r2({
-                        gridLayout: {
-                            columnWidths: o3.columns.map(function() {
-                                return "auto";
-                            })
-                        }
-                    }, e4);
-                if ("columnStartResizing" === t3.type) {
-                    var i3 = t3.columnId,
-                        u3 = o3.visibleColumns.findIndex(function(e6) {
-                            return e6.id === i3;
-                        }),
-                        l3 = function(e6) {
-                            var t4, n4 = null == (t4 = document.getElementById("header-cell-" + e6)) ? void 0 : t4.offsetWidth;
-                            if (void 0 !== n4)
-                                return n4;
-                        }(i3);
-                    return void 0 !== l3 ? r2({}, e4, {
-                        gridLayout: r2({}, e4.gridLayout, {
-                            columnId: i3,
-                            columnIndex: u3,
-                            startingWidth: l3
-                        })
-                    }) : e4;
-                }
-                if ("columnResizing" === t3.type) {
-                    var s3 = e4.gridLayout,
-                        a3 = s3.columnIndex,
-                        c3 = s3.startingWidth,
-                        d3 = s3.columnWidths,
-                        f3 = c3 - (e4.columnResizing.startX - t3.clientX),
-                        p3 = [].concat(d3);
-                    return p3[a3] = f3 + "px", r2({}, e4, {
-                        gridLayout: r2({}, e4.gridLayout, {
-                            columnWidths: p3
-                        })
+        },
+        i: function i2(date, token, localize2) {
+            var dayOfWeek = date.getUTCDay();
+            var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
+            switch (token) {
+                case "i":
+                    return String(isoDayOfWeek);
+                case "ii":
+                    return addLeadingZeros(isoDayOfWeek, token.length);
+                case "io":
+                    return localize2.ordinalNumber(isoDayOfWeek, {
+                        unit: "day"
+                    });
+                case "iii":
+                    return localize2.day(dayOfWeek, {
+                        width: "abbreviated",
+                        context: "formatting"
+                    });
+                case "iiiii":
+                    return localize2.day(dayOfWeek, {
+                        width: "narrow",
+                        context: "formatting"
+                    });
+                case "iiiiii":
+                    return localize2.day(dayOfWeek, {
+                        width: "short",
+                        context: "formatting"
+                    });
+                case "iiii":
+                default:
+                    return localize2.day(dayOfWeek, {
+                        width: "wide",
+                        context: "formatting"
                     });
-                }
             }
-            e3._UNSTABLE_usePivotColumns = nt2, e3.actions = l2, e3.defaultColumn = c2, e3.defaultGroupByFn = De2, e3.defaultOrderByFn = Qe2, e3.defaultRenderer = s2, e3.emptyRenderer = a2, e3.ensurePluginOrder = v2, e3.flexRender = b2, e3.functionalUpdate = m2, e3.loopHooks = g2, e3.makePropGetter = f2, e3.makeRenderer = R2, e3.reduceHooks = p2, e3.safeUseLayoutEffect = y2, e3.useAbsoluteLayout = Mt2, e3.useAsyncDebounce = function(e4, n3) {
-                void 0 === n3 && (n3 = 0);
-                var r3 = t2.useRef({}),
-                    i3 = h2(e4),
-                    u3 = h2(n3);
-                return t2.useCallback(function() {
-                    var e6 = o2(regeneratorRuntime.mark(function e7() {
-                        var t3, n4, l3, s3 = arguments;
-                        return regeneratorRuntime.wrap(function(e8) {
-                            for (;;)
-                                switch (e8.prev = e8.next) {
-                                    case 0:
-                                        for (t3 = s3.length, n4 = new Array(t3), l3 = 0; l3 < t3; l3++)
-                                            n4[l3] = s3[l3];
-                                        return r3.current.promise || (r3.current.promise = new Promise(function(e9, t4) {
-                                            r3.current.resolve = e9, r3.current.reject = t4;
-                                        })), r3.current.timeout && clearTimeout(r3.current.timeout), r3.current.timeout = setTimeout(o2(regeneratorRuntime.mark(function e9() {
-                                            return regeneratorRuntime.wrap(function(e11) {
-                                                for (;;)
-                                                    switch (e11.prev = e11.next) {
-                                                        case 0:
-                                                            return delete r3.current.timeout, e11.prev = 1, e11.t0 = r3.current, e11.next = 5, i3().apply(void 0, n4);
-                                                        case 5:
-                                                            e11.t1 = e11.sent, e11.t0.resolve.call(e11.t0, e11.t1), e11.next = 12;
-                                                            break;
-                                                        case 9:
-                                                            e11.prev = 9, e11.t2 = e11.catch(1), r3.current.reject(e11.t2);
-                                                        case 12:
-                                                            return e11.prev = 12, delete r3.current.promise, e11.finish(12);
-                                                        case 15:
-                                                        case "end":
-                                                            return e11.stop();
-                                                    }
-                                            }, e9, null, [
-                                                [1, 9, 12, 15]
-                                            ]);
-                                        })), u3()), e8.abrupt("return", r3.current.promise);
-                                    case 5:
-                                    case "end":
-                                        return e8.stop();
-                                }
-                        }, e7);
-                    }));
-                    return function() {
-                        return e6.apply(this, arguments);
-                    };
-                }(), [i3, u3]);
-            }, e3.useBlockLayout = Dt2, e3.useColumnOrder = It2, e3.useExpanded = se2, e3.useFilters = Pe2, e3.useFlexLayout = Vt2, e3.useGetLatest = h2, e3.useGlobalFilter = Ie2, e3.useGridLayout = $t2, e3.useGroupBy = ze2, e3.useMountedLayoutEffect = w2, e3.usePagination = Ze2, e3.useResizeColumns = kt2, e3.useRowSelect = vt2, e3.useRowState = xt2, e3.useSortBy = Ue2, e3.useTable = function(e4) {
-                for (var n3 = arguments.length, o3 = new Array(n3 > 1 ? n3 - 1 : 0), i3 = 1; i3 < n3; i3++)
-                    o3[i3 - 1] = arguments[i3];
-                e4 = ie2(e4), o3 = [K2].concat(o3);
-                var u3 = t2.useRef({}),
-                    s3 = h2(u3.current);
-                Object.assign(s3(), r2({}, e4, {
-                    plugins: o3,
-                    hooks: q2()
-                })), o3.filter(Boolean).forEach(function(e6) {
-                    e6(s3().hooks);
-                });
-                var a3 = h2(s3().hooks);
-                s3().getHooks = a3, delete s3().hooks, Object.assign(s3(), p2(a3().useOptions, ie2(e4)));
-                var c3 = s3(),
-                    d3 = c3.data,
-                    v3 = c3.columns,
-                    m3 = c3.initialState,
-                    y3 = c3.defaultColumn,
-                    w3 = c3.getSubRows,
-                    b3 = c3.getRowId,
-                    E3 = c3.stateReducer,
-                    I3 = c3.useControlledState,
-                    F3 = h2(E3),
-                    G3 = t2.useCallback(function(e6, t3) {
-                        if (!t3.type)
-                            throw console.info({
-                                action: t3
-                            }), new Error("Unknown Action \u{1F446}");
-                        return [].concat(a3().stateReducers, Array.isArray(F3()) ? F3() : [F3()]).reduce(function(n4, o4) {
-                            return o4(n4, t3, e6, s3()) || n4;
-                        }, e6);
-                    }, [a3, F3, s3]),
-                    A3 = t2.useReducer(G3, void 0, function() {
-                        return G3(m3, {
-                            type: l2.init
-                        });
-                    }),
-                    k3 = A3[0],
-                    H3 = A3[1],
-                    T3 = p2([].concat(a3().useControlledState, [I3]), k3, {
-                        instance: s3()
+        },
+        a: function a2(date, token, localize2) {
+            var hours = date.getUTCHours();
+            var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
+            switch (token) {
+                case "a":
+                case "aa":
+                    return localize2.dayPeriod(dayPeriodEnumValue, {
+                        width: "abbreviated",
+                        context: "formatting"
                     });
-                Object.assign(s3(), {
-                    state: T3,
-                    dispatch: H3
-                });
-                var z3 = t2.useMemo(function() {
-                    return S2(p2(a3().columns, v3, {
-                        instance: s3()
-                    }));
-                }, [a3, s3, v3].concat(p2(a3().columnsDeps, [], {
-                    instance: s3()
-                })));
-                s3().columns = z3;
-                var W3 = t2.useMemo(function() {
-                    return p2(a3().allColumns, C2(z3), {
-                        instance: s3()
-                    }).map(x2);
-                }, [z3, a3, s3].concat(p2(a3().allColumnsDeps, [], {
-                    instance: s3()
-                })));
-                s3().allColumns = W3;
-                var O3 = t2.useMemo(function() {
-                        for (var e6 = [], t3 = [], n4 = {}, o4 = [].concat(W3); o4.length;) {
-                            var r3 = o4.shift();
-                            le2({
-                                data: d3,
-                                rows: e6,
-                                flatRows: t3,
-                                rowsById: n4,
-                                column: r3,
-                                getRowId: b3,
-                                getSubRows: w3,
-                                accessValueHooks: a3().accessValue,
-                                getInstance: s3
-                            });
-                        }
-                        return [e6, t3, n4];
-                    }, [W3, d3, b3, w3, a3, s3]),
-                    M3 = O3[0],
-                    j3 = O3[1],
-                    N3 = O3[2];
-                Object.assign(s3(), {
-                    rows: M3,
-                    initialRows: [].concat(M3),
-                    flatRows: j3,
-                    rowsById: N3
-                }), g2(a3().useInstanceAfterData, s3());
-                var L3 = t2.useMemo(function() {
-                    return p2(a3().visibleColumns, W3, {
-                        instance: s3()
-                    }).map(function(e6) {
-                        return P2(e6, y3);
+                case "aaa":
+                    return localize2.dayPeriod(dayPeriodEnumValue, {
+                        width: "abbreviated",
+                        context: "formatting"
+                    }).toLowerCase();
+                case "aaaaa":
+                    return localize2.dayPeriod(dayPeriodEnumValue, {
+                        width: "narrow",
+                        context: "formatting"
                     });
-                }, [a3, W3, s3, y3].concat(p2(a3().visibleColumnsDeps, [], {
-                    instance: s3()
-                })));
-                W3 = t2.useMemo(function() {
-                    var e6 = [].concat(L3);
-                    return W3.forEach(function(t3) {
-                        e6.find(function(e7) {
-                            return e7.id === t3.id;
-                        }) || e6.push(t3);
-                    }), e6;
-                }, [W3, L3]), s3().allColumns = W3;
-                var D3 = t2.useMemo(function() {
-                    return p2(a3().headerGroups, B2(L3, y3), s3());
-                }, [a3, L3, y3, s3].concat(p2(a3().headerGroupsDeps, [], {
-                    instance: s3()
-                })));
-                s3().headerGroups = D3;
-                var V3 = t2.useMemo(function() {
-                    return D3.length ? D3[0].headers : [];
-                }, [D3]);
-                s3().headers = V3, s3().flatHeaders = D3.reduce(function(e6, t3) {
-                    return [].concat(e6, t3.headers);
-                }, []), g2(a3().useInstanceBeforeDimensions, s3());
-                var _3 = L3.filter(function(e6) {
-                    return e6.isVisible;
-                }).map(function(e6) {
-                    return e6.id;
-                }).sort().join("_");
-                L3 = t2.useMemo(function() {
-                    return L3.filter(function(e6) {
-                        return e6.isVisible;
+                case "aaaa":
+                default:
+                    return localize2.dayPeriod(dayPeriodEnumValue, {
+                        width: "wide",
+                        context: "formatting"
                     });
-                }, [L3, _3]), s3().visibleColumns = L3;
-                var X3 = ue2(V3),
-                    U3 = X3[0],
-                    $3 = X3[1],
-                    J3 = X3[2];
-                return s3().totalColumnsMinWidth = U3, s3().totalColumnsWidth = $3, s3().totalColumnsMaxWidth = J3, g2(a3().useInstance, s3()), [].concat(s3().flatHeaders, s3().allColumns).forEach(function(e6) {
-                    e6.render = R2(s3(), e6), e6.getHeaderProps = f2(a3().getHeaderProps, {
-                        instance: s3(),
-                        column: e6
-                    }), e6.getFooterProps = f2(a3().getFooterProps, {
-                        instance: s3(),
-                        column: e6
+            }
+        },
+        b: function b2(date, token, localize2) {
+            var hours = date.getUTCHours();
+            var dayPeriodEnumValue;
+            if (hours === 12) {
+                dayPeriodEnumValue = dayPeriodEnum.noon;
+            } else if (hours === 0) {
+                dayPeriodEnumValue = dayPeriodEnum.midnight;
+            } else {
+                dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
+            }
+            switch (token) {
+                case "b":
+                case "bb":
+                    return localize2.dayPeriod(dayPeriodEnumValue, {
+                        width: "abbreviated",
+                        context: "formatting"
                     });
-                }), s3().headerGroups = t2.useMemo(function() {
-                    return D3.filter(function(e6, t3) {
-                        return e6.headers = e6.headers.filter(function(e7) {
-                            return e7.headers ? function e8(t4) {
-                                return t4.filter(function(t5) {
-                                    return t5.headers ? e8(t5.headers) : t5.isVisible;
-                                }).length;
-                            }(e7.headers) : e7.isVisible;
-                        }), !!e6.headers.length && (e6.getHeaderGroupProps = f2(a3().getHeaderGroupProps, {
-                            instance: s3(),
-                            headerGroup: e6,
-                            index: t3
-                        }), e6.getFooterGroupProps = f2(a3().getFooterGroupProps, {
-                            instance: s3(),
-                            headerGroup: e6,
-                            index: t3
-                        }), true);
+                case "bbb":
+                    return localize2.dayPeriod(dayPeriodEnumValue, {
+                        width: "abbreviated",
+                        context: "formatting"
+                    }).toLowerCase();
+                case "bbbbb":
+                    return localize2.dayPeriod(dayPeriodEnumValue, {
+                        width: "narrow",
+                        context: "formatting"
                     });
-                }, [D3, s3, a3]), s3().footerGroups = [].concat(s3().headerGroups).reverse(), s3().prepareRow = t2.useCallback(function(e6) {
-                    e6.getRowProps = f2(a3().getRowProps, {
-                        instance: s3(),
-                        row: e6
-                    }), e6.allCells = W3.map(function(t3) {
-                        var n4 = e6.values[t3.id],
-                            o4 = {
-                                column: t3,
-                                row: e6,
-                                value: n4
-                            };
-                        return o4.getCellProps = f2(a3().getCellProps, {
-                            instance: s3(),
-                            cell: o4
-                        }), o4.render = R2(s3(), t3, {
-                            row: e6,
-                            cell: o4,
-                            value: n4
-                        }), o4;
-                    }), e6.cells = L3.map(function(t3) {
-                        return e6.allCells.find(function(e7) {
-                            return e7.column.id === t3.id;
-                        });
-                    }), g2(a3().prepareRow, e6, {
-                        instance: s3()
+                case "bbbb":
+                default:
+                    return localize2.dayPeriod(dayPeriodEnumValue, {
+                        width: "wide",
+                        context: "formatting"
                     });
-                }, [a3, s3, W3, L3]), s3().getTableProps = f2(a3().getTableProps, {
-                    instance: s3()
-                }), s3().getTableBodyProps = f2(a3().getTableBodyProps, {
-                    instance: s3()
-                }), g2(a3().useFinalInstance, s3()), s3();
-            }, Object.defineProperty(e3, "__esModule", {
-                value: true
-            });
-        });
-    })(reactTable_production_min, reactTable_production_min.exports);
-    (function(module2) {
-        {
-            module2.exports = reactTable_production_min.exports;
-        }
-    })(reactTable);
-    var build = {};
-    (function(exports3) {
-        Object.defineProperty(exports3, "__esModule", {
-            value: true
-        });
-        exports3.checkErrors = (columns) => {
-            const hasGroups = !!columns.find((column) => column.parent);
-            const stickyColumnsWithoutGroup = columns.filter((column) => column.sticky && !column.parent).map(({
-                Header: Header2
-            }) => `'${Header2}'`);
-            if (hasGroups && stickyColumnsWithoutGroup.length) {
-                throw new Error(`WARNING react-table-sticky:
-      
-Your ReactTable has group and sticky columns outside groups, and that will break UI.
-      
-You must place ${stickyColumnsWithoutGroup.join(" and ")} columns into a group (even a group with an empty Header label)
-`);
             }
-            const bugWithUnderColumnsSticky = columns.find((parentCol) => !parentCol.sticky && parentCol.columns && parentCol.columns.find((col) => col.sticky));
-            if (!bugWithUnderColumnsSticky)
-                return;
-            const childBugs = bugWithUnderColumnsSticky.columns.find(({
-                sticky
-            }) => sticky);
-            if (!childBugs)
-                return;
-            throw new Error(`WARNING react-table-sticky:
-    
-Your ReactTable contain columns group with at least one child columns sticky.
-    
-When ReactTable has columns groups, only columns groups can be sticky
-    
-You must set sticky: 'left' | 'right' for the '${bugWithUnderColumnsSticky.Header}'
-    column, or remove the sticky property of '${childBugs.Header}' column.`);
-        };
-
-        function getStickyValue(column) {
-            if (column.sticky === "left" || column.sticky === "right") {
-                return column.sticky;
+        },
+        B: function B2(date, token, localize2) {
+            var hours = date.getUTCHours();
+            var dayPeriodEnumValue;
+            if (hours >= 17) {
+                dayPeriodEnumValue = dayPeriodEnum.evening;
+            } else if (hours >= 12) {
+                dayPeriodEnumValue = dayPeriodEnum.afternoon;
+            } else if (hours >= 4) {
+                dayPeriodEnumValue = dayPeriodEnum.morning;
+            } else {
+                dayPeriodEnumValue = dayPeriodEnum.night;
             }
-            if (column.parent) {
-                return getStickyValue(column.parent);
+            switch (token) {
+                case "B":
+                case "BB":
+                case "BBB":
+                    return localize2.dayPeriod(dayPeriodEnumValue, {
+                        width: "abbreviated",
+                        context: "formatting"
+                    });
+                case "BBBBB":
+                    return localize2.dayPeriod(dayPeriodEnumValue, {
+                        width: "narrow",
+                        context: "formatting"
+                    });
+                case "BBBB":
+                default:
+                    return localize2.dayPeriod(dayPeriodEnumValue, {
+                        width: "wide",
+                        context: "formatting"
+                    });
             }
-            return null;
-        }
-        exports3.getStickyValue = getStickyValue;
-
-        function columnIsLastLeftSticky(columnId, columns) {
-            const index2 = columns.findIndex(({
-                id: id2
-            }) => id2 === columnId);
-            const column = columns[index2];
-            const nextColumn = columns[index2 + 1];
-            const columnIsLeftSticky = getStickyValue(column) === "left";
-            const nextColumnIsLeftSticky = nextColumn && getStickyValue(nextColumn) === "left";
-            return columnIsLeftSticky && !nextColumnIsLeftSticky;
-        }
-        exports3.columnIsLastLeftSticky = columnIsLastLeftSticky;
-
-        function columnIsFirstRightSticky(columnId, columns) {
-            const index2 = columns.findIndex(({
-                id: id2
-            }) => id2 === columnId);
-            const column = columns[index2];
-            const prevColumn = columns[index2 - 1];
-            const columnIsRightSticky = getStickyValue(column) === "right";
-            const prevColumnIsRightSticky = prevColumn && getStickyValue(prevColumn) === "right";
-            return columnIsRightSticky && !prevColumnIsRightSticky;
-        }
-        exports3.columnIsFirstRightSticky = columnIsFirstRightSticky;
-
-        function getMarginRight(columnId, columns) {
-            const currentIndex = columns.findIndex(({
-                id: id2
-            }) => id2 === columnId);
-            let rightMargin = 0;
-            for (let i2 = currentIndex + 1; i2 < columns.length; i2 += 1) {
-                if (columns[i2].isVisible !== false) {
-                    rightMargin += columns[i2].width;
-                }
+        },
+        h: function h2(date, token, localize2) {
+            if (token === "ho") {
+                var hours = date.getUTCHours() % 12;
+                if (hours === 0)
+                    hours = 12;
+                return localize2.ordinalNumber(hours, {
+                    unit: "hour"
+                });
             }
-            return rightMargin;
-        }
-        exports3.getMarginRight = getMarginRight;
-        const cellStylesSticky = {
-            position: "sticky",
-            zIndex: 3
-        };
-
-        function findHeadersSameLevel(header, headers) {
-            return headers.filter((flatHeaderItem) => {
-                return flatHeaderItem.depth === header.depth;
-            });
-        }
-
-        function getStickyProps(header, instance2) {
-            let style2 = {};
-            const dataAttrs = {};
-            exports3.checkErrors(instance2.columns);
-            const sticky = getStickyValue(header);
-            if (sticky) {
-                style2 = Object.assign({}, cellStylesSticky);
-                dataAttrs["data-sticky-td"] = true;
-                const headers = findHeadersSameLevel(header, instance2.flatHeaders);
-                const margin = sticky === "left" ? header.totalLeft : getMarginRight(header.id, headers);
-                style2 = Object.assign(Object.assign({}, style2), {
-                    [sticky]: `${margin}px`
+            return lightFormatters.h(date, token);
+        },
+        H: function H2(date, token, localize2) {
+            if (token === "Ho") {
+                return localize2.ordinalNumber(date.getUTCHours(), {
+                    unit: "hour"
                 });
-                const isLastLeftSticky = columnIsLastLeftSticky(header.id, headers);
-                if (isLastLeftSticky) {
-                    dataAttrs["data-sticky-last-left-td"] = true;
-                }
-                const isFirstRightSticky = columnIsFirstRightSticky(header.id, headers);
-                if (isFirstRightSticky) {
-                    dataAttrs["data-sticky-first-right-td"] = true;
-                }
-            }
-            return Object.assign({
-                style: style2
-            }, dataAttrs);
-        }
-        exports3.useSticky = (hooks) => {
-            hooks.getHeaderProps.push((props, {
-                instance: instance2,
-                column
-            }) => {
-                const nextProps = getStickyProps(column, instance2);
-                return [props, nextProps];
-            });
-            hooks.getCellProps.push((props, {
-                instance: instance2,
-                cell
-            }) => {
-                const nextProps = getStickyProps(cell.column, instance2);
-                return [props, nextProps];
-            });
-        };
-        exports3.useSticky.pluginName = "useSticky";
-    })(build);
-    var classCallCheck = function(instance2, Constructor) {
-        if (!(instance2 instanceof Constructor)) {
-            throw new TypeError("Cannot call a class as a function");
-        }
-    };
-    var createClass = function() {
-        function defineProperties(target, props) {
-            for (var i2 = 0; i2 < props.length; i2++) {
-                var descriptor = props[i2];
-                descriptor.enumerable = descriptor.enumerable || false;
-                descriptor.configurable = true;
-                if ("value" in descriptor)
-                    descriptor.writable = true;
-                Object.defineProperty(target, descriptor.key, descriptor);
-            }
-        }
-        return function(Constructor, protoProps, staticProps) {
-            if (protoProps)
-                defineProperties(Constructor.prototype, protoProps);
-            if (staticProps)
-                defineProperties(Constructor, staticProps);
-            return Constructor;
-        };
-    }();
-    var _extends$2 = Object.assign || function(target) {
-        for (var i2 = 1; i2 < arguments.length; i2++) {
-            var source = arguments[i2];
-            for (var key in source) {
-                if (Object.prototype.hasOwnProperty.call(source, key)) {
-                    target[key] = source[key];
-                }
-            }
-        }
-        return target;
-    };
-    var inherits = function(subClass, superClass) {
-        if (typeof superClass !== "function" && superClass !== null) {
-            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
-        }
-        subClass.prototype = Object.create(superClass && superClass.prototype, {
-            constructor: {
-                value: subClass,
-                enumerable: false,
-                writable: true,
-                configurable: true
-            }
-        });
-        if (superClass)
-            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
-    };
-    var possibleConstructorReturn = function(self2, call2) {
-        if (!self2) {
-            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
-        }
-        return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
-    };
-    var slicedToArray = function() {
-        function sliceIterator(arr, i2) {
-            var _arr = [];
-            var _n2 = true;
-            var _d = false;
-            var _e2 = void 0;
-            try {
-                for (var _i2 = arr[Symbol.iterator](), _s; !(_n2 = (_s = _i2.next()).done); _n2 = true) {
-                    _arr.push(_s.value);
-                    if (i2 && _arr.length === i2)
-                        break;
-                }
-            } catch (err) {
-                _d = true;
-                _e2 = err;
-            } finally {
-                try {
-                    if (!_n2 && _i2["return"])
-                        _i2["return"]();
-                } finally {
-                    if (_d)
-                        throw _e2;
-                }
             }
-            return _arr;
-        }
-        return function(arr, i2) {
-            if (Array.isArray(arr)) {
-                return arr;
-            } else if (Symbol.iterator in Object(arr)) {
-                return sliceIterator(arr, i2);
-            } else {
-                throw new TypeError("Invalid attempt to destructure non-iterable instance");
+            return lightFormatters.H(date, token);
+        },
+        K: function K2(date, token, localize2) {
+            var hours = date.getUTCHours() % 12;
+            if (token === "Ko") {
+                return localize2.ordinalNumber(hours, {
+                    unit: "hour"
+                });
             }
-        };
-    }();
-    var windowObject = void 0;
-    if (typeof window !== "undefined") {
-        windowObject = window;
-    } else if (typeof self !== "undefined") {
-        windowObject = self;
-    } else {
-        windowObject = global;
-    }
-    var cancelFrame = null;
-    var requestFrame = null;
-    var TIMEOUT_DURATION = 20;
-    var clearTimeoutFn = windowObject.clearTimeout;
-    var setTimeoutFn = windowObject.setTimeout;
-    var cancelAnimationFrameFn = windowObject.cancelAnimationFrame || windowObject.mozCancelAnimationFrame || windowObject.webkitCancelAnimationFrame;
-    var requestAnimationFrameFn = windowObject.requestAnimationFrame || windowObject.mozRequestAnimationFrame || windowObject.webkitRequestAnimationFrame;
-    if (cancelAnimationFrameFn == null || requestAnimationFrameFn == null) {
-        cancelFrame = clearTimeoutFn;
-        requestFrame = function requestAnimationFrameViaSetTimeout(callback) {
-            return setTimeoutFn(callback, TIMEOUT_DURATION);
-        };
-    } else {
-        cancelFrame = function cancelFrame2(_ref2) {
-            var _ref22 = slicedToArray(_ref2, 2),
-                animationFrameID = _ref22[0],
-                timeoutID = _ref22[1];
-            cancelAnimationFrameFn(animationFrameID);
-            clearTimeoutFn(timeoutID);
-        };
-        requestFrame = function requestAnimationFrameWithSetTimeoutFallback(callback) {
-            var animationFrameID = requestAnimationFrameFn(function animationFrameCallback() {
-                clearTimeoutFn(timeoutID);
-                callback();
-            });
-            var timeoutID = setTimeoutFn(function timeoutCallback() {
-                cancelAnimationFrameFn(animationFrameID);
-                callback();
-            }, TIMEOUT_DURATION);
-            return [animationFrameID, timeoutID];
-        };
-    }
-
-    function createDetectElementResize(nonce) {
-        var animationKeyframes = void 0;
-        var animationName = void 0;
-        var animationStartEvent = void 0;
-        var animationStyle = void 0;
-        var checkTriggers = void 0;
-        var resetTriggers = void 0;
-        var scrollListener = void 0;
-        var attachEvent = typeof document !== "undefined" && document.attachEvent;
-        if (!attachEvent) {
-            resetTriggers = function resetTriggers2(element2) {
-                var triggers = element2.__resizeTriggers__,
-                    expand2 = triggers.firstElementChild,
-                    contract2 = triggers.lastElementChild,
-                    expandChild = expand2.firstElementChild;
-                contract2.scrollLeft = contract2.scrollWidth;
-                contract2.scrollTop = contract2.scrollHeight;
-                expandChild.style.width = expand2.offsetWidth + 1 + "px";
-                expandChild.style.height = expand2.offsetHeight + 1 + "px";
-                expand2.scrollLeft = expand2.scrollWidth;
-                expand2.scrollTop = expand2.scrollHeight;
-            };
-            checkTriggers = function checkTriggers2(element2) {
-                return element2.offsetWidth !== element2.__resizeLast__.width || element2.offsetHeight !== element2.__resizeLast__.height;
-            };
-            scrollListener = function scrollListener2(e3) {
-                if (e3.target.className && typeof e3.target.className.indexOf === "function" && e3.target.className.indexOf("contract-trigger") < 0 && e3.target.className.indexOf("expand-trigger") < 0) {
-                    return;
-                }
-                var element2 = this;
-                resetTriggers(this);
-                if (this.__resizeRAF__) {
-                    cancelFrame(this.__resizeRAF__);
-                }
-                this.__resizeRAF__ = requestFrame(function animationFrame() {
-                    if (checkTriggers(element2)) {
-                        element2.__resizeLast__.width = element2.offsetWidth;
-                        element2.__resizeLast__.height = element2.offsetHeight;
-                        element2.__resizeListeners__.forEach(function forEachResizeListener(fn2) {
-                            fn2.call(element2, e3);
-                        });
-                    }
+            return addLeadingZeros(hours, token.length);
+        },
+        k: function k2(date, token, localize2) {
+            var hours = date.getUTCHours();
+            if (hours === 0)
+                hours = 24;
+            if (token === "ko") {
+                return localize2.ordinalNumber(hours, {
+                    unit: "hour"
                 });
-            };
-            var animation = false;
-            var keyframeprefix = "";
-            animationStartEvent = "animationstart";
-            var domPrefixes = "Webkit Moz O ms".split(" ");
-            var startEvents = "webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(" ");
-            var pfx = "";
-            {
-                var elm = document.createElement("fakeelement");
-                if (elm.style.animationName !== void 0) {
-                    animation = true;
-                }
-                if (animation === false) {
-                    for (var i2 = 0; i2 < domPrefixes.length; i2++) {
-                        if (elm.style[domPrefixes[i2] + "AnimationName"] !== void 0) {
-                            pfx = domPrefixes[i2];
-                            keyframeprefix = "-" + pfx.toLowerCase() + "-";
-                            animationStartEvent = startEvents[i2];
-                            animation = true;
-                            break;
-                        }
-                    }
-                }
             }
-            animationName = "resizeanim";
-            animationKeyframes = "@" + keyframeprefix + "keyframes " + animationName + " { from { opacity: 0; } to { opacity: 0; } } ";
-            animationStyle = keyframeprefix + "animation: 1ms " + animationName + "; ";
-        }
-        var createStyles = function createStyles2(doc2) {
-            if (!doc2.getElementById("detectElementResize")) {
-                var css2 = (animationKeyframes ? animationKeyframes : "") + ".resize-triggers { " + (animationStyle ? animationStyle : "") + 'visibility: hidden; opacity: 0; } .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',
-                    head = doc2.head || doc2.getElementsByTagName("head")[0],
-                    style2 = doc2.createElement("style");
-                style2.id = "detectElementResize";
-                style2.type = "text/css";
-                if (nonce != null) {
-                    style2.setAttribute("nonce", nonce);
-                }
-                if (style2.styleSheet) {
-                    style2.styleSheet.cssText = css2;
-                } else {
-                    style2.appendChild(doc2.createTextNode(css2));
-                }
-                head.appendChild(style2);
+            return addLeadingZeros(hours, token.length);
+        },
+        m: function m2(date, token, localize2) {
+            if (token === "mo") {
+                return localize2.ordinalNumber(date.getUTCMinutes(), {
+                    unit: "minute"
+                });
             }
-        };
-        var addResizeListener = function addResizeListener2(element2, fn2) {
-            if (attachEvent) {
-                element2.attachEvent("onresize", fn2);
-            } else {
-                if (!element2.__resizeTriggers__) {
-                    var doc2 = element2.ownerDocument;
-                    var elementStyle = windowObject.getComputedStyle(element2);
-                    if (elementStyle && elementStyle.position === "static") {
-                        element2.style.position = "relative";
-                    }
-                    createStyles(doc2);
-                    element2.__resizeLast__ = {};
-                    element2.__resizeListeners__ = [];
-                    (element2.__resizeTriggers__ = doc2.createElement("div")).className = "resize-triggers";
-                    var expandTrigger = doc2.createElement("div");
-                    expandTrigger.className = "expand-trigger";
-                    expandTrigger.appendChild(doc2.createElement("div"));
-                    var contractTrigger = doc2.createElement("div");
-                    contractTrigger.className = "contract-trigger";
-                    element2.__resizeTriggers__.appendChild(expandTrigger);
-                    element2.__resizeTriggers__.appendChild(contractTrigger);
-                    element2.appendChild(element2.__resizeTriggers__);
-                    resetTriggers(element2);
-                    element2.addEventListener("scroll", scrollListener, true);
-                    if (animationStartEvent) {
-                        element2.__resizeTriggers__.__animationListener__ = function animationListener(e3) {
-                            if (e3.animationName === animationName) {
-                                resetTriggers(element2);
-                            }
-                        };
-                        element2.__resizeTriggers__.addEventListener(animationStartEvent, element2.__resizeTriggers__.__animationListener__);
-                    }
-                }
-                element2.__resizeListeners__.push(fn2);
+            return lightFormatters.m(date, token);
+        },
+        s: function s2(date, token, localize2) {
+            if (token === "so") {
+                return localize2.ordinalNumber(date.getUTCSeconds(), {
+                    unit: "second"
+                });
             }
-        };
-        var removeResizeListener = function removeResizeListener2(element2, fn2) {
-            if (attachEvent) {
-                element2.detachEvent("onresize", fn2);
-            } else {
-                element2.__resizeListeners__.splice(element2.__resizeListeners__.indexOf(fn2), 1);
-                if (!element2.__resizeListeners__.length) {
-                    element2.removeEventListener("scroll", scrollListener, true);
-                    if (element2.__resizeTriggers__.__animationListener__) {
-                        element2.__resizeTriggers__.removeEventListener(animationStartEvent, element2.__resizeTriggers__.__animationListener__);
-                        element2.__resizeTriggers__.__animationListener__ = null;
-                    }
-                    try {
-                        element2.__resizeTriggers__ = !element2.removeChild(element2.__resizeTriggers__);
-                    } catch (e3) {}
-                }
+            return lightFormatters.s(date, token);
+        },
+        S: function S2(date, token) {
+            return lightFormatters.S(date, token);
+        },
+        X: function X2(date, token, _localize, options) {
+            var originalDate = options._originalDate || date;
+            var timezoneOffset = originalDate.getTimezoneOffset();
+            if (timezoneOffset === 0) {
+                return "Z";
             }
-        };
-        return {
-            addResizeListener,
-            removeResizeListener
-        };
-    }
-    var AutoSizer = function(_React$PureComponent) {
-        inherits(AutoSizer2, _React$PureComponent);
-
-        function AutoSizer2() {
-            var _ref2;
-            var _temp, _this, _ret;
-            classCallCheck(this, AutoSizer2);
-            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
-                args[_key] = arguments[_key];
+            switch (token) {
+                case "X":
+                    return formatTimezoneWithOptionalMinutes(timezoneOffset);
+                case "XXXX":
+                case "XX":
+                    return formatTimezone(timezoneOffset);
+                case "XXXXX":
+                case "XXX":
+                default:
+                    return formatTimezone(timezoneOffset, ":");
             }
-            return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref2 = AutoSizer2.__proto__ || Object.getPrototypeOf(AutoSizer2)).call.apply(_ref2, [this].concat(args))), _this), _this.state = {
-                height: _this.props.defaultHeight || 0,
-                width: _this.props.defaultWidth || 0
-            }, _this._onResize = function() {
-                var _this$props = _this.props,
-                    disableHeight = _this$props.disableHeight,
-                    disableWidth = _this$props.disableWidth,
-                    onResize = _this$props.onResize;
-                if (_this._parentNode) {
-                    var _height = _this._parentNode.offsetHeight || 0;
-                    var _width = _this._parentNode.offsetWidth || 0;
-                    var _style = window.getComputedStyle(_this._parentNode) || {};
-                    var paddingLeft = parseInt(_style.paddingLeft, 10) || 0;
-                    var paddingRight = parseInt(_style.paddingRight, 10) || 0;
-                    var paddingTop = parseInt(_style.paddingTop, 10) || 0;
-                    var paddingBottom = parseInt(_style.paddingBottom, 10) || 0;
-                    var newHeight = _height - paddingTop - paddingBottom;
-                    var newWidth = _width - paddingLeft - paddingRight;
-                    if (!disableHeight && _this.state.height !== newHeight || !disableWidth && _this.state.width !== newWidth) {
-                        _this.setState({
-                            height: _height - paddingTop - paddingBottom,
-                            width: _width - paddingLeft - paddingRight
-                        });
-                        onResize({
-                            height: _height,
-                            width: _width
-                        });
-                    }
-                }
-            }, _this._setRef = function(autoSizer) {
-                _this._autoSizer = autoSizer;
-            }, _temp), possibleConstructorReturn(_this, _ret);
-        }
-        createClass(AutoSizer2, [{
-            key: "componentDidMount",
-            value: function componentDidMount() {
-                var nonce = this.props.nonce;
-                if (this._autoSizer && this._autoSizer.parentNode && this._autoSizer.parentNode.ownerDocument && this._autoSizer.parentNode.ownerDocument.defaultView && this._autoSizer.parentNode instanceof this._autoSizer.parentNode.ownerDocument.defaultView.HTMLElement) {
-                    this._parentNode = this._autoSizer.parentNode;
-                    this._detectElementResize = createDetectElementResize(nonce);
-                    this._detectElementResize.addResizeListener(this._parentNode, this._onResize);
-                    this._onResize();
-                }
+        },
+        x: function x2(date, token, _localize, options) {
+            var originalDate = options._originalDate || date;
+            var timezoneOffset = originalDate.getTimezoneOffset();
+            switch (token) {
+                case "x":
+                    return formatTimezoneWithOptionalMinutes(timezoneOffset);
+                case "xxxx":
+                case "xx":
+                    return formatTimezone(timezoneOffset);
+                case "xxxxx":
+                case "xxx":
+                default:
+                    return formatTimezone(timezoneOffset, ":");
             }
-        }, {
-            key: "componentWillUnmount",
-            value: function componentWillUnmount() {
-                if (this._detectElementResize && this._parentNode) {
-                    this._detectElementResize.removeResizeListener(this._parentNode, this._onResize);
-                }
+        },
+        O: function O2(date, token, _localize, options) {
+            var originalDate = options._originalDate || date;
+            var timezoneOffset = originalDate.getTimezoneOffset();
+            switch (token) {
+                case "O":
+                case "OO":
+                case "OOO":
+                    return "GMT" + formatTimezoneShort(timezoneOffset, ":");
+                case "OOOO":
+                default:
+                    return "GMT" + formatTimezone(timezoneOffset, ":");
             }
-        }, {
-            key: "render",
-            value: function render2() {
-                var _props = this.props,
-                    children2 = _props.children,
-                    className = _props.className,
-                    disableHeight = _props.disableHeight,
-                    disableWidth = _props.disableWidth,
-                    style2 = _props.style;
-                var _state = this.state,
-                    height = _state.height,
-                    width = _state.width;
-                var outerStyle = {
-                    overflow: "visible"
-                };
-                var childParams = {};
-                var bailoutOnChildren = false;
-                if (!disableHeight) {
-                    if (height === 0) {
-                        bailoutOnChildren = true;
-                    }
-                    outerStyle.height = 0;
-                    childParams.height = height;
-                }
-                if (!disableWidth) {
-                    if (width === 0) {
-                        bailoutOnChildren = true;
-                    }
-                    outerStyle.width = 0;
-                    childParams.width = width;
-                }
-                return React.createElement(
-                    "div", {
-                        className,
-                        ref: this._setRef,
-                        style: _extends$2({}, outerStyle, style2)
-                    },
-                    !bailoutOnChildren && children2(childParams)
-                );
+        },
+        z: function z2(date, token, _localize, options) {
+            var originalDate = options._originalDate || date;
+            var timezoneOffset = originalDate.getTimezoneOffset();
+            switch (token) {
+                case "z":
+                case "zz":
+                case "zzz":
+                    return "GMT" + formatTimezoneShort(timezoneOffset, ":");
+                case "zzzz":
+                default:
+                    return "GMT" + formatTimezone(timezoneOffset, ":");
             }
-        }]);
-        return AutoSizer2;
-    }(React.PureComponent);
-    AutoSizer.defaultProps = {
-        onResize: function onResize() {},
-        disableHeight: false,
-        disableWidth: false,
-        style: {}
+        },
+        t: function t2(date, token, _localize, options) {
+            var originalDate = options._originalDate || date;
+            var timestamp = Math.floor(originalDate.getTime() / 1e3);
+            return addLeadingZeros(timestamp, token.length);
+        },
+        T: function T2(date, token, _localize, options) {
+            var originalDate = options._originalDate || date;
+            var timestamp = originalDate.getTime();
+            return addLeadingZeros(timestamp, token.length);
+        }
     };
 
-    function _extends$1() {
-        _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
-            for (var i2 = 1; i2 < arguments.length; i2++) {
-                var source = arguments[i2];
-                for (var key in source) {
-                    if (Object.prototype.hasOwnProperty.call(source, key)) {
-                        target[key] = source[key];
-                    }
-                }
-            }
-            return target;
-        };
-        return _extends$1.apply(this, arguments);
-    }
-
-    function _assertThisInitialized(self2) {
-        if (self2 === void 0) {
-            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
+    function formatTimezoneShort(offset2, dirtyDelimiter) {
+        var sign2 = offset2 > 0 ? "-" : "+";
+        var absOffset = Math.abs(offset2);
+        var hours = Math.floor(absOffset / 60);
+        var minutes = absOffset % 60;
+        if (minutes === 0) {
+            return sign2 + String(hours);
         }
-        return self2;
+        var delimiter = dirtyDelimiter || "";
+        return sign2 + String(hours) + delimiter + addLeadingZeros(minutes, 2);
     }
 
-    function _setPrototypeOf(o2, p2) {
-        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
-            o3.__proto__ = p3;
-            return o3;
-        };
-        return _setPrototypeOf(o2, p2);
+    function formatTimezoneWithOptionalMinutes(offset2, dirtyDelimiter) {
+        if (offset2 % 60 === 0) {
+            var sign2 = offset2 > 0 ? "-" : "+";
+            return sign2 + addLeadingZeros(Math.abs(offset2) / 60, 2);
+        }
+        return formatTimezone(offset2, dirtyDelimiter);
     }
 
-    function _inheritsLoose(subClass, superClass) {
-        subClass.prototype = Object.create(superClass.prototype);
-        subClass.prototype.constructor = subClass;
-        _setPrototypeOf(subClass, superClass);
+    function formatTimezone(offset2, dirtyDelimiter) {
+        var delimiter = dirtyDelimiter || "";
+        var sign2 = offset2 > 0 ? "-" : "+";
+        var absOffset = Math.abs(offset2);
+        var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
+        var minutes = addLeadingZeros(absOffset % 60, 2);
+        return sign2 + hours + delimiter + minutes;
     }
-    var safeIsNaN = Number.isNaN || function ponyfill(value) {
-        return typeof value === "number" && value !== value;
-    };
-
-    function isEqual(first, second) {
-        if (first === second) {
-            return true;
-        }
-        if (safeIsNaN(first) && safeIsNaN(second)) {
-            return true;
+    const formatters$1 = formatters;
+    var dateLongFormatter = function dateLongFormatter2(pattern, formatLong2) {
+        switch (pattern) {
+            case "P":
+                return formatLong2.date({
+                    width: "short"
+                });
+            case "PP":
+                return formatLong2.date({
+                    width: "medium"
+                });
+            case "PPP":
+                return formatLong2.date({
+                    width: "long"
+                });
+            case "PPPP":
+            default:
+                return formatLong2.date({
+                    width: "full"
+                });
         }
-        return false;
-    }
-
-    function areInputsEqual(newInputs, lastInputs) {
-        if (newInputs.length !== lastInputs.length) {
-            return false;
+    };
+    var timeLongFormatter = function timeLongFormatter2(pattern, formatLong2) {
+        switch (pattern) {
+            case "p":
+                return formatLong2.time({
+                    width: "short"
+                });
+            case "pp":
+                return formatLong2.time({
+                    width: "medium"
+                });
+            case "ppp":
+                return formatLong2.time({
+                    width: "long"
+                });
+            case "pppp":
+            default:
+                return formatLong2.time({
+                    width: "full"
+                });
         }
-        for (var i2 = 0; i2 < newInputs.length; i2++) {
-            if (!isEqual(newInputs[i2], lastInputs[i2])) {
-                return false;
-            }
+    };
+    var dateTimeLongFormatter = function dateTimeLongFormatter2(pattern, formatLong2) {
+        var matchResult = pattern.match(/(P+)(p+)?/) || [];
+        var datePattern = matchResult[1];
+        var timePattern = matchResult[2];
+        if (!timePattern) {
+            return dateLongFormatter(pattern, formatLong2);
         }
-        return true;
-    }
-
-    function memoizeOne(resultFn, isEqual2) {
-        if (isEqual2 === void 0) {
-            isEqual2 = areInputsEqual;
+        var dateTimeFormat;
+        switch (datePattern) {
+            case "P":
+                dateTimeFormat = formatLong2.dateTime({
+                    width: "short"
+                });
+                break;
+            case "PP":
+                dateTimeFormat = formatLong2.dateTime({
+                    width: "medium"
+                });
+                break;
+            case "PPP":
+                dateTimeFormat = formatLong2.dateTime({
+                    width: "long"
+                });
+                break;
+            case "PPPP":
+            default:
+                dateTimeFormat = formatLong2.dateTime({
+                    width: "full"
+                });
+                break;
         }
-        var lastThis;
-        var lastArgs = [];
-        var lastResult;
-        var calledOnce = false;
+        return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
+    };
+    var longFormatters = {
+        p: timeLongFormatter,
+        P: dateTimeLongFormatter
+    };
+    const longFormatters$1 = longFormatters;
 
-        function memoized() {
-            var newArgs = [];
-            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
-                newArgs[_i2] = arguments[_i2];
-            }
-            if (calledOnce && lastThis === this && isEqual2(newArgs, lastArgs)) {
-                return lastResult;
-            }
-            lastResult = resultFn.apply(this, newArgs);
-            calledOnce = true;
-            lastThis = this;
-            lastArgs = newArgs;
-            return lastResult;
-        }
-        return memoized;
+    function getTimezoneOffsetInMilliseconds(date) {
+        var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
+        utcDate.setUTCFullYear(date.getFullYear());
+        return date.getTime() - utcDate.getTime();
     }
+    var protectedDayOfYearTokens = ["D", "DD"];
+    var protectedWeekYearTokens = ["YY", "YYYY"];
 
-    function _objectWithoutPropertiesLoose$1(source, excluded) {
-        if (source == null)
-            return {};
-        var target = {};
-        var sourceKeys = Object.keys(source);
-        var key, i2;
-        for (i2 = 0; i2 < sourceKeys.length; i2++) {
-            key = sourceKeys[i2];
-            if (excluded.indexOf(key) >= 0)
-                continue;
-            target[key] = source[key];
-        }
-        return target;
+    function isProtectedDayOfYearToken(token) {
+        return protectedDayOfYearTokens.indexOf(token) !== -1;
     }
-    var hasNativePerformanceNow = typeof performance === "object" && typeof performance.now === "function";
-    var now$1 = hasNativePerformanceNow ? function() {
-        return performance.now();
-    } : function() {
-        return Date.now();
-    };
 
-    function cancelTimeout(timeoutID) {
-        cancelAnimationFrame(timeoutID.id);
+    function isProtectedWeekYearToken(token) {
+        return protectedWeekYearTokens.indexOf(token) !== -1;
     }
 
-    function requestTimeout(callback, delay) {
-        var start2 = now$1();
-
-        function tick() {
-            if (now$1() - start2 >= delay) {
-                callback.call(null);
-            } else {
-                timeoutID.id = requestAnimationFrame(tick);
-            }
+    function throwProtectedError(token, format2, input) {
+        if (token === "YYYY") {
+            throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
+        } else if (token === "YY") {
+            throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
+        } else if (token === "D") {
+            throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
+        } else if (token === "DD") {
+            throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
         }
-        var timeoutID = {
-            id: requestAnimationFrame(tick)
-        };
-        return timeoutID;
     }
-    var size = -1;
-
-    function getScrollbarSize(recalculate) {
-        if (recalculate === void 0) {
-            recalculate = false;
-        }
-        if (size === -1 || recalculate) {
-            var div2 = document.createElement("div");
-            var style2 = div2.style;
-            style2.width = "50px";
-            style2.height = "50px";
-            style2.overflow = "scroll";
-            document.body.appendChild(div2);
-            size = div2.offsetWidth - div2.clientWidth;
-            document.body.removeChild(div2);
+    var formatDistanceLocale = {
+        lessThanXSeconds: {
+            one: "less than a second",
+            other: "less than {{count}} seconds"
+        },
+        xSeconds: {
+            one: "1 second",
+            other: "{{count}} seconds"
+        },
+        halfAMinute: "half a minute",
+        lessThanXMinutes: {
+            one: "less than a minute",
+            other: "less than {{count}} minutes"
+        },
+        xMinutes: {
+            one: "1 minute",
+            other: "{{count}} minutes"
+        },
+        aboutXHours: {
+            one: "about 1 hour",
+            other: "about {{count}} hours"
+        },
+        xHours: {
+            one: "1 hour",
+            other: "{{count}} hours"
+        },
+        xDays: {
+            one: "1 day",
+            other: "{{count}} days"
+        },
+        aboutXWeeks: {
+            one: "about 1 week",
+            other: "about {{count}} weeks"
+        },
+        xWeeks: {
+            one: "1 week",
+            other: "{{count}} weeks"
+        },
+        aboutXMonths: {
+            one: "about 1 month",
+            other: "about {{count}} months"
+        },
+        xMonths: {
+            one: "1 month",
+            other: "{{count}} months"
+        },
+        aboutXYears: {
+            one: "about 1 year",
+            other: "about {{count}} years"
+        },
+        xYears: {
+            one: "1 year",
+            other: "{{count}} years"
+        },
+        overXYears: {
+            one: "over 1 year",
+            other: "over {{count}} years"
+        },
+        almostXYears: {
+            one: "almost 1 year",
+            other: "almost {{count}} years"
         }
-        return size;
-    }
-    var cachedRTLResult = null;
-
-    function getRTLOffsetType(recalculate) {
-        if (recalculate === void 0) {
-            recalculate = false;
+    };
+    var formatDistance = function formatDistance2(token, count2, options) {
+        var result;
+        var tokenValue = formatDistanceLocale[token];
+        if (typeof tokenValue === "string") {
+            result = tokenValue;
+        } else if (count2 === 1) {
+            result = tokenValue.one;
+        } else {
+            result = tokenValue.other.replace("{{count}}", count2.toString());
         }
-        if (cachedRTLResult === null || recalculate) {
-            var outerDiv = document.createElement("div");
-            var outerStyle = outerDiv.style;
-            outerStyle.width = "50px";
-            outerStyle.height = "50px";
-            outerStyle.overflow = "scroll";
-            outerStyle.direction = "rtl";
-            var innerDiv = document.createElement("div");
-            var innerStyle = innerDiv.style;
-            innerStyle.width = "100px";
-            innerStyle.height = "100px";
-            outerDiv.appendChild(innerDiv);
-            document.body.appendChild(outerDiv);
-            if (outerDiv.scrollLeft > 0) {
-                cachedRTLResult = "positive-descending";
+        if (options !== null && options !== void 0 && options.addSuffix) {
+            if (options.comparison && options.comparison > 0) {
+                return "in " + result;
             } else {
-                outerDiv.scrollLeft = 1;
-                if (outerDiv.scrollLeft === 0) {
-                    cachedRTLResult = "negative";
-                } else {
-                    cachedRTLResult = "positive-ascending";
-                }
+                return result + " ago";
             }
-            document.body.removeChild(outerDiv);
-            return cachedRTLResult;
         }
-        return cachedRTLResult;
-    }
-    var IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;
-    var defaultItemKey$1 = function defaultItemKey(index2, data2) {
-        return index2;
+        return result;
     };
+    const formatDistance$1 = formatDistance;
 
-    function createListComponent(_ref2) {
-        var _class;
-        var getItemOffset = _ref2.getItemOffset,
-            getEstimatedTotalSize = _ref2.getEstimatedTotalSize,
-            getItemSize = _ref2.getItemSize,
-            getOffsetForIndexAndAlignment = _ref2.getOffsetForIndexAndAlignment,
-            getStartIndexForOffset = _ref2.getStartIndexForOffset,
-            getStopIndexForStartIndex = _ref2.getStopIndexForStartIndex,
-            initInstanceProps = _ref2.initInstanceProps,
-            shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,
-            validateProps = _ref2.validateProps;
-        return _class = /* @__PURE__ */ function(_PureComponent) {
-            _inheritsLoose(List2, _PureComponent);
+    function buildFormatLongFn(args) {
+        return function() {
+            var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
+            var width = options.width ? String(options.width) : args.defaultWidth;
+            var format2 = args.formats[width] || args.formats[args.defaultWidth];
+            return format2;
+        };
+    }
+    var dateFormats = {
+        full: "EEEE, MMMM do, y",
+        long: "MMMM do, y",
+        medium: "MMM d, y",
+        short: "MM/dd/yyyy"
+    };
+    var timeFormats = {
+        full: "h:mm:ss a zzzz",
+        long: "h:mm:ss a z",
+        medium: "h:mm:ss a",
+        short: "h:mm a"
+    };
+    var dateTimeFormats = {
+        full: "{{date}} 'at' {{time}}",
+        long: "{{date}} 'at' {{time}}",
+        medium: "{{date}}, {{time}}",
+        short: "{{date}}, {{time}}"
+    };
+    var formatLong = {
+        date: buildFormatLongFn({
+            formats: dateFormats,
+            defaultWidth: "full"
+        }),
+        time: buildFormatLongFn({
+            formats: timeFormats,
+            defaultWidth: "full"
+        }),
+        dateTime: buildFormatLongFn({
+            formats: dateTimeFormats,
+            defaultWidth: "full"
+        })
+    };
+    const formatLong$1 = formatLong;
+    var formatRelativeLocale = {
+        lastWeek: "'last' eeee 'at' p",
+        yesterday: "'yesterday at' p",
+        today: "'today at' p",
+        tomorrow: "'tomorrow at' p",
+        nextWeek: "eeee 'at' p",
+        other: "P"
+    };
+    var formatRelative = function formatRelative2(token, _date, _baseDate, _options) {
+        return formatRelativeLocale[token];
+    };
+    const formatRelative$1 = formatRelative;
 
-            function List2(props) {
-                var _this;
-                _this = _PureComponent.call(this, props) || this;
-                _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));
-                _this._outerRef = void 0;
-                _this._resetIsScrollingTimeoutId = null;
-                _this.state = {
-                    instance: _assertThisInitialized(_this),
-                    isScrolling: false,
-                    scrollDirection: "forward",
-                    scrollOffset: typeof _this.props.initialScrollOffset === "number" ? _this.props.initialScrollOffset : 0,
-                    scrollUpdateWasRequested: false
-                };
-                _this._callOnItemsRendered = void 0;
-                _this._callOnItemsRendered = memoizeOne(function(overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {
-                    return _this.props.onItemsRendered({
-                        overscanStartIndex,
-                        overscanStopIndex,
-                        visibleStartIndex,
-                        visibleStopIndex
-                    });
-                });
-                _this._callOnScroll = void 0;
-                _this._callOnScroll = memoizeOne(function(scrollDirection, scrollOffset, scrollUpdateWasRequested) {
-                    return _this.props.onScroll({
-                        scrollDirection,
-                        scrollOffset,
-                        scrollUpdateWasRequested
-                    });
-                });
-                _this._getItemStyle = void 0;
-                _this._getItemStyle = function(index2) {
-                    var _this$props = _this.props,
-                        direction = _this$props.direction,
-                        itemSize = _this$props.itemSize,
-                        layout2 = _this$props.layout;
-                    var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout2, shouldResetStyleCacheOnItemSizeChange && direction);
-                    var style2;
-                    if (itemStyleCache.hasOwnProperty(index2)) {
-                        style2 = itemStyleCache[index2];
-                    } else {
-                        var _offset = getItemOffset(_this.props, index2, _this._instanceProps);
-                        var size2 = getItemSize(_this.props, index2, _this._instanceProps);
-                        var isHorizontal = direction === "horizontal" || layout2 === "horizontal";
-                        var isRtl = direction === "rtl";
-                        var offsetHorizontal = isHorizontal ? _offset : 0;
-                        itemStyleCache[index2] = style2 = {
-                            position: "absolute",
-                            left: isRtl ? void 0 : offsetHorizontal,
-                            right: isRtl ? offsetHorizontal : void 0,
-                            top: !isHorizontal ? _offset : 0,
-                            height: !isHorizontal ? size2 : "100%",
-                            width: isHorizontal ? size2 : "100%"
-                        };
-                    }
-                    return style2;
-                };
-                _this._getItemStyleCache = void 0;
-                _this._getItemStyleCache = memoizeOne(function(_2, __, ___) {
-                    return {};
-                });
-                _this._onScrollHorizontal = function(event2) {
-                    var _event$currentTarget = event2.currentTarget,
-                        clientWidth = _event$currentTarget.clientWidth,
-                        scrollLeft = _event$currentTarget.scrollLeft,
-                        scrollWidth = _event$currentTarget.scrollWidth;
-                    _this.setState(function(prevState) {
-                        if (prevState.scrollOffset === scrollLeft) {
-                            return null;
-                        }
-                        var direction = _this.props.direction;
-                        var scrollOffset = scrollLeft;
-                        if (direction === "rtl") {
-                            switch (getRTLOffsetType()) {
-                                case "negative":
-                                    scrollOffset = -scrollLeft;
-                                    break;
-                                case "positive-descending":
-                                    scrollOffset = scrollWidth - clientWidth - scrollLeft;
-                                    break;
-                            }
-                        }
-                        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
-                        return {
-                            isScrolling: true,
-                            scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
-                            scrollOffset,
-                            scrollUpdateWasRequested: false
-                        };
-                    }, _this._resetIsScrollingDebounced);
-                };
-                _this._onScrollVertical = function(event2) {
-                    var _event$currentTarget2 = event2.currentTarget,
-                        clientHeight = _event$currentTarget2.clientHeight,
-                        scrollHeight = _event$currentTarget2.scrollHeight,
-                        scrollTop = _event$currentTarget2.scrollTop;
-                    _this.setState(function(prevState) {
-                        if (prevState.scrollOffset === scrollTop) {
-                            return null;
-                        }
-                        var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
-                        return {
-                            isScrolling: true,
-                            scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
-                            scrollOffset,
-                            scrollUpdateWasRequested: false
-                        };
-                    }, _this._resetIsScrollingDebounced);
-                };
-                _this._outerRefSetter = function(ref2) {
-                    var outerRef = _this.props.outerRef;
-                    _this._outerRef = ref2;
-                    if (typeof outerRef === "function") {
-                        outerRef(ref2);
-                    } else if (outerRef != null && typeof outerRef === "object" && outerRef.hasOwnProperty("current")) {
-                        outerRef.current = ref2;
-                    }
-                };
-                _this._resetIsScrollingDebounced = function() {
-                    if (_this._resetIsScrollingTimeoutId !== null) {
-                        cancelTimeout(_this._resetIsScrollingTimeoutId);
-                    }
-                    _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);
-                };
-                _this._resetIsScrolling = function() {
-                    _this._resetIsScrollingTimeoutId = null;
-                    _this.setState({
-                        isScrolling: false
-                    }, function() {
-                        _this._getItemStyleCache(-1, null);
-                    });
-                };
-                return _this;
+    function buildLocalizeFn(args) {
+        return function(dirtyIndex, options) {
+            var context2 = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
+            var valuesArray;
+            if (context2 === "formatting" && args.formattingValues) {
+                var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
+                var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
+                valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
+            } else {
+                var _defaultWidth = args.defaultWidth;
+                var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
+                valuesArray = args.values[_width] || args.values[_defaultWidth];
             }
-            List2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
-                validateSharedProps$1(nextProps, prevState);
-                validateProps(nextProps);
-                return null;
-            };
-            var _proto = List2.prototype;
-            _proto.scrollTo = function scrollTo(scrollOffset) {
-                scrollOffset = Math.max(0, scrollOffset);
-                this.setState(function(prevState) {
-                    if (prevState.scrollOffset === scrollOffset) {
-                        return null;
-                    }
-                    return {
-                        scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
-                        scrollOffset,
-                        scrollUpdateWasRequested: true
-                    };
-                }, this._resetIsScrollingDebounced);
-            };
-            _proto.scrollToItem = function scrollToItem(index2, align) {
-                if (align === void 0) {
-                    align = "auto";
-                }
-                var _this$props2 = this.props,
-                    itemCount = _this$props2.itemCount,
-                    layout2 = _this$props2.layout;
-                var scrollOffset = this.state.scrollOffset;
-                index2 = Math.max(0, Math.min(index2, itemCount - 1));
-                var scrollbarSize = 0;
-                if (this._outerRef) {
-                    var outerRef = this._outerRef;
-                    if (layout2 === "vertical") {
-                        scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;
-                    } else {
-                        scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;
-                    }
-                }
-                this.scrollTo(getOffsetForIndexAndAlignment(this.props, index2, align, scrollOffset, this._instanceProps, scrollbarSize));
-            };
-            _proto.componentDidMount = function componentDidMount() {
-                var _this$props3 = this.props,
-                    direction = _this$props3.direction,
-                    initialScrollOffset = _this$props3.initialScrollOffset,
-                    layout2 = _this$props3.layout;
-                if (typeof initialScrollOffset === "number" && this._outerRef != null) {
-                    var outerRef = this._outerRef;
-                    if (direction === "horizontal" || layout2 === "horizontal") {
-                        outerRef.scrollLeft = initialScrollOffset;
-                    } else {
-                        outerRef.scrollTop = initialScrollOffset;
-                    }
-                }
-                this._callPropsCallbacks();
-            };
-            _proto.componentDidUpdate = function componentDidUpdate() {
-                var _this$props4 = this.props,
-                    direction = _this$props4.direction,
-                    layout2 = _this$props4.layout;
-                var _this$state = this.state,
-                    scrollOffset = _this$state.scrollOffset,
-                    scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;
-                if (scrollUpdateWasRequested && this._outerRef != null) {
-                    var outerRef = this._outerRef;
-                    if (direction === "horizontal" || layout2 === "horizontal") {
-                        if (direction === "rtl") {
-                            switch (getRTLOffsetType()) {
-                                case "negative":
-                                    outerRef.scrollLeft = -scrollOffset;
-                                    break;
-                                case "positive-ascending":
-                                    outerRef.scrollLeft = scrollOffset;
-                                    break;
-                                default:
-                                    var clientWidth = outerRef.clientWidth,
-                                        scrollWidth = outerRef.scrollWidth;
-                                    outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;
-                                    break;
-                            }
-                        } else {
-                            outerRef.scrollLeft = scrollOffset;
-                        }
-                    } else {
-                        outerRef.scrollTop = scrollOffset;
-                    }
-                }
-                this._callPropsCallbacks();
-            };
-            _proto.componentWillUnmount = function componentWillUnmount() {
-                if (this._resetIsScrollingTimeoutId !== null) {
-                    cancelTimeout(this._resetIsScrollingTimeoutId);
-                }
-            };
-            _proto.render = function render2() {
-                var _this$props5 = this.props,
-                    children2 = _this$props5.children,
-                    className = _this$props5.className,
-                    direction = _this$props5.direction,
-                    height = _this$props5.height,
-                    innerRef = _this$props5.innerRef,
-                    innerElementType = _this$props5.innerElementType,
-                    innerTagName = _this$props5.innerTagName,
-                    itemCount = _this$props5.itemCount,
-                    itemData = _this$props5.itemData,
-                    _this$props5$itemKey = _this$props5.itemKey,
-                    itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey,
-                    layout2 = _this$props5.layout,
-                    outerElementType = _this$props5.outerElementType,
-                    outerTagName = _this$props5.outerTagName,
-                    style2 = _this$props5.style,
-                    useIsScrolling = _this$props5.useIsScrolling,
-                    width = _this$props5.width;
-                var isScrolling = this.state.isScrolling;
-                var isHorizontal = direction === "horizontal" || layout2 === "horizontal";
-                var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;
-                var _this$_getRangeToRend = this._getRangeToRender(),
-                    startIndex = _this$_getRangeToRend[0],
-                    stopIndex = _this$_getRangeToRend[1];
-                var items = [];
-                if (itemCount > 0) {
-                    for (var _index = startIndex; _index <= stopIndex; _index++) {
-                        items.push(React.createElement(children2, {
-                            data: itemData,
-                            key: itemKey(_index, itemData),
-                            index: _index,
-                            isScrolling: useIsScrolling ? isScrolling : void 0,
-                            style: this._getItemStyle(_index)
-                        }));
-                    }
-                }
-                var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);
-                return React.createElement(outerElementType || outerTagName || "div", {
-                    className,
-                    onScroll,
-                    ref: this._outerRefSetter,
-                    style: _extends$1({
-                        position: "relative",
-                        height,
-                        width,
-                        overflow: "auto",
-                        WebkitOverflowScrolling: "touch",
-                        willChange: "transform",
-                        direction
-                    }, style2)
-                }, React.createElement(innerElementType || innerTagName || "div", {
-                    children: items,
-                    ref: innerRef,
-                    style: {
-                        height: isHorizontal ? "100%" : estimatedTotalSize,
-                        pointerEvents: isScrolling ? "none" : void 0,
-                        width: isHorizontal ? estimatedTotalSize : "100%"
-                    }
-                }));
-            };
-            _proto._callPropsCallbacks = function _callPropsCallbacks() {
-                if (typeof this.props.onItemsRendered === "function") {
-                    var itemCount = this.props.itemCount;
-                    if (itemCount > 0) {
-                        var _this$_getRangeToRend2 = this._getRangeToRender(),
-                            _overscanStartIndex = _this$_getRangeToRend2[0],
-                            _overscanStopIndex = _this$_getRangeToRend2[1],
-                            _visibleStartIndex = _this$_getRangeToRend2[2],
-                            _visibleStopIndex = _this$_getRangeToRend2[3];
-                        this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);
-                    }
-                }
-                if (typeof this.props.onScroll === "function") {
-                    var _this$state2 = this.state,
-                        _scrollDirection = _this$state2.scrollDirection,
-                        _scrollOffset = _this$state2.scrollOffset,
-                        _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;
-                    this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);
-                }
-            };
-            _proto._getRangeToRender = function _getRangeToRender() {
-                var _this$props6 = this.props,
-                    itemCount = _this$props6.itemCount,
-                    overscanCount = _this$props6.overscanCount;
-                var _this$state3 = this.state,
-                    isScrolling = _this$state3.isScrolling,
-                    scrollDirection = _this$state3.scrollDirection,
-                    scrollOffset = _this$state3.scrollOffset;
-                if (itemCount === 0) {
-                    return [0, 0, 0, 0];
-                }
-                var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);
-                var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps);
-                var overscanBackward = !isScrolling || scrollDirection === "backward" ? Math.max(1, overscanCount) : 1;
-                var overscanForward = !isScrolling || scrollDirection === "forward" ? Math.max(1, overscanCount) : 1;
-                return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
-            };
-            return List2;
-        }(React.PureComponent), _class.defaultProps = {
-            direction: "ltr",
-            itemData: void 0,
-            layout: "vertical",
-            overscanCount: 2,
-            useIsScrolling: false
-        }, _class;
+            var index2 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
+            return valuesArray[index2];
+        };
     }
-    var validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {
-        _ref2.children;
-        _ref2.direction;
-        _ref2.height;
-        _ref2.layout;
-        _ref2.innerTagName;
-        _ref2.outerTagName;
-        _ref2.width;
-        _ref3.instance;
+    var eraValues = {
+        narrow: ["B", "A"],
+        abbreviated: ["BC", "AD"],
+        wide: ["Before Christ", "Anno Domini"]
     };
-    var FixedSizeList = /* @__PURE__ */ createListComponent({
-        getItemOffset: function getItemOffset(_ref2, index2) {
-            var itemSize = _ref2.itemSize;
-            return index2 * itemSize;
-        },
-        getItemSize: function getItemSize(_ref2, index2) {
-            var itemSize = _ref2.itemSize;
-            return itemSize;
-        },
-        getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {
-            var itemCount = _ref3.itemCount,
-                itemSize = _ref3.itemSize;
-            return itemSize * itemCount;
+    var quarterValues = {
+        narrow: ["1", "2", "3", "4"],
+        abbreviated: ["Q1", "Q2", "Q3", "Q4"],
+        wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
+    };
+    var monthValues = {
+        narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
+        abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
+        wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
+    };
+    var dayValues = {
+        narrow: ["S", "M", "T", "W", "T", "F", "S"],
+        short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
+        abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
+        wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
+    };
+    var dayPeriodValues = {
+        narrow: {
+            am: "a",
+            pm: "p",
+            midnight: "mi",
+            noon: "n",
+            morning: "morning",
+            afternoon: "afternoon",
+            evening: "evening",
+            night: "night"
         },
-        getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index2, align, scrollOffset, instanceProps, scrollbarSize) {
-            var direction = _ref4.direction,
-                height = _ref4.height,
-                itemCount = _ref4.itemCount,
-                itemSize = _ref4.itemSize,
-                layout2 = _ref4.layout,
-                width = _ref4.width;
-            var isHorizontal = direction === "horizontal" || layout2 === "horizontal";
-            var size2 = isHorizontal ? width : height;
-            var lastItemOffset = Math.max(0, itemCount * itemSize - size2);
-            var maxOffset2 = Math.min(lastItemOffset, index2 * itemSize);
-            var minOffset = Math.max(0, index2 * itemSize - size2 + itemSize + scrollbarSize);
-            if (align === "smart") {
-                if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset2 + size2) {
-                    align = "auto";
-                } else {
-                    align = "center";
-                }
-            }
-            switch (align) {
-                case "start":
-                    return maxOffset2;
-                case "end":
-                    return minOffset;
-                case "center": {
-                    var middleOffset = Math.round(minOffset + (maxOffset2 - minOffset) / 2);
-                    if (middleOffset < Math.ceil(size2 / 2)) {
-                        return 0;
-                    } else if (middleOffset > lastItemOffset + Math.floor(size2 / 2)) {
-                        return lastItemOffset;
-                    } else {
-                        return middleOffset;
-                    }
-                }
-                case "auto":
-                default:
-                    if (scrollOffset >= minOffset && scrollOffset <= maxOffset2) {
-                        return scrollOffset;
-                    } else if (scrollOffset < minOffset) {
-                        return minOffset;
-                    } else {
-                        return maxOffset2;
-                    }
-            }
+        abbreviated: {
+            am: "AM",
+            pm: "PM",
+            midnight: "midnight",
+            noon: "noon",
+            morning: "morning",
+            afternoon: "afternoon",
+            evening: "evening",
+            night: "night"
         },
-        getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset2) {
-            var itemCount = _ref5.itemCount,
-                itemSize = _ref5.itemSize;
-            return Math.max(0, Math.min(itemCount - 1, Math.floor(offset2 / itemSize)));
+        wide: {
+            am: "a.m.",
+            pm: "p.m.",
+            midnight: "midnight",
+            noon: "noon",
+            morning: "morning",
+            afternoon: "afternoon",
+            evening: "evening",
+            night: "night"
+        }
+    };
+    var formattingDayPeriodValues = {
+        narrow: {
+            am: "a",
+            pm: "p",
+            midnight: "mi",
+            noon: "n",
+            morning: "in the morning",
+            afternoon: "in the afternoon",
+            evening: "in the evening",
+            night: "at night"
         },
-        getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {
-            var direction = _ref6.direction,
-                height = _ref6.height,
-                itemCount = _ref6.itemCount,
-                itemSize = _ref6.itemSize,
-                layout2 = _ref6.layout,
-                width = _ref6.width;
-            var isHorizontal = direction === "horizontal" || layout2 === "horizontal";
-            var offset2 = startIndex * itemSize;
-            var size2 = isHorizontal ? width : height;
-            var numVisibleItems = Math.ceil((size2 + scrollOffset - offset2) / itemSize);
-            return Math.max(0, Math.min(
-                itemCount - 1,
-                startIndex + numVisibleItems - 1
-            ));
+        abbreviated: {
+            am: "AM",
+            pm: "PM",
+            midnight: "midnight",
+            noon: "noon",
+            morning: "in the morning",
+            afternoon: "in the afternoon",
+            evening: "in the evening",
+            night: "at night"
         },
-        initInstanceProps: function initInstanceProps(props) {},
-        shouldResetStyleCacheOnItemSizeChange: true,
-        validateProps: function validateProps(_ref7) {
-            _ref7.itemSize;
+        wide: {
+            am: "a.m.",
+            pm: "p.m.",
+            midnight: "midnight",
+            noon: "noon",
+            morning: "in the morning",
+            afternoon: "in the afternoon",
+            evening: "in the evening",
+            night: "at night"
         }
-    });
-
-    function shallowDiffers(prev, next2) {
-        for (var attribute in prev) {
-            if (!(attribute in next2)) {
-                return true;
+    };
+    var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
+        var number2 = Number(dirtyNumber);
+        var rem100 = number2 % 100;
+        if (rem100 > 20 || rem100 < 10) {
+            switch (rem100 % 10) {
+                case 1:
+                    return number2 + "st";
+                case 2:
+                    return number2 + "nd";
+                case 3:
+                    return number2 + "rd";
             }
         }
-        for (var _attribute in next2) {
-            if (prev[_attribute] !== next2[_attribute]) {
-                return true;
+        return number2 + "th";
+    };
+    var localize = {
+        ordinalNumber,
+        era: buildLocalizeFn({
+            values: eraValues,
+            defaultWidth: "wide"
+        }),
+        quarter: buildLocalizeFn({
+            values: quarterValues,
+            defaultWidth: "wide",
+            argumentCallback: function argumentCallback(quarter) {
+                return quarter - 1;
             }
-        }
-        return false;
-    }
-    var _excluded$1 = ["style"],
-        _excluded2 = ["style"];
+        }),
+        month: buildLocalizeFn({
+            values: monthValues,
+            defaultWidth: "wide"
+        }),
+        day: buildLocalizeFn({
+            values: dayValues,
+            defaultWidth: "wide"
+        }),
+        dayPeriod: buildLocalizeFn({
+            values: dayPeriodValues,
+            defaultWidth: "wide",
+            formattingValues: formattingDayPeriodValues,
+            defaultFormattingWidth: "wide"
+        })
+    };
+    const localize$1 = localize;
 
-    function areEqual(prevProps, nextProps) {
-        var prevStyle = prevProps.style,
-            prevRest = _objectWithoutPropertiesLoose$1(prevProps, _excluded$1);
-        var nextStyle = nextProps.style,
-            nextRest = _objectWithoutPropertiesLoose$1(nextProps, _excluded2);
-        return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);
+    function buildMatchFn(args) {
+        return function(string2) {
+            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
+            var width = options.width;
+            var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
+            var matchResult = string2.match(matchPattern);
+            if (!matchResult) {
+                return null;
+            }
+            var matchedString = matchResult[0];
+            var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
+            var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
+                return pattern.test(matchedString);
+            }) : findKey(parsePatterns, function(pattern) {
+                return pattern.test(matchedString);
+            });
+            var value;
+            value = args.valueCallback ? args.valueCallback(key) : key;
+            value = options.valueCallback ? options.valueCallback(value) : value;
+            var rest = string2.slice(matchedString.length);
+            return {
+                value,
+                rest
+            };
+        };
     }
-    const GlobalStyle = styled.createGlobalStyle`
-    body {
-        /* stylelint-disable-next-line -- external classname */
-        .DatetimeFilterSelect {
-            background-color: ${(props) => props.theme.colors.grey1};
-
-            span {
-                background-color: ${(props) => props.theme.colors.grey1};
-                border-bottom: 1px solid ${(props) => props.theme.colors.grey1};
 
-                &[aria-selected="true"] {
-                    background-color: ${(props) => props.theme.colors.primary};
-                }
-
-                :hover {
-                    background-color: ${(props) => props.theme.colors.grey3};
-                }
-
-                :active {
-                    background-color: ${(props) => props.theme.colors.grey4};
-                }
+    function findKey(object2, predicate) {
+        for (var key in object2) {
+            if (object2.hasOwnProperty(key) && predicate(object2[key])) {
+                return key;
             }
         }
+        return void 0;
     }
-`;
-    const DatetimeFilterWrapper = styled__default.default(FilterWrapper)`
-    gap: 0;
-`;
-    const DatepickerWrapper = styled__default.default.div`
-    height: auto;
-
-    div:has(input) {
-        width: 6.7rem;
-    }
-
-    input {
-        width: 6.7rem;
-        padding: 0;
-        background-color: ${(props) => props.theme.colors.background};
-        border: 1px solid ${(props) => props.theme.colors.background};
 
-        ::after {
-            width: 5rem;
-        }
-
-        :hover:not(:disabled) {
-            background-color: ${(props) => props.theme.colors.background};
-            border: 1px solid ${(props) => props.theme.colors.grey4};
+    function findIndex(array2, predicate) {
+        for (var key = 0; key < array2.length; key++) {
+            if (predicate(array2[key])) {
+                return key;
+            }
         }
+        return void 0;
     }
 
-    div:has(> button) {
-        border: 1px solid ${(props) => props.theme.colors.grey1};
-
-        :hover {
-            border: 1px solid ${(props) => props.theme.colors.grey1};
-        }
-
-        :focus-within {
-            border: 1px solid ${(props) => props.theme.colors.grey1};
-        }
+    function buildMatchPatternFn(args) {
+        return function(string2) {
+            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
+            var matchResult = string2.match(args.matchPattern);
+            if (!matchResult)
+                return null;
+            var matchedString = matchResult[0];
+            var parseResult = string2.match(args.parsePattern);
+            if (!parseResult)
+                return null;
+            var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
+            value = options.valueCallback ? options.valueCallback(value) : value;
+            var rest = string2.slice(matchedString.length);
+            return {
+                value,
+                rest
+            };
+        };
     }
-
-    button {
-        background-color: ${(props) => props.theme.colors.grey1};
-
-        :hover:enabled {
-            background-color: ${(props) => props.theme.colors.grey2};
+    var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
+    var parseOrdinalNumberPattern = /\d+/i;
+    var matchEraPatterns = {
+        narrow: /^(b|a)/i,
+        abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
+        wide: /^(before christ|before common era|anno domini|common era)/i
+    };
+    var parseEraPatterns = {
+        any: [/^b/i, /^(a|c)/i]
+    };
+    var matchQuarterPatterns = {
+        narrow: /^[1234]/i,
+        abbreviated: /^q[1234]/i,
+        wide: /^[1234](th|st|nd|rd)? quarter/i
+    };
+    var parseQuarterPatterns = {
+        any: [/1/i, /2/i, /3/i, /4/i]
+    };
+    var matchMonthPatterns = {
+        narrow: /^[jfmasond]/i,
+        abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
+        wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
+    };
+    var parseMonthPatterns = {
+        narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
+        any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
+    };
+    var matchDayPatterns = {
+        narrow: /^[smtwf]/i,
+        short: /^(su|mo|tu|we|th|fr|sa)/i,
+        abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
+        wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
+    };
+    var parseDayPatterns = {
+        narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
+        any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
+    };
+    var matchDayPeriodPatterns = {
+        narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
+        any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
+    };
+    var parseDayPeriodPatterns = {
+        any: {
+            am: /^a/i,
+            pm: /^p/i,
+            midnight: /^mi/i,
+            noon: /^no/i,
+            morning: /morning/i,
+            afternoon: /afternoon/i,
+            evening: /evening/i,
+            night: /night/i
         }
-    }
-
-    .react-datepicker {
-        margin-bottom: -1rem;
-        margin-left: -0.5rem;
-
-        background-color: ${(props) => props.theme.colors.grey1};
-        border: none;
-        box-shadow: none;
-
-        /* stylelint-disable -- external classnames */
-        .react-datepicker__month-container {
-            .react-datepicker__header {
-                background-color: ${(props) => props.theme.colors.grey1};
+    };
+    var match$1 = {
+        ordinalNumber: buildMatchPatternFn({
+            matchPattern: matchOrdinalNumberPattern,
+            parsePattern: parseOrdinalNumberPattern,
+            valueCallback: function valueCallback(value) {
+                return parseInt(value, 10);
             }
-
-            .react-datepicker__month {
-                background-color: ${(props) => props.theme.colors.grey1};
+        }),
+        era: buildMatchFn({
+            matchPatterns: matchEraPatterns,
+            defaultMatchWidth: "wide",
+            parsePatterns: parseEraPatterns,
+            defaultParseWidth: "any"
+        }),
+        quarter: buildMatchFn({
+            matchPatterns: matchQuarterPatterns,
+            defaultMatchWidth: "wide",
+            parsePatterns: parseQuarterPatterns,
+            defaultParseWidth: "any",
+            valueCallback: function valueCallback(index2) {
+                return index2 + 1;
             }
+        }),
+        month: buildMatchFn({
+            matchPatterns: matchMonthPatterns,
+            defaultMatchWidth: "wide",
+            parsePatterns: parseMonthPatterns,
+            defaultParseWidth: "any"
+        }),
+        day: buildMatchFn({
+            matchPatterns: matchDayPatterns,
+            defaultMatchWidth: "wide",
+            parsePatterns: parseDayPatterns,
+            defaultParseWidth: "any"
+        }),
+        dayPeriod: buildMatchFn({
+            matchPatterns: matchDayPeriodPatterns,
+            defaultMatchWidth: "any",
+            parsePatterns: parseDayPeriodPatterns,
+            defaultParseWidth: "any"
+        })
+    };
+    const match$2 = match$1;
+    var locale = {
+        code: "en-US",
+        formatDistance: formatDistance$1,
+        formatLong: formatLong$1,
+        formatRelative: formatRelative$1,
+        localize: localize$1,
+        match: match$2,
+        options: {
+            weekStartsOn: 0,
+            firstWeekContainsDate: 1
         }
-    }
-`;
-    const StyledSelect$1 = styled__default.default(Select$1)`
-    margin-bottom: 0.25rem;
-    border: 1px solid ${(props) => props.theme.colors.background};
-
-    button {
-        background-color: ${(props) => props.theme.colors.background};
+    };
+    const defaultLocale = locale;
+    var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
+    var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
+    var escapedStringRegExp$1 = /^'([^]*?)'?$/;
+    var doubleQuoteRegExp$1 = /''/g;
+    var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
 
-        :hover:enabled {
-            background-color: ${(props) => props.theme.colors.background};
+    function format$1(dirtyDate, dirtyFormatStr, options) {
+        var _ref2, _options$locale, _ref22, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
+        requiredArgs(2, arguments);
+        var formatStr = String(dirtyFormatStr);
+        var defaultOptions2 = getDefaultOptions();
+        var locale2 = (_ref2 = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref2 !== void 0 ? _ref2 : defaultLocale;
+        var firstWeekContainsDate = toInteger$2((_ref22 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref22 !== void 0 ? _ref22 : 1);
+        if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
+            throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
         }
-    }
-`;
-    const StyledApply = styled__default.default(ApplyButton)`
-    width: 4rem;
-    height: 2rem;
-    padding: 0;
-`;
-    const DatetimeFilterItems = [{
-        label: "None",
-        value: "None"
-    }, {
-        label: "Before",
-        value: "Before"
-    }, {
-        label: "After",
-        value: "After"
-    }, {
-        label: "On date",
-        value: "On date"
-    }, {
-        label: "Between",
-        value: "Between"
-    }];
-
-    function DatetimeFilter(props) {
-        const [selected, setSelected] = React.useState(null);
-        const [dateValues, setDateValues] = React.useState(props.values);
-        const filteredValues = React.useMemo(() => {
-            let filterDate = dateValues;
-            if ((selected === null || selected === void 0 ? void 0 : selected.value) !== "Between" && Array.isArray(dateValues)) {
-                [filterDate] = dateValues;
+        var weekStartsOn = toInteger$2((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
+        if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
+            throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
+        }
+        if (!locale2.localize) {
+            throw new RangeError("locale must contain localize property");
+        }
+        if (!locale2.formatLong) {
+            throw new RangeError("locale must contain formatLong property");
+        }
+        var originalDate = toDate(dirtyDate);
+        if (!isValid(originalDate)) {
+            throw new RangeError("Invalid time value");
+        }
+        var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
+        var utcDate = subMilliseconds(originalDate, timezoneOffset);
+        var formatterOptions = {
+            firstWeekContainsDate,
+            weekStartsOn,
+            locale: locale2,
+            _originalDate: originalDate
+        };
+        var result = formatStr.match(longFormattingTokensRegExp$1).map(function(substring) {
+            var firstCharacter = substring[0];
+            if (firstCharacter === "p" || firstCharacter === "P") {
+                var longFormatter = longFormatters$1[firstCharacter];
+                return longFormatter(substring, locale2.formatLong);
             }
-            return {
-                selected: selected === null || selected === void 0 ? void 0 : selected.label,
-                value: filterDate
-            };
-        }, [dateValues, selected]);
-        const [previousFilter, setPreviousFilter] = React.useState(filteredValues);
-        const disableApply = React.useMemo(() => {
-            if (props.disabled || previousFilter === filteredValues) {
-                return true;
+            return substring;
+        }).join("").match(formattingTokensRegExp$1).map(function(substring) {
+            if (substring === "''") {
+                return "'";
             }
-            if (!dateValues || selected.label === "Between" && Array.isArray(dateValues) && (!dateValues[0] || !dateValues[1]) || selected.label === "Between" && !Array.isArray(dateValues)) {
-                return true;
+            var firstCharacter = substring[0];
+            if (firstCharacter === "'") {
+                return cleanEscapedString$1(substring);
             }
-            return false;
-        }, [props.disabled, previousFilter, filteredValues, dateValues, selected]);
-        return jsxRuntime.exports.jsxs(DatetimeFilterWrapper, {
-            className: props.className,
-            children: [jsxRuntime.exports.jsx(GlobalStyle, {}), jsxRuntime.exports.jsxs(FilterHeader, {
-                children: [jsxRuntime.exports.jsx(StyledSelect$1, {
-                    dropdownRef: (element2) => {
-                        if (props.portalsRef) {
-                            props.portalsRef.current[2] = element2;
-                        }
-                    },
-                    initialValue: {
-                        label: "None",
-                        value: "None"
-                    },
-                    items: DatetimeFilterItems,
-                    onSelect: setSelected
-                }), jsxRuntime.exports.jsx(DatepickerWrapper, {
-                    children: selected && selected.label !== "None" && jsxRuntime.exports.jsx(DatePicker, {
-                        inline: true,
-                        onChange: setDateValues,
-                        portalsRef: props.portalsRef,
-                        selectItemClass: "DatetimeFilterSelect",
-                        selectsRange: (selected === null || selected === void 0 ? void 0 : selected.value) === "Between",
-                        shouldCloseOnSelect: false,
-                        showTimeInput: props.showTimeInput
-                    })
-                })]
-            }), jsxRuntime.exports.jsx(StyledApply, {
-                disabled: disableApply,
-                onClick: (e3) => {
-                    var _a3, _b;
-                    (_a3 = props.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, filteredValues, e3);
-                    (_b = props === null || props === void 0 ? void 0 : props.column) === null || _b === void 0 ? void 0 : _b.setFilter(filteredValues || void 0);
-                    setPreviousFilter(filteredValues);
-                },
-                children: "Apply"
-            })]
-        });
+            var formatter = formatters$1[firstCharacter];
+            if (formatter) {
+                if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
+                    throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
+                }
+                if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
+                    throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
+                }
+                return formatter(utcDate, substring, locale2.localize, formatterOptions);
+            }
+            if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
+                throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
+            }
+            return substring;
+        }).join("");
+        return result;
     }
-    var Action;
-    (function(Action2) {
-        Action2["COPY"] = "copy";
-        Action2["DELETE"] = "delete";
-        Action2["SELECT"] = "select";
-        Action2["SELECT_ALL"] = "select_all";
-        Action2["SWITCH"] = "switch";
-        Action2["UNSELECT_ALL"] = "unselect_all";
-    })(Action || (Action = {}));
-    const SelectCheck = styled__default.default(CheckSquare)`
-    color: ${(props) => props.theme.colors.primary};
-`;
 
-    function getSelectIcon(row) {
-        return row.selected ? SelectCheck : Square;
+    function cleanEscapedString$1(input) {
+        var matched = input.match(escapedStringRegExp$1);
+        if (!matched) {
+            return input;
+        }
+        return matched[1].replace(doubleQuoteRegExp$1, "'");
     }
-    const SwitchOn = styled__default.default(ToggleOn)`
-    color: ${(props) => props.theme.colors.primary};
-`;
+    var MILLISECONDS_IN_MINUTE = 6e4;
 
-    function getSwitchIcon(row) {
-        return row.active ? SwitchOn : ToggleOff;
+    function addMinutes(dirtyDate, dirtyAmount) {
+        requiredArgs(2, arguments);
+        var amount = toInteger$2(dirtyAmount);
+        return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE);
     }
-    const Actions = {
-        COPY: {
-            icon: Copy,
-            id: Action.COPY,
-            label: "Copy"
-        },
-        DELETE: {
-            icon: Trash,
-            id: Action.DELETE,
-            label: "Delete"
-        },
-        SELECT: {
-            getIcon: getSelectIcon,
-            id: Action.SELECT,
-            label: "Select Row"
-        },
-        SELECT_ALL: {
-            id: Action.SELECT_ALL,
-            label: "Select All Rows"
-        },
-        SWITCH: {
-            getIcon: getSwitchIcon,
-            id: Action.SWITCH,
-            label: "Switch On/Off"
-        },
-        UNSELECT_ALL: {
-            id: Action.UNSELECT_ALL,
-            label: "Unselect All Rows"
-        }
-    };
-    const ActionWrapper = styled__default.default.div`
-    display: flex;
-    align-items: center;
-    justify-content: flex-end;
-
-    width: 100%;
-    padding: 0 1rem;
+    var MILLISECONDS_IN_HOUR = 36e5;
 
-    svg:not(:last-of-type) {
-        margin-right: 0.7rem;
+    function addHours(dirtyDate, dirtyAmount) {
+        requiredArgs(2, arguments);
+        var amount = toInteger$2(dirtyAmount);
+        return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_HOUR);
     }
-`;
 
-    function ActionCell(props) {
-        if (!props.column.actions) {
-            throw new Error("Must pass an array of actions to the column def when using the ActionCell");
+    function addDays(dirtyDate, dirtyAmount) {
+        requiredArgs(2, arguments);
+        var date = toDate(dirtyDate);
+        var amount = toInteger$2(dirtyAmount);
+        if (isNaN(amount)) {
+            return new Date(NaN);
         }
-        return jsxRuntime.exports.jsx(ActionWrapper, {
-            className: "table-action-cell",
-            children: props.column.actions.map((action) => {
-                const Icon2 = action.getIcon ? action.getIcon(props.row.original) : action.icon;
-                if (Icon2 === void 0) {
-                    return;
-                }
-                const label = action.getLabel ? action.getLabel(props.row.original) : action.label;
-                const onClick = (e3) => {
-                    var _a3;
-                    e3.stopPropagation();
-                    (_a3 = props.onAction) === null || _a3 === void 0 ? void 0 : _a3.call(props, action.id, props.row.original);
-                };
-                return jsxRuntime.exports.jsx(Icon2, {
-                    asButton: true,
-                    onClick,
-                    title: label
-                }, action.label);
-            })
-        });
+        if (!amount) {
+            return date;
+        }
+        date.setDate(date.getDate() + amount);
+        return date;
     }
 
-    function DatetimeCell(fmt = "yyyy-MM-dd HH:mm") {
-        return ({
-            value
-        }) => {
-            if (!value) {
-                return "";
-            }
-            const parsed = parseISO$1(value);
-            if (Number.isNaN(parsed.getTime())) {
-                return "";
-            }
-            return format$2(parsed, fmt);
-        };
+    function addWeeks(dirtyDate, dirtyAmount) {
+        requiredArgs(2, arguments);
+        var amount = toInteger$2(dirtyAmount);
+        var days = amount * 7;
+        return addDays(dirtyDate, days);
     }
-    const InputWrapper = styled__default.default.div`
-    display: flex;
-    width: calc(100% + 22px);
-    margin: 0 -1rem;
-`;
-    const ValueWrapper$1 = styled__default.default.span`
-    display: flex;
-    flex: 1 1 auto;
-    align-items: center;
-    height: 100%;
-`;
 
-    function EditInputCell() {
-        return function InputCell(props) {
-            const [value, setValue] = React.useState(props.value);
-            React.useEffect(() => {
-                setValue(props.value);
-            }, [props.value]);
-            if (isEqual_1(props.currentEditCell, [props.rowIdx, props.column.id])) {
-                const onComplete = () => {
-                    if (props.onChange && value !== props.value) {
-                        props.onChange(value, props.rowIdx, props.column.id);
-                    }
-                    props.onStopEdit();
-                };
-                const onChange2 = (val) => {
-                    setValue(val);
-                };
-                return jsxRuntime.exports.jsx(InputWrapper, {
-                    children: jsxRuntime.exports.jsx(Input$3, {
-                        autoFocus: true,
-                        initialValue: props.value,
-                        onBlur: onComplete,
-                        onChange: onChange2,
-                        onComplete,
-                        style: {
-                            maxWidth: "100%"
-                        }
-                    })
-                });
-            }
-            return jsxRuntime.exports.jsx(ValueWrapper$1, {
-                "data-cell": [props.rowIdx, props.column.id],
-                onClick: props.onStartEdit,
-                children: props.value
-            });
-        };
+    function addMonths(dirtyDate, dirtyAmount) {
+        requiredArgs(2, arguments);
+        var date = toDate(dirtyDate);
+        var amount = toInteger$2(dirtyAmount);
+        if (isNaN(amount)) {
+            return new Date(NaN);
+        }
+        if (!amount) {
+            return date;
+        }
+        var dayOfMonth = date.getDate();
+        var endOfDesiredMonth = new Date(date.getTime());
+        endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
+        var daysInMonth = endOfDesiredMonth.getDate();
+        if (dayOfMonth >= daysInMonth) {
+            return endOfDesiredMonth;
+        } else {
+            date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
+            return date;
+        }
     }
-    const SelectWrapper = styled__default.default.div`
-    display: flex;
-    width: calc(100% + 22px);
-    margin: 0 -1rem;
-`;
-    const ValueWrapper = styled__default.default.span`
-    display: flex;
-    flex: 1 1 auto;
-    align-items: center;
-    height: 100%;
-`;
 
-    function EditSelectCell(items) {
-        return function SelectCell(props) {
-            const selectedItem = items.find((item) => item.value === props.value);
-            if (isEqual_1(props.currentEditCell, [props.rowIdx, props.column.id])) {
-                const onSelect = (item) => {
-                    if (props.onChange && item.value !== props.value) {
-                        props.onChange(item.value, props.rowIdx, props.column.id);
-                    }
-                    props.onStopEdit();
-                };
-                return jsxRuntime.exports.jsx(SelectWrapper, {
-                    children: jsxRuntime.exports.jsx(Select$1, {
-                        initialIsOpen: true,
-                        initialValue: selectedItem,
-                        items,
-                        onSelect,
-                        style: {
-                            flex: "1 1 auto"
-                        }
-                    })
-                });
-            }
-            return jsxRuntime.exports.jsx(ValueWrapper, {
-                "data-cell": [props.rowIdx, props.column.id],
-                onClick: props.onStartEdit,
-                children: selectedItem ? selectedItem.label : ""
-            });
-        };
+    function addYears(dirtyDate, dirtyAmount) {
+        requiredArgs(2, arguments);
+        var amount = toInteger$2(dirtyAmount);
+        return addMonths(dirtyDate, amount * 12);
     }
-    const FilterIcon = styled__default.default(FontAwesomeIcon)`
-    cursor: pointer;
-    color: ${(props) => props.$hasFilter ? props.theme.colors.primary : props.theme.colors.grey3};
-`;
-    const HeaderIconWrapper = styled__default.default.div`
-    display: flex;
-    align-items: center;
-    justify-content: center;
 
-    width: 1.5rem;
-    height: 1.5rem;
-
-    border-radius: 0.25rem;
-
-    :hover {
-        background-color: ${(props) => curriedTransparentize$2(0.9, props.theme.colors.primaryHover)};
+    function subDays(dirtyDate, dirtyAmount) {
+        requiredArgs(2, arguments);
+        var amount = toInteger$2(dirtyAmount);
+        return addDays(dirtyDate, -amount);
+    }
 
-        svg {
-            color: ${(props) => props.hasFilter ? props.theme.colors.primary : props.theme.colors.grey3};
-        }
+    function subWeeks(dirtyDate, dirtyAmount) {
+        requiredArgs(2, arguments);
+        var amount = toInteger$2(dirtyAmount);
+        return addWeeks(dirtyDate, -amount);
     }
 
-    :active {
-        background-color: ${(props) => curriedTransparentize$2(0.8, props.theme.colors.primaryDown)};
+    function subMonths(dirtyDate, dirtyAmount) {
+        requiredArgs(2, arguments);
+        var amount = toInteger$2(dirtyAmount);
+        return addMonths(dirtyDate, -amount);
     }
-`;
-    var NumericOperator;
-    (function(NumericOperator2) {
-        NumericOperator2["BT"] = "Between";
-        NumericOperator2["EQ"] = "Equal to";
-        NumericOperator2["GT"] = "Greater than";
-        NumericOperator2["LT"] = "Less than";
-        NumericOperator2["NE"] = "Not equal to";
-    })(NumericOperator || (NumericOperator = {}));
-    var DateOperator;
-    (function(DateOperator2) {
-        DateOperator2["BT"] = "Between";
-        DateOperator2["EQ"] = "On date";
-        DateOperator2["GT"] = "After";
-        DateOperator2["LT"] = "Before";
-    })(DateOperator || (DateOperator = {}));
 
-    function isValidOperator(op) {
-        return Object.keys(NumericOperator).map((key) => NumericOperator[key]).includes(op);
+    function subYears(dirtyDate, dirtyAmount) {
+        requiredArgs(2, arguments);
+        var amount = toInteger$2(dirtyAmount);
+        return addYears(dirtyDate, -amount);
     }
 
-    function isValidDatetimeOperator(op) {
-        return Object.keys(DateOperator).map((key) => DateOperator[key]).includes(op);
+    function getSeconds(dirtyDate) {
+        requiredArgs(1, arguments);
+        var date = toDate(dirtyDate);
+        var seconds = date.getSeconds();
+        return seconds;
     }
 
-    function applyNumericOperator(operator2, value, filterValue) {
-        switch (operator2) {
-            case NumericOperator.EQ:
-                return value === filterValue;
-            case NumericOperator.GT:
-                if (Array.isArray(filterValue)) {
-                    throw new Error("Cannot use array for GT operator");
-                }
-                return value > filterValue;
-            case NumericOperator.LT:
-                if (Array.isArray(filterValue)) {
-                    throw new Error("Cannot use array for LT operator");
-                }
-                return value < filterValue;
-            case NumericOperator.NE:
-                return value !== filterValue;
-            case NumericOperator.BT:
-                if (Array.isArray(filterValue)) {
-                    return value <= filterValue[1] && value >= filterValue[0];
-                }
-                break;
-            default:
-                return true;
-        }
+    function getMinutes(dirtyDate) {
+        requiredArgs(1, arguments);
+        var date = toDate(dirtyDate);
+        var minutes = date.getMinutes();
+        return minutes;
     }
 
-    function applyDatetimeOperator(operator2, value, filterValue) {
-        const parsedValue = parseISO$1(value);
-        if (Array.isArray(filterValue)) {
-            if (operator2 === DateOperator.BT) {
-                return isWithinInterval$1(parsedValue, {
-                    end: filterValue[1],
-                    start: filterValue[0]
-                });
-            }
-            return true;
-        }
-        switch (operator2) {
-            case DateOperator.EQ:
-                return isEqual$3(parsedValue, filterValue);
-            case DateOperator.GT:
-                return isAfter$1(parsedValue, filterValue);
-            case DateOperator.LT:
-                return isBefore$1(parsedValue, filterValue);
-            default:
-                return true;
-        }
+    function getHours(dirtyDate) {
+        requiredArgs(1, arguments);
+        var date = toDate(dirtyDate);
+        var hours = date.getHours();
+        return hours;
     }
 
-    function numeric(rows, columnIds, filterValue) {
-        const {
-            selected,
-            value
-        } = filterValue;
-        const [colId] = columnIds;
-        if (!isValidOperator(selected) || !value && value !== 0) {
-            return rows;
-        }
-        return rows.filter((row) => applyNumericOperator(selected, row.values[colId], value));
+    function getDay(dirtyDate) {
+        requiredArgs(1, arguments);
+        var date = toDate(dirtyDate);
+        var day = date.getDay();
+        return day;
     }
 
-    function datetime(rows, columnIds, filterValue) {
-        const {
-            selected,
-            value
-        } = filterValue;
-        const [colId] = columnIds;
-        if (!isValidDatetimeOperator(selected) || !value) {
-            return rows;
-        }
-        return rows.filter((row) => applyDatetimeOperator(selected, row.values[colId], value));
+    function getDate(dirtyDate) {
+        requiredArgs(1, arguments);
+        var date = toDate(dirtyDate);
+        var dayOfMonth = date.getDate();
+        return dayOfMonth;
     }
 
-    function categorical(rows, columnIds, filterItems) {
-        const [colId] = columnIds;
-        const filteredItems = filterItems.map((item) => item.value);
-        if (filteredItems.length === 0) {
-            return rows;
+    function startOfWeek(dirtyDate, options) {
+        var _ref2, _ref22, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
+        requiredArgs(1, arguments);
+        var defaultOptions2 = getDefaultOptions();
+        var weekStartsOn = toInteger$2((_ref2 = (_ref22 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : 0);
+        if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
+            throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
         }
-        return rows.filter((row) => filteredItems.includes(row.values[colId]));
+        var date = toDate(dirtyDate);
+        var day = date.getDay();
+        var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
+        date.setDate(date.getDate() - diff);
+        date.setHours(0, 0, 0, 0);
+        return date;
     }
 
-    function TextFilter(props) {
-        return jsxRuntime.exports.jsx(FilterWrapper, {
-            children: jsxRuntime.exports.jsx(StyledSearchBar, {
-                onChange: (val) => props.column.setFilter(val || void 0),
-                placeholder: "Rows containing value...",
-                value: props.column.filterValue || ""
-            })
+    function startOfISOWeek(dirtyDate) {
+        requiredArgs(1, arguments);
+        return startOfWeek(dirtyDate, {
+            weekStartsOn: 1
         });
     }
 
-    function FilterContainer(props) {
-        var _a3;
-        const [visible, setVisible] = React.useState(false);
-        const show = () => setVisible(true);
-        const hide2 = () => setVisible(false);
-        const hasFilter = !(props.col.filterValue === void 0 || ((_a3 = props.col.filterValue) === null || _a3 === void 0 ? void 0 : _a3.selected) === "None" || Array.isArray(props.col.filterValue) && props.col.filterValue.length === 0);
-        const items = React.useMemo(() => {
-            var _a4;
-            if ((_a4 = props.col) === null || _a4 === void 0 ? void 0 : _a4.uniqueItems) {
-                return props.col.uniqueItems.map((item) => ({
-                    label: item,
-                    value: item
-                }));
-            }
-        }, [props.col]);
-        const portalsRef = React.useRef([]);
-
-        function onClickOutside(instance2, event2) {
-            const target = event2.target;
-            for (const portal of portalsRef.current) {
-                if (portal === null || portal === void 0 ? void 0 : portal.contains(target)) {
-                    return;
-                }
-            }
-            hide2();
+    function getISOWeekYear(dirtyDate) {
+        requiredArgs(1, arguments);
+        var date = toDate(dirtyDate);
+        var year = date.getFullYear();
+        var fourthOfJanuaryOfNextYear = new Date(0);
+        fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
+        fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
+        var startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
+        var fourthOfJanuaryOfThisYear = new Date(0);
+        fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
+        fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
+        var startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
+        if (date.getTime() >= startOfNextYear.getTime()) {
+            return year + 1;
+        } else if (date.getTime() >= startOfThisYear.getTime()) {
+            return year;
+        } else {
+            return year - 1;
         }
-        return jsxRuntime.exports.jsx(Tooltip$1, {
-            content: props.col.render("Filter", {
-                items,
-                onChange: hide2,
-                portalsRef
-            }),
-            hidden: true,
-            interactive: true,
-            onClickOutside,
-            visible,
-            children: jsxRuntime.exports.jsx("span", {
-                children: jsxRuntime.exports.jsx(HeaderIconWrapper, {
-                    hasFilter,
-                    children: jsxRuntime.exports.jsx(FilterIcon, {
-                        "$hasFilter": hasFilter,
-                        icon: faFilter,
-                        onClick: show
-                    })
-                })
-            })
-        });
     }
-    var CheckboxState;
-    (function(CheckboxState2) {
-        CheckboxState2["CHECKED"] = "checked";
-        CheckboxState2["INDETERMINATE"] = "indeterminate";
-        CheckboxState2["UNCHECKED"] = "unchecked";
-    })(CheckboxState || (CheckboxState = {}));
-    const StyledTriStateCheckbox = styled__default.default.div`
-    ${(props) => {
-    if (props.state === CheckboxState.INDETERMINATE) {
-      return `
-                    span:after {
-                        display: block ;
-                        left: 0.07rem;
-                        top: 0.4rem;
-                        width: 0.75rem;
-                        border-radius: 0.25rem;
-                        height: 0px;
-                        border: 1px solid ${props.theme.colors.grey6};
-                        transform: rotate(0deg)
-                    }
 
-            `;
+    function startOfISOWeekYear(dirtyDate) {
+        requiredArgs(1, arguments);
+        var year = getISOWeekYear(dirtyDate);
+        var fourthOfJanuary = new Date(0);
+        fourthOfJanuary.setFullYear(year, 0, 4);
+        fourthOfJanuary.setHours(0, 0, 0, 0);
+        var date = startOfISOWeek(fourthOfJanuary);
+        return date;
     }
-  }}
-`;
+    var MILLISECONDS_IN_WEEK = 6048e5;
 
-    function computeState(allSelected, noneSelected) {
-        if (noneSelected) {
-            return CheckboxState.UNCHECKED;
-        }
-        return allSelected ? CheckboxState.CHECKED : CheckboxState.INDETERMINATE;
+    function getISOWeek(dirtyDate) {
+        requiredArgs(1, arguments);
+        var date = toDate(dirtyDate);
+        var diff = startOfISOWeek(date).getTime() - startOfISOWeekYear(date).getTime();
+        return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
     }
 
-    function getControlledState(allSelected, noneSelected) {
-        if (allSelected) {
-            return allSelected;
-        }
-        if (noneSelected) {
-            return false;
-        }
-        return void 0;
+    function getMonth(dirtyDate) {
+        requiredArgs(1, arguments);
+        var date = toDate(dirtyDate);
+        var month = date.getMonth();
+        return month;
     }
 
-    function TriStateCheckbox(props) {
-        const [state, setState] = React.useState(computeState(props.allSelected, props.noneSelected));
-        React.useEffect(() => {
-            setState(computeState(props.allSelected, props.noneSelected));
-        }, [props.allSelected, props.noneSelected]);
-        const onClick = (checked, e3) => {
-            setState(checked ? CheckboxState.CHECKED : CheckboxState.UNCHECKED);
-            if (props.onChange) {
-                if (state === CheckboxState.UNCHECKED) {
-                    props.onChange(CheckboxState.CHECKED, e3);
-                } else {
-                    props.onChange(CheckboxState.UNCHECKED, e3);
-                }
-            }
-        };
-        return jsxRuntime.exports.jsx(StyledTriStateCheckbox, {
-            state,
-            style: props.style,
-            children: jsxRuntime.exports.jsx(Checkbox, {
-                className: props.className,
-                disabled: props.disabled,
-                initialValue: state === CheckboxState.CHECKED,
-                onChange: (checked, event2) => {
-                    onClick(checked, event2);
-                },
-                selected: getControlledState(props.allSelected, props.noneSelected)
-            })
-        });
+    function getQuarter(dirtyDate) {
+        requiredArgs(1, arguments);
+        var date = toDate(dirtyDate);
+        var quarter = Math.floor(date.getMonth() / 3) + 1;
+        return quarter;
     }
 
-    function SelectHeader(props) {
-        const allValues = props.rows.map((r2) => r2.original.selected);
-        const countSelected = allValues.filter(Boolean).length;
-        const allSelected = countSelected > 0 && countSelected === allValues.length;
-        const noneSelected = countSelected === 0;
-        const onChange2 = (state) => {
-            if (state === CheckboxState.UNCHECKED) {
-                props.onAction(Action.UNSELECT_ALL);
-            } else if (state === CheckboxState.CHECKED) {
-                props.onAction(Action.SELECT_ALL, props.rows.map((r2) => r2.original));
-            }
-        };
-        return jsxRuntime.exports.jsx(TriStateCheckbox, {
-            allSelected,
-            noneSelected,
-            onChange: onChange2,
-            style: {
-                display: "flex",
-                justifyContent: "center"
-            }
-        });
+    function getYear(dirtyDate) {
+        requiredArgs(1, arguments);
+        return toDate(dirtyDate).getFullYear();
     }
-    const HeaderOptionsIcon = styled__default.default(FontAwesomeIcon)`
-    cursor: pointer;
-    align-items: center;
-    color: ${(props) => props.theme.colors.grey5};
-`;
-    const HeaderOptions = styled__default.default.div`
-    display: flex;
-    align-items: center;
-    justify-content: center;
-
-    width: 12px;
-
-    background-color: ${(props) => props.theme.colors.grey3};
-`;
-    const OptionsDropdownList = styled__default.default(List)`
-    background-color: ${(props) => props.theme.colors.background};
-    box-shadow: ${(props) => props.theme.shadow.light};
-`;
-    const OptionsMenu = ({
-        allColumns,
-        allowColumnHiding,
-        numVisibleColumns,
-        resetResizing,
-        setAllFilters,
-        style: style2
-    }) => {
-        const [optionsElement, setOptionsElement] = React.useState(null);
-        const [popperElement, setPopperElement] = React.useState(null);
-        const [showOptions, setShowOptions] = React.useState(false);
-        const {
-            styles: styles2,
-            attributes: attributes2,
-            update: update2
-        } = usePopper$1(optionsElement, popperElement, {
-            placement: "left-end"
-        });
-        const toggleOptions = () => {
-            setShowOptions(!showOptions);
-        };
-        const onOptionSelect = (option) => {
-            option.onClick();
-        };
-        const clickOutsideOptionsHandler = () => {
-            if (showOptions) {
-                toggleOptions();
-            }
-        };
-        useOnClickOutside(popperElement, clickOutsideOptionsHandler);
-        React.useEffect(() => {
-            if (showOptions) {
-                update2();
-            }
-        }, [showOptions, update2]);
-        const resetFunctions = React.useMemo(() => {
-            const functions2 = {
-                items: [{
-                    label: "Reset Column Widths",
-                    onClick: resetResizing,
-                    value: "resetResizing"
-                }, {
-                    label: "Reset Filters",
-                    onClick: () => setAllFilters([]),
-                    value: "resetFilters"
-                }],
-                label: "Reset"
-            };
-            if (allowColumnHiding) {
-                functions2.items.push({
-                    label: "Show All Columns",
-                    onClick: () => {
-                        allColumns.forEach((column) => {
-                            if (!column.isVisible) {
-                                column.toggleHidden();
-                            }
-                        });
-                    },
-                    value: "showAllColumns"
-                });
-            }
-            return functions2;
-        }, [resetResizing, setAllFilters, allColumns, allowColumnHiding]);
-        const columnToggles = React.useMemo(() => {
-            return {
-                items: allColumns.filter((column) => typeof column.Header === "string").map((column) => ({
-                    label: `${column.isVisible ? "Hide" : "Show"} ${String(column.Header)}`,
-                    onClick: () => !(column.isVisible && numVisibleColumns === 1) ? column.toggleHidden() : null,
-                    value: `${column.isVisible ? "hide" : "show"}${String(column.Header)}`
-                })),
-                label: "Columns"
-            };
-        }, [allColumns, allowColumnHiding, numVisibleColumns]);
-        return jsxRuntime.exports.jsxs(HeaderOptions, {
-            ref: setOptionsElement,
-            children: [jsxRuntime.exports.jsx(HeaderOptionsIcon, {
-                icon: faEllipsisV,
-                onClick: toggleOptions
-            }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(OptionsDropdownList, Object.assign({}, attributes2.popper, {
-                isOpen: showOptions,
-                ref: setPopperElement,
-                style: Object.assign(Object.assign(Object.assign({}, styles2.popper), {
-                    maxHeight: 800,
-                    minWidth: 150,
-                    zIndex: 9999
-                }), style2),
-                children: jsxRuntime.exports.jsx(SectionedList, {
-                    items: allowColumnHiding ? [resetFunctions, columnToggles] : [resetFunctions],
-                    onSelect: onOptionSelect
-                })
-            })), document.body)]
-        });
-    };
-    var __rest$7 = globalThis && globalThis.__rest || function(s2, e3) {
-        var t2 = {};
-        for (var p2 in s2)
-            if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
-                t2[p2] = s2[p2];
-        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
-            for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
-                if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
-                    t2[p2[i2]] = s2[p2[i2]];
-            }
-        return t2;
-    };
-    const {
-        fontSize
-    } = window.getComputedStyle(document.documentElement);
-    const ROW_HEIGHT = parseFloat(fontSize) * 2.5;
-    const shouldForwardProp = (prop) => !["isSorted", "onClickRow"].includes(prop);
-    const Row$1 = styled__default.default.div.withConfig({
-        shouldForwardProp
-    })`
-    cursor: ${(props) => props.onClickRow ? "pointer" : "default"};
-    display: flex;
 
-    :hover {
-        div {
-            background-color: ${(props) => props.theme.colors.grey1};
-        }
+    function getTime(dirtyDate) {
+        requiredArgs(1, arguments);
+        var date = toDate(dirtyDate);
+        var timestamp = date.getTime();
+        return timestamp;
     }
 
-    :active,
-    :focus {
-        div {
-            background-color: ${(props) => props.theme.colors.grey2};
-        }
+    function setSeconds(dirtyDate, dirtySeconds) {
+        requiredArgs(2, arguments);
+        var date = toDate(dirtyDate);
+        var seconds = toInteger$2(dirtySeconds);
+        date.setSeconds(seconds);
+        return date;
     }
-`;
-    const RowPlaceholder = styled__default.default(Row$1)`
-    position: absolute;
-    left: 0;
-
-    display: flex;
-    align-items: center;
-    justify-content: center;
-`;
-    const CellPlaceholder = styled__default.default.div`
-    min-width: 80px;
-    height: 0.7rem;
-    margin: 0.5rem;
-
-    background: ${(props) => `linear-gradient(to right, ${props.theme.colors.grey2}, ${curriedTransparentize$2(0.2, props.theme.colors.grey3)}, ${props.theme.colors.grey2});`};
-    background-size: 50%;
-    border-radius: 0.5rem;
-
-    animation-name: ani-horizontal;
-    animation-duration: 3.5s;
-    animation-timing-function: linear;
-    animation-iteration-count: infinite;
 
-    @keyframes ani-horizontal {
-        0% {
-            background-position: -100% 0;
-        }
-
-        100% {
-            background-position: 100% 0;
-        }
+    function setMinutes(dirtyDate, dirtyMinutes) {
+        requiredArgs(2, arguments);
+        var date = toDate(dirtyDate);
+        var minutes = toInteger$2(dirtyMinutes);
+        date.setMinutes(minutes);
+        return date;
     }
-`;
-    const Cell = styled__default.default.div`
-    display: flex !important;
-    align-items: center;
-
-    min-width: 80px;
-    height: ${() => `${ROW_HEIGHT}px`};
-
-    color: ${(props) => props.theme.colors.grey6};
-
-    background-color: ${(props) => props.theme.colors.blue1};
-    border-bottom: 1px solid ${(props) => props.theme.colors.grey3};
 
-    :last-child {
-        border-right: 0;
+    function setHours(dirtyDate, dirtyHours) {
+        requiredArgs(2, arguments);
+        var date = toDate(dirtyDate);
+        var hours = toInteger$2(dirtyHours);
+        date.setHours(hours);
+        return date;
     }
-`;
-    const CellContent = styled__default.default.span`
-    overflow: hidden;
-
-    width: 100%;
-    padding: 0 1rem;
-
-    text-overflow: ellipsis;
-    white-space: nowrap;
-`;
-    const arePropsEqual = (prevProps, nextProps) => {
-        var _a3;
-        return areEqual(prevProps, nextProps) && !(((_a3 = nextProps.data) === null || _a3 === void 0 ? void 0 : _a3.headerGroups) || []).some((headerGroup) => ((headerGroup === null || headerGroup === void 0 ? void 0 : headerGroup.headers) || []).some((header) => header.isResizing));
-    };
-    const RenderRow = React__namespace.memo(({
-        data: {
-            width,
-            currentEditCell,
-            headerGroups,
-            rows,
-            prepareRow,
-            getItem,
-            totalColumnsWidth,
-            onClickRow,
-            throttledClickRow,
-            backgroundColor,
-            mappedColumns
-        },
-        index: index2,
-        style: renderRowStyle
-    }) => {
-        let row = rows[index2];
-        if (getItem) {
-            const value = getItem(index2);
-            if (!value) {
-                row = null;
-            } else {
-                row.original = value;
-                row.values = value;
-            }
-        }
-        if (!row) {
-            return jsxRuntime.exports.jsx("div", {
-                children: headerGroups.map((headerGroup, gidx) => jsxRuntime.exports.jsx(RowPlaceholder, {
-                    style: {
-                        height: ROW_HEIGHT,
-                        top: (index2 + 1) * ROW_HEIGHT,
-                        width: totalColumnsWidth > width ? totalColumnsWidth : "100%"
-                    },
-                    children: headerGroup === null || headerGroup === void 0 ? void 0 : headerGroup.headers.map((col, cidx) => {
-                        const headerProps = col.getHeaderProps();
-                        const headerWidth = headerProps.style.width === "NaNpx" ? mappedColumns[cidx].width : headerProps.style.width;
-                        return jsxRuntime.exports.jsx(CellPlaceholder, {
-                            style: {
-                                maxWidth: col.maxWidth,
-                                width: headerWidth
-                            }
-                        }, `col-${index2}-${cidx}`);
-                    })
-                }, `row-${gidx}`))
-            });
-        }
-        prepareRow(row);
-        const onClick = () => {
-            if (onClickRow) {
-                throttledClickRow(row.original);
-            }
-        };
-        const _a3 = row.getRowProps({
-                style: renderRowStyle
-            }),
-            {
-                style: rowStyle
-            } = _a3,
-            restRow = __rest$7(_a3, ["style"]);
-        return React.createElement(Row$1, Object.assign({}, restRow, {
-            key: `row-${index2}`,
-            onClick,
-            onClickRow,
-            style: Object.assign(Object.assign({}, rowStyle), {
-                top: (index2 + 1) * ROW_HEIGHT,
-                width: totalColumnsWidth > width ? totalColumnsWidth : "100%"
-            })
-        }), row.cells.map((cell, colIdx) => {
-            var _a4;
-            const cellProps = cell.getCellProps();
-            return React.createElement(
-                Cell,
-                Object.assign({}, cellProps, {
-                    key: `cell-${index2}-${colIdx}`,
-                    style: Object.assign(Object.assign({}, cellProps.style), {
-                        backgroundColor,
-                        justifyContent: mappedColumns[colIdx].align,
-                        maxWidth: (_a4 = cell.column) === null || _a4 === void 0 ? void 0 : _a4.maxWidth,
-                        width: cellProps.style.width === "NaNpx" ? mappedColumns[colIdx].width : cellProps.style.width
-                    })
-                }),
-                jsxRuntime.exports.jsx(CellContent, {
-                    children: cell.render("Cell", {
-                        colIdx,
-                        currentEditCell,
-                        rowIdx: index2
-                    })
-                })
-            );
-        }));
-    }, arePropsEqual);
-    var __rest$6 = globalThis && globalThis.__rest || function(s2, e3) {
-        var t2 = {};
-        for (var p2 in s2)
-            if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
-                t2[p2] = s2[p2];
-        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
-            for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
-                if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
-                    t2[p2[i2]] = s2[p2[i2]];
-            }
-        return t2;
-    };
-    const Wrapper$4 = styled__default.default.div`
-    display: inline-block;
-    width: 100%;
-    max-width: 100%;
-    padding: 1rem;
-
-    ${(props) => !props.$hasMaxRows && `flex: 1 1 auto;`}
-    &.sticky {
-        [data-sticky-td] {
-            position: sticky;
-        }
-
-        [data-sticky-last-left-td] {
-            box-shadow: 4px 0 4px -3px ${(props) => props.theme.colors.shadowMedium};
-        }
 
-        [data-sticky-first-right-td] {
-            box-shadow: -4px 0 4px -3px ${(props) => props.theme.colors.shadowMedium};
-        }
+    function getDaysInMonth(dirtyDate) {
+        requiredArgs(1, arguments);
+        var date = toDate(dirtyDate);
+        var year = date.getFullYear();
+        var monthIndex = date.getMonth();
+        var lastDayOfMonth = new Date(0);
+        lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
+        lastDayOfMonth.setHours(0, 0, 0, 0);
+        return lastDayOfMonth.getDate();
     }
-`;
-    const StyledFixedSizeList = styled__default.default(FixedSizeList)`
-    /* this adds a fixed box shadow underneath the header */
-    ::before {
-        content: '';
-
-        position: sticky;
-        z-index: 5;
-        inset: calc(2.5rem - 2px) 0 0 0;
-
-        display: block;
-
-        height: 1px;
 
-        box-shadow: 0 3px 3px ${(props) => props.theme.colors.shadowLight};
+    function setMonth(dirtyDate, dirtyMonth) {
+        requiredArgs(2, arguments);
+        var date = toDate(dirtyDate);
+        var month = toInteger$2(dirtyMonth);
+        var year = date.getFullYear();
+        var day = date.getDate();
+        var dateWithDesiredMonth = new Date(0);
+        dateWithDesiredMonth.setFullYear(year, month, 15);
+        dateWithDesiredMonth.setHours(0, 0, 0, 0);
+        var daysInMonth = getDaysInMonth(dateWithDesiredMonth);
+        date.setMonth(month, Math.min(day, daysInMonth));
+        return date;
     }
-`;
-    const Header = styled__default.default.div`
-    position: sticky;
-    z-index: 4;
-    top: 0;
-
-    flex-direction: column;
-
-    width: fit-content;
-    min-width: 80px;
-
-    /* needed as before box shadow pushes this dows by 1px */
-    margin-top: -1px;
-`;
-    const HeaderRow = styled__default.default.div`
-    display: flex;
-`;
-    const HeaderCell = styled__default.default.div`
-    user-select: none;
-
-    display: flex !important;
-    align-items: center;
-    justify-content: space-between;
-
-    min-width: 80px;
-    height: ${ROW_HEIGHT}px;
 
-    color: ${(props) => props.theme.colors.text};
-
-    background-color: ${(props) => props.theme.colors.blue3};
-
-    :not(:last-child) {
-        border-right: 1px solid ${(props) => props.theme.colors.background};
+    function setQuarter(dirtyDate, dirtyQuarter) {
+        requiredArgs(2, arguments);
+        var date = toDate(dirtyDate);
+        var quarter = toInteger$2(dirtyQuarter);
+        var oldQuarter = Math.floor(date.getMonth() / 3) + 1;
+        var diff = quarter - oldQuarter;
+        return setMonth(date, date.getMonth() + diff * 3);
     }
 
-    :hover {
-        /* stylelint-disable-next-line -- hard-coded classname */
-        .tableSortArrow {
-            color: ${(props) => props.theme.colors.grey3};
+    function setYear(dirtyDate, dirtyYear) {
+        requiredArgs(2, arguments);
+        var date = toDate(dirtyDate);
+        var year = toInteger$2(dirtyYear);
+        if (isNaN(date.getTime())) {
+            return new Date(NaN);
         }
+        date.setFullYear(year);
+        return date;
     }
-`;
-    const HeaderContentWrapper = styled__default.default.span`
-    overflow: hidden;
-    flex: 1 1 auto;
-
-    padding-left: ${(props) => props.isPrimitiveHeader ? "1rem" : void 0};
-
-    text-overflow: ellipsis;
-    white-space: nowrap;
-`;
-    const HeaderTooltipContainer = styled__default.default.div`
-    display: flex;
-    gap: 0.5rem;
-    align-items: center;
-    justify-content: center;
 
-    width: ${(props) => props.isPrimitiveHeader ? void 0 : "100%"};
-    max-width: ${(props) => props.isPrimitiveHeader ? "calc(100% - 3rem)" : void 0};
-`;
-    const HeaderCellButtonContainer = styled__default.default.div`
-    display: flex;
-    flex-direction: row;
-    height: 100%;
-`;
-    const HeaderIconsWrapper = styled__default.default.div`
-    display: flex;
-    align-items: center;
-    justify-content: space-between;
-    justify-self: flex-end;
-`;
-    const ResizeBorder = styled__default.default.div`
-    /* prevents from scrolling while dragging on touch devices */
-    touch-action: none;
-    width: 10px;
-    height: 100%;
-`;
-    const SortIcon = styled__default.default(FontAwesomeIcon).withConfig({
-        shouldForwardProp
-    })`
-    color: ${(props) => props.isSorted ? props.theme.colors.grey3 : props.theme.colors.blue3};
-`;
-    const TooltipIcon = styled__default.default(FontAwesomeIcon)`
-    color: ${(props) => props.theme.colors.grey4};
-`;
-    const getSortIcon = (isSorted, isSortedDesc) => {
-        if (!isSorted) {
-            return faArrowUp;
+    function min$1(dirtyDatesArray) {
+        requiredArgs(1, arguments);
+        var datesArray;
+        if (dirtyDatesArray && typeof dirtyDatesArray.forEach === "function") {
+            datesArray = dirtyDatesArray;
+        } else if (_typeof$5(dirtyDatesArray) === "object" && dirtyDatesArray !== null) {
+            datesArray = Array.prototype.slice.call(dirtyDatesArray);
+        } else {
+            return new Date(NaN);
         }
-        return isSortedDesc ? faArrowDown : faArrowUp;
-    };
-    const getSortKey = (sortBy, columns) => {
-        return sortBy.map((sort) => {
-            var _a3;
-            return Object.assign(Object.assign({}, sort), {
-                id: ((_a3 = columns.find((col) => col.accessor === sort.id)) === null || _a3 === void 0 ? void 0 : _a3.sortKey) || sort.id
-            });
-        });
-    };
-    const orderStickyCols = (columns) => {
-        const leftStickyCols = [];
-        const nonStickyCols = [];
-        const rightStickyCols = [];
-        columns.forEach((col) => {
-            if (col.sticky === "left") {
-                leftStickyCols.push(col);
-            } else if (col.sticky === "right") {
-                rightStickyCols.push(col);
-            } else {
-                nonStickyCols.push(col);
-            }
-        });
-        return [...leftStickyCols, ...nonStickyCols, ...rightStickyCols];
-    };
-    const filterComponentMap = {
-        categorical: CategoricalFilter,
-        datetime: DatetimeFilter,
-        numeric: NumericFilter,
-        text: TextFilter
-    };
-    const appendFilterComponents = (columns) => {
-        return columns.map((col) => {
-            if (!col.filter) {
-                return col;
-            }
-            if (!(col.filter in filterComponentMap)) {
-                throw new Error(`Invalid filter ${col.filter} encountered in column ${col.id}, only ${Object.keys(filterComponentMap).join(",")} are supported`);
+        var result;
+        datesArray.forEach(function(dirtyDate) {
+            var currentDate = toDate(dirtyDate);
+            if (result === void 0 || result > currentDate || isNaN(currentDate.getDate())) {
+                result = currentDate;
             }
-            return Object.assign(Object.assign({}, col), {
-                Filter: filterComponentMap[col.filter]
-            });
         });
-    };
-    const cells = {
-        DATETIME: DatetimeCell,
-        EDIT_INPUT: EditInputCell,
-        EDIT_SELECT: EditSelectCell
-    };
-    const createItemData = memoizeOne$1((width, currentEditCell, headerGroups, rows, prepareRow, getItem, totalColumnsWidth, onClickRow, throttledClickRow, backgroundColor, mappedColumns) => ({
-        backgroundColor,
-        currentEditCell,
-        getItem,
-        headerGroups,
-        mappedColumns,
-        onClickRow,
-        prepareRow,
-        rows,
-        throttledClickRow,
-        totalColumnsWidth,
-        width
-    }));
-    const Table$1 = React.forwardRef(({
-        allowHiding,
-        backgroundColor,
-        className,
-        columns,
-        data: data2,
-        getItem,
-        initialSort = [],
-        itemCount,
-        maxRows,
-        onAction,
-        onChange: onChange2,
-        onClickRow,
-        onItemsRendered,
-        onFilter,
-        onSort,
-        showTableOptions,
-        style: style2,
-        tableOptionsStyle
-    }, ref2) => {
-        const [currentSortBy, setCurrentSortBy] = React.useState(initialSort);
-        React.useEffect(
-            () => {
-                setCurrentSortBy(initialSort);
-            },
-            useDeepCompare([initialSort])
-        );
-        if (!data2 && !getItem) {
-            throw new Error("One of data and getItem must be passed to the table component");
-        }
-        if (getItem && (!onItemsRendered || !Number.isFinite(itemCount))) {
-            throw new Error("itemCount and onItemsRendered must also be passed when using the table in infinite mode");
+        return result || new Date(NaN);
+    }
+
+    function max$2(dirtyDatesArray) {
+        requiredArgs(1, arguments);
+        var datesArray;
+        if (dirtyDatesArray && typeof dirtyDatesArray.forEach === "function") {
+            datesArray = dirtyDatesArray;
+        } else if (_typeof$5(dirtyDatesArray) === "object" && dirtyDatesArray !== null) {
+            datesArray = Array.prototype.slice.call(dirtyDatesArray);
+        } else {
+            return new Date(NaN);
         }
-        const [currentEditCell, throttledSetEditCell, immediateSetEditCell] = useThrottledState(void 0, 500);
-        const throttledClickRow = useThrottle(onClickRow, 500);
-        const onStopEdit = () => {
-            throttledSetEditCell(void 0);
-        };
-        const onStartEdit = (e3) => {
-            var _a3, _b;
-            const cell = (_b = (_a3 = e3 === null || e3 === void 0 ? void 0 : e3.currentTarget) === null || _a3 === void 0 ? void 0 : _a3.getAttribute("data-cell")) === null || _b === void 0 ? void 0 : _b.split(",");
-            if (!cell || (cell === null || cell === void 0 ? void 0 : cell.length) !== 2) {
-                throttledSetEditCell(void 0);
-                return;
-            }
-            immediateSetEditCell([Number(cell[0]), cell[1]]);
-            throttledSetEditCell([Number(cell[0]), cell[1]]);
-        };
-        const infiniteData = React.useMemo(() => Array(itemCount).fill(0), [itemCount]);
-        const mappedColumns = React.useMemo(() => appendFilterComponents(orderStickyCols(columns)), [columns]);
-        const hasFixedColumns = React.useMemo(() => mappedColumns.some((column) => "sticky" in column), [mappedColumns]);
-        const totalColumnsWidth = React.useMemo(() => mappedColumns.reduce((acc, column) => acc + (parseInt(column.width) || 150), 0), [mappedColumns]);
-        const filterTypes = React.useMemo(() => ({
-            categorical,
-            datetime,
-            numeric
-        }), []);
-        const {
-            getTableProps,
-            getTableBodyProps,
-            headerGroups,
-            rows,
-            prepareRow,
-            state: {
-                sortBy,
-                filters: filters2
-            },
-            setAllFilters,
-            resetResizing,
-            allColumns
-        } = reactTable.exports.useTable({
-            columns: mappedColumns,
-            data: data2 || infiniteData,
-            filterTypes,
-            initialState: {
-                sortBy: currentSortBy.map((sort) => Object.assign(Object.assign({}, sort), {
-                    id: mappedColumns.find((col) => [col.sortKey, col.accessor].includes(sort.id)).accessor
-                }))
-            },
-            manualFilters: !data2,
-            manualSortBy: !!onSort,
-            onAction,
-            onChange: onChange2,
-            onStartEdit,
-            onStopEdit
-        }, reactTable.exports.useFilters, reactTable.exports.useFlexLayout, reactTable.exports.useSortBy, reactTable.exports.useResizeColumns, ...hasFixedColumns ? [build.useSticky] : []);
-        React.useImperativeHandle(ref2, () => ({
-            resetFilters() {
-                setAllFilters([]);
-            }
-        }));
-        React.useEffect(() => {
-            if (onSort) {
-                onSort(getSortKey(sortBy, mappedColumns));
-            } else {
-                setCurrentSortBy(sortBy);
-            }
-        }, [onSort, sortBy]);
-        React.useEffect(() => {
-            if (onFilter) {
-                onFilter(filters2);
+        var result;
+        datesArray.forEach(function(dirtyDate) {
+            var currentDate = toDate(dirtyDate);
+            if (result === void 0 || result < currentDate || isNaN(Number(currentDate))) {
+                result = currentDate;
             }
-        }, [onFilter, filters2]);
-        const tableProps = getTableBodyProps();
-        const renderTable = React.useCallback(
-            (_a3) => {
-                var {
-                    children: children2,
-                    style: tableStyle
-                } = _a3, rest = __rest$6(_a3, ["children", "style"]);
-                return jsxRuntime.exports.jsxs("div", {
-                    children: [jsxRuntime.exports.jsx(Header, {
-                        style: {
-                            width: `max(${totalColumnsWidth}px, 100%)`
-                        },
-                        children: headerGroups.map((headerGroup, gidx) => React.createElement(HeaderRow, Object.assign({}, headerGroup.getHeaderGroupProps(), {
-                            key: `group-${gidx}`
-                        }), headerGroup.headers.map((col, cidx) => {
-                            const headerProps = col.getHeaderProps();
-                            const sortProps = col.getSortByToggleProps();
-                            const headerContent = col.render("Header");
-                            const resizerProps = col.getResizerProps();
-                            const numVisibleColumns = allColumns.filter((column) => column.isVisible).length;
-                            const showSort = !col.disableSortBy;
-                            const showFilter = col.canFilter && col.filter;
-                            const showOptions = cidx === numVisibleColumns - 1 && showTableOptions;
-                            const showHeaderCellButtonContainer = showSort || showFilter || showOptions;
-                            return React.createElement(
-                                HeaderCell,
-                                Object.assign({}, headerProps, {
-                                    key: `col-${gidx}-${cidx}`,
-                                    style: Object.assign(Object.assign({}, headerProps.style), {
-                                        maxWidth: col.maxWidth,
-                                        width: headerProps.style.width === "NaNpx" ? mappedColumns[cidx].width : headerProps.style.width
-                                    })
-                                }),
-                                jsxRuntime.exports.jsxs(HeaderTooltipContainer, {
-                                    isPrimitiveHeader: typeof headerContent === "string",
-                                    children: [jsxRuntime.exports.jsx(HeaderContentWrapper, Object.assign({}, sortProps, {
-                                        isPrimitiveHeader: typeof headerContent === "string",
-                                        title: typeof headerContent === "string" ? headerContent : "",
-                                        children: headerContent
-                                    })), col.tooltip && jsxRuntime.exports.jsx(Tooltip$1, {
-                                        content: col.tooltip,
-                                        children: jsxRuntime.exports.jsx(TooltipIcon, {
-                                            icon: faCircleQuestion
-                                        })
-                                    })]
-                                }),
-                                showHeaderCellButtonContainer && jsxRuntime.exports.jsxs(HeaderCellButtonContainer, {
-                                    children: [jsxRuntime.exports.jsxs(HeaderIconsWrapper, {
-                                        children: [showSort && jsxRuntime.exports.jsx(HeaderIconWrapper, {
-                                            children: jsxRuntime.exports.jsx(SortIcon, Object.assign({}, sortProps, {
-                                                className: "tableSortArrow",
-                                                icon: getSortIcon(col.isSorted, col.isSortedDesc),
-                                                isSorted: col.isSorted
-                                            }))
-                                        }), showFilter ? jsxRuntime.exports.jsx(FilterContainer, {
-                                            col
-                                        }) : null, showOptions && jsxRuntime.exports.jsx(OptionsMenu, {
-                                            allColumns,
-                                            allowColumnHiding: allowHiding,
-                                            numVisibleColumns,
-                                            resetResizing,
-                                            setAllFilters,
-                                            style: tableOptionsStyle
-                                        })]
-                                    }), jsxRuntime.exports.jsx(ResizeBorder, Object.assign({}, resizerProps))]
-                                })
-                            );
-                        })))
-                    }), React.createElement("div", Object.assign({}, tableProps, rest, {
-                        key: "table-body-inner",
-                        style: tableStyle
-                    }), children2)]
-                }, "table-inner");
-            },
-            useDeepCompare([tableProps, totalColumnsWidth, headerGroups])
-        );
-        return jsxRuntime.exports.jsx(Wrapper$4, Object.assign({}, getTableProps(), {
-            "$hasMaxRows": !!maxRows,
-            className: `${className} ${hasFixedColumns ? "sticky" : ""}`,
-            style: Object.assign({
-                height: maxRows ? (Math.min(rows.length, maxRows) + 1) * ROW_HEIGHT : "100%"
-            }, style2),
-            children: jsxRuntime.exports.jsx(AutoSizer, {
-                children: ({
-                    height,
-                    width
-                }) => {
-                    return jsxRuntime.exports.jsx(StyledFixedSizeList, {
-                        height,
-                        innerElementType: renderTable,
-                        itemCount: itemCount || rows.length,
-                        itemData: createItemData(width, currentEditCell, headerGroups, rows, prepareRow, getItem, totalColumnsWidth, onClickRow, throttledClickRow, backgroundColor, mappedColumns),
-                        itemSize: ROW_HEIGHT,
-                        onItemsRendered,
-                        style: {
-                            overflowX: width < totalColumnsWidth ? "auto" : "hidden",
-                            overflowY: height < (rows.length + 1) * ROW_HEIGHT ? "auto" : "hidden"
-                        },
-                        width,
-                        children: RenderRow
-                    }, "table-list");
-                }
-            })
-        }));
-    });
-    Table$1.displayName = "Table";
-    Table$1.ActionColumn = (actions, accessor, sticky, disableSelectAll = false) => {
-        const width = actions.includes(Actions.SELECT) ? 52 : actions.length * 24 + 24;
-        return {
-            Cell: ActionCell,
-            Header: actions.includes(Actions.SELECT) && !disableSelectAll ? SelectHeader : "",
-            accessor: accessor || "actions",
-            actions,
-            disableSortBy: true,
-            maxWidth: width,
-            minWidth: actions.includes(Actions.SELECT) ? 52 : 48,
-            sticky: sticky || null,
-            width
-        };
-    };
-    Table$1.Actions = Actions;
-    Table$1.cells = cells;
-    const TabWrapper = styled__default.default.div`
-    overflow: hidden;
-    display: flex;
-
-    /* This is needed as the content of a TabbedCard overflows for the wrapper to not shrink */
-    flex-shrink: 0;
-
-    width: 100%;
-
-    border-radius: 1rem 1rem 0 0;
-`;
-    const TabComponent = styled__default.default.span`
-    cursor: pointer;
-    user-select: none;
+        });
+        return result || new Date(NaN);
+    }
 
-    overflow: hidden;
-    display: flex;
-    flex: 1 1 0;
-    align-items: center;
-    justify-content: center;
+    function startOfDay(dirtyDate) {
+        requiredArgs(1, arguments);
+        var date = toDate(dirtyDate);
+        date.setHours(0, 0, 0, 0);
+        return date;
+    }
+    var MILLISECONDS_IN_DAY = 864e5;
 
-    box-sizing: border-box;
-    height: 2.5rem;
+    function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
+        requiredArgs(2, arguments);
+        var startOfDayLeft = startOfDay(dirtyDateLeft);
+        var startOfDayRight = startOfDay(dirtyDateRight);
+        var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
+        var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight);
+        return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY);
+    }
 
-    color: ${(props) => props.selected ? props.theme.colors.primary : props.theme.colors.grey3};
+    function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
+        requiredArgs(2, arguments);
+        var dateLeft = toDate(dirtyDateLeft);
+        var dateRight = toDate(dirtyDateRight);
+        var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
+        var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
+        return yearDiff * 12 + monthDiff;
+    }
 
-    background-color: ${(props) => props.theme.colors.blue1};
-    border-bottom: ${(props) => props.selected ? `2px solid ${props.theme.colors.primary}` : `1px solid ${props.theme.colors.grey3}`};
+    function differenceInCalendarYears(dirtyDateLeft, dirtyDateRight) {
+        requiredArgs(2, arguments);
+        var dateLeft = toDate(dirtyDateLeft);
+        var dateRight = toDate(dirtyDateRight);
+        return dateLeft.getFullYear() - dateRight.getFullYear();
+    }
 
-    :hover {
-        color: ${(props) => props.selected ? props.theme.colors.primary : props.theme.colors.text};
-        background-color: ${(props) => props.selected ? props.theme.colors.blue1 : props.theme.colors.grey1};
+    function startOfMonth(dirtyDate) {
+        requiredArgs(1, arguments);
+        var date = toDate(dirtyDate);
+        date.setDate(1);
+        date.setHours(0, 0, 0, 0);
+        return date;
     }
 
-    h2 {
-        font-weight: ${(props) => props.selected ? "700" : "400"};
+    function startOfQuarter(dirtyDate) {
+        requiredArgs(1, arguments);
+        var date = toDate(dirtyDate);
+        var currentMonth = date.getMonth();
+        var month = currentMonth - currentMonth % 3;
+        date.setMonth(month, 1);
+        date.setHours(0, 0, 0, 0);
+        return date;
     }
-`;
-    const Title$2 = styled__default.default.h2`
-    overflow: hidden;
 
-    width: 100%;
-    margin: 0;
-    padding: 0 1rem;
+    function startOfYear(dirtyDate) {
+        requiredArgs(1, arguments);
+        var cleanDate = toDate(dirtyDate);
+        var date = new Date(0);
+        date.setFullYear(cleanDate.getFullYear(), 0, 1);
+        date.setHours(0, 0, 0, 0);
+        return date;
+    }
 
-    font-size: 1rem;
-    font-weight: 300;
-    text-align: center;
-    text-overflow: ellipsis;
-    white-space: nowrap;
-`;
+    function endOfDay(dirtyDate) {
+        requiredArgs(1, arguments);
+        var date = toDate(dirtyDate);
+        date.setHours(23, 59, 59, 999);
+        return date;
+    }
 
-    function instanceOfTab(tab2) {
-        return typeof tab2 === "string" ? false : "title" in tab2;
+    function isEqual$2(dirtyLeftDate, dirtyRightDate) {
+        requiredArgs(2, arguments);
+        var dateLeft = toDate(dirtyLeftDate);
+        var dateRight = toDate(dirtyRightDate);
+        return dateLeft.getTime() === dateRight.getTime();
     }
 
-    function Tabs({
-        className,
-        onSelectTab,
-        selectedTab,
-        tabs
-    }) {
-        const objectTabs = tabs.map((tab2) => instanceOfTab(tab2) ? tab2 : {
-            title: tab2
-        });
-        const tabSelected = instanceOfTab(selectedTab) ? selectedTab : {
-            title: selectedTab
-        };
-        const onClick = (tab2) => () => {
-            if (onSelectTab) {
-                onSelectTab(tab2);
-            }
-        };
-        return jsxRuntime.exports.jsx(TabWrapper, {
-            className,
-            children: objectTabs.map((tab2, idx) => jsxRuntime.exports.jsx(TabComponent, {
-                onClick: onClick(instanceOfTab(selectedTab) ? tab2 : tab2.title),
-                selected: isEqual_1(tab2, tabSelected || objectTabs[0]),
-                children: jsxRuntime.exports.jsx(Title$2, {
-                    children: tab2.title
-                })
-            }, `tab-${objectTabs[idx].title}`))
-        });
+    function isSameDay(dirtyDateLeft, dirtyDateRight) {
+        requiredArgs(2, arguments);
+        var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
+        var dateRightStartOfDay = startOfDay(dirtyDateRight);
+        return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
     }
-    const StyledHeader = styled__default.default.div`
-    display: flex;
-    align-items: center;
-    justify-content: space-between;
 
-    width: 100%;
-    padding-right: 0.5rem;
-`;
-    const StyledAccordion = core$2.injectCss(Accordion$1);
+    function isSameMonth(dirtyDateLeft, dirtyDateRight) {
+        requiredArgs(2, arguments);
+        var dateLeft = toDate(dirtyDateLeft);
+        var dateRight = toDate(dirtyDateRight);
+        return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
+    }
 
-    function headerRenderer(item) {
-        const theme2 = useClTheme();
-        return /* @__PURE__ */ React__default.default.createElement(StyledHeader, null, typeof item.label === "string" ? /* @__PURE__ */ React__default.default.createElement("span", null, item.label) : /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
-            component: item.label
-        }), item.badge && /* @__PURE__ */ React__default.default.createElement(Badge, {
-            color: item.badge.color || theme2.colors.primary,
-            height: 24,
-            width: "10rem"
-        }, item.badge.label));
+    function isSameYear(dirtyDateLeft, dirtyDateRight) {
+        requiredArgs(2, arguments);
+        var dateLeft = toDate(dirtyDateLeft);
+        var dateRight = toDate(dirtyDateRight);
+        return dateLeft.getFullYear() === dateRight.getFullYear();
     }
-    const innerRender = (item) => {
-        return /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
-            component: item.content
-        });
-    };
 
-    function Accordion(props) {
-        const [style2, css2] = core$2.useComponentStyles(props);
-        const [value, setValue] = core$2.useVariable(props.value);
-        const [onCarouselAction] = core$2.useAction(props.onchange);
+    function isSameQuarter(dirtyDateLeft, dirtyDateRight) {
+        requiredArgs(2, arguments);
+        var dateLeftStartOfQuarter = startOfQuarter(dirtyDateLeft);
+        var dateRightStartOfQuarter = startOfQuarter(dirtyDateRight);
+        return dateLeftStartOfQuarter.getTime() === dateRightStartOfQuarter.getTime();
+    }
 
-        function handleChange(val) {
-            setValue(val);
-            onCarouselAction(val);
-        }
-        return /* @__PURE__ */ React__default.default.createElement(
-            StyledAccordion, {
-                $rawCss: css2,
-                className: props.className,
-                headerRenderer,
-                initialOpenItems: props.initial,
-                innerRenderer: innerRender,
-                items: props.items,
-                multi: props.multi,
-                onChange: handleChange,
-                style: style2,
-                value
-            }
-        );
+    function isAfter(dirtyDate, dirtyDateToCompare) {
+        requiredArgs(2, arguments);
+        var date = toDate(dirtyDate);
+        var dateToCompare = toDate(dirtyDateToCompare);
+        return date.getTime() > dateToCompare.getTime();
     }
-    var ComponentType = /* @__PURE__ */ ((ComponentType2) => {
-        ComponentType2["ANCHOR"] = "anchor";
-        ComponentType2["BUTTON"] = "button";
-        ComponentType2["CAROUSEL"] = "carousel";
-        ComponentType2["CODE"] = "code";
-        ComponentType2["COMPONENT_SELECT_LIST"] = "component_select_list";
-        ComponentType2["FORM_PAGE"] = "form_page";
-        ComponentType2["HEADING"] = "heading";
-        ComponentType2["HTML_RAW"] = "html_raw";
-        ComponentType2["ICON"] = "icon";
-        ComponentType2["PARAGRAPH"] = "paragraph";
-        ComponentType2["PROGRESS_BAR"] = "progress_bar";
-        ComponentType2["SPACER"] = "spacer";
-        ComponentType2["STACK"] = "stack";
-        ComponentType2["TABLE"] = "table";
-        ComponentType2["TEXT"] = "text";
-        ComponentType2["TOOLTIP"] = "tooltip";
-        return ComponentType2;
-    })(ComponentType || {});
-    const StyledA = core$2.injectCss(styled__default.default.a`
-    :visited {
-        color: ${(props) => props.theme.colors.secondary};
+
+    function isBefore(dirtyDate, dirtyDateToCompare) {
+        requiredArgs(2, arguments);
+        var date = toDate(dirtyDate);
+        var dateToCompare = toDate(dirtyDateToCompare);
+        return date.getTime() < dateToCompare.getTime();
     }
 
-    :link {
-        color: ${(props) => props.theme.colors.primary};
+    function isWithinInterval(dirtyDate, interval2) {
+        requiredArgs(2, arguments);
+        var time = toDate(dirtyDate).getTime();
+        var startTime = toDate(interval2.start).getTime();
+        var endTime = toDate(interval2.end).getTime();
+        if (!(startTime <= endTime)) {
+            throw new RangeError("Invalid interval");
+        }
+        return time >= startTime && time <= endTime;
     }
 
-    :hover {
-        color: ${(props) => props.theme.colors.primaryHover};
+    function _arrayLikeToArray$9(arr, len) {
+        if (len == null || len > arr.length)
+            len = arr.length;
+        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
+            arr2[i2] = arr[i2];
+        return arr2;
     }
 
-    :active {
-        color: ${(props) => props.theme.colors.primaryDown};
+    function _unsupportedIterableToArray$9(o2, minLen) {
+        if (!o2)
+            return;
+        if (typeof o2 === "string")
+            return _arrayLikeToArray$9(o2, minLen);
+        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
+        if (n2 === "Object" && o2.constructor)
+            n2 = o2.constructor.name;
+        if (n2 === "Map" || n2 === "Set")
+            return Array.from(o2);
+        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
+            return _arrayLikeToArray$9(o2, minLen);
     }
-`);
 
-    function Anchor(props) {
-        const [style2, css2] = core$2.useComponentStyles(props);
-        const isRelative = React.useMemo(() => {
-            var _a3;
-            return (_a3 = props.href) == null ? void 0 : _a3.startsWith("/");
-        }, [props.href]);
-        const extraProps = React.useMemo(() => {
-            if (!isRelative) {
-                return {};
+    function _createForOfIteratorHelper(o2, allowArrayLike) {
+        var it2 = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
+        if (!it2) {
+            if (Array.isArray(o2) || (it2 = _unsupportedIterableToArray$9(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
+                if (it2)
+                    o2 = it2;
+                var i2 = 0;
+                var F2 = function F3() {};
+                return {
+                    s: F2,
+                    n: function n2() {
+                        if (i2 >= o2.length)
+                            return {
+                                done: true
+                            };
+                        return {
+                            done: false,
+                            value: o2[i2++]
+                        };
+                    },
+                    e: function e3(_e2) {
+                        throw _e2;
+                    },
+                    f: F2
+                };
             }
-            return {
-                href: void 0,
-                to: props.href
-            };
-        }, [isRelative, props.href]);
-        const AsComponent = React.useMemo(() => isRelative ? core$2.ReactRouter.Link : "a", [isRelative]);
-        return /* @__PURE__ */ React__default.default.createElement(
-            StyledA, {
-                $rawCss: css2,
-                as: AsComponent,
-                className: props.clean ? "report-clean-anchor" : props.className,
-                href: props.href,
-                id: props.name,
-                rel: "noreferrer",
-                style: style2,
-                target: props.new_tab ? "_blank" : "_self",
-                ...extraProps
+            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
+        }
+        var normalCompletion = true,
+            didErr = false,
+            err;
+        return {
+            s: function s2() {
+                it2 = it2.call(o2);
             },
-            /* @__PURE__ */
-            React__default.default.createElement(core$2.DisplayCtx.Provider, {
-                value: {
-                    component: ComponentType.ANCHOR,
-                    direction: "horizontal"
+            n: function n2() {
+                var step2 = it2.next();
+                normalCompletion = step2.done;
+                return step2;
+            },
+            e: function e3(_e2) {
+                didErr = true;
+                err = _e2;
+            },
+            f: function f2() {
+                try {
+                    if (!normalCompletion && it2["return"] != null)
+                        it2["return"]();
+                } finally {
+                    if (didErr)
+                        throw err;
                 }
-            }, props.children.map((child, idx) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
-                component: child,
-                key: `stack-${idx}-${child.name}`
-            })))
-        );
-    }
-    const StyledTag$2 = core$2.injectCss("div");
-
-    function BulletList(props) {
-        const items = core$2.useVariable(props.items)[0];
-        const [style2, css2] = core$2.useComponentStyles(props);
-        const tag = props.numbered ? "ol" : "ul";
-        return /* @__PURE__ */ React__default.default.createElement(StyledTag$2, {
-            $rawCss: css2,
-            as: tag,
-            style: style2
-        }, items.map((item, index2) => /* @__PURE__ */ React__default.default.createElement("li", {
-            key: `li-${index2}`,
-            style: {
-                textAlign: "left"
             }
-        }, item)));
+        };
     }
 
-    function isConditionTrue(operator2, value, other) {
-        if (operator2 === core$2.ConditionOperator.EQUAL) {
-            return value === other;
-        }
-        if (operator2 === core$2.ConditionOperator.NOT_EQUAL) {
-            return value !== other;
-        }
-        if (operator2 === core$2.ConditionOperator.GREATER_EQUAL) {
-            return value >= other;
-        }
-        if (operator2 === core$2.ConditionOperator.GREATER_THAN) {
-            return value > other;
-        }
-        if (operator2 === core$2.ConditionOperator.LESS_EQUAL) {
-            return value <= other;
-        }
-        if (operator2 === core$2.ConditionOperator.LESS_THAN) {
-            return value < other;
+    function assign$5(target, object2) {
+        if (target == null) {
+            throw new TypeError("assign requires that input parameter not be null or undefined");
         }
-        if (operator2 === core$2.ConditionOperator.TRUTHY) {
-            return !!value;
+        for (var property in object2) {
+            if (Object.prototype.hasOwnProperty.call(object2, property)) {
+                target[property] = object2[property];
+            }
         }
-        throw new Error(`Unexpected operator ${String(operator2)} passed to conditional (If) component`);
+        return target;
     }
 
-    function If(props) {
-        const value = core$2.useAnyVariable(props.condition.variable);
-        const other = core$2.useAnyVariable(props.condition.other);
-        const conditionResult = React.useMemo(
-            () => isConditionTrue(props.condition.operator, value, other),
-            [props.condition, value, other]
-        );
-        const children2 = React.useMemo(() => {
-            return conditionResult ? props.true_children : props.false_children;
-        }, [conditionResult]);
-        return /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, children2.map((child, idx) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
-            component: child,
-            key: `if-${idx}-${child.name}-${String(conditionResult)}`
-        })));
+    function _assertThisInitialized$3(self2) {
+        if (self2 === void 0) {
+            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
+        }
+        return self2;
     }
 
-    function isCondition(condition) {
-        return condition && !!condition.operator;
+    function _setPrototypeOf$3(o2, p2) {
+        _setPrototypeOf$3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
+            o3.__proto__ = p3;
+            return o3;
+        };
+        return _setPrototypeOf$3(o2, p2);
     }
 
-    function useConditionOrVariable(arg) {
-        if (isCondition(arg)) {
-            const value = core$2.useVariable(arg.variable)[0];
-            const other = core$2.useVariable(arg.other)[0];
-            return isConditionTrue(arg.operator, value, other);
+    function _inherits$1(subClass, superClass) {
+        if (typeof superClass !== "function" && superClass !== null) {
+            throw new TypeError("Super expression must either be null or a function");
         }
-        return core$2.useVariable(arg)[0];
+        subClass.prototype = Object.create(superClass && superClass.prototype, {
+            constructor: {
+                value: subClass,
+                writable: true,
+                configurable: true
+            }
+        });
+        Object.defineProperty(subClass, "prototype", {
+            writable: false
+        });
+        if (superClass)
+            _setPrototypeOf$3(subClass, superClass);
     }
-    const StyledButton$1 = core$2.injectCss(styled__default.default(Button$3)`
-    flex: ${(props) => props.isSimpleButton ? void 0 : "1 1 100%"};
-`);
 
-    function Button(props) {
-        var _a3, _b, _c, _d;
-        const [style2, css2] = core$2.useComponentStyles(props);
-        const [onClick, loading] = core$2.useAction(props.onclick);
-        const disabled2 = useConditionOrVariable(props.disabled);
-        const Icon2 = props.icon ? core$2.getIcon(props.icon) : null;
-        const iconColor = Array.isArray(props.children) ? ((_c = (_b = (_a3 = props.children) == null ? void 0 : _a3[0]) == null ? void 0 : _b.props) == null ? void 0 : _c.color) || "inherit" : "inherit";
-        return /* @__PURE__ */ React__default.default.createElement(
-            StyledButton$1, {
-                $rawCss: css2,
-                className: props.className,
-                disabled: disabled2,
-                isSimpleButton: typeof props.children === "string" || ((_d = props.children[0]) == null ? void 0 : _d.name) === "Text",
-                loading,
-                onClick: () => onClick(null),
-                outline: props.outline,
-                style: {
-                    gap: "0.75rem",
-                    ...style2
-                },
-                styling: props.styling
-            },
-            props.icon && /* @__PURE__ */ React__default.default.createElement(
-                Icon2, {
-                    style: {
-                        color: iconColor,
-                        cursor: "pointer"
-                    }
-                }
-            ),
-            /* @__PURE__ */
-            React__default.default.createElement(core$2.DisplayCtx.Provider, {
-                value: {
-                    component: ComponentType.BUTTON,
-                    direction: "horizontal"
-                }
-            }, typeof props.children === "string" ? props.children : props.children.map((child) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
-                component: child,
-                key: `button-${child.uid}`
-            })))
-        );
+    function _getPrototypeOf$2(o2) {
+        _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
+            return o3.__proto__ || Object.getPrototypeOf(o3);
+        };
+        return _getPrototypeOf$2(o2);
     }
-    const formCtx = React.createContext(null);
 
-    function useFormContext(props) {
-        const formContext = React.useContext(formCtx);
-        const idRef = React.useRef(null);
-        const isMounted = React.useRef(false);
-        if (formContext === null) {
-            return {
-                resolveInitialValue: (defaultValue2) => {
-                    var _a3;
-                    return (_a3 = props.value) != null ? _a3 : defaultValue2;
-                },
-                updateForm: () => {}
-            };
-        }
-        if (isMounted.current === false) {
-            isMounted.current = true;
-            if (!props.id) {
-                throw new Error("Attempted to add a form interactive component without an id");
-            }
-            idRef.current = props.id;
+    function _isNativeReflectConstruct$2() {
+        try {
+            var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
+        } catch (t3) {}
+        return (_isNativeReflectConstruct$2 = function _isNativeReflectConstruct2() {
+            return !!t2;
+        })();
+    }
+
+    function _possibleConstructorReturn$1(self2, call2) {
+        if (call2 && (_typeof$5(call2) === "object" || typeof call2 === "function")) {
+            return call2;
+        } else if (call2 !== void 0) {
+            throw new TypeError("Derived constructors may only return object or undefined");
         }
-        const updateForm = (value) => formContext.updateForm(value, idRef.current);
-        const resolveInitialValue = (defaultValue2) => formContext.resolveInitialValue(defaultValue2, props.value, idRef.current);
-        return {
-            resolveInitialValue,
-            updateForm
-        };
+        return _assertThisInitialized$3(self2);
     }
-    const StyledButtonBar = core$2.injectCss(ButtonBar$1);
 
-    function ButtonBar(props) {
-        const formCtx2 = useFormContext(props);
-        const [style2, css2] = core$2.useComponentStyles(props);
-        const [value, setValue] = core$2.useVariable(formCtx2.resolveInitialValue(props.items[0].value));
-        const [onChangeAction] = core$2.useAction(props.onchange);
-        const onSelect = React.useCallback(
-            (item) => {
-                setValue(item.value);
-                onChangeAction(item.value);
-                formCtx2.updateForm(item.value);
-            },
-            [setValue, onChangeAction]
-        );
-        return /* @__PURE__ */ React__default.default.createElement(
-            StyledButtonBar, {
-                $rawCss: css2,
-                className: props.className,
-                items: props.items,
-                onSelect,
-                style: style2,
-                styling: props.styling,
-                value: props.items.find((item) => item.value === value)
+    function _createSuper$1(Derived) {
+        var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
+        return function _createSuperInternal() {
+            var Super = _getPrototypeOf$2(Derived),
+                result;
+            if (hasNativeReflectConstruct) {
+                var NewTarget = _getPrototypeOf$2(this).constructor;
+                result = Reflect.construct(Super, arguments, NewTarget);
+            } else {
+                result = Super.apply(this, arguments);
             }
-        );
+            return _possibleConstructorReturn$1(this, result);
+        };
     }
 
-    function _getPrototypeOf(o2) {
-        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
-            return o3.__proto__ || Object.getPrototypeOf(o3);
-        };
-        return _getPrototypeOf(o2);
+    function _classCallCheck$g(instance2, Constructor) {
+        if (!(instance2 instanceof Constructor)) {
+            throw new TypeError("Cannot call a class as a function");
+        }
     }
 
-    function _isNativeFunction(fn2) {
-        try {
-            return Function.toString.call(fn2).indexOf("[native code]") !== -1;
-        } catch (e3) {
-            return typeof fn2 === "function";
+    function toPrimitive(t2, r2) {
+        if ("object" != _typeof$5(t2) || !t2)
+            return t2;
+        var e3 = t2[Symbol.toPrimitive];
+        if (void 0 !== e3) {
+            var i2 = e3.call(t2, r2 || "default");
+            if ("object" != _typeof$5(i2))
+                return i2;
+            throw new TypeError("@@toPrimitive must return a primitive value.");
         }
+        return ("string" === r2 ? String : Number)(t2);
     }
 
-    function _isNativeReflectConstruct() {
-        if (typeof Reflect === "undefined" || !Reflect.construct)
-            return false;
-        if (Reflect.construct.sham)
-            return false;
-        if (typeof Proxy === "function")
-            return true;
-        try {
-            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
-            return true;
-        } catch (e3) {
-            return false;
+    function toPropertyKey(t2) {
+        var i2 = toPrimitive(t2, "string");
+        return "symbol" == _typeof$5(i2) ? i2 : i2 + "";
+    }
+
+    function _defineProperties$g(target, props) {
+        for (var i2 = 0; i2 < props.length; i2++) {
+            var descriptor = props[i2];
+            descriptor.enumerable = descriptor.enumerable || false;
+            descriptor.configurable = true;
+            if ("value" in descriptor)
+                descriptor.writable = true;
+            Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
         }
     }
 
-    function _construct(Parent, args, Class) {
-        if (_isNativeReflectConstruct()) {
-            _construct = Reflect.construct.bind();
+    function _createClass$g(Constructor, protoProps, staticProps) {
+        if (protoProps)
+            _defineProperties$g(Constructor.prototype, protoProps);
+        if (staticProps)
+            _defineProperties$g(Constructor, staticProps);
+        Object.defineProperty(Constructor, "prototype", {
+            writable: false
+        });
+        return Constructor;
+    }
+
+    function _defineProperty$o(obj, key, value) {
+        key = toPropertyKey(key);
+        if (key in obj) {
+            Object.defineProperty(obj, key, {
+                value,
+                enumerable: true,
+                configurable: true,
+                writable: true
+            });
         } else {
-            _construct = function _construct2(Parent2, args2, Class2) {
-                var a2 = [null];
-                a2.push.apply(a2, args2);
-                var Constructor = Function.bind.apply(Parent2, a2);
-                var instance2 = new Constructor();
-                if (Class2)
-                    _setPrototypeOf(instance2, Class2.prototype);
-                return instance2;
-            };
+            obj[key] = value;
         }
-        return _construct.apply(null, arguments);
+        return obj;
     }
+    var TIMEZONE_UNIT_PRIORITY = 10;
+    var Setter = /* @__PURE__ */ function() {
+        function Setter2() {
+            _classCallCheck$g(this, Setter2);
+            _defineProperty$o(this, "priority", void 0);
+            _defineProperty$o(this, "subPriority", 0);
+        }
+        _createClass$g(Setter2, [{
+            key: "validate",
+            value: function validate2(_utcDate, _options) {
+                return true;
+            }
+        }]);
+        return Setter2;
+    }();
+    var ValueSetter = /* @__PURE__ */ function(_Setter) {
+        _inherits$1(ValueSetter2, _Setter);
+        var _super = _createSuper$1(ValueSetter2);
 
-    function _wrapNativeSuper(Class) {
-        var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
-        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
-            if (Class2 === null || !_isNativeFunction(Class2))
-                return Class2;
-            if (typeof Class2 !== "function") {
-                throw new TypeError("Super expression must either be null or a function");
+        function ValueSetter2(value, validateValue, setValue, priority, subPriority) {
+            var _this;
+            _classCallCheck$g(this, ValueSetter2);
+            _this = _super.call(this);
+            _this.value = value;
+            _this.validateValue = validateValue;
+            _this.setValue = setValue;
+            _this.priority = priority;
+            if (subPriority) {
+                _this.subPriority = subPriority;
             }
-            if (typeof _cache !== "undefined") {
-                if (_cache.has(Class2))
-                    return _cache.get(Class2);
-                _cache.set(Class2, Wrapper2);
+            return _this;
+        }
+        _createClass$g(ValueSetter2, [{
+            key: "validate",
+            value: function validate2(utcDate, options) {
+                return this.validateValue(utcDate, this.value, options);
+            }
+        }, {
+            key: "set",
+            value: function set2(utcDate, flags, options) {
+                return this.setValue(utcDate, flags, this.value, options);
             }
+        }]);
+        return ValueSetter2;
+    }(Setter);
+    var DateToSystemTimezoneSetter = /* @__PURE__ */ function(_Setter2) {
+        _inherits$1(DateToSystemTimezoneSetter2, _Setter2);
+        var _super2 = _createSuper$1(DateToSystemTimezoneSetter2);
 
-            function Wrapper2() {
-                return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
+        function DateToSystemTimezoneSetter2() {
+            var _this2;
+            _classCallCheck$g(this, DateToSystemTimezoneSetter2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
             }
-            Wrapper2.prototype = Object.create(Class2.prototype, {
-                constructor: {
-                    value: Wrapper2,
-                    enumerable: false,
-                    writable: true,
-                    configurable: true
+            _this2 = _super2.call.apply(_super2, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
+            _defineProperty$o(_assertThisInitialized$3(_this2), "subPriority", -1);
+            return _this2;
+        }
+        _createClass$g(DateToSystemTimezoneSetter2, [{
+            key: "set",
+            value: function set2(date, flags) {
+                if (flags.timestampIsSet) {
+                    return date;
                 }
-            });
-            return _setPrototypeOf(Wrapper2, Class2);
-        };
-        return _wrapNativeSuper(Class);
-    }
-    var PolishedError$1 = /* @__PURE__ */ function(_Error) {
-        _inheritsLoose(PolishedError2, _Error);
-
-        function PolishedError2(code2) {
-            var _this;
-            {
-                _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + code2 + " for more information.") || this;
+                var convertedDate = new Date(0);
+                convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
+                convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
+                return convertedDate;
             }
-            return _assertThisInitialized(_this);
+        }]);
+        return DateToSystemTimezoneSetter2;
+    }(Setter);
+    var Parser$2 = /* @__PURE__ */ function() {
+        function Parser2() {
+            _classCallCheck$g(this, Parser2);
+            _defineProperty$o(this, "incompatibleTokens", void 0);
+            _defineProperty$o(this, "priority", void 0);
+            _defineProperty$o(this, "subPriority", void 0);
         }
-        return PolishedError2;
-    }( /* @__PURE__ */ _wrapNativeSuper(Error));
-
-    function colorToInt$1(color2) {
-        return Math.round(color2 * 255);
-    }
-
-    function convertToInt$1(red, green, blue) {
-        return colorToInt$1(red) + "," + colorToInt$1(green) + "," + colorToInt$1(blue);
-    }
+        _createClass$g(Parser2, [{
+            key: "run",
+            value: function run(dateString, token, match2, options) {
+                var result = this.parse(dateString, token, match2, options);
+                if (!result) {
+                    return null;
+                }
+                return {
+                    setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
+                    rest: result.rest
+                };
+            }
+        }, {
+            key: "validate",
+            value: function validate2(_utcDate, _value, _options) {
+                return true;
+            }
+        }]);
+        return Parser2;
+    }();
+    var EraParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(EraParser2, _Parser);
+        var _super = _createSuper$1(EraParser2);
 
-    function hslToRgb$1(hue, saturation, lightness, convert2) {
-        if (convert2 === void 0) {
-            convert2 = convertToInt$1;
-        }
-        if (saturation === 0) {
-            return convert2(lightness, lightness, lightness);
+        function EraParser2() {
+            var _this;
+            _classCallCheck$g(this, EraParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 140);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["R", "u", "t", "T"]);
+            return _this;
         }
-        var huePrime = (hue % 360 + 360) % 360 / 60;
-        var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
-        var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
-        var red = 0;
-        var green = 0;
-        var blue = 0;
-        if (huePrime >= 0 && huePrime < 1) {
-            red = chroma;
-            green = secondComponent;
-        } else if (huePrime >= 1 && huePrime < 2) {
-            red = secondComponent;
-            green = chroma;
-        } else if (huePrime >= 2 && huePrime < 3) {
-            green = chroma;
-            blue = secondComponent;
-        } else if (huePrime >= 3 && huePrime < 4) {
-            green = secondComponent;
-            blue = chroma;
-        } else if (huePrime >= 4 && huePrime < 5) {
-            red = secondComponent;
-            blue = chroma;
-        } else if (huePrime >= 5 && huePrime < 6) {
-            red = chroma;
-            blue = secondComponent;
-        }
-        var lightnessModification = lightness - chroma / 2;
-        var finalRed = red + lightnessModification;
-        var finalGreen = green + lightnessModification;
-        var finalBlue = blue + lightnessModification;
-        return convert2(finalRed, finalGreen, finalBlue);
-    }
-    var namedColorMap$1 = {
-        aliceblue: "f0f8ff",
-        antiquewhite: "faebd7",
-        aqua: "00ffff",
-        aquamarine: "7fffd4",
-        azure: "f0ffff",
-        beige: "f5f5dc",
-        bisque: "ffe4c4",
-        black: "000",
-        blanchedalmond: "ffebcd",
-        blue: "0000ff",
-        blueviolet: "8a2be2",
-        brown: "a52a2a",
-        burlywood: "deb887",
-        cadetblue: "5f9ea0",
-        chartreuse: "7fff00",
-        chocolate: "d2691e",
-        coral: "ff7f50",
-        cornflowerblue: "6495ed",
-        cornsilk: "fff8dc",
-        crimson: "dc143c",
-        cyan: "00ffff",
-        darkblue: "00008b",
-        darkcyan: "008b8b",
-        darkgoldenrod: "b8860b",
-        darkgray: "a9a9a9",
-        darkgreen: "006400",
-        darkgrey: "a9a9a9",
-        darkkhaki: "bdb76b",
-        darkmagenta: "8b008b",
-        darkolivegreen: "556b2f",
-        darkorange: "ff8c00",
-        darkorchid: "9932cc",
-        darkred: "8b0000",
-        darksalmon: "e9967a",
-        darkseagreen: "8fbc8f",
-        darkslateblue: "483d8b",
-        darkslategray: "2f4f4f",
-        darkslategrey: "2f4f4f",
-        darkturquoise: "00ced1",
-        darkviolet: "9400d3",
-        deeppink: "ff1493",
-        deepskyblue: "00bfff",
-        dimgray: "696969",
-        dimgrey: "696969",
-        dodgerblue: "1e90ff",
-        firebrick: "b22222",
-        floralwhite: "fffaf0",
-        forestgreen: "228b22",
-        fuchsia: "ff00ff",
-        gainsboro: "dcdcdc",
-        ghostwhite: "f8f8ff",
-        gold: "ffd700",
-        goldenrod: "daa520",
-        gray: "808080",
-        green: "008000",
-        greenyellow: "adff2f",
-        grey: "808080",
-        honeydew: "f0fff0",
-        hotpink: "ff69b4",
-        indianred: "cd5c5c",
-        indigo: "4b0082",
-        ivory: "fffff0",
-        khaki: "f0e68c",
-        lavender: "e6e6fa",
-        lavenderblush: "fff0f5",
-        lawngreen: "7cfc00",
-        lemonchiffon: "fffacd",
-        lightblue: "add8e6",
-        lightcoral: "f08080",
-        lightcyan: "e0ffff",
-        lightgoldenrodyellow: "fafad2",
-        lightgray: "d3d3d3",
-        lightgreen: "90ee90",
-        lightgrey: "d3d3d3",
-        lightpink: "ffb6c1",
-        lightsalmon: "ffa07a",
-        lightseagreen: "20b2aa",
-        lightskyblue: "87cefa",
-        lightslategray: "789",
-        lightslategrey: "789",
-        lightsteelblue: "b0c4de",
-        lightyellow: "ffffe0",
-        lime: "0f0",
-        limegreen: "32cd32",
-        linen: "faf0e6",
-        magenta: "f0f",
-        maroon: "800000",
-        mediumaquamarine: "66cdaa",
-        mediumblue: "0000cd",
-        mediumorchid: "ba55d3",
-        mediumpurple: "9370db",
-        mediumseagreen: "3cb371",
-        mediumslateblue: "7b68ee",
-        mediumspringgreen: "00fa9a",
-        mediumturquoise: "48d1cc",
-        mediumvioletred: "c71585",
-        midnightblue: "191970",
-        mintcream: "f5fffa",
-        mistyrose: "ffe4e1",
-        moccasin: "ffe4b5",
-        navajowhite: "ffdead",
-        navy: "000080",
-        oldlace: "fdf5e6",
-        olive: "808000",
-        olivedrab: "6b8e23",
-        orange: "ffa500",
-        orangered: "ff4500",
-        orchid: "da70d6",
-        palegoldenrod: "eee8aa",
-        palegreen: "98fb98",
-        paleturquoise: "afeeee",
-        palevioletred: "db7093",
-        papayawhip: "ffefd5",
-        peachpuff: "ffdab9",
-        peru: "cd853f",
-        pink: "ffc0cb",
-        plum: "dda0dd",
-        powderblue: "b0e0e6",
-        purple: "800080",
-        rebeccapurple: "639",
-        red: "f00",
-        rosybrown: "bc8f8f",
-        royalblue: "4169e1",
-        saddlebrown: "8b4513",
-        salmon: "fa8072",
-        sandybrown: "f4a460",
-        seagreen: "2e8b57",
-        seashell: "fff5ee",
-        sienna: "a0522d",
-        silver: "c0c0c0",
-        skyblue: "87ceeb",
-        slateblue: "6a5acd",
-        slategray: "708090",
-        slategrey: "708090",
-        snow: "fffafa",
-        springgreen: "00ff7f",
-        steelblue: "4682b4",
-        tan: "d2b48c",
-        teal: "008080",
-        thistle: "d8bfd8",
-        tomato: "ff6347",
-        turquoise: "40e0d0",
-        violet: "ee82ee",
-        wheat: "f5deb3",
-        white: "fff",
-        whitesmoke: "f5f5f5",
-        yellow: "ff0",
-        yellowgreen: "9acd32"
+        _createClass$g(EraParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                switch (token) {
+                    case "G":
+                    case "GG":
+                    case "GGG":
+                        return match2.era(dateString, {
+                            width: "abbreviated"
+                        }) || match2.era(dateString, {
+                            width: "narrow"
+                        });
+                    case "GGGGG":
+                        return match2.era(dateString, {
+                            width: "narrow"
+                        });
+                    case "GGGG":
+                    default:
+                        return match2.era(dateString, {
+                            width: "wide"
+                        }) || match2.era(dateString, {
+                            width: "abbreviated"
+                        }) || match2.era(dateString, {
+                            width: "narrow"
+                        });
+                }
+            }
+        }, {
+            key: "set",
+            value: function set2(date, flags, value) {
+                flags.era = value;
+                date.setUTCFullYear(value, 0, 1);
+                date.setUTCHours(0, 0, 0, 0);
+                return date;
+            }
+        }]);
+        return EraParser2;
+    }(Parser$2);
+    var millisecondsInMinute = 6e4;
+    var millisecondsInHour = 36e5;
+    var millisecondsInSecond = 1e3;
+    var numericPatterns = {
+        month: /^(1[0-2]|0?\d)/,
+        date: /^(3[0-1]|[0-2]?\d)/,
+        dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
+        week: /^(5[0-3]|[0-4]?\d)/,
+        hour23h: /^(2[0-3]|[0-1]?\d)/,
+        hour24h: /^(2[0-4]|[0-1]?\d)/,
+        hour11h: /^(1[0-1]|0?\d)/,
+        hour12h: /^(1[0-2]|0?\d)/,
+        minute: /^[0-5]?\d/,
+        second: /^[0-5]?\d/,
+        singleDigit: /^\d/,
+        twoDigits: /^\d{1,2}/,
+        threeDigits: /^\d{1,3}/,
+        fourDigits: /^\d{1,4}/,
+        anyDigitsSigned: /^-?\d+/,
+        singleDigitSigned: /^-?\d/,
+        twoDigitsSigned: /^-?\d{1,2}/,
+        threeDigitsSigned: /^-?\d{1,3}/,
+        fourDigitsSigned: /^-?\d{1,4}/
+    };
+    var timezonePatterns = {
+        basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
+        basic: /^([+-])(\d{2})(\d{2})|Z/,
+        basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
+        extended: /^([+-])(\d{2}):(\d{2})|Z/,
+        extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
     };
 
-    function nameToHex$1(color2) {
-        if (typeof color2 !== "string")
-            return color2;
-        var normalizedColorName = color2.toLowerCase();
-        return namedColorMap$1[normalizedColorName] ? "#" + namedColorMap$1[normalizedColorName] : color2;
+    function mapValue(parseFnResult, mapFn) {
+        if (!parseFnResult) {
+            return parseFnResult;
+        }
+        return {
+            value: mapFn(parseFnResult.value),
+            rest: parseFnResult.rest
+        };
     }
-    var hexRegex$1 = /^#[a-fA-F0-9]{6}$/;
-    var hexRgbaRegex$1 = /^#[a-fA-F0-9]{8}$/;
-    var reducedHexRegex$1 = /^#[a-fA-F0-9]{3}$/;
-    var reducedRgbaHexRegex$1 = /^#[a-fA-F0-9]{4}$/;
-    var rgbRegex$1 = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i;
-    var rgbaRegex$1 = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
-    var hslRegex$1 = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
-    var hslaRegex$1 = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
 
-    function parseToRgb$1(color2) {
-        if (typeof color2 !== "string") {
-            throw new PolishedError$1(3);
-        }
-        var normalizedColor = nameToHex$1(color2);
-        if (normalizedColor.match(hexRegex$1)) {
-            return {
-                red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
-                green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
-                blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
-            };
-        }
-        if (normalizedColor.match(hexRgbaRegex$1)) {
-            var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
-            return {
-                red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
-                green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
-                blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
-                alpha
-            };
-        }
-        if (normalizedColor.match(reducedHexRegex$1)) {
-            return {
-                red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
-                green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
-                blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
-            };
-        }
-        if (normalizedColor.match(reducedRgbaHexRegex$1)) {
-            var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));
-            return {
-                red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
-                green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
-                blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
-                alpha: _alpha
-            };
-        }
-        var rgbMatched = rgbRegex$1.exec(normalizedColor);
-        if (rgbMatched) {
-            return {
-                red: parseInt("" + rgbMatched[1], 10),
-                green: parseInt("" + rgbMatched[2], 10),
-                blue: parseInt("" + rgbMatched[3], 10)
-            };
-        }
-        var rgbaMatched = rgbaRegex$1.exec(normalizedColor.substring(0, 50));
-        if (rgbaMatched) {
-            return {
-                red: parseInt("" + rgbaMatched[1], 10),
-                green: parseInt("" + rgbaMatched[2], 10),
-                blue: parseInt("" + rgbaMatched[3], 10),
-                alpha: parseFloat("" + rgbaMatched[4]) > 1 ? parseFloat("" + rgbaMatched[4]) / 100 : parseFloat("" + rgbaMatched[4])
-            };
+    function parseNumericPattern(pattern, dateString) {
+        var matchResult = dateString.match(pattern);
+        if (!matchResult) {
+            return null;
         }
-        var hslMatched = hslRegex$1.exec(normalizedColor);
-        if (hslMatched) {
-            var hue = parseInt("" + hslMatched[1], 10);
-            var saturation = parseInt("" + hslMatched[2], 10) / 100;
-            var lightness = parseInt("" + hslMatched[3], 10) / 100;
-            var rgbColorString = "rgb(" + hslToRgb$1(hue, saturation, lightness) + ")";
-            var hslRgbMatched = rgbRegex$1.exec(rgbColorString);
-            if (!hslRgbMatched) {
-                throw new PolishedError$1(4, normalizedColor, rgbColorString);
-            }
-            return {
-                red: parseInt("" + hslRgbMatched[1], 10),
-                green: parseInt("" + hslRgbMatched[2], 10),
-                blue: parseInt("" + hslRgbMatched[3], 10)
-            };
+        return {
+            value: parseInt(matchResult[0], 10),
+            rest: dateString.slice(matchResult[0].length)
+        };
+    }
+
+    function parseTimezonePattern(pattern, dateString) {
+        var matchResult = dateString.match(pattern);
+        if (!matchResult) {
+            return null;
         }
-        var hslaMatched = hslaRegex$1.exec(normalizedColor.substring(0, 50));
-        if (hslaMatched) {
-            var _hue = parseInt("" + hslaMatched[1], 10);
-            var _saturation = parseInt("" + hslaMatched[2], 10) / 100;
-            var _lightness = parseInt("" + hslaMatched[3], 10) / 100;
-            var _rgbColorString = "rgb(" + hslToRgb$1(_hue, _saturation, _lightness) + ")";
-            var _hslRgbMatched = rgbRegex$1.exec(_rgbColorString);
-            if (!_hslRgbMatched) {
-                throw new PolishedError$1(4, normalizedColor, _rgbColorString);
-            }
+        if (matchResult[0] === "Z") {
             return {
-                red: parseInt("" + _hslRgbMatched[1], 10),
-                green: parseInt("" + _hslRgbMatched[2], 10),
-                blue: parseInt("" + _hslRgbMatched[3], 10),
-                alpha: parseFloat("" + hslaMatched[4]) > 1 ? parseFloat("" + hslaMatched[4]) / 100 : parseFloat("" + hslaMatched[4])
+                value: 0,
+                rest: dateString.slice(1)
             };
         }
-        throw new PolishedError$1(5);
+        var sign2 = matchResult[1] === "+" ? 1 : -1;
+        var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
+        var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
+        var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
+        return {
+            value: sign2 * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
+            rest: dateString.slice(matchResult[0].length)
+        };
     }
-    var reduceHexValue$2 = function reduceHexValue2(value) {
-        if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
-            return "#" + value[1] + value[3] + value[5];
-        }
-        return value;
-    };
-    var reduceHexValue$1$1 = reduceHexValue$2;
 
-    function numberToHex$1(value) {
-        var hex2 = value.toString(16);
-        return hex2.length === 1 ? "0" + hex2 : hex2;
+    function parseAnyDigitsSigned(dateString) {
+        return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
     }
 
-    function rgb$2(value, green, blue) {
-        if (typeof value === "number" && typeof green === "number" && typeof blue === "number") {
-            return reduceHexValue$1$1("#" + numberToHex$1(value) + numberToHex$1(green) + numberToHex$1(blue));
-        } else if (typeof value === "object" && green === void 0 && blue === void 0) {
-            return reduceHexValue$1$1("#" + numberToHex$1(value.red) + numberToHex$1(value.green) + numberToHex$1(value.blue));
+    function parseNDigits(n2, dateString) {
+        switch (n2) {
+            case 1:
+                return parseNumericPattern(numericPatterns.singleDigit, dateString);
+            case 2:
+                return parseNumericPattern(numericPatterns.twoDigits, dateString);
+            case 3:
+                return parseNumericPattern(numericPatterns.threeDigits, dateString);
+            case 4:
+                return parseNumericPattern(numericPatterns.fourDigits, dateString);
+            default:
+                return parseNumericPattern(new RegExp("^\\d{1," + n2 + "}"), dateString);
         }
-        throw new PolishedError$1(6);
     }
 
-    function rgba$3(firstValue, secondValue, thirdValue, fourthValue) {
-        if (typeof firstValue === "string" && typeof secondValue === "number") {
-            var rgbValue = parseToRgb$1(firstValue);
-            return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
-        } else if (typeof firstValue === "number" && typeof secondValue === "number" && typeof thirdValue === "number" && typeof fourthValue === "number") {
-            return fourthValue >= 1 ? rgb$2(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
-        } else if (typeof firstValue === "object" && secondValue === void 0 && thirdValue === void 0 && fourthValue === void 0) {
-            return firstValue.alpha >= 1 ? rgb$2(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
+    function parseNDigitsSigned(n2, dateString) {
+        switch (n2) {
+            case 1:
+                return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
+            case 2:
+                return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
+            case 3:
+                return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
+            case 4:
+                return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
+            default:
+                return parseNumericPattern(new RegExp("^-?\\d{1," + n2 + "}"), dateString);
         }
-        throw new PolishedError$1(7);
     }
 
-    function curried$1(f2, length, acc) {
-        return function fn2() {
-            var combined = acc.concat(Array.prototype.slice.call(arguments));
-            return combined.length >= length ? f2.apply(this, combined) : curried$1(f2, length, combined);
-        };
+    function dayPeriodEnumToHours(dayPeriod) {
+        switch (dayPeriod) {
+            case "morning":
+                return 4;
+            case "evening":
+                return 17;
+            case "pm":
+            case "noon":
+            case "afternoon":
+                return 12;
+            case "am":
+            case "midnight":
+            case "night":
+            default:
+                return 0;
+        }
     }
 
-    function curry$1(f2) {
-        return curried$1(f2, f2.length, []);
+    function normalizeTwoDigitYear(twoDigitYear, currentYear) {
+        var isCommonEra = currentYear > 0;
+        var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
+        var result;
+        if (absCurrentYear <= 50) {
+            result = twoDigitYear || 100;
+        } else {
+            var rangeEnd2 = absCurrentYear + 50;
+            var rangeEndCentury = Math.floor(rangeEnd2 / 100) * 100;
+            var isPreviousCentury = twoDigitYear >= rangeEnd2 % 100;
+            result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
+        }
+        return isCommonEra ? result : 1 - result;
     }
 
-    function guard$1(lowerBoundary, upperBoundary, value) {
-        return Math.max(lowerBoundary, Math.min(upperBoundary, value));
+    function isLeapYearIndex$1(year) {
+        return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
     }
+    var YearParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(YearParser2, _Parser);
+        var _super = _createSuper$1(YearParser2);
 
-    function transparentize$1(amount, color2) {
-        if (color2 === "transparent")
-            return color2;
-        var parsedColor = parseToRgb$1(color2);
-        var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
-        var colorWithAlpha = _extends$1({}, parsedColor, {
-            alpha: guard$1(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)
-        });
-        return rgba$3(colorWithAlpha);
-    }
-    var curriedTransparentize = /* @__PURE__ */ curry$1(transparentize$1);
-    var curriedTransparentize$1 = curriedTransparentize;
-    const CardDiv = core$2.injectCss(styled__default.default.div`
-    display: flex;
-    flex: 1 1 auto;
-    flex-direction: column;
+        function YearParser2() {
+            var _this;
+            _classCallCheck$g(this, YearParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 130);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
+            return _this;
+        }
+        _createClass$g(YearParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                var valueCallback = function valueCallback2(year) {
+                    return {
+                        year,
+                        isTwoDigitYear: token === "yy"
+                    };
+                };
+                switch (token) {
+                    case "y":
+                        return mapValue(parseNDigits(4, dateString), valueCallback);
+                    case "yo":
+                        return mapValue(match2.ordinalNumber(dateString, {
+                            unit: "year"
+                        }), valueCallback);
+                    default:
+                        return mapValue(parseNDigits(token.length, dateString), valueCallback);
+                }
+            }
+        }, {
+            key: "validate",
+            value: function validate2(_date, value) {
+                return value.isTwoDigitYear || value.year > 0;
+            }
+        }, {
+            key: "set",
+            value: function set2(date, flags, value) {
+                var currentYear = date.getUTCFullYear();
+                if (value.isTwoDigitYear) {
+                    var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
+                    date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
+                    date.setUTCHours(0, 0, 0, 0);
+                    return date;
+                }
+                var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
+                date.setUTCFullYear(year, 0, 1);
+                date.setUTCHours(0, 0, 0, 0);
+                return date;
+            }
+        }]);
+        return YearParser2;
+    }(Parser$2);
+    var LocalWeekYearParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(LocalWeekYearParser2, _Parser);
+        var _super = _createSuper$1(LocalWeekYearParser2);
 
-    width: 100%;
-    padding: 1.5rem;
+        function LocalWeekYearParser2() {
+            var _this;
+            _classCallCheck$g(this, LocalWeekYearParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 130);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]);
+            return _this;
+        }
+        _createClass$g(LocalWeekYearParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                var valueCallback = function valueCallback2(year) {
+                    return {
+                        year,
+                        isTwoDigitYear: token === "YY"
+                    };
+                };
+                switch (token) {
+                    case "Y":
+                        return mapValue(parseNDigits(4, dateString), valueCallback);
+                    case "Yo":
+                        return mapValue(match2.ordinalNumber(dateString, {
+                            unit: "year"
+                        }), valueCallback);
+                    default:
+                        return mapValue(parseNDigits(token.length, dateString), valueCallback);
+                }
+            }
+        }, {
+            key: "validate",
+            value: function validate2(_date, value) {
+                return value.isTwoDigitYear || value.year > 0;
+            }
+        }, {
+            key: "set",
+            value: function set2(date, flags, value, options) {
+                var currentYear = getUTCWeekYear(date, options);
+                if (value.isTwoDigitYear) {
+                    var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
+                    date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
+                    date.setUTCHours(0, 0, 0, 0);
+                    return startOfUTCWeek(date, options);
+                }
+                var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
+                date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
+                date.setUTCHours(0, 0, 0, 0);
+                return startOfUTCWeek(date, options);
+            }
+        }]);
+        return LocalWeekYearParser2;
+    }(Parser$2);
+    var ISOWeekYearParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(ISOWeekYearParser2, _Parser);
+        var _super = _createSuper$1(ISOWeekYearParser2);
 
-    color: ${(props) => props.theme.colors.text};
+        function ISOWeekYearParser2() {
+            var _this;
+            _classCallCheck$g(this, ISOWeekYearParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 130);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
+            return _this;
+        }
+        _createClass$g(ISOWeekYearParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token) {
+                if (token === "R") {
+                    return parseNDigitsSigned(4, dateString);
+                }
+                return parseNDigitsSigned(token.length, dateString);
+            }
+        }, {
+            key: "set",
+            value: function set2(_date, _flags, value) {
+                var firstWeekOfYear = new Date(0);
+                firstWeekOfYear.setUTCFullYear(value, 0, 4);
+                firstWeekOfYear.setUTCHours(0, 0, 0, 0);
+                return startOfUTCISOWeek(firstWeekOfYear);
+            }
+        }]);
+        return ISOWeekYearParser2;
+    }(Parser$2);
+    var ExtendedYearParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(ExtendedYearParser2, _Parser);
+        var _super = _createSuper$1(ExtendedYearParser2);
 
-    background: ${(props) => props.accent ? `radial-gradient(circle closest-corner at 50% 40%, ${curriedTransparentize$1(
-    0.9,
-    props.theme.colors.background
-  )} 0%, ${curriedTransparentize$1(
-    0.8,
-    props.theme.colors.blue4
-  )} 70%),radial-gradient(circle closest-corner at 20% 150%, ${curriedTransparentize$1(
-    0.8,
-    props.theme.colors.error
-  )} 0%, ${curriedTransparentize$1(0.2, props.theme.colors.blue4)} 230%)` : props.theme.colors.blue1};
-    border-radius: 1rem;
-    box-shadow: ${(props) => props.theme.shadow.medium};
-`);
-    const ChildrenWrapper = styled__default.default.div`
-    display: flex;
-    flex-direction: column;
-    gap: 0.75rem;
+        function ExtendedYearParser2() {
+            var _this;
+            _classCallCheck$g(this, ExtendedYearParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 130);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
+            return _this;
+        }
+        _createClass$g(ExtendedYearParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token) {
+                if (token === "u") {
+                    return parseNDigitsSigned(4, dateString);
+                }
+                return parseNDigitsSigned(token.length, dateString);
+            }
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value) {
+                date.setUTCFullYear(value, 0, 1);
+                date.setUTCHours(0, 0, 0, 0);
+                return date;
+            }
+        }]);
+        return ExtendedYearParser2;
+    }(Parser$2);
+    var QuarterParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(QuarterParser2, _Parser);
+        var _super = _createSuper$1(QuarterParser2);
 
-    width: 100%;
-    height: 100%;
-    margin-top: ${(props) => props.hasTitle || props.hasSubtitle ? "0.75rem" : "0rem"};
-`;
-    const Title$1 = styled__default.default.span`
-    font-size: 1.2rem;
-    font-weight: 400;
-    text-align: left;
-`;
-    const Subtitle = styled__default.default.span`
-    margin-top: ${(props) => props.hasTitle ? "0.25rem" : "0rem"};
+        function QuarterParser2() {
+            var _this;
+            _classCallCheck$g(this, QuarterParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 120);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
+            return _this;
+        }
+        _createClass$g(QuarterParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                switch (token) {
+                    case "Q":
+                    case "QQ":
+                        return parseNDigits(token.length, dateString);
+                    case "Qo":
+                        return match2.ordinalNumber(dateString, {
+                            unit: "quarter"
+                        });
+                    case "QQQ":
+                        return match2.quarter(dateString, {
+                            width: "abbreviated",
+                            context: "formatting"
+                        }) || match2.quarter(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
+                    case "QQQQQ":
+                        return match2.quarter(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
+                    case "QQQQ":
+                    default:
+                        return match2.quarter(dateString, {
+                            width: "wide",
+                            context: "formatting"
+                        }) || match2.quarter(dateString, {
+                            width: "abbreviated",
+                            context: "formatting"
+                        }) || match2.quarter(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
+                }
+            }
+        }, {
+            key: "validate",
+            value: function validate2(_date, value) {
+                return value >= 1 && value <= 4;
+            }
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value) {
+                date.setUTCMonth((value - 1) * 3, 1);
+                date.setUTCHours(0, 0, 0, 0);
+                return date;
+            }
+        }]);
+        return QuarterParser2;
+    }(Parser$2);
+    var StandAloneQuarterParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(StandAloneQuarterParser2, _Parser);
+        var _super = _createSuper$1(StandAloneQuarterParser2);
 
-    font-size: 1rem;
-    font-weight: 400;
-    color: ${(props) => props.theme.colors.grey4};
-    text-align: left;
-`;
+        function StandAloneQuarterParser2() {
+            var _this;
+            _classCallCheck$g(this, StandAloneQuarterParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 120);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
+            return _this;
+        }
+        _createClass$g(StandAloneQuarterParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                switch (token) {
+                    case "q":
+                    case "qq":
+                        return parseNDigits(token.length, dateString);
+                    case "qo":
+                        return match2.ordinalNumber(dateString, {
+                            unit: "quarter"
+                        });
+                    case "qqq":
+                        return match2.quarter(dateString, {
+                            width: "abbreviated",
+                            context: "standalone"
+                        }) || match2.quarter(dateString, {
+                            width: "narrow",
+                            context: "standalone"
+                        });
+                    case "qqqqq":
+                        return match2.quarter(dateString, {
+                            width: "narrow",
+                            context: "standalone"
+                        });
+                    case "qqqq":
+                    default:
+                        return match2.quarter(dateString, {
+                            width: "wide",
+                            context: "standalone"
+                        }) || match2.quarter(dateString, {
+                            width: "abbreviated",
+                            context: "standalone"
+                        }) || match2.quarter(dateString, {
+                            width: "narrow",
+                            context: "standalone"
+                        });
+                }
+            }
+        }, {
+            key: "validate",
+            value: function validate2(_date, value) {
+                return value >= 1 && value <= 4;
+            }
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value) {
+                date.setUTCMonth((value - 1) * 3, 1);
+                date.setUTCHours(0, 0, 0, 0);
+                return date;
+            }
+        }]);
+        return StandAloneQuarterParser2;
+    }(Parser$2);
+    var MonthParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(MonthParser2, _Parser);
+        var _super = _createSuper$1(MonthParser2);
 
-    function Card$1(props) {
-        const [style2, css2] = core$2.useComponentStyles(props);
-        return /* @__PURE__ */ React__default.default.createElement(CardDiv, {
-            $rawCss: css2,
-            accent: props.accent,
-            style: style2
-        }, props.title && /* @__PURE__ */ React__default.default.createElement(Title$1, null, props.title), props.subtitle && /* @__PURE__ */ React__default.default.createElement(Subtitle, {
-            hasTitle: props.title !== null
-        }, props.subtitle), /* @__PURE__ */ React__default.default.createElement(
-            ChildrenWrapper, {
-                "data-type": "children-wrapper",
-                hasSubtitle: props.subtitle !== null,
-                hasTitle: props.title !== null,
-                style: {
-                    alignItems: props.align,
-                    justifyContent: props.justify
+        function MonthParser2() {
+            var _this;
+            _classCallCheck$g(this, MonthParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 110);
+            return _this;
+        }
+        _createClass$g(MonthParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                var valueCallback = function valueCallback2(value) {
+                    return value - 1;
+                };
+                switch (token) {
+                    case "M":
+                        return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
+                    case "MM":
+                        return mapValue(parseNDigits(2, dateString), valueCallback);
+                    case "Mo":
+                        return mapValue(match2.ordinalNumber(dateString, {
+                            unit: "month"
+                        }), valueCallback);
+                    case "MMM":
+                        return match2.month(dateString, {
+                            width: "abbreviated",
+                            context: "formatting"
+                        }) || match2.month(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
+                    case "MMMMM":
+                        return match2.month(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
+                    case "MMMM":
+                    default:
+                        return match2.month(dateString, {
+                            width: "wide",
+                            context: "formatting"
+                        }) || match2.month(dateString, {
+                            width: "abbreviated",
+                            context: "formatting"
+                        }) || match2.month(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
                 }
-            },
-            /* @__PURE__ */
-            React__default.default.createElement(core$2.DisplayCtx.Provider, {
-                value: {
-                    component: "card",
-                    direction: "vertical"
+            }
+        }, {
+            key: "validate",
+            value: function validate2(_date, value) {
+                return value >= 0 && value <= 11;
+            }
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value) {
+                date.setUTCMonth(value, 1);
+                date.setUTCHours(0, 0, 0, 0);
+                return date;
+            }
+        }]);
+        return MonthParser2;
+    }(Parser$2);
+    var StandAloneMonthParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(StandAloneMonthParser2, _Parser);
+        var _super = _createSuper$1(StandAloneMonthParser2);
+
+        function StandAloneMonthParser2() {
+            var _this;
+            _classCallCheck$g(this, StandAloneMonthParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 110);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]);
+            return _this;
+        }
+        _createClass$g(StandAloneMonthParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                var valueCallback = function valueCallback2(value) {
+                    return value - 1;
+                };
+                switch (token) {
+                    case "L":
+                        return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
+                    case "LL":
+                        return mapValue(parseNDigits(2, dateString), valueCallback);
+                    case "Lo":
+                        return mapValue(match2.ordinalNumber(dateString, {
+                            unit: "month"
+                        }), valueCallback);
+                    case "LLL":
+                        return match2.month(dateString, {
+                            width: "abbreviated",
+                            context: "standalone"
+                        }) || match2.month(dateString, {
+                            width: "narrow",
+                            context: "standalone"
+                        });
+                    case "LLLLL":
+                        return match2.month(dateString, {
+                            width: "narrow",
+                            context: "standalone"
+                        });
+                    case "LLLL":
+                    default:
+                        return match2.month(dateString, {
+                            width: "wide",
+                            context: "standalone"
+                        }) || match2.month(dateString, {
+                            width: "abbreviated",
+                            context: "standalone"
+                        }) || match2.month(dateString, {
+                            width: "narrow",
+                            context: "standalone"
+                        });
                 }
-            }, props.children.map((child, idx) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
-                component: child,
-                key: `card-${idx}-${child.name}`
-            })))
-        ));
-    }
-    const StyledCarousel = core$2.injectCss(Carousel$1);
+            }
+        }, {
+            key: "validate",
+            value: function validate2(_date, value) {
+                return value >= 0 && value <= 11;
+            }
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value) {
+                date.setUTCMonth(value, 1);
+                date.setUTCHours(0, 0, 0, 0);
+                return date;
+            }
+        }]);
+        return StandAloneMonthParser2;
+    }(Parser$2);
 
-    function Carousel(props) {
-        const [items] = core$2.useVariable(props.items);
-        const [value, setValue] = core$2.useVariable(props.value);
-        const [onCarouselAction] = core$2.useAction(props.onchange);
+    function setUTCWeek(dirtyDate, dirtyWeek, options) {
+        requiredArgs(2, arguments);
+        var date = toDate(dirtyDate);
+        var week = toInteger$2(dirtyWeek);
+        var diff = getUTCWeek(date, options) - week;
+        date.setUTCDate(date.getUTCDate() - diff * 7);
+        return date;
+    }
+    var LocalWeekParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(LocalWeekParser2, _Parser);
+        var _super = _createSuper$1(LocalWeekParser2);
 
-        function handleChange(val) {
-            setValue(val);
-            onCarouselAction(val);
+        function LocalWeekParser2() {
+            var _this;
+            _classCallCheck$g(this, LocalWeekParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 100);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]);
+            return _this;
         }
-        const remappedItems = React.useMemo(
-            () => items.map((item) => {
-                const {
-                    component,
-                    ...rest
-                } = item;
-                if (component) {
-                    return {
-                        ...rest,
-                        component: /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
-                            component
-                        }),
-                        imageAlt: item.image_alt,
-                        imageHeight: item.image_height,
-                        imageWidth: item.image_width
-                    };
+        _createClass$g(LocalWeekParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                switch (token) {
+                    case "w":
+                        return parseNumericPattern(numericPatterns.week, dateString);
+                    case "wo":
+                        return match2.ordinalNumber(dateString, {
+                            unit: "week"
+                        });
+                    default:
+                        return parseNDigits(token.length, dateString);
                 }
-                return {
-                    ...rest,
-                    imageAlt: item.image_alt,
-                    imageHeight: item.image_height,
-                    imageWidth: item.image_width
-                };
-            }),
-            [items]
-        );
-        const [style2, css2] = core$2.useComponentStyles(props);
-        return /* @__PURE__ */ React__default.default.createElement(
-            StyledCarousel, {
-                $rawCss: css2,
-                className: props.className,
-                items: remappedItems,
-                onChange: handleChange,
-                style: style2,
-                value
             }
-        );
+        }, {
+            key: "validate",
+            value: function validate2(_date, value) {
+                return value >= 1 && value <= 53;
+            }
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value, options) {
+                return startOfUTCWeek(setUTCWeek(date, value, options), options);
+            }
+        }]);
+        return LocalWeekParser2;
+    }(Parser$2);
+
+    function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
+        requiredArgs(2, arguments);
+        var date = toDate(dirtyDate);
+        var isoWeek = toInteger$2(dirtyISOWeek);
+        var diff = getUTCISOWeek(date) - isoWeek;
+        date.setUTCDate(date.getUTCDate() - diff * 7);
+        return date;
     }
-    const ColumnComponent = core$2.injectCss(styled__default.default.div`
-    overflow: visible;
-    display: flex;
-    flex: 1 1 auto;
-    flex-direction: ${(props) => props.direction === "horizontal" ? "row" : "column"};
-    gap: 0.75rem;
-`);
-    const StyledColumn$1 = core$2.injectCss(ColumnComponent);
+    var ISOWeekParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(ISOWeekParser2, _Parser);
+        var _super = _createSuper$1(ISOWeekParser2);
 
-    function Column(props) {
-        const [style2, css2] = core$2.useComponentStyles(props);
-        return /* @__PURE__ */ React__default.default.createElement(
-            StyledColumn$1, {
-                $rawCss: css2,
-                className: props.className,
-                direction: props.direction,
-                style: {
-                    alignItems: props.align,
-                    justifyContent: props.justify,
-                    ...style2
+        function ISOWeekParser2() {
+            var _this;
+            _classCallCheck$g(this, ISOWeekParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 100);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
+            return _this;
+        }
+        _createClass$g(ISOWeekParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                switch (token) {
+                    case "I":
+                        return parseNumericPattern(numericPatterns.week, dateString);
+                    case "Io":
+                        return match2.ordinalNumber(dateString, {
+                            unit: "week"
+                        });
+                    default:
+                        return parseNDigits(token.length, dateString);
                 }
-            },
-            /* @__PURE__ */
-            React__default.default.createElement(core$2.DisplayCtx.Provider, {
-                value: {
-                    component: "column",
-                    direction: props.direction
+            }
+        }, {
+            key: "validate",
+            value: function validate2(_date, value) {
+                return value >= 1 && value <= 53;
+            }
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value) {
+                return startOfUTCISOWeek(setUTCISOWeek(date, value));
+            }
+        }]);
+        return ISOWeekParser2;
+    }(Parser$2);
+    var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
+    var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
+    var DateParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(DateParser2, _Parser);
+        var _super = _createSuper$1(DateParser2);
+
+        function DateParser2() {
+            var _this;
+            _classCallCheck$g(this, DateParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 90);
+            _defineProperty$o(_assertThisInitialized$3(_this), "subPriority", 1);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]);
+            return _this;
+        }
+        _createClass$g(DateParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                switch (token) {
+                    case "d":
+                        return parseNumericPattern(numericPatterns.date, dateString);
+                    case "do":
+                        return match2.ordinalNumber(dateString, {
+                            unit: "date"
+                        });
+                    default:
+                        return parseNDigits(token.length, dateString);
                 }
-            }, props.children.map((child, idx) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
-                component: child,
-                key: `cell-${idx}-${child.uid}`
-            })))
-        );
-    }
-    const StyledCheckbox = core$2.injectCss(CheckboxGroup$1);
+            }
+        }, {
+            key: "validate",
+            value: function validate2(date, value) {
+                var year = date.getUTCFullYear();
+                var isLeapYear = isLeapYearIndex$1(year);
+                var month = date.getUTCMonth();
+                if (isLeapYear) {
+                    return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
+                } else {
+                    return value >= 1 && value <= DAYS_IN_MONTH[month];
+                }
+            }
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value) {
+                date.setUTCDate(value);
+                date.setUTCHours(0, 0, 0, 0);
+                return date;
+            }
+        }]);
+        return DateParser2;
+    }(Parser$2);
+    var DayOfYearParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(DayOfYearParser2, _Parser);
+        var _super = _createSuper$1(DayOfYearParser2);
 
-    function CheckboxGroup(props) {
-        const formCtx2 = useFormContext(props);
-        const [items] = core$2.useVariable(props.items);
-        const [value, setValue] = core$2.useVariable(formCtx2.resolveInitialValue([]));
-        const [style2, css2] = core$2.useComponentStyles(props);
-        const [onChangeAction] = core$2.useAction(props.onchange);
-        const onChange2 = React.useCallback(
-            (values) => {
-                let newValues;
-                if (Array.isArray(values)) {
-                    newValues = values.map((item) => item.value);
+        function DayOfYearParser2() {
+            var _this;
+            _classCallCheck$g(this, DayOfYearParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 90);
+            _defineProperty$o(_assertThisInitialized$3(_this), "subpriority", 1);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]);
+            return _this;
+        }
+        _createClass$g(DayOfYearParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                switch (token) {
+                    case "D":
+                    case "DD":
+                        return parseNumericPattern(numericPatterns.dayOfYear, dateString);
+                    case "Do":
+                        return match2.ordinalNumber(dateString, {
+                            unit: "date"
+                        });
+                    default:
+                        return parseNDigits(token.length, dateString);
+                }
+            }
+        }, {
+            key: "validate",
+            value: function validate2(date, value) {
+                var year = date.getUTCFullYear();
+                var isLeapYear = isLeapYearIndex$1(year);
+                if (isLeapYear) {
+                    return value >= 1 && value <= 366;
                 } else {
-                    newValues = values.value;
+                    return value >= 1 && value <= 365;
                 }
-                setValue(newValues);
-                onChangeAction(newValues);
-                formCtx2.updateForm(newValues);
-            },
-            [setValue]
-        );
-        return /* @__PURE__ */ React__default.default.createElement(
-            StyledCheckbox, {
-                $rawCss: css2,
-                className: props.className,
-                isListStyle: props.list_styling,
-                items,
-                onChange: onChange2,
-                selectMax: props.select_max,
-                selectMin: props.select_min,
-                style: style2,
-                values: items.filter((item) => value.includes(item.value))
             }
-        );
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value) {
+                date.setUTCMonth(0, value);
+                date.setUTCHours(0, 0, 0, 0);
+                return date;
+            }
+        }]);
+        return DayOfYearParser2;
+    }(Parser$2);
+
+    function setUTCDay(dirtyDate, dirtyDay, options) {
+        var _ref2, _ref22, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
+        requiredArgs(2, arguments);
+        var defaultOptions2 = getDefaultOptions();
+        var weekStartsOn = toInteger$2((_ref2 = (_ref22 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : 0);
+        if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
+            throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
+        }
+        var date = toDate(dirtyDate);
+        var day = toInteger$2(dirtyDay);
+        var currentDay = date.getUTCDay();
+        var remainder = day % 7;
+        var dayIndex = (remainder + 7) % 7;
+        var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
+        date.setUTCDate(date.getUTCDate() + diff);
+        return date;
     }
-    /**
-     * Prism: Lightweight, robust, elegant syntax highlighting
-     *
-     * @license MIT <https://opensource.org/licenses/MIT>
-     * @author Lea Verou <https://lea.verou.me>
-     * @namespace
-     * @public
-     */
-    var Prism = function() {
-        var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
-        var uniqueId = 0;
-        var plainTextGrammar = {};
-        var _2 = {
-            util: {
-                encode: function encode2(tokens2) {
-                    if (tokens2 instanceof Token) {
-                        return new Token(tokens2.type, encode2(tokens2.content), tokens2.alias);
-                    } else if (Array.isArray(tokens2)) {
-                        return tokens2.map(encode2);
-                    } else {
-                        return tokens2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
-                    }
-                },
-                type: function(o2) {
-                    return Object.prototype.toString.call(o2).slice(8, -1);
-                },
-                objId: function(obj) {
-                    if (!obj["__id"]) {
-                        Object.defineProperty(obj, "__id", {
-                            value: ++uniqueId
+    var DayParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(DayParser2, _Parser);
+        var _super = _createSuper$1(DayParser2);
+
+        function DayParser2() {
+            var _this;
+            _classCallCheck$g(this, DayParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 90);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
+            return _this;
+        }
+        _createClass$g(DayParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                switch (token) {
+                    case "E":
+                    case "EE":
+                    case "EEE":
+                        return match2.day(dateString, {
+                            width: "abbreviated",
+                            context: "formatting"
+                        }) || match2.day(dateString, {
+                            width: "short",
+                            context: "formatting"
+                        }) || match2.day(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
+                    case "EEEEE":
+                        return match2.day(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
+                    case "EEEEEE":
+                        return match2.day(dateString, {
+                            width: "short",
+                            context: "formatting"
+                        }) || match2.day(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
+                    case "EEEE":
+                    default:
+                        return match2.day(dateString, {
+                            width: "wide",
+                            context: "formatting"
+                        }) || match2.day(dateString, {
+                            width: "abbreviated",
+                            context: "formatting"
+                        }) || match2.day(dateString, {
+                            width: "short",
+                            context: "formatting"
+                        }) || match2.day(dateString, {
+                            width: "narrow",
+                            context: "formatting"
                         });
-                    }
-                    return obj["__id"];
-                },
-                clone: function deepClone(o2, visited) {
-                    visited = visited || {};
-                    var clone2;
-                    var id2;
-                    switch (_2.util.type(o2)) {
-                        case "Object":
-                            id2 = _2.util.objId(o2);
-                            if (visited[id2]) {
-                                return visited[id2];
-                            }
-                            clone2 = {};
-                            visited[id2] = clone2;
-                            for (var key in o2) {
-                                if (o2.hasOwnProperty(key)) {
-                                    clone2[key] = deepClone(o2[key], visited);
-                                }
-                            }
-                            return clone2;
-                        case "Array":
-                            id2 = _2.util.objId(o2);
-                            if (visited[id2]) {
-                                return visited[id2];
-                            }
-                            clone2 = [];
-                            visited[id2] = clone2;
-                            o2.forEach(function(v2, i2) {
-                                clone2[i2] = deepClone(v2, visited);
-                            });
-                            return clone2;
-                        default:
-                            return o2;
-                    }
-                },
-                getLanguage: function(element2) {
-                    while (element2) {
-                        var m2 = lang.exec(element2.className);
-                        if (m2) {
-                            return m2[1].toLowerCase();
-                        }
-                        element2 = element2.parentElement;
-                    }
-                    return "none";
-                },
-                setLanguage: function(element2, language2) {
-                    element2.className = element2.className.replace(RegExp(lang, "gi"), "");
-                    element2.classList.add("language-" + language2);
-                },
-                isActive: function(element2, className, defaultActivation) {
-                    var no = "no-" + className;
-                    while (element2) {
-                        var classList2 = element2.classList;
-                        if (classList2.contains(className)) {
-                            return true;
-                        }
-                        if (classList2.contains(no)) {
-                            return false;
-                        }
-                        element2 = element2.parentElement;
-                    }
-                    return !!defaultActivation;
                 }
-            },
-            languages: {
-                plain: plainTextGrammar,
-                plaintext: plainTextGrammar,
-                text: plainTextGrammar,
-                txt: plainTextGrammar,
-                extend: function(id2, redef) {
-                    var lang2 = _2.util.clone(_2.languages[id2]);
-                    for (var key in redef) {
-                        lang2[key] = redef[key];
-                    }
-                    return lang2;
-                },
-                insertBefore: function(inside2, before, insert2, root2) {
-                    root2 = root2 || _2.languages;
-                    var grammar = root2[inside2];
-                    var ret = {};
-                    for (var token in grammar) {
-                        if (grammar.hasOwnProperty(token)) {
-                            if (token == before) {
-                                for (var newToken in insert2) {
-                                    if (insert2.hasOwnProperty(newToken)) {
-                                        ret[newToken] = insert2[newToken];
-                                    }
-                                }
-                            }
-                            if (!insert2.hasOwnProperty(token)) {
-                                ret[token] = grammar[token];
-                            }
-                        }
-                    }
-                    var old = root2[inside2];
-                    root2[inside2] = ret;
-                    _2.languages.DFS(_2.languages, function(key, value) {
-                        if (value === old && key != inside2) {
-                            this[key] = ret;
-                        }
-                    });
-                    return ret;
-                },
-                DFS: function DFS(o2, callback, type2, visited) {
-                    visited = visited || {};
-                    var objId = _2.util.objId;
-                    for (var i2 in o2) {
-                        if (o2.hasOwnProperty(i2)) {
-                            callback.call(o2, i2, o2[i2], type2 || i2);
-                            var property = o2[i2];
-                            var propertyType = _2.util.type(property);
-                            if (propertyType === "Object" && !visited[objId(property)]) {
-                                visited[objId(property)] = true;
-                                DFS(property, callback, null, visited);
-                            } else if (propertyType === "Array" && !visited[objId(property)]) {
-                                visited[objId(property)] = true;
-                                DFS(property, callback, i2, visited);
-                            }
-                        }
-                    }
+            }
+        }, {
+            key: "validate",
+            value: function validate2(_date, value) {
+                return value >= 0 && value <= 6;
+            }
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value, options) {
+                date = setUTCDay(date, value, options);
+                date.setUTCHours(0, 0, 0, 0);
+                return date;
+            }
+        }]);
+        return DayParser2;
+    }(Parser$2);
+    var LocalDayParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(LocalDayParser2, _Parser);
+        var _super = _createSuper$1(LocalDayParser2);
+
+        function LocalDayParser2() {
+            var _this;
+            _classCallCheck$g(this, LocalDayParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 90);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]);
+            return _this;
+        }
+        _createClass$g(LocalDayParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2, options) {
+                var valueCallback = function valueCallback2(value) {
+                    var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
+                    return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
+                };
+                switch (token) {
+                    case "e":
+                    case "ee":
+                        return mapValue(parseNDigits(token.length, dateString), valueCallback);
+                    case "eo":
+                        return mapValue(match2.ordinalNumber(dateString, {
+                            unit: "day"
+                        }), valueCallback);
+                    case "eee":
+                        return match2.day(dateString, {
+                            width: "abbreviated",
+                            context: "formatting"
+                        }) || match2.day(dateString, {
+                            width: "short",
+                            context: "formatting"
+                        }) || match2.day(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
+                    case "eeeee":
+                        return match2.day(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
+                    case "eeeeee":
+                        return match2.day(dateString, {
+                            width: "short",
+                            context: "formatting"
+                        }) || match2.day(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
+                    case "eeee":
+                    default:
+                        return match2.day(dateString, {
+                            width: "wide",
+                            context: "formatting"
+                        }) || match2.day(dateString, {
+                            width: "abbreviated",
+                            context: "formatting"
+                        }) || match2.day(dateString, {
+                            width: "short",
+                            context: "formatting"
+                        }) || match2.day(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
                 }
-            },
-            plugins: {},
-            highlight: function(text2, grammar, language2) {
-                var env2 = {
-                    code: text2,
-                    grammar,
-                    language: language2
+            }
+        }, {
+            key: "validate",
+            value: function validate2(_date, value) {
+                return value >= 0 && value <= 6;
+            }
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value, options) {
+                date = setUTCDay(date, value, options);
+                date.setUTCHours(0, 0, 0, 0);
+                return date;
+            }
+        }]);
+        return LocalDayParser2;
+    }(Parser$2);
+    var StandAloneLocalDayParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(StandAloneLocalDayParser2, _Parser);
+        var _super = _createSuper$1(StandAloneLocalDayParser2);
+
+        function StandAloneLocalDayParser2() {
+            var _this;
+            _classCallCheck$g(this, StandAloneLocalDayParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 90);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]);
+            return _this;
+        }
+        _createClass$g(StandAloneLocalDayParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2, options) {
+                var valueCallback = function valueCallback2(value) {
+                    var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
+                    return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
                 };
-                _2.hooks.run("before-tokenize", env2);
-                env2.tokens = _2.tokenize(env2.code, env2.grammar);
-                _2.hooks.run("after-tokenize", env2);
-                return Token.stringify(_2.util.encode(env2.tokens), env2.language);
-            },
-            tokenize: function(text2, grammar) {
-                var rest = grammar.rest;
-                if (rest) {
-                    for (var token in rest) {
-                        grammar[token] = rest[token];
-                    }
-                    delete grammar.rest;
+                switch (token) {
+                    case "c":
+                    case "cc":
+                        return mapValue(parseNDigits(token.length, dateString), valueCallback);
+                    case "co":
+                        return mapValue(match2.ordinalNumber(dateString, {
+                            unit: "day"
+                        }), valueCallback);
+                    case "ccc":
+                        return match2.day(dateString, {
+                            width: "abbreviated",
+                            context: "standalone"
+                        }) || match2.day(dateString, {
+                            width: "short",
+                            context: "standalone"
+                        }) || match2.day(dateString, {
+                            width: "narrow",
+                            context: "standalone"
+                        });
+                    case "ccccc":
+                        return match2.day(dateString, {
+                            width: "narrow",
+                            context: "standalone"
+                        });
+                    case "cccccc":
+                        return match2.day(dateString, {
+                            width: "short",
+                            context: "standalone"
+                        }) || match2.day(dateString, {
+                            width: "narrow",
+                            context: "standalone"
+                        });
+                    case "cccc":
+                    default:
+                        return match2.day(dateString, {
+                            width: "wide",
+                            context: "standalone"
+                        }) || match2.day(dateString, {
+                            width: "abbreviated",
+                            context: "standalone"
+                        }) || match2.day(dateString, {
+                            width: "short",
+                            context: "standalone"
+                        }) || match2.day(dateString, {
+                            width: "narrow",
+                            context: "standalone"
+                        });
                 }
-                var tokenList = new LinkedList();
-                addAfter(tokenList, tokenList.head, text2);
-                matchGrammar(text2, tokenList, grammar, tokenList.head, 0);
-                return toArray2(tokenList);
-            },
-            hooks: {
-                all: {},
-                add: function(name2, callback) {
-                    var hooks = _2.hooks.all;
-                    hooks[name2] = hooks[name2] || [];
-                    hooks[name2].push(callback);
-                },
-                run: function(name2, env2) {
-                    var callbacks = _2.hooks.all[name2];
-                    if (!callbacks || !callbacks.length) {
-                        return;
-                    }
-                    for (var i2 = 0, callback; callback = callbacks[i2++];) {
-                        callback(env2);
+            }
+        }, {
+            key: "validate",
+            value: function validate2(_date, value) {
+                return value >= 0 && value <= 6;
+            }
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value, options) {
+                date = setUTCDay(date, value, options);
+                date.setUTCHours(0, 0, 0, 0);
+                return date;
+            }
+        }]);
+        return StandAloneLocalDayParser2;
+    }(Parser$2);
+
+    function setUTCISODay(dirtyDate, dirtyDay) {
+        requiredArgs(2, arguments);
+        var day = toInteger$2(dirtyDay);
+        if (day % 7 === 0) {
+            day = day - 7;
+        }
+        var weekStartsOn = 1;
+        var date = toDate(dirtyDate);
+        var currentDay = date.getUTCDay();
+        var remainder = day % 7;
+        var dayIndex = (remainder + 7) % 7;
+        var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
+        date.setUTCDate(date.getUTCDate() + diff);
+        return date;
+    }
+    var ISODayParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(ISODayParser2, _Parser);
+        var _super = _createSuper$1(ISODayParser2);
+
+        function ISODayParser2() {
+            var _this;
+            _classCallCheck$g(this, ISODayParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 90);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]);
+            return _this;
+        }
+        _createClass$g(ISODayParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                var valueCallback = function valueCallback2(value) {
+                    if (value === 0) {
+                        return 7;
                     }
+                    return value;
+                };
+                switch (token) {
+                    case "i":
+                    case "ii":
+                        return parseNDigits(token.length, dateString);
+                    case "io":
+                        return match2.ordinalNumber(dateString, {
+                            unit: "day"
+                        });
+                    case "iii":
+                        return mapValue(match2.day(dateString, {
+                            width: "abbreviated",
+                            context: "formatting"
+                        }) || match2.day(dateString, {
+                            width: "short",
+                            context: "formatting"
+                        }) || match2.day(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        }), valueCallback);
+                    case "iiiii":
+                        return mapValue(match2.day(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        }), valueCallback);
+                    case "iiiiii":
+                        return mapValue(match2.day(dateString, {
+                            width: "short",
+                            context: "formatting"
+                        }) || match2.day(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        }), valueCallback);
+                    case "iiii":
+                    default:
+                        return mapValue(match2.day(dateString, {
+                            width: "wide",
+                            context: "formatting"
+                        }) || match2.day(dateString, {
+                            width: "abbreviated",
+                            context: "formatting"
+                        }) || match2.day(dateString, {
+                            width: "short",
+                            context: "formatting"
+                        }) || match2.day(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        }), valueCallback);
                 }
-            },
-            Token
-        };
+            }
+        }, {
+            key: "validate",
+            value: function validate2(_date, value) {
+                return value >= 1 && value <= 7;
+            }
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value) {
+                date = setUTCISODay(date, value);
+                date.setUTCHours(0, 0, 0, 0);
+                return date;
+            }
+        }]);
+        return ISODayParser2;
+    }(Parser$2);
+    var AMPMParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(AMPMParser2, _Parser);
+        var _super = _createSuper$1(AMPMParser2);
 
-        function Token(type2, content2, alias, matchedStr) {
-            this.type = type2;
-            this.content = content2;
-            this.alias = alias;
-            this.length = (matchedStr || "").length | 0;
+        function AMPMParser2() {
+            var _this;
+            _classCallCheck$g(this, AMPMParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 80);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
+            return _this;
         }
-        Token.stringify = function stringify2(o2, language2) {
-            if (typeof o2 == "string") {
-                return o2;
+        _createClass$g(AMPMParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                switch (token) {
+                    case "a":
+                    case "aa":
+                    case "aaa":
+                        return match2.dayPeriod(dateString, {
+                            width: "abbreviated",
+                            context: "formatting"
+                        }) || match2.dayPeriod(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
+                    case "aaaaa":
+                        return match2.dayPeriod(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
+                    case "aaaa":
+                    default:
+                        return match2.dayPeriod(dateString, {
+                            width: "wide",
+                            context: "formatting"
+                        }) || match2.dayPeriod(dateString, {
+                            width: "abbreviated",
+                            context: "formatting"
+                        }) || match2.dayPeriod(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
+                }
             }
-            if (Array.isArray(o2)) {
-                var s2 = "";
-                o2.forEach(function(e3) {
-                    s2 += stringify2(e3, language2);
-                });
-                return s2;
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value) {
+                date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
+                return date;
             }
-            var env2 = {
-                type: o2.type,
-                content: stringify2(o2.content, language2),
-                tag: "span",
-                classes: ["token", o2.type],
-                attributes: {},
-                language: language2
-            };
-            var aliases = o2.alias;
-            if (aliases) {
-                if (Array.isArray(aliases)) {
-                    Array.prototype.push.apply(env2.classes, aliases);
-                } else {
-                    env2.classes.push(aliases);
+        }]);
+        return AMPMParser2;
+    }(Parser$2);
+    var AMPMMidnightParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(AMPMMidnightParser2, _Parser);
+        var _super = _createSuper$1(AMPMMidnightParser2);
+
+        function AMPMMidnightParser2() {
+            var _this;
+            _classCallCheck$g(this, AMPMMidnightParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 80);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
+            return _this;
+        }
+        _createClass$g(AMPMMidnightParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                switch (token) {
+                    case "b":
+                    case "bb":
+                    case "bbb":
+                        return match2.dayPeriod(dateString, {
+                            width: "abbreviated",
+                            context: "formatting"
+                        }) || match2.dayPeriod(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
+                    case "bbbbb":
+                        return match2.dayPeriod(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
+                    case "bbbb":
+                    default:
+                        return match2.dayPeriod(dateString, {
+                            width: "wide",
+                            context: "formatting"
+                        }) || match2.dayPeriod(dateString, {
+                            width: "abbreviated",
+                            context: "formatting"
+                        }) || match2.dayPeriod(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
                 }
             }
-            _2.hooks.run("wrap", env2);
-            var attributes2 = "";
-            for (var name2 in env2.attributes) {
-                attributes2 += " " + name2 + '="' + (env2.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value) {
+                date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
+                return date;
             }
-            return "<" + env2.tag + ' class="' + env2.classes.join(" ") + '"' + attributes2 + ">" + env2.content + "</" + env2.tag + ">";
-        };
+        }]);
+        return AMPMMidnightParser2;
+    }(Parser$2);
+    var DayPeriodParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(DayPeriodParser2, _Parser);
+        var _super = _createSuper$1(DayPeriodParser2);
 
-        function matchPattern(pattern, pos, text2, lookbehind) {
-            pattern.lastIndex = pos;
-            var match2 = pattern.exec(text2);
-            if (match2 && lookbehind && match2[1]) {
-                var lookbehindLength = match2[1].length;
-                match2.index += lookbehindLength;
-                match2[0] = match2[0].slice(lookbehindLength);
+        function DayPeriodParser2() {
+            var _this;
+            _classCallCheck$g(this, DayPeriodParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
             }
-            return match2;
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 80);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["a", "b", "t", "T"]);
+            return _this;
         }
+        _createClass$g(DayPeriodParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                switch (token) {
+                    case "B":
+                    case "BB":
+                    case "BBB":
+                        return match2.dayPeriod(dateString, {
+                            width: "abbreviated",
+                            context: "formatting"
+                        }) || match2.dayPeriod(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
+                    case "BBBBB":
+                        return match2.dayPeriod(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
+                    case "BBBB":
+                    default:
+                        return match2.dayPeriod(dateString, {
+                            width: "wide",
+                            context: "formatting"
+                        }) || match2.dayPeriod(dateString, {
+                            width: "abbreviated",
+                            context: "formatting"
+                        }) || match2.dayPeriod(dateString, {
+                            width: "narrow",
+                            context: "formatting"
+                        });
+                }
+            }
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value) {
+                date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
+                return date;
+            }
+        }]);
+        return DayPeriodParser2;
+    }(Parser$2);
+    var Hour1to12Parser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(Hour1to12Parser2, _Parser);
+        var _super = _createSuper$1(Hour1to12Parser2);
 
-        function matchGrammar(text2, tokenList, grammar, startNode, startPos, rematch) {
-            for (var token in grammar) {
-                if (!grammar.hasOwnProperty(token) || !grammar[token]) {
-                    continue;
+        function Hour1to12Parser2() {
+            var _this;
+            _classCallCheck$g(this, Hour1to12Parser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 70);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["H", "K", "k", "t", "T"]);
+            return _this;
+        }
+        _createClass$g(Hour1to12Parser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                switch (token) {
+                    case "h":
+                        return parseNumericPattern(numericPatterns.hour12h, dateString);
+                    case "ho":
+                        return match2.ordinalNumber(dateString, {
+                            unit: "hour"
+                        });
+                    default:
+                        return parseNDigits(token.length, dateString);
                 }
-                var patterns2 = grammar[token];
-                patterns2 = Array.isArray(patterns2) ? patterns2 : [patterns2];
-                for (var j2 = 0; j2 < patterns2.length; ++j2) {
-                    if (rematch && rematch.cause == token + "," + j2) {
-                        return;
-                    }
-                    var patternObj = patterns2[j2];
-                    var inside2 = patternObj.inside;
-                    var lookbehind = !!patternObj.lookbehind;
-                    var greedy = !!patternObj.greedy;
-                    var alias = patternObj.alias;
-                    if (greedy && !patternObj.pattern.global) {
-                        var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
-                        patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
-                    }
-                    var pattern = patternObj.pattern || patternObj;
-                    for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
-                        if (rematch && pos >= rematch.reach) {
-                            break;
-                        }
-                        var str = currentNode.value;
-                        if (tokenList.length > text2.length) {
-                            return;
-                        }
-                        if (str instanceof Token) {
-                            continue;
-                        }
-                        var removeCount = 1;
-                        var match2;
-                        if (greedy) {
-                            match2 = matchPattern(pattern, pos, text2, lookbehind);
-                            if (!match2 || match2.index >= text2.length) {
-                                break;
-                            }
-                            var from = match2.index;
-                            var to2 = match2.index + match2[0].length;
-                            var p2 = pos;
-                            p2 += currentNode.value.length;
-                            while (from >= p2) {
-                                currentNode = currentNode.next;
-                                p2 += currentNode.value.length;
-                            }
-                            p2 -= currentNode.value.length;
-                            pos = p2;
-                            if (currentNode.value instanceof Token) {
-                                continue;
-                            }
-                            for (var k2 = currentNode; k2 !== tokenList.tail && (p2 < to2 || typeof k2.value === "string"); k2 = k2.next) {
-                                removeCount++;
-                                p2 += k2.value.length;
-                            }
-                            removeCount--;
-                            str = text2.slice(pos, p2);
-                            match2.index -= pos;
-                        } else {
-                            match2 = matchPattern(pattern, 0, str, lookbehind);
-                            if (!match2) {
-                                continue;
-                            }
-                        }
-                        var from = match2.index;
-                        var matchStr = match2[0];
-                        var before = str.slice(0, from);
-                        var after = str.slice(from + matchStr.length);
-                        var reach = pos + str.length;
-                        if (rematch && reach > rematch.reach) {
-                            rematch.reach = reach;
-                        }
-                        var removeFrom = currentNode.prev;
-                        if (before) {
-                            removeFrom = addAfter(tokenList, removeFrom, before);
-                            pos += before.length;
-                        }
-                        removeRange(tokenList, removeFrom, removeCount);
-                        var wrapped = new Token(token, inside2 ? _2.tokenize(matchStr, inside2) : matchStr, alias, matchStr);
-                        currentNode = addAfter(tokenList, removeFrom, wrapped);
-                        if (after) {
-                            addAfter(tokenList, currentNode, after);
-                        }
-                        if (removeCount > 1) {
-                            var nestedRematch = {
-                                cause: token + "," + j2,
-                                reach
-                            };
-                            matchGrammar(text2, tokenList, grammar, currentNode.prev, pos, nestedRematch);
-                            if (rematch && nestedRematch.reach > rematch.reach) {
-                                rematch.reach = nestedRematch.reach;
-                            }
-                        }
-                    }
+            }
+        }, {
+            key: "validate",
+            value: function validate2(_date, value) {
+                return value >= 1 && value <= 12;
+            }
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value) {
+                var isPM = date.getUTCHours() >= 12;
+                if (isPM && value < 12) {
+                    date.setUTCHours(value + 12, 0, 0, 0);
+                } else if (!isPM && value === 12) {
+                    date.setUTCHours(0, 0, 0, 0);
+                } else {
+                    date.setUTCHours(value, 0, 0, 0);
                 }
+                return date;
             }
-        }
+        }]);
+        return Hour1to12Parser2;
+    }(Parser$2);
+    var Hour0to23Parser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(Hour0to23Parser2, _Parser);
+        var _super = _createSuper$1(Hour0to23Parser2);
 
-        function LinkedList() {
-            var head = {
-                value: null,
-                prev: null,
-                next: null
-            };
-            var tail = {
-                value: null,
-                prev: head,
-                next: null
-            };
-            head.next = tail;
-            this.head = head;
-            this.tail = tail;
-            this.length = 0;
+        function Hour0to23Parser2() {
+            var _this;
+            _classCallCheck$g(this, Hour0to23Parser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 70);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
+            return _this;
         }
+        _createClass$g(Hour0to23Parser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                switch (token) {
+                    case "H":
+                        return parseNumericPattern(numericPatterns.hour23h, dateString);
+                    case "Ho":
+                        return match2.ordinalNumber(dateString, {
+                            unit: "hour"
+                        });
+                    default:
+                        return parseNDigits(token.length, dateString);
+                }
+            }
+        }, {
+            key: "validate",
+            value: function validate2(_date, value) {
+                return value >= 0 && value <= 23;
+            }
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value) {
+                date.setUTCHours(value, 0, 0, 0);
+                return date;
+            }
+        }]);
+        return Hour0to23Parser2;
+    }(Parser$2);
+    var Hour0To11Parser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(Hour0To11Parser2, _Parser);
+        var _super = _createSuper$1(Hour0To11Parser2);
 
-        function addAfter(list2, node2, value) {
-            var next2 = node2.next;
-            var newNode = {
-                value,
-                prev: node2,
-                next: next2
-            };
-            node2.next = newNode;
-            next2.prev = newNode;
-            list2.length++;
-            return newNode;
+        function Hour0To11Parser2() {
+            var _this;
+            _classCallCheck$g(this, Hour0To11Parser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 70);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["h", "H", "k", "t", "T"]);
+            return _this;
         }
+        _createClass$g(Hour0To11Parser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                switch (token) {
+                    case "K":
+                        return parseNumericPattern(numericPatterns.hour11h, dateString);
+                    case "Ko":
+                        return match2.ordinalNumber(dateString, {
+                            unit: "hour"
+                        });
+                    default:
+                        return parseNDigits(token.length, dateString);
+                }
+            }
+        }, {
+            key: "validate",
+            value: function validate2(_date, value) {
+                return value >= 0 && value <= 11;
+            }
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value) {
+                var isPM = date.getUTCHours() >= 12;
+                if (isPM && value < 12) {
+                    date.setUTCHours(value + 12, 0, 0, 0);
+                } else {
+                    date.setUTCHours(value, 0, 0, 0);
+                }
+                return date;
+            }
+        }]);
+        return Hour0To11Parser2;
+    }(Parser$2);
+    var Hour1To24Parser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(Hour1To24Parser2, _Parser);
+        var _super = _createSuper$1(Hour1To24Parser2);
 
-        function removeRange(list2, node2, count2) {
-            var next2 = node2.next;
-            for (var i2 = 0; i2 < count2 && next2 !== list2.tail; i2++) {
-                next2 = next2.next;
+        function Hour1To24Parser2() {
+            var _this;
+            _classCallCheck$g(this, Hour1To24Parser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
             }
-            node2.next = next2;
-            next2.prev = node2;
-            list2.length -= i2;
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 70);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
+            return _this;
         }
+        _createClass$g(Hour1To24Parser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                switch (token) {
+                    case "k":
+                        return parseNumericPattern(numericPatterns.hour24h, dateString);
+                    case "ko":
+                        return match2.ordinalNumber(dateString, {
+                            unit: "hour"
+                        });
+                    default:
+                        return parseNDigits(token.length, dateString);
+                }
+            }
+        }, {
+            key: "validate",
+            value: function validate2(_date, value) {
+                return value >= 1 && value <= 24;
+            }
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value) {
+                var hours = value <= 24 ? value % 24 : value;
+                date.setUTCHours(hours, 0, 0, 0);
+                return date;
+            }
+        }]);
+        return Hour1To24Parser2;
+    }(Parser$2);
+    var MinuteParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(MinuteParser2, _Parser);
+        var _super = _createSuper$1(MinuteParser2);
 
-        function toArray2(list2) {
-            var array2 = [];
-            var node2 = list2.head.next;
-            while (node2 !== list2.tail) {
-                array2.push(node2.value);
-                node2 = node2.next;
+        function MinuteParser2() {
+            var _this;
+            _classCallCheck$g(this, MinuteParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
             }
-            return array2;
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 60);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["t", "T"]);
+            return _this;
         }
-        return _2;
-    }();
-    var prism = Prism;
-    Prism.default = Prism;
-    prism.languages.markup = {
-        "comment": {
-            pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
-            greedy: true
-        },
-        "prolog": {
-            pattern: /<\?[\s\S]+?\?>/,
-            greedy: true
-        },
-        "doctype": {
-            pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
-            greedy: true,
-            inside: {
-                "internal-subset": {
-                    pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
-                    lookbehind: true,
-                    greedy: true,
-                    inside: null
-                },
-                "string": {
-                    pattern: /"[^"]*"|'[^']*'/,
-                    greedy: true
-                },
-                "punctuation": /^<!|>$|[[\]]/,
-                "doctype-tag": /^DOCTYPE/i,
-                "name": /[^\s<>'"]+/
+        _createClass$g(MinuteParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                switch (token) {
+                    case "m":
+                        return parseNumericPattern(numericPatterns.minute, dateString);
+                    case "mo":
+                        return match2.ordinalNumber(dateString, {
+                            unit: "minute"
+                        });
+                    default:
+                        return parseNDigits(token.length, dateString);
+                }
             }
-        },
-        "cdata": {
-            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
-            greedy: true
-        },
-        "tag": {
-            pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
-            greedy: true,
-            inside: {
-                "tag": {
-                    pattern: /^<\/?[^\s>\/]+/,
-                    inside: {
-                        "punctuation": /^<\/?/,
-                        "namespace": /^[^\s>\/:]+:/
-                    }
-                },
-                "special-attr": [],
-                "attr-value": {
-                    pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
-                    inside: {
-                        "punctuation": [{
-                            pattern: /^=/,
-                            alias: "attr-equals"
-                        }, /"|'/]
-                    }
-                },
-                "punctuation": /\/?>/,
-                "attr-name": {
-                    pattern: /[^\s>\/]+/,
-                    inside: {
-                        "namespace": /^[^\s>\/:]+:/
-                    }
+        }, {
+            key: "validate",
+            value: function validate2(_date, value) {
+                return value >= 0 && value <= 59;
+            }
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value) {
+                date.setUTCMinutes(value, 0, 0);
+                return date;
+            }
+        }]);
+        return MinuteParser2;
+    }(Parser$2);
+    var SecondParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(SecondParser2, _Parser);
+        var _super = _createSuper$1(SecondParser2);
+
+        function SecondParser2() {
+            var _this;
+            _classCallCheck$g(this, SecondParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 50);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["t", "T"]);
+            return _this;
+        }
+        _createClass$g(SecondParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token, match2) {
+                switch (token) {
+                    case "s":
+                        return parseNumericPattern(numericPatterns.second, dateString);
+                    case "so":
+                        return match2.ordinalNumber(dateString, {
+                            unit: "second"
+                        });
+                    default:
+                        return parseNDigits(token.length, dateString);
                 }
             }
-        },
-        "entity": [{
-            pattern: /&[\da-z]{1,8};/i,
-            alias: "named-entity"
-        }, /&#x?[\da-f]{1,8};/i]
-    };
-    prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = prism.languages.markup["entity"];
-    prism.languages.markup["doctype"].inside["internal-subset"].inside = prism.languages.markup;
-    prism.hooks.add("wrap", function(env2) {
-        if (env2.type === "entity") {
-            env2.attributes["title"] = env2.content.replace(/&amp;/, "&");
+        }, {
+            key: "validate",
+            value: function validate2(_date, value) {
+                return value >= 0 && value <= 59;
+            }
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value) {
+                date.setUTCSeconds(value, 0);
+                return date;
+            }
+        }]);
+        return SecondParser2;
+    }(Parser$2);
+    var FractionOfSecondParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(FractionOfSecondParser2, _Parser);
+        var _super = _createSuper$1(FractionOfSecondParser2);
+
+        function FractionOfSecondParser2() {
+            var _this;
+            _classCallCheck$g(this, FractionOfSecondParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 30);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["t", "T"]);
+            return _this;
         }
-    });
-    Object.defineProperty(prism.languages.markup.tag, "addInlined", {
-        value: function addInlined(tagName, lang) {
-            var includedCdataInside = {};
-            includedCdataInside["language-" + lang] = {
-                pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
-                lookbehind: true,
-                inside: prism.languages[lang]
-            };
-            includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
-            var inside2 = {
-                "included-cdata": {
-                    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
-                    inside: includedCdataInside
+        _createClass$g(FractionOfSecondParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token) {
+                var valueCallback = function valueCallback2(value) {
+                    return Math.floor(value * Math.pow(10, -token.length + 3));
+                };
+                return mapValue(parseNDigits(token.length, dateString), valueCallback);
+            }
+        }, {
+            key: "set",
+            value: function set2(date, _flags, value) {
+                date.setUTCMilliseconds(value);
+                return date;
+            }
+        }]);
+        return FractionOfSecondParser2;
+    }(Parser$2);
+    var ISOTimezoneWithZParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(ISOTimezoneWithZParser2, _Parser);
+        var _super = _createSuper$1(ISOTimezoneWithZParser2);
+
+        function ISOTimezoneWithZParser2() {
+            var _this;
+            _classCallCheck$g(this, ISOTimezoneWithZParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 10);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["t", "T", "x"]);
+            return _this;
+        }
+        _createClass$g(ISOTimezoneWithZParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token) {
+                switch (token) {
+                    case "X":
+                        return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
+                    case "XX":
+                        return parseTimezonePattern(timezonePatterns.basic, dateString);
+                    case "XXXX":
+                        return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
+                    case "XXXXX":
+                        return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
+                    case "XXX":
+                    default:
+                        return parseTimezonePattern(timezonePatterns.extended, dateString);
                 }
-            };
-            inside2["language-" + lang] = {
-                pattern: /[\s\S]+/,
-                inside: prism.languages[lang]
-            };
-            var def = {};
-            def[tagName] = {
-                pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
-                    return tagName;
-                }), "i"),
-                lookbehind: true,
-                greedy: true,
-                inside: inside2
-            };
-            prism.languages.insertBefore("markup", "cdata", def);
+            }
+        }, {
+            key: "set",
+            value: function set2(date, flags, value) {
+                if (flags.timestampIsSet) {
+                    return date;
+                }
+                return new Date(date.getTime() - value);
+            }
+        }]);
+        return ISOTimezoneWithZParser2;
+    }(Parser$2);
+    var ISOTimezoneParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(ISOTimezoneParser2, _Parser);
+        var _super = _createSuper$1(ISOTimezoneParser2);
+
+        function ISOTimezoneParser2() {
+            var _this;
+            _classCallCheck$g(this, ISOTimezoneParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 10);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", ["t", "T", "X"]);
+            return _this;
         }
-    });
-    Object.defineProperty(prism.languages.markup.tag, "addAttribute", {
-        value: function(attrName, lang) {
-            prism.languages.markup.tag.inside["special-attr"].push({
-                pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
-                lookbehind: true,
-                inside: {
-                    "attr-name": /^[^\s=]+/,
-                    "attr-value": {
-                        pattern: /=[\s\S]+/,
-                        inside: {
-                            "value": {
-                                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
-                                lookbehind: true,
-                                alias: [lang, "language-" + lang],
-                                inside: prism.languages[lang]
-                            },
-                            "punctuation": [{
-                                pattern: /^=/,
-                                alias: "attr-equals"
-                            }, /"|'/]
-                        }
-                    }
+        _createClass$g(ISOTimezoneParser2, [{
+            key: "parse",
+            value: function parse2(dateString, token) {
+                switch (token) {
+                    case "x":
+                        return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
+                    case "xx":
+                        return parseTimezonePattern(timezonePatterns.basic, dateString);
+                    case "xxxx":
+                        return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
+                    case "xxxxx":
+                        return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
+                    case "xxx":
+                    default:
+                        return parseTimezonePattern(timezonePatterns.extended, dateString);
                 }
-            });
+            }
+        }, {
+            key: "set",
+            value: function set2(date, flags, value) {
+                if (flags.timestampIsSet) {
+                    return date;
+                }
+                return new Date(date.getTime() - value);
+            }
+        }]);
+        return ISOTimezoneParser2;
+    }(Parser$2);
+    var TimestampSecondsParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(TimestampSecondsParser2, _Parser);
+        var _super = _createSuper$1(TimestampSecondsParser2);
+
+        function TimestampSecondsParser2() {
+            var _this;
+            _classCallCheck$g(this, TimestampSecondsParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 40);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", "*");
+            return _this;
         }
-    });
-    prism.languages.html = prism.languages.markup;
-    prism.languages.mathml = prism.languages.markup;
-    prism.languages.svg = prism.languages.markup;
-    prism.languages.xml = prism.languages.extend("markup", {});
-    prism.languages.ssml = prism.languages.xml;
-    prism.languages.atom = prism.languages.xml;
-    prism.languages.rss = prism.languages.xml;
-    (function(Prism2) {
-        var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
-        var commandAfterHeredoc = {
-            pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
-            lookbehind: true,
-            alias: "punctuation",
-            inside: null
+        _createClass$g(TimestampSecondsParser2, [{
+            key: "parse",
+            value: function parse2(dateString) {
+                return parseAnyDigitsSigned(dateString);
+            }
+        }, {
+            key: "set",
+            value: function set2(_date, _flags, value) {
+                return [new Date(value * 1e3), {
+                    timestampIsSet: true
+                }];
+            }
+        }]);
+        return TimestampSecondsParser2;
+    }(Parser$2);
+    var TimestampMillisecondsParser = /* @__PURE__ */ function(_Parser) {
+        _inherits$1(TimestampMillisecondsParser2, _Parser);
+        var _super = _createSuper$1(TimestampMillisecondsParser2);
+
+        function TimestampMillisecondsParser2() {
+            var _this;
+            _classCallCheck$g(this, TimestampMillisecondsParser2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _defineProperty$o(_assertThisInitialized$3(_this), "priority", 20);
+            _defineProperty$o(_assertThisInitialized$3(_this), "incompatibleTokens", "*");
+            return _this;
+        }
+        _createClass$g(TimestampMillisecondsParser2, [{
+            key: "parse",
+            value: function parse2(dateString) {
+                return parseAnyDigitsSigned(dateString);
+            }
+        }, {
+            key: "set",
+            value: function set2(_date, _flags, value) {
+                return [new Date(value), {
+                    timestampIsSet: true
+                }];
+            }
+        }]);
+        return TimestampMillisecondsParser2;
+    }(Parser$2);
+    var parsers = {
+        G: new EraParser(),
+        y: new YearParser(),
+        Y: new LocalWeekYearParser(),
+        R: new ISOWeekYearParser(),
+        u: new ExtendedYearParser(),
+        Q: new QuarterParser(),
+        q: new StandAloneQuarterParser(),
+        M: new MonthParser(),
+        L: new StandAloneMonthParser(),
+        w: new LocalWeekParser(),
+        I: new ISOWeekParser(),
+        d: new DateParser(),
+        D: new DayOfYearParser(),
+        E: new DayParser(),
+        e: new LocalDayParser(),
+        c: new StandAloneLocalDayParser(),
+        i: new ISODayParser(),
+        a: new AMPMParser(),
+        b: new AMPMMidnightParser(),
+        B: new DayPeriodParser(),
+        h: new Hour1to12Parser(),
+        H: new Hour0to23Parser(),
+        K: new Hour0To11Parser(),
+        k: new Hour1To24Parser(),
+        m: new MinuteParser(),
+        s: new SecondParser(),
+        S: new FractionOfSecondParser(),
+        X: new ISOTimezoneWithZParser(),
+        x: new ISOTimezoneParser(),
+        t: new TimestampSecondsParser(),
+        T: new TimestampMillisecondsParser()
+    };
+    var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
+    var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
+    var escapedStringRegExp = /^'([^]*?)'?$/;
+    var doubleQuoteRegExp = /''/g;
+    var notWhitespaceRegExp = /\S/;
+    var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
+
+    function parse$5(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
+        var _ref2, _options$locale, _ref22, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
+        requiredArgs(3, arguments);
+        var dateString = String(dirtyDateString);
+        var formatString = String(dirtyFormatString);
+        var defaultOptions2 = getDefaultOptions();
+        var locale2 = (_ref2 = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref2 !== void 0 ? _ref2 : defaultLocale;
+        if (!locale2.match) {
+            throw new RangeError("locale must contain match property");
+        }
+        var firstWeekContainsDate = toInteger$2((_ref22 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref22 !== void 0 ? _ref22 : 1);
+        if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
+            throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
+        }
+        var weekStartsOn = toInteger$2((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
+        if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
+            throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
+        }
+        if (formatString === "") {
+            if (dateString === "") {
+                return toDate(dirtyReferenceDate);
+            } else {
+                return new Date(NaN);
+            }
+        }
+        var subFnOptions = {
+            firstWeekContainsDate,
+            weekStartsOn,
+            locale: locale2
         };
-        var insideString = {
-            "bash": commandAfterHeredoc,
-            "environment": {
-                pattern: RegExp("\\$" + envVars),
-                alias: "constant"
-            },
-            "variable": [{
-                    pattern: /\$?\(\([\s\S]+?\)\)/,
-                    greedy: true,
-                    inside: {
-                        "variable": [{
-                            pattern: /(^\$\(\([\s\S]+)\)\)/,
-                            lookbehind: true
-                        }, /^\$\(\(/],
-                        "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
-                        "operator": /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
-                        "punctuation": /\(\(?|\)\)?|,|;/
+        var setters = [new DateToSystemTimezoneSetter()];
+        var tokens2 = formatString.match(longFormattingTokensRegExp).map(function(substring) {
+            var firstCharacter = substring[0];
+            if (firstCharacter in longFormatters$1) {
+                var longFormatter = longFormatters$1[firstCharacter];
+                return longFormatter(substring, locale2.formatLong);
+            }
+            return substring;
+        }).join("").match(formattingTokensRegExp);
+        var usedTokens = [];
+        var _iterator = _createForOfIteratorHelper(tokens2),
+            _step;
+        try {
+            var _loop = function _loop2() {
+                var token = _step.value;
+                if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
+                    throwProtectedError(token, formatString, dirtyDateString);
+                }
+                if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
+                    throwProtectedError(token, formatString, dirtyDateString);
+                }
+                var firstCharacter = token[0];
+                var parser2 = parsers[firstCharacter];
+                if (parser2) {
+                    var incompatibleTokens = parser2.incompatibleTokens;
+                    if (Array.isArray(incompatibleTokens)) {
+                        var incompatibleToken = usedTokens.find(function(usedToken) {
+                            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
+                        });
+                        if (incompatibleToken) {
+                            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
+                        }
+                    } else if (parser2.incompatibleTokens === "*" && usedTokens.length > 0) {
+                        throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
                     }
-                }, {
-                    pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
-                    greedy: true,
-                    inside: {
-                        "variable": /^\$\(|^`|\)$|`$/
+                    usedTokens.push({
+                        token: firstCharacter,
+                        fullToken: token
+                    });
+                    var parseResult = parser2.run(dateString, token, locale2.match, subFnOptions);
+                    if (!parseResult) {
+                        return {
+                            v: new Date(NaN)
+                        };
                     }
-                }, {
-                    pattern: /\$\{[^}]+\}/,
-                    greedy: true,
-                    inside: {
-                        "operator": /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
-                        "punctuation": /[\[\]]/,
-                        "environment": {
-                            pattern: RegExp("(\\{)" + envVars),
-                            lookbehind: true,
-                            alias: "constant"
-                        }
+                    setters.push(parseResult.setter);
+                    dateString = parseResult.rest;
+                } else {
+                    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
+                        throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
                     }
-                },
-                /\$(?:\w+|[#?*!@$])/
-            ],
-            "entity": /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
-        };
-        Prism2.languages.bash = {
-            "shebang": {
-                pattern: /^#!\s*\/.*/,
-                alias: "important"
-            },
-            "comment": {
-                pattern: /(^|[^"{\\$])#.*/,
-                lookbehind: true
-            },
-            "function-name": [{
-                pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
-                lookbehind: true,
-                alias: "function"
-            }, {
-                pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
-                alias: "function"
-            }],
-            "for-or-select": {
-                pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
-                alias: "variable",
-                lookbehind: true
-            },
-            "assign-left": {
-                pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,
-                inside: {
-                    "environment": {
-                        pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
-                        lookbehind: true,
-                        alias: "constant"
+                    if (token === "''") {
+                        token = "'";
+                    } else if (firstCharacter === "'") {
+                        token = cleanEscapedString(token);
+                    }
+                    if (dateString.indexOf(token) === 0) {
+                        dateString = dateString.slice(token.length);
+                    } else {
+                        return {
+                            v: new Date(NaN)
+                        };
                     }
-                },
-                alias: "variable",
-                lookbehind: true
-            },
-            "string": [{
-                pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
-                lookbehind: true,
-                greedy: true,
-                inside: insideString
-            }, {
-                pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
-                lookbehind: true,
-                greedy: true,
-                inside: {
-                    "bash": commandAfterHeredoc
                 }
-            }, {
-                pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
-                lookbehind: true,
-                greedy: true,
-                inside: insideString
-            }, {
-                pattern: /(^|[^$\\])'[^']*'/,
-                lookbehind: true,
-                greedy: true
-            }, {
-                pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
-                greedy: true,
-                inside: {
-                    "entity": insideString.entity
+            };
+            for (_iterator.s(); !(_step = _iterator.n()).done;) {
+                var _ret = _loop();
+                if (_typeof$5(_ret) === "object")
+                    return _ret.v;
+            }
+        } catch (err) {
+            _iterator.e(err);
+        } finally {
+            _iterator.f();
+        }
+        if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
+            return new Date(NaN);
+        }
+        var uniquePrioritySetters = setters.map(function(setter2) {
+            return setter2.priority;
+        }).sort(function(a2, b2) {
+            return b2 - a2;
+        }).filter(function(priority, index2, array2) {
+            return array2.indexOf(priority) === index2;
+        }).map(function(priority) {
+            return setters.filter(function(setter2) {
+                return setter2.priority === priority;
+            }).sort(function(a2, b2) {
+                return b2.subPriority - a2.subPriority;
+            });
+        }).map(function(setterArray) {
+            return setterArray[0];
+        });
+        var date = toDate(dirtyReferenceDate);
+        if (isNaN(date.getTime())) {
+            return new Date(NaN);
+        }
+        var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
+        var flags = {};
+        var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters),
+            _step2;
+        try {
+            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
+                var setter = _step2.value;
+                if (!setter.validate(utcDate, subFnOptions)) {
+                    return new Date(NaN);
                 }
-            }],
-            "environment": {
-                pattern: RegExp("\\$?" + envVars),
-                alias: "constant"
-            },
-            "variable": insideString.variable,
-            "function": {
-                pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
-                lookbehind: true
-            },
-            "keyword": {
-                pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
-                lookbehind: true
-            },
-            "builtin": {
-                pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
-                lookbehind: true,
-                alias: "class-name"
-            },
-            "boolean": {
-                pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
-                lookbehind: true
-            },
-            "file-descriptor": {
-                pattern: /\B&\d\b/,
-                alias: "important"
-            },
-            "operator": {
-                pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
-                inside: {
-                    "file-descriptor": {
-                        pattern: /^\d/,
-                        alias: "important"
-                    }
+                var result = setter.set(utcDate, flags, subFnOptions);
+                if (Array.isArray(result)) {
+                    utcDate = result[0];
+                    assign$5(flags, result[1]);
+                } else {
+                    utcDate = result;
                 }
-            },
-            "punctuation": /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
-            "number": {
-                pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
-                lookbehind: true
             }
-        };
-        commandAfterHeredoc.inside = Prism2.languages.bash;
-        var toBeCopied = ["comment", "function-name", "for-or-select", "assign-left", "string", "environment", "function", "keyword", "builtin", "boolean", "file-descriptor", "operator", "punctuation", "number"];
-        var inside2 = insideString.variable[1].inside;
-        for (var i2 = 0; i2 < toBeCopied.length; i2++) {
-            inside2[toBeCopied[i2]] = Prism2.languages.bash[toBeCopied[i2]];
+        } catch (err) {
+            _iterator2.e(err);
+        } finally {
+            _iterator2.f();
         }
-        Prism2.languages.shell = Prism2.languages.bash;
-    })(prism);
-    prism.languages.clike = {
-        "comment": [{
-            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
-            lookbehind: true,
-            greedy: true
-        }, {
-            pattern: /(^|[^\\:])\/\/.*/,
-            lookbehind: true,
-            greedy: true
-        }],
-        "string": {
-            pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
-            greedy: true
-        },
-        "class-name": {
-            pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
-            lookbehind: true,
-            inside: {
-                "punctuation": /[.\\]/
+        return utcDate;
+    }
+
+    function cleanEscapedString(input) {
+        return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
+    }
+
+    function parseISO(argument, options) {
+        var _options$additionalDi;
+        requiredArgs(1, arguments);
+        var additionalDigits = toInteger$2((_options$additionalDi = options === null || options === void 0 ? void 0 : options.additionalDigits) !== null && _options$additionalDi !== void 0 ? _options$additionalDi : 2);
+        if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
+            throw new RangeError("additionalDigits must be 0, 1 or 2");
+        }
+        if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
+            return new Date(NaN);
+        }
+        var dateStrings = splitDateString(argument);
+        var date;
+        if (dateStrings.date) {
+            var parseYearResult = parseYear(dateStrings.date, additionalDigits);
+            date = parseDate(parseYearResult.restDateString, parseYearResult.year);
+        }
+        if (!date || isNaN(date.getTime())) {
+            return new Date(NaN);
+        }
+        var timestamp = date.getTime();
+        var time = 0;
+        var offset2;
+        if (dateStrings.time) {
+            time = parseTime(dateStrings.time);
+            if (isNaN(time)) {
+                return new Date(NaN);
             }
-        },
-        "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
-        "boolean": /\b(?:false|true)\b/,
-        "function": /\b\w+(?=\()/,
-        "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
-        "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
-        "punctuation": /[{}[\];(),.:]/
+        }
+        if (dateStrings.timezone) {
+            offset2 = parseTimezone(dateStrings.timezone);
+            if (isNaN(offset2)) {
+                return new Date(NaN);
+            }
+        } else {
+            var dirtyDate = new Date(timestamp + time);
+            var result = new Date(0);
+            result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
+            result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
+            return result;
+        }
+        return new Date(timestamp + time + offset2);
+    }
+    var patterns = {
+        dateTimeDelimiter: /[T ]/,
+        timeZoneDelimiter: /[Z ]/i,
+        timezone: /([Z+-].*)$/
     };
-    prism.languages.c = prism.languages.extend("clike", {
-        "comment": {
-            pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
-            greedy: true
-        },
-        "string": {
-            pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
-            greedy: true
-        },
-        "class-name": {
-            pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
-            lookbehind: true
-        },
-        "keyword": /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
-        "function": /\b[a-z_]\w*(?=\s*\()/i,
-        "number": /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
-        "operator": />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
-    });
-    prism.languages.insertBefore("c", "string", {
-        "char": {
-            pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
-            greedy: true
+    var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
+    var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
+    var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
+
+    function splitDateString(dateString) {
+        var dateStrings = {};
+        var array2 = dateString.split(patterns.dateTimeDelimiter);
+        var timeString;
+        if (array2.length > 2) {
+            return dateStrings;
         }
-    });
-    prism.languages.insertBefore("c", "string", {
-        "macro": {
-            pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
-            lookbehind: true,
-            greedy: true,
-            alias: "property",
-            inside: {
-                "string": [{
-                    pattern: /^(#\s*include\s*)<[^>]+>/,
-                    lookbehind: true
-                }, prism.languages.c["string"]],
-                "char": prism.languages.c["char"],
-                "comment": prism.languages.c["comment"],
-                "macro-name": [{
-                    pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
-                    lookbehind: true
-                }, {
-                    pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
-                    lookbehind: true,
-                    alias: "function"
-                }],
-                "directive": {
-                    pattern: /^(#\s*)[a-z]+/,
-                    lookbehind: true,
-                    alias: "keyword"
-                },
-                "directive-hash": /^#/,
-                "punctuation": /##|\\(?=[\r\n])/,
-                "expression": {
-                    pattern: /\S[\s\S]*/,
-                    inside: prism.languages.c
-                }
+        if (/:/.test(array2[0])) {
+            timeString = array2[0];
+        } else {
+            dateStrings.date = array2[0];
+            timeString = array2[1];
+            if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
+                dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
+                timeString = dateString.substr(dateStrings.date.length, dateString.length);
             }
         }
-    });
-    prism.languages.insertBefore("c", "function", {
-        "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
-    });
-    delete prism.languages.c["boolean"];
-    (function(Prism2) {
-        var keyword2 = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
-        var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
-            return keyword2.source;
-        });
-        Prism2.languages.cpp = Prism2.languages.extend("c", {
-            "class-name": [{
-                    pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
-                        return keyword2.source;
-                    })),
-                    lookbehind: true
-                },
-                /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
-                /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
-                /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
-            ],
-            "keyword": keyword2,
-            "number": {
-                pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
-                greedy: true
-            },
-            "operator": />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
-            "boolean": /\b(?:false|true)\b/
-        });
-        Prism2.languages.insertBefore("cpp", "string", {
-            "module": {
-                pattern: RegExp(/(\b(?:import|module)\s+)/.source + "(?:" + /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
-                    return modName;
-                }) + ")"),
-                lookbehind: true,
-                greedy: true,
-                inside: {
-                    "string": /^[<"][\s\S]+/,
-                    "operator": /:/,
-                    "punctuation": /\./
-                }
-            },
-            "raw-string": {
-                pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
-                alias: "string",
-                greedy: true
+        if (timeString) {
+            var token = patterns.timezone.exec(timeString);
+            if (token) {
+                dateStrings.time = timeString.replace(token[1], "");
+                dateStrings.timezone = token[1];
+            } else {
+                dateStrings.time = timeString;
             }
-        });
-        Prism2.languages.insertBefore("cpp", "keyword", {
-            "generic-function": {
-                pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
-                inside: {
-                    "function": /^\w+/,
-                    "generic": {
-                        pattern: /<[\s\S]+/,
-                        alias: "class-name",
-                        inside: Prism2.languages.cpp
-                    }
-                }
+        }
+        return dateStrings;
+    }
+
+    function parseYear(dateString, additionalDigits) {
+        var regex = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
+        var captures = dateString.match(regex);
+        if (!captures)
+            return {
+                year: NaN,
+                restDateString: ""
+            };
+        var year = captures[1] ? parseInt(captures[1]) : null;
+        var century = captures[2] ? parseInt(captures[2]) : null;
+        return {
+            year: century === null ? year : century * 100,
+            restDateString: dateString.slice((captures[1] || captures[2]).length)
+        };
+    }
+
+    function parseDate(dateString, year) {
+        if (year === null)
+            return new Date(NaN);
+        var captures = dateString.match(dateRegex);
+        if (!captures)
+            return new Date(NaN);
+        var isWeekDate = !!captures[4];
+        var dayOfYear = parseDateUnit(captures[1]);
+        var month = parseDateUnit(captures[2]) - 1;
+        var day = parseDateUnit(captures[3]);
+        var week = parseDateUnit(captures[4]);
+        var dayOfWeek = parseDateUnit(captures[5]) - 1;
+        if (isWeekDate) {
+            if (!validateWeekDate(year, week, dayOfWeek)) {
+                return new Date(NaN);
             }
-        });
-        Prism2.languages.insertBefore("cpp", "operator", {
-            "double-colon": {
-                pattern: /::/,
-                alias: "punctuation"
+            return dayOfISOWeekYear(year, week, dayOfWeek);
+        } else {
+            var date = new Date(0);
+            if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
+                return new Date(NaN);
             }
-        });
-        Prism2.languages.insertBefore("cpp", "class-name", {
-            "base-clause": {
-                pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
-                lookbehind: true,
-                greedy: true,
-                inside: Prism2.languages.extend("cpp", {})
+            date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
+            return date;
+        }
+    }
+
+    function parseDateUnit(value) {
+        return value ? parseInt(value) : 1;
+    }
+
+    function parseTime(timeString) {
+        var captures = timeString.match(timeRegex);
+        if (!captures)
+            return NaN;
+        var hours = parseTimeUnit(captures[1]);
+        var minutes = parseTimeUnit(captures[2]);
+        var seconds = parseTimeUnit(captures[3]);
+        if (!validateTime(hours, minutes, seconds)) {
+            return NaN;
+        }
+        return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1e3;
+    }
+
+    function parseTimeUnit(value) {
+        return value && parseFloat(value.replace(",", ".")) || 0;
+    }
+
+    function parseTimezone(timezoneString) {
+        if (timezoneString === "Z")
+            return 0;
+        var captures = timezoneString.match(timezoneRegex);
+        if (!captures)
+            return 0;
+        var sign2 = captures[1] === "+" ? -1 : 1;
+        var hours = parseInt(captures[2]);
+        var minutes = captures[3] && parseInt(captures[3]) || 0;
+        if (!validateTimezone(hours, minutes)) {
+            return NaN;
+        }
+        return sign2 * (hours * millisecondsInHour + minutes * millisecondsInMinute);
+    }
+
+    function dayOfISOWeekYear(isoWeekYear, week, day) {
+        var date = new Date(0);
+        date.setUTCFullYear(isoWeekYear, 0, 4);
+        var fourthOfJanuaryDay = date.getUTCDay() || 7;
+        var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
+        date.setUTCDate(date.getUTCDate() + diff);
+        return date;
+    }
+    var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
+
+    function isLeapYearIndex(year) {
+        return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
+    }
+
+    function validateDate(year, month, date) {
+        return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
+    }
+
+    function validateDayOfYearDate(year, dayOfYear) {
+        return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
+    }
+
+    function validateWeekDate(_year, week, day) {
+        return week >= 1 && week <= 53 && day >= 0 && day <= 6;
+    }
+
+    function validateTime(hours, minutes, seconds) {
+        if (hours === 24) {
+            return minutes === 0 && seconds === 0;
+        }
+        return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
+    }
+
+    function validateTimezone(_hours, minutes) {
+        return minutes >= 0 && minutes <= 59;
+    }
+
+    function _inheritsLoose$1(subClass, superClass) {
+        subClass.prototype = Object.create(superClass.prototype);
+        subClass.prototype.constructor = subClass;
+        _setPrototypeOf$2(subClass, superClass);
+    }
+
+    function _setPrototypeOf$2(o2, p2) {
+        _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
+            o3.__proto__ = p3;
+            return o3;
+        };
+        return _setPrototypeOf$2(o2, p2);
+    }
+
+    function _objectWithoutPropertiesLoose$3(source, excluded) {
+        if (source == null)
+            return {};
+        var target = {};
+        var sourceKeys = Object.keys(source);
+        var key, i2;
+        for (i2 = 0; i2 < sourceKeys.length; i2++) {
+            key = sourceKeys[i2];
+            if (excluded.indexOf(key) >= 0)
+                continue;
+            target[key] = source[key];
+        }
+        return target;
+    }
+
+    function _assertThisInitialized$2(self2) {
+        if (self2 === void 0) {
+            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
+        }
+        return self2;
+    }
+
+    function isNodeFound(current2, componentNode, ignoreClass) {
+        if (current2 === componentNode) {
+            return true;
+        }
+        if (current2.correspondingElement) {
+            return current2.correspondingElement.classList.contains(ignoreClass);
+        }
+        return current2.classList.contains(ignoreClass);
+    }
+
+    function findHighest(current2, componentNode, ignoreClass) {
+        if (current2 === componentNode) {
+            return true;
+        }
+        while (current2.parentNode || current2.host) {
+            if (current2.parentNode && isNodeFound(current2, componentNode, ignoreClass)) {
+                return true;
+            }
+            current2 = current2.parentNode || current2.host;
+        }
+        return current2;
+    }
+
+    function clickedScrollbar(evt) {
+        return document.documentElement.clientWidth <= evt.clientX || document.documentElement.clientHeight <= evt.clientY;
+    }
+    var testPassiveEventSupport = function testPassiveEventSupport2() {
+        if (typeof window === "undefined" || typeof window.addEventListener !== "function") {
+            return;
+        }
+        var passive2 = false;
+        var options = Object.defineProperty({}, "passive", {
+            get: function get2() {
+                passive2 = true;
             }
         });
-        Prism2.languages.insertBefore("inside", "double-colon", {
-            "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
-        }, Prism2.languages.cpp["base-clause"]);
-    })(prism);
-    (function(Prism2) {
-        var string2 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
-        Prism2.languages.css = {
-            "comment": /\/\*[\s\S]*?\*\//,
-            "atrule": {
-                pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
-                inside: {
-                    "rule": /^@[\w-]+/,
-                    "selector-function-argument": {
-                        pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
-                        lookbehind: true,
-                        alias: "selector"
-                    },
-                    "keyword": {
-                        pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
-                        lookbehind: true
+        var noop2 = function noop3() {};
+        window.addEventListener("testPassiveEventSupport", noop2, options);
+        window.removeEventListener("testPassiveEventSupport", noop2, options);
+        return passive2;
+    };
+
+    function autoInc(seed2) {
+        if (seed2 === void 0) {
+            seed2 = 0;
+        }
+        return function() {
+            return ++seed2;
+        };
+    }
+    var uid$1 = autoInc();
+    var passiveEventSupport;
+    var handlersMap = {};
+    var enabledInstances = {};
+    var touchEvents = ["touchstart", "touchmove"];
+    var IGNORE_CLASS_NAME = "ignore-react-onclickoutside";
+
+    function getEventHandlerOptions(instance2, eventName) {
+        var handlerOptions = {};
+        var isTouchEvent = touchEvents.indexOf(eventName) !== -1;
+        if (isTouchEvent && passiveEventSupport) {
+            handlerOptions.passive = !instance2.props.preventDefault;
+        }
+        return handlerOptions;
+    }
+
+    function onClickOutsideHOC(WrappedComponent, config2) {
+        var _class, _temp;
+        var componentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
+        return _temp = _class = /* @__PURE__ */ function(_Component) {
+            _inheritsLoose$1(onClickOutside, _Component);
+
+            function onClickOutside(props) {
+                var _this;
+                _this = _Component.call(this, props) || this;
+                _this.__outsideClickHandler = function(event2) {
+                    if (typeof _this.__clickOutsideHandlerProp === "function") {
+                        _this.__clickOutsideHandlerProp(event2);
+                        return;
+                    }
+                    var instance2 = _this.getInstance();
+                    if (typeof instance2.props.handleClickOutside === "function") {
+                        instance2.props.handleClickOutside(event2);
+                        return;
+                    }
+                    if (typeof instance2.handleClickOutside === "function") {
+                        instance2.handleClickOutside(event2);
+                        return;
+                    }
+                    throw new Error("WrappedComponent: " + componentName + " lacks a handleClickOutside(event) function for processing outside click events.");
+                };
+                _this.__getComponentNode = function() {
+                    var instance2 = _this.getInstance();
+                    if (config2 && typeof config2.setClickOutsideRef === "function") {
+                        return config2.setClickOutsideRef()(instance2);
+                    }
+                    if (typeof instance2.setClickOutsideRef === "function") {
+                        return instance2.setClickOutsideRef();
+                    }
+                    return ReactDOM.findDOMNode(instance2);
+                };
+                _this.enableOnClickOutside = function() {
+                    if (typeof document === "undefined" || enabledInstances[_this._uid]) {
+                        return;
+                    }
+                    if (typeof passiveEventSupport === "undefined") {
+                        passiveEventSupport = testPassiveEventSupport();
+                    }
+                    enabledInstances[_this._uid] = true;
+                    var events2 = _this.props.eventTypes;
+                    if (!events2.forEach) {
+                        events2 = [events2];
                     }
+                    handlersMap[_this._uid] = function(event2) {
+                        if (_this.componentNode === null)
+                            return;
+                        if (_this.props.preventDefault) {
+                            event2.preventDefault();
+                        }
+                        if (_this.props.stopPropagation) {
+                            event2.stopPropagation();
+                        }
+                        if (_this.props.excludeScrollbar && clickedScrollbar(event2))
+                            return;
+                        var current2 = event2.composed && event2.composedPath && event2.composedPath().shift() || event2.target;
+                        if (findHighest(current2, _this.componentNode, _this.props.outsideClickIgnoreClass) !== document) {
+                            return;
+                        }
+                        _this.__outsideClickHandler(event2);
+                    };
+                    events2.forEach(function(eventName) {
+                        document.addEventListener(eventName, handlersMap[_this._uid], getEventHandlerOptions(_assertThisInitialized$2(_this), eventName));
+                    });
+                };
+                _this.disableOnClickOutside = function() {
+                    delete enabledInstances[_this._uid];
+                    var fn2 = handlersMap[_this._uid];
+                    if (fn2 && typeof document !== "undefined") {
+                        var events2 = _this.props.eventTypes;
+                        if (!events2.forEach) {
+                            events2 = [events2];
+                        }
+                        events2.forEach(function(eventName) {
+                            return document.removeEventListener(eventName, fn2, getEventHandlerOptions(_assertThisInitialized$2(_this), eventName));
+                        });
+                        delete handlersMap[_this._uid];
+                    }
+                };
+                _this.getRef = function(ref2) {
+                    return _this.instanceRef = ref2;
+                };
+                _this._uid = uid$1();
+                return _this;
+            }
+            var _proto = onClickOutside.prototype;
+            _proto.getInstance = function getInstance() {
+                if (WrappedComponent.prototype && !WrappedComponent.prototype.isReactComponent) {
+                    return this;
                 }
-            },
-            "url": {
-                pattern: RegExp("\\burl\\((?:" + string2.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
-                greedy: true,
-                inside: {
-                    "function": /^url/i,
-                    "punctuation": /^\(|\)$/,
-                    "string": {
-                        pattern: RegExp("^" + string2.source + "$"),
-                        alias: "url"
+                var ref2 = this.instanceRef;
+                return ref2.getInstance ? ref2.getInstance() : ref2;
+            };
+            _proto.componentDidMount = function componentDidMount() {
+                if (typeof document === "undefined" || !document.createElement) {
+                    return;
+                }
+                var instance2 = this.getInstance();
+                if (config2 && typeof config2.handleClickOutside === "function") {
+                    this.__clickOutsideHandlerProp = config2.handleClickOutside(instance2);
+                    if (typeof this.__clickOutsideHandlerProp !== "function") {
+                        throw new Error("WrappedComponent: " + componentName + " lacks a function for processing outside click events specified by the handleClickOutside config option.");
                     }
                 }
-            },
-            "selector": {
-                pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string2.source + ")*(?=\\s*\\{)"),
-                lookbehind: true
-            },
-            "string": {
-                pattern: string2,
-                greedy: true
-            },
-            "property": {
-                pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
-                lookbehind: true
-            },
-            "important": /!important\b/i,
-            "function": {
-                pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
-                lookbehind: true
-            },
-            "punctuation": /[(){};:,]/
-        };
-        Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
-        var markup = Prism2.languages.markup;
-        if (markup) {
-            markup.tag.addInlined("style", "css");
-            markup.tag.addAttribute("style", "css");
+                this.componentNode = this.__getComponentNode();
+                if (this.props.disableOnClickOutside)
+                    return;
+                this.enableOnClickOutside();
+            };
+            _proto.componentDidUpdate = function componentDidUpdate() {
+                this.componentNode = this.__getComponentNode();
+            };
+            _proto.componentWillUnmount = function componentWillUnmount() {
+                this.disableOnClickOutside();
+            };
+            _proto.render = function render2() {
+                var _this$props = this.props;
+                _this$props.excludeScrollbar;
+                var props = _objectWithoutPropertiesLoose$3(_this$props, ["excludeScrollbar"]);
+                if (WrappedComponent.prototype && WrappedComponent.prototype.isReactComponent) {
+                    props.ref = this.getRef;
+                } else {
+                    props.wrappedRef = this.getRef;
+                }
+                props.disableOnClickOutside = this.disableOnClickOutside;
+                props.enableOnClickOutside = this.enableOnClickOutside;
+                return React.createElement(WrappedComponent, props);
+            };
+            return onClickOutside;
+        }(React.Component), _class.displayName = "OnClickOutside(" + componentName + ")", _class.defaultProps = {
+            eventTypes: ["mousedown", "touchstart"],
+            excludeScrollbar: config2 && config2.excludeScrollbar || false,
+            outsideClickIgnoreClass: IGNORE_CLASS_NAME,
+            preventDefault: false,
+            stopPropagation: false
+        }, _class.getClass = function() {
+            return WrappedComponent.getClass ? WrappedComponent.getClass() : WrappedComponent;
+        }, _temp;
+    }
+    var ManagerReferenceNodeContext = React__namespace.createContext();
+    var ManagerReferenceNodeSetterContext = React__namespace.createContext();
+
+    function Manager(_ref2) {
+        var children2 = _ref2.children;
+        var _React$useState = React__namespace.useState(null),
+            referenceNode = _React$useState[0],
+            setReferenceNode = _React$useState[1];
+        var hasUnmounted = React__namespace.useRef(false);
+        React__namespace.useEffect(function() {
+            return function() {
+                hasUnmounted.current = true;
+            };
+        }, []);
+        var handleSetReferenceNode = React__namespace.useCallback(function(node2) {
+            if (!hasUnmounted.current) {
+                setReferenceNode(node2);
+            }
+        }, []);
+        return /* @__PURE__ */ React__namespace.createElement(ManagerReferenceNodeContext.Provider, {
+            value: referenceNode
+        }, /* @__PURE__ */ React__namespace.createElement(ManagerReferenceNodeSetterContext.Provider, {
+            value: handleSetReferenceNode
+        }, children2));
+    }
+    var unwrapArray = function unwrapArray2(arg) {
+        return Array.isArray(arg) ? arg[0] : arg;
+    };
+    var safeInvoke = function safeInvoke2(fn2) {
+        if (typeof fn2 === "function") {
+            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
+                args[_key - 1] = arguments[_key];
+            }
+            return fn2.apply(void 0, args);
         }
-    })(prism);
-    (function(Prism2) {
-        var string2 = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
-        var selectorInside;
-        Prism2.languages.css.selector = {
-            pattern: Prism2.languages.css.selector.pattern,
-            lookbehind: true,
-            inside: selectorInside = {
-                "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,
-                "pseudo-class": /:[-\w]+/,
-                "class": /\.[-\w]+/,
-                "id": /#[-\w]+/,
-                "attribute": {
-                    pattern: RegExp(`\\[(?:[^[\\]"']|` + string2.source + ")*\\]"),
-                    greedy: true,
-                    inside: {
-                        "punctuation": /^\[|\]$/,
-                        "case-sensitivity": {
-                            pattern: /(\s)[si]$/i,
-                            lookbehind: true,
-                            alias: "keyword"
-                        },
-                        "namespace": {
-                            pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/,
-                            lookbehind: true,
-                            inside: {
-                                "punctuation": /\|$/
-                            }
-                        },
-                        "attr-name": {
-                            pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/,
-                            lookbehind: true
-                        },
-                        "attr-value": [string2, {
-                            pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/,
-                            lookbehind: true
-                        }],
-                        "operator": /[|~*^$]?=/
+    };
+    var setRef$1 = function setRef2(ref2, node2) {
+        if (typeof ref2 === "function") {
+            return safeInvoke(ref2, node2);
+        } else if (ref2 != null) {
+            ref2.current = node2;
+        }
+    };
+    var fromEntries = function fromEntries2(entries) {
+        return entries.reduce(function(acc, _ref2) {
+            var key = _ref2[0],
+                value = _ref2[1];
+            acc[key] = value;
+            return acc;
+        }, {});
+    };
+    var useIsomorphicLayoutEffect$1 = typeof window !== "undefined" && window.document && window.document.createElement ? React__namespace.useLayoutEffect : React__namespace.useEffect;
+    var EMPTY_MODIFIERS$1 = [];
+    var usePopper = function usePopper2(referenceElement, popperElement, options) {
+        if (options === void 0) {
+            options = {};
+        }
+        var prevOptions = React__namespace.useRef(null);
+        var optionsWithDefaults = {
+            onFirstUpdate: options.onFirstUpdate,
+            placement: options.placement || "bottom",
+            strategy: options.strategy || "absolute",
+            modifiers: options.modifiers || EMPTY_MODIFIERS$1
+        };
+        var _React$useState = React__namespace.useState({
+                styles: {
+                    popper: {
+                        position: optionsWithDefaults.strategy,
+                        left: "0",
+                        top: "0"
+                    },
+                    arrow: {
+                        position: "absolute"
                     }
                 },
-                "n-th": [{
-                    pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/,
-                    lookbehind: true,
-                    inside: {
-                        "number": /[\dn]+/,
-                        "operator": /[+-]/
-                    }
-                }, {
-                    pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i,
-                    lookbehind: true
-                }],
-                "combinator": />|\+|~|\|\|/,
-                "punctuation": /[(),]/
+                attributes: {}
+            }),
+            state = _React$useState[0],
+            setState = _React$useState[1];
+        var updateStateModifier = React__namespace.useMemo(function() {
+            return {
+                name: "updateState",
+                enabled: true,
+                phase: "write",
+                fn: function fn2(_ref2) {
+                    var state2 = _ref2.state;
+                    var elements = Object.keys(state2.elements);
+                    ReactDOM__namespace.flushSync(function() {
+                        setState({
+                            styles: fromEntries(elements.map(function(element2) {
+                                return [element2, state2.styles[element2] || {}];
+                            })),
+                            attributes: fromEntries(elements.map(function(element2) {
+                                return [element2, state2.attributes[element2]];
+                            }))
+                        });
+                    });
+                },
+                requires: ["computeStyles"]
+            };
+        }, []);
+        var popperOptions = React__namespace.useMemo(function() {
+            var newOptions = {
+                onFirstUpdate: optionsWithDefaults.onFirstUpdate,
+                placement: optionsWithDefaults.placement,
+                strategy: optionsWithDefaults.strategy,
+                modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
+                    name: "applyStyles",
+                    enabled: false
+                }])
+            };
+            if (reactFastCompare(prevOptions.current, newOptions)) {
+                return prevOptions.current || newOptions;
+            } else {
+                prevOptions.current = newOptions;
+                return newOptions;
             }
-        };
-        Prism2.languages.css["atrule"].inside["selector-function-argument"].inside = selectorInside;
-        Prism2.languages.insertBefore("css", "property", {
-            "variable": {
-                pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i,
-                lookbehind: true
+        }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
+        var popperInstanceRef = React__namespace.useRef();
+        useIsomorphicLayoutEffect$1(function() {
+            if (popperInstanceRef.current) {
+                popperInstanceRef.current.setOptions(popperOptions);
             }
-        });
-        var unit = {
-            pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/,
-            lookbehind: true
-        };
-        var number2 = {
-            pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
-            lookbehind: true
-        };
-        Prism2.languages.insertBefore("css", "function", {
-            "operator": {
-                pattern: /(\s)[+\-*\/](?=\s)/,
-                lookbehind: true
-            },
-            "hexcode": {
-                pattern: /\B#[\da-f]{3,8}\b/i,
-                alias: "color"
-            },
-            "color": [{
-                pattern: /(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i,
-                lookbehind: true
-            }, {
-                pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
-                inside: {
-                    "unit": unit,
-                    "number": number2,
-                    "function": /[\w-]+(?=\()/,
-                    "punctuation": /[(),]/
-                }
-            }],
-            "entity": /\\[\da-f]{1,8}/i,
-            "unit": unit,
-            "number": number2
-        });
-    })(prism);
-    prism.languages.javascript = prism.languages.extend("clike", {
-        "class-name": [prism.languages.clike["class-name"], {
-            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
-            lookbehind: true
-        }],
-        "keyword": [{
-            pattern: /((?:^|\})\s*)catch\b/,
-            lookbehind: true
-        }, {
-            pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
-            lookbehind: true
-        }],
-        "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
-        "number": {
-            pattern: RegExp(/(^|[^\w$])/.source + "(?:" + (/NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
-            lookbehind: true
-        },
-        "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
-    });
-    prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
-    prism.languages.insertBefore("javascript", "keyword", {
-        "regex": {
-            pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
-            lookbehind: true,
-            greedy: true,
-            inside: {
-                "regex-source": {
-                    pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
-                    lookbehind: true,
-                    alias: "language-regex",
-                    inside: prism.languages.regex
-                },
-                "regex-delimiter": /^\/|\/$/,
-                "regex-flags": /^[a-z]+$/
+        }, [popperOptions]);
+        useIsomorphicLayoutEffect$1(function() {
+            if (referenceElement == null || popperElement == null) {
+                return;
             }
-        },
-        "function-variable": {
-            pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
-            alias: "function"
-        },
-        "parameter": [{
-            pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
-            lookbehind: true,
-            inside: prism.languages.javascript
-        }, {
-            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
-            lookbehind: true,
-            inside: prism.languages.javascript
-        }, {
-            pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
-            lookbehind: true,
-            inside: prism.languages.javascript
-        }, {
-            pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
-            lookbehind: true,
-            inside: prism.languages.javascript
-        }],
-        "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
-    });
-    prism.languages.insertBefore("javascript", "string", {
-        "hashbang": {
-            pattern: /^#!.*/,
-            greedy: true,
-            alias: "comment"
-        },
-        "template-string": {
-            pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
-            greedy: true,
-            inside: {
-                "template-punctuation": {
-                    pattern: /^`|`$/,
-                    alias: "string"
-                },
-                "interpolation": {
-                    pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
-                    lookbehind: true,
-                    inside: {
-                        "interpolation-punctuation": {
-                            pattern: /^\$\{|\}$/,
-                            alias: "punctuation"
-                        },
-                        rest: prism.languages.javascript
+            var createPopper2 = options.createPopper || createPopper$1;
+            var popperInstance = createPopper2(referenceElement, popperElement, popperOptions);
+            popperInstanceRef.current = popperInstance;
+            return function() {
+                popperInstance.destroy();
+                popperInstanceRef.current = null;
+            };
+        }, [referenceElement, popperElement, options.createPopper]);
+        return {
+            state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
+            styles: state.styles,
+            attributes: state.attributes,
+            update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
+            forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
+        };
+    };
+    var NOOP$1 = function NOOP2() {
+        return void 0;
+    };
+    var NOOP_PROMISE = function NOOP_PROMISE2() {
+        return Promise.resolve(null);
+    };
+    var EMPTY_MODIFIERS = [];
+
+    function Popper(_ref2) {
+        var _ref$placement = _ref2.placement,
+            placement = _ref$placement === void 0 ? "bottom" : _ref$placement,
+            _ref$strategy = _ref2.strategy,
+            strategy = _ref$strategy === void 0 ? "absolute" : _ref$strategy,
+            _ref$modifiers = _ref2.modifiers,
+            modifiers2 = _ref$modifiers === void 0 ? EMPTY_MODIFIERS : _ref$modifiers,
+            referenceElement = _ref2.referenceElement,
+            onFirstUpdate = _ref2.onFirstUpdate,
+            innerRef = _ref2.innerRef,
+            children2 = _ref2.children;
+        var referenceNode = React__namespace.useContext(ManagerReferenceNodeContext);
+        var _React$useState = React__namespace.useState(null),
+            popperElement = _React$useState[0],
+            setPopperElement = _React$useState[1];
+        var _React$useState2 = React__namespace.useState(null),
+            arrowElement = _React$useState2[0],
+            setArrowElement = _React$useState2[1];
+        React__namespace.useEffect(function() {
+            setRef$1(innerRef, popperElement);
+        }, [innerRef, popperElement]);
+        var options = React__namespace.useMemo(function() {
+            return {
+                placement,
+                strategy,
+                onFirstUpdate,
+                modifiers: [].concat(modifiers2, [{
+                    name: "arrow",
+                    enabled: arrowElement != null,
+                    options: {
+                        element: arrowElement
                     }
+                }])
+            };
+        }, [placement, strategy, onFirstUpdate, modifiers2, arrowElement]);
+        var _usePopper = usePopper(referenceElement || referenceNode, popperElement, options),
+            state = _usePopper.state,
+            styles2 = _usePopper.styles,
+            forceUpdate = _usePopper.forceUpdate,
+            update2 = _usePopper.update;
+        var childrenProps = React__namespace.useMemo(function() {
+            return {
+                ref: setPopperElement,
+                style: styles2.popper,
+                placement: state ? state.placement : placement,
+                hasPopperEscaped: state && state.modifiersData.hide ? state.modifiersData.hide.hasPopperEscaped : null,
+                isReferenceHidden: state && state.modifiersData.hide ? state.modifiersData.hide.isReferenceHidden : null,
+                arrowProps: {
+                    style: styles2.arrow,
+                    ref: setArrowElement
                 },
-                "string": /[\s\S]+/
-            }
-        },
-        "string-property": {
-            pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
-            lookbehind: true,
-            greedy: true,
-            alias: "property"
+                forceUpdate: forceUpdate || NOOP$1,
+                update: update2 || NOOP_PROMISE
+            };
+        }, [setPopperElement, setArrowElement, placement, state, styles2, update2, forceUpdate]);
+        return unwrapArray(children2)(childrenProps);
+    }
+
+    function Reference(_ref2) {
+        var children2 = _ref2.children,
+            innerRef = _ref2.innerRef;
+        var setReferenceNode = React__namespace.useContext(ManagerReferenceNodeSetterContext);
+        var refHandler = React__namespace.useCallback(function(node2) {
+            setRef$1(innerRef, node2);
+            safeInvoke(setReferenceNode, node2);
+        }, [innerRef, setReferenceNode]);
+        React__namespace.useEffect(function() {
+            return function() {
+                return setRef$1(innerRef, null);
+            };
+        }, []);
+        React__namespace.useEffect(function() {}, [setReferenceNode]);
+        return unwrapArray(children2)({
+            ref: refHandler
+        });
+    }
+
+    function ae$1(e3, t2) {
+        var r2 = Object.keys(e3);
+        if (Object.getOwnPropertySymbols) {
+            var n2 = Object.getOwnPropertySymbols(e3);
+            t2 && (n2 = n2.filter(function(t3) {
+                return Object.getOwnPropertyDescriptor(e3, t3).enumerable;
+            })), r2.push.apply(r2, n2);
         }
-    });
-    prism.languages.insertBefore("javascript", "operator", {
-        "literal-property": {
-            pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
-            lookbehind: true,
-            alias: "property"
+        return r2;
+    }
+
+    function se$1(e3) {
+        for (var t2 = 1; t2 < arguments.length; t2++) {
+            var r2 = null != arguments[t2] ? arguments[t2] : {};
+            t2 % 2 ? ae$1(Object(r2), true).forEach(function(t3) {
+                de$1(e3, t3, r2[t3]);
+            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r2)) : ae$1(Object(r2)).forEach(function(t3) {
+                Object.defineProperty(e3, t3, Object.getOwnPropertyDescriptor(r2, t3));
+            });
         }
-    });
-    if (prism.languages.markup) {
-        prism.languages.markup.tag.addInlined("script", "javascript");
-        prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
+        return e3;
     }
-    prism.languages.js = prism.languages.javascript;
-    (function(Prism2) {
-        var comment2 = /#(?!\{).+/;
-        var interpolation = {
-            pattern: /#\{[^}]+\}/,
-            alias: "variable"
-        };
-        Prism2.languages.coffeescript = Prism2.languages.extend("javascript", {
-            "comment": comment2,
-            "string": [{
-                pattern: /'(?:\\[\s\S]|[^\\'])*'/,
-                greedy: true
-            }, {
-                pattern: /"(?:\\[\s\S]|[^\\"])*"/,
-                greedy: true,
-                inside: {
-                    "interpolation": interpolation
-                }
-            }],
-            "keyword": /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
-            "class-member": {
-                pattern: /@(?!\d)\w+/,
-                alias: "variable"
+
+    function ie$3(e3) {
+        return (ie$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
+            return typeof e4;
+        } : function(e4) {
+            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
+        })(e3);
+    }
+
+    function pe$1(e3, t2) {
+        if (!(e3 instanceof t2))
+            throw new TypeError("Cannot call a class as a function");
+    }
+
+    function ce$1(e3, t2) {
+        for (var r2 = 0; r2 < t2.length; r2++) {
+            var n2 = t2[r2];
+            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, n2.key, n2);
+        }
+    }
+
+    function le$1(e3, t2, r2) {
+        return t2 && ce$1(e3.prototype, t2), r2 && ce$1(e3, r2), Object.defineProperty(e3, "prototype", {
+            writable: false
+        }), e3;
+    }
+
+    function de$1(e3, t2, r2) {
+        return t2 in e3 ? Object.defineProperty(e3, t2, {
+            value: r2,
+            enumerable: true,
+            configurable: true,
+            writable: true
+        }) : e3[t2] = r2, e3;
+    }
+
+    function ue$1() {
+        return (ue$1 = Object.assign || function(e3) {
+            for (var t2 = 1; t2 < arguments.length; t2++) {
+                var r2 = arguments[t2];
+                for (var n2 in r2)
+                    Object.prototype.hasOwnProperty.call(r2, n2) && (e3[n2] = r2[n2]);
             }
-        });
-        Prism2.languages.insertBefore("coffeescript", "comment", {
-            "multiline-comment": {
-                pattern: /###[\s\S]+?###/,
-                alias: "comment"
-            },
-            "block-regex": {
-                pattern: /\/{3}[\s\S]*?\/{3}/,
-                alias: "regex",
-                inside: {
-                    "comment": comment2,
-                    "interpolation": interpolation
+            return e3;
+        }).apply(this, arguments);
+    }
+
+    function he$1(e3, t2) {
+        if ("function" != typeof t2 && null !== t2)
+            throw new TypeError("Super expression must either be null or a function");
+        Object.defineProperty(e3, "prototype", {
+            value: Object.create(t2 && t2.prototype, {
+                constructor: {
+                    value: e3,
+                    writable: true,
+                    configurable: true
                 }
+            }),
+            writable: false
+        }), t2 && fe$1(e3, t2);
+    }
+
+    function me(e3) {
+        return (me = Object.setPrototypeOf ? Object.getPrototypeOf : function(e4) {
+            return e4.__proto__ || Object.getPrototypeOf(e4);
+        })(e3);
+    }
+
+    function fe$1(e3, t2) {
+        return (fe$1 = Object.setPrototypeOf || function(e4, t3) {
+            return e4.__proto__ = t3, e4;
+        })(e3, t2);
+    }
+
+    function ye(e3) {
+        if (void 0 === e3)
+            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
+        return e3;
+    }
+
+    function ve(e3, t2) {
+        if (t2 && ("object" == typeof t2 || "function" == typeof t2))
+            return t2;
+        if (void 0 !== t2)
+            throw new TypeError("Derived constructors may only return object or undefined");
+        return ye(e3);
+    }
+
+    function De(e3) {
+        var t2 = function() {
+            if ("undefined" == typeof Reflect || !Reflect.construct)
+                return false;
+            if (Reflect.construct.sham)
+                return false;
+            if ("function" == typeof Proxy)
+                return true;
+            try {
+                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), true;
+            } catch (e4) {
+                return false;
             }
-        });
-        Prism2.languages.insertBefore("coffeescript", "string", {
-            "inline-javascript": {
-                pattern: /`(?:\\[\s\S]|[^\\`])*`/,
-                inside: {
-                    "delimiter": {
-                        pattern: /^`|`$/,
-                        alias: "punctuation"
-                    },
-                    "script": {
-                        pattern: /[\s\S]+/,
-                        alias: "language-javascript",
-                        inside: Prism2.languages.javascript
-                    }
-                }
-            },
-            "multiline-string": [{
-                pattern: /'''[\s\S]*?'''/,
-                greedy: true,
-                alias: "string"
-            }, {
-                pattern: /"""[\s\S]*?"""/,
-                greedy: true,
-                alias: "string",
-                inside: {
-                    interpolation
+        }();
+        return function() {
+            var r2, n2 = me(e3);
+            if (t2) {
+                var o2 = me(this).constructor;
+                r2 = Reflect.construct(n2, arguments, o2);
+            } else
+                r2 = n2.apply(this, arguments);
+            return ve(this, r2);
+        };
+    }
+
+    function we$1(e3) {
+        return function(e4) {
+            if (Array.isArray(e4))
+                return ge(e4);
+        }(e3) || function(e4) {
+            if ("undefined" != typeof Symbol && null != e4[Symbol.iterator] || null != e4["@@iterator"])
+                return Array.from(e4);
+        }(e3) || function(e4, t2) {
+            if (!e4)
+                return;
+            if ("string" == typeof e4)
+                return ge(e4, t2);
+            var r2 = Object.prototype.toString.call(e4).slice(8, -1);
+            "Object" === r2 && e4.constructor && (r2 = e4.constructor.name);
+            if ("Map" === r2 || "Set" === r2)
+                return Array.from(e4);
+            if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
+                return ge(e4, t2);
+        }(e3) || function() {
+            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
+        }();
+    }
+
+    function ge(e3, t2) {
+        (null == t2 || t2 > e3.length) && (t2 = e3.length);
+        for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
+            n2[r2] = e3[r2];
+        return n2;
+    }
+
+    function ke(e3, t2) {
+        switch (e3) {
+            case "P":
+                return t2.date({
+                    width: "short"
+                });
+            case "PP":
+                return t2.date({
+                    width: "medium"
+                });
+            case "PPP":
+                return t2.date({
+                    width: "long"
+                });
+            case "PPPP":
+            default:
+                return t2.date({
+                    width: "full"
+                });
+        }
+    }
+
+    function be$1(e3, t2) {
+        switch (e3) {
+            case "p":
+                return t2.time({
+                    width: "short"
+                });
+            case "pp":
+                return t2.time({
+                    width: "medium"
+                });
+            case "ppp":
+                return t2.time({
+                    width: "long"
+                });
+            case "pppp":
+            default:
+                return t2.time({
+                    width: "full"
+                });
+        }
+    }
+    var Ce$1 = {
+            p: be$1,
+            P: function(e3, t2) {
+                var r2, n2 = e3.match(/(P+)(p+)?/) || [],
+                    o2 = n2[1],
+                    a2 = n2[2];
+                if (!a2)
+                    return ke(e3, t2);
+                switch (o2) {
+                    case "P":
+                        r2 = t2.dateTime({
+                            width: "short"
+                        });
+                        break;
+                    case "PP":
+                        r2 = t2.dateTime({
+                            width: "medium"
+                        });
+                        break;
+                    case "PPP":
+                        r2 = t2.dateTime({
+                            width: "long"
+                        });
+                        break;
+                    case "PPPP":
+                    default:
+                        r2 = t2.dateTime({
+                            width: "full"
+                        });
                 }
-            }]
+                return r2.replace("{{date}}", ke(o2, t2)).replace("{{time}}", be$1(a2, t2));
+            }
+        },
+        Se = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
+
+    function _e$1(e3) {
+        var t2 = e3 ? "string" == typeof e3 || e3 instanceof String ? parseISO(e3) : toDate(e3) : new Date();
+        return Pe$1(t2) ? t2 : null;
+    }
+
+    function Me$1(e3, t2, r2, n2, o2) {
+        var a2 = null,
+            s2 = Ue(r2) || Ue(qe$1()),
+            i2 = true;
+        return Array.isArray(t2) ? (t2.forEach(function(t3) {
+            var p2 = parse$5(e3, t3, new Date(), {
+                locale: s2
+            });
+            n2 && (i2 = Pe$1(p2, o2) && e3 === Ee$1(p2, t3, r2)), Pe$1(p2, o2) && i2 && (a2 = p2);
+        }), a2) : (a2 = parse$5(e3, t2, new Date(), {
+            locale: s2
+        }), n2 ? i2 = Pe$1(a2) && e3 === Ee$1(a2, t2, r2) : Pe$1(a2) || (t2 = t2.match(Se).map(function(e4) {
+            var t3 = e4[0];
+            return "p" === t3 || "P" === t3 ? s2 ? (0, Ce$1[t3])(e4, s2.formatLong) : t3 : e4;
+        }).join(""), e3.length > 0 && (a2 = parse$5(e3, t2.slice(0, e3.length), new Date())), Pe$1(a2) || (a2 = new Date(e3))), Pe$1(a2) && i2 ? a2 : null);
+    }
+
+    function Pe$1(e3, t2) {
+        return t2 = t2 || new Date("1/1/1000"), isValid(e3) && !isBefore(e3, t2);
+    }
+
+    function Ee$1(e3, t2, r2) {
+        if ("en" === r2)
+            return format$1(e3, t2, {
+                awareOfUnicodeTokens: true
+            });
+        var n2 = Ue(r2);
+        return r2 && !n2 && console.warn('A locale object was not found for the provided string ["'.concat(r2, '"].')), !n2 && qe$1() && Ue(qe$1()) && (n2 = Ue(qe$1())), format$1(e3, t2, {
+            locale: n2 || null,
+            awareOfUnicodeTokens: true
         });
-        Prism2.languages.insertBefore("coffeescript", "keyword", {
-            "property": /(?!\d)\w+(?=\s*:(?!:))/
+    }
+
+    function Ne$1(e3, t2) {
+        var r2 = t2.dateFormat,
+            n2 = t2.locale;
+        return e3 && Ee$1(e3, Array.isArray(r2) ? r2[0] : r2, n2) || "";
+    }
+
+    function xe$1(e3, t2) {
+        var r2 = t2.hour,
+            n2 = void 0 === r2 ? 0 : r2,
+            o2 = t2.minute,
+            a2 = void 0 === o2 ? 0 : o2,
+            s2 = t2.second;
+        return setHours(setMinutes(setSeconds(e3, void 0 === s2 ? 0 : s2), a2), n2);
+    }
+
+    function Ye$1(e3, t2) {
+        var r2 = t2 && Ue(t2) || qe$1() && Ue(qe$1());
+        return getISOWeek(e3, r2 ? {
+            locale: r2
+        } : null);
+    }
+
+    function Oe$1(e3, t2) {
+        return Ee$1(e3, "ddd", t2);
+    }
+
+    function Ie$1(e3) {
+        return startOfDay(e3);
+    }
+
+    function Te(e3, t2, r2) {
+        var n2 = Ue(t2 || qe$1());
+        return startOfWeek(e3, {
+            locale: n2,
+            weekStartsOn: r2
         });
-        delete Prism2.languages.coffeescript["template-string"];
-        Prism2.languages.coffee = Prism2.languages.coffeescript;
-    })(prism);
-    (function(Prism2) {
-        var anchorOrAlias = /[*&][^\s[\]{},]+/;
-        var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
-        var properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)";
-        var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
-            return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
+    }
+
+    function Le$1(e3) {
+        return startOfMonth(e3);
+    }
+
+    function Re$1(e3) {
+        return startOfYear(e3);
+    }
+
+    function Fe$1(e3) {
+        return startOfQuarter(e3);
+    }
+
+    function Ae(e3, t2) {
+        return e3 && t2 ? isSameYear(e3, t2) : !e3 && !t2;
+    }
+
+    function Be$1(e3, t2) {
+        return e3 && t2 ? isSameMonth(e3, t2) : !e3 && !t2;
+    }
+
+    function Ke$1(e3, t2) {
+        return e3 && t2 ? isSameQuarter(e3, t2) : !e3 && !t2;
+    }
+
+    function We$1(e3, t2) {
+        return e3 && t2 ? isSameDay(e3, t2) : !e3 && !t2;
+    }
+
+    function je$1(e3, t2) {
+        return e3 && t2 ? isEqual$2(e3, t2) : !e3 && !t2;
+    }
+
+    function He$1(e3, t2, r2) {
+        var n2, o2 = startOfDay(t2),
+            a2 = endOfDay(r2);
+        try {
+            n2 = isWithinInterval(e3, {
+                start: o2,
+                end: a2
+            });
+        } catch (e4) {
+            n2 = false;
+        }
+        return n2;
+    }
+
+    function qe$1() {
+        return ("undefined" != typeof window ? window : globalThis).__localeId__;
+    }
+
+    function Ue(e3) {
+        if ("string" == typeof e3) {
+            var t2 = "undefined" != typeof window ? window : globalThis;
+            return t2.__localeData__ ? t2.__localeData__[e3] : null;
+        }
+        return e3;
+    }
+
+    function $e$1(e3, t2) {
+        return Ee$1(setMonth(_e$1(), e3), "LLLL", t2);
+    }
+
+    function ze$1(e3, t2) {
+        return Ee$1(setMonth(_e$1(), e3), "LLL", t2);
+    }
+
+    function Ge$1(e3, t2) {
+        return Ee$1(setQuarter(_e$1(), e3), "QQQ", t2);
+    }
+
+    function Je$1(e3) {
+        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
+            r2 = t2.minDate,
+            n2 = t2.maxDate,
+            o2 = t2.excludeDates,
+            a2 = t2.excludeDateIntervals,
+            s2 = t2.includeDates,
+            i2 = t2.includeDateIntervals,
+            p2 = t2.filterDate;
+        return ot(e3, {
+            minDate: r2,
+            maxDate: n2
+        }) || o2 && o2.some(function(t3) {
+            return We$1(e3, t3);
+        }) || a2 && a2.some(function(t3) {
+            var r3 = t3.start,
+                n3 = t3.end;
+            return isWithinInterval(e3, {
+                start: r3,
+                end: n3
+            });
+        }) || s2 && !s2.some(function(t3) {
+            return We$1(e3, t3);
+        }) || i2 && !i2.some(function(t3) {
+            var r3 = t3.start,
+                n3 = t3.end;
+            return isWithinInterval(e3, {
+                start: r3,
+                end: n3
+            });
+        }) || p2 && !p2(_e$1(e3)) || false;
+    }
+
+    function Xe(e3) {
+        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
+            r2 = t2.excludeDates,
+            n2 = t2.excludeDateIntervals;
+        return n2 && n2.length > 0 ? n2.some(function(t3) {
+            var r3 = t3.start,
+                n3 = t3.end;
+            return isWithinInterval(e3, {
+                start: r3,
+                end: n3
+            });
+        }) : r2 && r2.some(function(t3) {
+            return We$1(e3, t3);
+        }) || false;
+    }
+
+    function Ze$1(e3) {
+        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
+            r2 = t2.minDate,
+            n2 = t2.maxDate,
+            o2 = t2.excludeDates,
+            a2 = t2.includeDates,
+            s2 = t2.filterDate;
+        return ot(e3, {
+            minDate: r2,
+            maxDate: n2
+        }) || o2 && o2.some(function(t3) {
+            return Be$1(e3, t3);
+        }) || a2 && !a2.some(function(t3) {
+            return Be$1(e3, t3);
+        }) || s2 && !s2(_e$1(e3)) || false;
+    }
+
+    function et$1(e3, t2, r2, n2) {
+        var o2 = getYear(e3),
+            a2 = getMonth(e3),
+            s2 = getYear(t2),
+            i2 = getMonth(t2),
+            p2 = getYear(n2);
+        return o2 === s2 && o2 === p2 ? a2 <= r2 && r2 <= i2 : o2 < s2 ? p2 === o2 && a2 <= r2 || p2 === s2 && i2 >= r2 || p2 < s2 && p2 > o2 : void 0;
+    }
+
+    function tt$1(e3) {
+        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
+            r2 = t2.minDate,
+            n2 = t2.maxDate,
+            o2 = t2.excludeDates,
+            a2 = t2.includeDates,
+            s2 = t2.filterDate;
+        return ot(e3, {
+            minDate: r2,
+            maxDate: n2
+        }) || o2 && o2.some(function(t3) {
+            return Ke$1(e3, t3);
+        }) || a2 && !a2.some(function(t3) {
+            return Ke$1(e3, t3);
+        }) || s2 && !s2(_e$1(e3)) || false;
+    }
+
+    function rt(e3) {
+        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
+            r2 = t2.minDate,
+            n2 = t2.maxDate,
+            o2 = new Date(e3, 0, 1);
+        return ot(o2, {
+            minDate: r2,
+            maxDate: n2
+        }) || false;
+    }
+
+    function nt(e3, t2, r2, n2) {
+        var o2 = getYear(e3),
+            a2 = getQuarter(e3),
+            s2 = getYear(t2),
+            i2 = getQuarter(t2),
+            p2 = getYear(n2);
+        return o2 === s2 && o2 === p2 ? a2 <= r2 && r2 <= i2 : o2 < s2 ? p2 === o2 && a2 <= r2 || p2 === s2 && i2 >= r2 || p2 < s2 && p2 > o2 : void 0;
+    }
+
+    function ot(e3) {
+        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
+            r2 = t2.minDate,
+            n2 = t2.maxDate;
+        return r2 && differenceInCalendarDays(e3, r2) < 0 || n2 && differenceInCalendarDays(e3, n2) > 0;
+    }
+
+    function at(e3, t2) {
+        return t2.some(function(t3) {
+            return getHours(t3) === getHours(e3) && getMinutes(t3) === getMinutes(e3);
         });
-        var string2 = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
+    }
 
-        function createValuePattern(value, flags) {
-            flags = (flags || "").replace(/m/g, "") + "m";
-            var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
-                return properties;
-            }).replace(/<<value>>/g, function() {
-                return value;
+    function st$1(e3) {
+        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
+            r2 = t2.excludeTimes,
+            n2 = t2.includeTimes,
+            o2 = t2.filterTime;
+        return r2 && at(e3, r2) || n2 && !at(e3, n2) || o2 && !o2(e3) || false;
+    }
+
+    function it(e3, t2) {
+        var r2 = t2.minTime,
+            n2 = t2.maxTime;
+        if (!r2 || !n2)
+            throw new Error("Both minTime and maxTime props required");
+        var o2, a2 = _e$1(),
+            s2 = setHours(setMinutes(a2, getMinutes(e3)), getHours(e3)),
+            i2 = setHours(setMinutes(a2, getMinutes(r2)), getHours(r2)),
+            p2 = setHours(setMinutes(a2, getMinutes(n2)), getHours(n2));
+        try {
+            o2 = !isWithinInterval(s2, {
+                start: i2,
+                end: p2
             });
-            return RegExp(pattern, flags);
+        } catch (e4) {
+            o2 = false;
         }
-        Prism2.languages.yaml = {
-            "scalar": {
-                pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
-                    return properties;
-                })),
-                lookbehind: true,
-                alias: "string"
-            },
-            "comment": /#.*/,
-            "key": {
-                pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
-                    return properties;
-                }).replace(/<<key>>/g, function() {
-                    return "(?:" + plainKey + "|" + string2 + ")";
-                })),
-                lookbehind: true,
-                greedy: true,
-                alias: "atrule"
-            },
-            "directive": {
-                pattern: /(^[ \t]*)%.+/m,
-                lookbehind: true,
-                alias: "important"
-            },
-            "datetime": {
-                pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
-                lookbehind: true,
-                alias: "number"
-            },
-            "boolean": {
-                pattern: createValuePattern(/false|true/.source, "i"),
-                lookbehind: true,
-                alias: "important"
-            },
-            "null": {
-                pattern: createValuePattern(/null|~/.source, "i"),
-                lookbehind: true,
-                alias: "important"
-            },
-            "string": {
-                pattern: createValuePattern(string2),
-                lookbehind: true,
-                greedy: true
-            },
-            "number": {
-                pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
-                lookbehind: true
-            },
-            "tag": tag,
-            "important": anchorOrAlias,
-            "punctuation": /---|[:[\]{}\-,|>?]|\.\.\./
-        };
-        Prism2.languages.yml = Prism2.languages.yaml;
-    })(prism);
-    (function(Prism2) {
-        var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
+        return o2;
+    }
 
-        function createInline(pattern) {
-            pattern = pattern.replace(/<inner>/g, function() {
-                return inner;
+    function pt$1(e3) {
+        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
+            r2 = t2.minDate,
+            n2 = t2.includeDates,
+            o2 = subMonths(e3, 1);
+        return r2 && differenceInCalendarMonths(r2, o2) > 0 || n2 && n2.every(function(e4) {
+            return differenceInCalendarMonths(e4, o2) > 0;
+        }) || false;
+    }
+
+    function ct$1(e3) {
+        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
+            r2 = t2.maxDate,
+            n2 = t2.includeDates,
+            o2 = addMonths(e3, 1);
+        return r2 && differenceInCalendarMonths(o2, r2) > 0 || n2 && n2.every(function(e4) {
+            return differenceInCalendarMonths(o2, e4) > 0;
+        }) || false;
+    }
+
+    function lt$1(e3) {
+        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
+            r2 = t2.minDate,
+            n2 = t2.includeDates,
+            o2 = subYears(e3, 1);
+        return r2 && differenceInCalendarYears(r2, o2) > 0 || n2 && n2.every(function(e4) {
+            return differenceInCalendarYears(e4, o2) > 0;
+        }) || false;
+    }
+
+    function dt$1(e3) {
+        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
+            r2 = t2.maxDate,
+            n2 = t2.includeDates,
+            o2 = addYears(e3, 1);
+        return r2 && differenceInCalendarYears(o2, r2) > 0 || n2 && n2.every(function(e4) {
+            return differenceInCalendarYears(o2, e4) > 0;
+        }) || false;
+    }
+
+    function ut$1(e3) {
+        var t2 = e3.minDate,
+            r2 = e3.includeDates;
+        if (r2 && t2) {
+            var n2 = r2.filter(function(e4) {
+                return differenceInCalendarDays(e4, t2) >= 0;
             });
-            return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
+            return min$1(n2);
         }
-        var tableCell2 = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
-        var tableRow2 = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
-            return tableCell2;
-        });
-        var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
-        Prism2.languages.markdown = Prism2.languages.extend("markup", {});
-        Prism2.languages.insertBefore("markdown", "prolog", {
-            "front-matter-block": {
-                pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
-                lookbehind: true,
-                greedy: true,
-                inside: {
-                    "punctuation": /^---|---$/,
-                    "front-matter": {
-                        pattern: /\S+(?:\s+\S+)*/,
-                        alias: ["yaml", "language-yaml"],
-                        inside: Prism2.languages.yaml
+        return r2 ? min$1(r2) : t2;
+    }
+
+    function ht$2(e3) {
+        var t2 = e3.maxDate,
+            r2 = e3.includeDates;
+        if (r2 && t2) {
+            var n2 = r2.filter(function(e4) {
+                return differenceInCalendarDays(e4, t2) <= 0;
+            });
+            return max$2(n2);
+        }
+        return r2 ? max$2(r2) : t2;
+    }
+
+    function mt$1() {
+        for (var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "react-datepicker__day--highlighted", r2 = /* @__PURE__ */ new Map(), o2 = 0, a2 = e3.length; o2 < a2; o2++) {
+            var s2 = e3[o2];
+            if (isDate$1(s2)) {
+                var i2 = Ee$1(s2, "MM.dd.yyyy"),
+                    p2 = r2.get(i2) || [];
+                p2.includes(t2) || (p2.push(t2), r2.set(i2, p2));
+            } else if ("object" === ie$3(s2)) {
+                var c2 = Object.keys(s2),
+                    l2 = c2[0],
+                    d2 = s2[c2[0]];
+                if ("string" == typeof l2 && d2.constructor === Array)
+                    for (var u2 = 0, h2 = d2.length; u2 < h2; u2++) {
+                        var m2 = Ee$1(d2[u2], "MM.dd.yyyy"),
+                            f2 = r2.get(m2) || [];
+                        f2.includes(l2) || (f2.push(l2), r2.set(m2, f2));
                     }
+            }
+        }
+        return r2;
+    }
+
+    function ft$1(e3, t2, r2, n2, o2) {
+        for (var a2 = o2.length, p2 = [], c2 = 0; c2 < a2; c2++) {
+            var l2 = addMinutes(addHours(e3, getHours(o2[c2])), getMinutes(o2[c2])),
+                d2 = addMinutes(e3, (r2 + 1) * n2);
+            isAfter(l2, t2) && isBefore(l2, d2) && p2.push(o2[c2]);
+        }
+        return p2;
+    }
+
+    function yt(e3) {
+        return e3 < 10 ? "0".concat(e3) : "".concat(e3);
+    }
+
+    function vt(e3) {
+        var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 12,
+            r2 = Math.ceil(getYear(e3) / t2) * t2,
+            n2 = r2 - (t2 - 1);
+        return {
+            startPeriod: n2,
+            endPeriod: r2
+        };
+    }
+
+    function Dt$1(e3, t2, r2, n2) {
+        for (var o2 = [], a2 = 0; a2 < 2 * t2 + 1; a2++) {
+            var s2 = e3 + t2 - a2,
+                i2 = true;
+            r2 && (i2 = getYear(r2) <= s2), n2 && i2 && (i2 = getYear(n2) >= s2), i2 && o2.push(s2);
+        }
+        return o2;
+    }
+    var wt = onClickOutsideHOC(function(n2) {
+            he$1(a2, React__default.default.Component);
+            var o2 = De(a2);
+
+            function a2(r2) {
+                var n3;
+                pe$1(this, a2), de$1(ye(n3 = o2.call(this, r2)), "renderOptions", function() {
+                    var t2 = n3.props.year,
+                        r3 = n3.state.yearsList.map(function(r4) {
+                            return React__default.default.createElement("div", {
+                                className: t2 === r4 ? "react-datepicker__year-option react-datepicker__year-option--selected_year" : "react-datepicker__year-option",
+                                key: r4,
+                                onClick: n3.onChange.bind(ye(n3), r4),
+                                "aria-selected": t2 === r4 ? "true" : void 0
+                            }, t2 === r4 ? React__default.default.createElement("span", {
+                                className: "react-datepicker__year-option--selected"
+                            }, "\u2713") : "", r4);
+                        }),
+                        o3 = n3.props.minDate ? getYear(n3.props.minDate) : null,
+                        a3 = n3.props.maxDate ? getYear(n3.props.maxDate) : null;
+                    return a3 && n3.state.yearsList.find(function(e3) {
+                        return e3 === a3;
+                    }) || r3.unshift(React__default.default.createElement("div", {
+                        className: "react-datepicker__year-option",
+                        key: "upcoming",
+                        onClick: n3.incrementYears
+                    }, React__default.default.createElement("a", {
+                        className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-upcoming"
+                    }))), o3 && n3.state.yearsList.find(function(e3) {
+                        return e3 === o3;
+                    }) || r3.push(React__default.default.createElement("div", {
+                        className: "react-datepicker__year-option",
+                        key: "previous",
+                        onClick: n3.decrementYears
+                    }, React__default.default.createElement("a", {
+                        className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-previous"
+                    }))), r3;
+                }), de$1(ye(n3), "onChange", function(e3) {
+                    n3.props.onChange(e3);
+                }), de$1(ye(n3), "handleClickOutside", function() {
+                    n3.props.onCancel();
+                }), de$1(ye(n3), "shiftYears", function(e3) {
+                    var t2 = n3.state.yearsList.map(function(t3) {
+                        return t3 + e3;
+                    });
+                    n3.setState({
+                        yearsList: t2
+                    });
+                }), de$1(ye(n3), "incrementYears", function() {
+                    return n3.shiftYears(1);
+                }), de$1(ye(n3), "decrementYears", function() {
+                    return n3.shiftYears(-1);
+                });
+                var s2 = r2.yearDropdownItemNumber,
+                    i2 = r2.scrollableYearDropdown,
+                    p2 = s2 || (i2 ? 10 : 5);
+                return n3.state = {
+                    yearsList: Dt$1(n3.props.year, p2, n3.props.minDate, n3.props.maxDate)
+                }, n3.dropdownRef = React.createRef(), n3;
+            }
+            return le$1(a2, [{
+                key: "componentDidMount",
+                value: function() {
+                    var e3 = this.dropdownRef.current;
+                    e3 && (e3.scrollTop = e3.scrollHeight / 2 - e3.clientHeight / 2);
                 }
-            },
-            "blockquote": {
-                pattern: /^>(?:[\t ]*>)*/m,
-                alias: "punctuation"
-            },
-            "table": {
-                pattern: RegExp("^" + tableRow2 + tableLine + "(?:" + tableRow2 + ")*", "m"),
-                inside: {
-                    "table-data-rows": {
-                        pattern: RegExp("^(" + tableRow2 + tableLine + ")(?:" + tableRow2 + ")*$"),
-                        lookbehind: true,
-                        inside: {
-                            "table-data": {
-                                pattern: RegExp(tableCell2),
-                                inside: Prism2.languages.markdown
-                            },
-                            "punctuation": /\|/
-                        }
-                    },
-                    "table-line": {
-                        pattern: RegExp("^(" + tableRow2 + ")" + tableLine + "$"),
-                        lookbehind: true,
-                        inside: {
-                            "punctuation": /\||:?-{3,}:?/
+            }, {
+                key: "render",
+                value: function() {
+                    var t2 = r$1({
+                        "react-datepicker__year-dropdown": true,
+                        "react-datepicker__year-dropdown--scrollable": this.props.scrollableYearDropdown
+                    });
+                    return React__default.default.createElement("div", {
+                        className: t2,
+                        ref: this.dropdownRef
+                    }, this.renderOptions());
+                }
+            }]), a2;
+        }()),
+        gt = function(t2) {
+            he$1(n2, React__default.default.Component);
+            var r2 = De(n2);
+
+            function n2() {
+                var t3;
+                pe$1(this, n2);
+                for (var o2 = arguments.length, a2 = new Array(o2), s2 = 0; s2 < o2; s2++)
+                    a2[s2] = arguments[s2];
+                return de$1(ye(t3 = r2.call.apply(r2, [this].concat(a2))), "state", {
+                    dropdownVisible: false
+                }), de$1(ye(t3), "renderSelectOptions", function() {
+                    for (var r3 = t3.props.minDate ? getYear(t3.props.minDate) : 1900, n3 = t3.props.maxDate ? getYear(t3.props.maxDate) : 2100, o3 = [], a3 = r3; a3 <= n3; a3++)
+                        o3.push(React__default.default.createElement("option", {
+                            key: a3,
+                            value: a3
+                        }, a3));
+                    return o3;
+                }), de$1(ye(t3), "onSelectChange", function(e3) {
+                    t3.onChange(e3.target.value);
+                }), de$1(ye(t3), "renderSelectMode", function() {
+                    return React__default.default.createElement("select", {
+                        value: t3.props.year,
+                        className: "react-datepicker__year-select",
+                        onChange: t3.onSelectChange
+                    }, t3.renderSelectOptions());
+                }), de$1(ye(t3), "renderReadView", function(r3) {
+                    return React__default.default.createElement("div", {
+                        key: "read",
+                        style: {
+                            visibility: r3 ? "visible" : "hidden"
+                        },
+                        className: "react-datepicker__year-read-view",
+                        onClick: function(e3) {
+                            return t3.toggleDropdown(e3);
                         }
-                    },
-                    "table-header-row": {
-                        pattern: RegExp("^" + tableRow2 + "$"),
-                        inside: {
-                            "table-header": {
-                                pattern: RegExp(tableCell2),
-                                alias: "important",
-                                inside: Prism2.languages.markdown
-                            },
-                            "punctuation": /\|/
+                    }, React__default.default.createElement("span", {
+                        className: "react-datepicker__year-read-view--down-arrow"
+                    }), React__default.default.createElement("span", {
+                        className: "react-datepicker__year-read-view--selected-year"
+                    }, t3.props.year));
+                }), de$1(ye(t3), "renderDropdown", function() {
+                    return React__default.default.createElement(wt, {
+                        key: "dropdown",
+                        year: t3.props.year,
+                        onChange: t3.onChange,
+                        onCancel: t3.toggleDropdown,
+                        minDate: t3.props.minDate,
+                        maxDate: t3.props.maxDate,
+                        scrollableYearDropdown: t3.props.scrollableYearDropdown,
+                        yearDropdownItemNumber: t3.props.yearDropdownItemNumber
+                    });
+                }), de$1(ye(t3), "renderScrollMode", function() {
+                    var e3 = t3.state.dropdownVisible,
+                        r3 = [t3.renderReadView(!e3)];
+                    return e3 && r3.unshift(t3.renderDropdown()), r3;
+                }), de$1(ye(t3), "onChange", function(e3) {
+                    t3.toggleDropdown(), e3 !== t3.props.year && t3.props.onChange(e3);
+                }), de$1(ye(t3), "toggleDropdown", function(e3) {
+                    t3.setState({
+                        dropdownVisible: !t3.state.dropdownVisible
+                    }, function() {
+                        t3.props.adjustDateOnChange && t3.handleYearChange(t3.props.date, e3);
+                    });
+                }), de$1(ye(t3), "handleYearChange", function(e3, r3) {
+                    t3.onSelect(e3, r3), t3.setOpen();
+                }), de$1(ye(t3), "onSelect", function(e3, r3) {
+                    t3.props.onSelect && t3.props.onSelect(e3, r3);
+                }), de$1(ye(t3), "setOpen", function() {
+                    t3.props.setOpen && t3.props.setOpen(true);
+                }), t3;
+            }
+            return le$1(n2, [{
+                key: "render",
+                value: function() {
+                    var t3;
+                    switch (this.props.dropdownMode) {
+                        case "scroll":
+                            t3 = this.renderScrollMode();
+                            break;
+                        case "select":
+                            t3 = this.renderSelectMode();
+                    }
+                    return React__default.default.createElement("div", {
+                        className: "react-datepicker__year-dropdown-container react-datepicker__year-dropdown-container--".concat(this.props.dropdownMode)
+                    }, t3);
+                }
+            }]), n2;
+        }(),
+        kt$1 = onClickOutsideHOC(function(t2) {
+            he$1(n2, React__default.default.Component);
+            var r2 = De(n2);
+
+            function n2() {
+                var t3;
+                pe$1(this, n2);
+                for (var o2 = arguments.length, a2 = new Array(o2), s2 = 0; s2 < o2; s2++)
+                    a2[s2] = arguments[s2];
+                return de$1(ye(t3 = r2.call.apply(r2, [this].concat(a2))), "isSelectedMonth", function(e3) {
+                    return t3.props.month === e3;
+                }), de$1(ye(t3), "renderOptions", function() {
+                    return t3.props.monthNames.map(function(r3, n3) {
+                        return React__default.default.createElement("div", {
+                            className: t3.isSelectedMonth(n3) ? "react-datepicker__month-option react-datepicker__month-option--selected_month" : "react-datepicker__month-option",
+                            key: r3,
+                            onClick: t3.onChange.bind(ye(t3), n3),
+                            "aria-selected": t3.isSelectedMonth(n3) ? "true" : void 0
+                        }, t3.isSelectedMonth(n3) ? React__default.default.createElement("span", {
+                            className: "react-datepicker__month-option--selected"
+                        }, "\u2713") : "", r3);
+                    });
+                }), de$1(ye(t3), "onChange", function(e3) {
+                    return t3.props.onChange(e3);
+                }), de$1(ye(t3), "handleClickOutside", function() {
+                    return t3.props.onCancel();
+                }), t3;
+            }
+            return le$1(n2, [{
+                key: "render",
+                value: function() {
+                    return React__default.default.createElement("div", {
+                        className: "react-datepicker__month-dropdown"
+                    }, this.renderOptions());
+                }
+            }]), n2;
+        }()),
+        bt = function(t2) {
+            he$1(n2, React__default.default.Component);
+            var r2 = De(n2);
+
+            function n2() {
+                var t3;
+                pe$1(this, n2);
+                for (var o2 = arguments.length, a2 = new Array(o2), s2 = 0; s2 < o2; s2++)
+                    a2[s2] = arguments[s2];
+                return de$1(ye(t3 = r2.call.apply(r2, [this].concat(a2))), "state", {
+                    dropdownVisible: false
+                }), de$1(ye(t3), "renderSelectOptions", function(t4) {
+                    return t4.map(function(t5, r3) {
+                        return React__default.default.createElement("option", {
+                            key: r3,
+                            value: r3
+                        }, t5);
+                    });
+                }), de$1(ye(t3), "renderSelectMode", function(r3) {
+                    return React__default.default.createElement("select", {
+                        value: t3.props.month,
+                        className: "react-datepicker__month-select",
+                        onChange: function(e3) {
+                            return t3.onChange(e3.target.value);
                         }
+                    }, t3.renderSelectOptions(r3));
+                }), de$1(ye(t3), "renderReadView", function(r3, n3) {
+                    return React__default.default.createElement("div", {
+                        key: "read",
+                        style: {
+                            visibility: r3 ? "visible" : "hidden"
+                        },
+                        className: "react-datepicker__month-read-view",
+                        onClick: t3.toggleDropdown
+                    }, React__default.default.createElement("span", {
+                        className: "react-datepicker__month-read-view--down-arrow"
+                    }), React__default.default.createElement("span", {
+                        className: "react-datepicker__month-read-view--selected-month"
+                    }, n3[t3.props.month]));
+                }), de$1(ye(t3), "renderDropdown", function(r3) {
+                    return React__default.default.createElement(kt$1, {
+                        key: "dropdown",
+                        month: t3.props.month,
+                        monthNames: r3,
+                        onChange: t3.onChange,
+                        onCancel: t3.toggleDropdown
+                    });
+                }), de$1(ye(t3), "renderScrollMode", function(e3) {
+                    var r3 = t3.state.dropdownVisible,
+                        n3 = [t3.renderReadView(!r3, e3)];
+                    return r3 && n3.unshift(t3.renderDropdown(e3)), n3;
+                }), de$1(ye(t3), "onChange", function(e3) {
+                    t3.toggleDropdown(), e3 !== t3.props.month && t3.props.onChange(e3);
+                }), de$1(ye(t3), "toggleDropdown", function() {
+                    return t3.setState({
+                        dropdownVisible: !t3.state.dropdownVisible
+                    });
+                }), t3;
+            }
+            return le$1(n2, [{
+                key: "render",
+                value: function() {
+                    var t3, r3 = this,
+                        n3 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(this.props.useShortMonthInDropdown ? function(e3) {
+                            return ze$1(e3, r3.props.locale);
+                        } : function(e3) {
+                            return $e$1(e3, r3.props.locale);
+                        });
+                    switch (this.props.dropdownMode) {
+                        case "scroll":
+                            t3 = this.renderScrollMode(n3);
+                            break;
+                        case "select":
+                            t3 = this.renderSelectMode(n3);
                     }
+                    return React__default.default.createElement("div", {
+                        className: "react-datepicker__month-dropdown-container react-datepicker__month-dropdown-container--".concat(this.props.dropdownMode)
+                    }, t3);
                 }
-            },
-            "code": [{
-                pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
-                lookbehind: true,
-                alias: "keyword"
-            }, {
-                pattern: /^```[\s\S]*?^```$/m,
-                greedy: true,
-                inside: {
-                    "code-block": {
-                        pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
-                        lookbehind: true
-                    },
-                    "code-language": {
-                        pattern: /^(```).+/,
-                        lookbehind: true
-                    },
-                    "punctuation": /```/
+            }]), n2;
+        }();
+
+    function Ct(e3, t2) {
+        for (var r2 = [], n2 = Le$1(e3), o2 = Le$1(t2); !isAfter(n2, o2);)
+            r2.push(_e$1(n2)), n2 = addMonths(n2, 1);
+        return r2;
+    }
+    var St = onClickOutsideHOC(function(t2) {
+            he$1(o2, React__default.default.Component);
+            var n2 = De(o2);
+
+            function o2(t3) {
+                var r2;
+                return pe$1(this, o2), de$1(ye(r2 = n2.call(this, t3)), "renderOptions", function() {
+                    return r2.state.monthYearsList.map(function(t4) {
+                        var n3 = getTime(t4),
+                            o3 = Ae(r2.props.date, t4) && Be$1(r2.props.date, t4);
+                        return React__default.default.createElement("div", {
+                            className: o3 ? "react-datepicker__month-year-option--selected_month-year" : "react-datepicker__month-year-option",
+                            key: n3,
+                            onClick: r2.onChange.bind(ye(r2), n3),
+                            "aria-selected": o3 ? "true" : void 0
+                        }, o3 ? React__default.default.createElement("span", {
+                            className: "react-datepicker__month-year-option--selected"
+                        }, "\u2713") : "", Ee$1(t4, r2.props.dateFormat, r2.props.locale));
+                    });
+                }), de$1(ye(r2), "onChange", function(e3) {
+                    return r2.props.onChange(e3);
+                }), de$1(ye(r2), "handleClickOutside", function() {
+                    r2.props.onCancel();
+                }), r2.state = {
+                    monthYearsList: Ct(r2.props.minDate, r2.props.maxDate)
+                }, r2;
+            }
+            return le$1(o2, [{
+                key: "render",
+                value: function() {
+                    var t3 = r$1({
+                        "react-datepicker__month-year-dropdown": true,
+                        "react-datepicker__month-year-dropdown--scrollable": this.props.scrollableMonthYearDropdown
+                    });
+                    return React__default.default.createElement("div", {
+                        className: t3
+                    }, this.renderOptions());
                 }
-            }],
-            "title": [{
-                pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
-                alias: "important",
-                inside: {
-                    punctuation: /==+$|--+$/
+            }]), o2;
+        }()),
+        _t$1 = function(t2) {
+            he$1(n2, React__default.default.Component);
+            var r2 = De(n2);
+
+            function n2() {
+                var t3;
+                pe$1(this, n2);
+                for (var o2 = arguments.length, a2 = new Array(o2), s2 = 0; s2 < o2; s2++)
+                    a2[s2] = arguments[s2];
+                return de$1(ye(t3 = r2.call.apply(r2, [this].concat(a2))), "state", {
+                    dropdownVisible: false
+                }), de$1(ye(t3), "renderSelectOptions", function() {
+                    for (var r3 = Le$1(t3.props.minDate), n3 = Le$1(t3.props.maxDate), o3 = []; !isAfter(r3, n3);) {
+                        var a3 = getTime(r3);
+                        o3.push(React__default.default.createElement("option", {
+                            key: a3,
+                            value: a3
+                        }, Ee$1(r3, t3.props.dateFormat, t3.props.locale))), r3 = addMonths(r3, 1);
+                    }
+                    return o3;
+                }), de$1(ye(t3), "onSelectChange", function(e3) {
+                    t3.onChange(e3.target.value);
+                }), de$1(ye(t3), "renderSelectMode", function() {
+                    return React__default.default.createElement("select", {
+                        value: getTime(Le$1(t3.props.date)),
+                        className: "react-datepicker__month-year-select",
+                        onChange: t3.onSelectChange
+                    }, t3.renderSelectOptions());
+                }), de$1(ye(t3), "renderReadView", function(r3) {
+                    var n3 = Ee$1(t3.props.date, t3.props.dateFormat, t3.props.locale);
+                    return React__default.default.createElement("div", {
+                        key: "read",
+                        style: {
+                            visibility: r3 ? "visible" : "hidden"
+                        },
+                        className: "react-datepicker__month-year-read-view",
+                        onClick: function(e3) {
+                            return t3.toggleDropdown(e3);
+                        }
+                    }, React__default.default.createElement("span", {
+                        className: "react-datepicker__month-year-read-view--down-arrow"
+                    }), React__default.default.createElement("span", {
+                        className: "react-datepicker__month-year-read-view--selected-month-year"
+                    }, n3));
+                }), de$1(ye(t3), "renderDropdown", function() {
+                    return React__default.default.createElement(St, {
+                        key: "dropdown",
+                        date: t3.props.date,
+                        dateFormat: t3.props.dateFormat,
+                        onChange: t3.onChange,
+                        onCancel: t3.toggleDropdown,
+                        minDate: t3.props.minDate,
+                        maxDate: t3.props.maxDate,
+                        scrollableMonthYearDropdown: t3.props.scrollableMonthYearDropdown,
+                        locale: t3.props.locale
+                    });
+                }), de$1(ye(t3), "renderScrollMode", function() {
+                    var e3 = t3.state.dropdownVisible,
+                        r3 = [t3.renderReadView(!e3)];
+                    return e3 && r3.unshift(t3.renderDropdown()), r3;
+                }), de$1(ye(t3), "onChange", function(e3) {
+                    t3.toggleDropdown();
+                    var r3 = _e$1(parseInt(e3));
+                    Ae(t3.props.date, r3) && Be$1(t3.props.date, r3) || t3.props.onChange(r3);
+                }), de$1(ye(t3), "toggleDropdown", function() {
+                    return t3.setState({
+                        dropdownVisible: !t3.state.dropdownVisible
+                    });
+                }), t3;
+            }
+            return le$1(n2, [{
+                key: "render",
+                value: function() {
+                    var t3;
+                    switch (this.props.dropdownMode) {
+                        case "scroll":
+                            t3 = this.renderScrollMode();
+                            break;
+                        case "select":
+                            t3 = this.renderSelectMode();
+                    }
+                    return React__default.default.createElement("div", {
+                        className: "react-datepicker__month-year-dropdown-container react-datepicker__month-year-dropdown-container--".concat(this.props.dropdownMode)
+                    }, t3);
+                }
+            }]), n2;
+        }(),
+        Mt$1 = function(t2) {
+            he$1(o2, React__default.default.Component);
+            var n2 = De(o2);
+
+            function o2() {
+                var t3;
+                pe$1(this, o2);
+                for (var a2 = arguments.length, s2 = new Array(a2), i2 = 0; i2 < a2; i2++)
+                    s2[i2] = arguments[i2];
+                return de$1(ye(t3 = n2.call.apply(n2, [this].concat(s2))), "dayEl", React__default.default.createRef()), de$1(ye(t3), "handleClick", function(e3) {
+                    !t3.isDisabled() && t3.props.onClick && t3.props.onClick(e3);
+                }), de$1(ye(t3), "handleMouseEnter", function(e3) {
+                    !t3.isDisabled() && t3.props.onMouseEnter && t3.props.onMouseEnter(e3);
+                }), de$1(ye(t3), "handleOnKeyDown", function(e3) {
+                    " " === e3.key && (e3.preventDefault(), e3.key = "Enter"), t3.props.handleOnKeyDown(e3);
+                }), de$1(ye(t3), "isSameDay", function(e3) {
+                    return We$1(t3.props.day, e3);
+                }), de$1(ye(t3), "isKeyboardSelected", function() {
+                    return !t3.props.disabledKeyboardNavigation && !t3.isSameDay(t3.props.selected) && t3.isSameDay(t3.props.preSelection);
+                }), de$1(ye(t3), "isDisabled", function() {
+                    return Je$1(t3.props.day, t3.props);
+                }), de$1(ye(t3), "isExcluded", function() {
+                    return Xe(t3.props.day, t3.props);
+                }), de$1(ye(t3), "getHighLightedClass", function(e3) {
+                    var r2 = t3.props,
+                        n3 = r2.day,
+                        o3 = r2.highlightDates;
+                    if (!o3)
+                        return false;
+                    var a3 = Ee$1(n3, "MM.dd.yyyy");
+                    return o3.get(a3);
+                }), de$1(ye(t3), "isInRange", function() {
+                    var e3 = t3.props,
+                        r2 = e3.day,
+                        n3 = e3.startDate,
+                        o3 = e3.endDate;
+                    return !(!n3 || !o3) && He$1(r2, n3, o3);
+                }), de$1(ye(t3), "isInSelectingRange", function() {
+                    var e3, r2 = t3.props,
+                        n3 = r2.day,
+                        o3 = r2.selectsStart,
+                        a3 = r2.selectsEnd,
+                        s3 = r2.selectsRange,
+                        i3 = r2.selectsDisabledDaysInRange,
+                        p2 = r2.startDate,
+                        c2 = r2.endDate,
+                        l2 = null !== (e3 = t3.props.selectingDate) && void 0 !== e3 ? e3 : t3.props.preSelection;
+                    return !(!(o3 || a3 || s3) || !l2 || !i3 && t3.isDisabled()) && (o3 && c2 && (isBefore(l2, c2) || je$1(l2, c2)) ? He$1(n3, l2, c2) : (a3 && p2 && (isAfter(l2, p2) || je$1(l2, p2)) || !(!s3 || !p2 || c2 || !isAfter(l2, p2) && !je$1(l2, p2))) && He$1(n3, p2, l2));
+                }), de$1(ye(t3), "isSelectingRangeStart", function() {
+                    var e3;
+                    if (!t3.isInSelectingRange())
+                        return false;
+                    var r2 = t3.props,
+                        n3 = r2.day,
+                        o3 = r2.startDate,
+                        a3 = r2.selectsStart,
+                        s3 = null !== (e3 = t3.props.selectingDate) && void 0 !== e3 ? e3 : t3.props.preSelection;
+                    return We$1(n3, a3 ? s3 : o3);
+                }), de$1(ye(t3), "isSelectingRangeEnd", function() {
+                    var e3;
+                    if (!t3.isInSelectingRange())
+                        return false;
+                    var r2 = t3.props,
+                        n3 = r2.day,
+                        o3 = r2.endDate,
+                        a3 = r2.selectsEnd,
+                        s3 = null !== (e3 = t3.props.selectingDate) && void 0 !== e3 ? e3 : t3.props.preSelection;
+                    return We$1(n3, a3 ? s3 : o3);
+                }), de$1(ye(t3), "isRangeStart", function() {
+                    var e3 = t3.props,
+                        r2 = e3.day,
+                        n3 = e3.startDate,
+                        o3 = e3.endDate;
+                    return !(!n3 || !o3) && We$1(n3, r2);
+                }), de$1(ye(t3), "isRangeEnd", function() {
+                    var e3 = t3.props,
+                        r2 = e3.day,
+                        n3 = e3.startDate,
+                        o3 = e3.endDate;
+                    return !(!n3 || !o3) && We$1(o3, r2);
+                }), de$1(ye(t3), "isWeekend", function() {
+                    var e3 = getDay(t3.props.day);
+                    return 0 === e3 || 6 === e3;
+                }), de$1(ye(t3), "isAfterMonth", function() {
+                    return void 0 !== t3.props.month && (t3.props.month + 1) % 12 === getMonth(t3.props.day);
+                }), de$1(ye(t3), "isBeforeMonth", function() {
+                    return void 0 !== t3.props.month && (getMonth(t3.props.day) + 1) % 12 === t3.props.month;
+                }), de$1(ye(t3), "isCurrentDay", function() {
+                    return t3.isSameDay(_e$1());
+                }), de$1(ye(t3), "isSelected", function() {
+                    return t3.isSameDay(t3.props.selected);
+                }), de$1(ye(t3), "getClassNames", function(e3) {
+                    var n3 = t3.props.dayClassName ? t3.props.dayClassName(e3) : void 0;
+                    return r$1("react-datepicker__day", n3, "react-datepicker__day--" + Oe$1(t3.props.day), {
+                        "react-datepicker__day--disabled": t3.isDisabled(),
+                        "react-datepicker__day--excluded": t3.isExcluded(),
+                        "react-datepicker__day--selected": t3.isSelected(),
+                        "react-datepicker__day--keyboard-selected": t3.isKeyboardSelected(),
+                        "react-datepicker__day--range-start": t3.isRangeStart(),
+                        "react-datepicker__day--range-end": t3.isRangeEnd(),
+                        "react-datepicker__day--in-range": t3.isInRange(),
+                        "react-datepicker__day--in-selecting-range": t3.isInSelectingRange(),
+                        "react-datepicker__day--selecting-range-start": t3.isSelectingRangeStart(),
+                        "react-datepicker__day--selecting-range-end": t3.isSelectingRangeEnd(),
+                        "react-datepicker__day--today": t3.isCurrentDay(),
+                        "react-datepicker__day--weekend": t3.isWeekend(),
+                        "react-datepicker__day--outside-month": t3.isAfterMonth() || t3.isBeforeMonth()
+                    }, t3.getHighLightedClass("react-datepicker__day--highlighted"));
+                }), de$1(ye(t3), "getAriaLabel", function() {
+                    var e3 = t3.props,
+                        r2 = e3.day,
+                        n3 = e3.ariaLabelPrefixWhenEnabled,
+                        o3 = void 0 === n3 ? "Choose" : n3,
+                        a3 = e3.ariaLabelPrefixWhenDisabled,
+                        s3 = void 0 === a3 ? "Not available" : a3,
+                        i3 = t3.isDisabled() || t3.isExcluded() ? s3 : o3;
+                    return "".concat(i3, " ").concat(Ee$1(r2, "PPPP", t3.props.locale));
+                }), de$1(ye(t3), "getTabIndex", function(e3, r2) {
+                    var n3 = e3 || t3.props.selected,
+                        o3 = r2 || t3.props.preSelection;
+                    return t3.isKeyboardSelected() || t3.isSameDay(n3) && We$1(o3, n3) ? 0 : -1;
+                }), de$1(ye(t3), "handleFocusDay", function() {
+                    var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
+                        r2 = false;
+                    0 === t3.getTabIndex() && !e3.isInputFocused && t3.isSameDay(t3.props.preSelection) && (document.activeElement && document.activeElement !== document.body || (r2 = true), t3.props.inline && !t3.props.shouldFocusDayInline && (r2 = false), t3.props.containerRef && t3.props.containerRef.current && t3.props.containerRef.current.contains(document.activeElement) && document.activeElement.classList.contains("react-datepicker__day") && (r2 = true)), r2 && t3.dayEl.current.focus({
+                        preventScroll: true
+                    });
+                }), de$1(ye(t3), "renderDayContents", function() {
+                    return t3.props.monthShowsDuplicateDaysEnd && t3.isAfterMonth() || t3.props.monthShowsDuplicateDaysStart && t3.isBeforeMonth() ? null : t3.props.renderDayContents ? t3.props.renderDayContents(getDate(t3.props.day), t3.props.day) : getDate(t3.props.day);
+                }), de$1(ye(t3), "render", function() {
+                    return React__default.default.createElement("div", {
+                        ref: t3.dayEl,
+                        className: t3.getClassNames(t3.props.day),
+                        onKeyDown: t3.handleOnKeyDown,
+                        onClick: t3.handleClick,
+                        onMouseEnter: t3.handleMouseEnter,
+                        tabIndex: t3.getTabIndex(),
+                        "aria-label": t3.getAriaLabel(),
+                        role: "option",
+                        "aria-disabled": t3.isDisabled(),
+                        "aria-current": t3.isCurrentDay() ? "date" : void 0,
+                        "aria-selected": t3.isSelected()
+                    }, t3.renderDayContents());
+                }), t3;
+            }
+            return le$1(o2, [{
+                key: "componentDidMount",
+                value: function() {
+                    this.handleFocusDay();
                 }
             }, {
-                pattern: /(^\s*)#.+/m,
-                lookbehind: true,
-                alias: "important",
-                inside: {
-                    punctuation: /^#+|#+$/
+                key: "componentDidUpdate",
+                value: function(e3) {
+                    this.handleFocusDay(e3);
                 }
-            }],
-            "hr": {
-                pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
-                lookbehind: true,
-                alias: "punctuation"
-            },
-            "list": {
-                pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
-                lookbehind: true,
-                alias: "punctuation"
-            },
-            "url-reference": {
-                pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
-                inside: {
-                    "variable": {
-                        pattern: /^(!?\[)[^\]]+/,
-                        lookbehind: true
-                    },
-                    "string": /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
-                    "punctuation": /^[\[\]!:]|[<>]/
-                },
-                alias: "url"
-            },
-            "bold": {
-                pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
-                lookbehind: true,
-                greedy: true,
-                inside: {
-                    "content": {
-                        pattern: /(^..)[\s\S]+(?=..$)/,
-                        lookbehind: true,
-                        inside: {}
-                    },
-                    "punctuation": /\*\*|__/
+            }]), o2;
+        }(),
+        Pt$1 = function(t2) {
+            he$1(o2, React__default.default.Component);
+            var n2 = De(o2);
+
+            function o2() {
+                var e3;
+                pe$1(this, o2);
+                for (var t3 = arguments.length, r2 = new Array(t3), a2 = 0; a2 < t3; a2++)
+                    r2[a2] = arguments[a2];
+                return de$1(ye(e3 = n2.call.apply(n2, [this].concat(r2))), "handleClick", function(t4) {
+                    e3.props.onClick && e3.props.onClick(t4);
+                }), e3;
+            }
+            return le$1(o2, [{
+                key: "render",
+                value: function() {
+                    var t3 = this.props,
+                        n3 = t3.weekNumber,
+                        o3 = t3.ariaLabelPrefix,
+                        a2 = void 0 === o3 ? "week " : o3,
+                        s2 = {
+                            "react-datepicker__week-number": true,
+                            "react-datepicker__week-number--clickable": !!t3.onClick
+                        };
+                    return React__default.default.createElement("div", {
+                        className: r$1(s2),
+                        "aria-label": "".concat(a2, " ").concat(this.props.weekNumber),
+                        onClick: this.handleClick
+                    }, n3);
                 }
-            },
-            "italic": {
-                pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
-                lookbehind: true,
-                greedy: true,
-                inside: {
-                    "content": {
-                        pattern: /(^.)[\s\S]+(?=.$)/,
-                        lookbehind: true,
-                        inside: {}
-                    },
-                    "punctuation": /[*_]/
+            }]), o2;
+        }(),
+        Et$1 = function(t2) {
+            he$1(n2, React__default.default.Component);
+            var r2 = De(n2);
+
+            function n2() {
+                var t3;
+                pe$1(this, n2);
+                for (var o2 = arguments.length, a2 = new Array(o2), s2 = 0; s2 < o2; s2++)
+                    a2[s2] = arguments[s2];
+                return de$1(ye(t3 = r2.call.apply(r2, [this].concat(a2))), "handleDayClick", function(e3, r3) {
+                    t3.props.onDayClick && t3.props.onDayClick(e3, r3);
+                }), de$1(ye(t3), "handleDayMouseEnter", function(e3) {
+                    t3.props.onDayMouseEnter && t3.props.onDayMouseEnter(e3);
+                }), de$1(ye(t3), "handleWeekClick", function(e3, r3, n3) {
+                    "function" == typeof t3.props.onWeekSelect && t3.props.onWeekSelect(e3, r3, n3), t3.props.shouldCloseOnSelect && t3.props.setOpen(false);
+                }), de$1(ye(t3), "formatWeekNumber", function(e3) {
+                    return t3.props.formatWeekNumber ? t3.props.formatWeekNumber(e3) : Ye$1(e3);
+                }), de$1(ye(t3), "renderDays", function() {
+                    var r3 = Te(t3.props.day, t3.props.locale, t3.props.calendarStartDay),
+                        n3 = [],
+                        o3 = t3.formatWeekNumber(r3);
+                    if (t3.props.showWeekNumber) {
+                        var a3 = t3.props.onWeekSelect ? t3.handleWeekClick.bind(ye(t3), r3, o3) : void 0;
+                        n3.push(React__default.default.createElement(Pt$1, {
+                            key: "W",
+                            weekNumber: o3,
+                            onClick: a3,
+                            ariaLabelPrefix: t3.props.ariaLabelPrefix
+                        }));
+                    }
+                    return n3.concat([0, 1, 2, 3, 4, 5, 6].map(function(n4) {
+                        var o4 = addDays(r3, n4);
+                        return React__default.default.createElement(Mt$1, {
+                            ariaLabelPrefixWhenEnabled: t3.props.chooseDayAriaLabelPrefix,
+                            ariaLabelPrefixWhenDisabled: t3.props.disabledDayAriaLabelPrefix,
+                            key: o4.valueOf(),
+                            day: o4,
+                            month: t3.props.month,
+                            onClick: t3.handleDayClick.bind(ye(t3), o4),
+                            onMouseEnter: t3.handleDayMouseEnter.bind(ye(t3), o4),
+                            minDate: t3.props.minDate,
+                            maxDate: t3.props.maxDate,
+                            excludeDates: t3.props.excludeDates,
+                            excludeDateIntervals: t3.props.excludeDateIntervals,
+                            includeDates: t3.props.includeDates,
+                            includeDateIntervals: t3.props.includeDateIntervals,
+                            highlightDates: t3.props.highlightDates,
+                            selectingDate: t3.props.selectingDate,
+                            filterDate: t3.props.filterDate,
+                            preSelection: t3.props.preSelection,
+                            selected: t3.props.selected,
+                            selectsStart: t3.props.selectsStart,
+                            selectsEnd: t3.props.selectsEnd,
+                            selectsRange: t3.props.selectsRange,
+                            selectsDisabledDaysInRange: t3.props.selectsDisabledDaysInRange,
+                            startDate: t3.props.startDate,
+                            endDate: t3.props.endDate,
+                            dayClassName: t3.props.dayClassName,
+                            renderDayContents: t3.props.renderDayContents,
+                            disabledKeyboardNavigation: t3.props.disabledKeyboardNavigation,
+                            handleOnKeyDown: t3.props.handleOnKeyDown,
+                            isInputFocused: t3.props.isInputFocused,
+                            containerRef: t3.props.containerRef,
+                            inline: t3.props.inline,
+                            shouldFocusDayInline: t3.props.shouldFocusDayInline,
+                            monthShowsDuplicateDaysEnd: t3.props.monthShowsDuplicateDaysEnd,
+                            monthShowsDuplicateDaysStart: t3.props.monthShowsDuplicateDaysStart,
+                            locale: t3.props.locale
+                        });
+                    }));
+                }), t3;
+            }
+            return le$1(n2, [{
+                key: "render",
+                value: function() {
+                    return React__default.default.createElement("div", {
+                        className: "react-datepicker__week"
+                    }, this.renderDays());
                 }
-            },
-            "strike": {
-                pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
-                lookbehind: true,
-                greedy: true,
-                inside: {
-                    "content": {
-                        pattern: /(^~~?)[\s\S]+(?=\1$)/,
-                        lookbehind: true,
-                        inside: {}
-                    },
-                    "punctuation": /~~?/
+            }], [{
+                key: "defaultProps",
+                get: function() {
+                    return {
+                        shouldCloseOnSelect: true
+                    };
                 }
-            },
-            "code-snippet": {
-                pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
-                lookbehind: true,
-                greedy: true,
-                alias: ["code", "keyword"]
-            },
-            "url": {
-                pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
-                lookbehind: true,
-                greedy: true,
-                inside: {
-                    "operator": /^!/,
-                    "content": {
-                        pattern: /(^\[)[^\]]+(?=\])/,
-                        lookbehind: true,
-                        inside: {}
-                    },
-                    "variable": {
-                        pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
-                        lookbehind: true
-                    },
-                    "url": {
-                        pattern: /(^\]\()[^\s)]+/,
-                        lookbehind: true
-                    },
-                    "string": {
-                        pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
-                        lookbehind: true
+            }]), n2;
+        }(),
+        Nt = function(t2) {
+            he$1(o2, React__default.default.Component);
+            var n2 = De(o2);
+
+            function o2() {
+                var t3;
+                pe$1(this, o2);
+                for (var a2 = arguments.length, s2 = new Array(a2), i2 = 0; i2 < a2; i2++)
+                    s2[i2] = arguments[i2];
+                return de$1(ye(t3 = n2.call.apply(n2, [this].concat(s2))), "MONTH_REFS", we$1(Array(12)).map(function() {
+                    return React__default.default.createRef();
+                })), de$1(ye(t3), "isDisabled", function(e3) {
+                    return Je$1(e3, t3.props);
+                }), de$1(ye(t3), "isExcluded", function(e3) {
+                    return Xe(e3, t3.props);
+                }), de$1(ye(t3), "handleDayClick", function(e3, r2) {
+                    t3.props.onDayClick && t3.props.onDayClick(e3, r2, t3.props.orderInDisplay);
+                }), de$1(ye(t3), "handleDayMouseEnter", function(e3) {
+                    t3.props.onDayMouseEnter && t3.props.onDayMouseEnter(e3);
+                }), de$1(ye(t3), "handleMouseLeave", function() {
+                    t3.props.onMouseLeave && t3.props.onMouseLeave();
+                }), de$1(ye(t3), "isRangeStartMonth", function(e3) {
+                    var r2 = t3.props,
+                        n3 = r2.day,
+                        o3 = r2.startDate,
+                        a3 = r2.endDate;
+                    return !(!o3 || !a3) && Be$1(setMonth(n3, e3), o3);
+                }), de$1(ye(t3), "isRangeStartQuarter", function(e3) {
+                    var r2 = t3.props,
+                        n3 = r2.day,
+                        o3 = r2.startDate,
+                        a3 = r2.endDate;
+                    return !(!o3 || !a3) && Ke$1(setQuarter(n3, e3), o3);
+                }), de$1(ye(t3), "isRangeEndMonth", function(e3) {
+                    var r2 = t3.props,
+                        n3 = r2.day,
+                        o3 = r2.startDate,
+                        a3 = r2.endDate;
+                    return !(!o3 || !a3) && Be$1(setMonth(n3, e3), a3);
+                }), de$1(ye(t3), "isRangeEndQuarter", function(e3) {
+                    var r2 = t3.props,
+                        n3 = r2.day,
+                        o3 = r2.startDate,
+                        a3 = r2.endDate;
+                    return !(!o3 || !a3) && Ke$1(setQuarter(n3, e3), a3);
+                }), de$1(ye(t3), "isWeekInMonth", function(e3) {
+                    var r2 = t3.props.day,
+                        n3 = addDays(e3, 6);
+                    return Be$1(e3, r2) || Be$1(n3, r2);
+                }), de$1(ye(t3), "isCurrentMonth", function(e3, t4) {
+                    return getYear(e3) === getYear(_e$1()) && t4 === getMonth(_e$1());
+                }), de$1(ye(t3), "isSelectedMonth", function(e3, t4, r2) {
+                    return getMonth(e3) === t4 && getYear(e3) === getYear(r2);
+                }), de$1(ye(t3), "isSelectedQuarter", function(e3, t4, r2) {
+                    return getQuarter(e3) === t4 && getYear(e3) === getYear(r2);
+                }), de$1(ye(t3), "renderWeeks", function() {
+                    for (var r2 = [], n3 = t3.props.fixedHeight, o3 = 0, a3 = false, s3 = Te(Le$1(t3.props.day), t3.props.locale, t3.props.calendarStartDay); r2.push(React__default.default.createElement(Et$1, {
+                            ariaLabelPrefix: t3.props.weekAriaLabelPrefix,
+                            chooseDayAriaLabelPrefix: t3.props.chooseDayAriaLabelPrefix,
+                            disabledDayAriaLabelPrefix: t3.props.disabledDayAriaLabelPrefix,
+                            key: o3,
+                            day: s3,
+                            month: getMonth(t3.props.day),
+                            onDayClick: t3.handleDayClick,
+                            onDayMouseEnter: t3.handleDayMouseEnter,
+                            onWeekSelect: t3.props.onWeekSelect,
+                            formatWeekNumber: t3.props.formatWeekNumber,
+                            locale: t3.props.locale,
+                            minDate: t3.props.minDate,
+                            maxDate: t3.props.maxDate,
+                            excludeDates: t3.props.excludeDates,
+                            excludeDateIntervals: t3.props.excludeDateIntervals,
+                            includeDates: t3.props.includeDates,
+                            includeDateIntervals: t3.props.includeDateIntervals,
+                            inline: t3.props.inline,
+                            shouldFocusDayInline: t3.props.shouldFocusDayInline,
+                            highlightDates: t3.props.highlightDates,
+                            selectingDate: t3.props.selectingDate,
+                            filterDate: t3.props.filterDate,
+                            preSelection: t3.props.preSelection,
+                            selected: t3.props.selected,
+                            selectsStart: t3.props.selectsStart,
+                            selectsEnd: t3.props.selectsEnd,
+                            selectsRange: t3.props.selectsRange,
+                            selectsDisabledDaysInRange: t3.props.selectsDisabledDaysInRange,
+                            showWeekNumber: t3.props.showWeekNumbers,
+                            startDate: t3.props.startDate,
+                            endDate: t3.props.endDate,
+                            dayClassName: t3.props.dayClassName,
+                            setOpen: t3.props.setOpen,
+                            shouldCloseOnSelect: t3.props.shouldCloseOnSelect,
+                            disabledKeyboardNavigation: t3.props.disabledKeyboardNavigation,
+                            renderDayContents: t3.props.renderDayContents,
+                            handleOnKeyDown: t3.props.handleOnKeyDown,
+                            isInputFocused: t3.props.isInputFocused,
+                            containerRef: t3.props.containerRef,
+                            calendarStartDay: t3.props.calendarStartDay,
+                            monthShowsDuplicateDaysEnd: t3.props.monthShowsDuplicateDaysEnd,
+                            monthShowsDuplicateDaysStart: t3.props.monthShowsDuplicateDaysStart
+                        })), !a3;) {
+                        o3++, s3 = addWeeks(s3, 1);
+                        var i3 = n3 && o3 >= 6,
+                            p2 = !n3 && !t3.isWeekInMonth(s3);
+                        if (i3 || p2) {
+                            if (!t3.props.peekNextMonth)
+                                break;
+                            a3 = true;
+                        }
                     }
-                }
+                    return r2;
+                }), de$1(ye(t3), "onMonthClick", function(e3, r2) {
+                    t3.handleDayClick(Le$1(setMonth(t3.props.day, r2)), e3);
+                }), de$1(ye(t3), "handleMonthNavigation", function(e3, r2) {
+                    t3.isDisabled(r2) || t3.isExcluded(r2) || (t3.props.setPreSelection(r2), t3.MONTH_REFS[e3].current && t3.MONTH_REFS[e3].current.focus());
+                }), de$1(ye(t3), "onMonthKeyDown", function(e3, r2) {
+                    var n3 = e3.key;
+                    if (!t3.props.disabledKeyboardNavigation)
+                        switch (n3) {
+                            case "Enter":
+                                t3.onMonthClick(e3, r2), t3.props.setPreSelection(t3.props.selected);
+                                break;
+                            case "ArrowRight":
+                                t3.handleMonthNavigation(11 === r2 ? 0 : r2 + 1, addMonths(t3.props.preSelection, 1));
+                                break;
+                            case "ArrowLeft":
+                                t3.handleMonthNavigation(0 === r2 ? 11 : r2 - 1, subMonths(t3.props.preSelection, 1));
+                        }
+                }), de$1(ye(t3), "onQuarterClick", function(e3, r2) {
+                    t3.handleDayClick(Fe$1(setQuarter(t3.props.day, r2)), e3);
+                }), de$1(ye(t3), "getMonthClassNames", function(e3) {
+                    var n3 = t3.props,
+                        o3 = n3.day,
+                        a3 = n3.startDate,
+                        s3 = n3.endDate,
+                        i3 = n3.selected,
+                        p2 = n3.minDate,
+                        c2 = n3.maxDate,
+                        l2 = n3.preSelection,
+                        d2 = n3.monthClassName,
+                        u2 = d2 ? d2(o3) : void 0;
+                    return r$1("react-datepicker__month-text", "react-datepicker__month-".concat(e3), u2, {
+                        "react-datepicker__month--disabled": (p2 || c2) && Ze$1(setMonth(o3, e3), t3.props),
+                        "react-datepicker__month--selected": t3.isSelectedMonth(o3, e3, i3),
+                        "react-datepicker__month-text--keyboard-selected": getMonth(l2) === e3,
+                        "react-datepicker__month--in-range": et$1(a3, s3, e3, o3),
+                        "react-datepicker__month--range-start": t3.isRangeStartMonth(e3),
+                        "react-datepicker__month--range-end": t3.isRangeEndMonth(e3),
+                        "react-datepicker__month-text--today": t3.isCurrentMonth(o3, e3)
+                    });
+                }), de$1(ye(t3), "getTabIndex", function(e3) {
+                    var r2 = getMonth(t3.props.preSelection);
+                    return t3.props.disabledKeyboardNavigation || e3 !== r2 ? "-1" : "0";
+                }), de$1(ye(t3), "getAriaLabel", function(e3) {
+                    var r2 = t3.props,
+                        n3 = r2.chooseDayAriaLabelPrefix,
+                        o3 = void 0 === n3 ? "Choose" : n3,
+                        a3 = r2.disabledDayAriaLabelPrefix,
+                        s3 = void 0 === a3 ? "Not available" : a3,
+                        i3 = r2.day,
+                        p2 = setMonth(i3, e3),
+                        c2 = t3.isDisabled(p2) || t3.isExcluded(p2) ? s3 : o3;
+                    return "".concat(c2, " ").concat(Ee$1(p2, "MMMM yyyy"));
+                }), de$1(ye(t3), "getQuarterClassNames", function(e3) {
+                    var n3 = t3.props,
+                        o3 = n3.day,
+                        a3 = n3.startDate,
+                        s3 = n3.endDate,
+                        i3 = n3.selected,
+                        p2 = n3.minDate,
+                        c2 = n3.maxDate;
+                    return r$1("react-datepicker__quarter-text", "react-datepicker__quarter-".concat(e3), {
+                        "react-datepicker__quarter--disabled": (p2 || c2) && tt$1(setQuarter(o3, e3), t3.props),
+                        "react-datepicker__quarter--selected": t3.isSelectedQuarter(o3, e3, i3),
+                        "react-datepicker__quarter--in-range": nt(a3, s3, e3, o3),
+                        "react-datepicker__quarter--range-start": t3.isRangeStartQuarter(e3),
+                        "react-datepicker__quarter--range-end": t3.isRangeEndQuarter(e3)
+                    });
+                }), de$1(ye(t3), "renderMonths", function() {
+                    var r2 = t3.props,
+                        n3 = r2.showFullMonthYearPicker,
+                        o3 = r2.showTwoColumnMonthYearPicker,
+                        a3 = r2.showFourColumnMonthYearPicker,
+                        s3 = r2.locale,
+                        i3 = r2.day,
+                        p2 = r2.selected;
+                    return (a3 ? [
+                        [0, 1, 2, 3],
+                        [4, 5, 6, 7],
+                        [8, 9, 10, 11]
+                    ] : o3 ? [
+                        [0, 1],
+                        [2, 3],
+                        [4, 5],
+                        [6, 7],
+                        [8, 9],
+                        [10, 11]
+                    ] : [
+                        [0, 1, 2],
+                        [3, 4, 5],
+                        [6, 7, 8],
+                        [9, 10, 11]
+                    ]).map(function(r3, o4) {
+                        return React__default.default.createElement("div", {
+                            className: "react-datepicker__month-wrapper",
+                            key: o4
+                        }, r3.map(function(r4, o5) {
+                            return React__default.default.createElement("div", {
+                                ref: t3.MONTH_REFS[r4],
+                                key: o5,
+                                onClick: function(e3) {
+                                    t3.onMonthClick(e3, r4);
+                                },
+                                onKeyDown: function(e3) {
+                                    t3.onMonthKeyDown(e3, r4);
+                                },
+                                tabIndex: t3.getTabIndex(r4),
+                                className: t3.getMonthClassNames(r4),
+                                role: "option",
+                                "aria-label": t3.getAriaLabel(r4),
+                                "aria-current": t3.isCurrentMonth(i3, r4) ? "date" : void 0,
+                                "aria-selected": t3.isSelectedMonth(i3, r4, p2)
+                            }, n3 ? $e$1(r4, s3) : ze$1(r4, s3));
+                        }));
+                    });
+                }), de$1(ye(t3), "renderQuarters", function() {
+                    var r2 = t3.props,
+                        n3 = r2.day,
+                        o3 = r2.selected;
+                    return React__default.default.createElement("div", {
+                        className: "react-datepicker__quarter-wrapper"
+                    }, [1, 2, 3, 4].map(function(r3, a3) {
+                        return React__default.default.createElement("div", {
+                            key: a3,
+                            role: "option",
+                            onClick: function(e3) {
+                                t3.onQuarterClick(e3, r3);
+                            },
+                            className: t3.getQuarterClassNames(r3),
+                            "aria-selected": t3.isSelectedQuarter(n3, r3, o3)
+                        }, Ge$1(r3, t3.props.locale));
+                    }));
+                }), de$1(ye(t3), "getClassNames", function() {
+                    var e3 = t3.props;
+                    e3.day;
+                    var n3 = e3.selectingDate,
+                        o3 = e3.selectsStart,
+                        a3 = e3.selectsEnd,
+                        s3 = e3.showMonthYearPicker,
+                        i3 = e3.showQuarterYearPicker;
+                    return r$1("react-datepicker__month", {
+                        "react-datepicker__month--selecting-range": n3 && (o3 || a3)
+                    }, {
+                        "react-datepicker__monthPicker": s3
+                    }, {
+                        "react-datepicker__quarterPicker": i3
+                    });
+                }), t3;
             }
-        });
-        ["url", "bold", "italic", "strike"].forEach(function(token) {
-            ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside2) {
-                if (token !== inside2) {
-                    Prism2.languages.markdown[token].inside.content.inside[inside2] = Prism2.languages.markdown[inside2];
+            return le$1(o2, [{
+                key: "render",
+                value: function() {
+                    var t3 = this.props,
+                        r2 = t3.showMonthYearPicker,
+                        n3 = t3.showQuarterYearPicker,
+                        o3 = t3.day,
+                        a2 = t3.ariaLabelPrefix,
+                        s2 = void 0 === a2 ? "month " : a2;
+                    return React__default.default.createElement("div", {
+                        className: this.getClassNames(),
+                        onMouseLeave: this.handleMouseLeave,
+                        "aria-label": "".concat(s2, " ").concat(Ee$1(o3, "yyyy-MM")),
+                        role: "listbox"
+                    }, r2 ? this.renderMonths() : n3 ? this.renderQuarters() : this.renderWeeks());
                 }
-            });
-        });
-        Prism2.hooks.add("after-tokenize", function(env2) {
-            if (env2.language !== "markdown" && env2.language !== "md") {
-                return;
-            }
+            }]), o2;
+        }(),
+        xt = function(t2) {
+            he$1(n2, React__default.default.Component);
+            var r2 = De(n2);
 
-            function walkTokens(tokens2) {
-                if (!tokens2 || typeof tokens2 === "string") {
-                    return;
-                }
-                for (var i2 = 0, l2 = tokens2.length; i2 < l2; i2++) {
-                    var token = tokens2[i2];
-                    if (token.type !== "code") {
-                        walkTokens(token.content);
-                        continue;
-                    }
-                    var codeLang = token.content[1];
-                    var codeBlock = token.content[3];
-                    if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
-                        var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
-                        lang = (/[a-z][\w-]*/i.exec(lang) || [""])[0].toLowerCase();
-                        var alias = "language-" + lang;
-                        if (!codeBlock.alias) {
-                            codeBlock.alias = [alias];
-                        } else if (typeof codeBlock.alias === "string") {
-                            codeBlock.alias = [codeBlock.alias, alias];
-                        } else {
-                            codeBlock.alias.push(alias);
+            function n2() {
+                var t3;
+                pe$1(this, n2);
+                for (var o2 = arguments.length, a2 = new Array(o2), i2 = 0; i2 < o2; i2++)
+                    a2[i2] = arguments[i2];
+                return de$1(ye(t3 = r2.call.apply(r2, [this].concat(a2))), "state", {
+                    height: null
+                }), de$1(ye(t3), "handleClick", function(e3) {
+                    (t3.props.minTime || t3.props.maxTime) && it(e3, t3.props) || (t3.props.excludeTimes || t3.props.includeTimes || t3.props.filterTime) && st$1(e3, t3.props) || t3.props.onChange(e3);
+                }), de$1(ye(t3), "isSelectedTime", function(e3, r3, n3) {
+                    return t3.props.selected && r3 === getHours(e3) && n3 === getMinutes(e3);
+                }), de$1(ye(t3), "liClasses", function(e3, r3, n3) {
+                    var o3 = ["react-datepicker__time-list-item", t3.props.timeClassName ? t3.props.timeClassName(e3, r3, n3) : void 0];
+                    return t3.isSelectedTime(e3, r3, n3) && o3.push("react-datepicker__time-list-item--selected"), ((t3.props.minTime || t3.props.maxTime) && it(e3, t3.props) || (t3.props.excludeTimes || t3.props.includeTimes || t3.props.filterTime) && st$1(e3, t3.props)) && o3.push("react-datepicker__time-list-item--disabled"), t3.props.injectTimes && (60 * getHours(e3) + getMinutes(e3)) % t3.props.intervals != 0 && o3.push("react-datepicker__time-list-item--injected"), o3.join(" ");
+                }), de$1(ye(t3), "handleOnKeyDown", function(e3, r3) {
+                    " " === e3.key && (e3.preventDefault(), e3.key = "Enter"), "Enter" === e3.key && t3.handleClick(r3), t3.props.handleOnKeyDown(e3);
+                }), de$1(ye(t3), "renderTimes", function() {
+                    for (var r3 = [], n3 = t3.props.format ? t3.props.format : "p", o3 = t3.props.intervals, a3 = Ie$1(_e$1(t3.props.selected)), i3 = 1440 / o3, p2 = t3.props.injectTimes && t3.props.injectTimes.sort(function(e3, t4) {
+                            return e3 - t4;
+                        }), c2 = t3.props.selected || t3.props.openToDate || _e$1(), l2 = getHours(c2), d2 = getMinutes(c2), u2 = setHours(setMinutes(a3, d2), l2), h2 = 0; h2 < i3; h2++) {
+                        var m2 = addMinutes(a3, h2 * o3);
+                        if (r3.push(m2), p2) {
+                            var f2 = ft$1(a3, m2, h2, o3, p2);
+                            r3 = r3.concat(f2);
                         }
                     }
-                }
-            }
-            walkTokens(env2.tokens);
-        });
-        Prism2.hooks.add("wrap", function(env2) {
-            if (env2.type !== "code-block") {
-                return;
+                    return r3.map(function(r4, o4) {
+                        return React__default.default.createElement("li", {
+                            key: o4,
+                            onClick: t3.handleClick.bind(ye(t3), r4),
+                            className: t3.liClasses(r4, l2, d2),
+                            ref: function(e3) {
+                                (isBefore(r4, u2) || je$1(r4, u2)) && (t3.centerLi = e3);
+                            },
+                            onKeyDown: function(e3) {
+                                t3.handleOnKeyDown(e3, r4);
+                            },
+                            tabIndex: "0",
+                            "aria-selected": t3.isSelectedTime(r4, l2, d2) ? "true" : void 0
+                        }, Ee$1(r4, n3, t3.props.locale));
+                    });
+                }), t3;
             }
-            var codeLang = "";
-            for (var i2 = 0, l2 = env2.classes.length; i2 < l2; i2++) {
-                var cls = env2.classes[i2];
-                var match2 = /language-(.+)/.exec(cls);
-                if (match2) {
-                    codeLang = match2[1];
-                    break;
+            return le$1(n2, [{
+                key: "componentDidMount",
+                value: function() {
+                    this.list.scrollTop = n2.calcCenterPosition(this.props.monthRef ? this.props.monthRef.clientHeight - this.header.clientHeight : this.list.clientHeight, this.centerLi), this.props.monthRef && this.header && this.setState({
+                        height: this.props.monthRef.clientHeight - this.header.clientHeight
+                    });
                 }
-            }
-            var grammar = Prism2.languages[codeLang];
-            if (!grammar) {
-                if (codeLang && codeLang !== "none" && Prism2.plugins.autoloader) {
-                    var id2 = "md-" + new Date().valueOf() + "-" + Math.floor(Math.random() * 1e16);
-                    env2.attributes["id"] = id2;
-                    Prism2.plugins.autoloader.loadLanguages(codeLang, function() {
-                        var ele = document.getElementById(id2);
-                        if (ele) {
-                            ele.innerHTML = Prism2.highlight(ele.textContent, Prism2.languages[codeLang], codeLang);
+            }, {
+                key: "render",
+                value: function() {
+                    var t3 = this,
+                        r3 = this.state.height;
+                    return React__default.default.createElement("div", {
+                        className: "react-datepicker__time-container ".concat(this.props.todayButton ? "react-datepicker__time-container--with-today-button" : "")
+                    }, React__default.default.createElement("div", {
+                        className: "react-datepicker__header react-datepicker__header--time ".concat(this.props.showTimeSelectOnly ? "react-datepicker__header--time--only" : ""),
+                        ref: function(e3) {
+                            t3.header = e3;
+                        }
+                    }, React__default.default.createElement("div", {
+                        className: "react-datepicker-time__header"
+                    }, this.props.timeCaption)), React__default.default.createElement("div", {
+                        className: "react-datepicker__time"
+                    }, React__default.default.createElement("div", {
+                        className: "react-datepicker__time-box"
+                    }, React__default.default.createElement("ul", {
+                        className: "react-datepicker__time-list",
+                        ref: function(e3) {
+                            t3.list = e3;
+                        },
+                        style: r3 ? {
+                            height: r3
+                        } : {},
+                        tabIndex: "0"
+                    }, this.renderTimes()))));
+                }
+            }], [{
+                key: "defaultProps",
+                get: function() {
+                    return {
+                        intervals: 30,
+                        onTimeChange: function() {},
+                        todayButton: null,
+                        timeCaption: "Time"
+                    };
+                }
+            }]), n2;
+        }();
+    de$1(xt, "calcCenterPosition", function(e3, t2) {
+        return t2.offsetTop - (e3 / 2 - t2.clientHeight / 2);
+    });
+    var Yt$1 = function(t2) {
+            he$1(o2, React__default.default.Component);
+            var n2 = De(o2);
+
+            function o2(t3) {
+                var a2;
+                return pe$1(this, o2), de$1(ye(a2 = n2.call(this, t3)), "YEAR_REFS", we$1(Array(a2.props.yearItemNumber)).map(function() {
+                    return React__default.default.createRef();
+                })), de$1(ye(a2), "isDisabled", function(e3) {
+                    return Je$1(e3, a2.props);
+                }), de$1(ye(a2), "isExcluded", function(e3) {
+                    return Xe(e3, a2.props);
+                }), de$1(ye(a2), "updateFocusOnPaginate", function(e3) {
+                    var t4 = function() {
+                        this.YEAR_REFS[e3].current.focus();
+                    }.bind(ye(a2));
+                    window.requestAnimationFrame(t4);
+                }), de$1(ye(a2), "handleYearClick", function(e3, t4) {
+                    a2.props.onDayClick && a2.props.onDayClick(e3, t4);
+                }), de$1(ye(a2), "handleYearNavigation", function(e3, t4) {
+                    var r2 = a2.props,
+                        n3 = r2.date,
+                        o3 = r2.yearItemNumber,
+                        s2 = vt(n3, o3).startPeriod;
+                    a2.isDisabled(t4) || a2.isExcluded(t4) || (a2.props.setPreSelection(t4), e3 - s2 == -1 ? a2.updateFocusOnPaginate(o3 - 1) : e3 - s2 === o3 ? a2.updateFocusOnPaginate(0) : a2.YEAR_REFS[e3 - s2].current.focus());
+                }), de$1(ye(a2), "isSameDay", function(e3, t4) {
+                    return We$1(e3, t4);
+                }), de$1(ye(a2), "isCurrentYear", function(e3) {
+                    return e3 === getYear(_e$1());
+                }), de$1(ye(a2), "isKeyboardSelected", function(e3) {
+                    var t4 = Re$1(setYear(a2.props.date, e3));
+                    return !a2.props.disabledKeyboardNavigation && !a2.props.inline && !We$1(t4, Re$1(a2.props.selected)) && We$1(t4, Re$1(a2.props.preSelection));
+                }), de$1(ye(a2), "onYearClick", function(e3, t4) {
+                    var r2 = a2.props.date;
+                    a2.handleYearClick(Re$1(setYear(r2, t4)), e3);
+                }), de$1(ye(a2), "onYearKeyDown", function(e3, t4) {
+                    var r2 = e3.key;
+                    if (!a2.props.disabledKeyboardNavigation)
+                        switch (r2) {
+                            case "Enter":
+                                a2.onYearClick(e3, t4), a2.props.setPreSelection(a2.props.selected);
+                                break;
+                            case "ArrowRight":
+                                a2.handleYearNavigation(t4 + 1, addYears(a2.props.preSelection, 1));
+                                break;
+                            case "ArrowLeft":
+                                a2.handleYearNavigation(t4 - 1, subYears(a2.props.preSelection, 1));
                         }
+                }), de$1(ye(a2), "getYearClassNames", function(e3) {
+                    var t4 = a2.props,
+                        n3 = t4.minDate,
+                        o3 = t4.maxDate,
+                        s2 = t4.selected;
+                    return r$1("react-datepicker__year-text", {
+                        "react-datepicker__year-text--selected": e3 === getYear(s2),
+                        "react-datepicker__year-text--disabled": (n3 || o3) && rt(e3, a2.props),
+                        "react-datepicker__year-text--keyboard-selected": a2.isKeyboardSelected(e3),
+                        "react-datepicker__year-text--today": a2.isCurrentYear(e3)
                     });
+                }), de$1(ye(a2), "getYearTabIndex", function(e3) {
+                    return a2.props.disabledKeyboardNavigation ? "-1" : e3 === getYear(a2.props.preSelection) ? "0" : "-1";
+                }), a2;
+            }
+            return le$1(o2, [{
+                key: "render",
+                value: function() {
+                    for (var t3 = this, r2 = [], n3 = this.props, o3 = vt(n3.date, n3.yearItemNumber), a2 = o3.startPeriod, s2 = o3.endPeriod, i2 = function(n4) {
+                            r2.push(React__default.default.createElement("div", {
+                                ref: t3.YEAR_REFS[n4 - a2],
+                                onClick: function(e3) {
+                                    t3.onYearClick(e3, n4);
+                                },
+                                onKeyDown: function(e3) {
+                                    t3.onYearKeyDown(e3, n4);
+                                },
+                                tabIndex: t3.getYearTabIndex(n4),
+                                className: t3.getYearClassNames(n4),
+                                key: n4,
+                                "aria-current": t3.isCurrentYear(n4) ? "date" : void 0
+                            }, n4));
+                        }, p2 = a2; p2 <= s2; p2++)
+                        i2(p2);
+                    return React__default.default.createElement("div", {
+                        className: "react-datepicker__year"
+                    }, React__default.default.createElement("div", {
+                        className: "react-datepicker__year-wrapper"
+                    }, r2));
                 }
-            } else {
-                env2.content = Prism2.highlight(textContent(env2.content), grammar, codeLang);
+            }]), o2;
+        }(),
+        Ot = function(t2) {
+            he$1(n2, React__default.default.Component);
+            var r2 = De(n2);
+
+            function n2(t3) {
+                var o2;
+                return pe$1(this, n2), de$1(ye(o2 = r2.call(this, t3)), "onTimeChange", function(e3) {
+                    o2.setState({
+                        time: e3
+                    });
+                    var t4 = new Date();
+                    t4.setHours(e3.split(":")[0]), t4.setMinutes(e3.split(":")[1]), o2.props.onChange(t4);
+                }), de$1(ye(o2), "renderTimeInput", function() {
+                    var t4 = o2.state.time,
+                        r3 = o2.props,
+                        n3 = r3.date,
+                        a2 = r3.timeString,
+                        s2 = r3.customTimeInput;
+                    return s2 ? React__default.default.cloneElement(s2, {
+                        date: n3,
+                        value: t4,
+                        onChange: o2.onTimeChange
+                    }) : React__default.default.createElement("input", {
+                        type: "time",
+                        className: "react-datepicker-time__input",
+                        placeholder: "Time",
+                        name: "time-input",
+                        required: true,
+                        value: t4,
+                        onChange: function(e3) {
+                            o2.onTimeChange(e3.target.value || a2);
+                        }
+                    });
+                }), o2.state = {
+                    time: o2.props.timeString
+                }, o2;
             }
-        });
-        var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, "gi");
-        var KNOWN_ENTITY_NAMES = {
-            "amp": "&",
-            "lt": "<",
-            "gt": ">",
-            "quot": '"'
-        };
-        var fromCodePoint2 = String.fromCodePoint || String.fromCharCode;
+            return le$1(n2, [{
+                key: "render",
+                value: function() {
+                    return React__default.default.createElement("div", {
+                        className: "react-datepicker__input-time-container"
+                    }, React__default.default.createElement("div", {
+                        className: "react-datepicker-time__caption"
+                    }, this.props.timeInputLabel), React__default.default.createElement("div", {
+                        className: "react-datepicker-time__input-container"
+                    }, React__default.default.createElement("div", {
+                        className: "react-datepicker-time__input"
+                    }, this.renderTimeInput())));
+                }
+            }], [{
+                key: "getDerivedStateFromProps",
+                value: function(e3, t3) {
+                    return e3.timeString !== t3.time ? {
+                        time: e3.timeString
+                    } : null;
+                }
+            }]), n2;
+        }();
 
-        function textContent(html2) {
-            var text2 = html2.replace(tagPattern, "");
-            text2 = text2.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m2, code2) {
-                code2 = code2.toLowerCase();
-                if (code2[0] === "#") {
-                    var value;
-                    if (code2[1] === "x") {
-                        value = parseInt(code2.slice(2), 16);
-                    } else {
-                        value = Number(code2.slice(1));
+    function It(t2) {
+        var r2 = t2.className,
+            n2 = t2.children,
+            o2 = t2.showPopperArrow,
+            a2 = t2.arrowProps,
+            s2 = void 0 === a2 ? {} : a2;
+        return React__default.default.createElement("div", {
+            className: r2
+        }, o2 && React__default.default.createElement("div", ue$1({
+            className: "react-datepicker__triangle"
+        }, s2)), n2);
+    }
+    var Tt$1 = ["react-datepicker__year-select", "react-datepicker__month-select", "react-datepicker__month-year-select"],
+        Lt = function(t2) {
+            he$1(o2, React__default.default.Component);
+            var n2 = De(o2);
+
+            function o2(t3) {
+                var a2;
+                return pe$1(this, o2), de$1(ye(a2 = n2.call(this, t3)), "handleClickOutside", function(e3) {
+                    a2.props.onClickOutside(e3);
+                }), de$1(ye(a2), "setClickOutsideRef", function() {
+                    return a2.containerRef.current;
+                }), de$1(ye(a2), "handleDropdownFocus", function(e3) {
+                    (function() {
+                        var e4 = ((arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).className || "").split(/\s+/);
+                        return Tt$1.some(function(t4) {
+                            return e4.indexOf(t4) >= 0;
+                        });
+                    })(e3.target) && a2.props.onDropdownFocus();
+                }), de$1(ye(a2), "getDateInView", function() {
+                    var e3 = a2.props,
+                        t4 = e3.preSelection,
+                        r2 = e3.selected,
+                        n3 = e3.openToDate,
+                        o3 = ut$1(a2.props),
+                        s2 = ht$2(a2.props),
+                        i2 = _e$1(),
+                        p2 = n3 || r2 || t4;
+                    return p2 || (o3 && isBefore(i2, o3) ? o3 : s2 && isAfter(i2, s2) ? s2 : i2);
+                }), de$1(ye(a2), "increaseMonth", function() {
+                    a2.setState(function(e3) {
+                        var t4 = e3.date;
+                        return {
+                            date: addMonths(t4, 1)
+                        };
+                    }, function() {
+                        return a2.handleMonthChange(a2.state.date);
+                    });
+                }), de$1(ye(a2), "decreaseMonth", function() {
+                    a2.setState(function(e3) {
+                        var t4 = e3.date;
+                        return {
+                            date: subMonths(t4, 1)
+                        };
+                    }, function() {
+                        return a2.handleMonthChange(a2.state.date);
+                    });
+                }), de$1(ye(a2), "handleDayClick", function(e3, t4, r2) {
+                    a2.props.onSelect(e3, t4, r2), a2.props.setPreSelection && a2.props.setPreSelection(e3);
+                }), de$1(ye(a2), "handleDayMouseEnter", function(e3) {
+                    a2.setState({
+                        selectingDate: e3
+                    }), a2.props.onDayMouseEnter && a2.props.onDayMouseEnter(e3);
+                }), de$1(ye(a2), "handleMonthMouseLeave", function() {
+                    a2.setState({
+                        selectingDate: null
+                    }), a2.props.onMonthMouseLeave && a2.props.onMonthMouseLeave();
+                }), de$1(ye(a2), "handleYearChange", function(e3) {
+                    a2.props.onYearChange && a2.props.onYearChange(e3), a2.props.adjustDateOnChange && (a2.props.onSelect && a2.props.onSelect(e3), a2.props.setOpen && a2.props.setOpen(true)), a2.props.setPreSelection && a2.props.setPreSelection(e3);
+                }), de$1(ye(a2), "handleMonthChange", function(e3) {
+                    a2.props.onMonthChange && a2.props.onMonthChange(e3), a2.props.adjustDateOnChange && (a2.props.onSelect && a2.props.onSelect(e3), a2.props.setOpen && a2.props.setOpen(true)), a2.props.setPreSelection && a2.props.setPreSelection(e3);
+                }), de$1(ye(a2), "handleMonthYearChange", function(e3) {
+                    a2.handleYearChange(e3), a2.handleMonthChange(e3);
+                }), de$1(ye(a2), "changeYear", function(e3) {
+                    a2.setState(function(t4) {
+                        var r2 = t4.date;
+                        return {
+                            date: setYear(r2, e3)
+                        };
+                    }, function() {
+                        return a2.handleYearChange(a2.state.date);
+                    });
+                }), de$1(ye(a2), "changeMonth", function(e3) {
+                    a2.setState(function(t4) {
+                        var r2 = t4.date;
+                        return {
+                            date: setMonth(r2, e3)
+                        };
+                    }, function() {
+                        return a2.handleMonthChange(a2.state.date);
+                    });
+                }), de$1(ye(a2), "changeMonthYear", function(e3) {
+                    a2.setState(function(t4) {
+                        var r2 = t4.date;
+                        return {
+                            date: setYear(setMonth(r2, getMonth(e3)), getYear(e3))
+                        };
+                    }, function() {
+                        return a2.handleMonthYearChange(a2.state.date);
+                    });
+                }), de$1(ye(a2), "header", function() {
+                    var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a2.state.date,
+                        n3 = Te(t4, a2.props.locale, a2.props.calendarStartDay),
+                        o3 = [];
+                    return a2.props.showWeekNumbers && o3.push(React__default.default.createElement("div", {
+                        key: "W",
+                        className: "react-datepicker__day-name"
+                    }, a2.props.weekLabel || "#")), o3.concat([0, 1, 2, 3, 4, 5, 6].map(function(t5) {
+                        var o4 = addDays(n3, t5),
+                            s2 = a2.formatWeekday(o4, a2.props.locale),
+                            i2 = a2.props.weekDayClassName ? a2.props.weekDayClassName(o4) : void 0;
+                        return React__default.default.createElement("div", {
+                            key: t5,
+                            className: r$1("react-datepicker__day-name", i2)
+                        }, s2);
+                    }));
+                }), de$1(ye(a2), "formatWeekday", function(e3, t4) {
+                    return a2.props.formatWeekDay ? function(e4, t5, r2) {
+                        return t5(Ee$1(e4, "EEEE", r2));
+                    }(e3, a2.props.formatWeekDay, t4) : a2.props.useWeekdaysShort ? function(e4, t5) {
+                        return Ee$1(e4, "EEE", t5);
+                    }(e3, t4) : function(e4, t5) {
+                        return Ee$1(e4, "EEEEEE", t5);
+                    }(e3, t4);
+                }), de$1(ye(a2), "decreaseYear", function() {
+                    a2.setState(function(e3) {
+                        var t4 = e3.date;
+                        return {
+                            date: subYears(t4, a2.props.showYearPicker ? a2.props.yearItemNumber : 1)
+                        };
+                    }, function() {
+                        return a2.handleYearChange(a2.state.date);
+                    });
+                }), de$1(ye(a2), "renderPreviousButton", function() {
+                    if (!a2.props.renderCustomHeader) {
+                        var t4;
+                        switch (true) {
+                            case a2.props.showMonthYearPicker:
+                                t4 = lt$1(a2.state.date, a2.props);
+                                break;
+                            case a2.props.showYearPicker:
+                                t4 = function(e3) {
+                                    var t5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
+                                        r3 = t5.minDate,
+                                        n4 = t5.yearItemNumber,
+                                        o4 = void 0 === n4 ? 12 : n4,
+                                        a3 = vt(Re$1(subYears(e3, o4)), o4).endPeriod,
+                                        s3 = r3 && getYear(r3);
+                                    return s3 && s3 > a3 || false;
+                                }(a2.state.date, a2.props);
+                                break;
+                            default:
+                                t4 = pt$1(a2.state.date, a2.props);
+                        }
+                        if ((a2.props.forceShowMonthNavigation || a2.props.showDisabledMonthNavigation || !t4) && !a2.props.showTimeSelectOnly) {
+                            var r2 = ["react-datepicker__navigation", "react-datepicker__navigation--previous"],
+                                n3 = a2.decreaseMonth;
+                            (a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker || a2.props.showYearPicker) && (n3 = a2.decreaseYear), t4 && a2.props.showDisabledMonthNavigation && (r2.push("react-datepicker__navigation--previous--disabled"), n3 = null);
+                            var o3 = a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker || a2.props.showYearPicker,
+                                s2 = a2.props,
+                                i2 = s2.previousMonthButtonLabel,
+                                p2 = s2.previousYearButtonLabel,
+                                c2 = a2.props,
+                                l2 = c2.previousMonthAriaLabel,
+                                d2 = void 0 === l2 ? "string" == typeof i2 ? i2 : "Previous Month" : l2,
+                                u2 = c2.previousYearAriaLabel,
+                                h2 = void 0 === u2 ? "string" == typeof p2 ? p2 : "Previous Year" : u2;
+                            return React__default.default.createElement("button", {
+                                type: "button",
+                                className: r2.join(" "),
+                                onClick: n3,
+                                onKeyDown: a2.props.handleOnKeyDown,
+                                "aria-label": o3 ? h2 : d2
+                            }, React__default.default.createElement("span", {
+                                className: ["react-datepicker__navigation-icon", "react-datepicker__navigation-icon--previous"].join(" ")
+                            }, o3 ? a2.props.previousYearButtonLabel : a2.props.previousMonthButtonLabel));
+                        }
                     }
-                    return fromCodePoint2(value);
-                } else {
-                    var known = KNOWN_ENTITY_NAMES[code2];
-                    if (known) {
-                        return known;
+                }), de$1(ye(a2), "increaseYear", function() {
+                    a2.setState(function(e3) {
+                        var t4 = e3.date;
+                        return {
+                            date: addYears(t4, a2.props.showYearPicker ? a2.props.yearItemNumber : 1)
+                        };
+                    }, function() {
+                        return a2.handleYearChange(a2.state.date);
+                    });
+                }), de$1(ye(a2), "renderNextButton", function() {
+                    if (!a2.props.renderCustomHeader) {
+                        var t4;
+                        switch (true) {
+                            case a2.props.showMonthYearPicker:
+                                t4 = dt$1(a2.state.date, a2.props);
+                                break;
+                            case a2.props.showYearPicker:
+                                t4 = function(e3) {
+                                    var t5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
+                                        r3 = t5.maxDate,
+                                        n4 = t5.yearItemNumber,
+                                        o4 = void 0 === n4 ? 12 : n4,
+                                        a3 = vt(addYears(e3, o4), o4).startPeriod,
+                                        s3 = r3 && getYear(r3);
+                                    return s3 && s3 < a3 || false;
+                                }(a2.state.date, a2.props);
+                                break;
+                            default:
+                                t4 = ct$1(a2.state.date, a2.props);
+                        }
+                        if ((a2.props.forceShowMonthNavigation || a2.props.showDisabledMonthNavigation || !t4) && !a2.props.showTimeSelectOnly) {
+                            var r2 = ["react-datepicker__navigation", "react-datepicker__navigation--next"];
+                            a2.props.showTimeSelect && r2.push("react-datepicker__navigation--next--with-time"), a2.props.todayButton && r2.push("react-datepicker__navigation--next--with-today-button");
+                            var n3 = a2.increaseMonth;
+                            (a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker || a2.props.showYearPicker) && (n3 = a2.increaseYear), t4 && a2.props.showDisabledMonthNavigation && (r2.push("react-datepicker__navigation--next--disabled"), n3 = null);
+                            var o3 = a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker || a2.props.showYearPicker,
+                                s2 = a2.props,
+                                i2 = s2.nextMonthButtonLabel,
+                                p2 = s2.nextYearButtonLabel,
+                                c2 = a2.props,
+                                l2 = c2.nextMonthAriaLabel,
+                                u2 = void 0 === l2 ? "string" == typeof i2 ? i2 : "Next Month" : l2,
+                                h2 = c2.nextYearAriaLabel,
+                                m2 = void 0 === h2 ? "string" == typeof p2 ? p2 : "Next Year" : h2;
+                            return React__default.default.createElement("button", {
+                                type: "button",
+                                className: r2.join(" "),
+                                onClick: n3,
+                                onKeyDown: a2.props.handleOnKeyDown,
+                                "aria-label": o3 ? m2 : u2
+                            }, React__default.default.createElement("span", {
+                                className: ["react-datepicker__navigation-icon", "react-datepicker__navigation-icon--next"].join(" ")
+                            }, o3 ? a2.props.nextYearButtonLabel : a2.props.nextMonthButtonLabel));
+                        }
                     }
-                    return m2;
+                }), de$1(ye(a2), "renderCurrentMonth", function() {
+                    var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a2.state.date,
+                        r2 = ["react-datepicker__current-month"];
+                    return a2.props.showYearDropdown && r2.push("react-datepicker__current-month--hasYearDropdown"), a2.props.showMonthDropdown && r2.push("react-datepicker__current-month--hasMonthDropdown"), a2.props.showMonthYearDropdown && r2.push("react-datepicker__current-month--hasMonthYearDropdown"), React__default.default.createElement("div", {
+                        className: r2.join(" ")
+                    }, Ee$1(t4, a2.props.dateFormat, a2.props.locale));
+                }), de$1(ye(a2), "renderYearDropdown", function() {
+                    var t4 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
+                    if (a2.props.showYearDropdown && !t4)
+                        return React__default.default.createElement(gt, {
+                            adjustDateOnChange: a2.props.adjustDateOnChange,
+                            date: a2.state.date,
+                            onSelect: a2.props.onSelect,
+                            setOpen: a2.props.setOpen,
+                            dropdownMode: a2.props.dropdownMode,
+                            onChange: a2.changeYear,
+                            minDate: a2.props.minDate,
+                            maxDate: a2.props.maxDate,
+                            year: getYear(a2.state.date),
+                            scrollableYearDropdown: a2.props.scrollableYearDropdown,
+                            yearDropdownItemNumber: a2.props.yearDropdownItemNumber
+                        });
+                }), de$1(ye(a2), "renderMonthDropdown", function() {
+                    var t4 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
+                    if (a2.props.showMonthDropdown && !t4)
+                        return React__default.default.createElement(bt, {
+                            dropdownMode: a2.props.dropdownMode,
+                            locale: a2.props.locale,
+                            onChange: a2.changeMonth,
+                            month: getMonth(a2.state.date),
+                            useShortMonthInDropdown: a2.props.useShortMonthInDropdown
+                        });
+                }), de$1(ye(a2), "renderMonthYearDropdown", function() {
+                    var t4 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
+                    if (a2.props.showMonthYearDropdown && !t4)
+                        return React__default.default.createElement(_t$1, {
+                            dropdownMode: a2.props.dropdownMode,
+                            locale: a2.props.locale,
+                            dateFormat: a2.props.dateFormat,
+                            onChange: a2.changeMonthYear,
+                            minDate: a2.props.minDate,
+                            maxDate: a2.props.maxDate,
+                            date: a2.state.date,
+                            scrollableMonthYearDropdown: a2.props.scrollableMonthYearDropdown
+                        });
+                }), de$1(ye(a2), "renderTodayButton", function() {
+                    if (a2.props.todayButton && !a2.props.showTimeSelectOnly)
+                        return React__default.default.createElement("div", {
+                            className: "react-datepicker__today-button",
+                            onClick: function(e3) {
+                                return a2.props.onSelect(startOfDay(_e$1()), e3);
+                            }
+                        }, a2.props.todayButton);
+                }), de$1(ye(a2), "renderDefaultHeader", function(t4) {
+                    var r2 = t4.monthDate,
+                        n3 = t4.i;
+                    return React__default.default.createElement("div", {
+                        className: "react-datepicker__header ".concat(a2.props.showTimeSelect ? "react-datepicker__header--has-time-select" : "")
+                    }, a2.renderCurrentMonth(r2), React__default.default.createElement("div", {
+                        className: "react-datepicker__header__dropdown react-datepicker__header__dropdown--".concat(a2.props.dropdownMode),
+                        onFocus: a2.handleDropdownFocus
+                    }, a2.renderMonthDropdown(0 !== n3), a2.renderMonthYearDropdown(0 !== n3), a2.renderYearDropdown(0 !== n3)), React__default.default.createElement("div", {
+                        className: "react-datepicker__day-names"
+                    }, a2.header(r2)));
+                }), de$1(ye(a2), "renderCustomHeader", function() {
+                    var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
+                        r2 = t4.monthDate,
+                        n3 = t4.i;
+                    if (a2.props.showTimeSelect && !a2.state.monthContainer || a2.props.showTimeSelectOnly)
+                        return null;
+                    var o3 = pt$1(a2.state.date, a2.props),
+                        s2 = ct$1(a2.state.date, a2.props),
+                        i2 = lt$1(a2.state.date, a2.props),
+                        p2 = dt$1(a2.state.date, a2.props),
+                        c2 = !a2.props.showMonthYearPicker && !a2.props.showQuarterYearPicker && !a2.props.showYearPicker;
+                    return React__default.default.createElement("div", {
+                        className: "react-datepicker__header react-datepicker__header--custom",
+                        onFocus: a2.props.onDropdownFocus
+                    }, a2.props.renderCustomHeader(se$1(se$1({}, a2.state), {}, {
+                        customHeaderCount: n3,
+                        monthDate: r2,
+                        changeMonth: a2.changeMonth,
+                        changeYear: a2.changeYear,
+                        decreaseMonth: a2.decreaseMonth,
+                        increaseMonth: a2.increaseMonth,
+                        decreaseYear: a2.decreaseYear,
+                        increaseYear: a2.increaseYear,
+                        prevMonthButtonDisabled: o3,
+                        nextMonthButtonDisabled: s2,
+                        prevYearButtonDisabled: i2,
+                        nextYearButtonDisabled: p2
+                    })), c2 && React__default.default.createElement("div", {
+                        className: "react-datepicker__day-names"
+                    }, a2.header(r2)));
+                }), de$1(ye(a2), "renderYearHeader", function() {
+                    var t4 = a2.state.date,
+                        r2 = a2.props,
+                        n3 = r2.showYearPicker,
+                        o3 = vt(t4, r2.yearItemNumber),
+                        s2 = o3.startPeriod,
+                        i2 = o3.endPeriod;
+                    return React__default.default.createElement("div", {
+                        className: "react-datepicker__header react-datepicker-year-header"
+                    }, n3 ? "".concat(s2, " - ").concat(i2) : getYear(t4));
+                }), de$1(ye(a2), "renderHeader", function(e3) {
+                    switch (true) {
+                        case void 0 !== a2.props.renderCustomHeader:
+                            return a2.renderCustomHeader(e3);
+                        case (a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker || a2.props.showYearPicker):
+                            return a2.renderYearHeader(e3);
+                        default:
+                            return a2.renderDefaultHeader(e3);
+                    }
+                }), de$1(ye(a2), "renderMonths", function() {
+                    if (!a2.props.showTimeSelectOnly && !a2.props.showYearPicker) {
+                        for (var t4 = [], r2 = a2.props.showPreviousMonths ? a2.props.monthsShown - 1 : 0, n3 = subMonths(a2.state.date, r2), o3 = 0; o3 < a2.props.monthsShown; ++o3) {
+                            var s2 = o3 - a2.props.monthSelectedIn,
+                                i2 = addMonths(n3, s2),
+                                p2 = "month-".concat(o3),
+                                c2 = o3 < a2.props.monthsShown - 1,
+                                d2 = o3 > 0;
+                            t4.push(React__default.default.createElement("div", {
+                                key: p2,
+                                ref: function(e3) {
+                                    a2.monthContainer = e3;
+                                },
+                                className: "react-datepicker__month-container"
+                            }, a2.renderHeader({
+                                monthDate: i2,
+                                i: o3
+                            }), React__default.default.createElement(Nt, {
+                                chooseDayAriaLabelPrefix: a2.props.chooseDayAriaLabelPrefix,
+                                disabledDayAriaLabelPrefix: a2.props.disabledDayAriaLabelPrefix,
+                                weekAriaLabelPrefix: a2.props.weekAriaLabelPrefix,
+                                ariaLabelPrefix: a2.props.monthAriaLabelPrefix,
+                                onChange: a2.changeMonthYear,
+                                day: i2,
+                                dayClassName: a2.props.dayClassName,
+                                calendarStartDay: a2.props.calendarStartDay,
+                                monthClassName: a2.props.monthClassName,
+                                onDayClick: a2.handleDayClick,
+                                handleOnKeyDown: a2.props.handleOnDayKeyDown,
+                                onDayMouseEnter: a2.handleDayMouseEnter,
+                                onMouseLeave: a2.handleMonthMouseLeave,
+                                onWeekSelect: a2.props.onWeekSelect,
+                                orderInDisplay: o3,
+                                formatWeekNumber: a2.props.formatWeekNumber,
+                                locale: a2.props.locale,
+                                minDate: a2.props.minDate,
+                                maxDate: a2.props.maxDate,
+                                excludeDates: a2.props.excludeDates,
+                                excludeDateIntervals: a2.props.excludeDateIntervals,
+                                highlightDates: a2.props.highlightDates,
+                                selectingDate: a2.state.selectingDate,
+                                includeDates: a2.props.includeDates,
+                                includeDateIntervals: a2.props.includeDateIntervals,
+                                inline: a2.props.inline,
+                                shouldFocusDayInline: a2.props.shouldFocusDayInline,
+                                fixedHeight: a2.props.fixedHeight,
+                                filterDate: a2.props.filterDate,
+                                preSelection: a2.props.preSelection,
+                                setPreSelection: a2.props.setPreSelection,
+                                selected: a2.props.selected,
+                                selectsStart: a2.props.selectsStart,
+                                selectsEnd: a2.props.selectsEnd,
+                                selectsRange: a2.props.selectsRange,
+                                selectsDisabledDaysInRange: a2.props.selectsDisabledDaysInRange,
+                                showWeekNumbers: a2.props.showWeekNumbers,
+                                startDate: a2.props.startDate,
+                                endDate: a2.props.endDate,
+                                peekNextMonth: a2.props.peekNextMonth,
+                                setOpen: a2.props.setOpen,
+                                shouldCloseOnSelect: a2.props.shouldCloseOnSelect,
+                                renderDayContents: a2.props.renderDayContents,
+                                disabledKeyboardNavigation: a2.props.disabledKeyboardNavigation,
+                                showMonthYearPicker: a2.props.showMonthYearPicker,
+                                showFullMonthYearPicker: a2.props.showFullMonthYearPicker,
+                                showTwoColumnMonthYearPicker: a2.props.showTwoColumnMonthYearPicker,
+                                showFourColumnMonthYearPicker: a2.props.showFourColumnMonthYearPicker,
+                                showYearPicker: a2.props.showYearPicker,
+                                showQuarterYearPicker: a2.props.showQuarterYearPicker,
+                                isInputFocused: a2.props.isInputFocused,
+                                containerRef: a2.containerRef,
+                                monthShowsDuplicateDaysEnd: c2,
+                                monthShowsDuplicateDaysStart: d2
+                            })));
+                        }
+                        return t4;
+                    }
+                }), de$1(ye(a2), "renderYears", function() {
+                    if (!a2.props.showTimeSelectOnly)
+                        return a2.props.showYearPicker ? React__default.default.createElement("div", {
+                            className: "react-datepicker__year--container"
+                        }, a2.renderHeader(), React__default.default.createElement(Yt$1, ue$1({
+                            onDayClick: a2.handleDayClick,
+                            date: a2.state.date
+                        }, a2.props))) : void 0;
+                }), de$1(ye(a2), "renderTimeSection", function() {
+                    if (a2.props.showTimeSelect && (a2.state.monthContainer || a2.props.showTimeSelectOnly))
+                        return React__default.default.createElement(xt, {
+                            selected: a2.props.selected,
+                            openToDate: a2.props.openToDate,
+                            onChange: a2.props.onTimeChange,
+                            timeClassName: a2.props.timeClassName,
+                            format: a2.props.timeFormat,
+                            includeTimes: a2.props.includeTimes,
+                            intervals: a2.props.timeIntervals,
+                            minTime: a2.props.minTime,
+                            maxTime: a2.props.maxTime,
+                            excludeTimes: a2.props.excludeTimes,
+                            filterTime: a2.props.filterTime,
+                            timeCaption: a2.props.timeCaption,
+                            todayButton: a2.props.todayButton,
+                            showMonthDropdown: a2.props.showMonthDropdown,
+                            showMonthYearDropdown: a2.props.showMonthYearDropdown,
+                            showYearDropdown: a2.props.showYearDropdown,
+                            withPortal: a2.props.withPortal,
+                            monthRef: a2.state.monthContainer,
+                            injectTimes: a2.props.injectTimes,
+                            locale: a2.props.locale,
+                            handleOnKeyDown: a2.props.handleOnKeyDown,
+                            showTimeSelectOnly: a2.props.showTimeSelectOnly
+                        });
+                }), de$1(ye(a2), "renderInputTimeSection", function() {
+                    var t4 = new Date(a2.props.selected),
+                        r2 = Pe$1(t4) && Boolean(a2.props.selected) ? "".concat(yt(t4.getHours()), ":").concat(yt(t4.getMinutes())) : "";
+                    if (a2.props.showTimeInput)
+                        return React__default.default.createElement(Ot, {
+                            date: t4,
+                            timeString: r2,
+                            timeInputLabel: a2.props.timeInputLabel,
+                            onChange: a2.props.onTimeChange,
+                            customTimeInput: a2.props.customTimeInput
+                        });
+                }), a2.containerRef = React__default.default.createRef(), a2.state = {
+                    date: a2.getDateInView(),
+                    selectingDate: null,
+                    monthContainer: null
+                }, a2;
+            }
+            return le$1(o2, [{
+                key: "componentDidMount",
+                value: function() {
+                    var e3 = this;
+                    this.props.showTimeSelect && (this.assignMonthContainer = void e3.setState({
+                        monthContainer: e3.monthContainer
+                    }));
                 }
-            });
-            return text2;
-        }
-        Prism2.languages.md = Prism2.languages.markdown;
-    })(prism);
-    prism.languages.graphql = {
-        "comment": /#.*/,
-        "description": {
-            pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i,
-            greedy: true,
-            alias: "string",
-            inside: {
-                "language-markdown": {
-                    pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/,
-                    lookbehind: true,
-                    inside: prism.languages.markdown
+            }, {
+                key: "componentDidUpdate",
+                value: function(e3) {
+                    this.props.preSelection && !We$1(this.props.preSelection, e3.preSelection) ? this.setState({
+                        date: this.props.preSelection
+                    }) : this.props.openToDate && !We$1(this.props.openToDate, e3.openToDate) && this.setState({
+                        date: this.props.openToDate
+                    });
+                }
+            }, {
+                key: "render",
+                value: function() {
+                    var t3 = this.props.container || It;
+                    return React__default.default.createElement("div", {
+                        ref: this.containerRef
+                    }, React__default.default.createElement(t3, {
+                        className: r$1("react-datepicker", this.props.className, {
+                            "react-datepicker--time-only": this.props.showTimeSelectOnly
+                        }),
+                        showPopperArrow: this.props.showPopperArrow,
+                        arrowProps: this.props.arrowProps
+                    }, this.renderPreviousButton(), this.renderNextButton(), this.renderMonths(), this.renderYears(), this.renderTodayButton(), this.renderTimeSection(), this.renderInputTimeSection(), this.props.children));
                 }
+            }], [{
+                key: "defaultProps",
+                get: function() {
+                    return {
+                        onDropdownFocus: function() {},
+                        monthsShown: 1,
+                        monthSelectedIn: 0,
+                        forceShowMonthNavigation: false,
+                        timeCaption: "Time",
+                        previousYearButtonLabel: "Previous Year",
+                        nextYearButtonLabel: "Next Year",
+                        previousMonthButtonLabel: "Previous Month",
+                        nextMonthButtonLabel: "Next Month",
+                        customTimeInput: null,
+                        yearItemNumber: 12
+                    };
+                }
+            }]), o2;
+        }(),
+        Rt$1 = function(t2) {
+            he$1(n2, React__default.default.Component);
+            var r2 = De(n2);
+
+            function n2(e3) {
+                var t3;
+                return pe$1(this, n2), (t3 = r2.call(this, e3)).el = document.createElement("div"), t3;
             }
+            return le$1(n2, [{
+                key: "componentDidMount",
+                value: function() {
+                    this.portalRoot = (this.props.portalHost || document).getElementById(this.props.portalId), this.portalRoot || (this.portalRoot = document.createElement("div"), this.portalRoot.setAttribute("id", this.props.portalId), (this.props.portalHost || document.body).appendChild(this.portalRoot)), this.portalRoot.appendChild(this.el);
+                }
+            }, {
+                key: "componentWillUnmount",
+                value: function() {
+                    this.portalRoot.removeChild(this.el);
+                }
+            }, {
+                key: "render",
+                value: function() {
+                    return ReactDOM__default.default.createPortal(this.props.children, this.el);
+                }
+            }]), n2;
+        }(),
+        Ft$1 = function(e3) {
+            return !e3.disabled && -1 !== e3.tabIndex;
         },
-        "string": {
-            pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/,
-            greedy: true
-        },
-        "number": /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
-        "boolean": /\b(?:false|true)\b/,
-        "variable": /\$[a-z_]\w*/i,
-        "directive": {
-            pattern: /@[a-z_]\w*/i,
-            alias: "function"
-        },
-        "attr-name": {
-            pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i,
-            greedy: true
-        },
-        "atom-input": {
-            pattern: /\b[A-Z]\w*Input\b/,
-            alias: "class-name"
-        },
-        "scalar": /\b(?:Boolean|Float|ID|Int|String)\b/,
-        "constant": /\b[A-Z][A-Z_\d]*\b/,
-        "class-name": {
-            pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/,
-            lookbehind: true
-        },
-        "fragment": {
-            pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/,
-            lookbehind: true,
-            alias: "function"
-        },
-        "definition-mutation": {
-            pattern: /(\bmutation\s+)[a-zA-Z_]\w*/,
-            lookbehind: true,
-            alias: "function"
-        },
-        "definition-query": {
-            pattern: /(\bquery\s+)[a-zA-Z_]\w*/,
-            lookbehind: true,
-            alias: "function"
-        },
-        "keyword": /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/,
-        "operator": /[!=|&]|\.{3}/,
-        "property-query": /\w+(?=\s*\()/,
-        "object": /\w+(?=\s*\{)/,
-        "punctuation": /[!(){}\[\]:=,]/,
-        "property": /\w+/
-    };
-    prism.hooks.add("after-tokenize", function afterTokenizeGraphql(env2) {
-        if (env2.language !== "graphql") {
-            return;
-        }
-        var validTokens = env2.tokens.filter(function(token) {
-            return typeof token !== "string" && token.type !== "comment" && token.type !== "scalar";
-        });
-        var currentIndex = 0;
-
-        function getToken(offset2) {
-            return validTokens[currentIndex + offset2];
-        }
+        At$1 = function(t2) {
+            he$1(n2, React__default.default.Component);
+            var r2 = De(n2);
 
-        function isTokenType(types2, offset2) {
-            offset2 = offset2 || 0;
-            for (var i3 = 0; i3 < types2.length; i3++) {
-                var token = getToken(i3 + offset2);
-                if (!token || token.type !== types2[i3]) {
-                    return false;
-                }
+            function n2(t3) {
+                var o2;
+                return pe$1(this, n2), de$1(ye(o2 = r2.call(this, t3)), "getTabChildren", function() {
+                    return Array.prototype.slice.call(o2.tabLoopRef.current.querySelectorAll("[tabindex], a, button, input, select, textarea"), 1, -1).filter(Ft$1);
+                }), de$1(ye(o2), "handleFocusStart", function(e3) {
+                    var t4 = o2.getTabChildren();
+                    t4 && t4.length > 1 && t4[t4.length - 1].focus();
+                }), de$1(ye(o2), "handleFocusEnd", function(e3) {
+                    var t4 = o2.getTabChildren();
+                    t4 && t4.length > 1 && t4[0].focus();
+                }), o2.tabLoopRef = React__default.default.createRef(), o2;
             }
-            return true;
-        }
+            return le$1(n2, [{
+                key: "render",
+                value: function() {
+                    return this.props.enableTabLoop ? React__default.default.createElement("div", {
+                        className: "react-datepicker__tab-loop",
+                        ref: this.tabLoopRef
+                    }, React__default.default.createElement("div", {
+                        className: "react-datepicker__tab-loop__start",
+                        tabIndex: "0",
+                        onFocus: this.handleFocusStart
+                    }), this.props.children, React__default.default.createElement("div", {
+                        className: "react-datepicker__tab-loop__end",
+                        tabIndex: "0",
+                        onFocus: this.handleFocusEnd
+                    })) : this.props.children;
+                }
+            }], [{
+                key: "defaultProps",
+                get: function() {
+                    return {
+                        enableTabLoop: true
+                    };
+                }
+            }]), n2;
+        }(),
+        Bt$1 = function(t2) {
+            he$1(o2, React__default.default.Component);
+            var n2 = De(o2);
 
-        function findClosingBracket(open, close) {
-            var stackHeight = 1;
-            for (var i3 = currentIndex; i3 < validTokens.length; i3++) {
-                var token = validTokens[i3];
-                var content2 = token.content;
-                if (token.type === "punctuation" && typeof content2 === "string") {
-                    if (open.test(content2)) {
-                        stackHeight++;
-                    } else if (close.test(content2)) {
-                        stackHeight--;
-                        if (stackHeight === 0) {
-                            return i3;
-                        }
+            function o2() {
+                return pe$1(this, o2), n2.apply(this, arguments);
+            }
+            return le$1(o2, [{
+                key: "render",
+                value: function() {
+                    var t3, n3 = this.props,
+                        o3 = n3.className,
+                        a2 = n3.wrapperClassName,
+                        s2 = n3.hidePopper,
+                        i2 = n3.popperComponent,
+                        p2 = n3.popperModifiers,
+                        c2 = n3.popperPlacement,
+                        l2 = n3.popperProps,
+                        d2 = n3.targetComponent,
+                        u2 = n3.enableTabLoop,
+                        h2 = n3.popperOnKeyDown,
+                        m2 = n3.portalId,
+                        f2 = n3.portalHost;
+                    if (!s2) {
+                        var y2 = r$1("react-datepicker-popper", o3);
+                        t3 = React__default.default.createElement(Popper, ue$1({
+                            modifiers: p2,
+                            placement: c2
+                        }, l2), function(t4) {
+                            var r2 = t4.ref,
+                                n4 = t4.style,
+                                o4 = t4.placement,
+                                a3 = t4.arrowProps;
+                            return React__default.default.createElement(At$1, {
+                                enableTabLoop: u2
+                            }, React__default.default.createElement("div", {
+                                ref: r2,
+                                style: n4,
+                                className: y2,
+                                "data-placement": o4,
+                                onKeyDown: h2
+                            }, React__default.default.cloneElement(i2, {
+                                arrowProps: a3
+                            })));
+                        });
                     }
+                    this.props.popperContainer && (t3 = React__default.default.createElement(this.props.popperContainer, {}, t3)), m2 && !s2 && (t3 = React__default.default.createElement(Rt$1, {
+                        portalId: m2,
+                        portalHost: f2
+                    }, t3));
+                    var v2 = r$1("react-datepicker-wrapper", a2);
+                    return React__default.default.createElement(Manager, {
+                        className: "react-datepicker-manager"
+                    }, React__default.default.createElement(Reference, null, function(t4) {
+                        var r2 = t4.ref;
+                        return React__default.default.createElement("div", {
+                            ref: r2,
+                            className: v2
+                        }, d2);
+                    }), t3);
                 }
-            }
-            return -1;
-        }
+            }], [{
+                key: "defaultProps",
+                get: function() {
+                    return {
+                        hidePopper: true,
+                        popperModifiers: [],
+                        popperProps: {},
+                        popperPlacement: "bottom-start"
+                    };
+                }
+            }]), o2;
+        }(),
+        Kt$1 = onClickOutsideHOC(Lt);
+    var Wt$1 = function(t2) {
+            he$1(a2, React__default.default.Component);
+            var o2 = De(a2);
 
-        function addAlias(token, alias) {
-            var aliases = token.alias;
-            if (!aliases) {
-                token.alias = aliases = [];
-            } else if (!Array.isArray(aliases)) {
-                token.alias = aliases = [aliases];
-            }
-            aliases.push(alias);
-        }
-        for (; currentIndex < validTokens.length;) {
-            var startToken = validTokens[currentIndex++];
-            if (startToken.type === "keyword" && startToken.content === "mutation") {
-                var inputVariables = [];
-                if (isTokenType(["definition-mutation", "punctuation"]) && getToken(1).content === "(") {
-                    currentIndex += 2;
-                    var definitionEnd = findClosingBracket(/^\($/, /^\)$/);
-                    if (definitionEnd === -1) {
-                        continue;
+            function a2(t3) {
+                var s2;
+                return pe$1(this, a2), de$1(ye(s2 = o2.call(this, t3)), "getPreSelection", function() {
+                    return s2.props.openToDate ? s2.props.openToDate : s2.props.selectsEnd && s2.props.startDate ? s2.props.startDate : s2.props.selectsStart && s2.props.endDate ? s2.props.endDate : _e$1();
+                }), de$1(ye(s2), "calcInitialState", function() {
+                    var e3, t4 = s2.getPreSelection(),
+                        r2 = ut$1(s2.props),
+                        n2 = ht$2(s2.props),
+                        o3 = r2 && isBefore(t4, startOfDay(r2)) ? r2 : n2 && isAfter(t4, endOfDay(n2)) ? n2 : t4;
+                    return {
+                        open: s2.props.startOpen || false,
+                        preventFocus: false,
+                        preSelection: null !== (e3 = s2.props.selectsRange ? s2.props.startDate : s2.props.selected) && void 0 !== e3 ? e3 : o3,
+                        highlightDates: mt$1(s2.props.highlightDates),
+                        focused: false,
+                        shouldFocusDayInline: false
+                    };
+                }), de$1(ye(s2), "clearPreventFocusTimeout", function() {
+                    s2.preventFocusTimeout && clearTimeout(s2.preventFocusTimeout);
+                }), de$1(ye(s2), "setFocus", function() {
+                    s2.input && s2.input.focus && s2.input.focus({
+                        preventScroll: true
+                    });
+                }), de$1(ye(s2), "setBlur", function() {
+                    s2.input && s2.input.blur && s2.input.blur(), s2.cancelFocusInput();
+                }), de$1(ye(s2), "setOpen", function(e3) {
+                    var t4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
+                    s2.setState({
+                        open: e3,
+                        preSelection: e3 && s2.state.open ? s2.state.preSelection : s2.calcInitialState().preSelection,
+                        lastPreSelectChange: Ht$1
+                    }, function() {
+                        e3 || s2.setState(function(e4) {
+                            return {
+                                focused: !!t4 && e4.focused
+                            };
+                        }, function() {
+                            !t4 && s2.setBlur(), s2.setState({
+                                inputValue: null
+                            });
+                        });
+                    });
+                }), de$1(ye(s2), "inputOk", function() {
+                    return isDate$1(s2.state.preSelection);
+                }), de$1(ye(s2), "isCalendarOpen", function() {
+                    return void 0 === s2.props.open ? s2.state.open && !s2.props.disabled && !s2.props.readOnly : s2.props.open;
+                }), de$1(ye(s2), "handleFocus", function(e3) {
+                    s2.state.preventFocus || (s2.props.onFocus(e3), s2.props.preventOpenOnFocus || s2.props.readOnly || s2.setOpen(true)), s2.setState({
+                        focused: true
+                    });
+                }), de$1(ye(s2), "cancelFocusInput", function() {
+                    clearTimeout(s2.inputFocusTimeout), s2.inputFocusTimeout = null;
+                }), de$1(ye(s2), "deferFocusInput", function() {
+                    s2.cancelFocusInput(), s2.inputFocusTimeout = setTimeout(function() {
+                        return s2.setFocus();
+                    }, 1);
+                }), de$1(ye(s2), "handleDropdownFocus", function() {
+                    s2.cancelFocusInput();
+                }), de$1(ye(s2), "handleBlur", function(e3) {
+                    (!s2.state.open || s2.props.withPortal || s2.props.showTimeInput) && s2.props.onBlur(e3), s2.setState({
+                        focused: false
+                    });
+                }), de$1(ye(s2), "handleCalendarClickOutside", function(e3) {
+                    s2.props.inline || s2.setOpen(false), s2.props.onClickOutside(e3), s2.props.withPortal && e3.preventDefault();
+                }), de$1(ye(s2), "handleChange", function() {
+                    for (var e3 = arguments.length, t4 = new Array(e3), r2 = 0; r2 < e3; r2++)
+                        t4[r2] = arguments[r2];
+                    var n2 = t4[0];
+                    if (!s2.props.onChangeRaw || (s2.props.onChangeRaw.apply(ye(s2), t4), "function" == typeof n2.isDefaultPrevented && !n2.isDefaultPrevented())) {
+                        s2.setState({
+                            inputValue: n2.target.value,
+                            lastPreSelectChange: jt$1
+                        });
+                        var o3 = Me$1(n2.target.value, s2.props.dateFormat, s2.props.locale, s2.props.strictParsing, s2.props.minDate);
+                        !o3 && n2.target.value || s2.setSelected(o3, n2, true);
                     }
-                    for (; currentIndex < definitionEnd; currentIndex++) {
-                        var t2 = getToken(0);
-                        if (t2.type === "variable") {
-                            addAlias(t2, "variable-input");
-                            inputVariables.push(t2.content);
-                        }
+                }), de$1(ye(s2), "handleSelect", function(e3, t4, r2) {
+                    if (s2.setState({
+                            preventFocus: true
+                        }, function() {
+                            return s2.preventFocusTimeout = setTimeout(function() {
+                                return s2.setState({
+                                    preventFocus: false
+                                });
+                            }, 50), s2.preventFocusTimeout;
+                        }), s2.props.onChangeRaw && s2.props.onChangeRaw(t4), s2.setSelected(e3, t4, false, r2), !s2.props.shouldCloseOnSelect || s2.props.showTimeSelect)
+                        s2.setPreSelection(e3);
+                    else if (!s2.props.inline) {
+                        s2.props.selectsRange || s2.setOpen(false);
+                        var n2 = s2.props,
+                            o3 = n2.startDate,
+                            a3 = n2.endDate;
+                        !o3 || a3 || isBefore(e3, o3) || s2.setOpen(false);
                     }
-                    currentIndex = definitionEnd + 1;
-                }
-                if (isTokenType(["punctuation", "property-query"]) && getToken(0).content === "{") {
-                    currentIndex++;
-                    addAlias(getToken(0), "property-mutation");
-                    if (inputVariables.length > 0) {
-                        var mutationEnd = findClosingBracket(/^\{$/, /^\}$/);
-                        if (mutationEnd === -1) {
-                            continue;
+                }), de$1(ye(s2), "setSelected", function(e3, t4, r2, n2) {
+                    var o3 = e3;
+                    if (null === o3 || !Je$1(o3, s2.props)) {
+                        var a3 = s2.props,
+                            i2 = a3.onChange,
+                            p2 = a3.selectsRange,
+                            c2 = a3.startDate,
+                            l2 = a3.endDate;
+                        if (!je$1(s2.props.selected, o3) || s2.props.allowSameDay || p2)
+                            if (null !== o3 && (!s2.props.selected || r2 && (s2.props.showTimeSelect || s2.props.showTimeSelectOnly || s2.props.showTimeInput) || (o3 = xe$1(o3, {
+                                    hour: getHours(s2.props.selected),
+                                    minute: getMinutes(s2.props.selected),
+                                    second: getSeconds(s2.props.selected)
+                                })), s2.props.inline || s2.setState({
+                                    preSelection: o3
+                                }), s2.props.focusSelectedMonth || s2.setState({
+                                    monthSelectedIn: n2
+                                })), p2) {
+                                var d2 = c2 && !l2,
+                                    u2 = c2 && l2;
+                                !c2 && !l2 ? i2([o3, null], t4) : d2 && (isBefore(o3, c2) ? i2([o3, null], t4) : i2([c2, o3], t4)), u2 && i2([o3, null], t4);
+                            } else
+                                i2(o3, t4);
+                        r2 || (s2.props.onSelect(o3, t4), s2.setState({
+                            inputValue: null
+                        }));
+                    }
+                }), de$1(ye(s2), "setPreSelection", function(e3) {
+                    var t4 = void 0 !== s2.props.minDate,
+                        r2 = void 0 !== s2.props.maxDate,
+                        n2 = true;
+                    if (e3) {
+                        var o3 = startOfDay(e3);
+                        if (t4 && r2)
+                            n2 = He$1(e3, s2.props.minDate, s2.props.maxDate);
+                        else if (t4) {
+                            var a3 = startOfDay(s2.props.minDate);
+                            n2 = isAfter(e3, a3) || je$1(o3, a3);
+                        } else if (r2) {
+                            var i2 = endOfDay(s2.props.maxDate);
+                            n2 = isBefore(e3, i2) || je$1(o3, i2);
                         }
-                        for (var i2 = currentIndex; i2 < mutationEnd; i2++) {
-                            var varToken = validTokens[i2];
-                            if (varToken.type === "variable" && inputVariables.indexOf(varToken.content) >= 0) {
-                                addAlias(varToken, "variable-input");
+                    }
+                    n2 && s2.setState({
+                        preSelection: e3
+                    });
+                }), de$1(ye(s2), "handleTimeChange", function(e3) {
+                    var t4 = xe$1(s2.props.selected ? s2.props.selected : s2.getPreSelection(), {
+                        hour: getHours(e3),
+                        minute: getMinutes(e3)
+                    });
+                    s2.setState({
+                        preSelection: t4
+                    }), s2.props.onChange(t4), s2.props.shouldCloseOnSelect && s2.setOpen(false), s2.props.showTimeInput && s2.setOpen(true), s2.setState({
+                        inputValue: null
+                    });
+                }), de$1(ye(s2), "onInputClick", function() {
+                    s2.props.disabled || s2.props.readOnly || s2.setOpen(true), s2.props.onInputClick();
+                }), de$1(ye(s2), "onInputKeyDown", function(e3) {
+                    s2.props.onKeyDown(e3);
+                    var t4 = e3.key;
+                    if (s2.state.open || s2.props.inline || s2.props.preventOpenOnFocus) {
+                        if (s2.state.open) {
+                            if ("ArrowDown" === t4 || "ArrowUp" === t4) {
+                                e3.preventDefault();
+                                var r2 = s2.calendar.componentNode && s2.calendar.componentNode.querySelector('.react-datepicker__day[tabindex="0"]');
+                                return void(r2 && r2.focus({
+                                    preventScroll: true
+                                }));
                             }
+                            var n2 = _e$1(s2.state.preSelection);
+                            "Enter" === t4 ? (e3.preventDefault(), s2.inputOk() && s2.state.lastPreSelectChange === Ht$1 ? (s2.handleSelect(n2, e3), !s2.props.shouldCloseOnSelect && s2.setPreSelection(n2)) : s2.setOpen(false)) : "Escape" === t4 && (e3.preventDefault(), s2.setOpen(false)), s2.inputOk() || s2.props.onInputError({
+                                code: 1,
+                                msg: "Date input not valid."
+                            });
+                        }
+                    } else
+                        "ArrowDown" !== t4 && "ArrowUp" !== t4 && "Enter" !== t4 || s2.onInputClick();
+                }), de$1(ye(s2), "onDayKeyDown", function(e3) {
+                    s2.props.onKeyDown(e3);
+                    var t4 = e3.key,
+                        r2 = _e$1(s2.state.preSelection);
+                    if ("Enter" === t4)
+                        e3.preventDefault(), s2.handleSelect(r2, e3), !s2.props.shouldCloseOnSelect && s2.setPreSelection(r2);
+                    else if ("Escape" === t4)
+                        e3.preventDefault(), s2.setOpen(false), s2.inputOk() || s2.props.onInputError({
+                            code: 1,
+                            msg: "Date input not valid."
+                        });
+                    else if (!s2.props.disabledKeyboardNavigation) {
+                        var n2;
+                        switch (t4) {
+                            case "ArrowLeft":
+                                n2 = subDays(r2, 1);
+                                break;
+                            case "ArrowRight":
+                                n2 = addDays(r2, 1);
+                                break;
+                            case "ArrowUp":
+                                n2 = subWeeks(r2, 1);
+                                break;
+                            case "ArrowDown":
+                                n2 = addWeeks(r2, 1);
+                                break;
+                            case "PageUp":
+                                n2 = subMonths(r2, 1);
+                                break;
+                            case "PageDown":
+                                n2 = addMonths(r2, 1);
+                                break;
+                            case "Home":
+                                n2 = subYears(r2, 1);
+                                break;
+                            case "End":
+                                n2 = addYears(r2, 1);
+                        }
+                        if (!n2)
+                            return void(s2.props.onInputError && s2.props.onInputError({
+                                code: 1,
+                                msg: "Date input not valid."
+                            }));
+                        if (e3.preventDefault(), s2.setState({
+                                lastPreSelectChange: Ht$1
+                            }), s2.props.adjustDateOnChange && s2.setSelected(n2), s2.setPreSelection(n2), s2.props.inline) {
+                            var o3 = getMonth(r2),
+                                a3 = getMonth(n2),
+                                i2 = getYear(r2),
+                                y2 = getYear(n2);
+                            o3 !== a3 || i2 !== y2 ? s2.setState({
+                                shouldFocusDayInline: true
+                            }) : s2.setState({
+                                shouldFocusDayInline: false
+                            });
                         }
                     }
+                }), de$1(ye(s2), "onPopperKeyDown", function(e3) {
+                    "Escape" === e3.key && (e3.preventDefault(), s2.setState({
+                        preventFocus: true
+                    }, function() {
+                        s2.setOpen(false), setTimeout(function() {
+                            s2.setFocus(), s2.setState({
+                                preventFocus: false
+                            });
+                        });
+                    }));
+                }), de$1(ye(s2), "onClearClick", function(e3) {
+                    e3 && e3.preventDefault && e3.preventDefault(), s2.props.selectsRange ? s2.props.onChange([null, null], e3) : s2.props.onChange(null, e3), s2.setState({
+                        inputValue: null
+                    });
+                }), de$1(ye(s2), "clear", function() {
+                    s2.onClearClick();
+                }), de$1(ye(s2), "onScroll", function(e3) {
+                    "boolean" == typeof s2.props.closeOnScroll && s2.props.closeOnScroll ? e3.target !== document && e3.target !== document.documentElement && e3.target !== document.body || s2.setOpen(false) : "function" == typeof s2.props.closeOnScroll && s2.props.closeOnScroll(e3) && s2.setOpen(false);
+                }), de$1(ye(s2), "renderCalendar", function() {
+                    return s2.props.inline || s2.isCalendarOpen() ? React__default.default.createElement(Kt$1, {
+                        ref: function(e3) {
+                            s2.calendar = e3;
+                        },
+                        locale: s2.props.locale,
+                        calendarStartDay: s2.props.calendarStartDay,
+                        chooseDayAriaLabelPrefix: s2.props.chooseDayAriaLabelPrefix,
+                        disabledDayAriaLabelPrefix: s2.props.disabledDayAriaLabelPrefix,
+                        weekAriaLabelPrefix: s2.props.weekAriaLabelPrefix,
+                        monthAriaLabelPrefix: s2.props.monthAriaLabelPrefix,
+                        adjustDateOnChange: s2.props.adjustDateOnChange,
+                        setOpen: s2.setOpen,
+                        shouldCloseOnSelect: s2.props.shouldCloseOnSelect,
+                        dateFormat: s2.props.dateFormatCalendar,
+                        useWeekdaysShort: s2.props.useWeekdaysShort,
+                        formatWeekDay: s2.props.formatWeekDay,
+                        dropdownMode: s2.props.dropdownMode,
+                        selected: s2.props.selected,
+                        preSelection: s2.state.preSelection,
+                        onSelect: s2.handleSelect,
+                        onWeekSelect: s2.props.onWeekSelect,
+                        openToDate: s2.props.openToDate,
+                        minDate: s2.props.minDate,
+                        maxDate: s2.props.maxDate,
+                        selectsStart: s2.props.selectsStart,
+                        selectsEnd: s2.props.selectsEnd,
+                        selectsRange: s2.props.selectsRange,
+                        startDate: s2.props.startDate,
+                        endDate: s2.props.endDate,
+                        excludeDates: s2.props.excludeDates,
+                        excludeDateIntervals: s2.props.excludeDateIntervals,
+                        filterDate: s2.props.filterDate,
+                        onClickOutside: s2.handleCalendarClickOutside,
+                        formatWeekNumber: s2.props.formatWeekNumber,
+                        highlightDates: s2.state.highlightDates,
+                        includeDates: s2.props.includeDates,
+                        includeDateIntervals: s2.props.includeDateIntervals,
+                        includeTimes: s2.props.includeTimes,
+                        injectTimes: s2.props.injectTimes,
+                        inline: s2.props.inline,
+                        shouldFocusDayInline: s2.state.shouldFocusDayInline,
+                        peekNextMonth: s2.props.peekNextMonth,
+                        showMonthDropdown: s2.props.showMonthDropdown,
+                        showPreviousMonths: s2.props.showPreviousMonths,
+                        useShortMonthInDropdown: s2.props.useShortMonthInDropdown,
+                        showMonthYearDropdown: s2.props.showMonthYearDropdown,
+                        showWeekNumbers: s2.props.showWeekNumbers,
+                        showYearDropdown: s2.props.showYearDropdown,
+                        withPortal: s2.props.withPortal,
+                        forceShowMonthNavigation: s2.props.forceShowMonthNavigation,
+                        showDisabledMonthNavigation: s2.props.showDisabledMonthNavigation,
+                        scrollableYearDropdown: s2.props.scrollableYearDropdown,
+                        scrollableMonthYearDropdown: s2.props.scrollableMonthYearDropdown,
+                        todayButton: s2.props.todayButton,
+                        weekLabel: s2.props.weekLabel,
+                        outsideClickIgnoreClass: "react-datepicker-ignore-onclickoutside",
+                        fixedHeight: s2.props.fixedHeight,
+                        monthsShown: s2.props.monthsShown,
+                        monthSelectedIn: s2.state.monthSelectedIn,
+                        onDropdownFocus: s2.handleDropdownFocus,
+                        onMonthChange: s2.props.onMonthChange,
+                        onYearChange: s2.props.onYearChange,
+                        dayClassName: s2.props.dayClassName,
+                        weekDayClassName: s2.props.weekDayClassName,
+                        monthClassName: s2.props.monthClassName,
+                        timeClassName: s2.props.timeClassName,
+                        showTimeSelect: s2.props.showTimeSelect,
+                        showTimeSelectOnly: s2.props.showTimeSelectOnly,
+                        onTimeChange: s2.handleTimeChange,
+                        timeFormat: s2.props.timeFormat,
+                        timeIntervals: s2.props.timeIntervals,
+                        minTime: s2.props.minTime,
+                        maxTime: s2.props.maxTime,
+                        excludeTimes: s2.props.excludeTimes,
+                        filterTime: s2.props.filterTime,
+                        timeCaption: s2.props.timeCaption,
+                        className: s2.props.calendarClassName,
+                        container: s2.props.calendarContainer,
+                        yearItemNumber: s2.props.yearItemNumber,
+                        yearDropdownItemNumber: s2.props.yearDropdownItemNumber,
+                        previousMonthAriaLabel: s2.props.previousMonthAriaLabel,
+                        previousMonthButtonLabel: s2.props.previousMonthButtonLabel,
+                        nextMonthAriaLabel: s2.props.nextMonthAriaLabel,
+                        nextMonthButtonLabel: s2.props.nextMonthButtonLabel,
+                        previousYearAriaLabel: s2.props.previousYearAriaLabel,
+                        previousYearButtonLabel: s2.props.previousYearButtonLabel,
+                        nextYearAriaLabel: s2.props.nextYearAriaLabel,
+                        nextYearButtonLabel: s2.props.nextYearButtonLabel,
+                        timeInputLabel: s2.props.timeInputLabel,
+                        disabledKeyboardNavigation: s2.props.disabledKeyboardNavigation,
+                        renderCustomHeader: s2.props.renderCustomHeader,
+                        popperProps: s2.props.popperProps,
+                        renderDayContents: s2.props.renderDayContents,
+                        onDayMouseEnter: s2.props.onDayMouseEnter,
+                        onMonthMouseLeave: s2.props.onMonthMouseLeave,
+                        selectsDisabledDaysInRange: s2.props.selectsDisabledDaysInRange,
+                        showTimeInput: s2.props.showTimeInput,
+                        showMonthYearPicker: s2.props.showMonthYearPicker,
+                        showFullMonthYearPicker: s2.props.showFullMonthYearPicker,
+                        showTwoColumnMonthYearPicker: s2.props.showTwoColumnMonthYearPicker,
+                        showFourColumnMonthYearPicker: s2.props.showFourColumnMonthYearPicker,
+                        showYearPicker: s2.props.showYearPicker,
+                        showQuarterYearPicker: s2.props.showQuarterYearPicker,
+                        showPopperArrow: s2.props.showPopperArrow,
+                        excludeScrollbar: s2.props.excludeScrollbar,
+                        handleOnKeyDown: s2.props.onKeyDown,
+                        handleOnDayKeyDown: s2.onDayKeyDown,
+                        isInputFocused: s2.state.focused,
+                        customTimeInput: s2.props.customTimeInput,
+                        setPreSelection: s2.setPreSelection
+                    }, s2.props.children) : null;
+                }), de$1(ye(s2), "renderDateInput", function() {
+                    var t4, n2 = r$1(s2.props.className, de$1({}, "react-datepicker-ignore-onclickoutside", s2.state.open)),
+                        o3 = s2.props.customInput || React__default.default.createElement("input", {
+                            type: "text"
+                        }),
+                        a3 = s2.props.customInputRef || "ref",
+                        i2 = "string" == typeof s2.props.value ? s2.props.value : "string" == typeof s2.state.inputValue ? s2.state.inputValue : s2.props.selectsRange ? function(e3, t5, r2) {
+                            if (!e3)
+                                return "";
+                            var n3 = Ne$1(e3, r2),
+                                o4 = t5 ? Ne$1(t5, r2) : "";
+                            return "".concat(n3, " - ").concat(o4);
+                        }(s2.props.startDate, s2.props.endDate, s2.props) : Ne$1(s2.props.selected, s2.props);
+                    return React__default.default.cloneElement(o3, (de$1(t4 = {}, a3, function(e3) {
+                        s2.input = e3;
+                    }), de$1(t4, "value", i2), de$1(t4, "onBlur", s2.handleBlur), de$1(t4, "onChange", s2.handleChange), de$1(t4, "onClick", s2.onInputClick), de$1(t4, "onFocus", s2.handleFocus), de$1(t4, "onKeyDown", s2.onInputKeyDown), de$1(t4, "id", s2.props.id), de$1(t4, "name", s2.props.name), de$1(t4, "autoFocus", s2.props.autoFocus), de$1(t4, "placeholder", s2.props.placeholderText), de$1(t4, "disabled", s2.props.disabled), de$1(t4, "autoComplete", s2.props.autoComplete), de$1(t4, "className", r$1(o3.props.className, n2)), de$1(t4, "title", s2.props.title), de$1(t4, "readOnly", s2.props.readOnly), de$1(t4, "required", s2.props.required), de$1(t4, "tabIndex", s2.props.tabIndex), de$1(t4, "aria-describedby", s2.props.ariaDescribedBy), de$1(t4, "aria-invalid", s2.props.ariaInvalid), de$1(t4, "aria-labelledby", s2.props.ariaLabelledBy), de$1(t4, "aria-required", s2.props.ariaRequired), t4));
+                }), de$1(ye(s2), "renderClearButton", function() {
+                    var t4 = s2.props,
+                        r2 = t4.isClearable,
+                        n2 = t4.selected,
+                        o3 = t4.startDate,
+                        a3 = t4.endDate,
+                        i2 = t4.clearButtonTitle,
+                        p2 = t4.clearButtonClassName,
+                        c2 = void 0 === p2 ? "" : p2,
+                        l2 = t4.ariaLabelClose,
+                        d2 = void 0 === l2 ? "Close" : l2;
+                    return !r2 || null == n2 && null == o3 && null == a3 ? null : React__default.default.createElement("button", {
+                        type: "button",
+                        className: "react-datepicker__close-icon ".concat(c2).trim(),
+                        "aria-label": d2,
+                        onClick: s2.onClearClick,
+                        title: i2,
+                        tabIndex: -1
+                    });
+                }), s2.state = s2.calcInitialState(), s2;
+            }
+            return le$1(a2, [{
+                key: "componentDidMount",
+                value: function() {
+                    window.addEventListener("scroll", this.onScroll, true);
+                }
+            }, {
+                key: "componentDidUpdate",
+                value: function(e3, t3) {
+                    var r2, n2;
+                    e3.inline && (r2 = e3.selected, n2 = this.props.selected, r2 && n2 ? getMonth(r2) !== getMonth(n2) || getYear(r2) !== getYear(n2) : r2 !== n2) && this.setPreSelection(this.props.selected), void 0 !== this.state.monthSelectedIn && e3.monthsShown !== this.props.monthsShown && this.setState({
+                        monthSelectedIn: 0
+                    }), e3.highlightDates !== this.props.highlightDates && this.setState({
+                        highlightDates: mt$1(this.props.highlightDates)
+                    }), t3.focused || je$1(e3.selected, this.props.selected) || this.setState({
+                        inputValue: null
+                    }), t3.open !== this.state.open && (false === t3.open && true === this.state.open && this.props.onCalendarOpen(), true === t3.open && false === this.state.open && this.props.onCalendarClose());
+                }
+            }, {
+                key: "componentWillUnmount",
+                value: function() {
+                    this.clearPreventFocusTimeout(), window.removeEventListener("scroll", this.onScroll, true);
+                }
+            }, {
+                key: "renderInputContainer",
+                value: function() {
+                    return React__default.default.createElement("div", {
+                        className: "react-datepicker__input-container"
+                    }, this.renderDateInput(), this.renderClearButton());
+                }
+            }, {
+                key: "render",
+                value: function() {
+                    var t3 = this.renderCalendar();
+                    if (this.props.inline)
+                        return t3;
+                    if (this.props.withPortal) {
+                        var r2 = this.state.open ? React__default.default.createElement("div", {
+                            className: "react-datepicker__portal"
+                        }, t3) : null;
+                        return this.state.open && this.props.portalId && (r2 = React__default.default.createElement(Rt$1, {
+                            portalId: this.props.portalId,
+                            portalHost: this.props.portalHost
+                        }, r2)), React__default.default.createElement("div", null, this.renderInputContainer(), r2);
+                    }
+                    return React__default.default.createElement(Bt$1, {
+                        className: this.props.popperClassName,
+                        wrapperClassName: this.props.wrapperClassName,
+                        hidePopper: !this.isCalendarOpen(),
+                        portalId: this.props.portalId,
+                        portalHost: this.props.portalHost,
+                        popperModifiers: this.props.popperModifiers,
+                        targetComponent: this.renderInputContainer(),
+                        popperContainer: this.props.popperContainer,
+                        popperComponent: t3,
+                        popperPlacement: this.props.popperPlacement,
+                        popperProps: this.props.popperProps,
+                        popperOnKeyDown: this.onPopperKeyDown,
+                        enableTabLoop: this.props.enableTabLoop
+                    });
+                }
+            }], [{
+                key: "defaultProps",
+                get: function() {
+                    return {
+                        allowSameDay: false,
+                        dateFormat: "MM/dd/yyyy",
+                        dateFormatCalendar: "LLLL yyyy",
+                        onChange: function() {},
+                        disabled: false,
+                        disabledKeyboardNavigation: false,
+                        dropdownMode: "scroll",
+                        onFocus: function() {},
+                        onBlur: function() {},
+                        onKeyDown: function() {},
+                        onInputClick: function() {},
+                        onSelect: function() {},
+                        onClickOutside: function() {},
+                        onMonthChange: function() {},
+                        onCalendarOpen: function() {},
+                        onCalendarClose: function() {},
+                        preventOpenOnFocus: false,
+                        onYearChange: function() {},
+                        onInputError: function() {},
+                        monthsShown: 1,
+                        readOnly: false,
+                        withPortal: false,
+                        selectsDisabledDaysInRange: false,
+                        shouldCloseOnSelect: true,
+                        showTimeSelect: false,
+                        showTimeInput: false,
+                        showPreviousMonths: false,
+                        showMonthYearPicker: false,
+                        showFullMonthYearPicker: false,
+                        showTwoColumnMonthYearPicker: false,
+                        showFourColumnMonthYearPicker: false,
+                        showYearPicker: false,
+                        showQuarterYearPicker: false,
+                        strictParsing: false,
+                        timeIntervals: 30,
+                        timeCaption: "Time",
+                        previousMonthAriaLabel: "Previous Month",
+                        previousMonthButtonLabel: "Previous Month",
+                        nextMonthAriaLabel: "Next Month",
+                        nextMonthButtonLabel: "Next Month",
+                        previousYearAriaLabel: "Previous Year",
+                        previousYearButtonLabel: "Previous Year",
+                        nextYearAriaLabel: "Next Year",
+                        nextYearButtonLabel: "Next Year",
+                        timeInputLabel: "Time",
+                        enableTabLoop: true,
+                        yearItemNumber: 12,
+                        renderDayContents: function(e3) {
+                            return e3;
+                        },
+                        focusSelectedMonth: false,
+                        showPopperArrow: true,
+                        excludeScrollbar: true,
+                        customTimeInput: null,
+                        calendarStartDay: void 0
+                    };
                 }
+            }]), a2;
+        }(),
+        jt$1 = "input",
+        Ht$1 = "navigate";
+    const reactDatepicker = "";
+    var __rest$a = globalThis && globalThis.__rest || function(s2, e3) {
+        var t2 = {};
+        for (var p2 in s2)
+            if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
+                t2[p2] = s2[p2];
+        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
+            for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
+                if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
+                    t2[p2[i2]] = s2[p2[i2]];
             }
+        return t2;
+    };
+    const {
+        stateChangeTypes: stateChangeTypes$2
+    } = useSelect;
+    const SelectedItem$1 = styled__default.default.div`
+    width: 100%;
+    font-size: ${(props) => props.size ? `${props.size}rem` : props.theme.font.size};
+    font-weight: 300;
+`;
+    const Wrapper$9 = styled__default.default.div`
+    display: inline-flex;
+    width: 6.25rem;
+    height: 1.5rem;
+    border-radius: 0.25rem;
+
+    ${(props) => {
+    if (props.isDisabled) {
+      return `
+                border: 1px solid ${props.theme.colors.grey1};
+                cursor: not-allowed;
+            `;
+    }
+    if (props.isErrored) {
+      return `
+    border: 1 px solid $ {
+        props.theme.colors.error
+    };
+    `;
+    }
+    return `
+    border: 1 px solid $ {
+        props.theme.colors.grey1
+    };
+    `;
+  }}
+`;
+    const SelectButton$1 = styled__default.default.button`
+    cursor: pointer;
+
+    display: inline-flex;
+    flex: 1 1 auto;
+    align-items: center;
+    justify-content: space-between;
+
+    width: 100%;
+    height: 100%;
+    padding: 0 0.5rem 0 1rem;
+
+    font-size: ${(props) => props.theme.font.size};
+
+    border: none;
+    outline: 0;
+
+    :not(:enabled) {
+        cursor: not-allowed;
+    }
+`;
+    const SelectButtonPrimary = styled__default.default(SelectButton$1)`
+    justify-content: start;
+
+    width: 100%;
+    padding: 0 0.25rem;
+
+    font-size: 0.875rem;
+    color: ${(props) => props.theme.colors.text};
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border-radius: 0.25rem;
+
+    :hover:enabled {
+        background-color: ${(props) => props.theme.colors.grey2};
+    }
+
+    svg {
+        width: 1rem !important;
+        height: 0.8rem;
+        margin-left: 0.5rem !important;
+    }
+
+    :disabled {
+        color: ${(props) => props.theme.colors.grey2};
+
+        svg {
+            color: ${(props) => props.theme.colors.grey2};
         }
-    });
-    prism.languages.sql = {
-        "comment": {
-            pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
-            lookbehind: true
-        },
-        "variable": [{
-            pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
-            greedy: true
-        }, /@[\w.$]+/],
-        "string": {
-            pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
-            greedy: true,
-            lookbehind: true
-        },
-        "identifier": {
-            pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
-            greedy: true,
-            lookbehind: true,
-            inside: {
-                "punctuation": /^`|`$/
+    }
+`;
+    const DatepickerListItem = styled__default.default.span`
+    cursor: pointer;
+    user-select: none;
+
+    overflow: hidden;
+    display: flex;
+    align-items: center;
+
+    width: 100%;
+    min-height: 2rem;
+    padding: 0.25rem 1.5rem;
+
+    font-size: ${(props) => props.size ? `${props.size}rem` : props.theme.font.size};
+    font-weight: 300;
+    color: ${(props) => props.isSelected ? "#FFF" : props.theme.colors.text};
+    text-overflow: ellipsis;
+    white-space: nowrap;
+
+    background-color: ${(props) => {
+    if (props.isSelected) {
+      return props.theme.colors.primary;
+    }
+    if (props.hovered) {
+      return props.theme.colors.grey2;
+    }
+    return props.theme.colors.grey1;
+  }};
+
+    :active {
+        background-color: ${(props) => props.theme.colors.grey1};
+    }
+
+    &:last-child {
+        border-bottom: none;
+    }
+`;
+    const DropdownList$2 = styled__default.default.div`
+    overflow-y: auto;
+    display: ${(props) => props.isOpen ? "flex" : "none"};
+    flex-direction: column;
+    gap: 0.125rem;
+
+    max-height: calc(${(props) => (props.maxItems || 5) * 2}em + 2px);
+    margin-left: ${(props) => props.displacement}rem;
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border: none;
+    outline: 0;
+`;
+
+    function DatepickerSelect(props) {
+        var _a3, _b, _c;
+        const referenceElement = React.useRef(null);
+        const popperElement = React.useRef(null);
+        const {
+            styles: styles2,
+            attributes: attributes2,
+            update: update2
+        } = usePopper$1(referenceElement.current, popperElement.current, {
+            modifiers: [sameWidthModifier],
+            placement: props.placement || "bottom-start"
+        });
+        const [pendingHighlight, setPendingHighlight] = React.useState(null);
+        const {
+            isOpen,
+            selectedItem,
+            getToggleButtonProps,
+            getMenuProps,
+            highlightedIndex,
+            getItemProps,
+            setHighlightedIndex
+        } = useSelect(Object.assign({
+            initialSelectedItem: props.initialValue,
+            itemToString: (item) => item.label,
+            items: props.items,
+            onSelectedItemChange: (changes) => {
+                const selected = changes.selectedItem;
+                if (props.onSelect) {
+                    props.onSelect(selected);
+                }
+            },
+            stateReducer: (state, {
+                changes,
+                type: type2
+            }) => {
+                if (type2 === stateChangeTypes$2.ToggleButtonClick) {
+                    setPendingHighlight(changes.selectedItem ? props.items.findIndex((i2) => i2.value === changes.selectedItem.value) : 0);
+                }
+                return changes;
             }
-        },
-        "function": /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
-        "keyword": /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
-        "boolean": /\b(?:FALSE|NULL|TRUE)\b/i,
-        "number": /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
-        "operator": /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
-        "punctuation": /[;[\]()`,.]/
-    };
-    (function(Prism2) {
-        var templateString = Prism2.languages.javascript["template-string"];
-        var templateLiteralPattern = templateString.pattern.source;
-        var interpolationObject = templateString.inside["interpolation"];
-        var interpolationPunctuationObject = interpolationObject.inside["interpolation-punctuation"];
-        var interpolationPattern = interpolationObject.pattern.source;
+        }, props.selectedItem && {
+            selectedItem: props.selectedItem
+        }));
+        React.useEffect(() => {
+            if (isOpen && pendingHighlight !== null) {
+                setHighlightedIndex(pendingHighlight);
+                setPendingHighlight(null);
+            }
+        }, [isOpen, pendingHighlight, setHighlightedIndex]);
+        React.useEffect(() => {
+            if (isOpen && update2) {
+                update2();
+            }
+        }, [isOpen, update2]);
+        const buttonProps = getToggleButtonProps({
+            disabled: props.disabled
+        });
+        const setButtonRef = buttonProps.ref;
+        delete buttonProps.ref;
+        const setButtonReference = (value) => {
+            setButtonRef(value);
+            referenceElement.current = value;
+        };
+        const menuProps = getMenuProps();
+        const setMenuRef = menuProps.ref;
+        delete menuProps.ref;
+        const setMenuReference = (value) => {
+            var _a4;
+            setMenuRef(value);
+            popperElement.current = value;
+            (_a4 = props.dropdownRef) === null || _a4 === void 0 ? void 0 : _a4.call(props, value);
+        };
+        return jsxRuntime.exports.jsx(Tooltip$1, {
+            content: props.errorMsg,
+            disabled: !props.errorMsg,
+            styling: "error",
+            children: jsxRuntime.exports.jsxs(Wrapper$9, {
+                className: props.className,
+                isDisabled: props.disabled,
+                isErrored: !!props.errorMsg,
+                onClick: props.onClick,
+                style: props.style,
+                children: [jsxRuntime.exports.jsxs(SelectButtonPrimary, Object.assign({
+                    disabled: props.disabled
+                }, buttonProps, {
+                    ref: setButtonReference,
+                    type: "button",
+                    children: [jsxRuntime.exports.jsx(SelectedItem$1, {
+                        size: props.size,
+                        children: selectedItem ? selectedItem.label : "Select"
+                    }), jsxRuntime.exports.jsx(Chevron$2, {
+                        disabled: props.disabled,
+                        isOpen
+                    })]
+                })), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(DropdownList$2, Object.assign({}, menuProps, attributes2.popper, {
+                    className: `${(_a3 = menuProps === null || menuProps === void 0 ? void 0 : menuProps.className) !== null && _a3 !== void 0 ? _a3 : ""} ${(_c = (_b = attributes2 === null || attributes2 === void 0 ? void 0 : attributes2.popper) === null || _b === void 0 ? void 0 : _b.className) !== null && _c !== void 0 ? _c : ""} ${props.itemClass}`,
+                    displacement: props.displacement,
+                    isOpen,
+                    maxItems: 7,
+                    ref: setMenuReference,
+                    style: Object.assign(Object.assign({}, styles2.popper), {
+                        marginTop: `0.8rem`,
+                        width: "16.25rem",
+                        zIndex: 9999
+                    }),
+                    children: props.items.map((item, index2) => {
+                        const _a4 = getItemProps({
+                                index: index2,
+                                item
+                            }),
+                            {
+                                itemClassName
+                            } = _a4,
+                            itemProps = __rest$a(_a4, ["itemClassName"]);
+                        return React.createElement(DatepickerListItem, Object.assign({}, itemProps, {
+                            "aria-selected": selectedItem.label === item.label,
+                            className: `${itemClassName} ${props.itemClass}`,
+                            hovered: index2 === highlightedIndex,
+                            isSelected: selectedItem.label === item.label,
+                            key: `item-${index2}`,
+                            size: props.size,
+                            title: item.label
+                        }), item.label);
+                    })
+                })), document.body)]
+            })
+        });
+    }
+
+    function getMonths() {
+        const months = [];
+        for (let i2 = 0; i2 < 12; i2++) {
+            months.push({
+                label: enGB.localize.month(i2),
+                value: i2
+            });
+        }
+        return months;
+    }
+
+    function getYears(minDate, maxDate) {
+        var _a3, _b;
+        const minYear = (_a3 = minDate === null || minDate === void 0 ? void 0 : minDate.getFullYear()) !== null && _a3 !== void 0 ? _a3 : 1900;
+        const maxYear = (_b = maxDate === null || maxDate === void 0 ? void 0 : maxDate.getFullYear()) !== null && _b !== void 0 ? _b : 2100;
+        return lodash$1.exports.range(minYear, maxYear + 1, 1).map((val) => ({
+            label: val.toString(),
+            value: val
+        }));
+    }
+    const IGNORE_CLASSNAME = "react-datepicker-ignore-onclickoutside";
+    const DatepickerWrapper$1 = styled__default.default.div`
+    /* stylelint-disable selector-class-pattern */
+    display: flex;
+    flex-direction: ${(props) => props.inline ? "column" : "row"};
+    align-items: ${(props) => props.inline ? "baseline" : "center"};
+
+    width: 8.5rem;
+
+    color: ${(props) => props.theme.colors.text};
+
+    .react-datepicker-popper {
+        z-index: 5;
+        width: 16.45rem;
+        height: 18.5rem;
+    }
+
+    .react-datepicker-wrapper {
+        width: auto;
+        margin-top: 1rem;
+        margin-left: -8.5rem;
+
+        ${(props) => {
+    if (props.showsRange && props.showsTime) {
+      return `margin-left: -19.045rem;
+                margin-top: 3rem;`;
+    }
+    if (props.showsRange) {
+      return `
+    margin - left: -19.045 rem;
+    `;
+    }
+    if (props.showsTime) {
+      return `
+    margin - left: -14 rem;
+    `;
+    }
+  }}
+    }
+
+    .react-datepicker {
+        width: 16.45rem;
+        height: 18.5rem;
+
+        font-family: Manrope, sans-serif;
+        font-size: 0.75rem;
+
+        background-color: ${(props) => props.theme.colors.grey1};
+        border: 1px solid ${(props) => props.theme.colors.grey1};
+        box-shadow: ${(props) => props.theme.shadow.light};
 
-        function createTemplate(language2, tag) {
-            if (!Prism2.languages[language2]) {
-                return void 0;
-            }
-            return {
-                pattern: RegExp("((?:" + tag + ")\\s*)" + templateLiteralPattern),
-                lookbehind: true,
-                greedy: true,
-                inside: {
-                    "template-punctuation": {
-                        pattern: /^`|`$/,
-                        alias: "string"
-                    },
-                    "embedded-code": {
-                        pattern: /[\s\S]+/,
-                        alias: language2
-                    }
-                }
-            };
+        svg {
+            cursor: pointer;
         }
-        Prism2.languages.javascript["template-string"] = [
-            createTemplate("css", /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),
-            createTemplate("html", /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source),
-            createTemplate("svg", /\bsvg/.source),
-            createTemplate("markdown", /\b(?:markdown|md)/.source),
-            createTemplate("graphql", /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source),
-            createTemplate("sql", /\bsql/.source),
-            templateString
-        ].filter(Boolean);
 
-        function getPlaceholder(counter2, language2) {
-            return "___" + language2.toUpperCase() + "_" + counter2 + "___";
+        .react-datepicker__triangle {
+            visibility: hidden;
         }
 
-        function tokenizeWithHooks(code2, grammar, language2) {
-            var env2 = {
-                code: code2,
-                grammar,
-                language: language2
-            };
-            Prism2.hooks.run("before-tokenize", env2);
-            env2.tokens = Prism2.tokenize(env2.code, env2.grammar);
-            Prism2.hooks.run("after-tokenize", env2);
-            return env2.tokens;
-        }
+        .react-datepicker__input-time-container {
+            position: absolute;
+            top: -51px;
+            left: 150px;
 
-        function tokenizeInterpolationExpression(expression) {
-            var tempGrammar = {};
-            tempGrammar["interpolation-punctuation"] = interpolationPunctuationObject;
-            var tokens2 = Prism2.tokenize(expression, tempGrammar);
-            if (tokens2.length === 3) {
-                var args = [1, 1];
-                args.push.apply(args, tokenizeWithHooks(tokens2[1], Prism2.languages.javascript, "javascript"));
-                tokens2.splice.apply(tokens2, args);
+            float: none;
+
+            margin: 0;
+
+            color: ${(props) => props.theme.colors.text};
+
+            .react-datepicker-time__caption {
+                display: none;
             }
-            return new Prism2.Token("interpolation", tokens2, interpolationObject.alias, expression);
         }
 
-        function tokenizeEmbedded(code2, grammar, language2) {
-            var _tokens = Prism2.tokenize(code2, {
-                "interpolation": {
-                    pattern: RegExp(interpolationPattern),
-                    lookbehind: true
+        .react-datepicker__month-container {
+            .react-datepicker__header {
+                margin-right: 3px;
+                margin-left: 3px;
+                padding: 1.25em 0.75em 0;
+
+                color: ${(props) => props.theme.colors.text};
+
+                background-color: ${(props) => props.theme.colors.grey1};
+                border: none;
+
+                .react-datepicker__day-names {
+                    display: flex;
+                    gap: 0.125rem;
+                    justify-content: space-around;
+                    margin-bottom: 0;
+
+                    .react-datepicker__day-name {
+                        width: 2rem;
+                        height: 2rem;
+                        margin: 0;
+
+                        line-height: 2rem;
+                        color: ${(props) => props.theme.colors.text};
+                    }
                 }
-            });
-            var placeholderCounter = 0;
-            var placeholderMap = {};
-            var embeddedCode = _tokens.map(function(token) {
-                if (typeof token === "string") {
-                    return token;
-                } else {
-                    var interpolationExpression = token.content;
-                    var placeholder;
-                    while (code2.indexOf(placeholder = getPlaceholder(placeholderCounter++, language2)) !== -1) {}
-                    placeholderMap[placeholder] = interpolationExpression;
-                    return placeholder;
+            }
+
+            .react-datepicker__month {
+                display: grid;
+                gap: 0.125rem;
+
+                /* Switch default margin to padding so it applies background color completely */
+                margin: 0;
+                padding: 0.125rem 0.75rem 0;
+
+                color: ${(props) => props.theme.colors.text};
+
+                background-color: ${(props) => props.theme.colors.grey1};
+
+                .react-datepicker__week {
+                    display: flex;
+                    gap: 0.125rem;
                 }
-            }).join("");
-            var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language2);
-            var placeholders = Object.keys(placeholderMap);
-            placeholderCounter = 0;
 
-            function walkTokens(tokens2) {
-                for (var i2 = 0; i2 < tokens2.length; i2++) {
-                    if (placeholderCounter >= placeholders.length) {
-                        return;
+                .react-datepicker__day {
+                    width: 2rem;
+                    height: 2rem;
+                    margin: 0;
+
+                    line-height: 2rem;
+                    color: ${(props) => props.theme.colors.text};
+
+                    :hover {
+                        background-color: ${(props) => props.theme.colors.grey2};
                     }
-                    var token = tokens2[i2];
-                    if (typeof token === "string" || typeof token.content === "string") {
-                        var placeholder = placeholders[placeholderCounter];
-                        var s2 = typeof token === "string" ? token : token.content;
-                        var index2 = s2.indexOf(placeholder);
-                        if (index2 !== -1) {
-                            ++placeholderCounter;
-                            var before = s2.substring(0, index2);
-                            var middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);
-                            var after = s2.substring(index2 + placeholder.length);
-                            var replacement = [];
-                            if (before) {
-                                replacement.push(before);
-                            }
-                            replacement.push(middle);
-                            if (after) {
-                                var afterTokens = [after];
-                                walkTokens(afterTokens);
-                                replacement.push.apply(replacement, afterTokens);
-                            }
-                            if (typeof token === "string") {
-                                tokens2.splice.apply(tokens2, [i2, 1].concat(replacement));
-                                i2 += replacement.length - 1;
-                            } else {
-                                token.content = replacement;
-                            }
+
+                    &.react-datepicker__day--outside-month {
+                        color: ${(props) => props.theme.colors.grey4};
+                    }
+
+                    &.react-datepicker__day--selected {
+                        color: ${(props) => props.theme.colors.blue1};
+                        background-color: ${(props) => props.theme.colors.primary};
+
+                        :hover {
+                            background-color: ${(props) => props.theme.colors.primaryHover};
                         }
-                    } else {
-                        var content2 = token.content;
-                        if (Array.isArray(content2)) {
-                            walkTokens(content2);
-                        } else {
-                            walkTokens([content2]);
+                    }
+
+                    &.react-datepicker__day--keyboard-selected {
+                        color: ${(props) => props.theme.colors.text};
+                        background-color: ${(props) => curriedTransparentize$2(0.8, props.theme.colors.primary)};
+                        border: 1px solid ${(props) => props.theme.colors.primary}
+
+                        :hover {
+                            background-color: ${(props) => curriedTransparentize$2(0.6, props.theme.colors.primary)};
                         }
                     }
-                }
-            }
-            walkTokens(embeddedTokens);
-            return new Prism2.Token(language2, embeddedTokens, "language-" + language2, code2);
-        }
-        var supportedLanguages = {
-            "javascript": true,
-            "js": true,
-            "typescript": true,
-            "ts": true,
-            "jsx": true,
-            "tsx": true
-        };
-        Prism2.hooks.add("after-tokenize", function(env2) {
-            if (!(env2.language in supportedLanguages)) {
-                return;
-            }
 
-            function findTemplateStrings(tokens2) {
-                for (var i2 = 0, l2 = tokens2.length; i2 < l2; i2++) {
-                    var token = tokens2[i2];
-                    if (typeof token === "string") {
-                        continue;
+                    &.react-datepicker__day--in-range {
+                        color: ${(props) => props.theme.colors.blue1};
+                        background-color: ${(props) => curriedTransparentize$2(0.2, props.theme.colors.primary)};
                     }
-                    var content2 = token.content;
-                    if (!Array.isArray(content2)) {
-                        if (typeof content2 !== "string") {
-                            findTemplateStrings([content2]);
-                        }
-                        continue;
+
+                    &.react-datepicker__day--in-selecting-range {
+                        color: ${(props) => props.theme.colors.blue1};
+                        background-color: ${(props) => props.theme.colors.primary};
                     }
-                    if (token.type === "template-string") {
-                        var embedded = content2[1];
-                        if (content2.length === 3 && typeof embedded !== "string" && embedded.type === "embedded-code") {
-                            var code2 = stringContent2(embedded);
-                            var alias = embedded.alias;
-                            var language2 = Array.isArray(alias) ? alias[0] : alias;
-                            var grammar = Prism2.languages[language2];
-                            if (!grammar) {
-                                continue;
-                            }
-                            content2[1] = tokenizeEmbedded(code2, grammar, language2);
+
+                    &.react-datepicker__day--selecting-range-end {
+                        font-weight: normal;
+                        color: ${(props) => props.theme.colors.blue1};
+                        background-color: ${(props) => props.theme.colors.primary};
+                    }
+
+                    &.react-datepicker__day--disabled {
+                        color: ${(props) => props.theme.colors.grey3};
+
+                        :hover {
+                            background-color: ${(props) => props.theme.colors.grey1};
                         }
-                    } else {
-                        findTemplateStrings(content2);
                     }
                 }
             }
-            findTemplateStrings(env2.tokens);
-        });
+        }
+    }
+    /* stylelint-enable selector-class-pattern */
+`;
+    const DatepickerInputs = styled__default.default.div`
+    display: flex;
+    gap: 0.5rem;
+`;
+    const HeaderWrapper = styled__default.default.div`
+    display: flex;
+    flex-direction: column;
+    align-items: center;
+    padding-bottom: 0.75rem;
+`;
+    const MonthNavigation = styled__default.default.div`
+    display: flex;
+    align-items: center;
+    justify-content: space-between;
+`;
+    const DropdownsWrapper = styled__default.default.div`
+    display: flex;
+    align-items: center;
+    justify-content: center;
+`;
+    const MonthButton = styled__default.default(Button$3)`
+    min-width: 0;
+    height: 1.5rem;
+    margin: 0;
+    padding: 0.75rem 0.37rem;
 
-        function stringContent2(value) {
-            if (typeof value === "string") {
-                return value;
-            } else if (Array.isArray(value)) {
-                return value.map(stringContent2).join("");
-            } else {
-                return stringContent2(value.content);
-            }
+    svg {
+        width: 0.75rem;
+        height: 0.75rem;
+        color: ${(props) => props.theme.colors.grey5};
+    }
+
+    :hover:not(:disabled) {
+        svg {
+            color: ${(props) => props.theme.colors.text};
         }
-    })(prism);
-    (function(Prism2) {
-        Prism2.languages.typescript = Prism2.languages.extend("javascript", {
-            "class-name": {
-                pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
-                lookbehind: true,
-                greedy: true,
-                inside: null
-            },
-            "builtin": /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
-        });
-        Prism2.languages.typescript.keyword.push(
-            /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
-            /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
-            /\btype\b(?=\s*(?:[\{*]|$))/
-        );
-        delete Prism2.languages.typescript["parameter"];
-        delete Prism2.languages.typescript["literal-property"];
-        var typeInside = Prism2.languages.extend("typescript", {});
-        delete typeInside["class-name"];
-        Prism2.languages.typescript["class-name"].inside = typeInside;
-        Prism2.languages.insertBefore("typescript", "function", {
-            "decorator": {
-                pattern: /@[$\w\xA0-\uFFFF]+/,
-                inside: {
-                    "at": {
-                        pattern: /^@/,
-                        alias: "operator"
+    }
+`;
+    const MonthSelect = styled__default.default(DatepickerSelect)`
+    width: 6.25rem;
+    margin-right: 0.55em;
+    font-size: 0.875rem;
+`;
+    const YearSelect = styled__default.default(DatepickerSelect)`
+    width: 3.75rem;
+    margin-right: 0.8em;
+`;
+    const EndDateInputWrapper = styled__default.default.div`
+    display: flex;
+    gap: 0.5rem;
+    align-items: center;
+`;
+    const DateTimeWrapper = styled__default.default.div`
+    display: flex;
+    flex-direction: ${(props) => props.isRange ? "column" : "row"};
+    gap: ${(props) => props.isRange ? "none" : "0.5rem"};
+`;
+    const DateInput = styled__default.default.input`
+    display: flex;
+    align-items: center;
+
+    width: 8.5rem;
+    height: 2.5rem;
+    padding: 0 1rem;
+
+    font-size: 1rem;
+    color: ${(props) => props.disabled ? props.theme.colors.grey2 : props.theme.colors.text};
+    text-align: center;
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border: 1px solid ${(props) => props.theme.colors.grey1};
+    border-radius: 0.25rem;
+    border-radius: ${(props) => props.isTimeRange ? "0.25rem 0.25rem 0rem 0rem" : "0.25rem"};
+    outline: 0;
+
+    :focus:not(:disabled) {
+        border: 1px solid ${(props) => props.theme.colors.grey3};
+    }
+
+    :hover:not(:disabled) {
+        background-color: ${(props) => props.theme.colors.grey2};
+    }
+
+    :disabled {
+        cursor: not-allowed;
+    }
+
+    ::placeholder {
+        font-style: italic;
+    }
+
+    ::-webkit-calendar-picker-indicator {
+        display: none;
+        background: none;
+    }
+`;
+    const TimeInput = styled__default.default(Input$3)`
+    width: ${(props) => props.isRange ? "8.5rem" : "5rem"};
+
+    input {
+        position: relative;
+
+        display: flex;
+        justify-content: center;
+
+        padding: 0.5rem;
+
+        font-size: 1rem;
+        color: ${(props) => props.theme.colors.text};
+        text-align: center;
+
+        border-radius: ${(props) => props.isRange ? "0rem 0rem 0.25rem 0.25rem" : "0.25rem"};
+
+        :focus:not(:disabled) {
+            border: 1px solid ${(props) => props.theme.colors.grey3};
+        }
+
+        ::-webkit-calendar-picker-indicator {
+            display: none;
+            background: none;
+        }
+
+        ::after {
+            content: '';
+
+            position: absolute;
+            top: 0;
+            left: 1.2rem;
+
+            display: block;
+
+            width: 6rem;
+
+            border-top: ${(props) => props.isRange ? `1px solid ${props.theme.colors.grey2}` : "none"};
+        }
+    }
+`;
+
+    function DatePickerHeader({
+        date,
+        changeMonth,
+        changeYear,
+        decreaseMonth,
+        increaseMonth,
+        selectItemClass,
+        portalsRef,
+        minDate,
+        maxDate
+    }) {
+        const months = React.useMemo(() => getMonths(), []);
+        const years = React.useMemo(() => getYears(minDate, maxDate), [minDate, maxDate]);
+        const selectedMonth = React.useMemo(() => {
+            return {
+                label: enGB.localize.month(date.getMonth()),
+                value: date.getMonth()
+            };
+        }, [date]);
+        const selectedYear = React.useMemo(() => ({
+            label: date.getFullYear().toString(),
+            value: date.getFullYear()
+        }), [date]);
+        return jsxRuntime.exports.jsx(HeaderWrapper, {
+            children: jsxRuntime.exports.jsxs(DropdownsWrapper, {
+                children: [jsxRuntime.exports.jsx(MonthSelect, {
+                    displacement: -1.1,
+                    dropdownRef: (element2) => {
+                        if (portalsRef) {
+                            portalsRef.current[0] = element2;
+                        }
                     },
-                    "function": /^[\s\S]+/
-                }
-            },
-            "generic-function": {
-                pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
-                greedy: true,
-                inside: {
-                    "function": /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
-                    "generic": {
-                        pattern: /<[\s\S]+/,
-                        alias: "class-name",
-                        inside: typeInside
-                    }
-                }
-            }
-        });
-        Prism2.languages.ts = Prism2.languages.typescript;
-    })(prism);
-    (function(Prism2) {
-        Prism2.languages.insertBefore("javascript", "function-variable", {
-            "method-variable": {
-                pattern: RegExp("(\\.\\s*)" + Prism2.languages.javascript["function-variable"].pattern.source),
-                lookbehind: true,
-                alias: ["function-variable", "method", "function", "property-access"]
-            }
-        });
-        Prism2.languages.insertBefore("javascript", "function", {
-            "method": {
-                pattern: RegExp("(\\.\\s*)" + Prism2.languages.javascript["function"].source),
-                lookbehind: true,
-                alias: ["function", "property-access"]
-            }
-        });
-        Prism2.languages.insertBefore("javascript", "constant", {
-            "known-class-name": [{
-                pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/,
-                alias: "class-name"
-            }, {
-                pattern: /\b(?:[A-Z]\w*)Error\b/,
-                alias: "class-name"
-            }]
+                    itemClass: `${IGNORE_CLASSNAME} ${selectItemClass}`,
+                    items: months,
+                    onSelect: (item) => changeMonth(item.value),
+                    selectedItem: selectedMonth,
+                    size: 0.875
+                }), jsxRuntime.exports.jsx(YearSelect, {
+                    displacement: -7.8,
+                    dropdownRef: (element2) => {
+                        if (portalsRef) {
+                            portalsRef.current[1] = element2;
+                        }
+                    },
+                    itemClass: `${IGNORE_CLASSNAME} ${selectItemClass}`,
+                    items: years,
+                    onSelect: (item) => changeYear(item.value),
+                    selectedItem: selectedYear,
+                    size: 0.875
+                }), jsxRuntime.exports.jsxs(MonthNavigation, {
+                    children: [jsxRuntime.exports.jsx(MonthButton, {
+                        onClick: decreaseMonth,
+                        styling: "ghost",
+                        children: jsxRuntime.exports.jsx(ChevronLeft, {})
+                    }), jsxRuntime.exports.jsx(MonthButton, {
+                        onClick: increaseMonth,
+                        styling: "ghost",
+                        children: jsxRuntime.exports.jsx(ChevronRight, {})
+                    })]
+                })]
+            })
         });
+    }
 
-        function withId(source, flags) {
-            return RegExp(source.replace(/<ID>/g, function() {
-                return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
-            }), flags);
+    function getTimeFormatted(time) {
+        const timeString = String(time);
+        if (timeString.length > 1) {
+            return timeString;
         }
-        Prism2.languages.insertBefore("javascript", "keyword", {
-            "imports": {
-                pattern: withId(/(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source),
-                lookbehind: true,
-                inside: Prism2.languages.javascript
-            },
-            "exports": {
-                pattern: withId(/(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source),
-                lookbehind: true,
-                inside: Prism2.languages.javascript
-            }
-        });
-        Prism2.languages.javascript["keyword"].unshift({
-            pattern: /\b(?:as|default|export|from|import)\b/,
-            alias: "module"
-        }, {
-            pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,
-            alias: "control-flow"
-        }, {
-            pattern: /\bnull\b/,
-            alias: ["null", "nil"]
-        }, {
-            pattern: /\bundefined\b/,
-            alias: "nil"
-        });
-        Prism2.languages.insertBefore("javascript", "operator", {
-            "spread": {
-                pattern: /\.{3}/,
-                alias: "operator"
-            },
-            "arrow": {
-                pattern: /=>/,
-                alias: "operator"
-            }
-        });
-        Prism2.languages.insertBefore("javascript", "punctuation", {
-            "property-access": {
-                pattern: withId(/(\.\s*)#?<ID>/.source),
-                lookbehind: true
-            },
-            "maybe-class-name": {
-                pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/,
-                lookbehind: true
-            },
-            "dom": {
-                pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/,
-                alias: "variable"
-            },
-            "console": {
-                pattern: /\bconsole(?=\s*\.)/,
-                alias: "class-name"
+        return `0${timeString}`;
+    }
+
+    function getInitialTime(initialDate, isRange) {
+        if (!initialDate) {
+            if (isRange) {
+                return ["00:00", "00:00"];
             }
-        });
-        var maybeClassNameTokens = ["function", "function-variable", "method", "method-variable", "property-access"];
-        for (var i2 = 0; i2 < maybeClassNameTokens.length; i2++) {
-            var token = maybeClassNameTokens[i2];
-            var value = Prism2.languages.javascript[token];
-            if (Prism2.util.type(value) === "RegExp") {
-                value = Prism2.languages.javascript[token] = {
-                    pattern: value
-                };
+            return "00:00";
+        }
+        if (Array.isArray(initialDate)) {
+            return [
+                `${getTimeFormatted(initialDate[0].getHours())}:${getTimeFormatted(initialDate[0].getMinutes())}`,
+                `${getTimeFormatted(initialDate[1].getHours())}:${getTimeFormatted(initialDate[1].getMinutes())}`
+            ];
+        }
+        return `${getTimeFormatted(initialDate.getHours())}:${getTimeFormatted(initialDate.getMinutes())}`;
+    }
+
+    function getInitialDate(initialDate, formatToApply, isStart) {
+        let formattedDate = "";
+        if (initialDate) {
+            if (Array.isArray(initialDate)) {
+                formattedDate = format$2(initialDate[isStart ? 0 : 1], formatToApply);
+            } else {
+                formattedDate = format$2(initialDate, formatToApply);
             }
-            var inside2 = value.inside || {};
-            value.inside = inside2;
-            inside2["maybe-class-name"] = /^[A-Z][\s\S]*/;
         }
-    })(prism);
-    (function(Prism2) {
-        var javascript = Prism2.util.clone(Prism2.languages.javascript);
-        var space2 = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
-        var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
-        var spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
+        return formattedDate;
+    }
 
-        function re2(source, flags) {
-            source = source.replace(/<S>/g, function() {
-                return space2;
-            }).replace(/<BRACES>/g, function() {
-                return braces;
-            }).replace(/<SPREAD>/g, function() {
-                return spread;
-            });
-            return RegExp(source, flags);
+    function getNewDatetime(date, time) {
+        var _a3, _b, _c, _d, _e2;
+        if (!Array.isArray(date) && !Array.isArray(time)) {
+            const [hours, minutes] = (_a3 = time === null || time === void 0 ? void 0 : time.split(":")) !== null && _a3 !== void 0 ? _a3 : ["00", "00"];
+            const newDate = date ? new Date(date.setHours(Number(hours), Number(minutes))) : null;
+            return newDate;
         }
-        spread = re2(spread).source;
-        Prism2.languages.jsx = Prism2.languages.extend("markup", javascript);
-        Prism2.languages.jsx.tag.pattern = re2(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source);
-        Prism2.languages.jsx.tag.inside["tag"].pattern = /^<\/?[^\s>\/]*/;
-        Prism2.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
-        Prism2.languages.jsx.tag.inside["tag"].inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
-        Prism2.languages.jsx.tag.inside["comment"] = javascript["comment"];
-        Prism2.languages.insertBefore("inside", "attr-name", {
-            "spread": {
-                pattern: re2(/<SPREAD>/.source),
-                inside: Prism2.languages.jsx
-            }
-        }, Prism2.languages.jsx.tag);
-        Prism2.languages.insertBefore("inside", "special-attr", {
-            "script": {
-                pattern: re2(/=<BRACES>/.source),
-                alias: "language-javascript",
-                inside: {
-                    "script-punctuation": {
-                        pattern: /^=(?=\{)/,
-                        alias: "punctuation"
-                    },
-                    rest: Prism2.languages.jsx
+        const [startHours, startMinutes] = (_c = (_b = time[0]) === null || _b === void 0 ? void 0 : _b.split(":")) !== null && _c !== void 0 ? _c : ["00", "00"];
+        const [endHours, endMinutes] = (_e2 = (_d = time[1]) === null || _d === void 0 ? void 0 : _d.split(":")) !== null && _e2 !== void 0 ? _e2 : ["00", "00"];
+        const dates = date;
+        const startDate = dates[0] ? new Date(dates[0].setHours(Number(startHours), Number(startMinutes))) : null;
+        const endDate = dates[1] ? new Date(dates[1].setHours(Number(endHours), Number(endMinutes))) : null;
+        return [startDate, endDate];
+    }
+
+    function DatePicker(props) {
+        var _a3, _b, _c;
+        const value = (_a3 = props.value) !== null && _a3 !== void 0 ? _a3 : props.initialValue;
+        const [selectedDate, setSelectedDate] = React.useState(value || (props.selectsRange ? [null, null] : null));
+        const [selectedTime, setSelectedTime] = React.useState(() => getInitialTime(value, props.selectsRange));
+        const formatToApply = (_b = props.dateFormat) !== null && _b !== void 0 ? _b : "dd/MM/yyyy";
+        const [startDate, setStartDate] = React.useState(() => getInitialDate(value, formatToApply, true));
+        const [endDate, setEndDate] = React.useState(() => getInitialDate(value, formatToApply, false));
+        const [isSelectingStart, setIsSelectingStart] = React.useState(null);
+        const selectedDateRef = React.useRef(selectedDate);
+        selectedDateRef.current = selectedDate;
+        const datepickerRef = React.useRef(null);
+        const extraProps = React.useMemo(() => {
+            if (props.selectsRange) {
+                const selectedDates = selectedDate !== null && selectedDate !== void 0 ? selectedDate : [null, null];
+                let {
+                    minDate
+                } = props;
+                if (!isSelectingStart) {
+                    const [currentStartDate] = selectedDates;
+                    minDate = currentStartDate;
                 }
+                return {
+                    endDate: selectedDates[1],
+                    minDate,
+                    startDate: selectedDates[0]
+                };
             }
-        }, Prism2.languages.jsx.tag);
-        var stringifyToken = function(token) {
-            if (!token) {
-                return "";
+            let date = selectedDate;
+            if (Array.isArray(selectedDate)) {
+                [date] = selectedDate;
             }
-            if (typeof token === "string") {
-                return token;
+            return {
+                selected: date
+            };
+        }, [selectedDate, isSelectingStart, props]);
+        const onChangeDate = (date) => {
+            var _a4;
+            if (props.shouldCloseOnSelect) {
+                (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.setOpen(false);
             }
-            if (typeof token.content === "string") {
-                return token.content;
+            if (props.selectsRange) {
+                let currentStartDate;
+                let currentEndDate;
+                if (isSelectingStart) {
+                    currentStartDate = date;
+                    currentEndDate = Array.isArray(selectedDate) ? selectedDate[1] : null;
+                    currentEndDate = currentEndDate && currentEndDate > date ? currentEndDate : date;
+                } else {
+                    currentStartDate = Array.isArray(selectedDate) ? selectedDate[0] : null;
+                    currentEndDate = date;
+                }
+                setStartDate(format$2(currentStartDate, formatToApply));
+                setEndDate(format$2(currentEndDate, formatToApply));
+                setSelectedDate([currentStartDate, currentEndDate]);
+            } else {
+                setSelectedDate(date);
+                setStartDate(format$2(date, formatToApply));
             }
-            return token.content.map(stringifyToken).join("");
         };
-        var walkTokens = function(tokens2) {
-            var openedTags = [];
-            for (var i2 = 0; i2 < tokens2.length; i2++) {
-                var token = tokens2[i2];
-                var notTagNorBrace = false;
-                if (typeof token !== "string") {
-                    if (token.type === "tag" && token.content[0] && token.content[0].type === "tag") {
-                        if (token.content[0].content[0].content === "</") {
-                            if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {
-                                openedTags.pop();
-                            }
-                        } else {
-                            if (token.content[token.content.length - 1].content === "/>")
-                            ;
-                            else {
-                                openedTags.push({
-                                    tagName: stringifyToken(token.content[0].content[1]),
-                                    openedBraces: 0
-                                });
-                            }
+        const onChangeDateInput = (isStartDate, e3) => {
+            var _a4;
+            const target = e3.target;
+            const newDate = parse$9(target.value, formatToApply, new Date());
+            if (newDate instanceof Date && !Number.isNaN(newDate.valueOf()) && !(newDate < props.minDate) && !(newDate > props.maxDate)) {
+                (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.setState({
+                    preSelection: newDate
+                });
+                if (Array.isArray(selectedDate)) {
+                    if (isStartDate) {
+                        let end2 = selectedDate[1];
+                        if (newDate > end2) {
+                            end2 = newDate;
+                            setEndDate(target.value);
                         }
-                    } else if (openedTags.length > 0 && token.type === "punctuation" && token.content === "{") {
-                        openedTags[openedTags.length - 1].openedBraces++;
-                    } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === "punctuation" && token.content === "}") {
-                        openedTags[openedTags.length - 1].openedBraces--;
-                    } else {
-                        notTagNorBrace = true;
+                        setSelectedDate([newDate, end2]);
+                        setStartDate(target.value);
+                        return;
                     }
-                }
-                if (notTagNorBrace || typeof token === "string") {
-                    if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
-                        var plainText = stringifyToken(token);
-                        if (i2 < tokens2.length - 1 && (typeof tokens2[i2 + 1] === "string" || tokens2[i2 + 1].type === "plain-text")) {
-                            plainText += stringifyToken(tokens2[i2 + 1]);
-                            tokens2.splice(i2 + 1, 1);
-                        }
-                        if (i2 > 0 && (typeof tokens2[i2 - 1] === "string" || tokens2[i2 - 1].type === "plain-text")) {
-                            plainText = stringifyToken(tokens2[i2 - 1]) + plainText;
-                            tokens2.splice(i2 - 1, 1);
-                            i2--;
-                        }
-                        tokens2[i2] = new Prism2.Token("plain-text", plainText, null, plainText);
+                    let start2 = selectedDate[0];
+                    if (newDate < start2) {
+                        start2 = newDate;
+                        setStartDate(target.value);
                     }
+                    setSelectedDate([start2, newDate]);
+                    setEndDate(target.value);
+                    return;
                 }
-                if (token.content && typeof token.content !== "string") {
-                    walkTokens(token.content);
-                }
+                setSelectedDate(newDate);
             }
-        };
-        Prism2.hooks.add("after-tokenize", function(env2) {
-            if (env2.language !== "jsx" && env2.language !== "tsx") {
+            if (!isStartDate) {
+                setEndDate(target.value);
                 return;
             }
-            walkTokens(env2.tokens);
-        });
-    })(prism);
-    (function(Prism2) {
-        Prism2.languages.diff = {
-            "coord": [
-                /^(?:\*{3}|-{3}|\+{3}).*$/m,
-                /^@@.*@@$/m,
-                /^\d.*$/m
-            ]
+            setStartDate(target.value);
         };
-        var PREFIXES2 = {
-            "deleted-sign": "-",
-            "deleted-arrow": "<",
-            "inserted-sign": "+",
-            "inserted-arrow": ">",
-            "unchanged": " ",
-            "diff": "!"
+        const onChangeTime = (time, isStartTime) => {
+            if (time) {
+                if (Array.isArray(selectedTime)) {
+                    if (isStartTime) {
+                        setSelectedTime([time, selectedTime[1]]);
+                        return;
+                    }
+                    setSelectedTime([selectedTime[0], time]);
+                    return;
+                }
+                setSelectedTime(time);
+            }
         };
-        Object.keys(PREFIXES2).forEach(function(name2) {
-            var prefix = PREFIXES2[name2];
-            var alias = [];
-            if (!/^\w+$/.test(name2)) {
-                alias.push(/\w+/.exec(name2)[0]);
+        React.useEffect(() => {
+            var _a4;
+            const newValue = (_a4 = props.value) !== null && _a4 !== void 0 ? _a4 : props.initialValue;
+            const newDate = newValue || (props.selectsRange ? [null, null] : null);
+            if (JSON.stringify(newDate) === JSON.stringify(selectedDateRef.current)) {
+                return;
             }
-            if (name2 === "diff") {
-                alias.push("bold");
+            setSelectedDate(newDate);
+            const newTime = getInitialTime(newValue, props.selectsRange);
+            setSelectedTime(newTime);
+            const newStartDate = getInitialDate(newValue, formatToApply, true);
+            setStartDate(newStartDate);
+            const newEndDate = getInitialDate(newValue, formatToApply, false);
+            setEndDate(newEndDate);
+        }, [props.value, props.initialValue]);
+        React.useEffect(() => {
+            var _a4;
+            let time = selectedTime;
+            if (props.selectsRange && !Array.isArray(selectedTime)) {
+                time = [selectedTime, "00:00"];
+                setSelectedTime([selectedTime, "00:00"]);
             }
-            Prism2.languages.diff[name2] = {
-                pattern: RegExp("^(?:[" + prefix + "].*(?:\r\n?|\n|(?![\\s\\S])))+", "m"),
-                alias,
-                inside: {
-                    "line": {
-                        pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
-                        lookbehind: true
-                    },
-                    "prefix": {
-                        pattern: /[\s\S]/,
-                        alias: /\w+/.exec(name2)[0]
-                    }
-                }
-            };
-        });
-        Object.defineProperty(Prism2.languages.diff, "PREFIXES", {
-            value: PREFIXES2
+            const newDateTime = getNewDatetime(selectedDate, time);
+            (_a4 = props.onChange) === null || _a4 === void 0 ? void 0 : _a4.call(props, newDateTime);
+        }, [selectedDate, selectedTime]);
+        return jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, {
+            children: jsxRuntime.exports.jsx(Tooltip$1, {
+                content: props.errorMsg,
+                disabled: !props.errorMsg,
+                styling: "error",
+                children: jsxRuntime.exports.jsxs(DatepickerWrapper$1, {
+                    inline: props.inline,
+                    showsRange: props.selectsRange,
+                    showsTime: props.showTimeInput,
+                    children: [jsxRuntime.exports.jsxs(DatepickerInputs, {
+                        children: [jsxRuntime.exports.jsxs(DateTimeWrapper, {
+                            isRange: props.selectsRange,
+                            children: [jsxRuntime.exports.jsx(DateInput, {
+                                isTimeRange: props.selectsRange && props.showTimeInput,
+                                onChange: (e3) => {
+                                    onChangeDateInput(true, e3);
+                                },
+                                onClick: () => {
+                                    var _a4;
+                                    setIsSelectingStart(true);
+                                    (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.setOpen(true);
+                                },
+                                onFocus: () => {
+                                    var _a4;
+                                    setIsSelectingStart(true);
+                                    (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.setOpen(true);
+                                },
+                                onKeyDown: (e3) => {
+                                    var _a4;
+                                    (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.onInputKeyDown(e3);
+                                },
+                                placeholder: formatToApply,
+                                value: startDate
+                            }), props.showTimeInput && jsxRuntime.exports.jsx(TimeInput, {
+                                isRange: props.selectsRange,
+                                onChange: (e3) => {
+                                    onChangeTime(e3, true);
+                                },
+                                type: "time",
+                                value: Array.isArray(selectedTime) ? selectedTime[0] : selectedTime
+                            })]
+                        }), props.selectsRange && jsxRuntime.exports.jsxs(EndDateInputWrapper, {
+                            children: ["\u2192", jsxRuntime.exports.jsxs(DateTimeWrapper, {
+                                isRange: true,
+                                children: [jsxRuntime.exports.jsx(DateInput, {
+                                    isTimeRange: props.showTimeInput,
+                                    onChange: (e3) => {
+                                        onChangeDateInput(false, e3);
+                                    },
+                                    onClick: () => {
+                                        var _a4;
+                                        setIsSelectingStart(false);
+                                        (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.setOpen(true);
+                                    },
+                                    onFocus: () => {
+                                        var _a4;
+                                        setIsSelectingStart(false);
+                                        (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.setOpen(true);
+                                    },
+                                    onKeyDown: (e3) => {
+                                        var _a4;
+                                        (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.onInputKeyDown(e3);
+                                    },
+                                    placeholder: formatToApply,
+                                    value: endDate
+                                }), props.showTimeInput && jsxRuntime.exports.jsx(TimeInput, {
+                                    isRange: true,
+                                    onChange: (e3) => {
+                                        onChangeTime(e3, false);
+                                    },
+                                    type: "time",
+                                    value: selectedTime[1]
+                                })]
+                            })]
+                        })]
+                    }), jsxRuntime.exports.jsx(Wt$1, Object.assign({
+                        className: props.className,
+                        customInput: jsxRuntime.exports.jsx("div", {}),
+                        disabled: props.disabled,
+                        inline: props.inline,
+                        maxDate: props.maxDate,
+                        onChange: onChangeDate,
+                        ref: datepickerRef,
+                        selectsEnd: !isSelectingStart,
+                        selectsStart: isSelectingStart,
+                        shouldCloseOnSelect: props.shouldCloseOnSelect
+                    }, extraProps, {
+                        popperProps: {
+                            strategy: (_c = props.popperStrategy) !== null && _c !== void 0 ? _c : "absolute"
+                        },
+                        renderCustomHeader: (headerProps) => jsxRuntime.exports.jsx(DatePickerHeader, Object.assign({}, headerProps, {
+                            maxDate: props.maxDate,
+                            minDate: props.minDate,
+                            portalsRef: props.portalsRef,
+                            selectItemClass: props.selectItemClass
+                        }))
+                    }))]
+                })
+            })
         });
-    })(prism);
-    prism.languages.git = {
-        "comment": /^#.*/m,
-        "deleted": /^[-–].*/m,
-        "inserted": /^\+.*/m,
-        "string": /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
-        "command": {
-            pattern: /^.*\$ git .*$/m,
-            inside: {
-                "parameter": /\s--?\w+/
-            }
-        },
-        "coord": /^@@.*@@$/m,
-        "commit-sha1": /^commit \w{40}$/m
-    };
-    prism.languages.go = prism.languages.extend("clike", {
-        "string": {
-            pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
-            lookbehind: true,
-            greedy: true
-        },
-        "keyword": /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
-        "boolean": /\b(?:_|false|iota|nil|true)\b/,
-        "number": [
-            /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
-            /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
-            /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
-        ],
-        "operator": /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
-        "builtin": /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
-    });
-    prism.languages.insertBefore("go", "string", {
-        "char": {
-            pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
-            greedy: true
+    }
+    var COMMON_MIME_TYPES = /* @__PURE__ */ new Map([
+        ["avi", "video/avi"],
+        ["gif", "image/gif"],
+        ["ico", "image/x-icon"],
+        ["jpeg", "image/jpeg"],
+        ["jpg", "image/jpeg"],
+        ["mkv", "video/x-matroska"],
+        ["mov", "video/quicktime"],
+        ["mp4", "video/mp4"],
+        ["pdf", "application/pdf"],
+        ["png", "image/png"],
+        ["zip", "application/zip"],
+        ["doc", "application/msword"],
+        ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"]
+    ]);
+
+    function toFileWithPath(file, path2) {
+        var f2 = withMimeType(file);
+        if (typeof f2.path !== "string") {
+            var webkitRelativePath = file.webkitRelativePath;
+            Object.defineProperty(f2, "path", {
+                value: typeof path2 === "string" ? path2 : typeof webkitRelativePath === "string" && webkitRelativePath.length > 0 ? webkitRelativePath : file.name,
+                writable: false,
+                configurable: false,
+                enumerable: true
+            });
         }
-    });
-    delete prism.languages.go["class-name"];
-    (function(Prism2) {
-        function getPlaceholder(language2, index2) {
-            return "___" + language2.toUpperCase() + index2 + "___";
+        return f2;
+    }
+
+    function withMimeType(file) {
+        var name2 = file.name;
+        var hasExtension = name2 && name2.lastIndexOf(".") !== -1;
+        if (hasExtension && !file.type) {
+            var ext = name2.split(".").pop().toLowerCase();
+            var type2 = COMMON_MIME_TYPES.get(ext);
+            if (type2) {
+                Object.defineProperty(file, "type", {
+                    value: type2,
+                    writable: false,
+                    configurable: false,
+                    enumerable: true
+                });
+            }
         }
-        Object.defineProperties(Prism2.languages["markup-templating"] = {}, {
-            buildPlaceholders: {
-                value: function(env2, language2, placeholderPattern, replaceFilter) {
-                    if (env2.language !== language2) {
-                        return;
-                    }
-                    var tokenStack = env2.tokenStack = [];
-                    env2.code = env2.code.replace(placeholderPattern, function(match2) {
-                        if (typeof replaceFilter === "function" && !replaceFilter(match2)) {
-                            return match2;
-                        }
-                        var i2 = tokenStack.length;
-                        var placeholder;
-                        while (env2.code.indexOf(placeholder = getPlaceholder(language2, i2)) !== -1) {
-                            ++i2;
+        return file;
+    }
+    var FILES_TO_IGNORE = [
+        ".DS_Store",
+        "Thumbs.db"
+    ];
+
+    function fromEvent(evt) {
+        return __awaiter$2(this, void 0, void 0, function() {
+            return __generator(this, function(_a3) {
+                return [2, isDragEvt(evt) && evt.dataTransfer ? getDataTransferFiles(evt.dataTransfer, evt.type) : getInputFiles(evt)];
+            });
+        });
+    }
+
+    function isDragEvt(value) {
+        return !!value.dataTransfer;
+    }
+
+    function getInputFiles(evt) {
+        var files = isInput(evt.target) ? evt.target.files ? fromList(evt.target.files) : [] : [];
+        return files.map(function(file) {
+            return toFileWithPath(file);
+        });
+    }
+
+    function isInput(value) {
+        return value !== null;
+    }
+
+    function getDataTransferFiles(dt2, type2) {
+        return __awaiter$2(this, void 0, void 0, function() {
+            var items, files;
+            return __generator(this, function(_a3) {
+                switch (_a3.label) {
+                    case 0:
+                        if (!dt2.items)
+                            return [3, 2];
+                        items = fromList(dt2.items).filter(function(item) {
+                            return item.kind === "file";
+                        });
+                        if (type2 !== "drop") {
+                            return [2, items];
                         }
-                        tokenStack[i2] = match2;
-                        return placeholder;
-                    });
-                    env2.grammar = Prism2.languages.markup;
+                        return [4, Promise.all(items.map(toFilePromises))];
+                    case 1:
+                        files = _a3.sent();
+                        return [2, noIgnoredFiles(flatten$1(files))];
+                    case 2:
+                        return [2, noIgnoredFiles(fromList(dt2.files).map(function(file) {
+                            return toFileWithPath(file);
+                        }))];
                 }
-            },
-            tokenizePlaceholders: {
-                value: function(env2, language2) {
-                    if (env2.language !== language2 || !env2.tokenStack) {
-                        return;
-                    }
-                    env2.grammar = Prism2.languages[language2];
-                    var j2 = 0;
-                    var keys2 = Object.keys(env2.tokenStack);
+            });
+        });
+    }
 
-                    function walkTokens(tokens2) {
-                        for (var i2 = 0; i2 < tokens2.length; i2++) {
-                            if (j2 >= keys2.length) {
-                                break;
-                            }
-                            var token = tokens2[i2];
-                            if (typeof token === "string" || token.content && typeof token.content === "string") {
-                                var k2 = keys2[j2];
-                                var t2 = env2.tokenStack[k2];
-                                var s2 = typeof token === "string" ? token : token.content;
-                                var placeholder = getPlaceholder(language2, k2);
-                                var index2 = s2.indexOf(placeholder);
-                                if (index2 > -1) {
-                                    ++j2;
-                                    var before = s2.substring(0, index2);
-                                    var middle = new Prism2.Token(language2, Prism2.tokenize(t2, env2.grammar), "language-" + language2, t2);
-                                    var after = s2.substring(index2 + placeholder.length);
-                                    var replacement = [];
-                                    if (before) {
-                                        replacement.push.apply(replacement, walkTokens([before]));
-                                    }
-                                    replacement.push(middle);
-                                    if (after) {
-                                        replacement.push.apply(replacement, walkTokens([after]));
-                                    }
-                                    if (typeof token === "string") {
-                                        tokens2.splice.apply(tokens2, [i2, 1].concat(replacement));
-                                    } else {
-                                        token.content = replacement;
-                                    }
-                                }
-                            } else if (token.content) {
-                                walkTokens(token.content);
+    function noIgnoredFiles(files) {
+        return files.filter(function(file) {
+            return FILES_TO_IGNORE.indexOf(file.name) === -1;
+        });
+    }
+
+    function fromList(items) {
+        var files = [];
+        for (var i2 = 0; i2 < items.length; i2++) {
+            var file = items[i2];
+            files.push(file);
+        }
+        return files;
+    }
+
+    function toFilePromises(item) {
+        if (typeof item.webkitGetAsEntry !== "function") {
+            return fromDataTransferItem(item);
+        }
+        var entry = item.webkitGetAsEntry();
+        if (entry && entry.isDirectory) {
+            return fromDirEntry(entry);
+        }
+        return fromDataTransferItem(item);
+    }
+
+    function flatten$1(items) {
+        return items.reduce(function(acc, files) {
+            return __spread(acc, Array.isArray(files) ? flatten$1(files) : [files]);
+        }, []);
+    }
+
+    function fromDataTransferItem(item) {
+        var file = item.getAsFile();
+        if (!file) {
+            return Promise.reject(item + " is not a File");
+        }
+        var fwp = toFileWithPath(file);
+        return Promise.resolve(fwp);
+    }
+
+    function fromEntry(entry) {
+        return __awaiter$2(this, void 0, void 0, function() {
+            return __generator(this, function(_a3) {
+                return [2, entry.isDirectory ? fromDirEntry(entry) : fromFileEntry(entry)];
+            });
+        });
+    }
+
+    function fromDirEntry(entry) {
+        var reader = entry.createReader();
+        return new Promise(function(resolve2, reject) {
+            var entries = [];
+
+            function readEntries() {
+                var _this = this;
+                reader.readEntries(function(batch) {
+                    return __awaiter$2(_this, void 0, void 0, function() {
+                        var files, err_1, items;
+                        return __generator(this, function(_a3) {
+                            switch (_a3.label) {
+                                case 0:
+                                    if (!!batch.length)
+                                        return [3, 5];
+                                    _a3.label = 1;
+                                case 1:
+                                    _a3.trys.push([1, 3, , 4]);
+                                    return [4, Promise.all(entries)];
+                                case 2:
+                                    files = _a3.sent();
+                                    resolve2(files);
+                                    return [3, 4];
+                                case 3:
+                                    err_1 = _a3.sent();
+                                    reject(err_1);
+                                    return [3, 4];
+                                case 4:
+                                    return [3, 6];
+                                case 5:
+                                    items = Promise.all(batch.map(fromEntry));
+                                    entries.push(items);
+                                    readEntries();
+                                    _a3.label = 6;
+                                case 6:
+                                    return [2];
                             }
-                        }
-                        return tokens2;
-                    }
-                    walkTokens(env2.tokens);
-                }
+                        });
+                    });
+                }, function(err) {
+                    reject(err);
+                });
             }
+            readEntries();
         });
-    })(prism);
-    (function(Prism2) {
-        Prism2.languages.handlebars = {
-            "comment": /\{\{![\s\S]*?\}\}/,
-            "delimiter": {
-                pattern: /^\{\{\{?|\}\}\}?$/,
-                alias: "punctuation"
-            },
-            "string": /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
-            "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][+-]?\d+)?/,
-            "boolean": /\b(?:false|true)\b/,
-            "block": {
-                pattern: /^(\s*(?:~\s*)?)[#\/]\S+?(?=\s*(?:~\s*)?$|\s)/,
-                lookbehind: true,
-                alias: "keyword"
-            },
-            "brackets": {
-                pattern: /\[[^\]]+\]/,
-                inside: {
-                    punctuation: /\[|\]/,
-                    variable: /[\s\S]+/
-                }
-            },
-            "punctuation": /[!"#%&':()*+,.\/;<=>@\[\\\]^`{|}~]/,
-            "variable": /[^!"#%&'()*+,\/;<=>@\[\\\]^`{|}~\s]+/
-        };
-        Prism2.hooks.add("before-tokenize", function(env2) {
-            var handlebarsPattern = /\{\{\{[\s\S]+?\}\}\}|\{\{[\s\S]+?\}\}/g;
-            Prism2.languages["markup-templating"].buildPlaceholders(env2, "handlebars", handlebarsPattern);
-        });
-        Prism2.hooks.add("after-tokenize", function(env2) {
-            Prism2.languages["markup-templating"].tokenizePlaceholders(env2, "handlebars");
+    }
+
+    function fromFileEntry(entry) {
+        return __awaiter$2(this, void 0, void 0, function() {
+            return __generator(this, function(_a3) {
+                return [2, new Promise(function(resolve2, reject) {
+                    entry.file(function(file) {
+                        var fwp = toFileWithPath(file, entry.fullPath);
+                        resolve2(fwp);
+                    }, function(err) {
+                        reject(err);
+                    });
+                })];
+            });
         });
-        Prism2.languages.hbs = Prism2.languages.handlebars;
-    })(prism);
-    prism.languages.json = {
-        "property": {
-            pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
-            lookbehind: true,
-            greedy: true
-        },
-        "string": {
-            pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
-            lookbehind: true,
-            greedy: true
-        },
-        "comment": {
-            pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
-            greedy: true
-        },
-        "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
-        "punctuation": /[{}[\],]/,
-        "operator": /:/,
-        "boolean": /\b(?:false|true)\b/,
-        "null": {
-            pattern: /\bnull\b/,
-            alias: "keyword"
+    }
+    var _default$1 = function(file, acceptedFiles) {
+        if (file && acceptedFiles) {
+            var acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
+            var fileName = file.name || "";
+            var mimeType = (file.type || "").toLowerCase();
+            var baseMimeType = mimeType.replace(/\/.*$/, "");
+            return acceptedFilesArray.some(function(type2) {
+                var validType = type2.trim().toLowerCase();
+                if (validType.charAt(0) === ".") {
+                    return fileName.toLowerCase().endsWith(validType);
+                } else if (validType.endsWith("/*")) {
+                    return baseMimeType === validType.replace(/\/.*$/, "");
+                }
+                return mimeType === validType;
+            });
         }
+        return true;
     };
-    prism.languages.webmanifest = prism.languages.json;
-    prism.languages.less = prism.languages.extend("css", {
-        "comment": [/\/\*[\s\S]*?\*\//, {
-            pattern: /(^|[^\\])\/\/.*/,
-            lookbehind: true
-        }],
-        "atrule": {
-            pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
-            inside: {
-                "punctuation": /[:()]/
+
+    function _slicedToArray$9(arr, i2) {
+        return _arrayWithHoles$9(arr) || _iterableToArrayLimit$9(arr, i2) || _nonIterableRest$9();
+    }
+
+    function _nonIterableRest$9() {
+        throw new TypeError("Invalid attempt to destructure non-iterable instance");
+    }
+
+    function _iterableToArrayLimit$9(arr, i2) {
+        if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
+            return;
+        }
+        var _arr = [];
+        var _n2 = true;
+        var _d = false;
+        var _e2 = void 0;
+        try {
+            for (var _i2 = arr[Symbol.iterator](), _s; !(_n2 = (_s = _i2.next()).done); _n2 = true) {
+                _arr.push(_s.value);
+                if (i2 && _arr.length === i2)
+                    break;
             }
-        },
-        "selector": {
-            pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
-            inside: {
-                "variable": /@+[\w-]+/
+        } catch (err) {
+            _d = true;
+            _e2 = err;
+        } finally {
+            try {
+                if (!_n2 && _i2["return"] != null)
+                    _i2["return"]();
+            } finally {
+                if (_d)
+                    throw _e2;
             }
-        },
-        "property": /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
-        "operator": /[+\-*\/]/
-    });
-    prism.languages.insertBefore("less", "property", {
-        "variable": [{
-                pattern: /@[\w-]+\s*:/,
-                inside: {
-                    "punctuation": /:/
-                }
-            },
-            /@@?[\w-]+/
-        ],
-        "mixin-usage": {
-            pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
-            lookbehind: true,
-            alias: "function"
         }
-    });
-    prism.languages.makefile = {
-        "comment": {
-            pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
-            lookbehind: true
-        },
-        "string": {
-            pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
-            greedy: true
-        },
-        "builtin-target": {
-            pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
-            alias: "builtin"
-        },
-        "target": {
-            pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
-            alias: "symbol",
-            inside: {
-                "variable": /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/
-            }
-        },
-        "variable": /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
-        "keyword": /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
-        "function": {
-            pattern: /(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
-            lookbehind: true
-        },
-        "operator": /(?:::|[?:+!])?=|[|@]/,
-        "punctuation": /[:;(){}]/
+        return _arr;
+    }
+
+    function _arrayWithHoles$9(arr) {
+        if (Array.isArray(arr))
+            return arr;
+    }
+    var FILE_INVALID_TYPE = "file-invalid-type";
+    var FILE_TOO_LARGE = "file-too-large";
+    var FILE_TOO_SMALL = "file-too-small";
+    var TOO_MANY_FILES = "too-many-files";
+    var getInvalidTypeRejectionErr = function getInvalidTypeRejectionErr2(accept) {
+        accept = Array.isArray(accept) && accept.length === 1 ? accept[0] : accept;
+        var messageSuffix = Array.isArray(accept) ? "one of ".concat(accept.join(", ")) : accept;
+        return {
+            code: FILE_INVALID_TYPE,
+            message: "File type must be ".concat(messageSuffix)
+        };
     };
-    prism.languages.objectivec = prism.languages.extend("c", {
-        "string": {
-            pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
-            greedy: true
-        },
-        "keyword": /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
-        "operator": /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
-    });
-    delete prism.languages.objectivec["class-name"];
-    prism.languages.objc = prism.languages.objectivec;
-    prism.languages.ocaml = {
-        "comment": {
-            pattern: /\(\*[\s\S]*?\*\)/,
-            greedy: true
-        },
-        "char": {
-            pattern: /'(?:[^\\\r\n']|\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,
-            greedy: true
-        },
-        "string": [{
-            pattern: /"(?:\\(?:[\s\S]|\r\n)|[^\\\r\n"])*"/,
-            greedy: true
-        }, {
-            pattern: /\{([a-z_]*)\|[\s\S]*?\|\1\}/,
-            greedy: true
-        }],
-        "number": [
-            /\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\b/i,
-            /\b0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]*)?(?:p[+-]?\d[\d_]*)?(?!\w)/i,
-            /\b\d[\d_]*(?:\.[\d_]*)?(?:e[+-]?\d[\d_]*)?(?!\w)/i
-        ],
-        "directive": {
-            pattern: /\B#\w+/,
-            alias: "property"
-        },
-        "label": {
-            pattern: /\B~\w+/,
-            alias: "property"
-        },
-        "type-variable": {
-            pattern: /\B'\w+/,
-            alias: "function"
-        },
-        "variant": {
-            pattern: /`\w+/,
-            alias: "symbol"
-        },
-        "keyword": /\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\b/,
-        "boolean": /\b(?:false|true)\b/,
-        "operator-like-punctuation": {
-            pattern: /\[[<>|]|[>|]\]|\{<|>\}/,
-            alias: "punctuation"
-        },
-        "operator": /\.[.~]|:[=>]|[=<>@^|&+\-*\/$%!?~][!$%&*+\-.\/:<=>?@^|~]*|\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\b/,
-        "punctuation": /;;|::|[(){}\[\].,:;#]|\b_\b/
+    var getTooLargeRejectionErr = function getTooLargeRejectionErr2(maxSize) {
+        return {
+            code: FILE_TOO_LARGE,
+            message: "File is larger than ".concat(maxSize, " bytes")
+        };
     };
-    prism.languages.python = {
-        "comment": {
-            pattern: /(^|[^\\])#.*/,
-            lookbehind: true,
-            greedy: true
-        },
-        "string-interpolation": {
-            pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
-            greedy: true,
-            inside: {
-                "interpolation": {
-                    pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
-                    lookbehind: true,
-                    inside: {
-                        "format-spec": {
-                            pattern: /(:)[^:(){}]+(?=\}$)/,
-                            lookbehind: true
-                        },
-                        "conversion-option": {
-                            pattern: /![sra](?=[:}]$)/,
-                            alias: "punctuation"
-                        },
-                        rest: null
-                    }
-                },
-                "string": /[\s\S]+/
-            }
-        },
-        "triple-quoted-string": {
-            pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
-            greedy: true,
-            alias: "string"
-        },
-        "string": {
-            pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
-            greedy: true
-        },
-        "function": {
-            pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
-            lookbehind: true
-        },
-        "class-name": {
-            pattern: /(\bclass\s+)\w+/i,
-            lookbehind: true
-        },
-        "decorator": {
-            pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
-            lookbehind: true,
-            alias: ["annotation", "punctuation"],
-            inside: {
-                "punctuation": /\./
-            }
-        },
-        "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
-        "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
-        "boolean": /\b(?:False|None|True)\b/,
-        "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
-        "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
-        "punctuation": /[{}[\];(),.:]/
+    var getTooSmallRejectionErr = function getTooSmallRejectionErr2(minSize) {
+        return {
+            code: FILE_TOO_SMALL,
+            message: "File is smaller than ".concat(minSize, " bytes")
+        };
     };
-    prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = prism.languages.python;
-    prism.languages.py = prism.languages.python;
-    prism.languages.reason = prism.languages.extend("clike", {
-        "string": {
-            pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
-            greedy: true
-        },
-        "class-name": /\b[A-Z]\w*/,
-        "keyword": /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/,
-        "operator": /\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/
-    });
-    prism.languages.insertBefore("reason", "class-name", {
-        "char": {
-            pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/,
-            greedy: true
-        },
-        "constructor": /\b[A-Z]\w*\b(?!\s*\.)/,
-        "label": {
-            pattern: /\b[a-z]\w*(?=::)/,
-            alias: "symbol"
+    var TOO_MANY_FILES_REJECTION = {
+        code: TOO_MANY_FILES,
+        message: "Too many files"
+    };
+
+    function fileAccepted(file, accept) {
+        var isAcceptable = file.type === "application/x-moz-file" || _default$1(file, accept);
+        return [isAcceptable, isAcceptable ? null : getInvalidTypeRejectionErr(accept)];
+    }
+
+    function fileMatchSize(file, minSize, maxSize) {
+        if (isDefined(file.size)) {
+            if (isDefined(minSize) && isDefined(maxSize)) {
+                if (file.size > maxSize)
+                    return [false, getTooLargeRejectionErr(maxSize)];
+                if (file.size < minSize)
+                    return [false, getTooSmallRejectionErr(minSize)];
+            } else if (isDefined(minSize) && file.size < minSize)
+                return [false, getTooSmallRejectionErr(minSize)];
+            else if (isDefined(maxSize) && file.size > maxSize)
+                return [false, getTooLargeRejectionErr(maxSize)];
         }
-    });
-    delete prism.languages.reason.function;
-    (function(Prism2) {
-        Prism2.languages.sass = Prism2.languages.extend("css", {
-            "comment": {
-                pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
-                lookbehind: true,
-                greedy: true
-            }
+        return [true, null];
+    }
+
+    function isDefined(value) {
+        return value !== void 0 && value !== null;
+    }
+
+    function allFilesAccepted(_ref2) {
+        var files = _ref2.files,
+            accept = _ref2.accept,
+            minSize = _ref2.minSize,
+            maxSize = _ref2.maxSize,
+            multiple = _ref2.multiple;
+        if (!multiple && files.length > 1) {
+            return false;
+        }
+        return files.every(function(file) {
+            var _fileAccepted = fileAccepted(file, accept),
+                _fileAccepted2 = _slicedToArray$9(_fileAccepted, 1),
+                accepted = _fileAccepted2[0];
+            var _fileMatchSize = fileMatchSize(file, minSize, maxSize),
+                _fileMatchSize2 = _slicedToArray$9(_fileMatchSize, 1),
+                sizeMatch = _fileMatchSize2[0];
+            return accepted && sizeMatch;
         });
-        Prism2.languages.insertBefore("sass", "atrule", {
-            "atrule-line": {
-                pattern: /^(?:[ \t]*)[@+=].+/m,
-                greedy: true,
-                inside: {
-                    "atrule": /(?:@[\w-]+|[+=])/
-                }
-            }
+    }
+
+    function isPropagationStopped(event2) {
+        if (typeof event2.isPropagationStopped === "function") {
+            return event2.isPropagationStopped();
+        } else if (typeof event2.cancelBubble !== "undefined") {
+            return event2.cancelBubble;
+        }
+        return false;
+    }
+
+    function isEvtWithFiles(event2) {
+        if (!event2.dataTransfer) {
+            return !!event2.target && !!event2.target.files;
+        }
+        return Array.prototype.some.call(event2.dataTransfer.types, function(type2) {
+            return type2 === "Files" || type2 === "application/x-moz-file";
         });
-        delete Prism2.languages.sass.atrule;
-        var variable = /\$[-\w]+|#\{\$[-\w]+\}/;
-        var operator2 = [/[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/, {
-            pattern: /(\s)-(?=\s)/,
-            lookbehind: true
-        }];
-        Prism2.languages.insertBefore("sass", "property", {
-            "variable-line": {
-                pattern: /^[ \t]*\$.+/m,
-                greedy: true,
-                inside: {
-                    "punctuation": /:/,
-                    "variable": variable,
-                    "operator": operator2
-                }
-            },
-            "property-line": {
-                pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
-                greedy: true,
-                inside: {
-                    "property": [/[^:\s]+(?=\s*:)/, {
-                        pattern: /(:)[^:\s]+/,
-                        lookbehind: true
-                    }],
-                    "punctuation": /:/,
-                    "variable": variable,
-                    "operator": operator2,
-                    "important": Prism2.languages.sass.important
+    }
+
+    function onDocumentDragOver(event2) {
+        event2.preventDefault();
+    }
+
+    function isIe(userAgent2) {
+        return userAgent2.indexOf("MSIE") !== -1 || userAgent2.indexOf("Trident/") !== -1;
+    }
+
+    function isEdge(userAgent2) {
+        return userAgent2.indexOf("Edge/") !== -1;
+    }
+
+    function isIeOrEdge() {
+        var userAgent2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.navigator.userAgent;
+        return isIe(userAgent2) || isEdge(userAgent2);
+    }
+
+    function composeEventHandlers() {
+        for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
+            fns[_key] = arguments[_key];
+        }
+        return function(event2) {
+            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
+                args[_key2 - 1] = arguments[_key2];
+            }
+            return fns.some(function(fn2) {
+                if (!isPropagationStopped(event2) && fn2) {
+                    fn2.apply(void 0, [event2].concat(args));
                 }
+                return isPropagationStopped(event2);
+            });
+        };
+    }
+
+    function _toConsumableArray$2(arr) {
+        return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _nonIterableSpread$2();
+    }
+
+    function _nonIterableSpread$2() {
+        throw new TypeError("Invalid attempt to spread non-iterable instance");
+    }
+
+    function _iterableToArray$2(iter2) {
+        if (Symbol.iterator in Object(iter2) || Object.prototype.toString.call(iter2) === "[object Arguments]")
+            return Array.from(iter2);
+    }
+
+    function _arrayWithoutHoles$2(arr) {
+        if (Array.isArray(arr)) {
+            for (var i2 = 0, arr2 = new Array(arr.length); i2 < arr.length; i2++) {
+                arr2[i2] = arr[i2];
             }
-        });
-        delete Prism2.languages.sass.property;
-        delete Prism2.languages.sass.important;
-        Prism2.languages.insertBefore("sass", "punctuation", {
-            "selector": {
-                pattern: /^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
-                lookbehind: true,
-                greedy: true
+            return arr2;
+        }
+    }
+
+    function _slicedToArray$8(arr, i2) {
+        return _arrayWithHoles$8(arr) || _iterableToArrayLimit$8(arr, i2) || _nonIterableRest$8();
+    }
+
+    function _nonIterableRest$8() {
+        throw new TypeError("Invalid attempt to destructure non-iterable instance");
+    }
+
+    function _iterableToArrayLimit$8(arr, i2) {
+        if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
+            return;
+        }
+        var _arr = [];
+        var _n2 = true;
+        var _d = false;
+        var _e2 = void 0;
+        try {
+            for (var _i2 = arr[Symbol.iterator](), _s; !(_n2 = (_s = _i2.next()).done); _n2 = true) {
+                _arr.push(_s.value);
+                if (i2 && _arr.length === i2)
+                    break;
             }
-        });
-    })(prism);
-    prism.languages.scss = prism.languages.extend("css", {
-        "comment": {
-            pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
-            lookbehind: true
-        },
-        "atrule": {
-            pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
-            inside: {
-                "rule": /@[\w-]+/
+        } catch (err) {
+            _d = true;
+            _e2 = err;
+        } finally {
+            try {
+                if (!_n2 && _i2["return"] != null)
+                    _i2["return"]();
+            } finally {
+                if (_d)
+                    throw _e2;
             }
-        },
-        "url": /(?:[-a-z]+-)?url(?=\()/i,
-        "selector": {
-            pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
-            inside: {
-                "parent": {
-                    pattern: /&/,
-                    alias: "important"
-                },
-                "placeholder": /%[-\w]+/,
-                "variable": /\$[-\w]+|#\{\$[-\w]+\}/
+        }
+        return _arr;
+    }
+
+    function _arrayWithHoles$8(arr) {
+        if (Array.isArray(arr))
+            return arr;
+    }
+
+    function ownKeys$6(object2, enumerableOnly) {
+        var keys2 = Object.keys(object2);
+        if (Object.getOwnPropertySymbols) {
+            var symbols = Object.getOwnPropertySymbols(object2);
+            if (enumerableOnly)
+                symbols = symbols.filter(function(sym) {
+                    return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
+                });
+            keys2.push.apply(keys2, symbols);
+        }
+        return keys2;
+    }
+
+    function _objectSpread$5(target) {
+        for (var i2 = 1; i2 < arguments.length; i2++) {
+            var source = arguments[i2] != null ? arguments[i2] : {};
+            if (i2 % 2) {
+                ownKeys$6(source, true).forEach(function(key) {
+                    _defineProperty$n(target, key, source[key]);
+                });
+            } else if (Object.getOwnPropertyDescriptors) {
+                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+            } else {
+                ownKeys$6(source).forEach(function(key) {
+                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
+                });
             }
-        },
-        "property": {
-            pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
-            inside: {
-                "variable": /\$[-\w]+|#\{\$[-\w]+\}/
+        }
+        return target;
+    }
+
+    function _defineProperty$n(obj, key, value) {
+        if (key in obj) {
+            Object.defineProperty(obj, key, {
+                value,
+                enumerable: true,
+                configurable: true,
+                writable: true
+            });
+        } else {
+            obj[key] = value;
+        }
+        return obj;
+    }
+
+    function _objectWithoutProperties$1(source, excluded) {
+        if (source == null)
+            return {};
+        var target = _objectWithoutPropertiesLoose$2(source, excluded);
+        var key, i2;
+        if (Object.getOwnPropertySymbols) {
+            var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
+            for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
+                key = sourceSymbolKeys[i2];
+                if (excluded.indexOf(key) >= 0)
+                    continue;
+                if (!Object.prototype.propertyIsEnumerable.call(source, key))
+                    continue;
+                target[key] = source[key];
             }
         }
-    });
-    prism.languages.insertBefore("scss", "atrule", {
-        "keyword": [/@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i, {
-            pattern: /( )(?:from|through)(?= )/,
-            lookbehind: true
-        }]
-    });
-    prism.languages.insertBefore("scss", "important", {
-        "variable": /\$[-\w]+|#\{\$[-\w]+\}/
-    });
-    prism.languages.insertBefore("scss", "function", {
-        "module-modifier": {
-            pattern: /\b(?:as|hide|show|with)\b/i,
-            alias: "keyword"
-        },
-        "placeholder": {
-            pattern: /%[-\w]+/,
-            alias: "selector"
-        },
-        "statement": {
-            pattern: /\B!(?:default|optional)\b/i,
-            alias: "keyword"
-        },
-        "boolean": /\b(?:false|true)\b/,
-        "null": {
-            pattern: /\bnull\b/,
-            alias: "keyword"
-        },
-        "operator": {
-            pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
-            lookbehind: true
+        return target;
+    }
+
+    function _objectWithoutPropertiesLoose$2(source, excluded) {
+        if (source == null)
+            return {};
+        var target = {};
+        var sourceKeys = Object.keys(source);
+        var key, i2;
+        for (i2 = 0; i2 < sourceKeys.length; i2++) {
+            key = sourceKeys[i2];
+            if (excluded.indexOf(key) >= 0)
+                continue;
+            target[key] = source[key];
         }
+        return target;
+    }
+    var Dropzone$1 = React.forwardRef(function(_ref2, ref2) {
+        var children2 = _ref2.children,
+            params = _objectWithoutProperties$1(_ref2, ["children"]);
+        var _useDropzone = useDropzone(params),
+            open = _useDropzone.open,
+            props = _objectWithoutProperties$1(_useDropzone, ["open"]);
+        React.useImperativeHandle(ref2, function() {
+            return {
+                open
+            };
+        }, [open]);
+        return React__default.default.createElement(React.Fragment, null, children2(_objectSpread$5({}, props, {
+            open
+        })));
     });
-    prism.languages.scss["atrule"].inside.rest = prism.languages.scss;
-    (function(Prism2) {
-        var unit = {
-            pattern: /(\b\d+)(?:%|[a-z]+)/,
-            lookbehind: true
-        };
-        var number2 = {
-            pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
-            lookbehind: true
-        };
-        var inside2 = {
-            "comment": {
-                pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
-                lookbehind: true
-            },
-            "url": {
-                pattern: /\burl\((["']?).*?\1\)/i,
-                greedy: true
-            },
-            "string": {
-                pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
-                greedy: true
-            },
-            "interpolation": null,
-            "func": null,
-            "important": /\B!(?:important|optional)\b/i,
-            "keyword": {
-                pattern: /(^|\s+)(?:(?:else|for|if|return|unless)(?=\s|$)|@[\w-]+)/,
-                lookbehind: true
-            },
-            "hexcode": /#[\da-f]{3,6}/i,
-            "color": [/\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i, {
-                pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
-                inside: {
-                    "unit": unit,
-                    "number": number2,
-                    "function": /[\w-]+(?=\()/,
-                    "punctuation": /[(),]/
-                }
-            }],
-            "entity": /\\[\da-f]{1,8}/i,
-            "unit": unit,
-            "boolean": /\b(?:false|true)\b/,
-            "operator": [
-                /~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.{2,3}|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/
-            ],
-            "number": number2,
-            "punctuation": /[{}()\[\];:,]/
-        };
-        inside2["interpolation"] = {
-            pattern: /\{[^\r\n}:]+\}/,
-            alias: "variable",
-            inside: {
-                "delimiter": {
-                    pattern: /^\{|\}$/,
-                    alias: "punctuation"
-                },
-                rest: inside2
-            }
-        };
-        inside2["func"] = {
-            pattern: /[\w-]+\([^)]*\).*/,
-            inside: {
-                "function": /^[^(]+/,
-                rest: inside2
+    Dropzone$1.displayName = "Dropzone";
+    Dropzone$1.propTypes = {
+        children: propTypes.exports.func,
+        accept: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.arrayOf(propTypes.exports.string)]),
+        multiple: propTypes.exports.bool,
+        preventDropOnDocument: propTypes.exports.bool,
+        noClick: propTypes.exports.bool,
+        noKeyboard: propTypes.exports.bool,
+        noDrag: propTypes.exports.bool,
+        noDragEventsBubbling: propTypes.exports.bool,
+        minSize: propTypes.exports.number,
+        maxSize: propTypes.exports.number,
+        disabled: propTypes.exports.bool,
+        getFilesFromEvent: propTypes.exports.func,
+        onFileDialogCancel: propTypes.exports.func,
+        onDragEnter: propTypes.exports.func,
+        onDragLeave: propTypes.exports.func,
+        onDragOver: propTypes.exports.func,
+        onDrop: propTypes.exports.func,
+        onDropAccepted: propTypes.exports.func,
+        onDropRejected: propTypes.exports.func
+    };
+    var initialState$2 = {
+        isFocused: false,
+        isFileDialogActive: false,
+        isDragActive: false,
+        isDragAccept: false,
+        isDragReject: false,
+        draggedFiles: [],
+        acceptedFiles: [],
+        fileRejections: []
+    };
+
+    function useDropzone() {
+        var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
+            accept = _ref2.accept,
+            _ref2$disabled = _ref2.disabled,
+            disabled2 = _ref2$disabled === void 0 ? false : _ref2$disabled,
+            _ref2$getFilesFromEve = _ref2.getFilesFromEvent,
+            getFilesFromEvent = _ref2$getFilesFromEve === void 0 ? fromEvent : _ref2$getFilesFromEve,
+            _ref2$maxSize = _ref2.maxSize,
+            maxSize = _ref2$maxSize === void 0 ? Infinity : _ref2$maxSize,
+            _ref2$minSize = _ref2.minSize,
+            minSize = _ref2$minSize === void 0 ? 0 : _ref2$minSize,
+            _ref2$multiple = _ref2.multiple,
+            multiple = _ref2$multiple === void 0 ? true : _ref2$multiple,
+            onDragEnter = _ref2.onDragEnter,
+            onDragLeave = _ref2.onDragLeave,
+            onDragOver = _ref2.onDragOver,
+            onDrop = _ref2.onDrop,
+            onDropAccepted = _ref2.onDropAccepted,
+            onDropRejected = _ref2.onDropRejected,
+            onFileDialogCancel = _ref2.onFileDialogCancel,
+            _ref2$preventDropOnDo = _ref2.preventDropOnDocument,
+            preventDropOnDocument = _ref2$preventDropOnDo === void 0 ? true : _ref2$preventDropOnDo,
+            _ref2$noClick = _ref2.noClick,
+            noClick = _ref2$noClick === void 0 ? false : _ref2$noClick,
+            _ref2$noKeyboard = _ref2.noKeyboard,
+            noKeyboard = _ref2$noKeyboard === void 0 ? false : _ref2$noKeyboard,
+            _ref2$noDrag = _ref2.noDrag,
+            noDrag = _ref2$noDrag === void 0 ? false : _ref2$noDrag,
+            _ref2$noDragEventsBub = _ref2.noDragEventsBubbling,
+            noDragEventsBubbling = _ref2$noDragEventsBub === void 0 ? false : _ref2$noDragEventsBub;
+        var rootRef = React.useRef(null);
+        var inputRef = React.useRef(null);
+        var _useReducer = React.useReducer(reducer, initialState$2),
+            _useReducer2 = _slicedToArray$8(_useReducer, 2),
+            state = _useReducer2[0],
+            dispatch2 = _useReducer2[1];
+        var isFocused = state.isFocused,
+            isFileDialogActive = state.isFileDialogActive,
+            draggedFiles = state.draggedFiles;
+        var openFileDialog = React.useCallback(function() {
+            if (inputRef.current) {
+                dispatch2({
+                    type: "openDialog"
+                });
+                inputRef.current.value = null;
+                inputRef.current.click();
             }
-        };
-        Prism2.languages.stylus = {
-            "atrule-declaration": {
-                pattern: /(^[ \t]*)@.+/m,
-                lookbehind: true,
-                inside: {
-                    "atrule": /^@[\w-]+/,
-                    rest: inside2
-                }
-            },
-            "variable-declaration": {
-                pattern: /(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:\{[^{}]*\}|\S.*|$)/m,
-                lookbehind: true,
-                inside: {
-                    "variable": /^\S+/,
-                    rest: inside2
-                }
-            },
-            "statement": {
-                pattern: /(^[ \t]*)(?:else|for|if|return|unless)[ \t].+/m,
-                lookbehind: true,
-                inside: {
-                    "keyword": /^\S+/,
-                    rest: inside2
-                }
-            },
-            "property-declaration": {
-                pattern: /((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)(?!\s)[^{\r\n]*(?:;|[^{\r\n,]$(?!(?:\r?\n|\r)(?:\{|\2[ \t])))/m,
-                lookbehind: true,
-                inside: {
-                    "property": {
-                        pattern: /^[^\s:]+/,
-                        inside: {
-                            "interpolation": inside2.interpolation
+        }, [dispatch2]);
+        var onWindowFocus = function onWindowFocus2() {
+            if (isFileDialogActive) {
+                setTimeout(function() {
+                    if (inputRef.current) {
+                        var files = inputRef.current.files;
+                        if (!files.length) {
+                            dispatch2({
+                                type: "closeDialog"
+                            });
+                            if (typeof onFileDialogCancel === "function") {
+                                onFileDialogCancel();
+                            }
                         }
-                    },
-                    rest: inside2
-                }
-            },
-            "selector": {
-                pattern: /(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t])))/m,
-                lookbehind: true,
-                inside: {
-                    "interpolation": inside2.interpolation,
-                    "comment": inside2.comment,
-                    "punctuation": /[{},]/
-                }
-            },
-            "func": inside2.func,
-            "string": inside2.string,
-            "comment": {
-                pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
-                lookbehind: true,
-                greedy: true
-            },
-            "interpolation": inside2.interpolation,
-            "punctuation": /[{}()\[\];:.]/
+                    }
+                }, 300);
+            }
         };
-    })(prism);
-    (function(Prism2) {
-        var typescript = Prism2.util.clone(Prism2.languages.typescript);
-        Prism2.languages.tsx = Prism2.languages.extend("jsx", typescript);
-        delete Prism2.languages.tsx["parameter"];
-        delete Prism2.languages.tsx["literal-property"];
-        var tag = Prism2.languages.tsx.tag;
-        tag.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + tag.pattern.source + ")", tag.pattern.flags);
-        tag.lookbehind = true;
-    })(prism);
-    prism.languages.wasm = {
-        "comment": [/\(;[\s\S]*?;\)/, {
-            pattern: /;;.*/,
-            greedy: true
-        }],
-        "string": {
-            pattern: /"(?:\\[\s\S]|[^"\\])*"/,
-            greedy: true
-        },
-        "keyword": [{
-            pattern: /\b(?:align|offset)=/,
-            inside: {
-                "operator": /=/
+        React.useEffect(function() {
+            window.addEventListener("focus", onWindowFocus, false);
+            return function() {
+                window.removeEventListener("focus", onWindowFocus, false);
+            };
+        }, [inputRef, isFileDialogActive, onFileDialogCancel]);
+        var onKeyDownCb = React.useCallback(function(event2) {
+            if (!rootRef.current || !rootRef.current.isEqualNode(event2.target)) {
+                return;
             }
-        }, {
-            pattern: /\b(?:(?:f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|neg?|nearest|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|sqrt|store(?:8|16|32)?|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))?|memory\.(?:grow|size))\b/,
-            inside: {
-                "punctuation": /\./
+            if (event2.keyCode === 32 || event2.keyCode === 13) {
+                event2.preventDefault();
+                openFileDialog();
             }
-        }, /\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\b/],
-        "variable": /\$[\w!#$%&'*+\-./:<=>?@\\^`|~]+/,
-        "number": /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/,
-        "punctuation": /[()]/
-    };
-    const prism$1 = prism;
-    var theme$2 = {
-        plain: {
-            backgroundColor: "#2a2734",
-            color: "#9a86fd"
-        },
-        styles: [{
-            types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
-            style: {
-                color: "#6c6783"
+        }, [rootRef, inputRef]);
+        var onFocusCb = React.useCallback(function() {
+            dispatch2({
+                type: "focus"
+            });
+        }, []);
+        var onBlurCb = React.useCallback(function() {
+            dispatch2({
+                type: "blur"
+            });
+        }, []);
+        var onClickCb = React.useCallback(function() {
+            if (noClick) {
+                return;
             }
-        }, {
-            types: ["namespace"],
-            style: {
-                opacity: 0.7
+            if (isIeOrEdge()) {
+                setTimeout(openFileDialog, 0);
+            } else {
+                openFileDialog();
             }
-        }, {
-            types: ["tag", "operator", "number"],
-            style: {
-                color: "#e09142"
+        }, [inputRef, noClick]);
+        var dragTargetsRef = React.useRef([]);
+        var onDocumentDrop = function onDocumentDrop2(event2) {
+            if (rootRef.current && rootRef.current.contains(event2.target)) {
+                return;
             }
-        }, {
-            types: ["property", "function"],
-            style: {
-                color: "#9a86fd"
+            event2.preventDefault();
+            dragTargetsRef.current = [];
+        };
+        React.useEffect(function() {
+            if (preventDropOnDocument) {
+                document.addEventListener("dragover", onDocumentDragOver, false);
+                document.addEventListener("drop", onDocumentDrop, false);
             }
-        }, {
-            types: ["tag-id", "selector", "atrule-id"],
-            style: {
-                color: "#eeebff"
+            return function() {
+                if (preventDropOnDocument) {
+                    document.removeEventListener("dragover", onDocumentDragOver);
+                    document.removeEventListener("drop", onDocumentDrop);
+                }
+            };
+        }, [rootRef, preventDropOnDocument]);
+        var onDragEnterCb = React.useCallback(function(event2) {
+            event2.preventDefault();
+            event2.persist();
+            stopPropagation(event2);
+            dragTargetsRef.current = [].concat(_toConsumableArray$2(dragTargetsRef.current), [event2.target]);
+            if (isEvtWithFiles(event2)) {
+                Promise.resolve(getFilesFromEvent(event2)).then(function(draggedFiles2) {
+                    if (isPropagationStopped(event2) && !noDragEventsBubbling) {
+                        return;
+                    }
+                    dispatch2({
+                        draggedFiles: draggedFiles2,
+                        isDragActive: true,
+                        type: "setDraggedFiles"
+                    });
+                    if (onDragEnter) {
+                        onDragEnter(event2);
+                    }
+                });
             }
-        }, {
-            types: ["attr-name"],
-            style: {
-                color: "#c4b9fe"
+        }, [getFilesFromEvent, onDragEnter, noDragEventsBubbling]);
+        var onDragOverCb = React.useCallback(function(event2) {
+            event2.preventDefault();
+            event2.persist();
+            stopPropagation(event2);
+            if (event2.dataTransfer) {
+                try {
+                    event2.dataTransfer.dropEffect = "copy";
+                } catch (_unused) {}
             }
-        }, {
-            types: ["boolean", "string", "entity", "url", "attr-value", "keyword", "control", "directive", "unit", "statement", "regex", "atrule", "placeholder", "variable"],
-            style: {
-                color: "#ffcc99"
+            if (isEvtWithFiles(event2) && onDragOver) {
+                onDragOver(event2);
             }
-        }, {
-            types: ["deleted"],
-            style: {
-                textDecorationLine: "line-through"
+            return false;
+        }, [onDragOver, noDragEventsBubbling]);
+        var onDragLeaveCb = React.useCallback(function(event2) {
+            event2.preventDefault();
+            event2.persist();
+            stopPropagation(event2);
+            var targets = dragTargetsRef.current.filter(function(target) {
+                return rootRef.current && rootRef.current.contains(target);
+            });
+            var targetIdx = targets.indexOf(event2.target);
+            if (targetIdx !== -1) {
+                targets.splice(targetIdx, 1);
             }
-        }, {
-            types: ["inserted"],
-            style: {
-                textDecorationLine: "underline"
+            dragTargetsRef.current = targets;
+            if (targets.length > 0) {
+                return;
             }
-        }, {
-            types: ["italic"],
-            style: {
-                fontStyle: "italic"
+            dispatch2({
+                isDragActive: false,
+                type: "setDraggedFiles",
+                draggedFiles: []
+            });
+            if (isEvtWithFiles(event2) && onDragLeave) {
+                onDragLeave(event2);
             }
-        }, {
-            types: ["important", "bold"],
-            style: {
-                fontWeight: "bold"
+        }, [rootRef, onDragLeave, noDragEventsBubbling]);
+        var onDropCb = React.useCallback(function(event2) {
+            event2.preventDefault();
+            event2.persist();
+            stopPropagation(event2);
+            dragTargetsRef.current = [];
+            if (isEvtWithFiles(event2)) {
+                Promise.resolve(getFilesFromEvent(event2)).then(function(files) {
+                    if (isPropagationStopped(event2) && !noDragEventsBubbling) {
+                        return;
+                    }
+                    var acceptedFiles = [];
+                    var fileRejections = [];
+                    files.forEach(function(file) {
+                        var _fileAccepted = fileAccepted(file, accept),
+                            _fileAccepted2 = _slicedToArray$8(_fileAccepted, 2),
+                            accepted = _fileAccepted2[0],
+                            acceptError = _fileAccepted2[1];
+                        var _fileMatchSize = fileMatchSize(file, minSize, maxSize),
+                            _fileMatchSize2 = _slicedToArray$8(_fileMatchSize, 2),
+                            sizeMatch = _fileMatchSize2[0],
+                            sizeError = _fileMatchSize2[1];
+                        if (accepted && sizeMatch) {
+                            acceptedFiles.push(file);
+                        } else {
+                            var errors = [acceptError, sizeError].filter(function(e3) {
+                                return e3;
+                            });
+                            fileRejections.push({
+                                file,
+                                errors
+                            });
+                        }
+                    });
+                    if (!multiple && acceptedFiles.length > 1) {
+                        acceptedFiles.forEach(function(file) {
+                            fileRejections.push({
+                                file,
+                                errors: [TOO_MANY_FILES_REJECTION]
+                            });
+                        });
+                        acceptedFiles.splice(0);
+                    }
+                    dispatch2({
+                        acceptedFiles,
+                        fileRejections,
+                        type: "setFiles"
+                    });
+                    if (onDrop) {
+                        onDrop(acceptedFiles, fileRejections, event2);
+                    }
+                    if (fileRejections.length > 0 && onDropRejected) {
+                        onDropRejected(fileRejections, event2);
+                    }
+                    if (acceptedFiles.length > 0 && onDropAccepted) {
+                        onDropAccepted(acceptedFiles, event2);
+                    }
+                });
             }
-        }, {
-            types: ["important"],
-            style: {
-                color: "#c4b9fe"
+            dispatch2({
+                type: "reset"
+            });
+        }, [multiple, accept, minSize, maxSize, getFilesFromEvent, onDrop, onDropAccepted, onDropRejected, noDragEventsBubbling]);
+        var composeHandler = function composeHandler2(fn2) {
+            return disabled2 ? null : fn2;
+        };
+        var composeKeyboardHandler = function composeKeyboardHandler2(fn2) {
+            return noKeyboard ? null : composeHandler(fn2);
+        };
+        var composeDragHandler = function composeDragHandler2(fn2) {
+            return noDrag ? null : composeHandler(fn2);
+        };
+        var stopPropagation = function stopPropagation2(event2) {
+            if (noDragEventsBubbling) {
+                event2.stopPropagation();
             }
-        }]
-    };
-    const duotoneDark = theme$2;
-    var defaultProps = {
-        Prism: prism$1,
-        theme: duotoneDark
-    };
+        };
+        var getRootProps = React.useMemo(function() {
+            return function() {
+                var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
+                    _ref3$refKey = _ref3.refKey,
+                    refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey,
+                    onKeyDown = _ref3.onKeyDown,
+                    onFocus = _ref3.onFocus,
+                    onBlur = _ref3.onBlur,
+                    onClick = _ref3.onClick,
+                    onDragEnter2 = _ref3.onDragEnter,
+                    onDragOver2 = _ref3.onDragOver,
+                    onDragLeave2 = _ref3.onDragLeave,
+                    onDrop2 = _ref3.onDrop,
+                    rest = _objectWithoutProperties$1(_ref3, ["refKey", "onKeyDown", "onFocus", "onBlur", "onClick", "onDragEnter", "onDragOver", "onDragLeave", "onDrop"]);
+                return _objectSpread$5(_defineProperty$n({
+                    onKeyDown: composeKeyboardHandler(composeEventHandlers(onKeyDown, onKeyDownCb)),
+                    onFocus: composeKeyboardHandler(composeEventHandlers(onFocus, onFocusCb)),
+                    onBlur: composeKeyboardHandler(composeEventHandlers(onBlur, onBlurCb)),
+                    onClick: composeHandler(composeEventHandlers(onClick, onClickCb)),
+                    onDragEnter: composeDragHandler(composeEventHandlers(onDragEnter2, onDragEnterCb)),
+                    onDragOver: composeDragHandler(composeEventHandlers(onDragOver2, onDragOverCb)),
+                    onDragLeave: composeDragHandler(composeEventHandlers(onDragLeave2, onDragLeaveCb)),
+                    onDrop: composeDragHandler(composeEventHandlers(onDrop2, onDropCb))
+                }, refKey, rootRef), !disabled2 && !noKeyboard ? {
+                    tabIndex: 0
+                } : {}, {}, rest);
+            };
+        }, [rootRef, onKeyDownCb, onFocusCb, onBlurCb, onClickCb, onDragEnterCb, onDragOverCb, onDragLeaveCb, onDropCb, noKeyboard, noDrag, disabled2]);
+        var onInputElementClick = React.useCallback(function(event2) {
+            event2.stopPropagation();
+        }, []);
+        var getInputProps = React.useMemo(function() {
+            return function() {
+                var _ref4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
+                    _ref4$refKey = _ref4.refKey,
+                    refKey = _ref4$refKey === void 0 ? "ref" : _ref4$refKey,
+                    onChange2 = _ref4.onChange,
+                    onClick = _ref4.onClick,
+                    rest = _objectWithoutProperties$1(_ref4, ["refKey", "onChange", "onClick"]);
+                var inputProps = _defineProperty$n({
+                    accept,
+                    multiple,
+                    type: "file",
+                    style: {
+                        display: "none"
+                    },
+                    onChange: composeHandler(composeEventHandlers(onChange2, onDropCb)),
+                    onClick: composeHandler(composeEventHandlers(onClick, onInputElementClick)),
+                    autoComplete: "off",
+                    tabIndex: -1
+                }, refKey, inputRef);
+                return _objectSpread$5({}, inputProps, {}, rest);
+            };
+        }, [inputRef, accept, multiple, onDropCb, disabled2]);
+        var fileCount = draggedFiles.length;
+        var isDragAccept = fileCount > 0 && allFilesAccepted({
+            files: draggedFiles,
+            accept,
+            minSize,
+            maxSize,
+            multiple
+        });
+        var isDragReject = fileCount > 0 && !isDragAccept;
+        return _objectSpread$5({}, state, {
+            isDragAccept,
+            isDragReject,
+            isFocused: isFocused && !disabled2,
+            getRootProps,
+            getInputProps,
+            rootRef,
+            inputRef,
+            open: composeHandler(openFileDialog)
+        });
+    }
 
-    function _defineProperty$l(obj, key, value) {
-        if (key in obj) {
-            Object.defineProperty(obj, key, {
-                value,
-                enumerable: true,
-                configurable: true,
-                writable: true
-            });
-        } else {
-            obj[key] = value;
+    function reducer(state, action) {
+        switch (action.type) {
+            case "focus":
+                return _objectSpread$5({}, state, {
+                    isFocused: true
+                });
+            case "blur":
+                return _objectSpread$5({}, state, {
+                    isFocused: false
+                });
+            case "openDialog":
+                return _objectSpread$5({}, state, {
+                    isFileDialogActive: true
+                });
+            case "closeDialog":
+                return _objectSpread$5({}, state, {
+                    isFileDialogActive: false
+                });
+            case "setDraggedFiles":
+                var isDragActive = action.isDragActive,
+                    draggedFiles = action.draggedFiles;
+                return _objectSpread$5({}, state, {
+                    draggedFiles,
+                    isDragActive
+                });
+            case "setFiles":
+                return _objectSpread$5({}, state, {
+                    acceptedFiles: action.acceptedFiles,
+                    fileRejections: action.fileRejections
+                });
+            case "reset":
+                return _objectSpread$5({}, state, {
+                    isFileDialogActive: false,
+                    isDragActive: false,
+                    draggedFiles: [],
+                    acceptedFiles: [],
+                    fileRejections: []
+                });
+            default:
+                return state;
         }
-        return obj;
     }
+    const DROPZONE_ALLOWED_MIME_TYPES = ".csv, text/csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel, application/csv, text/x-csv, application/x-csv, text/comma-separated-values, text/x-comma-separated-values";
+    const Dropzone = styled__default.default.div`
+    display: flex;
+    flex: 1 1 auto;
+    align-items: center;
+    justify-content: center;
 
-    function _extends() {
-        _extends = Object.assign || function(target) {
-            for (var i2 = 1; i2 < arguments.length; i2++) {
-                var source = arguments[i2];
-                for (var key in source) {
-                    if (Object.prototype.hasOwnProperty.call(source, key)) {
-                        target[key] = source[key];
-                    }
+    margin-top: 20px;
+
+    color: ${(props) => props.theme.colors.text};
+
+    border: 1px dashed ${(props) => props.isDragActive ? props.theme.colors.primary : props.theme.colors.grey3};
+    border-radius: 0.25rem;
+
+    :hover {
+        background-color: ${(props) => props.theme.colors.grey1};
+    }
+
+    :active,
+    :focus {
+        background-color: ${(props) => props.theme.colors.grey2};
+    }
+`;
+    const DropzoneMessage = styled__default.default.span`
+    max-width: 400px;
+    padding: 1.5rem;
+
+    font-family: Manrope, sans-serif;
+    font-weight: 300;
+    text-align: center;
+`;
+
+    function UploadDropzone$1(props) {
+        var _a3;
+        React.useEffect(() => {
+            if (!props.enablePaste) {
+                return;
+            }
+            const handlePaste = (ev) => {
+                const blob = new Blob([ev.clipboardData.getData("Text")], {
+                    type: "text/plain"
+                });
+                const file = new File([blob], "pasted_data", {
+                    type: "text/plain"
+                });
+                props.onDrop([file]);
+            };
+            document.addEventListener("paste", handlePaste);
+            return () => document.removeEventListener("paste", handlePaste);
+        }, [props]);
+        const {
+            getRootProps,
+            getInputProps,
+            isDragActive
+        } = useDropzone({
+            accept: (_a3 = props.accept) !== null && _a3 !== void 0 ? _a3 : DROPZONE_ALLOWED_MIME_TYPES,
+            multiple: false,
+            onDrop: props.onDrop
+        });
+        return jsxRuntime.exports.jsxs(Dropzone, Object.assign({}, getRootProps(), {
+            className: props.className,
+            isDragActive,
+            style: props.style,
+            children: [jsxRuntime.exports.jsx("input", Object.assign({}, getInputProps())), jsxRuntime.exports.jsxs(DropzoneMessage, {
+                children: ["Drop your file, ", jsxRuntime.exports.jsx("br", {}), "paste it ", jsxRuntime.exports.jsx("br", {}), "or click here to upload"]
+            })]
+        }));
+    }
+    styled__default.default.div`
+    display: flex;
+    flex-direction: column;
+
+    width: 100%;
+    padding: 1rem;
+
+    color: ${(props) => props.theme.colors.error};
+
+    background-color: ${(props) => props.theme.colors.background};
+`;
+    styled__default.default.div`
+    overflow: scroll;
+    display: flex;
+    flex-direction: column;
+
+    width: 100%;
+    max-height: 125px;
+    margin: 2rem 0;
+    padding: 0.5rem;
+
+    color: ${(props) => props.theme.colors.background};
+
+    background-color: ${(props) => props.theme.colors.errorHover};
+`;
+    styled__default.default.p`
+    color: ${(props) => props.theme.colors.error};
+`;
+    const NodeContent = styled__default.default.li`
+    margin-left: 0.35rem;
+    border-left: thin solid ${(props) => props.theme.colors.grey6};
+
+    &::before {
+        content: '';
+
+        display: inline-block;
+
+        width: 0.9rem;
+        height: 0.8rem;
+        margin-right: 0.1rem;
+
+        vertical-align: top;
+
+        border-bottom: thin solid ${(props) => props.theme.colors.grey6};
+    }
+
+    &:last-child {
+        border-left: none;
+
+        &::before {
+            border-left: thin solid ${(props) => props.theme.colors.grey6};
+        }
+    }
+`;
+    const Cell$1 = styled__default.default.span`
+    cursor: ${(props) => props.selectionAllowed ? "pointer" : "normal"};
+    font-weight: ${(props) => props.isLeaf ? 300 : 400};
+    color: ${(props) => {
+    if (props.selected) {
+      return props.theme.colors.primary;
+    }
+    return props.isLeaf ? props.theme.colors.grey6 : props.theme.colors.grey5;
+  }};
+`;
+    const CircleIcon = styled__default.default(Circle$1)`
+    width: 0.5rem;
+    height: 0.5rem;
+    margin-right: 0.4rem;
+
+    color: ${(props) => props.selected ? props.theme.colors.primary : props.theme.colors.grey6};
+    vertical-align: middle;
+`;
+    const grow = styled.keyframes`
+    0% {
+        transform: scaleY(0);
+        opacity: 0;
+    }
+    100% {
+        transform: scaleY(1);
+        opacity: 1;
+    }
+`;
+    const contract = styled.keyframes`
+    100% {
+        transform: scaleY(1);
+        opacity: 1;
+    }
+    0% {
+        transform: scaleY(0);
+        opacity: 0;
+    }
+`;
+    const NodeWrapper = styled__default.default.ul`
+    transform-origin: top center;
+
+    display: ${(props) => props.open ? "block" : "none"};
+
+    margin: 0;
+    margin-left: 1rem;
+    padding: 0;
+    padding-bottom: 1rem;
+
+    list-style: none;
+
+    animation: ${(props) => props.open ? grow : contract} 300ms
+        ${(props) => props.open ? "ease-out forwards" : "ease-in forwards"};
+`;
+
+    function Branch(props) {
+        const theme2 = useClTheme();
+        const [open, setOpen] = React.useState(props.open || false);
+        const toggle = () => {
+            if (props.content) {
+                setOpen(!open);
+            }
+        };
+        const select = () => {
+            props.selectNode(props.content.id);
+        };
+        const selectionAllowed = props.allowSelectCategory && props.content.children && props.content.children.length > 0 || props.allowSelectLeaf && (!props.content.children || props.content.children.length === 0);
+        return jsxRuntime.exports.jsxs(NodeContent, {
+            className: props.className,
+            style: props.style,
+            children: [jsxRuntime.exports.jsx(CircleIcon, {
+                selected: props.content.id === props.selectedNodeId
+            }), jsxRuntime.exports.jsx(Cell$1, {
+                isLeaf: !props.content.children || props.content.children.length === 0,
+                onClick: selectionAllowed ? select : toggle,
+                selected: props.content.id === props.selectedNodeId,
+                selectionAllowed,
+                children: props.content.label
+            }), props.content.children && props.content.children.length > 0 && jsxRuntime.exports.jsx(Chevron$2, {
+                isOpen: open,
+                onClick: toggle,
+                style: {
+                    color: theme2.colors.grey5,
+                    cursor: "pointer",
+                    height: "0.8rem",
+                    marginLeft: "0.5rem",
+                    verticalAlign: "middle",
+                    width: "0.8rem"
                 }
+            }), jsxRuntime.exports.jsx(NodeWrapper, {
+                open,
+                children: props.content.children && props.content.children.length > 0 && props.content.children.map((nodeObj) => jsxRuntime.exports.jsx(Branch, {
+                    allowSelectCategory: props.allowSelectCategory,
+                    allowSelectLeaf: props.allowSelectLeaf,
+                    content: nodeObj,
+                    selectCategory: props.selectCategory,
+                    selectNode: props.selectNode,
+                    selectedNodeId: props.selectedNodeId
+                }, nodeObj.id))
+            })]
+        });
+    }
+    const Wrapper$8 = styled__default.default.div`
+    overflow: scroll;
+`;
+    const Root = styled__default.default.div`
+    cursor: pointer;
+    margin-left: 1rem;
+`;
+
+    function HierarchySelector$1(props) {
+        const theme2 = useClTheme();
+        const [rootOpen, setRootOpen] = React.useState(props.rootOpen || false);
+        const [selectedNodeId, setSelectedNodeId] = React.useState(props.selected);
+        React.useEffect(() => {
+            if (props.selected) {
+                setSelectedNodeId(props.selected);
             }
-            return target;
+        }, [props.selected]);
+        const toggle = () => {
+            setRootOpen(!rootOpen);
         };
-        return _extends.apply(this, arguments);
+        const selectNode = (nodeId) => {
+            var _a3;
+            setSelectedNodeId(nodeId);
+            (_a3 = props.onSelect) === null || _a3 === void 0 ? void 0 : _a3.call(props, nodeId);
+        };
+        const {
+            label,
+            id: id2,
+            children: children2
+        } = props.rootNode;
+        return jsxRuntime.exports.jsxs(Wrapper$8, {
+            className: props.className,
+            style: props.style,
+            children: [jsxRuntime.exports.jsxs(Root, {
+                children: [jsxRuntime.exports.jsx(CircleIcon, {
+                    selected: id2 === selectedNodeId
+                }), jsxRuntime.exports.jsx(Cell$1, {
+                    onClick: props.allowSelectCategory || children2.length === 0 ? () => selectNode(id2) : toggle,
+                    selected: id2 === selectedNodeId,
+                    children: label
+                }), children2.length > 0 && jsxRuntime.exports.jsx(Chevron$2, {
+                    isOpen: rootOpen,
+                    onClick: toggle,
+                    style: {
+                        color: theme2.colors.grey5,
+                        cursor: "pointer",
+                        height: "0.8rem",
+                        marginLeft: "0.5rem",
+                        verticalAlign: "middle",
+                        width: "0.8rem"
+                    }
+                })]
+            }), jsxRuntime.exports.jsx(NodeWrapper, {
+                open: rootOpen,
+                children: children2 && children2.map((nodeObj) => jsxRuntime.exports.jsx(Branch, {
+                    allowSelectCategory: props.allowSelectCategory,
+                    allowSelectLeaf: props.allowSelectLeaf,
+                    content: nodeObj,
+                    open: rootOpen,
+                    selectNode,
+                    selectedNodeId
+                }, nodeObj.id))
+            })]
+        });
     }
-    var newlineRe = /\r\n|\r|\n/;
-    var normalizeEmptyLines = function(line) {
-        if (line.length === 0) {
-            line.push({
-                types: ["plain"],
-                content: "\n",
-                empty: true
-            });
-        } else if (line.length === 1 && line[0].content === "") {
-            line[0].content = "\n";
-            line[0].empty = true;
-        }
-    };
-    var appendTypes = function(types2, add2) {
-        var typesSize = types2.length;
-        if (typesSize > 0 && types2[typesSize - 1] === add2) {
-            return types2;
-        }
-        return types2.concat(add2);
-    };
-    var normalizeTokens = function(tokens2) {
-        var typeArrStack = [
-            []
-        ];
-        var tokenArrStack = [tokens2];
-        var tokenArrIndexStack = [0];
-        var tokenArrSizeStack = [tokens2.length];
-        var i2 = 0;
-        var stackIndex = 0;
-        var currentLine = [];
-        var acc = [currentLine];
-        while (stackIndex > -1) {
-            while ((i2 = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {
-                var content2 = void 0;
-                var types2 = typeArrStack[stackIndex];
-                var tokenArr = tokenArrStack[stackIndex];
-                var token = tokenArr[i2];
-                if (typeof token === "string") {
-                    types2 = stackIndex > 0 ? types2 : ["plain"];
-                    content2 = token;
-                } else {
-                    types2 = appendTypes(types2, token.type);
-                    if (token.alias) {
-                        types2 = appendTypes(types2, token.alias);
+    const Background$1 = styled__default.default.div`
+    position: fixed;
+    z-index: 2000;
+    top: 0;
+    left: 0;
+
+    display: flex;
+    align-items: center;
+    justify-content: center;
+
+    width: 100%;
+    height: 100%;
+
+    opacity: ${(props) => props.render ? 1 : 0};
+    background-color: ${(props) => props.theme.colors.modalBg};
+
+    transition: opacity ease-in 0.1s;
+`;
+    const ModalWrapper = styled__default.default.div`
+    overflow: hidden;
+    display: inline-flex;
+    flex-direction: column;
+
+    min-width: 20rem;
+    max-width: 80vw;
+    min-height: 10rem;
+    max-height: 80vh;
+    margin-top: ${(props) => props.render ? 0 : "-50px"};
+    padding: 1.75rem;
+
+    font-size: ${(props) => props.theme.font.size};
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border-radius: 0.25rem;
+    box-shadow: ${(props) => props.theme.shadow.medium};
+
+    transition: margin-top ease-in 0.1s;
+`;
+    styled__default.default.div`
+    display: flex;
+    flex: 0 0 auto;
+    justify-content: space-between;
+    margin-top: 1rem;
+`;
+    styled__default.default.div`
+    display: flex;
+    flex: 0 0 auto;
+    flex-direction: ${(props) => props.flexDirection || "column"};
+    justify-content: space-between;
+
+    margin-bottom: 1rem;
+`;
+
+    function Modal$1(props) {
+        var _a3;
+        const [mounted, setMounted] = React.useState(false);
+        const [renderModal, setRenderModal] = React.useState(false);
+        React.useEffect(() => {
+            setRenderModal(props.render);
+        }, [props.render]);
+        React.useEffect(() => {
+            if (renderModal) {
+                const keyHandler = (e3) => {
+                    if (e3.key === Key.ESCAPE && props.onAttemptClose) {
+                        props.onAttemptClose();
                     }
-                    content2 = token.content;
-                }
-                if (typeof content2 !== "string") {
-                    stackIndex++;
-                    typeArrStack.push(types2);
-                    tokenArrStack.push(content2);
-                    tokenArrIndexStack.push(0);
-                    tokenArrSizeStack.push(content2.length);
-                    continue;
-                }
-                var splitByNewlines = content2.split(newlineRe);
-                var newlineCount = splitByNewlines.length;
-                currentLine.push({
-                    types: types2,
-                    content: splitByNewlines[0]
-                });
-                for (var i$12 = 1; i$12 < newlineCount; i$12++) {
-                    normalizeEmptyLines(currentLine);
-                    acc.push(currentLine = []);
-                    currentLine.push({
-                        types: types2,
-                        content: splitByNewlines[i$12]
-                    });
-                }
+                };
+                document.addEventListener("keydown", keyHandler);
+                return () => {
+                    document.removeEventListener("keydown", keyHandler);
+                };
             }
-            stackIndex--;
-            typeArrStack.pop();
-            tokenArrStack.pop();
-            tokenArrIndexStack.pop();
-            tokenArrSizeStack.pop();
+        }, [renderModal, props.onAttemptClose]);
+        if (!props.render && !mounted) {
+            return null;
         }
-        normalizeEmptyLines(currentLine);
-        return acc;
-    };
-    var themeToDict = function(theme2, language2) {
-        var plain = theme2.plain;
-        var base2 = /* @__PURE__ */ Object.create(null);
-        var themeDict = theme2.styles.reduce(function(acc, themeEntry) {
-            var languages = themeEntry.languages;
-            var style2 = themeEntry.style;
-            if (languages && !languages.includes(language2)) {
-                return acc;
+        const onTransitionEnd = () => {
+            setMounted(props.render);
+            if (!props.render && props.onClosed) {
+                props.onClosed();
             }
-            themeEntry.types.forEach(function(type2) {
-                var accStyle = _extends({}, acc[type2], style2);
-                acc[type2] = accStyle;
-            });
-            return acc;
-        }, base2);
-        themeDict.root = plain;
-        themeDict.plain = _extends({}, plain, {
-            backgroundColor: null
-        });
-        return themeDict;
+        };
+        const stopPropagation = (e3) => {
+            e3.stopPropagation();
+        };
+        return ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(Background$1, {
+            id: props.id,
+            onClick: props.onAttemptClose,
+            onTransitionEnd,
+            render: renderModal,
+            children: jsxRuntime.exports.jsx(ModalWrapper, {
+                className: `cl-modal-content ${(_a3 = props.className) !== null && _a3 !== void 0 ? _a3 : ""}`,
+                onClick: stopPropagation,
+                render: renderModal,
+                style: props.style,
+                children: props.children
+            })
+        }), document.body);
+    }
+    var __rest$9 = globalThis && globalThis.__rest || function(s2, e3) {
+        var t2 = {};
+        for (var p2 in s2)
+            if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
+                t2[p2] = s2[p2];
+        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
+            for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
+                if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
+                    t2[p2[i2]] = s2[p2[i2]];
+            }
+        return t2;
     };
+    const {
+        stateChangeTypes: stateChangeTypes$1
+    } = useCombobox;
+    const tagHeight = 2;
+    const tagTopMargin = 0.5;
+    const Wrapper$7 = styled__default.default.div`
+    display: inline-flex;
+    ${(props) => {
+    if (props.isDisabled) {
+      return `
+                cursor: not-allowed;
+            `;
+    }
+  }}
 
-    function objectWithoutProperties(obj, exclude) {
-        var target = {};
-        for (var k2 in obj)
-            if (Object.prototype.hasOwnProperty.call(obj, k2) && exclude.indexOf(k2) === -1)
-                target[k2] = obj[k2];
-        return target;
+    width: 100%;
+    max-width: ${(props) => props.maxWidth};
+    max-height: ${(props) => props.maxRows * (tagHeight + tagTopMargin)}rem;
+
+    border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0rem 0rem" : "0.25rem"};
+`;
+    const InputWrapper$3 = styled__default.default.div`
+    display: flex;
+    flex: 1 1 auto;
+    align-items: center;
+    justify-content: space-between;
+
+    width: 100%;
+    min-width: 10rem;
+    min-height: 2.5rem;
+    margin-right: 0.25rem;
+    padding: 0.25rem 0.5rem 0.25rem 1rem;
+
+    color: ${(props) => props.isDisabled ? props.theme.colors.grey2 : props.theme.colors.text};
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border: none;
+    border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0rem 0rem" : "0.25rem"};
+
+    :hover {
+        background-color: ${(props) => props.isDisabled ? props.theme.colors.grey1 : props.theme.colors.grey2};
     }
-    var Highlight = /* @__PURE__ */ function(Component) {
-        function Highlight2() {
-            var this$1$1 = this;
-            var args = [],
-                len = arguments.length;
-            while (len--)
-                args[len] = arguments[len];
-            Component.apply(this, args);
-            _defineProperty$l(this, "getThemeDict", function(props) {
-                if (this$1$1.themeDict !== void 0 && props.theme === this$1$1.prevTheme && props.language === this$1$1.prevLanguage) {
-                    return this$1$1.themeDict;
-                }
-                this$1$1.prevTheme = props.theme;
-                this$1$1.prevLanguage = props.language;
-                var themeDict = props.theme ? themeToDict(props.theme, props.language) : void 0;
-                return this$1$1.themeDict = themeDict;
-            });
-            _defineProperty$l(this, "getLineProps", function(ref2) {
-                var key = ref2.key;
-                var className = ref2.className;
-                var style2 = ref2.style;
-                var rest$1 = objectWithoutProperties(ref2, ["key", "className", "style", "line"]);
-                var rest = rest$1;
-                var output2 = _extends({}, rest, {
-                    className: "token-line",
-                    style: void 0,
-                    key: void 0
-                });
-                var themeDict = this$1$1.getThemeDict(this$1$1.props);
-                if (themeDict !== void 0) {
-                    output2.style = themeDict.plain;
-                }
-                if (style2 !== void 0) {
-                    output2.style = output2.style !== void 0 ? _extends({}, output2.style, style2) : style2;
-                }
-                if (key !== void 0) {
-                    output2.key = key;
+
+    svg {
+        height: 0.8rem;
+    }
+
+    ${(props) => {
+    if (props.isDisabled) {
+      return `
+                border: 1px solid ${props.theme.colors.grey1};
+
+                svg {
+                    color: ${props.theme.colors.grey2};
+                    cursor: not-allowed;
                 }
-                if (className) {
-                    output2.className += " " + className;
+            `;
+    }
+    if (props.isErrored) {
+      return `
+    border: 1 px solid $ {
+        props.theme.colors.error
+    };
+    `;
+    }
+    return `
+    border: 1 px solid $ {
+        props.isOpen ? props.theme.colors.grey3 : props.theme.colors.grey1
+    };: hover {
+        border: 1 px solid $ {
+            props.theme.colors.grey3
+        };
+
+    }
+    `;
+  }}
+`;
+    const Input$1 = styled__default.default.input`
+    overflow: hidden;
+    flex: 1 1 auto;
+
+    margin-right: 0.5rem;
+    padding: 0;
+
+    font-size: ${(props) => props.size ? `${props.size}rem` : props.theme.font.size};
+    font-weight: 300;
+    color: ${(props) => props.theme.colors.grey6};
+    text-align: left;
+    text-overflow: ellipsis;
+    white-space: nowrap;
+
+    background-color: transparent;
+    border: none;
+    outline: 0;
+
+    :disabled {
+        cursor: not-allowed;
+    }
+`;
+    const TagWrapper = styled__default.default.div`
+    overflow: auto;
+    display: flex;
+    flex-wrap: wrap;
+    gap: 0.5rem;
+    align-items: center;
+
+    width: 100%;
+    height: 100%;
+    max-height: ${(props) => props.maxRows * (tagHeight + tagTopMargin) - 0.25}rem;
+`;
+    const Tag$1 = styled__default.default.span`
+    overflow: hidden;
+    display: flex;
+    align-items: center;
+
+    height: ${tagHeight}rem;
+    padding: 0 0.75rem;
+
+    font-size: 0.875rem;
+    color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.text};
+
+    background-color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.blue3};
+    border: 1px solid ${(props) => props.theme.colors.primary};
+    border-radius: 1rem;
+
+    svg {
+        width: 0.85rem;
+        height: 0.85rem;
+        margin-left: 0.25rem;
+        color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.text};
+
+        :hover {
+            color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.primary};
+        }
+    }
+`;
+    const TagText = styled__default.default.span`
+    overflow: hidden;
+    text-overflow: ellipsis;
+    white-space: nowrap;
+`;
+    const NoItemsLabel = styled__default.default.span`
+    display: flex;
+    flex: 1 1 auto;
+    align-items: center;
+    justify-content: center;
+
+    height: 2rem;
+
+    font-size: 1rem;
+    color: ${(props) => props.theme.colors.grey4};
+
+    background-color: ${(props) => props.theme.colors.blue1};
+`;
+    const DropdownList$1 = styled__default.default(List)`
+    border-radius: 0 0 0.25rem 0.25rem;
+    outline: 0;
+    box-shadow: ${(props) => props.theme.shadow.light};
+`;
+    const ChevronButton = styled__default.default(Button$3).attrs((attrs2) => Object.assign(Object.assign({}, attrs2), {
+        styling: "ghost"
+    }))`
+    min-width: 0;
+    height: auto;
+    margin: 0;
+    padding: 0 0.25rem;
+
+    background-color: transparent !important;
+`;
+
+    function MultiSelect(_a3) {
+        var _b, _c;
+        var {
+            maxWidth = "100%", maxRows = 3
+        } = _a3, props = __rest$9(_a3, ["maxWidth", "maxRows"]);
+        const referenceElement = React.useRef(null);
+        const popperElement = React.useRef(null);
+        const {
+            styles: styles2,
+            attributes: attributes2,
+            update: update2
+        } = usePopper$1(referenceElement.current, popperElement.current, {
+            modifiers: [sameWidthModifier],
+            placement: "bottom-start"
+        });
+        const [inputValue, setInputValue] = React.useState("");
+        const {
+            getSelectedItemProps,
+            getDropdownProps,
+            addSelectedItem,
+            removeSelectedItem,
+            selectedItems
+        } = useMultipleSelection(Object.assign({
+            initialSelectedItems: (_b = props.initialValue) !== null && _b !== void 0 ? _b : [],
+            onSelectedItemsChange: (changes) => {
+                if (props.onSelect) {
+                    props.onSelect(changes.selectedItems);
                 }
-                return output2;
-            });
-            _defineProperty$l(this, "getStyleForToken", function(ref2) {
-                var types2 = ref2.types;
-                var empty2 = ref2.empty;
-                var typesSize = types2.length;
-                var themeDict = this$1$1.getThemeDict(this$1$1.props);
-                if (themeDict === void 0) {
-                    return void 0;
-                } else if (typesSize === 1 && types2[0] === "plain") {
-                    return empty2 ? {
-                        display: "inline-block"
-                    } : void 0;
-                } else if (typesSize === 1 && !empty2) {
-                    return themeDict[types2[0]];
+                update2();
+            }
+        }, "selectedItems" in props && {
+            selectedItems: props.selectedItems
+        }));
+        const onTermChange = React.useCallback(
+            (term) => {
+                setInputValue(term);
+                if (props.onTermChange) {
+                    props.onTermChange(term);
                 }
-                var baseStyle = empty2 ? {
-                    display: "inline-block"
-                } : {};
-                var typeStyles = types2.map(function(type2) {
-                    return themeDict[type2];
-                });
-                return Object.assign.apply(Object, [baseStyle].concat(typeStyles));
-            });
-            _defineProperty$l(this, "getTokenProps", function(ref2) {
-                var key = ref2.key;
-                var className = ref2.className;
-                var style2 = ref2.style;
-                var token = ref2.token;
-                var rest$1 = objectWithoutProperties(ref2, ["key", "className", "style", "token"]);
-                var rest = rest$1;
-                var output2 = _extends({}, rest, {
-                    className: "token " + token.types.join(" "),
-                    children: token.content,
-                    style: this$1$1.getStyleForToken(token),
-                    key: void 0
-                });
-                if (style2 !== void 0) {
-                    output2.style = output2.style !== void 0 ? _extends({}, output2.style, style2) : style2;
+            },
+            [props.onTermChange]
+        );
+        const filteredItems = props.onTermChange ? props.items : props.items.filter((item) => {
+            var _a4;
+            return !selectedItems.includes(item) && ((_a4 = item.label) === null || _a4 === void 0 ? void 0 : _a4.toLowerCase().includes(inputValue.toLowerCase()));
+        });
+        const {
+            isOpen,
+            getMenuProps,
+            getInputProps,
+            highlightedIndex,
+            getItemProps,
+            openMenu,
+            getToggleButtonProps
+        } = useCombobox({
+            defaultHighlightedIndex: -1,
+            initialIsOpen: props.initialIsOpen,
+            inputValue,
+            itemToString: (item) => (item === null || item === void 0 ? void 0 : item.label) || "",
+            items: filteredItems,
+            onStateChange: ({
+                inputValue: internalInputVal,
+                selectedItem,
+                type: type2
+            }) => {
+                if (type2 === stateChangeTypes$1.InputChange) {
+                    onTermChange(internalInputVal);
                 }
-                if (key !== void 0) {
-                    output2.key = key;
+                if ([
+                        stateChangeTypes$1.InputKeyDownEnter,
+                        stateChangeTypes$1.ItemClick,
+                        stateChangeTypes$1.InputBlur
+                    ].includes(type2)) {
+                    if (selectedItem) {
+                        onTermChange("");
+                        addSelectedItem(selectedItem);
+                    }
                 }
-                if (className) {
-                    output2.className += " " + className;
+            },
+            selectedItem: null,
+            stateReducer: (state, {
+                changes,
+                type: type2
+            }) => {
+                if (type2 === stateChangeTypes$1.ItemClick || type2 === stateChangeTypes$1.InputKeyDownEnter) {
+                    return Object.assign(Object.assign({}, changes), {
+                        isOpen: true
+                    });
                 }
-                return output2;
-            });
-            _defineProperty$l(this, "tokenize", function(Prism2, code2, grammar, language2) {
-                var env2 = {
-                    code: code2,
-                    grammar,
-                    language: language2,
-                    tokens: []
-                };
-                Prism2.hooks.run("before-tokenize", env2);
-                var tokens2 = env2.tokens = Prism2.tokenize(env2.code, env2.grammar, env2.language);
-                Prism2.hooks.run("after-tokenize", env2);
-                return tokens2;
-            });
-        }
-        if (Component)
-            Highlight2.__proto__ = Component;
-        Highlight2.prototype = Object.create(Component && Component.prototype);
-        Highlight2.prototype.constructor = Highlight2;
-        Highlight2.prototype.render = function render2() {
-            var ref2 = this.props;
-            var Prism2 = ref2.Prism;
-            var language2 = ref2.language;
-            var code2 = ref2.code;
-            var children2 = ref2.children;
-            var themeDict = this.getThemeDict(this.props);
-            var grammar = Prism2.languages[language2];
-            var mixedTokens = grammar !== void 0 ? this.tokenize(Prism2, code2, grammar, language2) : [code2];
-            var tokens2 = normalizeTokens(mixedTokens);
-            return children2({
-                tokens: tokens2,
-                className: "prism-code language-" + language2,
-                style: themeDict !== void 0 ? themeDict.root : {},
-                getLineProps: this.getLineProps,
-                getTokenProps: this.getTokenProps
-            });
-        };
-        return Highlight2;
-    }(React.Component);
-    const Highlight$1 = Highlight;
-    var theme$1 = {
-        plain: {
-            backgroundColor: "#faf8f5",
-            color: "#728fcb"
-        },
-        styles: [{
-            types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
-            style: {
-                color: "#b6ad9a"
-            }
-        }, {
-            types: ["namespace"],
-            style: {
-                opacity: 0.7
-            }
-        }, {
-            types: ["tag", "operator", "number"],
-            style: {
-                color: "#063289"
+                return changes;
             }
-        }, {
-            types: ["property", "function"],
-            style: {
-                color: "#b29762"
+        });
+        React.useEffect(() => {
+            if (isOpen && update2) {
+                update2();
             }
-        }, {
-            types: ["tag-id", "selector", "atrule-id"],
-            style: {
-                color: "#2d2006"
+        }, [isOpen, update2]);
+        const menuProps = getMenuProps();
+        const setMenuRef = menuProps.ref;
+        delete menuProps.ref;
+        const setMenuReference = (value) => {
+            setMenuRef(value);
+            popperElement.current = value;
+        };
+        return jsxRuntime.exports.jsxs(Wrapper$7, {
+            className: props.className,
+            isDisabled: props.disabled,
+            isOpen,
+            maxRows,
+            maxWidth,
+            style: props.style,
+            children: [jsxRuntime.exports.jsx(Tooltip$1, {
+                content: props.errorMsg,
+                disabled: !props.errorMsg,
+                styling: "error",
+                children: jsxRuntime.exports.jsxs(InputWrapper$3, {
+                    isDisabled: props.disabled,
+                    isOpen,
+                    ref: referenceElement,
+                    children: [jsxRuntime.exports.jsxs(TagWrapper, {
+                        maxRows,
+                        children: [selectedItems.map((selectedItem, index2) => jsxRuntime.exports.jsxs(Tag$1, Object.assign({
+                            disabled: props.disabled
+                        }, getSelectedItemProps({
+                            index: index2,
+                            selectedItem
+                        }), {
+                            children: [jsxRuntime.exports.jsx(TagText, {
+                                children: selectedItem.label
+                            }), jsxRuntime.exports.jsx(Cross$1, {
+                                asButton: true,
+                                onClick: (e3) => {
+                                    e3.stopPropagation();
+                                    return removeSelectedItem(selectedItem);
+                                }
+                            })]
+                        }), selectedItem.value)), jsxRuntime.exports.jsx(Input$1, Object.assign({}, getInputProps(getDropdownProps({
+                            preventKeyAction: isOpen
+                        })), {
+                            disabled: props.disabled,
+                            onFocus: openMenu,
+                            placeholder: props.placeholder,
+                            size: props.size,
+                            style: {
+                                flex: "1 1 5ch"
+                            }
+                        }))]
+                    }), jsxRuntime.exports.jsx(ChevronButton, Object.assign({}, getToggleButtonProps(), {
+                        children: jsxRuntime.exports.jsx(Chevron$2, {
+                            disabled: props.disabled,
+                            isOpen
+                        })
+                    }))]
+                })
+            }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsxs(DropdownList$1, Object.assign({}, menuProps, attributes2.popper, {
+                isOpen,
+                ref: setMenuReference,
+                style: Object.assign(Object.assign({}, styles2.popper), {
+                    width: parseFloat((_c = styles2.popper) === null || _c === void 0 ? void 0 : _c.width),
+                    zIndex: 9999
+                }),
+                children: [filteredItems.length > 0 && filteredItems.map((item, index2) => React.createElement(ListItem, Object.assign({}, getItemProps({
+                    index: index2,
+                    item
+                }), {
+                    hovered: index2 === highlightedIndex,
+                    key: `item-${index2}`,
+                    size: props.size,
+                    title: item.label
+                }), item.label)), filteredItems.length === 0 && jsxRuntime.exports.jsx(NoItemsLabel, {
+                    children: "No Items"
+                })]
+            })), document.body)]
+        });
+    }
+    var __rest$8 = globalThis && globalThis.__rest || function(s2, e3) {
+        var t2 = {};
+        for (var p2 in s2)
+            if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
+                t2[p2] = s2[p2];
+        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
+            for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
+                if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
+                    t2[p2[i2]] = s2[p2[i2]];
             }
-        }, {
-            types: ["attr-name"],
-            style: {
-                color: "#896724"
+        return t2;
+    };
+    const SelectedItem = styled__default.default.div`
+    overflow: hidden;
+
+    /* The space available is that of the wrapper minus of the chevron */
+    width: calc(100% - 1rem);
+    margin-right: 0.5rem;
+
+    font-size: ${(props) => props.size ? `${props.size}rem` : "1rem"};
+    font-weight: 300;
+    text-align: left;
+    text-overflow: ellipsis;
+    white-space: nowrap;
+`;
+    const Wrapper$6 = styled__default.default.div`
+    display: inline-flex;
+
+    width: 100%;
+    min-width: 4rem;
+    height: 2.5rem;
+
+    border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0rem 0rem" : "0.25rem"};
+
+    ${(props) => {
+    if (props.isDisabled) {
+      return `
+                border: 1px solid ${props.theme.colors.grey1};
+                cursor: not-allowed;
+            `;
+    }
+    if (props.isErrored) {
+      return `
+    border: 1 px solid $ {
+        props.theme.colors.error
+    };
+    `;
+    }
+    return `
+    border: 1 px solid $ {
+        props.isOpen ? props.theme.colors.grey3 : props.theme.colors.grey1
+    };: hover {
+        border: 1 px solid $ {
+            props.theme.colors.grey3
+        };
+
+    }
+    `;
+  }}
+`;
+    const SelectButton = styled__default.default.button`
+    display: inline-flex;
+    flex: 1 1 auto;
+    align-items: center;
+    justify-content: space-between;
+
+    width: 100%;
+    height: 100%;
+    padding: 0 0.5rem 0 1rem;
+
+    font-size: 1rem;
+    color: ${(props) => props.theme.colors.text};
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border: none;
+    border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0rem 0rem" : "0.25rem"};
+    outline: 0;
+
+    :not(:enabled) {
+        cursor: not-allowed;
+    }
+
+    :hover:enabled {
+        background-color: ${(props) => props.theme.colors.grey2};
+    }
+
+    svg {
+        width: 1rem !important;
+        height: 0.8rem;
+    }
+
+    :disabled {
+        color: ${(props) => props.theme.colors.grey2};
+        background-color: ${(props) => props.theme.colors.grey1};
+
+        svg {
+            color: ${(props) => props.theme.colors.grey2};
+        }
+    }
+`;
+    const DropdownList = styled__default.default(List)`
+    margin-left: -1px;
+    border-radius: 0 0 0.25rem 0.25rem;
+    outline: 0;
+    box-shadow: ${(props) => props.theme.shadow.light};
+`;
+
+    function Select$1(props) {
+        var _a3, _b, _c, _d, _e2, _f;
+        const referenceElement = React.useRef(null);
+        const popperElement = React.useRef(null);
+        const {
+            styles: styles2,
+            attributes: attributes2,
+            update: update2
+        } = usePopper$1(referenceElement.current, popperElement.current, {
+            modifiers: props.applySameWidthModifier === false ? [] : [sameWidthModifier],
+            placement: props.placement || "bottom-start"
+        });
+        const {
+            isOpen,
+            selectedItem,
+            getToggleButtonProps,
+            getMenuProps,
+            highlightedIndex,
+            getItemProps
+        } = useSelect(Object.assign({
+            initialIsOpen: props.initialIsOpen,
+            initialSelectedItem: props.initialValue,
+            itemToString: (item) => item.label,
+            items: props.items,
+            onSelectedItemChange: (changes) => {
+                var _a4;
+                const selected = changes.selectedItem;
+                (_a4 = props.onSelect) === null || _a4 === void 0 ? void 0 : _a4.call(props, selected);
             }
-        }, {
-            types: ["boolean", "string", "entity", "url", "attr-value", "keyword", "control", "directive", "unit", "statement", "regex", "atrule"],
-            style: {
-                color: "#728fcb"
+        }, "selectedItem" in props && {
+            selectedItem: props.selectedItem
+        }));
+        React.useEffect(() => {
+            if (isOpen && update2) {
+                update2();
             }
-        }, {
-            types: ["placeholder", "variable"],
-            style: {
-                color: "#93abdc"
+        }, [isOpen, update2]);
+        const buttonProps = getToggleButtonProps({
+            disabled: props.disabled
+        });
+        const setButtonRef = buttonProps.ref;
+        delete buttonProps.ref;
+        const setButtonReference = (value) => {
+            setButtonRef(value);
+            referenceElement.current = value;
+        };
+        const menuProps = getMenuProps();
+        const setMenuRef = menuProps.ref;
+        delete menuProps.ref;
+        const setMenuReference = (value) => {
+            var _a4;
+            setMenuRef(value);
+            popperElement.current = value;
+            (_a4 = props.dropdownRef) === null || _a4 === void 0 ? void 0 : _a4.call(props, value);
+        };
+        return jsxRuntime.exports.jsx(Tooltip$1, {
+            content: props.errorMsg,
+            disabled: !props.errorMsg,
+            styling: "error",
+            children: jsxRuntime.exports.jsxs(Wrapper$6, {
+                className: props.className,
+                isDisabled: props.disabled,
+                isErrored: !!props.errorMsg,
+                isOpen,
+                onClick: props.onClick,
+                style: props.style,
+                children: [jsxRuntime.exports.jsxs(SelectButton, Object.assign({
+                    disabled: props.disabled,
+                    isOpen
+                }, buttonProps, {
+                    ref: setButtonReference,
+                    type: "button",
+                    children: [jsxRuntime.exports.jsx(SelectedItem, {
+                        size: props.size,
+                        children: (_b = (_a3 = selectedItem === null ? props.placeholder : selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.label) !== null && _a3 !== void 0 ? _a3 : props.placeholder) !== null && _b !== void 0 ? _b : "Select"
+                    }), jsxRuntime.exports.jsx(Chevron$2, {
+                        disabled: props.disabled,
+                        isOpen
+                    })]
+                })), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(DropdownList, Object.assign({}, menuProps, attributes2.popper, {
+                    className: `${(_c = menuProps === null || menuProps === void 0 ? void 0 : menuProps.className) !== null && _c !== void 0 ? _c : ""} ${(_e2 = (_d = attributes2 === null || attributes2 === void 0 ? void 0 : attributes2.popper) === null || _d === void 0 ? void 0 : _d.className) !== null && _e2 !== void 0 ? _e2 : ""} ${props.itemClass}`,
+                    isOpen,
+                    maxItems: props.maxItems,
+                    ref: setMenuReference,
+                    style: Object.assign(Object.assign({}, styles2.popper), {
+                        width: props.applySameWidthModifier === false ? void 0 : parseFloat((_f = styles2.popper) === null || _f === void 0 ? void 0 : _f.width) + 2,
+                        zIndex: 9999
+                    }),
+                    children: props.items.map((item, index2) => {
+                        const _a4 = getItemProps({
+                                index: index2,
+                                item
+                            }),
+                            {
+                                itemClassName
+                            } = _a4,
+                            itemProps = __rest$8(_a4, ["itemClassName"]);
+                        return React.createElement(ListItem, Object.assign({}, itemProps, {
+                            className: `${itemClassName} ${props.itemClass}`,
+                            hovered: index2 === highlightedIndex,
+                            key: `item-${index2}`,
+                            size: props.size,
+                            title: item.label
+                        }), item.label);
+                    })
+                })), document.body)]
+            })
+        });
+    }
+    const StyledSelect$2 = styled__default.default(Select$1)`
+    margin: 1px solid ${(props) => props.theme.colors.background};
+
+    button {
+        background-color: ${(props) => props.theme.colors.background};
+
+        :hover:enabled {
+            background-color: ${(props) => props.theme.colors.background};
+        }
+    }
+`;
+    const InputsWrapper = styled__default.default.div`
+    display: flex;
+    gap: 5px;
+    align-items: center;
+`;
+    const FilterHeader = styled__default.default.div`
+    display: flex;
+    flex-direction: column;
+    gap: 0.25rem;
+    padding: 0 0.5rem;
+`;
+    const StyledInput$3 = styled__default.default(Input$3)`
+    width: ${(props) => props.showTwoInputs ? "106px" : "100%"};
+
+    input {
+        width: ${(props) => props.showTwoInputs ? "106px" : "100%"};
+        background-color: ${(props) => props.theme.colors.background};
+        border: 1px solid ${(props) => props.showError ? props.theme.colors.error : props.theme.colors.background};
+
+        :hover:not(:disabled) {
+            background-color: ${(props) => props.theme.colors.background};
+            border: 1px solid ${(props) => props.showError ? props.theme.colors.error : props.theme.colors.grey3};
+        }
+
+        :active:not(:disabled),
+        :focus:not(:disabled) {
+            border: 1px solid ${(props) => props.showError ? props.theme.colors.error : props.theme.colors.grey3};
+        }
+    }
+`;
+    const ErrorMessage = styled__default.default.span`
+    user-select: none;
+    font-size: 0.7rem;
+    color: ${(props) => props.theme.colors.error};
+`;
+    const NumericFilterItems = [{
+        label: "None",
+        value: "None"
+    }, {
+        label: "Greater than",
+        value: "Greater than"
+    }, {
+        label: "Less than",
+        value: "Less tha"
+    }, {
+        label: "Equal to",
+        value: "Equal to"
+    }, {
+        label: "Not equal to",
+        value: "Not equal to"
+    }, {
+        label: "Between",
+        value: "Between"
+    }];
+
+    function NumericFilter(props) {
+        const [selected, setSelected] = React.useState(null);
+        const [firstInput, setFirstInput] = React.useState(null);
+        const [secondInput, setSecondInput] = React.useState(null);
+        const filteredValues = React.useMemo(() => {
+            if ((selected === null || selected === void 0 ? void 0 : selected.label) === "None") {
+                return {
+                    selected: selected === null || selected === void 0 ? void 0 : selected.label,
+                    value: null
+                };
             }
-        }, {
-            types: ["deleted"],
-            style: {
-                textDecorationLine: "line-through"
+            if ((selected === null || selected === void 0 ? void 0 : selected.label) === "Between") {
+                return {
+                    selected: selected === null || selected === void 0 ? void 0 : selected.label,
+                    value: [firstInput, secondInput]
+                };
             }
-        }, {
-            types: ["inserted"],
-            style: {
-                textDecorationLine: "underline"
+            return {
+                selected: selected === null || selected === void 0 ? void 0 : selected.label,
+                value: firstInput
+            };
+        }, [firstInput, secondInput, selected]);
+        const [previousFilter, setPreviousFilter] = React.useState(filteredValues);
+        const showError = React.useMemo(() => {
+            if (secondInput && firstInput && secondInput < firstInput && (selected === null || selected === void 0 ? void 0 : selected.label) === "Between") {
+                return true;
             }
-        }, {
-            types: ["italic"],
-            style: {
-                fontStyle: "italic"
+            return false;
+        }, [firstInput, secondInput, selected]);
+        const disableApply = React.useMemo(() => {
+            if (props.disabled || previousFilter === filteredValues || showError) {
+                return true;
             }
-        }, {
-            types: ["important", "bold"],
-            style: {
-                fontWeight: "bold"
+            if (firstInput === null && (selected === null || selected === void 0 ? void 0 : selected.label) !== "None") {
+                return true;
             }
-        }, {
-            types: ["important"],
-            style: {
-                color: "#896724"
+            if (secondInput === null && (selected === null || selected === void 0 ? void 0 : selected.label) === "Between") {
+                return true;
             }
-        }]
-    };
-    const duotoneLight = theme$1;
-    const StyledPre = styled__default.default.pre`
-    min-width: fit-content;
-    margin: 0;
-    padding: 1rem;
+            return false;
+        }, [props.disabled, firstInput, secondInput, previousFilter, filteredValues, showError, selected]);
+        return jsxRuntime.exports.jsxs(FilterWrapper, {
+            className: props.className,
+            children: [jsxRuntime.exports.jsxs(FilterHeader, {
+                children: [jsxRuntime.exports.jsx(StyledSelect$2, {
+                    dropdownRef: (element2) => {
+                        if (props.portalsRef) {
+                            props.portalsRef.current[0] = element2;
+                        }
+                    },
+                    initialValue: {
+                        label: "None",
+                        value: "None"
+                    },
+                    items: NumericFilterItems,
+                    maxItems: 6,
+                    onSelect: setSelected
+                }), selected && (selected === null || selected === void 0 ? void 0 : selected.label) !== "None" && jsxRuntime.exports.jsxs(InputsWrapper, {
+                    children: [jsxRuntime.exports.jsx(StyledInput$3, {
+                        onChange: (v2) => setFirstInput(Number(v2)),
+                        showError,
+                        showTwoInputs: (selected === null || selected === void 0 ? void 0 : selected.label) === "Between",
+                        type: "number"
+                    }), (selected === null || selected === void 0 ? void 0 : selected.label) === "Between" && jsxRuntime.exports.jsxs(InputsWrapper, {
+                        children: ["and", jsxRuntime.exports.jsx(StyledInput$3, {
+                            onChange: (v2) => setSecondInput(Number(v2)),
+                            showError,
+                            type: "number",
+                            value: String(secondInput)
+                        })]
+                    })]
+                })]
+            }), showError && jsxRuntime.exports.jsx(ErrorMessage, {
+                children: "Input range not valid"
+            }), jsxRuntime.exports.jsx(ApplyButton, {
+                disabled: disableApply,
+                onClick: (e3) => {
+                    var _a3, _b;
+                    (_a3 = props.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, filteredValues, e3);
+                    (_b = props === null || props === void 0 ? void 0 : props.column) === null || _b === void 0 ? void 0 : _b.setFilter(filteredValues || void 0);
+                    setPreviousFilter(filteredValues);
+                },
+                children: "Apply"
+            })]
+        });
+    }
+    const StepperWrapper = styled__default.default.div`
+    cursor: ${(props) => props.disabled ? "not-allowed" : "pointer"};
 
-    background-color: ${(props) => props.isLightTheme ? theme$3.colors.blue1 : darkTheme$1.colors.blue1} !important;
-    border-radius: 0.25rem;
+    display: flex;
+    flex-direction: column;
+    justify-content: space-around;
+
+    box-sizing: border-box;
+    padding: 0.25rem 0;
+
+    border-radius: 0 0.25rem 0.25rem 0;
 `;
-    const StyledCode = core$2.injectCss(StyledPre);
+    const StepperButton = styled__default.default(Button$3)`
+    min-width: 0.75rem;
+    height: max-content;
+    padding: 0;
+    background-color: transparent !important;
 
-    function Code(props) {
-        const themeCtx = useClTheme();
-        const [rootStyle, css2] = core$2.useComponentStyles(props);
-        const [code2] = core$2.useVariable(props.code);
+    svg {
+        cursor: ${(props) => props.disabled ? "not-allowed" : "pointer"};
+        width: 0.75rem;
+        height: 0.75rem;
+        color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.grey4};
+    }
 
-        function getTheme() {
-            if (props.theme) {
-                if (props.theme === "light") {
-                    return duotoneLight;
-                }
-                return duotoneDark;
-            }
-            if (themeCtx.themeType === "dark") {
-                return duotoneDark;
-            }
-            return duotoneLight;
+    :hover:not(:disabled) {
+        svg {
+            color: ${(props) => props.theme.colors.grey5};
         }
-        return /* @__PURE__ */ React__default.default.createElement(Highlight$1, {
-            ...defaultProps,
-            code: code2,
-            language: props.language,
-            theme: getTheme()
-        }, ({
-            className,
-            style: style2,
-            tokens: tokens2,
-            getLineProps,
-            getTokenProps
-        }) => /* @__PURE__ */ React__default.default.createElement(
-            StyledCode, {
-                $rawCss: css2,
-                className,
-                isLightTheme: props.theme !== "dark",
-                style: {
-                    ...rootStyle,
-                    ...style2
-                }
-            },
-            tokens2.map((line, i2) => /* @__PURE__ */ React__default.default.createElement("div", {
-                ...getLineProps({
-                    key: i2,
-                    line
-                }),
-                key: i2
-            }, line.map((token, key) => /* @__PURE__ */ React__default.default.createElement("span", {
-                ...getTokenProps({
-                    key,
-                    token
-                }),
-                key
-            }))))
-        ));
     }
-    const StyledComponentSelectList = core$2.injectCss(ComponentSelectList$1);
 
-    function ComponentSelectList(props) {
-        const [style2, css2] = core$2.useComponentStyles(props);
-        const [selectedItems, setSelectedItems] = core$2.useVariable(props.selected_items);
-        const [onSelect] = core$2.useAction(props.on_select);
-        const updateSelectedItems2 = React.useCallback(
-            (items) => {
-                const newSelectedItems = props.multi_select ? items : items[0] || null;
-                setSelectedItems == null ? void 0 : setSelectedItems(newSelectedItems);
-                onSelect == null ? void 0 : onSelect(newSelectedItems);
-            },
-            [onSelect, props.multi_select, setSelectedItems]
-        );
-        const remappedItems = props.items.map((item) => {
-            return {
-                ...item,
-                component: /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
-                    component: item.component
-                })
-            };
-        });
-        return /* @__PURE__ */ React__default.default.createElement(
-            StyledComponentSelectList, {
-                $rawCss: css2,
-                items: remappedItems,
-                itemsPerRow: props.items_per_row,
-                multiSelect: props.multi_select,
-                onSelect: updateSelectedItems2,
-                selectedItems: selectedItems && castArray_1(selectedItems),
-                style: style2
-            }
-        );
+    :active:not(:disabled) {
+        svg {
+            transform: scale(0.75);
+        }
     }
-    const DatepickerDiv = styled__default.default.div`
+`;
+    const InputStepper = ({
+        disabled: disabled2,
+        step: step2,
+        stepSkip
+    }) => {
+        const amountToStep = Math.abs(stepSkip !== null && stepSkip !== void 0 ? stepSkip : 1);
+        const stepUp = () => step2(amountToStep);
+        const stepDown = () => step2(amountToStep * -1);
+        return jsxRuntime.exports.jsxs(StepperWrapper, {
+            disabled: disabled2,
+            children: [jsxRuntime.exports.jsx(StepperButton, {
+                disabled: disabled2,
+                onClick: stepUp,
+                styling: "ghost",
+                tabIndex: -1,
+                children: jsxRuntime.exports.jsx(ChevronUp, {})
+            }), jsxRuntime.exports.jsx(StepperButton, {
+                disabled: disabled2,
+                onClick: stepDown,
+                styling: "ghost",
+                tabIndex: -1,
+                children: jsxRuntime.exports.jsx(ChevronDown, {})
+            })]
+        });
+    };
+    const InputWrapper$2 = styled__default.default.div`
     display: flex;
     flex-direction: row;
-    align-items: center;
-`;
-    const StyledDatepickerDiv = core$2.injectCss(DatepickerDiv);
 
-    function parseDateString$1(date) {
-        if (!date) {
-            return;
+    width: 22ch;
+    height: 2.5rem;
+    padding-right: 0.5rem;
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border: 1px solid ${(props) => props.errorMsg ? props.theme.colors.error : props.theme.colors.grey1};
+    border-radius: 0.25rem;
+
+    input {
+        height: calc(2.5rem - 2px);
+        border: none;
+        border-radius: 0.25rem;
+    }
+
+    div {
+        border: none;
+        border-radius: 0.25rem;
+
+        div {
+            border: none;
+            border-radius: 0.25rem;
         }
-        if (date instanceof Date) {
-            return date;
+    }
+
+    :hover {
+        background-color: ${(props) => props.disabled ? props.theme.colors.grey1 : props.theme.colors.grey2};
+        /* stylelint-disable -- fails to parse the statement */
+        border: 1px solid
+            ${(props) => {
+    if (props.disabled) {
+      return props.theme.colors.grey1;
+    }
+    if (props.errorMsg) {
+      return props.theme.colors.error;
+    }
+    return props.theme.colors.grey2;
+  }};
+        /* stylelint-enable */
+
+        input {
+            background-color: ${(props) => props.disabled ? props.theme.colors.grey1 : props.theme.colors.grey2};
         }
-        const parsed = parseISO$1(date);
-        if (Number.isNaN(parsed.getTime())) {
-            return;
+
+        div {
+            background-color: ${(props) => props.disabled ? props.theme.colors.grey1 : props.theme.colors.grey2};
         }
-        return parsed;
     }
 
-    function Datepicker(props) {
-        const formCtx2 = useFormContext(props);
-        const [style2, css2] = core$2.useComponentStyles(props);
-        const [value, setValue] = core$2.useVariable(formCtx2.resolveInitialValue());
-        const [onChangeAction] = core$2.useAction(props.onchange);
-        const isFirstRender = React.useRef(true);
-        const onChange2 = (date) => {
-            if (!isFirstRender.current && (!Array.isArray(date) && date || Array.isArray(date) && date[0] && date[1])) {
-                let newDate;
-                if (Array.isArray(date)) {
-                    newDate = [formatISO(date[0]), formatISO(date[1])];
-                } else {
-                    newDate = formatISO(date);
-                }
-                setValue(newDate);
-                onChangeAction(newDate);
-                formCtx2.updateForm(newDate);
-            }
-        };
-        React.useEffect(() => {
-            if (isFirstRender.current) {
-                isFirstRender.current = false;
-            }
-        }, []);
-        const formattedValue = React.useMemo(() => {
-            if (props.range && value) {
-                return [parseDateString$1(value == null ? void 0 : value[0]), parseDateString$1(value == null ? void 0 : value[1])];
-            }
-            return parseDateString$1(value);
-        }, [value, props.range]);
-        return /* @__PURE__ */ React__default.default.createElement(StyledDatepickerDiv, {
-            $rawCss: css2,
-            style: style2
-        }, /* @__PURE__ */ React__default.default.createElement(
-            DatePicker, {
-                dateFormat: props.date_format,
-                maxDate: parseDateString$1(props.max_date),
-                minDate: parseDateString$1(props.min_date),
-                onChange: onChange2,
-                popperStrategy: "fixed",
-                selectsRange: props.range,
-                shouldCloseOnSelect: props.select_close,
-                showTimeInput: props.enable_time,
-                value: formattedValue
-            }
-        ));
+    :focus-within:not(:disabled) {
+        border: 1px solid ${(props) => props.errorMsg ? props.theme.colors.error : props.theme.colors.grey3};
+
+        input {
+            border: none;
+        }
+    }
+
+    /* Fix: Overrides the 22ch default width of the nested regular input */
+    > div:first-child {
+        width: 100%;
+        height: auto;
     }
-    const status = {
-        FAILED: "FAILED",
-        INITIALIZED: "INITIALIZED",
-        LOADING: "LOADING",
-        SUCCESS: "SUCCESS"
-    };
-    const StyledCheck = styled__default.default(Check)`
-    color: ${(props) => props.theme.colors.success};
-`;
-    const Heading$2 = styled__default.default.h2`
-    margin-bottom: 1rem;
-    color: ${(props) => props.theme.colors.text};
 `;
-    async function uploadFileToExtension(file, extras, variableId, resolver_id) {
-        const formData = new FormData();
-        formData.append("data", file);
-        if (resolver_id) {
-            formData.append("resolver_id", resolver_id);
+    const numericFilter = (integerOnly) => (e3) => {
+        if (parseInt(e3.key) || parseInt(e3.key) === 0) {
+            return true;
         }
-        const url2 = new URL("/api/core/data/upload", window.location.origin);
-        if (variableId) {
-            url2.searchParams.set("data_uid", variableId);
+        if (CONTROL_KEYS.includes(e3.key)) {
+            return true;
         }
-        const res = await core$2.request(
-            url2, {
-                body: formData,
-                method: HTTP_METHOD.POST
-            },
-            extras
-        );
-        await validateResponse(res, `Failed to upload file: ${file.name}`);
-        const result = await res.json();
-        return {
-            newStatus: result.status
-        };
-    }
-    const StyledDropzone = core$2.injectCss(UploadDropzone$1);
-    const StyledCenter = core$2.injectCss(core$2.Center);
-
-    function UploadDropzone(props) {
-        const theme2 = useClTheme();
-        const [style2, css2] = core$2.useComponentStyles(props);
-        const [currentStatus, setCurrentStatus] = React.useState(status.INITIALIZED);
-        const [errorMessage, setErrorMessage] = React.useState();
-        const [onFileDrop] = core$2.useAction(props.on_drop);
-        const extras = core$2.useRequestExtras();
-        const onDrop = async (acceptedFiles) => {
+        const target = e3.target;
+        if (!integerOnly && e3.key === Key.PERIOD && !target.value.includes(Key.PERIOD)) {
+            return true;
+        }
+        if (e3.key === Key.MINUS && !e3.shiftKey && target.selectionStart === 0 && !target.value.includes(Key.MINUS)) {
+            return true;
+        }
+        return false;
+    };
+    const getInitialValue = (value, initialValue) => {
+        if (Number.isFinite(value)) {
+            return String(value);
+        }
+        if (Number.isFinite(initialValue)) {
+            return String(initialValue);
+        }
+        return "";
+    };
+    const NumericInput = React__namespace.forwardRef((props, ref2) => {
+        const keydownFilter = React.useMemo(() => numericFilter(props.integerOnly), [props.integerOnly]);
+        const [input, setInput] = React.useState(getInitialValue(props.value, props.initialValue));
+        const step2 = (value) => {
             var _a3;
-            if (acceptedFiles.length === 1) {
-                setCurrentStatus(status.LOADING);
-                try {
-                    const {
-                        newStatus
-                    } = await uploadFileToExtension(
-                        acceptedFiles[0],
-                        extras,
-                        (_a3 = props.target) == null ? void 0 : _a3.uid,
-                        props.resolver_id
-                    );
-                    setCurrentStatus(newStatus);
-                } catch (err) {
-                    setErrorMessage(err.message);
-                    setCurrentStatus(status.FAILED);
-                    throw err;
+            if (!input || input === "-") {
+                return;
+            }
+            const isFloat = input.includes(".");
+            const parsedValue = isFloat ? parseFloat(input) : parseInt(input);
+            let nextValueNumber = parsedValue + value;
+            let nextValueStr = String(nextValueNumber);
+            if (isFloat) {
+                const decimals = input.split(".")[1];
+                if (decimals) {
+                    nextValueStr = (parsedValue + value / Math.pow(10, decimals.length)).toFixed(decimals.length);
+                    nextValueNumber = parseFloat(nextValueStr);
                 }
-                onFileDrop(acceptedFiles[0]);
+            }
+            if (props.value !== void 0) {
+                (_a3 = props.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, nextValueNumber, {
+                    target: {
+                        value: nextValueStr
+                    }
+                });
             } else {
-                setErrorMessage("Upload failed. Please individually drop CSV files");
-                setCurrentStatus(status.FAILED);
+                setInput(nextValueStr);
             }
         };
-        const onReset = () => {
-            setCurrentStatus(status.INITIALIZED);
-            setErrorMessage(void 0);
-        };
-        if (currentStatus === status.SUCCESS) {
-            return /* @__PURE__ */ React__default.default.createElement(StyledCenter, {
-                $rawCss: css2,
-                style: style2
-            }, /* @__PURE__ */ React__default.default.createElement(StyledCheck, {
-                size: "10x"
-            }), /* @__PURE__ */ React__default.default.createElement(Heading$2, null, "Upload Successful"), /* @__PURE__ */ React__default.default.createElement(Button$3, {
-                onClick: onReset,
-                styling: "secondary"
-            }, "Upload Again"));
-        }
-        if (currentStatus === status.FAILED) {
-            return /* @__PURE__ */ React__default.default.createElement(StyledCenter, {
-                $rawCss: css2,
-                style: style2
-            }, /* @__PURE__ */ React__default.default.createElement("span", {
-                style: {
-                    color: theme2.colors.error,
-                    textAlign: "center"
-                }
-            }, errorMessage), /* @__PURE__ */ React__default.default.createElement(Heading$2, null, "Upload Failed"), /* @__PURE__ */ React__default.default.createElement(Button$3, {
-                onClick: onReset,
-                styling: "ghost"
-            }, "Upload Again"));
-        }
-        if (currentStatus === status.LOADING) {
-            return /* @__PURE__ */ React__default.default.createElement(core$2.DefaultFallback, null);
-        }
-        return /* @__PURE__ */ React__default.default.createElement(
-            StyledDropzone, {
-                $rawCss: css2,
-                accept: props.accept,
-                enablePaste: props.enable_paste,
-                onDrop,
-                style: style2
+        const onKeyDown = (e3) => {
+            var _a3, _b;
+            (_a3 = props.onKeyDown) === null || _a3 === void 0 ? void 0 : _a3.call(props, e3);
+            if (!props.stepper) {
+                return;
+            }
+            const stepSkip = Math.abs((_b = props.stepSkip) !== null && _b !== void 0 ? _b : 1);
+            if (e3.key === Key.UP) {
+                step2(stepSkip);
+            }
+            if (e3.key === Key.DOWN) {
+                step2(stepSkip * -1);
             }
-        );
-    }
-    const GridComponent = styled__default.default.div`
-    display: flex;
-    flex: 1 1 auto;
-    flex-direction: column;
-`;
-    const StyledGrid = core$2.injectCss(GridComponent);
-
-    function Grid(props) {
-        var _a3, _b, _c, _d, _e2, _f, _g, _h, _i2, _j;
-        const breakpoints = {
-            lg: (_b = (_a3 = props == null ? void 0 : props.breakpoints) == null ? void 0 : _a3.lg) != null ? _b : 992,
-            md: (_d = (_c = props == null ? void 0 : props.breakpoints) == null ? void 0 : _c.md) != null ? _d : 768,
-            sm: (_f = (_e2 = props == null ? void 0 : props.breakpoints) == null ? void 0 : _e2.sm) != null ? _f : 576,
-            xl: (_h = (_g = props == null ? void 0 : props.breakpoints) == null ? void 0 : _g.xl) != null ? _h : 1200,
-            xs: (_j = (_i2 = props == null ? void 0 : props.breakpoints) == null ? void 0 : _i2.xs) != null ? _j : 0
         };
-        const [style2, css2] = core$2.useComponentStyles(props);
-        const _children = props.children.map((child) => {
-            return {
-                ...child,
-                props: {
-                    ...child.props,
-                    breakpoints,
-                    row_gap: props.row_gap
+        const onChange2 = React.useCallback(
+            (value, e3) => {
+                var _a3, _b;
+                const parsed = props.integerOnly ? parseInt(value) : parseFloat(value);
+                if (props.value === void 0) {
+                    setInput(value);
+                    (_a3 = props.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, parsed, e3);
+                    return;
                 }
-            };
-        });
-        return /* @__PURE__ */ React__default.default.createElement(
-            StyledGrid, {
-                $rawCss: css2,
-                className: props.className,
-                style: {
-                    alignItems: props.align,
-                    justifyContent: props.justify,
-                    rowGap: props.row_gap,
-                    ...style2
+                if (value.endsWith(".")) {
+                    setInput(value);
+                    return;
                 }
-            },
-            /* @__PURE__ */
-            React__default.default.createElement(core$2.DisplayCtx.Provider, {
-                value: {
-                    component: "grid",
-                    direction: "vertical",
-                    hug: props.hug
+                if (value.includes(".") && value.endsWith("0")) {
+                    setInput(value);
+                    return;
                 }
-            }, _children.map((child, idx) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
-                component: child,
-                key: `grid-${idx}-${child.uid}`
-            })))
-        );
-    }
-    const StyledTag$1 = core$2.injectCss("h1");
-    const anchorName = (text2) => text2.toLowerCase().replace(/\s+/g, "-");
-
-    function Heading$1(props) {
-        const theme2 = useClTheme();
-        const [style2, css2] = core$2.useComponentStyles(props);
-        const [heading2] = core$2.useVariable(props.heading);
-        const tag = `h${props.level}`;
-        return /* @__PURE__ */ React__default.default.createElement(
-            StyledTag$1, {
-                $rawCss: css2,
-                as: tag,
-                className: props.className,
-                id: anchorName(heading2),
-                style: {
-                    color: theme2.colors.text,
-                    textAlign: props.align,
-                    ...style2
+                if (value === "-") {
+                    setInput(value);
+                    return;
                 }
+                (_b = props.onChange) === null || _b === void 0 ? void 0 : _b.call(props, parsed, e3);
             },
-            heading2
+            [props.integerOnly, props.value, props.onChange]
         );
-    }
-    const _Wrapper = styled__default.default.div`
-    display: flex;
-    width: 100%;
-    height: 100%;
-`;
-    const Wrapper$3 = core$2.injectCss(_Wrapper);
+        React.useEffect(() => {
+            setInput(getInitialValue(props.value, props.initialValue));
+        }, [props.value]);
+        return jsxRuntime.exports.jsxs("div", {
+            children: [jsxRuntime.exports.jsxs(InputWrapper$2, {
+                disabled: props.disabled,
+                errorMsg: props.errorMsg,
+                stepper: props.stepper,
+                style: props.style,
+                children: [jsxRuntime.exports.jsx(Input$3, {
+                    autoFocus: props.autoFocus,
+                    className: props.className,
+                    disabled: props.disabled,
+                    keydownFilter,
+                    maxValue: props.maxValue,
+                    minValue: props.minValue,
+                    onBlur: props.onBlur,
+                    onChange: onChange2,
+                    onComplete: props.onComplete,
+                    onKeyDown,
+                    placeholder: props.placeholder,
+                    ref: ref2,
+                    value: input
+                }), props.stepper && jsxRuntime.exports.jsx(InputStepper, {
+                    disabled: props.disabled,
+                    step: step2,
+                    stepSkip: props.stepSkip
+                })]
+            }), props.errorMsg && jsxRuntime.exports.jsx(ErrorMessage$1, {
+                children: props.errorMsg
+            })]
+        });
+    });
+    Input$3.displayName = "NumericInput";
+    var isArray$a = isArray_1;
 
-    function HtmlRaw(props) {
-        const [style2, css2] = core$2.useComponentStyles(props);
-        return /* @__PURE__ */ React__default.default.createElement(
-            Wrapper$3, {
-                $rawCss: css2,
-                className: props.className,
-                dangerouslySetInnerHTML: {
-                    __html: props.html
-                },
-                style: style2
-            }
-        );
+    function castArray() {
+        if (!arguments.length) {
+            return [];
+        }
+        var value = arguments[0];
+        return isArray$a(value) ? value : [value];
     }
-    const ButtonWrapper = styled__default.default.section`
-    display: flex;
-    flex-direction: row-reverse;
-    gap: 0.75rem;
-    justify-content: space-between;
+    var castArray_1 = castArray;
+    const Wrapper$5 = styled__default.default.div`
+    overflow: auto;
+    display: grid;
+    grid-template-columns: repeat(${(props) => props.itemsPerRow}, 1fr);
 
-    button {
-        width: 6rem;
-    }
+    max-height: 100%;
+    margin: 2rem;
+    padding: 1rem;
+
+    color: ${(props) => props.theme.colors.text};
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border-radius: 0.25rem;
 `;
-    const FormWrapper = styled__default.default.div`
+    const Card$2 = styled__default.default.div`
+    cursor: pointer;
+
+    position: relative;
+
     display: flex;
     flex-direction: column;
-    gap: 0.75rem;
-`;
-    const StyledForm = core$2.injectCss("div");
+    align-items: center;
+    justify-content: center;
 
-    function Form(props) {
-        const [formState, setFormState] = core$2.useVariable(props.value);
-        const [onSubmit] = core$2.useAction(props.onsubmit);
-        const [style2, css2] = core$2.useComponentStyles(props);
-        const updateForm = React.useCallback(
-            (value, id2) => {
-                setFormState((oldFormState) => ({
-                    ...oldFormState,
-                    [id2]: value
-                }));
-            },
-            [setFormState]
-        );
-        const resolveInitialValue = React.useCallback(
-            (defaultValue2, variable, id2) => {
-                if (formState == null ? void 0 : formState[id2]) {
-                    if (variable) {
-                        return {
-                            ...variable,
-                            default: formState == null ? void 0 : formState[id2]
-                        };
-                    }
-                    return formState == null ? void 0 : formState[id2];
-                }
-                return variable != null ? variable : defaultValue2;
-            },
-            [formState]
-        );
-        const pages = React.useMemo(() => {
-            return props.children.filter((child) => child.name === "FormPage");
-        }, [props.children]);
-        const [currentPage, setCurrentPage] = React.useState(0);
-        return /* @__PURE__ */ React__default.default.createElement(formCtx.Provider, {
-            value: {
-                formValues: formState,
-                resolveInitialValue,
-                updateForm
-            }
-        }, /* @__PURE__ */ React__default.default.createElement(StyledForm, {
-            $rawCss: css2,
-            className: props.className,
-            style: style2
-        }, pages.length === 0 && /* @__PURE__ */ React__default.default.createElement(FormWrapper, {
-            style: {
-                alignItems: props.align,
-                justifyContent: props.justify
-            }
-        }, props.children.map((child, idx) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
-            component: child,
-            key: `form-${idx}-${child.uid}`
-        })), /* @__PURE__ */ React__default.default.createElement(ButtonWrapper, null, props.onsubmit && /* @__PURE__ */ React__default.default.createElement(Button$3, {
-            onClick: () => onSubmit(formState),
-            styling: "primary"
-        }, "Submit"))), pages.length > 0 && /* @__PURE__ */ React__default.default.createElement(FormWrapper, null, /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
-            component: props.children[currentPage]
-        }), /* @__PURE__ */ React__default.default.createElement(ButtonWrapper, null, currentPage < pages.length - 1 && /* @__PURE__ */ React__default.default.createElement(Button$3, {
-            onClick: () => setCurrentPage(currentPage + 1),
-            styling: "primary"
-        }, "Next"), currentPage === pages.length - 1 && props.onsubmit && /* @__PURE__ */ React__default.default.createElement(Button$3, {
-            onClick: () => onSubmit(formState),
-            styling: "primary"
-        }, "Submit"), currentPage > 0 && pages.length > 1 && /* @__PURE__ */ React__default.default.createElement(Button$3, {
-            onClick: () => setCurrentPage(currentPage - 1),
-            outline: true,
-            styling: "primary"
-        }, "Back")))));
+    margin: 1rem;
+    padding: 1rem;
+
+    text-align: center;
+
+    background-color: ${(props) => props.theme.colors.blue1};
+    border: ${(props) => `2px solid ${props.selected ? props.theme.colors.primary : "transparent"}`};
+    border-radius: 0.25rem;
+
+    :hover {
+        border: ${(props) => `2px solid ${props.selected ? props.theme.colors.primary : props.theme.colors.grey3}`};
     }
-    const PageWrapper = styled__default.default.section`
-    display: flex;
-    flex-direction: column;
-    gap: 0.75rem;
 `;
-    const PageTitle = styled__default.default.h2`
-    font-size: 1.4rem;
+    const CardTitle = styled__default.default.h2`
+    margin-top: 1rem;
 `;
-    const StyledWrapper = core$2.injectCss(PageWrapper);
+    const CardSubtitle = styled__default.default.h4`
+    margin-top: 1rem;
+    color: ${(props) => props.theme.colors.grey6};
+`;
+    const StyledCheckSquare = styled__default.default(CheckSquare)`
+    cursor: pointer;
 
-    function FormPage(props) {
-        const [style2, css2] = core$2.useComponentStyles(props);
-        return /* @__PURE__ */ React__default.default.createElement(StyledWrapper, {
-            $rawCss: css2,
-            className: props.className,
-            style: style2
-        }, props.title && /* @__PURE__ */ React__default.default.createElement(PageTitle, null, props.title), props.children.map((child, idx) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
-            component: child,
-            key: `form-page-${idx}-${child.uid}`
-        })));
-    }
+    position: absolute;
+    z-index: 3;
+    top: 10px;
+    right: 10px;
 
-    function Icon$1(props) {
-        const [style2, css2] = core$2.useComponentStyles(props);
-        const IconComponent = core$2.getIcon(props.icon);
-        const validStyle = {
-            ...style2
-        };
-        delete validStyle.fontWeight;
-        return /* @__PURE__ */ React__default.default.createElement(
-            IconComponent, {
-                $rawCss: css2,
-                style: {
-                    alignItems: "center",
-                    display: "flex",
-                    ...validStyle,
-                    color: props.color
-                }
-            }
-        );
-    }
-    const ImageComponent = styled__default.default.div`
+    color: ${(props) => props.theme.colors.primary};
+`;
+    const ComponentWrapper = styled__default.default.div`
+    cursor: pointer;
     display: flex;
+    width: 100%;
 `;
-    const StyledImg$1 = core$2.injectCss(ImageComponent);
 
-    function Image$1(props) {
-        const [style2, css2] = core$2.useComponentStyles(props);
-        const source = core$2.prependBaseUrl(props.src);
-        return /* @__PURE__ */ React__default.default.createElement(StyledImg$1, {
-            $rawCss: css2,
-            style: style2
-        }, /* @__PURE__ */ React__default.default.createElement("img", {
-            alt: `Could not load ${source}`,
-            loading: "lazy",
-            src: source
-        }));
+    function getSelectedIndex(selectedItems, item) {
+        return selectedItems.findIndex((selectedItem) => selectedItem === item.title);
     }
-    const StyledInput$2 = core$2.injectCss(Input$3);
-    const StyledNumericInput = core$2.injectCss(NumericInput);
 
-    function getNumericValue(value) {
-        return value == null || Number.isNaN(Number(value)) ? null : Number(value);
+    function updateSelectedItems(prevSelections, item, multiSelect) {
+        const selectedIndex = getSelectedIndex(prevSelections, item);
+        if (selectedIndex > -1) {
+            return prevSelections.filter((_2, index2) => index2 !== selectedIndex);
+        }
+        if (multiSelect) {
+            return [...prevSelections, item.title];
+        }
+        return [item.title];
     }
 
-    function Input(props) {
-        const formCtx2 = useFormContext(props);
-        const [style2, css2] = core$2.useComponentStyles(props);
-        const [value, setValue] = core$2.useVariable(formCtx2.resolveInitialValue());
-        const [internalValue, setInternalValue] = React.useState(value);
-        const [onInputAction] = core$2.useAction(props.onchange);
-        const debouncedAction = React.useMemo(() => debounce_1(onInputAction, 500), [onInputAction]);
-        const debouncedSetValue = React.useMemo(() => debounce_1(setValue, 500), [setValue]);
-        const debouncedUpdateForm = React.useMemo(() => debounce_1(formCtx2.updateForm, 500), [formCtx2.updateForm]);
-
-        function handleChange(val) {
-            let newValue = val;
-            if (props.type === "number") {
-                newValue = getNumericValue(newValue);
-            }
-            setInternalValue(newValue);
-            debouncedSetValue(newValue);
-            debouncedAction(val);
-            debouncedUpdateForm(val);
-        }
+    function ComponentSelectList$1(props) {
+        const [selectedCards, setSelectedCards] = React.useState(props.selectedItems ? castArray_1(props.selectedItems) : []);
         React.useEffect(() => {
-            debouncedAction.cancel();
-            debouncedSetValue.cancel();
-            debouncedUpdateForm.cancel();
-            let newValue = value;
-            if (props.type === "number") {
-                newValue = getNumericValue(newValue);
-            }
-            setInternalValue(newValue);
-        }, [value]);
-        if (props.type === "number") {
-            return /* @__PURE__ */ React__default.default.createElement(
-                StyledNumericInput, {
-                    $rawCss: css2,
-                    className: props.className,
-                    onChange: (e3) => handleChange(String(e3)),
-                    placeholder: props.placeholder,
-                    stepper: true,
-                    style: style2,
-                    value: internalValue
-                }
-            );
-        }
-        return /* @__PURE__ */ React__default.default.createElement(
-            StyledInput$2, {
-                $rawCss: css2,
-                className: props.className,
-                onChange: handleChange,
-                placeholder: props.placeholder,
-                style: style2,
-                type: props.type,
-                value: internalValue
-            }
+            setSelectedCards(props.selectedItems ? castArray_1(props.selectedItems) : []);
+        }, [props.selectedItems]);
+        const onClick = React.useCallback(
+            (index2) => {
+                var _a3;
+                const updatedSelectedCards = updateSelectedItems(selectedCards, props.items[index2], props.multiSelect);
+                setSelectedCards(updatedSelectedCards);
+                (_a3 = props.onSelect) === null || _a3 === void 0 ? void 0 : _a3.call(props, updatedSelectedCards);
+            },
+            [props.items, props.multiSelect, selectedCards, setSelectedCards]
         );
+        return jsxRuntime.exports.jsx(Wrapper$5, {
+            className: props.className,
+            itemsPerRow: props.itemsPerRow && props.itemsPerRow > 0 ? props.itemsPerRow : 3,
+            style: props.style,
+            children: props.items.map((item, index2) => jsxRuntime.exports.jsxs(Card$2, {
+                onClick: () => onClick(index2),
+                selected: getSelectedIndex(selectedCards, item) > -1,
+                children: [getSelectedIndex(selectedCards, item) > -1 && jsxRuntime.exports.jsx(StyledCheckSquare, {
+                    size: "2x"
+                }), jsxRuntime.exports.jsx(ComponentWrapper, {
+                    children: item.component
+                }), jsxRuntime.exports.jsx(CardTitle, {
+                    children: item.title
+                }), item.subtitle && jsxRuntime.exports.jsx(CardSubtitle, {
+                    children: item.subtitle
+                })]
+            }, `${item.title}-${index2}`))
+        });
     }
-    const StyledLabel = core$2.injectCss(styled__default.default.label`
+    const Track$1 = styled__default.default.div`
+    position: relative;
+
+    overflow: hidden;
     display: flex;
-    flex-grow: 0 !important;
-    gap: 0.5rem;
-    align-items: flex-start;
 
-    font-size: 1rem;
-`);
+    width: 100%;
+    height: ${(props) => props.small ? "0.5rem" : "1rem"};
 
-    function Label(props) {
-        var _a3;
-        const [style2, css2] = core$2.useComponentStyles(props);
-        return /* @__PURE__ */ React__default.default.createElement(
-            StyledLabel, {
-                $rawCss: css2,
-                className: props.className,
+    background-color: ${(props) => props.theme.colors.grey2};
+    border-radius: ${(props) => props.small ? "0.25rem" : "0.5rem"};
+`;
+    const Bar = styled__default.default.div`
+    position: absolute;
+
+    overflow: ${(props) => props.multi ? "hidden" : "visible"};
+
+    height: 100%;
+
+    background-color: ${(props) => props.color ? props.color : props.theme.colors.primary};
+    border-radius: ${(props) => props.small ? "0.25rem" : "0.5rem"};
+`;
+    const Text$3 = styled__default.default.span`
+    position: absolute;
+    right: 0.5rem;
+    bottom: 0.05rem;
+    left: 0.5rem;
+
+    height: 100%;
+
+    font-size: 0.75rem;
+    color: ${(props) => props.theme.colors.blue1};
+    text-align: end;
+`;
+    const defaultColors = [theme$3.colors.primary, theme$3.colors.success, theme$3.colors.warning, theme$3.colors.error];
+    const arrayify = (input, defaultInput) => {
+        if (typeof input === "undefined") {
+            return defaultInput;
+        }
+        if (Array.isArray(input)) {
+            return input;
+        }
+        return [input];
+    };
+
+    function ProgressBar$1(props) {
+        const progresses = typeof props.progress === "number" ? [{
+            index: 0,
+            value: props.progress
+        }] : lodash$1.exports.sortBy([...props.progress.map((x2, i2) => ({
+            index: i2,
+            value: x2
+        }))], "value").reverse();
+        const colors2 = arrayify(props.color, defaultColors.slice(0, progresses.length));
+        const labels = arrayify(props.label, progresses.map((x2) => `${x2.value}%`));
+        return jsxRuntime.exports.jsx(Track$1, {
+            className: props.className,
+            multi: typeof props.progress !== "number",
+            small: props.small,
+            style: props.style,
+            children: progresses.map((progress, index2) => jsxRuntime.exports.jsx(Bar, {
+                color: colors2[progress.index],
+                multi: typeof props.progress !== "number",
+                small: props.small,
                 style: {
-                    flexDirection: props.direction === "horizontal" ? "row" : "column",
-                    ...style2
-                }
-            },
-            typeof props.value === "string" ? /* @__PURE__ */ React__default.default.createElement(
-                "span", {
-                    style: {
-                        alignItems: "center",
-                        display: "flex",
-                        height: props.direction === "horizontal" ? "2.5rem" : "auto",
-                        width: (_a3 = props.label_width) != null ? _a3 : "auto"
-                    }
+                    width: `${progress.value}%`
                 },
-                props.value
-            ) : /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
-                component: props.value
-            }),
-            props.children.map((child, idx) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
-                component: child,
-                key: `cell-${idx}-${child.uid}`
-            }))
-        );
+                children: !props.small && jsxRuntime.exports.jsx(Text$3, {
+                    progress: progress.value,
+                    children: labels[progress.index]
+                })
+            }, index2))
+        });
     }
+    const RadioGroupWrapper = styled__default.default.div`
+    display: ${(props) => props.isHorizontal ? "flex" : "block"};
+    gap: ${(props) => props.isHorizontal ? "1.25rem" : "0rem"};
+`;
+    const RadioWrapper = styled__default.default.label`
+    cursor: ${(props) => props["aria-disabled"] ? "not-allowed" : "pointer"};
+    user-select: none;
 
-    function ok$2() {}
+    display: flex;
+    gap: 0.5rem;
+    align-items: center;
+    justify-content: flex-start;
 
-    function unreachable() {}
+    width: ${(props) => props.isListStyle ? "auto" : "fit-content"};
+    height: 2.5rem;
+    padding: 0 0.5rem;
 
-    function parse$7(value) {
-        const tokens2 = [];
-        const input = String(value || "");
-        let index2 = input.indexOf(",");
-        let start2 = 0;
-        let end2 = false;
-        while (!end2) {
-            if (index2 === -1) {
-                index2 = input.length;
-                end2 = true;
-            }
-            const token = input.slice(start2, index2).trim();
-            if (token || !end2) {
-                tokens2.push(token);
-            }
-            start2 = index2 + 1;
-            index2 = input.indexOf(",", start2);
-        }
-        return tokens2;
-    }
+    color: ${(props) => props["aria-disabled"] ? props.theme.colors.grey3 : props.theme.colors.text};
 
-    function stringify$3(values, options) {
-        const settings2 = options || {};
-        const input = values[values.length - 1] === "" ? [...values, ""] : values;
-        return input.join(
-            (settings2.padRight ? " " : "") + "," + (settings2.padLeft === false ? "" : " ")
-        ).trim();
-    }
-    const nameRe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
-    const nameReJsx = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
-    const emptyOptions$3 = {};
+    border: none;
+    border-radius: 0.25rem;
 
-    function name$2(name2, options) {
-        const settings2 = options || emptyOptions$3;
-        const re2 = settings2.jsx ? nameReJsx : nameRe;
-        return re2.test(name2);
+    /* sets checkmark indicator */
+    span::after {
+        top: calc(0.25rem - 1px);
+        left: calc(0.25rem - 1px);
+
+        width: 0.5rem;
+        height: 0.5rem;
+
+        background-color: ${(props) => props["aria-disabled"] ? props.theme.colors.grey3 : props.theme.colors.grey5};
+        border-radius: 50%;
     }
-    const re$1 = /[ \t\n\f\r]/g;
 
-    function whitespace(thing) {
-        return typeof thing === "object" ? thing.type === "text" ? empty$3(thing.value) : false : empty$3(thing);
+    /* Show the checkmark when checked */
+    input:checked ~ span::after {
+        display: block;
     }
 
-    function empty$3(value) {
-        return value.replace(re$1, "") === "";
+    /* Controls background color change depending on style */
+    ${(props) => {
+    if (props.isListStyle) {
+      return `:hover {
+                        background-color: ${props["aria-disabled"] ? "none" : props.theme.colors.grey1}
+            }
+            :active {
+                background-color: ${props["aria-disabled"] ? "none" : props.theme.colors.grey2}
+    }`;
     }
-    class Schema {
-        constructor(property, normal, space2) {
-            this.property = property;
-            this.normal = normal;
-            if (space2) {
-                this.space = space2;
+    return `: hover {
+            span {
+                background - color: $ {
+                    props["aria-disabled"] ? "none" : props.theme.colors.grey1
+                };
             }
         }
-    }
-    Schema.prototype.property = {};
-    Schema.prototype.normal = {};
-    Schema.prototype.space = null;
 
-    function merge$1(definitions, space2) {
-        const property = {};
-        const normal = {};
-        let index2 = -1;
-        while (++index2 < definitions.length) {
-            Object.assign(property, definitions[index2].property);
-            Object.assign(normal, definitions[index2].normal);
+        : active {
+            span {
+                background - color: $ {
+                    props["aria-disabled"] ? "none" : props.theme.colors.grey2
+                };
+            }
         }
-        return new Schema(property, normal, space2);
-    }
+    `;
+  }}
 
-    function normalize$2(value) {
-        return value.toLowerCase();
-    }
-    class Info {
-        constructor(property, attribute) {
-            this.property = property;
-            this.attribute = attribute;
+    /* Sets the outer rim color of radio button */
+    :hover {
+        span {
+            border: 1px solid
+                ${(props) => props["aria-disabled"] ? props.theme.colors.grey2 : props.theme.colors.grey4};
         }
     }
-    Info.prototype.space = null;
-    Info.prototype.boolean = false;
-    Info.prototype.booleanish = false;
-    Info.prototype.overloadedBoolean = false;
-    Info.prototype.number = false;
-    Info.prototype.commaSeparated = false;
-    Info.prototype.spaceSeparated = false;
-    Info.prototype.commaOrSpaceSeparated = false;
-    Info.prototype.mustUseProperty = false;
-    Info.prototype.defined = false;
-    let powers = 0;
-    const boolean = increment();
-    const booleanish = increment();
-    const overloadedBoolean = increment();
-    const number$3 = increment();
-    const spaceSeparated = increment();
-    const commaSeparated = increment();
-    const commaOrSpaceSeparated = increment();
 
-    function increment() {
-        return 2 ** ++powers;
-    }
-    const types$1 = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
-        __proto__: null,
-        boolean,
-        booleanish,
-        overloadedBoolean,
-        number: number$3,
-        spaceSeparated,
-        commaSeparated,
-        commaOrSpaceSeparated
-    }, Symbol.toStringTag, {
-        value: "Module"
-    }));
-    const checks = Object.keys(types$1);
-    class DefinedInfo extends Info {
-        constructor(property, attribute, mask, space2) {
-            let index2 = -1;
-            super(property, attribute);
-            mark(this, "space", space2);
-            if (typeof mask === "number") {
-                while (++index2 < checks.length) {
-                    const check = checks[index2];
-                    mark(this, checks[index2], (mask & types$1[check]) === types$1[check]);
-                }
-            }
+    :active {
+        span {
+            border: 1px solid
+                ${(props) => props["aria-disabled"] ? props.theme.colors.grey2 : props.theme.colors.grey4};
         }
     }
-    DefinedInfo.prototype.defined = true;
+`;
+    const RadioButton = styled__default.default.input`
+    position: absolute;
+    opacity: 0;
+`;
+    const StyledCheckmark = styled__default.default.span`
+    position: relative;
+    top: 0;
+    left: 0;
 
-    function mark(values, key, value) {
-        if (value) {
-            values[key] = value;
-        }
+    width: 1rem;
+    height: 1rem;
+
+    background-color: ${(props) => props.disabled ? props.theme.colors.grey1 : props.theme.colors.blue1};
+    border: 1px solid ${(props) => props.disabled ? props.theme.colors.grey2 : props.theme.colors.grey3};
+    border-radius: 50%;
+
+    ::after {
+        content: '';
+        position: relative;
+        display: none;
     }
-    const own$8 = {}.hasOwnProperty;
+`;
 
-    function create$1(definition2) {
-        const property = {};
-        const normal = {};
-        let prop;
-        for (prop in definition2.properties) {
-            if (own$8.call(definition2.properties, prop)) {
-                const value = definition2.properties[prop];
-                const info = new DefinedInfo(
-                    prop,
-                    definition2.transform(definition2.attributes || {}, prop),
-                    value,
-                    definition2.space
-                );
-                if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
-                    info.mustUseProperty = true;
-                }
-                property[prop] = info;
-                normal[normalize$2(prop)] = prop;
-                normal[normalize$2(info.attribute)] = prop;
-            }
+    function RadioGroup$1(props) {
+        const [currentSelected, setCurrentSelected] = React.useState(props.items.findIndex((item) => props.value !== void 0 ? isEqual_1(item.value, props.value) : isEqual_1(item.value, props.initialValue)));
+        const uuid2 = React.useRef(null);
+        if (uuid2.current === null) {
+            uuid2.current = nanoid();
         }
-        return new Schema(property, normal, definition2.space);
+        const onChangeValue = (event2) => {
+            var _a3;
+            const target = event2.target;
+            const chosenIndex = Number(target.value);
+            if (props.value !== void 0) {
+                (_a3 = props.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, props.items[chosenIndex], event2);
+            } else {
+                setCurrentSelected(chosenIndex);
+            }
+        };
+        React.useEffect(() => {
+            setCurrentSelected(props.items.findIndex((item) => props.value !== void 0 ? isEqual_1(item.value, props.value) : isEqual_1(item.value, props.initialValue)));
+        }, [props.value]);
+        return jsxRuntime.exports.jsx(RadioGroupWrapper, {
+            className: props.className,
+            isHorizontal: props.direction === "horizontal",
+            style: props.style,
+            children: props.items.map((item, index2) => {
+                var _a3;
+                return jsxRuntime.exports.jsxs(RadioWrapper, {
+                    "aria-disabled": props.disabled,
+                    isListStyle: props.isListStyle,
+                    children: [jsxRuntime.exports.jsx(RadioButton, {
+                        checked: isEqual_1((_a3 = props.value) === null || _a3 === void 0 ? void 0 : _a3.value, item.value) || currentSelected === index2,
+                        disabled: props.disabled,
+                        name: uuid2.current,
+                        onChange: (e3) => onChangeValue(e3),
+                        type: "radio",
+                        value: index2
+                    }), jsxRuntime.exports.jsx(StyledCheckmark, {
+                        disabled: props.disabled
+                    }), item.label ? item.label : item.value]
+                }, `item-${index2}`);
+            })
+        });
     }
-    const xlink = create$1({
-        space: "xlink",
-        transform(_2, prop) {
-            return "xlink:" + prop.slice(5).toLowerCase();
-        },
-        properties: {
-            xLinkActuate: null,
-            xLinkArcRole: null,
-            xLinkHref: null,
-            xLinkRole: null,
-            xLinkShow: null,
-            xLinkTitle: null,
-            xLinkType: null
+    const {
+        stateChangeTypes
+    } = useCombobox;
+    const ListWrapper = styled__default.default(List)`
+    margin-left: -1px;
+    border-radius: 0 0 0.25rem 0.25rem;
+    box-shadow: ${(props) => props.theme.shadow.light};
+`;
+    const getTextColor = (heading2, selected, theme2) => {
+        if (heading2) {
+            return theme2.colors.text;
         }
-    });
-    const xml = create$1({
-        space: "xml",
-        transform(_2, prop) {
-            return "xml:" + prop.slice(3).toLowerCase();
-        },
-        properties: {
-            xmlLang: null,
-            xmlBase: null,
-            xmlSpace: null
+        if (selected) {
+            return theme2.colors.primary;
         }
-    });
+        return theme2.colors.text;
+    };
+    const ListItemSpan = styled__default.default(ListItem)`
+    cursor: ${(props) => (props === null || props === void 0 ? void 0 : props.heading) ? "text" : "pointer"};
+    user-select: ${(props) => (props === null || props === void 0 ? void 0 : props.heading) ? "text" : "none"};
 
-    function caseSensitiveTransform(attributes2, attribute) {
-        return attribute in attributes2 ? attributes2[attribute] : attribute;
+    display: flex;
+    align-items: center;
+    justify-content: space-between;
+
+    padding: ${(props) => (props === null || props === void 0 ? void 0 : props.heading) || !props.section ? "0 0.7rem" : "0 1.5rem"};
+    padding-right: 0.7rem;
+
+    font-weight: ${(props) => (props === null || props === void 0 ? void 0 : props.heading) ? "bold" : "normal"};
+    color: ${(props) => getTextColor(props === null || props === void 0 ? void 0 : props.heading, props.selected, props.theme)};
+
+    ${(props) => {
+    if (props.heading) {
+      return `
+                :hover {
+                    background-color: ${props.theme.colors.background};
+                    color: ${props.theme.colors.text};
+                }
+            `;
     }
+  }}
+`;
 
-    function caseInsensitiveTransform(attributes2, property) {
-        return caseSensitiveTransform(attributes2, property.toLowerCase());
+    function instanceOfSectionItem(item) {
+        return "items" in item;
     }
-    const xmlns = create$1({
-        space: "xmlns",
-        attributes: {
-            xmlnsxlink: "xmlns:xlink"
-        },
-        transform: caseInsensitiveTransform,
-        properties: {
-            xmlns: null,
-            xmlnsXLink: null
-        }
-    });
-    const aria = create$1({
-        transform(_2, prop) {
-            return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
-        },
-        properties: {
-            ariaActiveDescendant: null,
-            ariaAtomic: booleanish,
-            ariaAutoComplete: null,
-            ariaBusy: booleanish,
-            ariaChecked: booleanish,
-            ariaColCount: number$3,
-            ariaColIndex: number$3,
-            ariaColSpan: number$3,
-            ariaControls: spaceSeparated,
-            ariaCurrent: null,
-            ariaDescribedBy: spaceSeparated,
-            ariaDetails: null,
-            ariaDisabled: booleanish,
-            ariaDropEffect: spaceSeparated,
-            ariaErrorMessage: null,
-            ariaExpanded: booleanish,
-            ariaFlowTo: spaceSeparated,
-            ariaGrabbed: booleanish,
-            ariaHasPopup: null,
-            ariaHidden: booleanish,
-            ariaInvalid: null,
-            ariaKeyShortcuts: null,
-            ariaLabel: null,
-            ariaLabelledBy: spaceSeparated,
-            ariaLevel: number$3,
-            ariaLive: null,
-            ariaModal: booleanish,
-            ariaMultiLine: booleanish,
-            ariaMultiSelectable: booleanish,
-            ariaOrientation: null,
-            ariaOwns: spaceSeparated,
-            ariaPlaceholder: null,
-            ariaPosInSet: number$3,
-            ariaPressed: booleanish,
-            ariaReadOnly: booleanish,
-            ariaRelevant: null,
-            ariaRequired: booleanish,
-            ariaRoleDescription: spaceSeparated,
-            ariaRowCount: number$3,
-            ariaRowIndex: number$3,
-            ariaRowSpan: number$3,
-            ariaSelected: booleanish,
-            ariaSetSize: number$3,
-            ariaSort: null,
-            ariaValueMax: number$3,
-            ariaValueMin: number$3,
-            ariaValueNow: number$3,
-            ariaValueText: null,
-            role: null
-        }
-    });
-    const html$4 = create$1({
-        space: "html",
-        attributes: {
-            acceptcharset: "accept-charset",
-            classname: "class",
-            htmlfor: "for",
-            httpequiv: "http-equiv"
-        },
-        transform: caseInsensitiveTransform,
-        mustUseProperty: ["checked", "multiple", "muted", "selected"],
-        properties: {
-            abbr: null,
-            accept: commaSeparated,
-            acceptCharset: spaceSeparated,
-            accessKey: spaceSeparated,
-            action: null,
-            allow: null,
-            allowFullScreen: boolean,
-            allowPaymentRequest: boolean,
-            allowUserMedia: boolean,
-            alt: null,
-            as: null,
-            async: boolean,
-            autoCapitalize: null,
-            autoComplete: spaceSeparated,
-            autoFocus: boolean,
-            autoPlay: boolean,
-            blocking: spaceSeparated,
-            capture: boolean,
-            charSet: null,
-            checked: boolean,
-            cite: null,
-            className: spaceSeparated,
-            cols: number$3,
-            colSpan: null,
-            content: null,
-            contentEditable: booleanish,
-            controls: boolean,
-            controlsList: spaceSeparated,
-            coords: number$3 | commaSeparated,
-            crossOrigin: null,
-            data: null,
-            dateTime: null,
-            decoding: null,
-            default: boolean,
-            defer: boolean,
-            dir: null,
-            dirName: null,
-            disabled: boolean,
-            download: overloadedBoolean,
-            draggable: booleanish,
-            encType: null,
-            enterKeyHint: null,
-            fetchPriority: null,
-            form: null,
-            formAction: null,
-            formEncType: null,
-            formMethod: null,
-            formNoValidate: boolean,
-            formTarget: null,
-            headers: spaceSeparated,
-            height: number$3,
-            hidden: boolean,
-            high: number$3,
-            href: null,
-            hrefLang: null,
-            htmlFor: spaceSeparated,
-            httpEquiv: spaceSeparated,
-            id: null,
-            imageSizes: null,
-            imageSrcSet: null,
-            inert: boolean,
-            inputMode: null,
-            integrity: null,
-            is: null,
-            isMap: boolean,
-            itemId: null,
-            itemProp: spaceSeparated,
-            itemRef: spaceSeparated,
-            itemScope: boolean,
-            itemType: spaceSeparated,
-            kind: null,
-            label: null,
-            lang: null,
-            language: null,
-            list: null,
-            loading: null,
-            loop: boolean,
-            low: number$3,
-            manifest: null,
-            max: null,
-            maxLength: number$3,
-            media: null,
-            method: null,
-            min: null,
-            minLength: number$3,
-            multiple: boolean,
-            muted: boolean,
-            name: null,
-            nonce: null,
-            noModule: boolean,
-            noValidate: boolean,
-            onAbort: null,
-            onAfterPrint: null,
-            onAuxClick: null,
-            onBeforeMatch: null,
-            onBeforePrint: null,
-            onBeforeToggle: null,
-            onBeforeUnload: null,
-            onBlur: null,
-            onCancel: null,
-            onCanPlay: null,
-            onCanPlayThrough: null,
-            onChange: null,
-            onClick: null,
-            onClose: null,
-            onContextLost: null,
-            onContextMenu: null,
-            onContextRestored: null,
-            onCopy: null,
-            onCueChange: null,
-            onCut: null,
-            onDblClick: null,
-            onDrag: null,
-            onDragEnd: null,
-            onDragEnter: null,
-            onDragExit: null,
-            onDragLeave: null,
-            onDragOver: null,
-            onDragStart: null,
-            onDrop: null,
-            onDurationChange: null,
-            onEmptied: null,
-            onEnded: null,
-            onError: null,
-            onFocus: null,
-            onFormData: null,
-            onHashChange: null,
-            onInput: null,
-            onInvalid: null,
-            onKeyDown: null,
-            onKeyPress: null,
-            onKeyUp: null,
-            onLanguageChange: null,
-            onLoad: null,
-            onLoadedData: null,
-            onLoadedMetadata: null,
-            onLoadEnd: null,
-            onLoadStart: null,
-            onMessage: null,
-            onMessageError: null,
-            onMouseDown: null,
-            onMouseEnter: null,
-            onMouseLeave: null,
-            onMouseMove: null,
-            onMouseOut: null,
-            onMouseOver: null,
-            onMouseUp: null,
-            onOffline: null,
-            onOnline: null,
-            onPageHide: null,
-            onPageShow: null,
-            onPaste: null,
-            onPause: null,
-            onPlay: null,
-            onPlaying: null,
-            onPopState: null,
-            onProgress: null,
-            onRateChange: null,
-            onRejectionHandled: null,
-            onReset: null,
-            onResize: null,
-            onScroll: null,
-            onScrollEnd: null,
-            onSecurityPolicyViolation: null,
-            onSeeked: null,
-            onSeeking: null,
-            onSelect: null,
-            onSlotChange: null,
-            onStalled: null,
-            onStorage: null,
-            onSubmit: null,
-            onSuspend: null,
-            onTimeUpdate: null,
-            onToggle: null,
-            onUnhandledRejection: null,
-            onUnload: null,
-            onVolumeChange: null,
-            onWaiting: null,
-            onWheel: null,
-            open: boolean,
-            optimum: number$3,
-            pattern: null,
-            ping: spaceSeparated,
-            placeholder: null,
-            playsInline: boolean,
-            popover: null,
-            popoverTarget: null,
-            popoverTargetAction: null,
-            poster: null,
-            preload: null,
-            readOnly: boolean,
-            referrerPolicy: null,
-            rel: spaceSeparated,
-            required: boolean,
-            reversed: boolean,
-            rows: number$3,
-            rowSpan: number$3,
-            sandbox: spaceSeparated,
-            scope: null,
-            scoped: boolean,
-            seamless: boolean,
-            selected: boolean,
-            shadowRootDelegatesFocus: boolean,
-            shadowRootMode: null,
-            shape: null,
-            size: number$3,
-            sizes: null,
-            slot: null,
-            span: number$3,
-            spellCheck: booleanish,
-            src: null,
-            srcDoc: null,
-            srcLang: null,
-            srcSet: null,
-            start: number$3,
-            step: null,
-            style: null,
-            tabIndex: number$3,
-            target: null,
-            title: null,
-            translate: null,
-            type: null,
-            typeMustMatch: boolean,
-            useMap: null,
-            value: booleanish,
-            width: number$3,
-            wrap: null,
-            align: null,
-            aLink: null,
-            archive: spaceSeparated,
-            axis: null,
-            background: null,
-            bgColor: null,
-            border: number$3,
-            borderColor: null,
-            bottomMargin: number$3,
-            cellPadding: null,
-            cellSpacing: null,
-            char: null,
-            charOff: null,
-            classId: null,
-            clear: null,
-            code: null,
-            codeBase: null,
-            codeType: null,
-            color: null,
-            compact: boolean,
-            declare: boolean,
-            event: null,
-            face: null,
-            frame: null,
-            frameBorder: null,
-            hSpace: number$3,
-            leftMargin: number$3,
-            link: null,
-            longDesc: null,
-            lowSrc: null,
-            marginHeight: number$3,
-            marginWidth: number$3,
-            noResize: boolean,
-            noHref: boolean,
-            noShade: boolean,
-            noWrap: boolean,
-            object: null,
-            profile: null,
-            prompt: null,
-            rev: null,
-            rightMargin: number$3,
-            rules: null,
-            scheme: null,
-            scrolling: booleanish,
-            standby: null,
-            summary: null,
-            text: null,
-            topMargin: number$3,
-            valueType: null,
-            version: null,
-            vAlign: null,
-            vLink: null,
-            vSpace: number$3,
-            allowTransparency: null,
-            autoCorrect: null,
-            autoSave: null,
-            disablePictureInPicture: boolean,
-            disableRemotePlayback: boolean,
-            prefix: null,
-            property: null,
-            results: number$3,
-            security: null,
-            unselectable: null
-        }
-    });
-    const svg$1 = create$1({
-        space: "svg",
-        attributes: {
-            accentHeight: "accent-height",
-            alignmentBaseline: "alignment-baseline",
-            arabicForm: "arabic-form",
-            baselineShift: "baseline-shift",
-            capHeight: "cap-height",
-            className: "class",
-            clipPath: "clip-path",
-            clipRule: "clip-rule",
-            colorInterpolation: "color-interpolation",
-            colorInterpolationFilters: "color-interpolation-filters",
-            colorProfile: "color-profile",
-            colorRendering: "color-rendering",
-            crossOrigin: "crossorigin",
-            dataType: "datatype",
-            dominantBaseline: "dominant-baseline",
-            enableBackground: "enable-background",
-            fillOpacity: "fill-opacity",
-            fillRule: "fill-rule",
-            floodColor: "flood-color",
-            floodOpacity: "flood-opacity",
-            fontFamily: "font-family",
-            fontSize: "font-size",
-            fontSizeAdjust: "font-size-adjust",
-            fontStretch: "font-stretch",
-            fontStyle: "font-style",
-            fontVariant: "font-variant",
-            fontWeight: "font-weight",
-            glyphName: "glyph-name",
-            glyphOrientationHorizontal: "glyph-orientation-horizontal",
-            glyphOrientationVertical: "glyph-orientation-vertical",
-            hrefLang: "hreflang",
-            horizAdvX: "horiz-adv-x",
-            horizOriginX: "horiz-origin-x",
-            horizOriginY: "horiz-origin-y",
-            imageRendering: "image-rendering",
-            letterSpacing: "letter-spacing",
-            lightingColor: "lighting-color",
-            markerEnd: "marker-end",
-            markerMid: "marker-mid",
-            markerStart: "marker-start",
-            navDown: "nav-down",
-            navDownLeft: "nav-down-left",
-            navDownRight: "nav-down-right",
-            navLeft: "nav-left",
-            navNext: "nav-next",
-            navPrev: "nav-prev",
-            navRight: "nav-right",
-            navUp: "nav-up",
-            navUpLeft: "nav-up-left",
-            navUpRight: "nav-up-right",
-            onAbort: "onabort",
-            onActivate: "onactivate",
-            onAfterPrint: "onafterprint",
-            onBeforePrint: "onbeforeprint",
-            onBegin: "onbegin",
-            onCancel: "oncancel",
-            onCanPlay: "oncanplay",
-            onCanPlayThrough: "oncanplaythrough",
-            onChange: "onchange",
-            onClick: "onclick",
-            onClose: "onclose",
-            onCopy: "oncopy",
-            onCueChange: "oncuechange",
-            onCut: "oncut",
-            onDblClick: "ondblclick",
-            onDrag: "ondrag",
-            onDragEnd: "ondragend",
-            onDragEnter: "ondragenter",
-            onDragExit: "ondragexit",
-            onDragLeave: "ondragleave",
-            onDragOver: "ondragover",
-            onDragStart: "ondragstart",
-            onDrop: "ondrop",
-            onDurationChange: "ondurationchange",
-            onEmptied: "onemptied",
-            onEnd: "onend",
-            onEnded: "onended",
-            onError: "onerror",
-            onFocus: "onfocus",
-            onFocusIn: "onfocusin",
-            onFocusOut: "onfocusout",
-            onHashChange: "onhashchange",
-            onInput: "oninput",
-            onInvalid: "oninvalid",
-            onKeyDown: "onkeydown",
-            onKeyPress: "onkeypress",
-            onKeyUp: "onkeyup",
-            onLoad: "onload",
-            onLoadedData: "onloadeddata",
-            onLoadedMetadata: "onloadedmetadata",
-            onLoadStart: "onloadstart",
-            onMessage: "onmessage",
-            onMouseDown: "onmousedown",
-            onMouseEnter: "onmouseenter",
-            onMouseLeave: "onmouseleave",
-            onMouseMove: "onmousemove",
-            onMouseOut: "onmouseout",
-            onMouseOver: "onmouseover",
-            onMouseUp: "onmouseup",
-            onMouseWheel: "onmousewheel",
-            onOffline: "onoffline",
-            onOnline: "ononline",
-            onPageHide: "onpagehide",
-            onPageShow: "onpageshow",
-            onPaste: "onpaste",
-            onPause: "onpause",
-            onPlay: "onplay",
-            onPlaying: "onplaying",
-            onPopState: "onpopstate",
-            onProgress: "onprogress",
-            onRateChange: "onratechange",
-            onRepeat: "onrepeat",
-            onReset: "onreset",
-            onResize: "onresize",
-            onScroll: "onscroll",
-            onSeeked: "onseeked",
-            onSeeking: "onseeking",
-            onSelect: "onselect",
-            onShow: "onshow",
-            onStalled: "onstalled",
-            onStorage: "onstorage",
-            onSubmit: "onsubmit",
-            onSuspend: "onsuspend",
-            onTimeUpdate: "ontimeupdate",
-            onToggle: "ontoggle",
-            onUnload: "onunload",
-            onVolumeChange: "onvolumechange",
-            onWaiting: "onwaiting",
-            onZoom: "onzoom",
-            overlinePosition: "overline-position",
-            overlineThickness: "overline-thickness",
-            paintOrder: "paint-order",
-            panose1: "panose-1",
-            pointerEvents: "pointer-events",
-            referrerPolicy: "referrerpolicy",
-            renderingIntent: "rendering-intent",
-            shapeRendering: "shape-rendering",
-            stopColor: "stop-color",
-            stopOpacity: "stop-opacity",
-            strikethroughPosition: "strikethrough-position",
-            strikethroughThickness: "strikethrough-thickness",
-            strokeDashArray: "stroke-dasharray",
-            strokeDashOffset: "stroke-dashoffset",
-            strokeLineCap: "stroke-linecap",
-            strokeLineJoin: "stroke-linejoin",
-            strokeMiterLimit: "stroke-miterlimit",
-            strokeOpacity: "stroke-opacity",
-            strokeWidth: "stroke-width",
-            tabIndex: "tabindex",
-            textAnchor: "text-anchor",
-            textDecoration: "text-decoration",
-            textRendering: "text-rendering",
-            transformOrigin: "transform-origin",
-            typeOf: "typeof",
-            underlinePosition: "underline-position",
-            underlineThickness: "underline-thickness",
-            unicodeBidi: "unicode-bidi",
-            unicodeRange: "unicode-range",
-            unitsPerEm: "units-per-em",
-            vAlphabetic: "v-alphabetic",
-            vHanging: "v-hanging",
-            vIdeographic: "v-ideographic",
-            vMathematical: "v-mathematical",
-            vectorEffect: "vector-effect",
-            vertAdvY: "vert-adv-y",
-            vertOriginX: "vert-origin-x",
-            vertOriginY: "vert-origin-y",
-            wordSpacing: "word-spacing",
-            writingMode: "writing-mode",
-            xHeight: "x-height",
-            playbackOrder: "playbackorder",
-            timelineBegin: "timelinebegin"
-        },
-        transform: caseSensitiveTransform,
-        properties: {
-            about: commaOrSpaceSeparated,
-            accentHeight: number$3,
-            accumulate: null,
-            additive: null,
-            alignmentBaseline: null,
-            alphabetic: number$3,
-            amplitude: number$3,
-            arabicForm: null,
-            ascent: number$3,
-            attributeName: null,
-            attributeType: null,
-            azimuth: number$3,
-            bandwidth: null,
-            baselineShift: null,
-            baseFrequency: null,
-            baseProfile: null,
-            bbox: null,
-            begin: null,
-            bias: number$3,
-            by: null,
-            calcMode: null,
-            capHeight: number$3,
-            className: spaceSeparated,
-            clip: null,
-            clipPath: null,
-            clipPathUnits: null,
-            clipRule: null,
-            color: null,
-            colorInterpolation: null,
-            colorInterpolationFilters: null,
-            colorProfile: null,
-            colorRendering: null,
-            content: null,
-            contentScriptType: null,
-            contentStyleType: null,
-            crossOrigin: null,
-            cursor: null,
-            cx: null,
-            cy: null,
-            d: null,
-            dataType: null,
-            defaultAction: null,
-            descent: number$3,
-            diffuseConstant: number$3,
-            direction: null,
-            display: null,
-            dur: null,
-            divisor: number$3,
-            dominantBaseline: null,
-            download: boolean,
-            dx: null,
-            dy: null,
-            edgeMode: null,
-            editable: null,
-            elevation: number$3,
-            enableBackground: null,
-            end: null,
-            event: null,
-            exponent: number$3,
-            externalResourcesRequired: null,
-            fill: null,
-            fillOpacity: number$3,
-            fillRule: null,
-            filter: null,
-            filterRes: null,
-            filterUnits: null,
-            floodColor: null,
-            floodOpacity: null,
-            focusable: null,
-            focusHighlight: null,
-            fontFamily: null,
-            fontSize: null,
-            fontSizeAdjust: null,
-            fontStretch: null,
-            fontStyle: null,
-            fontVariant: null,
-            fontWeight: null,
-            format: null,
-            fr: null,
-            from: null,
-            fx: null,
-            fy: null,
-            g1: commaSeparated,
-            g2: commaSeparated,
-            glyphName: commaSeparated,
-            glyphOrientationHorizontal: null,
-            glyphOrientationVertical: null,
-            glyphRef: null,
-            gradientTransform: null,
-            gradientUnits: null,
-            handler: null,
-            hanging: number$3,
-            hatchContentUnits: null,
-            hatchUnits: null,
-            height: null,
-            href: null,
-            hrefLang: null,
-            horizAdvX: number$3,
-            horizOriginX: number$3,
-            horizOriginY: number$3,
-            id: null,
-            ideographic: number$3,
-            imageRendering: null,
-            initialVisibility: null,
-            in: null,
-            in2: null,
-            intercept: number$3,
-            k: number$3,
-            k1: number$3,
-            k2: number$3,
-            k3: number$3,
-            k4: number$3,
-            kernelMatrix: commaOrSpaceSeparated,
-            kernelUnitLength: null,
-            keyPoints: null,
-            keySplines: null,
-            keyTimes: null,
-            kerning: null,
-            lang: null,
-            lengthAdjust: null,
-            letterSpacing: null,
-            lightingColor: null,
-            limitingConeAngle: number$3,
-            local: null,
-            markerEnd: null,
-            markerMid: null,
-            markerStart: null,
-            markerHeight: null,
-            markerUnits: null,
-            markerWidth: null,
-            mask: null,
-            maskContentUnits: null,
-            maskUnits: null,
-            mathematical: null,
-            max: null,
-            media: null,
-            mediaCharacterEncoding: null,
-            mediaContentEncodings: null,
-            mediaSize: number$3,
-            mediaTime: null,
-            method: null,
-            min: null,
-            mode: null,
-            name: null,
-            navDown: null,
-            navDownLeft: null,
-            navDownRight: null,
-            navLeft: null,
-            navNext: null,
-            navPrev: null,
-            navRight: null,
-            navUp: null,
-            navUpLeft: null,
-            navUpRight: null,
-            numOctaves: null,
-            observer: null,
-            offset: null,
-            onAbort: null,
-            onActivate: null,
-            onAfterPrint: null,
-            onBeforePrint: null,
-            onBegin: null,
-            onCancel: null,
-            onCanPlay: null,
-            onCanPlayThrough: null,
-            onChange: null,
-            onClick: null,
-            onClose: null,
-            onCopy: null,
-            onCueChange: null,
-            onCut: null,
-            onDblClick: null,
-            onDrag: null,
-            onDragEnd: null,
-            onDragEnter: null,
-            onDragExit: null,
-            onDragLeave: null,
-            onDragOver: null,
-            onDragStart: null,
-            onDrop: null,
-            onDurationChange: null,
-            onEmptied: null,
-            onEnd: null,
-            onEnded: null,
-            onError: null,
-            onFocus: null,
-            onFocusIn: null,
-            onFocusOut: null,
-            onHashChange: null,
-            onInput: null,
-            onInvalid: null,
-            onKeyDown: null,
-            onKeyPress: null,
-            onKeyUp: null,
-            onLoad: null,
-            onLoadedData: null,
-            onLoadedMetadata: null,
-            onLoadStart: null,
-            onMessage: null,
-            onMouseDown: null,
-            onMouseEnter: null,
-            onMouseLeave: null,
-            onMouseMove: null,
-            onMouseOut: null,
-            onMouseOver: null,
-            onMouseUp: null,
-            onMouseWheel: null,
-            onOffline: null,
-            onOnline: null,
-            onPageHide: null,
-            onPageShow: null,
-            onPaste: null,
-            onPause: null,
-            onPlay: null,
-            onPlaying: null,
-            onPopState: null,
-            onProgress: null,
-            onRateChange: null,
-            onRepeat: null,
-            onReset: null,
-            onResize: null,
-            onScroll: null,
-            onSeeked: null,
-            onSeeking: null,
-            onSelect: null,
-            onShow: null,
-            onStalled: null,
-            onStorage: null,
-            onSubmit: null,
-            onSuspend: null,
-            onTimeUpdate: null,
-            onToggle: null,
-            onUnload: null,
-            onVolumeChange: null,
-            onWaiting: null,
-            onZoom: null,
-            opacity: null,
-            operator: null,
-            order: null,
-            orient: null,
-            orientation: null,
-            origin: null,
-            overflow: null,
-            overlay: null,
-            overlinePosition: number$3,
-            overlineThickness: number$3,
-            paintOrder: null,
-            panose1: null,
-            path: null,
-            pathLength: number$3,
-            patternContentUnits: null,
-            patternTransform: null,
-            patternUnits: null,
-            phase: null,
-            ping: spaceSeparated,
-            pitch: null,
-            playbackOrder: null,
-            pointerEvents: null,
-            points: null,
-            pointsAtX: number$3,
-            pointsAtY: number$3,
-            pointsAtZ: number$3,
-            preserveAlpha: null,
-            preserveAspectRatio: null,
-            primitiveUnits: null,
-            propagate: null,
-            property: commaOrSpaceSeparated,
-            r: null,
-            radius: null,
-            referrerPolicy: null,
-            refX: null,
-            refY: null,
-            rel: commaOrSpaceSeparated,
-            rev: commaOrSpaceSeparated,
-            renderingIntent: null,
-            repeatCount: null,
-            repeatDur: null,
-            requiredExtensions: commaOrSpaceSeparated,
-            requiredFeatures: commaOrSpaceSeparated,
-            requiredFonts: commaOrSpaceSeparated,
-            requiredFormats: commaOrSpaceSeparated,
-            resource: null,
-            restart: null,
-            result: null,
-            rotate: null,
-            rx: null,
-            ry: null,
-            scale: null,
-            seed: null,
-            shapeRendering: null,
-            side: null,
-            slope: null,
-            snapshotTime: null,
-            specularConstant: number$3,
-            specularExponent: number$3,
-            spreadMethod: null,
-            spacing: null,
-            startOffset: null,
-            stdDeviation: null,
-            stemh: null,
-            stemv: null,
-            stitchTiles: null,
-            stopColor: null,
-            stopOpacity: null,
-            strikethroughPosition: number$3,
-            strikethroughThickness: number$3,
-            string: null,
-            stroke: null,
-            strokeDashArray: commaOrSpaceSeparated,
-            strokeDashOffset: null,
-            strokeLineCap: null,
-            strokeLineJoin: null,
-            strokeMiterLimit: number$3,
-            strokeOpacity: number$3,
-            strokeWidth: null,
-            style: null,
-            surfaceScale: number$3,
-            syncBehavior: null,
-            syncBehaviorDefault: null,
-            syncMaster: null,
-            syncTolerance: null,
-            syncToleranceDefault: null,
-            systemLanguage: commaOrSpaceSeparated,
-            tabIndex: number$3,
-            tableValues: null,
-            target: null,
-            targetX: number$3,
-            targetY: number$3,
-            textAnchor: null,
-            textDecoration: null,
-            textRendering: null,
-            textLength: null,
-            timelineBegin: null,
-            title: null,
-            transformBehavior: null,
-            type: null,
-            typeOf: commaOrSpaceSeparated,
-            to: null,
-            transform: null,
-            transformOrigin: null,
-            u1: null,
-            u2: null,
-            underlinePosition: number$3,
-            underlineThickness: number$3,
-            unicode: null,
-            unicodeBidi: null,
-            unicodeRange: null,
-            unitsPerEm: number$3,
-            values: null,
-            vAlphabetic: number$3,
-            vMathematical: number$3,
-            vectorEffect: null,
-            vHanging: number$3,
-            vIdeographic: number$3,
-            version: null,
-            vertAdvY: number$3,
-            vertOriginX: number$3,
-            vertOriginY: number$3,
-            viewBox: null,
-            viewTarget: null,
-            visibility: null,
-            width: null,
-            widths: null,
-            wordSpacing: null,
-            writingMode: null,
-            x: null,
-            x1: null,
-            x2: null,
-            xChannelSelector: null,
-            xHeight: number$3,
-            y: null,
-            y1: null,
-            y2: null,
-            yChannelSelector: null,
-            z: null,
-            zoomAndPan: null
-        }
-    });
-    const valid$1 = /^data[-\w.:]+$/i;
-    const dash = /-[a-z]/g;
-    const cap$1 = /[A-Z]/g;
 
-    function find$3(schema, value) {
-        const normal = normalize$2(value);
-        let prop = value;
-        let Type2 = Info;
-        if (normal in schema.normal) {
-            return schema.property[schema.normal[normal]];
-        }
-        if (normal.length > 4 && normal.slice(0, 4) === "data" && valid$1.test(value)) {
-            if (value.charAt(4) === "-") {
-                const rest = value.slice(5).replace(dash, camelcase);
-                prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
-            } else {
-                const rest = value.slice(4);
-                if (!dash.test(rest)) {
-                    let dashes = rest.replace(cap$1, kebab);
-                    if (dashes.charAt(0) !== "-") {
-                        dashes = "-" + dashes;
+    function unpackSectionedList(listItems) {
+        return listItems.reduce((acc, item) => {
+            if (instanceOfSectionItem(item)) {
+                const sectionHeading = {
+                    heading: true,
+                    label: item.label,
+                    value: item.label
+                };
+                const sectionItems = item.items.map((sectionItem) => Object.assign(Object.assign({}, sectionItem), {
+                    section: item.label
+                }));
+                return [...acc, sectionHeading, ...sectionItems];
+            }
+            return [...acc, item];
+        }, []);
+    }
+
+    function SectionedList(props) {
+        var _a3, _b, _c, _d;
+        const theme2 = useClTheme();
+        const referenceElement = React.useRef(null);
+        const popperElement = React.useRef(null);
+        const {
+            styles: styles2,
+            attributes: attributes2,
+            update: update2
+        } = usePopper$1(referenceElement.current, popperElement.current, {
+            modifiers: [sameWidthModifier],
+            placement: "bottom-start"
+        });
+        const unpackedItems = React.useMemo(() => unpackSectionedList(props.items), [props.items]);
+        const [pendingHighlight, setPendingHighlight] = React.useState(null);
+        const [items, setItems] = React.useState(unpackedItems);
+        const [inputValue, setInputValue] = React.useState((_b = (_a3 = props.selectedItem) === null || _a3 === void 0 ? void 0 : _a3.label) !== null && _b !== void 0 ? _b : "");
+        const {
+            selectedItem,
+            isOpen,
+            getMenuProps,
+            getInputProps,
+            getToggleButtonProps,
+            highlightedIndex,
+            getItemProps,
+            setHighlightedIndex
+        } = useCombobox(Object.assign({
+            initialIsOpen: false,
+            initialSelectedItem: (_c = props.initialValue) !== null && _c !== void 0 ? _c : props.selectedItem,
+            itemToString: (item) => item ? item.label : "",
+            items,
+            onInputValueChange: (change) => {
+                setInputValue(change.inputValue);
+                if (!change.inputValue) {
+                    setItems(unpackedItems);
+                    return;
+                }
+                const counts = {};
+                const filteredItems = unpackedItems.filter((item) => {
+                    const lowercaseInput = change.inputValue.toLowerCase();
+                    const lowercaseLabel = item.label.toLowerCase();
+                    if (!item.heading && lowercaseLabel.includes(lowercaseInput)) {
+                        counts[item.label] = counts[item.label] ? counts[item.label] + 1 : 1;
+                        return true;
                     }
-                    value = "data" + dashes;
+                    if (item.heading) {
+                        const listSections = props.items.filter((propItem) => propItem.items.find((subItem) => subItem.label.toLowerCase().includes(lowercaseInput)));
+                        if (listSections.length) {
+                            listSections.forEach((section) => {
+                                counts[section.label] = counts[section.label] ? counts[section.label] + 1 : 1;
+                            });
+                            return true;
+                        }
+                    }
+                    return false;
+                });
+                setItems(filteredItems.filter((item) => counts[item.label] > 0));
+            },
+            onSelectedItemChange: (changes) => {
+                var _a4, _b2;
+                if (props.onSelect) {
+                    if (props.selectedItem && ((_a4 = changes.selectedItem) === null || _a4 === void 0 ? void 0 : _a4.value) !== ((_b2 = props.selectedItem) === null || _b2 === void 0 ? void 0 : _b2.value) || !props.selectedItem) {
+                        props.onSelect(changes.selectedItem);
+                    }
+                }
+            },
+            stateReducer: (state, {
+                changes,
+                type: type2
+            }) => {
+                var _a4, _b2, _c2;
+                if (type2 === stateChangeTypes.ControlledPropUpdatedSelectedItem) {
+                    return Object.assign(Object.assign({}, changes), {
+                        inputValue: ""
+                    });
+                }
+                if (type2 === stateChangeTypes.InputFocus || type2 === stateChangeTypes.ToggleButtonClick && changes.isOpen) {
+                    setPendingHighlight(changes.selectedItem ? props.items.findIndex((i2) => i2.value === changes.selectedItem.value) : 0);
+                    return Object.assign(Object.assign({}, changes), {
+                        inputValue: ""
+                    });
+                }
+                if ([
+                        stateChangeTypes.InputKeyDownEnter,
+                        stateChangeTypes.ItemClick,
+                        stateChangeTypes.InputBlur,
+                        stateChangeTypes.InputKeyDownEscape,
+                        stateChangeTypes.ToggleButtonClick
+                    ].includes(type2)) {
+                    return Object.assign(Object.assign({}, changes), {
+                        inputValue: ((_a4 = changes.selectedItem) === null || _a4 === void 0 ? void 0 : _a4.label) || ""
+                    });
+                }
+                if (type2 === stateChangeTypes.InputKeyDownArrowUp && ((_b2 = items[changes.highlightedIndex]) === null || _b2 === void 0 ? void 0 : _b2.heading)) {
+                    return Object.assign(Object.assign({}, changes), {
+                        highlightedIndex: changes.highlightedIndex - 1 < 0 ? items.length - 1 : changes.highlightedIndex - 1
+                    });
+                }
+                if (type2 === stateChangeTypes.InputKeyDownArrowDown && ((_c2 = items[changes.highlightedIndex]) === null || _c2 === void 0 ? void 0 : _c2.heading)) {
+                    return Object.assign(Object.assign({}, changes), {
+                        highlightedIndex: changes.highlightedIndex + 1 === items.length ? 0 : changes.highlightedIndex + 1
+                    });
                 }
+                return changes;
             }
-            Type2 = DefinedInfo;
-        }
-        return new Type2(prop, value);
+        }, "selectedItem" in props && {
+            selectedItem: props.selectedItem
+        }));
+        React.useEffect(() => {
+            if (isOpen && pendingHighlight !== null) {
+                setHighlightedIndex(pendingHighlight);
+                setPendingHighlight(null);
+            }
+        }, [isOpen, pendingHighlight, setHighlightedIndex]);
+        React.useEffect(() => {
+            if (props.selectedItem === null) {
+                setInputValue("");
+            }
+        }, [props.selectedItem]);
+        React.useEffect(() => {
+            if (isOpen && update2) {
+                update2();
+            }
+        }, [isOpen, update2]);
+        const menuProps = getMenuProps();
+        const setMenuRef = menuProps.ref;
+        delete menuProps.ref;
+        const setMenuReference = (value) => {
+            setMenuRef(value);
+            popperElement.current = value;
+        };
+        return jsxRuntime.exports.jsxs(Wrapper$a, {
+            className: props.className,
+            isDisabled: props.disabled,
+            isErrored: false,
+            isOpen,
+            style: props.style,
+            children: [jsxRuntime.exports.jsxs(InputWrapper$4, {
+                disabled: props.disabled,
+                isOpen,
+                ref: referenceElement,
+                children: [jsxRuntime.exports.jsx(Input$2, Object.assign({}, getInputProps({
+                    value: inputValue
+                }))), jsxRuntime.exports.jsx(ChevronButton$1, Object.assign({}, getToggleButtonProps(), {
+                    children: jsxRuntime.exports.jsx(Chevron$2, {
+                        disabled: props.disabled,
+                        isOpen
+                    })
+                }))]
+            }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsxs(ListWrapper, Object.assign({}, menuProps, attributes2.popper, {
+                isOpen,
+                ref: setMenuReference,
+                style: Object.assign(Object.assign({}, styles2.popper), {
+                    width: parseFloat((_d = styles2.popper) === null || _d === void 0 ? void 0 : _d.width) + 2,
+                    zIndex: 9999
+                }),
+                children: [items.length > 0 && items.map((item, index2) => {
+                    const itemProps = getItemProps({
+                        index: index2,
+                        item
+                    });
+                    if (item.heading) {
+                        delete itemProps.onClick;
+                    }
+                    return React.createElement(
+                        ListItemSpan,
+                        Object.assign({}, itemProps, {
+                            heading: item.heading,
+                            hovered: index2 === highlightedIndex,
+                            key: `item-${index2}`,
+                            section: item.section,
+                            selected: item.value === (selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.value),
+                            title: item.label
+                        }),
+                        item.label || item.section,
+                        item.badge && jsxRuntime.exports.jsx(Badge, {
+                            color: item.badge.color || theme2.colors.primary,
+                            children: item.badge.label
+                        })
+                    );
+                }), items.length === 0 && jsxRuntime.exports.jsx(NoItemsLabel$1, {
+                    children: "No Items"
+                })]
+            })), document.body)]
+        });
     }
+    var toNumber$1 = toNumber_1;
+    var INFINITY$2 = 1 / 0,
+        MAX_INTEGER = 17976931348623157e292;
 
-    function kebab($0) {
-        return "-" + $0.toLowerCase();
+    function toFinite$1(value) {
+        if (!value) {
+            return value === 0 ? value : 0;
+        }
+        value = toNumber$1(value);
+        if (value === INFINITY$2 || value === -INFINITY$2) {
+            var sign2 = value < 0 ? -1 : 1;
+            return sign2 * MAX_INTEGER;
+        }
+        return value === value ? value : 0;
     }
+    var toFinite_1 = toFinite$1;
+    var toFinite = toFinite_1;
 
-    function camelcase($0) {
-        return $0.charAt(1).toUpperCase();
+    function toInteger$1(value) {
+        var result = toFinite(value),
+            remainder = result % 1;
+        return result === result ? remainder ? result - remainder : result : 0;
     }
-    const hastToReact = {
-        classId: "classID",
-        dataType: "datatype",
-        itemId: "itemID",
-        strokeDashArray: "strokeDasharray",
-        strokeDashOffset: "strokeDashoffset",
-        strokeLineCap: "strokeLinecap",
-        strokeLineJoin: "strokeLinejoin",
-        strokeMiterLimit: "strokeMiterlimit",
-        typeOf: "typeof",
-        xLinkActuate: "xlinkActuate",
-        xLinkArcRole: "xlinkArcrole",
-        xLinkHref: "xlinkHref",
-        xLinkRole: "xlinkRole",
-        xLinkShow: "xlinkShow",
-        xLinkTitle: "xlinkTitle",
-        xLinkType: "xlinkType",
-        xmlnsXLink: "xmlnsXlink"
-    };
-    const html$3 = merge$1([xml, xlink, xmlns, aria, html$4], "html");
-    const svg = merge$1([xml, xlink, xmlns, aria, svg$1], "svg");
+    var toInteger_1 = toInteger$1;
 
-    function parse$6(value) {
-        const input = String(value || "").trim();
-        return input ? input.split(/[ \t\n\r\f]+/g) : [];
+    function arrayMap$2(array2, iteratee) {
+        var index2 = -1,
+            length = array2 == null ? 0 : array2.length,
+            result = Array(length);
+        while (++index2 < length) {
+            result[index2] = iteratee(array2[index2], index2, array2);
+        }
+        return result;
     }
+    var _arrayMap = arrayMap$2;
+    var Symbol$2 = _Symbol,
+        arrayMap$1 = _arrayMap,
+        isArray$9 = isArray_1,
+        isSymbol$4 = isSymbol_1;
+    var INFINITY$1 = 1 / 0;
+    var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0,
+        symbolToString$1 = symbolProto$1 ? symbolProto$1.toString : void 0;
 
-    function stringify$2(values) {
-        return values.join(" ").trim();
-    }
-    var cjs = {};
-    var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
-    var NEWLINE_REGEX = /\n/g;
-    var WHITESPACE_REGEX = /^\s*/;
-    var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
-    var COLON_REGEX = /^:\s*/;
-    var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
-    var SEMICOLON_REGEX = /^[;\s]*/;
-    var TRIM_REGEX = /^\s+|\s+$/g;
-    var NEWLINE = "\n";
-    var FORWARD_SLASH = "/";
-    var ASTERISK = "*";
-    var EMPTY_STRING = "";
-    var TYPE_COMMENT = "comment";
-    var TYPE_DECLARATION = "declaration";
-    var inlineStyleParser = function(style2, options) {
-        if (typeof style2 !== "string") {
-            throw new TypeError("First argument must be a string");
+    function baseToString$1(value) {
+        if (typeof value == "string") {
+            return value;
         }
-        if (!style2)
-            return [];
-        options = options || {};
-        var lineno = 1;
-        var column = 1;
-
-        function updatePosition(str) {
-            var lines = str.match(NEWLINE_REGEX);
-            if (lines)
-                lineno += lines.length;
-            var i2 = str.lastIndexOf(NEWLINE);
-            column = ~i2 ? str.length - i2 : column + str.length;
+        if (isArray$9(value)) {
+            return arrayMap$1(value, baseToString$1) + "";
         }
-
-        function position2() {
-            var start2 = {
-                line: lineno,
-                column
-            };
-            return function(node2) {
-                node2.position = new Position(start2);
-                whitespace2();
-                return node2;
-            };
+        if (isSymbol$4(value)) {
+            return symbolToString$1 ? symbolToString$1.call(value) : "";
         }
+        var result = value + "";
+        return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
+    }
+    var _baseToString = baseToString$1;
+    var baseToString = _baseToString;
 
-        function Position(start2) {
-            this.start = start2;
-            this.end = {
-                line: lineno,
-                column
-            };
-            this.source = options.source;
-        }
-        Position.prototype.content = style2;
+    function toString$4(value) {
+        return value == null ? "" : baseToString(value);
+    }
+    var toString_1 = toString$4;
+    var root$2 = _root,
+        toInteger = toInteger_1,
+        toNumber = toNumber_1,
+        toString$3 = toString_1;
+    var nativeIsFinite = root$2.isFinite,
+        nativeMin = Math.min;
 
-        function error2(msg) {
-            var err = new Error(
-                options.source + ":" + lineno + ":" + column + ": " + msg
-            );
-            err.reason = msg;
-            err.filename = options.source;
-            err.line = lineno;
-            err.column = column;
-            err.source = style2;
-            if (options.silent)
-            ;
-            else {
-                throw err;
+    function createRound$1(methodName) {
+        var func = Math[methodName];
+        return function(number2, precision2) {
+            number2 = toNumber(number2);
+            precision2 = precision2 == null ? 0 : nativeMin(toInteger(precision2), 292);
+            if (precision2 && nativeIsFinite(number2)) {
+                var pair2 = (toString$3(number2) + "e").split("e"),
+                    value = func(pair2[0] + "e" + (+pair2[1] + precision2));
+                pair2 = (toString$3(value) + "e").split("e");
+                return +(pair2[0] + "e" + (+pair2[1] - precision2));
             }
-        }
+            return func(number2);
+        };
+    }
+    var _createRound = createRound$1;
+    var createRound = _createRound;
+    var round$1 = createRound("round");
+    var round_1 = round$1;
 
-        function match2(re2) {
-            var m2 = re2.exec(style2);
-            if (!m2)
-                return;
-            var str = m2[0];
-            updatePosition(str);
-            style2 = style2.slice(str.length);
-            return m2;
+    function _classCallCheck$f(instance2, Constructor) {
+        if (!(instance2 instanceof Constructor)) {
+            throw new TypeError("Cannot call a class as a function");
         }
+    }
 
-        function whitespace2() {
-            match2(WHITESPACE_REGEX);
+    function _defineProperties$f(target, props) {
+        for (var i2 = 0; i2 < props.length; i2++) {
+            var descriptor = props[i2];
+            descriptor.enumerable = descriptor.enumerable || false;
+            descriptor.configurable = true;
+            if ("value" in descriptor)
+                descriptor.writable = true;
+            Object.defineProperty(target, descriptor.key, descriptor);
         }
+    }
 
-        function comments(rules) {
-            var c2;
-            rules = rules || [];
-            while (c2 = comment2()) {
-                if (c2 !== false) {
-                    rules.push(c2);
-                }
-            }
-            return rules;
-        }
+    function _createClass$f(Constructor, protoProps, staticProps) {
+        if (protoProps)
+            _defineProperties$f(Constructor.prototype, protoProps);
+        if (staticProps)
+            _defineProperties$f(Constructor, staticProps);
+        return Constructor;
+    }
 
-        function comment2() {
-            var pos = position2();
-            if (FORWARD_SLASH != style2.charAt(0) || ASTERISK != style2.charAt(1))
-                return;
-            var i2 = 2;
-            while (EMPTY_STRING != style2.charAt(i2) && (ASTERISK != style2.charAt(i2) || FORWARD_SLASH != style2.charAt(i2 + 1))) {
-                ++i2;
-            }
-            i2 += 2;
-            if (EMPTY_STRING === style2.charAt(i2 - 1)) {
-                return error2("End of comment missing");
-            }
-            var str = style2.slice(2, i2 - 2);
-            column += 2;
-            updatePosition(str);
-            style2 = style2.slice(i2);
-            column += 2;
-            return pos({
-                type: TYPE_COMMENT,
-                comment: str
+    function _defineProperty$m(obj, key, value) {
+        if (key in obj) {
+            Object.defineProperty(obj, key, {
+                value,
+                enumerable: true,
+                configurable: true,
+                writable: true
             });
+        } else {
+            obj[key] = value;
         }
+        return obj;
+    }
 
-        function declaration() {
-            var pos = position2();
-            var prop = match2(PROPERTY_REGEX);
-            if (!prop)
-                return;
-            comment2();
-            if (!match2(COLON_REGEX))
-                return error2("property missing ':'");
-            var val = match2(VALUE_REGEX);
-            var ret = pos({
-                type: TYPE_DECLARATION,
-                property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
-                value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
-            });
-            match2(SEMICOLON_REGEX);
-            return ret;
+    function ownKeys$5(object2, enumerableOnly) {
+        var keys2 = Object.keys(object2);
+        if (Object.getOwnPropertySymbols) {
+            var symbols = Object.getOwnPropertySymbols(object2);
+            if (enumerableOnly)
+                symbols = symbols.filter(function(sym) {
+                    return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
+                });
+            keys2.push.apply(keys2, symbols);
         }
+        return keys2;
+    }
 
-        function declarations() {
-            var decls = [];
-            comments(decls);
-            var decl;
-            while (decl = declaration()) {
-                if (decl !== false) {
-                    decls.push(decl);
-                    comments(decls);
-                }
+    function _objectSpread2(target) {
+        for (var i2 = 1; i2 < arguments.length; i2++) {
+            var source = arguments[i2] != null ? arguments[i2] : {};
+            if (i2 % 2) {
+                ownKeys$5(Object(source), true).forEach(function(key) {
+                    _defineProperty$m(target, key, source[key]);
+                });
+            } else if (Object.getOwnPropertyDescriptors) {
+                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+            } else {
+                ownKeys$5(Object(source)).forEach(function(key) {
+                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
+                });
             }
-            return decls;
         }
-        whitespace2();
-        return declarations();
-    };
-
-    function trim(str) {
-        return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
+        return target;
     }
-    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
-        return mod && mod.__esModule ? mod : {
-            "default": mod
-        };
-    };
-    Object.defineProperty(cjs, "__esModule", {
-        value: true
-    });
-    var inline_style_parser_1 = __importDefault(inlineStyleParser);
 
-    function StyleToObject(style2, iterator2) {
-        var styleObject = null;
-        if (!style2 || typeof style2 !== "string") {
-            return styleObject;
+    function _inherits(subClass, superClass) {
+        if (typeof superClass !== "function" && superClass !== null) {
+            throw new TypeError("Super expression must either be null or a function");
         }
-        var declarations = (0, inline_style_parser_1.default)(style2);
-        var hasIterator = typeof iterator2 === "function";
-        declarations.forEach(function(declaration) {
-            if (declaration.type !== "declaration") {
-                return;
-            }
-            var property = declaration.property,
-                value = declaration.value;
-            if (hasIterator) {
-                iterator2(property, value, declaration);
-            } else if (value) {
-                styleObject = styleObject || {};
-                styleObject[property] = value;
+        subClass.prototype = Object.create(superClass && superClass.prototype, {
+            constructor: {
+                value: subClass,
+                writable: true,
+                configurable: true
             }
         });
-        return styleObject;
+        if (superClass)
+            _setPrototypeOf$1(subClass, superClass);
     }
-    var _default$1 = cjs.default = StyleToObject;
-    const styleToObject = _default$1.default || _default$1;
-    const pointEnd$1 = point$4("end");
-    const pointStart$1 = point$4("start");
 
-    function point$4(type2) {
-        return point2;
+    function _getPrototypeOf$1(o2) {
+        _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
+            return o3.__proto__ || Object.getPrototypeOf(o3);
+        };
+        return _getPrototypeOf$1(o2);
+    }
 
-        function point2(node2) {
-            const point3 = node2 && node2.position && node2.position[type2] || {};
-            if (typeof point3.line === "number" && point3.line > 0 && typeof point3.column === "number" && point3.column > 0) {
-                return {
-                    line: point3.line,
-                    column: point3.column,
-                    offset: typeof point3.offset === "number" && point3.offset > -1 ? point3.offset : void 0
-                };
-            }
-        }
+    function _setPrototypeOf$1(o2, p2) {
+        _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
+            o3.__proto__ = p3;
+            return o3;
+        };
+        return _setPrototypeOf$1(o2, p2);
     }
 
-    function position$3(node2) {
-        const start2 = pointStart$1(node2);
-        const end2 = pointEnd$1(node2);
-        if (start2 && end2) {
-            return {
-                start: start2,
-                end: end2
-            };
+    function _isNativeReflectConstruct$1() {
+        if (typeof Reflect === "undefined" || !Reflect.construct)
+            return false;
+        if (Reflect.construct.sham)
+            return false;
+        if (typeof Proxy === "function")
+            return true;
+        try {
+            Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
+            return true;
+        } catch (e3) {
+            return false;
         }
     }
 
-    function stringifyPosition(value) {
-        if (!value || typeof value !== "object") {
-            return "";
-        }
-        if ("position" in value || "type" in value) {
-            return position$2(value.position);
-        }
-        if ("start" in value || "end" in value) {
-            return position$2(value);
+    function _assertThisInitialized$1(self2) {
+        if (self2 === void 0) {
+            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
         }
-        if ("line" in value || "column" in value) {
-            return point$3(value);
+        return self2;
+    }
+
+    function _possibleConstructorReturn(self2, call2) {
+        if (call2 && (typeof call2 === "object" || typeof call2 === "function")) {
+            return call2;
         }
-        return "";
+        return _assertThisInitialized$1(self2);
     }
 
-    function point$3(point2) {
-        return index$2(point2 && point2.line) + ":" + index$2(point2 && point2.column);
+    function _createSuper(Derived) {
+        var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
+        return function _createSuperInternal() {
+            var Super = _getPrototypeOf$1(Derived),
+                result;
+            if (hasNativeReflectConstruct) {
+                var NewTarget = _getPrototypeOf$1(this).constructor;
+                result = Reflect.construct(Super, arguments, NewTarget);
+            } else {
+                result = Super.apply(this, arguments);
+            }
+            return _possibleConstructorReturn(this, result);
+        };
     }
 
-    function position$2(pos) {
-        return point$3(pos && pos.start) + "-" + point$3(pos && pos.end);
+    function _slicedToArray$7(arr, i2) {
+        return _arrayWithHoles$7(arr) || _iterableToArrayLimit$7(arr, i2) || _unsupportedIterableToArray$8(arr, i2) || _nonIterableRest$7();
     }
 
-    function index$2(value) {
-        return value && typeof value === "number" ? value : 1;
+    function _toConsumableArray$1(arr) {
+        return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$8(arr) || _nonIterableSpread$1();
     }
-    class VFileMessage extends Error {
-        constructor(causeOrReason, optionsOrParentOrPlace, origin) {
-            super();
-            if (typeof optionsOrParentOrPlace === "string") {
-                origin = optionsOrParentOrPlace;
-                optionsOrParentOrPlace = void 0;
-            }
-            let reason = "";
-            let options = {};
-            let legacyCause = false;
-            if (optionsOrParentOrPlace) {
-                if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
-                    options = {
-                        place: optionsOrParentOrPlace
-                    };
-                } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
-                    options = {
-                        place: optionsOrParentOrPlace
-                    };
-                } else if ("type" in optionsOrParentOrPlace) {
-                    options = {
-                        ancestors: [optionsOrParentOrPlace],
-                        place: optionsOrParentOrPlace.position
-                    };
-                } else {
-                    options = {
-                        ...optionsOrParentOrPlace
-                    };
-                }
-            }
-            if (typeof causeOrReason === "string") {
-                reason = causeOrReason;
-            } else if (!options.cause && causeOrReason) {
-                legacyCause = true;
-                reason = causeOrReason.message;
-                options.cause = causeOrReason;
-            }
-            if (!options.ruleId && !options.source && typeof origin === "string") {
-                const index2 = origin.indexOf(":");
-                if (index2 === -1) {
-                    options.ruleId = origin;
-                } else {
-                    options.source = origin.slice(0, index2);
-                    options.ruleId = origin.slice(index2 + 1);
-                }
-            }
-            if (!options.place && options.ancestors && options.ancestors) {
-                const parent = options.ancestors[options.ancestors.length - 1];
-                if (parent) {
-                    options.place = parent.position;
-                }
-            }
-            const start2 = options.place && "start" in options.place ? options.place.start : options.place;
-            this.ancestors = options.ancestors || void 0;
-            this.cause = options.cause || void 0;
-            this.column = start2 ? start2.column : void 0;
-            this.fatal = void 0;
-            this.file;
-            this.message = reason;
-            this.line = start2 ? start2.line : void 0;
-            this.name = stringifyPosition(options.place) || "1:1";
-            this.place = options.place || void 0;
-            this.reason = this.message;
-            this.ruleId = options.ruleId || void 0;
-            this.source = options.source || void 0;
-            this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
-            this.actual;
-            this.expected;
-            this.note;
-            this.url;
-        }
+
+    function _arrayWithoutHoles$1(arr) {
+        if (Array.isArray(arr))
+            return _arrayLikeToArray$8(arr);
     }
-    VFileMessage.prototype.file = "";
-    VFileMessage.prototype.name = "";
-    VFileMessage.prototype.reason = "";
-    VFileMessage.prototype.message = "";
-    VFileMessage.prototype.stack = "";
-    VFileMessage.prototype.column = void 0;
-    VFileMessage.prototype.line = void 0;
-    VFileMessage.prototype.ancestors = void 0;
-    VFileMessage.prototype.cause = void 0;
-    VFileMessage.prototype.fatal = void 0;
-    VFileMessage.prototype.place = void 0;
-    VFileMessage.prototype.ruleId = void 0;
-    VFileMessage.prototype.source = void 0;
-    const own$7 = {}.hasOwnProperty;
-    const emptyMap = /* @__PURE__ */ new Map();
-    const cap = /[A-Z]/g;
-    const dashSomething = /-([a-z])/g;
-    const tableElements = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]);
-    const tableCellElement = /* @__PURE__ */ new Set(["td", "th"]);
-    const docs = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
 
-    function toJsxRuntime(tree, options) {
-        if (!options || options.Fragment === void 0) {
-            throw new TypeError("Expected `Fragment` in options");
-        }
-        const filePath = options.filePath || void 0;
-        let create2;
-        if (options.development) {
-            if (typeof options.jsxDEV !== "function") {
-                throw new TypeError(
-                    "Expected `jsxDEV` in options when `development: true`"
-                );
-            }
-            create2 = developmentCreate(filePath, options.jsxDEV);
-        } else {
-            if (typeof options.jsx !== "function") {
-                throw new TypeError("Expected `jsx` in production options");
-            }
-            if (typeof options.jsxs !== "function") {
-                throw new TypeError("Expected `jsxs` in production options");
-            }
-            create2 = productionCreate(filePath, options.jsx, options.jsxs);
-        }
-        const state = {
-            Fragment: options.Fragment,
-            ancestors: [],
-            components: options.components || {},
-            create: create2,
-            elementAttributeNameCase: options.elementAttributeNameCase || "react",
-            evaluater: options.createEvaluater ? options.createEvaluater() : void 0,
-            filePath,
-            ignoreInvalidStyle: options.ignoreInvalidStyle || false,
-            passKeys: options.passKeys !== false,
-            passNode: options.passNode || false,
-            schema: options.space === "svg" ? svg : html$3,
-            stylePropertyNameCase: options.stylePropertyNameCase || "dom",
-            tableCellAlignToStyle: options.tableCellAlignToStyle !== false
-        };
-        const result = one$4(state, tree, void 0);
-        if (result && typeof result !== "string") {
-            return result;
-        }
-        return state.create(
-            tree,
-            state.Fragment, {
-                children: result || void 0
-            },
-            void 0
-        );
+    function _arrayWithHoles$7(arr) {
+        if (Array.isArray(arr))
+            return arr;
     }
 
-    function one$4(state, node2, key) {
-        if (node2.type === "element") {
-            return element$4(state, node2, key);
-        }
-        if (node2.type === "mdxFlowExpression" || node2.type === "mdxTextExpression") {
-            return mdxExpression(state, node2);
-        }
-        if (node2.type === "mdxJsxFlowElement" || node2.type === "mdxJsxTextElement") {
-            return mdxJsxElement(state, node2, key);
-        }
-        if (node2.type === "mdxjsEsm") {
-            return mdxEsm(state, node2);
-        }
-        if (node2.type === "root") {
-            return root$4(state, node2, key);
-        }
-        if (node2.type === "text") {
-            return text$6(state, node2);
-        }
+    function _iterableToArray$1(iter2) {
+        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter2))
+            return Array.from(iter2);
     }
 
-    function element$4(state, node2, key) {
-        const parentSchema = state.schema;
-        let schema = parentSchema;
-        if (node2.tagName.toLowerCase() === "svg" && parentSchema.space === "html") {
-            schema = svg;
-            state.schema = schema;
-        }
-        state.ancestors.push(node2);
-        const type2 = findComponentFromName(state, node2.tagName, false);
-        const props = createElementProps(state, node2);
-        let children2 = createChildren(state, node2);
-        if (tableElements.has(node2.tagName)) {
-            children2 = children2.filter(function(child) {
-                return typeof child === "string" ? !whitespace(child) : true;
-            });
+    function _iterableToArrayLimit$7(arr, i2) {
+        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
+            return;
+        var _arr = [];
+        var _n2 = true;
+        var _d = false;
+        var _e2 = void 0;
+        try {
+            for (var _i2 = arr[Symbol.iterator](), _s; !(_n2 = (_s = _i2.next()).done); _n2 = true) {
+                _arr.push(_s.value);
+                if (i2 && _arr.length === i2)
+                    break;
+            }
+        } catch (err) {
+            _d = true;
+            _e2 = err;
+        } finally {
+            try {
+                if (!_n2 && _i2["return"] != null)
+                    _i2["return"]();
+            } finally {
+                if (_d)
+                    throw _e2;
+            }
         }
-        addNode$1(state, props, type2, node2);
-        addChildren$1(props, children2);
-        state.ancestors.pop();
-        state.schema = parentSchema;
-        return state.create(node2, type2, props, key);
+        return _arr;
     }
 
-    function mdxExpression(state, node2) {
-        if (node2.data && node2.data.estree && state.evaluater) {
-            const program = node2.data.estree;
-            const expression = program.body[0];
-            ok$2(expression.type === "ExpressionStatement");
-            return state.evaluater.evaluateExpression(expression.expression);
-        }
-        crashEstree(state, node2.position);
+    function _unsupportedIterableToArray$8(o2, minLen) {
+        if (!o2)
+            return;
+        if (typeof o2 === "string")
+            return _arrayLikeToArray$8(o2, minLen);
+        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
+        if (n2 === "Object" && o2.constructor)
+            n2 = o2.constructor.name;
+        if (n2 === "Map" || n2 === "Set")
+            return Array.from(o2);
+        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
+            return _arrayLikeToArray$8(o2, minLen);
     }
 
-    function mdxEsm(state, node2) {
-        if (node2.data && node2.data.estree && state.evaluater) {
-            return state.evaluater.evaluateProgram(node2.data.estree);
-        }
-        crashEstree(state, node2.position);
+    function _arrayLikeToArray$8(arr, len) {
+        if (len == null || len > arr.length)
+            len = arr.length;
+        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
+            arr2[i2] = arr[i2];
+        return arr2;
     }
 
-    function mdxJsxElement(state, node2, key) {
-        const parentSchema = state.schema;
-        let schema = parentSchema;
-        if (node2.name === "svg" && parentSchema.space === "html") {
-            schema = svg;
-            state.schema = schema;
-        }
-        state.ancestors.push(node2);
-        const type2 = node2.name === null ? state.Fragment : findComponentFromName(state, node2.name, true);
-        const props = createJsxElementProps(state, node2);
-        const children2 = createChildren(state, node2);
-        addNode$1(state, props, type2, node2);
-        addChildren$1(props, children2);
-        state.ancestors.pop();
-        state.schema = parentSchema;
-        return state.create(node2, type2, props, key);
+    function _nonIterableSpread$1() {
+        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
     }
 
-    function root$4(state, node2, key) {
-        const props = {};
-        addChildren$1(props, createChildren(state, node2));
-        return state.create(node2, state.Fragment, props, key);
+    function _nonIterableRest$7() {
+        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
     }
 
-    function text$6(_2, node2) {
-        return node2.value;
+    function getSortByVal() {
+        var reversed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
+        return function sortByVal(a2, b2) {
+            if (a2.val > b2.val) {
+                return reversed ? -1 : 1;
+            }
+            if (b2.val > a2.val) {
+                return reversed ? 1 : -1;
+            }
+            return 0;
+        };
     }
 
-    function addNode$1(state, props, type2, node2) {
-        if (typeof type2 !== "string" && type2 !== state.Fragment && state.passNode) {
-            props.node = node2;
+    function getUpdatedHandles(handles, updateKey, updateValue) {
+        var reversed = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
+        var index2 = handles.findIndex(function(v2) {
+            return v2.key === updateKey;
+        });
+        if (index2 !== -1) {
+            var _handles$index = handles[index2],
+                key = _handles$index.key,
+                val = _handles$index.val;
+            if (val === updateValue) {
+                return handles;
+            }
+            return [].concat(_toConsumableArray$1(handles.slice(0, index2)), [{
+                key,
+                val: updateValue
+            }], _toConsumableArray$1(handles.slice(index2 + 1))).sort(getSortByVal(reversed));
         }
+        return handles;
     }
 
-    function addChildren$1(props, children2) {
-        if (children2.length > 0) {
-            const value = children2.length > 1 ? children2 : children2[0];
-            if (value) {
-                props.children = value;
-            }
+    function getSliderDomain(slider, vertical) {
+        if (!slider) {
+            return [0, 0];
         }
+        var s2 = slider.getBoundingClientRect();
+        var d0 = vertical ? s2.top : s2.left;
+        var d1 = vertical ? s2.bottom : s2.right;
+        return [d0, d1];
     }
 
-    function productionCreate(_2, jsx, jsxs) {
-        return create2;
+    function isNotValidTouch(_ref2) {
+        var _ref$type = _ref2.type,
+            type2 = _ref$type === void 0 ? "" : _ref$type,
+            touches = _ref2.touches;
+        return !touches || touches.length > 1 || type2.toLowerCase() === "touchend" && touches.length > 0;
+    }
 
-        function create2(_3, type2, props, key) {
-            const isStaticChildren = Array.isArray(props.children);
-            const fn2 = isStaticChildren ? jsxs : jsx;
-            return key ? fn2(type2, props, key) : fn2(type2, props);
-        }
+    function getTouchPosition(vertical, e3) {
+        return vertical ? e3.touches[0].clientY : e3.touches[0].pageX;
     }
 
-    function developmentCreate(filePath, jsxDEV) {
-        return create2;
+    function getHandles() {
+        var values = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
+        var reversed = arguments.length > 1 ? arguments[1] : void 0;
+        var valueToStep = arguments.length > 2 ? arguments[2] : void 0;
+        var changes = 0;
+        var handles = values.map(function(x2) {
+            var val = valueToStep.getValue(x2);
+            if (x2 !== val) {
+                changes += 1;
+            }
+            return val;
+        }).map(function(val, i2) {
+            return {
+                key: "$$-".concat(i2),
+                val
+            };
+        }).sort(getSortByVal(reversed));
+        return {
+            handles,
+            changes
+        };
+    }
 
-        function create2(node2, type2, props, key) {
-            const isStaticChildren = Array.isArray(props.children);
-            const point2 = pointStart$1(node2);
-            return jsxDEV(
-                type2,
-                props,
-                key,
-                isStaticChildren, {
-                    columnNumber: point2 ? point2.column - 1 : void 0,
-                    fileName: filePath,
-                    lineNumber: point2 ? point2.line : void 0
-                },
-                void 0
-            );
-        }
+    function mode1(_2, next2) {
+        return next2;
     }
 
-    function createElementProps(state, node2) {
-        const props = {};
-        let alignValue;
-        let prop;
-        for (prop in node2.properties) {
-            if (prop !== "children" && own$7.call(node2.properties, prop)) {
-                const result = createProperty$1(state, prop, node2.properties[prop]);
-                if (result) {
-                    const [key, value] = result;
-                    if (state.tableCellAlignToStyle && key === "align" && typeof value === "string" && tableCellElement.has(node2.tagName)) {
-                        alignValue = value;
-                    } else {
-                        props[key] = value;
-                    }
-                }
+    function mode2(curr, next2) {
+        for (var i2 = 0; i2 < curr.length; i2++) {
+            if (curr[i2].key !== next2[i2].key) {
+                return curr;
+            }
+            if (next2[i2 + 1] && next2[i2].val === next2[i2 + 1].val) {
+                return curr;
             }
         }
-        if (alignValue) {
-            const style2 = props.style || (props.style = {});
-            style2[state.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = alignValue;
-        }
-        return props;
+        return next2;
     }
 
-    function createJsxElementProps(state, node2) {
-        const props = {};
-        for (const attribute of node2.attributes) {
-            if (attribute.type === "mdxJsxExpressionAttribute") {
-                if (attribute.data && attribute.data.estree && state.evaluater) {
-                    const program = attribute.data.estree;
-                    const expression = program.body[0];
-                    ok$2(expression.type === "ExpressionStatement");
-                    const objectExpression = expression.expression;
-                    ok$2(objectExpression.type === "ObjectExpression");
-                    const property = objectExpression.properties[0];
-                    ok$2(property.type === "SpreadElement");
-                    Object.assign(
-                        props,
-                        state.evaluater.evaluateExpression(property.argument)
-                    );
-                } else {
-                    crashEstree(state, node2.position);
-                }
-            } else {
-                const name2 = attribute.name;
-                let value;
-                if (attribute.value && typeof attribute.value === "object") {
-                    if (attribute.value.data && attribute.value.data.estree && state.evaluater) {
-                        const program = attribute.value.data.estree;
-                        const expression = program.body[0];
-                        ok$2(expression.type === "ExpressionStatement");
-                        value = state.evaluater.evaluateExpression(expression.expression);
+    function mode3(curr, next2, step2, reversed, getValue2) {
+        var indexForMovingHandle = -1;
+        var handleMoveIsPositive = true;
+        for (var i2 = 0; i2 < curr.length; i2++) {
+            var c2 = curr[i2];
+            var n2 = next2[i2];
+            if (!n2 || n2.key !== c2.key) {
+                return curr;
+            } else if (n2.val !== c2.val) {
+                indexForMovingHandle = i2;
+                handleMoveIsPositive = n2.val - c2.val > 0;
+            }
+        }
+        if (indexForMovingHandle === -1) {
+            return curr;
+        } else {
+            var increment2 = handleMoveIsPositive ? step2 : -step2;
+            for (var _i2 = 0; _i2 < next2.length; _i2++) {
+                var n0 = next2[_i2];
+                var n1 = next2[_i2 + 1];
+                if (n1 && n0.val === n1.val) {
+                    if (_i2 === indexForMovingHandle) {
+                        var newStep = n1.val + increment2;
+                        if (getValue2(newStep) === newStep) {
+                            var clone2 = getUpdatedHandles(next2, n1.key, n1.val + increment2, reversed);
+                            var check = mode3(next2, clone2, step2, reversed, getValue2);
+                            if (check === next2) {
+                                return curr;
+                            } else {
+                                return check;
+                            }
+                        } else {
+                            return curr;
+                        }
                     } else {
-                        crashEstree(state, node2.position);
+                        var _newStep = n0.val + increment2;
+                        if (getValue2(_newStep) === _newStep) {
+                            var _clone = getUpdatedHandles(next2, n0.key, n0.val + increment2, reversed);
+                            var _check = mode3(next2, _clone, step2, reversed, getValue2);
+                            if (_check === next2) {
+                                return curr;
+                            } else {
+                                return _check;
+                            }
+                        } else {
+                            return curr;
+                        }
                     }
-                } else {
-                    value = attribute.value === null ? true : attribute.value;
                 }
-                props[name2] = value;
             }
         }
-        return props;
+        return next2;
     }
 
-    function createChildren(state, node2) {
-        const children2 = [];
-        let index2 = -1;
-        const countsByName = state.passKeys ? /* @__PURE__ */ new Map() : emptyMap;
-        while (++index2 < node2.children.length) {
-            const child = node2.children[index2];
-            let key;
-            if (state.passKeys) {
-                const name2 = child.type === "element" ? child.tagName : child.type === "mdxJsxFlowElement" || child.type === "mdxJsxTextElement" ? child.name : void 0;
-                if (name2) {
-                    const count2 = countsByName.get(name2) || 0;
-                    key = name2 + "-" + count2;
-                    countsByName.set(name2, count2 + 1);
-                }
-            }
-            const result = one$4(state, child, key);
-            if (result !== void 0)
-                children2.push(result);
+    function callAll() {
+        for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
+            fns[_key] = arguments[_key];
         }
-        return children2;
+        return function(e3) {
+            return fns.forEach(function(fn2) {
+                return fn2 && fn2(e3);
+            });
+        };
     }
+    var NOOP = function NOOP2() {
+        return {
+            value: 0,
+            percent: 0
+        };
+    };
+    var Rail = /* @__PURE__ */ function(_Component) {
+        _inherits(Rail2, _Component);
+        var _super = _createSuper(Rail2);
 
-    function createProperty$1(state, prop, value) {
-        const info = find$3(state.schema, prop);
-        if (value === null || value === void 0 || typeof value === "number" && Number.isNaN(value)) {
-            return;
-        }
-        if (Array.isArray(value)) {
-            value = info.commaSeparated ? stringify$3(value) : stringify$2(value);
-        }
-        if (info.property === "style") {
-            let styleObject = typeof value === "object" ? value : parseStyle(state, String(value));
-            if (state.stylePropertyNameCase === "css") {
-                styleObject = transformStylesToCssCasing(styleObject);
+        function Rail2() {
+            var _this;
+            _classCallCheck$f(this, Rail2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
             }
-            return ["style", styleObject];
+            _this = _super.call.apply(_super, [this].concat(args));
+            _this.getRailProps = function() {
+                var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
+                var _this$props = _this.props,
+                    emitMouse = _this$props.emitMouse,
+                    emitTouch = _this$props.emitTouch;
+                return _objectSpread2(_objectSpread2({}, props), {}, {
+                    onMouseDown: callAll(props && props.onMouseDown, emitMouse),
+                    onTouchStart: callAll(props && props.onTouchStart, emitTouch)
+                });
+            };
+            return _this;
         }
-        return [
-            state.elementAttributeNameCase === "react" && info.space ? hastToReact[info.property] || info.property : info.attribute,
-            value
-        ];
-    }
-
-    function parseStyle(state, value) {
-        const result = {};
-        try {
-            styleToObject(value, replacer);
-        } catch (error2) {
-            if (!state.ignoreInvalidStyle) {
-                const cause = error2;
-                const message = new VFileMessage("Cannot parse `style` attribute", {
-                    ancestors: state.ancestors,
-                    cause,
-                    ruleId: "style",
-                    source: "hast-util-to-jsx-runtime"
+        _createClass$f(Rail2, [{
+            key: "render",
+            value: function render2() {
+                var getRailProps = this.getRailProps,
+                    _this$props2 = this.props,
+                    getEventData = _this$props2.getEventData,
+                    _this$props2$activeHa = _this$props2.activeHandleID,
+                    activeHandleID = _this$props2$activeHa === void 0 ? "" : _this$props2$activeHa,
+                    children2 = _this$props2.children;
+                var renderedChildren = children2({
+                    getEventData: getEventData || NOOP,
+                    activeHandleID,
+                    getRailProps
                 });
-                message.file = state.filePath || void 0;
-                message.url = docs + "#cannot-parse-style-attribute";
-                throw message;
+                return renderedChildren && React__default.default.Children.only(renderedChildren);
             }
-        }
-        return result;
+        }]);
+        return Rail2;
+    }(React.Component);
+    var Handles = /* @__PURE__ */ function(_Component) {
+        _inherits(Handles2, _Component);
+        var _super = _createSuper(Handles2);
 
-        function replacer(name2, value2) {
-            let key = name2;
-            if (key.slice(0, 2) !== "--") {
-                if (key.slice(0, 4) === "-ms-")
-                    key = "ms-" + key.slice(4);
-                key = key.replace(dashSomething, toCamel);
+        function Handles2() {
+            var _this;
+            _classCallCheck$f(this, Handles2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
             }
-            result[key] = value2;
-        }
-    }
-
-    function findComponentFromName(state, name2, allowExpression) {
-        let result;
-        if (!allowExpression) {
-            result = {
-                type: "Literal",
-                value: name2
+            _this = _super.call.apply(_super, [this].concat(args));
+            _this.autofocus = function(e3) {
+                if (e3.target instanceof HTMLElement) {
+                    e3.target.focus();
+                }
             };
-        } else if (name2.includes(".")) {
-            const identifiers = name2.split(".");
-            let index2 = -1;
-            let node2;
-            while (++index2 < identifiers.length) {
-                const prop = name$2(identifiers[index2]) ? {
-                    type: "Identifier",
-                    name: identifiers[index2]
-                } : {
-                    type: "Literal",
-                    value: identifiers[index2]
-                };
-                node2 = node2 ? {
-                    type: "MemberExpression",
-                    object: node2,
-                    property: prop,
-                    computed: Boolean(index2 && prop.type === "Literal"),
-                    optional: false
-                } : prop;
-            }
-            result = node2;
-        } else {
-            result = name$2(name2) && !/^[a-z]/.test(name2) ? {
-                type: "Identifier",
-                name: name2
-            } : {
-                type: "Literal",
-                value: name2
+            _this.getHandleProps = function(id2) {
+                var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
+                var _this$props = _this.props,
+                    emitKeyboard = _this$props.emitKeyboard,
+                    emitMouse = _this$props.emitMouse,
+                    emitTouch = _this$props.emitTouch;
+                return _objectSpread2(_objectSpread2({}, props), {}, {
+                    onKeyDown: callAll(props && props.onKeyDown, function(e3) {
+                        return emitKeyboard && emitKeyboard(e3, id2);
+                    }),
+                    onMouseDown: callAll(props && props.onMouseDown, _this.autofocus, function(e3) {
+                        return emitMouse && emitMouse(e3, id2);
+                    }),
+                    onTouchStart: callAll(props && props.onTouchStart, function(e3) {
+                        return emitTouch && emitTouch(e3, id2);
+                    })
+                });
             };
+            return _this;
         }
-        if (result.type === "Literal") {
-            const name3 = result.value;
-            return own$7.call(state.components, name3) ? state.components[name3] : name3;
-        }
-        if (state.evaluater) {
-            return state.evaluater.evaluateExpression(result);
+        _createClass$f(Handles2, [{
+            key: "render",
+            value: function render2() {
+                var getHandleProps = this.getHandleProps,
+                    _this$props2 = this.props,
+                    _this$props2$activeHa = _this$props2.activeHandleID,
+                    activeHandleID = _this$props2$activeHa === void 0 ? "" : _this$props2$activeHa,
+                    children2 = _this$props2.children,
+                    _this$props2$handles = _this$props2.handles,
+                    handles = _this$props2$handles === void 0 ? [] : _this$props2$handles;
+                var renderedChildren = children2({
+                    handles,
+                    activeHandleID,
+                    getHandleProps
+                });
+                return renderedChildren && React__default.default.Children.only(renderedChildren);
+            }
+        }]);
+        return Handles2;
+    }(React.Component);
+    var LinearScale = /* @__PURE__ */ function() {
+        function LinearScale2() {
+            _classCallCheck$f(this, LinearScale2);
+            this.interpolator = void 0;
+            this.domain = [0, 1];
+            this.range = [0, 1];
+            this.domain = [0, 1];
+            this.range = [0, 1];
+            this.interpolator = null;
         }
-        crashEstree(state);
-    }
+        _createClass$f(LinearScale2, [{
+            key: "createInterpolator",
+            value: function createInterpolator(domain2, range2) {
+                var _this = this;
+                var d0 = domain2[0];
+                var d1 = domain2[1];
+                var r0 = range2[0];
+                var r1 = range2[1];
+                if (d1 < d0) {
+                    return function(x2) {
+                        return _this.interpolateValue(r1, r0)(_this.deinterpolateValue(d1, d0)(x2));
+                    };
+                } else {
+                    return function(x2) {
+                        return _this.interpolateValue(r0, r1)(_this.deinterpolateValue(d0, d1)(x2));
+                    };
+                }
+            }
+        }, {
+            key: "interpolateValue",
+            value: function interpolateValue(a2, b2) {
+                return a2 = +a2, b2 -= a2,
+                    function i2(t2) {
+                        return a2 + b2 * t2;
+                    };
+            }
+        }, {
+            key: "deinterpolateValue",
+            value: function deinterpolateValue(a2, b2) {
+                return (b2 -= a2 = +a2) ? function(x2) {
+                    return (x2 - a2) / b2;
+                } : function() {
+                    return b2;
+                };
+            }
+        }, {
+            key: "rescale",
+            value: function rescale() {
+                this.interpolator = null;
+                return this;
+            }
+        }, {
+            key: "getValue",
+            value: function getValue2(x2) {
+                var domain2 = this.domain,
+                    range2 = this.range;
+                return (this.interpolator || (this.interpolator = this.createInterpolator(domain2, range2)))(+x2);
+            }
+        }, {
+            key: "setDomain",
+            value: function setDomain(val) {
+                this.domain = [val[0], val[1]];
+                this.rescale();
+                return this;
+            }
+        }, {
+            key: "getDomain",
+            value: function getDomain() {
+                return this.domain;
+            }
+        }, {
+            key: "setRange",
+            value: function setRange(val) {
+                this.range = [val[0], val[1]];
+                return this;
+            }
+        }, {
+            key: "getTicks",
+            value: function getTicks(count2) {
+                var d2 = this.domain;
+                return ticks(d2[0], d2[d2.length - 1], count2 ? count2 : 10);
+            }
+        }]);
+        return LinearScale2;
+    }();
+    var defaultGetEventData = function defaultGetEventData2() {
+        return {
+            value: 0,
+            percent: 0
+        };
+    };
+    var Ticks = /* @__PURE__ */ function(_Component) {
+        _inherits(Ticks2, _Component);
+        var _super = _createSuper(Ticks2);
 
-    function crashEstree(state, place2) {
-        const message = new VFileMessage(
-            "Cannot handle MDX estrees without `createEvaluater`", {
-                ancestors: state.ancestors,
-                place: place2,
-                ruleId: "mdx-estree",
-                source: "hast-util-to-jsx-runtime"
+        function Ticks2() {
+            _classCallCheck$f(this, Ticks2);
+            return _super.apply(this, arguments);
+        }
+        _createClass$f(Ticks2, [{
+            key: "render",
+            value: function render2() {
+                var _this$props = this.props,
+                    children2 = _this$props.children,
+                    values = _this$props.values,
+                    _this$props$scale = _this$props.scale,
+                    scale = _this$props$scale === void 0 ? new LinearScale() : _this$props$scale,
+                    _this$props$count = _this$props.count,
+                    count2 = _this$props$count === void 0 ? 10 : _this$props$count,
+                    _this$props$getEventD = _this$props.getEventData,
+                    getEventData = _this$props$getEventD === void 0 ? defaultGetEventData : _this$props$getEventD,
+                    _this$props$activeHan = _this$props.activeHandleID,
+                    activeHandleID = _this$props$activeHan === void 0 ? "" : _this$props$activeHan;
+                var ticks2 = (values ? values : scale.getTicks(count2)).map(function(value) {
+                    return {
+                        id: "$$-".concat(value),
+                        value,
+                        percent: scale.getValue(value)
+                    };
+                });
+                var renderedChildren = children2({
+                    getEventData,
+                    activeHandleID,
+                    ticks: ticks2
+                });
+                return renderedChildren && React__default.default.Children.only(renderedChildren);
             }
-        );
-        message.file = state.filePath || void 0;
-        message.url = docs + "#cannot-handle-mdx-estrees-without-createevaluater";
-        throw message;
-    }
+        }]);
+        return Ticks2;
+    }(React.Component);
+    var defaultGetEventData$1 = function defaultGetEventData2() {
+        return {
+            value: 0,
+            percent: 0
+        };
+    };
+    var Tracks = /* @__PURE__ */ function(_Component) {
+        _inherits(Tracks2, _Component);
+        var _super = _createSuper(Tracks2);
 
-    function transformStylesToCssCasing(domCasing) {
-        const cssCasing = {};
-        let from;
-        for (from in domCasing) {
-            if (own$7.call(domCasing, from)) {
-                cssCasing[transformStyleToCssCasing(from)] = domCasing[from];
+        function Tracks2() {
+            var _this;
+            _classCallCheck$f(this, Tracks2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
             }
+            _this = _super.call.apply(_super, [this].concat(args));
+            _this.getTrackProps = function(props) {
+                var _this$props = _this.props,
+                    emitMouse = _this$props.emitMouse,
+                    emitTouch = _this$props.emitTouch;
+                return _objectSpread2(_objectSpread2({}, props || {}), {}, {
+                    onMouseDown: callAll(props && props.onMouseDown, emitMouse),
+                    onTouchStart: callAll(props && props.onTouchStart, emitTouch)
+                });
+            };
+            return _this;
         }
-        return cssCasing;
-    }
-
-    function transformStyleToCssCasing(from) {
-        let to2 = from.replace(cap, toDash);
-        if (to2.slice(0, 3) === "ms-")
-            to2 = "-" + to2;
-        return to2;
-    }
-
-    function toCamel(_2, $1) {
-        return $1.toUpperCase();
-    }
+        _createClass$f(Tracks2, [{
+            key: "render",
+            value: function render2() {
+                var getTrackProps = this.getTrackProps,
+                    _this$props2 = this.props,
+                    children2 = _this$props2.children,
+                    _this$props2$left = _this$props2.left,
+                    left2 = _this$props2$left === void 0 ? true : _this$props2$left,
+                    _this$props2$right = _this$props2.right,
+                    right2 = _this$props2$right === void 0 ? true : _this$props2$right,
+                    _this$props2$scale = _this$props2.scale,
+                    scale = _this$props2$scale === void 0 ? new LinearScale() : _this$props2$scale,
+                    _this$props2$handles = _this$props2.handles,
+                    handles = _this$props2$handles === void 0 ? [] : _this$props2$handles,
+                    _this$props2$getEvent = _this$props2.getEventData,
+                    getEventData = _this$props2$getEvent === void 0 ? defaultGetEventData$1 : _this$props2$getEvent,
+                    _this$props2$activeHa = _this$props2.activeHandleID,
+                    activeHandleID = _this$props2$activeHa === void 0 ? "" : _this$props2$activeHa;
+                var domain2 = scale.getDomain();
+                var tracks = [];
+                for (var i2 = 0; i2 < handles.length + 1; i2++) {
+                    var source = handles[i2 - 1];
+                    var target = handles[i2];
+                    if (i2 === 0 && left2 === true) {
+                        source = {
+                            id: "$",
+                            value: domain2[0],
+                            percent: 0
+                        };
+                    } else if (i2 === handles.length && right2 === true) {
+                        target = {
+                            id: "$",
+                            value: domain2[1],
+                            percent: 100
+                        };
+                    }
+                    if (source && target) {
+                        tracks.push({
+                            id: "".concat(source.id, "-").concat(target.id),
+                            source,
+                            target
+                        });
+                    }
+                }
+                var renderedChildren = children2({
+                    getEventData,
+                    activeHandleID,
+                    tracks,
+                    getTrackProps
+                });
+                return renderedChildren && React__default.default.Children.only(renderedChildren);
+            }
+        }]);
+        return Tracks2;
+    }(React.Component);
 
-    function toDash($0) {
-        return "-" + $0.toLowerCase();
+    function clamp(value, min2, max2) {
+        return Math.min(Math.max(value, min2), max2);
     }
-    const urlAttributes = {
-        action: ["form"],
-        cite: ["blockquote", "del", "ins", "q"],
-        data: ["object"],
-        formAction: ["button", "input"],
-        href: ["a", "area", "base", "link"],
-        icon: ["menuitem"],
-        itemId: null,
-        manifest: ["html"],
-        ping: ["a", "area"],
-        poster: ["video"],
-        src: [
-            "audio",
-            "embed",
-            "iframe",
-            "img",
-            "input",
-            "script",
-            "source",
-            "track",
-            "video"
-        ]
+    var DiscreteScale = function DiscreteScale2() {
+        var _this = this;
+        _classCallCheck$f(this, DiscreteScale2);
+        this.step = 1;
+        this.domain = [0, 1];
+        this.range = [0, 1];
+        this.setDomain = function(val) {
+            _this.domain = [val[0], val[1]];
+            return _this;
+        };
+        this.setRange = function(val) {
+            _this.range = [val[0], val[1]];
+            return _this;
+        };
+        this.setStep = function(val) {
+            _this.step = val;
+            return _this;
+        };
+        this.getValue = function(x2) {
+            var _this$domain = _slicedToArray$7(_this.domain, 2),
+                d0 = _this$domain[0],
+                d1 = _this$domain[1],
+                _this$range = _slicedToArray$7(_this.range, 2),
+                r0 = _this$range[0],
+                r1 = _this$range[1],
+                step2 = _this.step;
+            var p2 = (clamp(x2, d0, d1) - d0) / (d1 - d0);
+            var b2 = step2 * Math.round(p2 * (r1 - r0) / step2) + r0;
+            return clamp(b2, r0 < r1 ? r0 : r1, r1 > r0 ? r1 : r0);
+        };
     };
-    const emptyOptions$2 = {};
-
-    function toString$4(value, options) {
-        const settings2 = options || emptyOptions$2;
-        const includeImageAlt = typeof settings2.includeImageAlt === "boolean" ? settings2.includeImageAlt : true;
-        const includeHtml = typeof settings2.includeHtml === "boolean" ? settings2.includeHtml : true;
-        return one$3(value, includeImageAlt, includeHtml);
-    }
+    var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
+    var noop$5 = function noop2() {};
+    var compare$1 = function compare2(b2) {
+        return function(m2, d2, i2) {
+            return m2 && b2[i2] === d2;
+        };
+    };
+    var equal = function equal2(a2, b2) {
+        return a2 === b2 || a2.length === b2.length && a2.reduce(compare$1(b2), true);
+    };
+    var isRCSComponent = function isRCSComponent2(item) {
+        if (! /* @__PURE__ */ React.isValidElement(item)) {
+            return false;
+        }
+        var type2 = item.type;
+        var name2 = type2 ? type2.name : "";
+        return name2 === Handles.name || name2 === Rail.name || name2 === Ticks.name || name2 === Tracks.name;
+    };
+    var getNextValue = function getNextValue2(curr, step2, domain2, reversed) {
+        var newVal = reversed ? curr - step2 : curr + step2;
+        return reversed ? Math.max(domain2[0], newVal) : Math.min(domain2[1], newVal);
+    };
+    var getPrevValue = function getPrevValue2(curr, step2, domain2, reversed) {
+        var newVal = reversed ? curr + step2 : curr - step2;
+        return reversed ? Math.min(domain2[1], newVal) : Math.max(domain2[0], newVal);
+    };
+    var Slider$2 = /* @__PURE__ */ function(_PureComponent) {
+        _inherits(Slider2, _PureComponent);
+        var _super = _createSuper(Slider2);
 
-    function one$3(value, includeImageAlt, includeHtml) {
-        if (node(value)) {
-            if ("value" in value) {
-                return value.type === "html" && !includeHtml ? "" : value.value;
+        function Slider2() {
+            var _this;
+            _classCallCheck$f(this, Slider2);
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
             }
-            if (includeImageAlt && "alt" in value && value.alt) {
-                return value.alt;
+            _this = _super.call.apply(_super, [this].concat(args));
+            _this.state = {
+                step: 0.1,
+                values: [],
+                domain: [0, 100],
+                handles: [],
+                reversed: false,
+                activeHandleID: "",
+                valueToPerc: null,
+                valueToStep: null,
+                pixelToStep: null
+            };
+            _this.slider = /* @__PURE__ */ React__default.default.createRef();
+            _this.onKeyDown = function(e3, handleID) {
+                var validUpKeys = ["ArrowRight", "ArrowUp"];
+                var validDownKeys = ["ArrowDown", "ArrowLeft"];
+                var _assertThisInitialize = _assertThisInitialized$1(_this),
+                    handles = _assertThisInitialize.state.handles,
+                    _assertThisInitialize2 = _assertThisInitialize.props,
+                    _assertThisInitialize3 = _assertThisInitialize2.step,
+                    step2 = _assertThisInitialize3 === void 0 ? 0.1 : _assertThisInitialize3,
+                    _assertThisInitialize4 = _assertThisInitialize2.reversed,
+                    reversed = _assertThisInitialize4 === void 0 ? false : _assertThisInitialize4,
+                    _assertThisInitialize5 = _assertThisInitialize2.vertical,
+                    vertical = _assertThisInitialize5 === void 0 ? false : _assertThisInitialize5,
+                    _assertThisInitialize6 = _assertThisInitialize2.domain,
+                    domain2 = _assertThisInitialize6 === void 0 ? [0, 100] : _assertThisInitialize6;
+                var key = e3.key || "".concat(e3.keyCode);
+                if (!validUpKeys.concat(validDownKeys).includes(key)) {
+                    return;
+                }
+                if (vertical) {
+                    var _ref2 = [validDownKeys, validUpKeys];
+                    validUpKeys = _ref2[0];
+                    validDownKeys = _ref2[1];
+                }
+                e3.stopPropagation && e3.stopPropagation();
+                e3.preventDefault && e3.preventDefault();
+                var found = handles.find(function(value) {
+                    return value.key === handleID;
+                });
+                if (!found) {
+                    return;
+                }
+                var currVal = found.val;
+                var newVal = currVal;
+                if (validUpKeys.includes(key)) {
+                    newVal = getNextValue(currVal, step2, domain2, reversed);
+                } else if (validDownKeys.includes(key)) {
+                    newVal = getPrevValue(currVal, step2, domain2, reversed);
+                }
+                var nextHandles = handles.map(function(v2) {
+                    return v2.key === handleID ? {
+                        key: v2.key,
+                        val: newVal
+                    } : v2;
+                });
+                _this.submitUpdate(nextHandles, true);
+            };
+            _this.onMouseDown = function(e3, handleID) {
+                _this.onStart(e3, handleID, false);
+            };
+            _this.onTouchStart = function(e3, handleID) {
+                if (isNotValidTouch(e3)) {
+                    return;
+                }
+                _this.onStart(e3, handleID, true);
+            };
+            _this.getEventData = function(e3, isTouch) {
+                var _assertThisInitialize7 = _assertThisInitialized$1(_this),
+                    _assertThisInitialize8 = _assertThisInitialize7.state,
+                    pixelToStep = _assertThisInitialize8.pixelToStep,
+                    valueToPerc = _assertThisInitialize8.valueToPerc,
+                    vertical = _assertThisInitialize7.props.vertical;
+                pixelToStep.setDomain(getSliderDomain(_this.slider.current, vertical));
+                var value;
+                if (isTouch && e3 instanceof TouchEvent) {
+                    value = pixelToStep.getValue(getTouchPosition(vertical, e3));
+                } else if (e3 instanceof MouseEvent) {
+                    value = pixelToStep.getValue(vertical ? e3.clientY : e3.pageX);
+                }
+                return {
+                    value,
+                    percent: valueToPerc.getValue(value)
+                };
+            };
+            _this.onMouseMove = function(e3) {
+                var _assertThisInitialize9 = _assertThisInitialized$1(_this),
+                    _assertThisInitialize10 = _assertThisInitialize9.state,
+                    curr = _assertThisInitialize10.handles,
+                    pixelToStep = _assertThisInitialize10.pixelToStep,
+                    _assertThisInitialize11 = _assertThisInitialize10.activeHandleID,
+                    activeHandleID = _assertThisInitialize11 === void 0 ? "" : _assertThisInitialize11,
+                    _assertThisInitialize12 = _assertThisInitialize9.props,
+                    vertical = _assertThisInitialize12.vertical,
+                    _assertThisInitialize13 = _assertThisInitialize12.reversed,
+                    reversed = _assertThisInitialize13 === void 0 ? false : _assertThisInitialize13;
+                pixelToStep.setDomain(getSliderDomain(_this.slider.current, vertical));
+                var updateValue = pixelToStep.getValue(vertical ? e3.clientY : e3.pageX);
+                var nextHandles = getUpdatedHandles(curr, activeHandleID, updateValue, reversed);
+                _this.submitUpdate(nextHandles);
+            };
+            _this.onTouchMove = function(e3) {
+                var _assertThisInitialize14 = _assertThisInitialized$1(_this),
+                    _assertThisInitialize15 = _assertThisInitialize14.state,
+                    curr = _assertThisInitialize15.handles,
+                    pixelToStep = _assertThisInitialize15.pixelToStep,
+                    activeHandleID = _assertThisInitialize15.activeHandleID,
+                    _assertThisInitialize16 = _assertThisInitialize14.props,
+                    vertical = _assertThisInitialize16.vertical,
+                    reversed = _assertThisInitialize16.reversed;
+                if (pixelToStep === null || isNotValidTouch(e3)) {
+                    return;
+                }
+                pixelToStep.setDomain(getSliderDomain(_this.slider.current, vertical));
+                var updateValue = pixelToStep.getValue(getTouchPosition(vertical, e3));
+                var nextHandles = getUpdatedHandles(curr, activeHandleID, updateValue, reversed);
+                _this.submitUpdate(nextHandles);
+            };
+            _this.onMouseUp = function() {
+                var _assertThisInitialize17 = _assertThisInitialized$1(_this),
+                    _assertThisInitialize18 = _assertThisInitialize17.state,
+                    _assertThisInitialize19 = _assertThisInitialize18.handles,
+                    handles = _assertThisInitialize19 === void 0 ? [] : _assertThisInitialize19,
+                    activeHandleID = _assertThisInitialize18.activeHandleID,
+                    _assertThisInitialize20 = _assertThisInitialize17.props,
+                    _assertThisInitialize21 = _assertThisInitialize20.onChange,
+                    onChange2 = _assertThisInitialize21 === void 0 ? noop$5 : _assertThisInitialize21,
+                    _assertThisInitialize22 = _assertThisInitialize20.onSlideEnd,
+                    onSlideEnd = _assertThisInitialize22 === void 0 ? noop$5 : _assertThisInitialize22;
+                onChange2(handles.map(function(d2) {
+                    return d2.val;
+                }));
+                onSlideEnd(handles.map(function(d2) {
+                    return d2.val;
+                }), {
+                    activeHandleID
+                });
+                _this.setState({
+                    activeHandleID: ""
+                });
+                if (isBrowser) {
+                    document.removeEventListener("mousemove", _this.onMouseMove);
+                    document.removeEventListener("mouseup", _this.onMouseUp);
+                }
+            };
+            _this.onTouchEnd = function() {
+                var _assertThisInitialize23 = _assertThisInitialized$1(_this),
+                    _assertThisInitialize24 = _assertThisInitialize23.state,
+                    handles = _assertThisInitialize24.handles,
+                    activeHandleID = _assertThisInitialize24.activeHandleID,
+                    _assertThisInitialize25 = _assertThisInitialize23.props,
+                    _assertThisInitialize26 = _assertThisInitialize25.onChange,
+                    onChange2 = _assertThisInitialize26 === void 0 ? noop$5 : _assertThisInitialize26,
+                    _assertThisInitialize27 = _assertThisInitialize25.onSlideEnd,
+                    onSlideEnd = _assertThisInitialize27 === void 0 ? noop$5 : _assertThisInitialize27;
+                onChange2(handles.map(function(d2) {
+                    return d2.val;
+                }));
+                onSlideEnd(handles.map(function(d2) {
+                    return d2.val;
+                }), {
+                    activeHandleID
+                });
+                _this.setState({
+                    activeHandleID: ""
+                });
+                if (isBrowser) {
+                    document.removeEventListener("touchmove", _this.onTouchMove);
+                    document.removeEventListener("touchend", _this.onTouchEnd);
+                }
+            };
+            return _this;
+        }
+        _createClass$f(Slider2, [{
+            key: "componentDidMount",
+            value: function componentDidMount() {
+                var pixelToStep = this.state.pixelToStep;
+                var vertical = this.props.vertical;
+                pixelToStep.setDomain(getSliderDomain(this.slider.current, vertical));
+            }
+        }, {
+            key: "componentWillUnmount",
+            value: function componentWillUnmount() {
+                this.removeListeners();
+            }
+        }, {
+            key: "removeListeners",
+            value: function removeListeners() {
+                if (isBrowser) {
+                    document.removeEventListener("mousemove", this.onMouseMove);
+                    document.removeEventListener("mouseup", this.onMouseUp);
+                    document.removeEventListener("touchmove", this.onTouchMove);
+                    document.removeEventListener("touchend", this.onTouchEnd);
+                }
+            }
+        }, {
+            key: "onStart",
+            value: function onStart(e3, handleID, isTouch) {
+                var handles = this.state.handles,
+                    _this$props$onSlideSt = this.props.onSlideStart,
+                    onSlideStart = _this$props$onSlideSt === void 0 ? noop$5 : _this$props$onSlideSt;
+                if (!isTouch) {
+                    e3.preventDefault && e3.preventDefault();
+                }
+                e3.stopPropagation && e3.stopPropagation();
+                var found = handles.find(function(value) {
+                    return value.key === handleID;
+                });
+                if (found) {
+                    this.setState({
+                        activeHandleID: handleID
+                    });
+                    onSlideStart(handles.map(function(d2) {
+                        return d2.val;
+                    }), {
+                        activeHandleID: handleID
+                    });
+                    isTouch ? this.addTouchEvents() : this.addMouseEvents();
+                } else {
+                    this.setState({
+                        activeHandleID: ""
+                    });
+                    this.handleRailAndTrackClicks(e3, isTouch);
+                }
+            }
+        }, {
+            key: "handleRailAndTrackClicks",
+            value: function handleRailAndTrackClicks(e3, isTouch) {
+                var _this2 = this;
+                var _this$state = this.state,
+                    curr = _this$state.handles,
+                    pixelToStep = _this$state.pixelToStep,
+                    _this$props = this.props,
+                    vertical = _this$props.vertical,
+                    _this$props$reversed = _this$props.reversed,
+                    reversed = _this$props$reversed === void 0 ? false : _this$props$reversed;
+                var slider = this.slider;
+                pixelToStep.setDomain(getSliderDomain(slider.current, vertical));
+                var updateValue;
+                if (isTouch) {
+                    updateValue = pixelToStep.getValue(getTouchPosition(vertical, e3));
+                } else {
+                    updateValue = pixelToStep.getValue(vertical ? e3.clientY : e3.pageX);
+                }
+                var updateKey = "";
+                var minDiff = Infinity;
+                for (var i2 = 0; i2 < curr.length; i2++) {
+                    var _curr$i = curr[i2],
+                        key = _curr$i.key,
+                        val = _curr$i.val;
+                    var diff = Math.abs(val - updateValue);
+                    if (diff < minDiff) {
+                        updateKey = key;
+                        minDiff = diff;
+                    }
+                }
+                var nextHandles = getUpdatedHandles(curr, updateKey, updateValue, reversed);
+                this.setState({
+                    activeHandleID: updateKey
+                }, function() {
+                    _this2.submitUpdate(nextHandles, true);
+                    isTouch ? _this2.addTouchEvents() : _this2.addMouseEvents();
+                });
+            }
+        }, {
+            key: "addMouseEvents",
+            value: function addMouseEvents() {
+                if (isBrowser) {
+                    document.addEventListener("mousemove", this.onMouseMove);
+                    document.addEventListener("mouseup", this.onMouseUp);
+                }
+            }
+        }, {
+            key: "addTouchEvents",
+            value: function addTouchEvents() {
+                if (isBrowser) {
+                    document.addEventListener("touchmove", this.onTouchMove);
+                    document.addEventListener("touchend", this.onTouchEnd);
+                }
+            }
+        }, {
+            key: "submitUpdate",
+            value: function submitUpdate(next2) {
+                var callOnChange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
+                var _this$props2 = this.props,
+                    _this$props2$mode = _this$props2.mode,
+                    mode = _this$props2$mode === void 0 ? 1 : _this$props2$mode,
+                    _this$props2$step = _this$props2.step,
+                    step2 = _this$props2$step === void 0 ? 0.1 : _this$props2$step,
+                    _this$props2$onUpdate = _this$props2.onUpdate,
+                    onUpdate = _this$props2$onUpdate === void 0 ? noop$5 : _this$props2$onUpdate,
+                    _this$props2$onChange = _this$props2.onChange,
+                    onChange2 = _this$props2$onChange === void 0 ? noop$5 : _this$props2$onChange,
+                    _this$props2$reversed = _this$props2.reversed,
+                    reversed = _this$props2$reversed === void 0 ? false : _this$props2$reversed;
+                var getValue2 = this.state.valueToStep.getValue;
+                this.setState(function(_ref2) {
+                    var curr = _ref2.handles;
+                    var handles = [];
+                    if (typeof mode === "function") {
+                        handles = mode(curr, next2, step2, reversed, getValue2);
+                    } else {
+                        switch (mode) {
+                            case 1:
+                                handles = mode1(curr, next2);
+                                break;
+                            case 2:
+                                handles = mode2(curr, next2);
+                                break;
+                            case 3:
+                                handles = mode3(curr, next2, step2, reversed, getValue2);
+                                break;
+                            default:
+                                handles = next2;
+                        }
+                    }
+                    onUpdate(handles.map(function(d2) {
+                        return d2.val;
+                    }));
+                    if (callOnChange) {
+                        onChange2(handles.map(function(d2) {
+                            return d2.val;
+                        }));
+                    }
+                    return {
+                        handles
+                    };
+                });
+            }
+        }, {
+            key: "render",
+            value: function render2() {
+                var _this3 = this;
+                var _this$state2 = this.state,
+                    handles = _this$state2.handles,
+                    valueToPerc = _this$state2.valueToPerc,
+                    activeHandleID = _this$state2.activeHandleID,
+                    _this$props3 = this.props,
+                    className = _this$props3.className,
+                    _this$props3$rootStyl = _this$props3.rootStyle,
+                    rootStyle = _this$props3$rootStyl === void 0 ? {} : _this$props3$rootStyl,
+                    _this$props3$rootProp = _this$props3.rootProps,
+                    rootProps = _this$props3$rootProp === void 0 ? {} : _this$props3$rootProp,
+                    _this$props3$componen = _this$props3.component,
+                    Comp = _this$props3$componen === void 0 ? "div" : _this$props3$componen,
+                    _this$props3$disabled = _this$props3.disabled,
+                    disabled2 = _this$props3$disabled === void 0 ? false : _this$props3$disabled,
+                    _this$props3$flatten = _this$props3.flatten,
+                    flatten2 = _this$props3$flatten === void 0 ? false : _this$props3$flatten;
+                var mappedHandles = handles.map(function(_ref3) {
+                    var key = _ref3.key,
+                        val = _ref3.val;
+                    return {
+                        id: key,
+                        value: val,
+                        percent: valueToPerc.getValue(val)
+                    };
+                });
+                var children2 = React__default.default.Children.map(this.props.children, function(child) {
+                    if (isRCSComponent(child) === true) {
+                        return /* @__PURE__ */ React__default.default.cloneElement(child, {
+                            scale: valueToPerc,
+                            handles: mappedHandles,
+                            activeHandleID,
+                            getEventData: _this3.getEventData,
+                            emitKeyboard: disabled2 ? noop$5 : _this3.onKeyDown,
+                            emitMouse: disabled2 ? noop$5 : _this3.onMouseDown,
+                            emitTouch: disabled2 ? noop$5 : _this3.onTouchStart
+                        });
+                    } else {
+                        return child;
+                    }
+                });
+                return flatten2 ? /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, /* @__PURE__ */ React__default.default.createElement(Comp, _objectSpread2(_objectSpread2({}, rootProps), {}, {
+                    style: rootStyle,
+                    className,
+                    ref: this.slider
+                })), children2) : /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, /* @__PURE__ */ React__default.default.createElement(Comp, _objectSpread2(_objectSpread2({}, rootProps), {}, {
+                    style: rootStyle,
+                    className,
+                    ref: this.slider
+                }), children2));
             }
-            if ("children" in value) {
-                return all$2(value.children, includeImageAlt, includeHtml);
+        }], [{
+            key: "getDerivedStateFromProps",
+            value: function getDerivedStateFromProps(nextProps, prevState) {
+                var _nextProps$step = nextProps.step,
+                    step2 = _nextProps$step === void 0 ? 0.1 : _nextProps$step,
+                    values = nextProps.values,
+                    _nextProps$domain = nextProps.domain,
+                    domain2 = _nextProps$domain === void 0 ? [0, 100] : _nextProps$domain,
+                    _nextProps$reversed = nextProps.reversed,
+                    reversed = _nextProps$reversed === void 0 ? false : _nextProps$reversed,
+                    _nextProps$onUpdate = nextProps.onUpdate,
+                    onUpdate = _nextProps$onUpdate === void 0 ? noop$5 : _nextProps$onUpdate,
+                    _nextProps$onChange = nextProps.onChange,
+                    onChange2 = _nextProps$onChange === void 0 ? noop$5 : _nextProps$onChange,
+                    _nextProps$warnOnChan = nextProps.warnOnChanges,
+                    warnOnChanges = _nextProps$warnOnChan === void 0 ? false : _nextProps$warnOnChan;
+                var valueToPerc = prevState.valueToPerc;
+                var valueToStep = prevState.valueToStep;
+                var pixelToStep = prevState.pixelToStep;
+                var nextState = {};
+                if (!valueToPerc || !valueToStep || !pixelToStep) {
+                    valueToPerc = new LinearScale();
+                    valueToStep = new DiscreteScale();
+                    pixelToStep = new DiscreteScale();
+                    nextState.valueToPerc = valueToPerc;
+                    nextState.valueToStep = valueToStep;
+                    nextState.pixelToStep = pixelToStep;
+                }
+                if (prevState.step === null || prevState.domain === null || prevState.reversed === null || step2 !== prevState.step || domain2[0] !== prevState.domain[0] || domain2[1] !== prevState.domain[1] || reversed !== prevState.reversed) {
+                    var _domain = _slicedToArray$7(domain2, 2),
+                        min2 = _domain[0],
+                        max2 = _domain[1];
+                    valueToStep.setStep(step2).setRange([min2, max2]).setDomain([min2, max2]);
+                    if (reversed === true) {
+                        valueToPerc.setDomain([min2, max2]).setRange([100, 0]);
+                        pixelToStep.setStep(step2).setRange([max2, min2]);
+                    } else {
+                        valueToPerc.setDomain([min2, max2]).setRange([0, 100]);
+                        pixelToStep.setStep(step2).setRange([min2, max2]);
+                    }
+                    var _getHandles = getHandles(values || prevState.values, reversed, valueToStep, warnOnChanges),
+                        handles = _getHandles.handles,
+                        changes = _getHandles.changes;
+                    if (changes || values === void 0 || values === prevState.values) {
+                        onUpdate(handles.map(function(d2) {
+                            return d2.val;
+                        }));
+                        onChange2(handles.map(function(d2) {
+                            return d2.val;
+                        }));
+                    }
+                    nextState.step = step2;
+                    nextState.values = values;
+                    nextState.domain = domain2;
+                    nextState.handles = handles;
+                    nextState.reversed = reversed;
+                } else if (!equal(values, prevState.values)) {
+                    var _getHandles2 = getHandles(values, reversed, valueToStep, warnOnChanges),
+                        _handles = _getHandles2.handles,
+                        _changes = _getHandles2.changes;
+                    if (_changes) {
+                        onUpdate(_handles.map(function(d2) {
+                            return d2.val;
+                        }));
+                        onChange2(_handles.map(function(d2) {
+                            return d2.val;
+                        }));
+                    }
+                    nextState.values = values;
+                    nextState.handles = _handles;
+                }
+                if (Object.keys(nextState).length) {
+                    return nextState;
+                }
+                return null;
             }
-        }
-        if (Array.isArray(value)) {
-            return all$2(value, includeImageAlt, includeHtml);
-        }
-        return "";
-    }
+        }]);
+        return Slider2;
+    }(React.PureComponent);
+    const InputWrapper$1 = styled__default.default.div`
+    position: relative;
+    display: flex;
+    flex: 1 1 auto;
+    height: 3rem;
 
-    function all$2(values, includeImageAlt, includeHtml) {
-        const result = [];
-        let index2 = -1;
-        while (++index2 < values.length) {
-            result[index2] = one$3(values[index2], includeImageAlt, includeHtml);
-        }
-        return result.join("");
+    div {
+        flex: 1 1 auto;
     }
 
-    function node(value) {
-        return Boolean(value && typeof value === "object");
-    }
-    const element$3 = document.createElement("i");
+    input {
+        height: 100%;
 
-    function decodeNamedCharacterReference(value) {
-        const characterReference2 = "&" + value + ";";
-        element$3.innerHTML = characterReference2;
-        const char = element$3.textContent;
-        if (char.charCodeAt(char.length - 1) === 59 && value !== "semi") {
-            return false;
-        }
-        return char === characterReference2 ? false : char;
-    }
+        ::before {
+            content: ' ';
 
-    function splice(list2, start2, remove2, items) {
-        const end2 = list2.length;
-        let chunkStart = 0;
-        let parameters;
-        if (start2 < 0) {
-            start2 = -start2 > end2 ? 0 : end2 + start2;
-        } else {
-            start2 = start2 > end2 ? end2 : start2;
-        }
-        remove2 = remove2 > 0 ? remove2 : 0;
-        if (items.length < 1e4) {
-            parameters = Array.from(items);
-            parameters.unshift(start2, remove2);
-            list2.splice(...parameters);
-        } else {
-            if (remove2)
-                list2.splice(start2, remove2);
-            while (chunkStart < items.length) {
-                parameters = items.slice(chunkStart, chunkStart + 1e4);
-                parameters.unshift(start2, 0);
-                list2.splice(...parameters);
-                chunkStart += 1e4;
-                start2 += 1e4;
-            }
-        }
-    }
+            position: sticky;
+            top: 0;
+            left: 0;
 
-    function push$2(list2, items) {
-        if (list2.length > 0) {
-            splice(list2, list2.length, 0, items);
-            return list2;
+            width: ${(props) => !props.firstInputVisible ? "8px" : 0};
+            height: 2.5rem;
         }
-        return items;
-    }
-    const hasOwnProperty$5 = {}.hasOwnProperty;
 
-    function combineExtensions(extensions2) {
-        const all2 = {};
-        let index2 = -1;
-        while (++index2 < extensions2.length) {
-            syntaxExtension(all2, extensions2[index2]);
-        }
-        return all2;
-    }
+        ::after {
+            content: '';
 
-    function syntaxExtension(all2, extension2) {
-        let hook;
-        for (hook in extension2) {
-            const maybe = hasOwnProperty$5.call(all2, hook) ? all2[hook] : void 0;
-            const left2 = maybe || (all2[hook] = {});
-            const right2 = extension2[hook];
-            let code2;
-            if (right2) {
-                for (code2 in right2) {
-                    if (!hasOwnProperty$5.call(left2, code2))
-                        left2[code2] = [];
-                    const value = right2[code2];
-                    constructs(
-                        left2[code2],
-                        Array.isArray(value) ? value : value ? [value] : []
-                    );
-                }
-            }
-        }
-    }
+            position: sticky;
+            top: 0;
+            right: 0;
 
-    function constructs(existing, list2) {
-        let index2 = -1;
-        const before = [];
-        while (++index2 < list2.length) {
-            (list2[index2].add === "after" ? existing : before).push(list2[index2]);
+            width: ${(props) => !props.lastInputVisible ? "8px" : 0};
+            height: 2.5rem;
         }
-        splice(existing, 0, 0, before);
     }
+`;
+    const SliderInputs = ({
+        getErrorMsg,
+        sliderValues,
+        setSliderValues,
+        domain: domain2
+    }) => {
+        const firstInputRef = React.useRef();
+        const lastInputRef = React.useRef();
+        const firstInputVisible = useIntersectionObserver(firstInputRef, "0px", 0.5);
+        const lastInputVisible = useIntersectionObserver(lastInputRef, "0px", 0.5);
+        const onInputChange = React.useCallback((value, index2) => {
+            setSliderValues((currSliderValues) => {
+                const updatedValues = [...currSliderValues];
+                updatedValues[index2] = Number.isNaN(value) ? domain2[0] : value;
+                return updatedValues;
+            });
+        }, [domain2, setSliderValues]);
+        return jsxRuntime.exports.jsx(InputWrapper$1, {
+            firstInputVisible,
+            lastInputVisible,
+            children: sliderValues.map((value, index2) => {
+                let inputRef = null;
+                if (index2 === 0) {
+                    inputRef = firstInputRef;
+                }
+                if (index2 === sliderValues.length - 1) {
+                    inputRef = lastInputRef;
+                }
+                return jsxRuntime.exports.jsx("div", {
+                    ref: inputRef,
+                    children: jsxRuntime.exports.jsx(NumericInput, {
+                        errorMsg: getErrorMsg(value, index2),
+                        onChange: (val) => onInputChange(val, index2),
+                        style: {
+                            height: "2rem",
+                            margin: "0.25rem 0.5rem"
+                        },
+                        value
+                    })
+                }, index2);
+            })
+        });
+    };
 
-    function decodeNumericCharacterReference(value, base2) {
-        const code2 = Number.parseInt(value, base2);
-        if (code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || code2 > 126 && code2 < 160 || code2 > 55295 && code2 < 57344 || code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || code2 > 1114111) {
-            return "\uFFFD";
+    function computeStep(difference) {
+        const log3 = Math.floor(Math.log10(difference));
+        const step2 = Math.pow(10, Math.floor(log3)) / 10;
+        if (log3 < 0) {
+            const precisionString = step2.toFixed(Math.abs(log3) + 1);
+            return parseFloat(precisionString);
         }
-        return String.fromCodePoint(code2);
-    }
-
-    function normalizeIdentifier(value) {
-        return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
+        return step2;
     }
-    const asciiAlpha = regexCheck(/[A-Za-z]/);
-    const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
-    const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
 
-    function asciiControl(code2) {
-        return code2 !== null && (code2 < 32 || code2 === 127);
+    function mapToClosestStep(value, step2) {
+        const stepsNumber = parseFloat((value / step2).toFixed(1));
+        const mappedRaw = Math.floor(stepsNumber) * step2;
+        const fractionDigits = Math.abs(Math.floor(Math.log10(step2)));
+        return parseFloat(mappedRaw.toFixed(fractionDigits));
     }
-    const asciiDigit = regexCheck(/\d/);
-    const asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
-    const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
+    const SliderWrapper = styled__default.default.div`
+    display: flex;
+    width: 100%;
+`;
+    const SliderInner = styled__default.default.div`
+    overflow: hidden;
+    display: flex;
+    width: 100%;
+`;
+    const StyledSlider$1 = styled__default.default(Slider$2)`
+    position: relative;
 
-    function markdownLineEnding(code2) {
-        return code2 !== null && code2 < -2;
-    }
+    display: inline-flex;
+    flex-direction: column;
+    justify-content: center;
 
-    function markdownLineEndingOrSpace(code2) {
-        return code2 !== null && (code2 < 0 || code2 === 32);
-    }
+    width: 100%;
+    height: 3rem;
+    margin: 0 1rem;
+`;
+    const SliderRail = styled__default.default.div`
+    cursor: pointer;
 
-    function markdownSpace(code2) {
-        return code2 === -2 || code2 === -1 || code2 === 32;
-    }
-    const unicodePunctuation = regexCheck(/\p{P}|\p{S}/u);
-    const unicodeWhitespace = regexCheck(/\s/);
+    width: 100%;
+    height: 0.25rem;
+    padding: 0 0.3rem;
 
-    function regexCheck(regex) {
-        return check;
+    background-color: ${(props) => props.theme.colors.grey2};
+    border-radius: 0.125rem;
+`;
+    const Handle = styled__default.default.span`
+    cursor: pointer;
 
-        function check(code2) {
-            return code2 !== null && code2 > -1 && regex.test(String.fromCharCode(code2));
-        }
-    }
+    position: absolute;
+    z-index: 2;
 
-    function normalizeUri(value) {
-        const result = [];
-        let index2 = -1;
-        let start2 = 0;
-        let skip = 0;
-        while (++index2 < value.length) {
-            const code2 = value.charCodeAt(index2);
-            let replace2 = "";
-            if (code2 === 37 && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
-                skip = 2;
-            } else if (code2 < 128) {
-                if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2))) {
-                    replace2 = String.fromCharCode(code2);
-                }
-            } else if (code2 > 55295 && code2 < 57344) {
-                const next2 = value.charCodeAt(index2 + 1);
-                if (code2 < 56320 && next2 > 56319 && next2 < 57344) {
-                    replace2 = String.fromCharCode(code2, next2);
-                    skip = 1;
-                } else {
-                    replace2 = "\uFFFD";
-                }
-            } else {
-                replace2 = String.fromCharCode(code2);
-            }
-            if (replace2) {
-                result.push(value.slice(start2, index2), encodeURIComponent(replace2));
-                start2 = index2 + skip + 1;
-                replace2 = "";
-            }
-            if (skip) {
-                index2 += skip;
-                skip = 0;
-            }
-        }
-        return result.join("") + value.slice(start2);
-    }
+    width: 1rem;
+    height: 1rem;
+    margin-top: ${(props) => props.hasTicks ? "-0.5rem" : "0"};
+    margin-left: -0.6rem;
 
-    function factorySpace(effects, ok2, type2, max2) {
-        const limit = max2 ? max2 - 1 : Number.POSITIVE_INFINITY;
-        let size2 = 0;
-        return start2;
+    background-color: ${(props) => props.theme.colors.primary};
+    border-radius: 50%;
+`;
+    const Track = styled__default.default.span`
+    position: absolute;
 
-        function start2(code2) {
-            if (markdownSpace(code2)) {
-                effects.enter(type2);
-                return prefix(code2);
-            }
-            return ok2(code2);
-        }
+    height: 0.25rem;
+    margin-top: ${(props) => props.hasTicks ? "-0.5rem" : "0"};
 
-        function prefix(code2) {
-            if (markdownSpace(code2) && size2++ < limit) {
-                effects.consume(code2);
-                return prefix;
-            }
-            effects.exit(type2);
-            return ok2(code2);
-        }
-    }
-    const content$2 = {
-        tokenize: initializeContent
-    };
+    background-color: ${(props) => props.theme.colors.primary};
+    border-radius: 0.125rem;
+`;
+    const TrackLabel = styled__default.default.span`
+    position: absolute;
+    z-index: 1;
+    top: -0.3rem;
+    color: ${(props) => props.theme.colors.grey6};
+`;
+    const LabelInner = styled__default.default.span`
+    margin-left: -50%;
+    line-height: 1.5rem;
+`;
+    const SliderTicks = styled__default.default.div`
+    position: relative;
+    margin-top: 0.5rem;
+`;
+    const Tick = styled__default.default.span`
+    position: absolute;
+    font-size: 0.875rem;
+    color: ${(props) => props.theme.colors.grey6};
 
-    function initializeContent(effects) {
-        const contentStart = effects.attempt(
-            this.parser.constructs.contentInitial,
-            afterContentStartConstruct,
-            paragraphInitial
-        );
-        let previous2;
-        return contentStart;
+    &${(props) => props.showLine ? "" : ":not(:first-child):not(:last-child)"}::before {
+        content: '';
 
-        function afterContentStartConstruct(code2) {
-            if (code2 === null) {
-                effects.consume(code2);
-                return;
-            }
-            effects.enter("lineEnding");
-            effects.consume(code2);
-            effects.exit("lineEnding");
-            return factorySpace(effects, contentStart, "linePrefix");
-        }
+        position: absolute;
+        z-index: 1;
+        left: 50%;
 
-        function paragraphInitial(code2) {
-            effects.enter("paragraph");
-            return lineStart(code2);
-        }
+        display: block;
 
-        function lineStart(code2) {
-            const token = effects.enter("chunkText", {
-                contentType: "text",
-                previous: previous2
-            });
-            if (previous2) {
-                previous2.next = token;
-            }
-            previous2 = token;
-            return data2(code2);
-        }
+        width: 0.125rem;
+        height: 0.125rem;
+        margin-top: -0.685rem;
 
-        function data2(code2) {
-            if (code2 === null) {
-                effects.exit("chunkText");
-                effects.exit("paragraph");
-                effects.consume(code2);
-                return;
-            }
-            if (markdownLineEnding(code2)) {
-                effects.consume(code2);
-                effects.exit("chunkText");
-                return lineStart;
-            }
-            effects.consume(code2);
-            return data2;
-        }
+        background-color: ${(props) => props.theme.colors.grey3};
+        border-radius: 50%;
     }
-    const document$2 = {
-        tokenize: initializeDocument
-    };
-    const containerConstruct = {
-        tokenize: tokenizeContainer
-    };
-
-    function initializeDocument(effects) {
-        const self2 = this;
-        const stack = [];
-        let continued = 0;
-        let childFlow;
-        let childToken;
-        let lineStartOffset;
-        return start2;
+`;
+    const SwapButtonWrapper = styled__default.default.div`
+    display: flex;
+    height: fit-content;
+    margin-top: 0.3rem;
+`;
 
-        function start2(code2) {
-            if (continued < stack.length) {
-                const item = stack[continued];
-                self2.containerState = item[1];
-                return effects.attempt(
-                    item[0].continuation,
-                    documentContinue,
-                    checkNewContainers
-                )(code2);
-            }
-            return checkNewContainers(code2);
+    function getTickTransform(idx, length) {
+        if (idx === 0) {
+            return "translateX(-0.7rem)";
         }
+        return idx === length - 1 ? "translateX(-100%) translateX(0.7rem)" : "translateX(-50%)";
+    }
 
-        function documentContinue(code2) {
-            continued++;
-            if (self2.containerState._closeFlow) {
-                self2.containerState._closeFlow = void 0;
-                if (childFlow) {
-                    closeFlow();
-                }
-                const indexBeforeExits = self2.events.length;
-                let indexBeforeFlow = indexBeforeExits;
-                let point2;
-                while (indexBeforeFlow--) {
-                    if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
-                        point2 = self2.events[indexBeforeFlow][1].end;
-                        break;
-                    }
-                }
-                exitContainers(continued);
-                let index2 = indexBeforeExits;
-                while (index2 < self2.events.length) {
-                    self2.events[index2][1].end = Object.assign({}, point2);
-                    index2++;
-                }
-                splice(
-                    self2.events,
-                    indexBeforeFlow + 1,
-                    0,
-                    self2.events.slice(indexBeforeExits)
-                );
-                self2.events.length = index2;
-                return checkNewContainers(code2);
+    function BaseSlider({
+        domain: domain2,
+        getValueLabel,
+        initialValue,
+        onChange: onChange2,
+        step: step2,
+        style: style2,
+        ticks: ticks2 = 5,
+        trackLabels,
+        trackToStart = true,
+        trackToEnd = false,
+        disableInputAlternative = false,
+        values,
+        className
+    }) {
+        const adjustedStep = React.useMemo(() => {
+            if (step2) {
+                return step2;
             }
-            return start2(code2);
-        }
-
-        function checkNewContainers(code2) {
-            if (continued === stack.length) {
-                if (!childFlow) {
-                    return documentContinued(code2);
-                }
-                if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
-                    return flowStart(code2);
+            return computeStep(domain2[1] - domain2[0]);
+        }, [domain2, step2]);
+        const [sliderValues, setSliderValues] = React.useState((values === null || values === void 0 ? void 0 : values.map((v2) => mapToClosestStep(v2, adjustedStep))) || (initialValue === null || initialValue === void 0 ? void 0 : initialValue.map((v2) => mapToClosestStep(v2, adjustedStep))) || [domain2[0]]);
+        const currSliderValues = React.useRef(sliderValues);
+        currSliderValues.current = sliderValues;
+        const isFirstRender = React.useRef(true);
+        React.useEffect(() => {
+            if (values !== void 0) {
+                const mappedValues = values.map((v2) => mapToClosestStep(v2, adjustedStep));
+                if (!isEqual_1(mappedValues, currSliderValues.current)) {
+                    setSliderValues(mappedValues);
                 }
-                self2.interrupt = Boolean(
-                    childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
-                );
             }
-            self2.containerState = {};
-            return effects.check(
-                containerConstruct,
-                thereIsANewContainer,
-                thereIsNoNewContainer
-            )(code2);
-        }
-
-        function thereIsANewContainer(code2) {
-            if (childFlow)
-                closeFlow();
-            exitContainers(continued);
-            return documentContinued(code2);
-        }
-
-        function thereIsNoNewContainer(code2) {
-            self2.parser.lazy[self2.now().line] = continued !== stack.length;
-            lineStartOffset = self2.now().offset;
-            return flowStart(code2);
-        }
-
-        function documentContinued(code2) {
-            self2.containerState = {};
-            return effects.attempt(
-                containerConstruct,
-                containerContinue,
-                flowStart
-            )(code2);
-        }
-
-        function containerContinue(code2) {
-            continued++;
-            stack.push([self2.currentConstruct, self2.containerState]);
-            return documentContinued(code2);
-        }
-
-        function flowStart(code2) {
-            if (code2 === null) {
-                if (childFlow)
-                    closeFlow();
-                exitContainers(0);
-                effects.consume(code2);
-                return;
+        }, [adjustedStep, values]);
+        const [showInputs, setShowInputs] = React.useState(false);
+        const precision2 = React.useMemo(() => Math.floor(adjustedStep) === adjustedStep ? 0 : adjustedStep.toString().split(".")[1].length || 0, [adjustedStep]);
+        const getErrorMsg = React.useCallback((value, index2) => {
+            if (Number.isNaN(value)) {
+                return "Value should not be left blank";
             }
-            childFlow = childFlow || self2.parser.flow(self2.now());
-            effects.enter("chunkFlow", {
-                contentType: "flow",
-                previous: childToken,
-                _tokenizer: childFlow
-            });
-            return flowContinue(code2);
-        }
-
-        function flowContinue(code2) {
-            if (code2 === null) {
-                writeToChild(effects.exit("chunkFlow"), true);
-                exitContainers(0);
-                effects.consume(code2);
-                return;
+            if (value < domain2[0] || value > domain2[1]) {
+                return `Value out of allowed range of ${domain2[0]} - ${domain2[1]}`;
             }
-            if (markdownLineEnding(code2)) {
-                effects.consume(code2);
-                writeToChild(effects.exit("chunkFlow"));
-                continued = 0;
-                self2.interrupt = void 0;
-                return start2;
+            if (index2 > 0 && value < sliderValues[index2 - 1] || index2 < sliderValues.length - 1 && value > sliderValues[index2 + 1]) {
+                return "Values have to be in ascending order";
             }
-            effects.consume(code2);
-            return flowContinue;
-        }
-
-        function writeToChild(token, eof2) {
-            const stream = self2.sliceStream(token);
-            if (eof2)
-                stream.push(null);
-            token.previous = childToken;
-            if (childToken)
-                childToken.next = token;
-            childToken = token;
-            childFlow.defineSkip(token.start);
-            childFlow.write(stream);
-            if (self2.parser.lazy[token.start.line]) {
-                let index2 = childFlow.events.length;
-                while (index2--) {
-                    if (childFlow.events[index2][1].start.offset < lineStartOffset && (!childFlow.events[index2][1].end || childFlow.events[index2][1].end.offset > lineStartOffset)) {
-                        return;
-                    }
+            return "";
+        }, [domain2, sliderValues]);
+        const validateValues = React.useCallback((value) => {
+            for (let index2 = 0; index2 < value.length; index2++) {
+                if (getErrorMsg(value[index2], index2) !== "") {
+                    return false;
                 }
-                const indexBeforeExits = self2.events.length;
-                let indexBeforeFlow = indexBeforeExits;
-                let seen;
-                let point2;
-                while (indexBeforeFlow--) {
-                    if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
-                        if (seen) {
-                            point2 = self2.events[indexBeforeFlow][1].end;
-                            break;
-                        }
-                        seen = true;
-                    }
+            }
+            return true;
+        }, [getErrorMsg]);
+        React.useEffect(
+            () => {
+                if (isFirstRender.current) {
+                    isFirstRender.current = false;
+                    return;
                 }
-                exitContainers(continued);
-                index2 = indexBeforeExits;
-                while (index2 < self2.events.length) {
-                    self2.events[index2][1].end = Object.assign({}, point2);
-                    index2++;
+                if (validateValues(sliderValues)) {
+                    const formattedValues = sliderValues.map(getValueLabel);
+                    onChange2 === null || onChange2 === void 0 ? void 0 : onChange2(formattedValues);
                 }
-                splice(
-                    self2.events,
-                    indexBeforeFlow + 1,
-                    0,
-                    self2.events.slice(indexBeforeExits)
-                );
-                self2.events.length = index2;
-            }
-        }
-
-        function exitContainers(size2) {
-            let index2 = stack.length;
-            while (index2-- > size2) {
-                const entry = stack[index2];
-                self2.containerState = entry[1];
-                entry[0].exit.call(self2, effects);
-            }
-            stack.length = size2;
-        }
-
-        function closeFlow() {
-            childFlow.write([null]);
-            childToken = void 0;
-            childFlow = void 0;
-            self2.containerState._closeFlow = void 0;
-        }
-    }
-
-    function tokenizeContainer(effects, ok2, nok) {
-        return factorySpace(
-            effects,
-            effects.attempt(this.parser.constructs.document, ok2, nok),
-            "linePrefix",
-            this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
+            },
+            useDeepCompare([sliderValues])
         );
+        const onSliderChange = React.useCallback((value) => {
+            setSliderValues(value.map((val) => parseFloat(val.toFixed(precision2))));
+        }, [precision2]);
+        const tickProps = typeof ticks2 === "number" ? {
+            count: ticks2
+        } : {
+            values: ticks2
+        };
+        return jsxRuntime.exports.jsxs(SliderWrapper, {
+            className,
+            children: [jsxRuntime.exports.jsx(SliderInner, {
+                children: showInputs ? jsxRuntime.exports.jsx(SliderInputs, {
+                    domain: domain2,
+                    getErrorMsg,
+                    setSliderValues,
+                    sliderValues
+                }) : jsxRuntime.exports.jsxs(StyledSlider$1, {
+                    domain: domain2,
+                    onChange: onSliderChange,
+                    rootStyle: style2,
+                    step: adjustedStep,
+                    values: sliderValues,
+                    children: [jsxRuntime.exports.jsx(Rail, {
+                        children: ({
+                            getRailProps
+                        }) => jsxRuntime.exports.jsx(SliderRail, Object.assign({}, getRailProps(), {
+                            "data-testid": "rail"
+                        }))
+                    }), jsxRuntime.exports.jsx(Handles, {
+                        children: ({
+                            handles,
+                            getHandleProps
+                        }) => jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, {
+                            children: handles.map((handle2, idx) => jsxRuntime.exports.jsx(Tooltip$1, {
+                                content: getValueLabel(handle2.value),
+                                hideOnClick: false,
+                                interactive: true,
+                                placement: "top",
+                                children: jsxRuntime.exports.jsx(Handle, Object.assign({}, getHandleProps(handle2.id), {
+                                    "data-testid": `handle-${idx}`,
+                                    hasTicks: !!ticks2,
+                                    style: {
+                                        left: `${handle2.percent}%`
+                                    }
+                                }))
+                            }, handle2.id))
+                        })
+                    }), jsxRuntime.exports.jsx(Tracks, {
+                        left: trackToStart,
+                        right: trackToEnd,
+                        children: ({
+                            tracks,
+                            getTrackProps
+                        }) => jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, {
+                            children: tracks.map(({
+                                id: id2,
+                                source,
+                                target
+                            }, idx) => jsxRuntime.exports.jsxs(React.Fragment, {
+                                children: [jsxRuntime.exports.jsx(Track, Object.assign({
+                                    hasTicks: !!ticks2
+                                }, getTrackProps(), {
+                                    "data-testid": `track-${idx}`,
+                                    style: {
+                                        left: `${source.percent}%`,
+                                        width: `${target.percent - source.percent}%`
+                                    }
+                                }), id2), trackLabels && trackLabels.length > 0 && jsxRuntime.exports.jsx(TrackLabel, {
+                                    "data-testid": `track-label-${idx}`,
+                                    style: {
+                                        display: target.percent - source.percent === 0 ? "none" : "flex",
+                                        left: `${(target.percent - source.percent) / 2 + source.percent}%`
+                                    },
+                                    children: jsxRuntime.exports.jsx(LabelInner, {
+                                        children: trackLabels[idx]
+                                    })
+                                }, `label_${id2}`)]
+                            }, id2))
+                        })
+                    }), ticks2 && jsxRuntime.exports.jsx(Ticks, Object.assign({}, tickProps, {
+                        children: ({
+                            ticks: sliderTicks
+                        }) => jsxRuntime.exports.jsx(SliderTicks, {
+                            children: sliderTicks.map((tick, idx) => jsxRuntime.exports.jsx(Tick, {
+                                "data-testid": `tick-${idx}`,
+                                showLine: tick.value !== domain2[0] && tick.value !== domain2[1],
+                                style: {
+                                    left: `${tick.percent}%`,
+                                    transform: getTickTransform(idx, sliderTicks.length)
+                                },
+                                children: getValueLabel(tick.value)
+                            }, tick.id))
+                        })
+                    }))]
+                })
+            }), !disableInputAlternative && sliderValues && jsxRuntime.exports.jsx(Tooltip$1, {
+                content: showInputs ? "Use Slider?" : "Use Input Alternative?",
+                placement: "top",
+                children: jsxRuntime.exports.jsx(SwapButtonWrapper, {
+                    children: jsxRuntime.exports.jsx(SwapHorizontal, {
+                        asButton: true,
+                        onClick: () => setShowInputs(!showInputs),
+                        size: "2x"
+                    })
+                })
+            })]
+        });
     }
 
-    function classifyCharacter(code2) {
-        if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
-            return 1;
-        }
-        if (unicodePunctuation(code2)) {
-            return 2;
-        }
-    }
-
-    function resolveAll(constructs2, events2, context2) {
-        const called = [];
-        let index2 = -1;
-        while (++index2 < constructs2.length) {
-            const resolve2 = constructs2[index2].resolveAll;
-            if (resolve2 && !called.includes(resolve2)) {
-                events2 = resolve2(events2, context2);
-                called.push(resolve2);
-            }
-        }
-        return events2;
+    function Slider$1(props) {
+        return jsxRuntime.exports.jsx(BaseSlider, Object.assign({
+            disableInputAlternative: props.disableInputAlternative
+        }, props, {
+            getValueLabel: (val) => round_1(val, 4)
+        }));
     }
-    const attention = {
-        name: "attention",
-        tokenize: tokenizeAttention,
-        resolveAll: resolveAllAttention
-    };
 
-    function resolveAllAttention(events2, context2) {
-        let index2 = -1;
-        let open;
-        let group;
-        let text2;
-        let openingSequence;
-        let closingSequence;
-        let use;
-        let nextEvents;
-        let offset2;
-        while (++index2 < events2.length) {
-            if (events2[index2][0] === "enter" && events2[index2][1].type === "attentionSequence" && events2[index2][1]._close) {
-                open = index2;
-                while (open--) {
-                    if (events2[open][0] === "exit" && events2[open][1].type === "attentionSequence" && events2[open][1]._open && context2.sliceSerialize(events2[open][1]).charCodeAt(0) === context2.sliceSerialize(events2[index2][1]).charCodeAt(0)) {
-                        if ((events2[open][1]._close || events2[index2][1]._open) && (events2[index2][1].end.offset - events2[index2][1].start.offset) % 3 && !((events2[open][1].end.offset - events2[open][1].start.offset + events2[index2][1].end.offset - events2[index2][1].start.offset) % 3)) {
-                            continue;
-                        }
-                        use = events2[open][1].end.offset - events2[open][1].start.offset > 1 && events2[index2][1].end.offset - events2[index2][1].start.offset > 1 ? 2 : 1;
-                        const start2 = Object.assign({}, events2[open][1].end);
-                        const end2 = Object.assign({}, events2[index2][1].start);
-                        movePoint(start2, -use);
-                        movePoint(end2, use);
-                        openingSequence = {
-                            type: use > 1 ? "strongSequence" : "emphasisSequence",
-                            start: start2,
-                            end: Object.assign({}, events2[open][1].end)
-                        };
-                        closingSequence = {
-                            type: use > 1 ? "strongSequence" : "emphasisSequence",
-                            start: Object.assign({}, events2[index2][1].start),
-                            end: end2
-                        };
-                        text2 = {
-                            type: use > 1 ? "strongText" : "emphasisText",
-                            start: Object.assign({}, events2[open][1].end),
-                            end: Object.assign({}, events2[index2][1].start)
-                        };
-                        group = {
-                            type: use > 1 ? "strong" : "emphasis",
-                            start: Object.assign({}, openingSequence.start),
-                            end: Object.assign({}, closingSequence.end)
-                        };
-                        events2[open][1].end = Object.assign({}, openingSequence.start);
-                        events2[index2][1].start = Object.assign({}, closingSequence.end);
-                        nextEvents = [];
-                        if (events2[open][1].end.offset - events2[open][1].start.offset) {
-                            nextEvents = push$2(nextEvents, [
-                                ["enter", events2[open][1], context2],
-                                ["exit", events2[open][1], context2]
-                            ]);
-                        }
-                        nextEvents = push$2(nextEvents, [
-                            ["enter", group, context2],
-                            ["enter", openingSequence, context2],
-                            ["exit", openingSequence, context2],
-                            ["enter", text2, context2]
-                        ]);
-                        nextEvents = push$2(
-                            nextEvents,
-                            resolveAll(
-                                context2.parser.constructs.insideSpan.null,
-                                events2.slice(open + 1, index2),
-                                context2
-                            )
-                        );
-                        nextEvents = push$2(nextEvents, [
-                            ["exit", text2, context2],
-                            ["enter", closingSequence, context2],
-                            ["exit", closingSequence, context2],
-                            ["exit", group, context2]
-                        ]);
-                        if (events2[index2][1].end.offset - events2[index2][1].start.offset) {
-                            offset2 = 2;
-                            nextEvents = push$2(nextEvents, [
-                                ["enter", events2[index2][1], context2],
-                                ["exit", events2[index2][1], context2]
-                            ]);
-                        } else {
-                            offset2 = 0;
-                        }
-                        splice(events2, open - 1, index2 - open + 3, nextEvents);
-                        index2 = open + nextEvents.length - offset2 - 2;
-                        break;
-                    }
-                }
-            }
-        }
-        index2 = -1;
-        while (++index2 < events2.length) {
-            if (events2[index2][1].type === "attentionSequence") {
-                events2[index2][1].type = "data";
-            }
-        }
-        return events2;
+    function Sun() {
+        const theme2 = useClTheme();
+        return jsxRuntime.exports.jsx("div", {
+            style: {
+                display: "flex",
+                height: "1rem",
+                width: "1rem"
+            },
+            children: jsxRuntime.exports.jsxs("svg", {
+                fill: "none",
+                viewBox: "0 0 200 200",
+                xmlns: "http://www.w3.org/2000/svg",
+                children: [jsxRuntime.exports.jsx("path", {
+                    d: "M138 100C138 120.987 120.987 138 100 138C79.0132 138 62 120.987 62 100C62 79.0132 79.0132 62 100 62C120.987 62 138 79.0132 138 100Z",
+                    fill: theme2.colors.background
+                }), jsxRuntime.exports.jsx("path", {
+                    d: "M87 13C87 5.8203 92.8203 0 100 0C107.18 0 113 5.8203 113 13V31C113 38.1797 107.18 44 100 44C92.8203 44 87 38.1797 87 31V13Z",
+                    fill: theme2.colors.background
+                }), jsxRuntime.exports.jsx("path", {
+                    d: "M87 169C87 161.82 92.8203 156 100 156C107.18 156 113 161.82 113 169V187C113 194.18 107.18 200 100 200C92.8203 200 87 194.18 87 187V169Z",
+                    fill: theme2.colors.background
+                }), jsxRuntime.exports.jsx("path", {
+                    d: "M169 113C161.82 113 156 107.18 156 100C156 92.8203 161.82 87 169 87H187C194.18 87 200 92.8203 200 100C200 107.18 194.18 113 187 113H169Z",
+                    fill: theme2.colors.background
+                }), jsxRuntime.exports.jsx("path", {
+                    d: "M13 113C5.8203 113 0 107.18 0 100C0 92.8203 5.8203 87 13 87H31C38.1797 87 44 92.8203 44 100C44 107.18 38.1797 113 31 113H13Z",
+                    fill: theme2.colors.background
+                }), jsxRuntime.exports.jsx("path", {
+                    d: "M28.1924 46.5772C23.1156 41.5003 23.1156 33.2692 28.1924 28.1924C33.2692 23.1156 41.5003 23.1156 46.5772 28.1924L59.3051 40.9203C64.3819 45.9971 64.3819 54.2283 59.3051 59.3051C54.2283 64.3819 45.9971 64.3819 40.9203 59.3051L28.1924 46.5772Z",
+                    fill: theme2.colors.background
+                }), jsxRuntime.exports.jsx("path", {
+                    d: "M159.579 59.3051C154.502 64.3819 146.271 64.3819 141.194 59.3051C136.118 54.2283 136.118 45.9972 141.194 40.9203L153.922 28.1924C158.999 23.1156 167.23 23.1156 172.307 28.1924C177.384 33.2692 177.384 41.5004 172.307 46.5772L159.579 59.3051Z",
+                    fill: theme2.colors.background
+                }), jsxRuntime.exports.jsx("path", {
+                    d: "M141.192 159.577C136.116 154.5 136.116 146.269 141.192 141.192C146.269 136.116 154.5 136.116 159.577 141.192L172.305 153.92C177.382 158.997 177.382 167.228 172.305 172.305C167.228 177.382 158.997 177.382 153.92 172.305L141.192 159.577Z",
+                    fill: theme2.colors.background
+                }), jsxRuntime.exports.jsx("path", {
+                    d: "M40.9209 141.192C45.9977 136.116 54.2289 136.116 59.3057 141.192C64.3825 146.269 64.3825 154.5 59.3057 159.577L46.5777 172.305C41.5009 177.382 33.2698 177.382 28.193 172.305C23.1162 167.228 23.1162 158.997 28.193 153.92L40.9209 141.192Z",
+                    fill: theme2.colors.background
+                })]
+            })
+        });
     }
+    const SwitchWrapper = styled__default.default.div`
+    cursor: pointer;
 
-    function tokenizeAttention(effects, ok2) {
-        const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
-        const previous2 = this.previous;
-        const before = classifyCharacter(previous2);
-        let marker;
-        return start2;
-
-        function start2(code2) {
-            marker = code2;
-            effects.enter("attentionSequence");
-            return inside2(code2);
-        }
-
-        function inside2(code2) {
-            if (code2 === marker) {
-                effects.consume(code2);
-                return inside2;
-            }
-            const token = effects.exit("attentionSequence");
-            const after = classifyCharacter(code2);
-            const open = !after || after === 2 && before || attentionMarkers2.includes(code2);
-            const close = !before || before === 2 && after || attentionMarkers2.includes(previous2);
-            token._open = Boolean(marker === 42 ? open : open && (before || !close));
-            token._close = Boolean(marker === 42 ? close : close && (after || !open));
-            return ok2(code2);
-        }
-    }
+    position: relative;
 
-    function movePoint(point2, offset2) {
-        point2.column += offset2;
-        point2.offset += offset2;
-        point2._bufferIndex += offset2;
-    }
-    const autolink = {
-        name: "autolink",
-        tokenize: tokenizeAutolink
-    };
+    display: flex;
+    align-items: center;
+    justify-content: ${(props) => props.enabled ? "flex-start" : "flex-end"};
 
-    function tokenizeAutolink(effects, ok2, nok) {
-        let size2 = 0;
-        return start2;
+    width: max-content;
+    height: 1.5rem;
+    padding: 0;
+    padding-right: ${(props) => props.enabled ? "1.75rem" : "0.5rem"};
+    padding-left: ${(props) => props.enabled ? "0.5rem" : "1.75rem"};
 
-        function start2(code2) {
-            effects.enter("autolink");
-            effects.enter("autolinkMarker");
-            effects.consume(code2);
-            effects.exit("autolinkMarker");
-            effects.enter("autolinkProtocol");
-            return open;
-        }
+    font-size: ${(props) => props.theme.font.size};
+    color: ${(props) => props.theme.colors.blue1};
 
-        function open(code2) {
-            if (asciiAlpha(code2)) {
-                effects.consume(code2);
-                return schemeOrEmailAtext;
-            }
-            return emailAtext(code2);
-        }
+    background-color: ${(props) => props.enabled ? props.theme.colors.primary : props.theme.colors.secondary};
+    border-radius: 12px;
 
-        function schemeOrEmailAtext(code2) {
-            if (code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) {
-                size2 = 1;
-                return schemeInsideOrEmailAtext(code2);
-            }
-            return emailAtext(code2);
-        }
+    svg {
+        color: ${(props) => props.theme.colors.blue1};
+    }
+`;
+    const SwitchHandle = styled__default.default.span`
+    position: absolute;
+    top: 2px;
+    left: ${(props) => props.enabled ? "calc(100% - 1.375rem)" : "0.125rem"};
 
-        function schemeInsideOrEmailAtext(code2) {
-            if (code2 === 58) {
-                effects.consume(code2);
-                size2 = 0;
-                return urlInside;
-            }
-            if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size2++ < 32) {
-                effects.consume(code2);
-                return schemeInsideOrEmailAtext;
-            }
-            size2 = 0;
-            return emailAtext(code2);
-        }
+    display: inline-block;
 
-        function urlInside(code2) {
-            if (code2 === 62) {
-                effects.exit("autolinkProtocol");
-                effects.enter("autolinkMarker");
-                effects.consume(code2);
-                effects.exit("autolinkMarker");
-                effects.exit("autolink");
-                return ok2;
-            }
-            if (code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2)) {
-                return nok(code2);
-            }
-            effects.consume(code2);
-            return urlInside;
-        }
+    width: 1.25rem;
+    height: 1.25rem;
 
-        function emailAtext(code2) {
-            if (code2 === 64) {
-                effects.consume(code2);
-                return emailAtSignOrDot;
-            }
-            if (asciiAtext(code2)) {
-                effects.consume(code2);
-                return emailAtext;
-            }
-            return nok(code2);
-        }
+    background-color: ${(props) => props.theme.colors.blue1};
+    border-radius: 0.625rem;
 
-        function emailAtSignOrDot(code2) {
-            return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
-        }
+    transition: left 100ms linear;
+`;
 
-        function emailLabel(code2) {
-            if (code2 === 46) {
-                effects.consume(code2);
-                size2 = 0;
-                return emailAtSignOrDot;
+    function Switch$1({
+        className,
+        initialValue = false,
+        labels = {
+            off: "OFF",
+            on: "ON"
+        },
+        lightDark = false,
+        onChange: onChange2,
+        style: style2,
+        value
+    }, ref2) {
+        const [enabled, setEnabled] = React.useState(value || initialValue);
+        const labelIconToShow = React.useMemo(() => {
+            if (lightDark) {
+                return enabled ? jsxRuntime.exports.jsx(Sun, {}) : jsxRuntime.exports.jsx(Moon, {});
             }
-            if (code2 === 62) {
-                effects.exit("autolinkProtocol").type = "autolinkEmail";
-                effects.enter("autolinkMarker");
-                effects.consume(code2);
-                effects.exit("autolinkMarker");
-                effects.exit("autolink");
-                return ok2;
+            return enabled ? labels.on : labels.off;
+        }, [labels, lightDark, enabled]);
+        React.useEffect(() => {
+            if (value !== void 0) {
+                setEnabled(value);
             }
-            return emailValue(code2);
-        }
-
-        function emailValue(code2) {
-            if ((code2 === 45 || asciiAlphanumeric(code2)) && size2++ < 63) {
-                const next2 = code2 === 45 ? emailValue : emailLabel;
-                effects.consume(code2);
-                return next2;
+        }, [value]);
+        const onClick = () => {
+            if (value === void 0) {
+                setEnabled(!enabled);
             }
-            return nok(code2);
-        }
+            onChange2 === null || onChange2 === void 0 ? void 0 : onChange2(!enabled);
+        };
+        return jsxRuntime.exports.jsxs(SwitchWrapper, {
+            className,
+            "data-testid": "wrapper",
+            enabled,
+            onClick,
+            ref: ref2,
+            style: style2,
+            children: [jsxRuntime.exports.jsx(SwitchHandle, {
+                "data-testid": "handle",
+                enabled
+            }), jsxRuntime.exports.jsx("div", {
+                style: {
+                    userSelect: "none"
+                },
+                children: labelIconToShow
+            })]
+        });
     }
-    const blankLine = {
-        tokenize: tokenizeBlankLine,
-        partial: true
+    const UISwitch = React.forwardRef(Switch$1);
+    var safeIsNaN$1 = Number.isNaN || function ponyfill(value) {
+        return typeof value === "number" && value !== value;
     };
 
-    function tokenizeBlankLine(effects, ok2, nok) {
-        return start2;
-
-        function start2(code2) {
-            return markdownSpace(code2) ? factorySpace(effects, after, "linePrefix")(code2) : after(code2);
+    function isEqual$1(first, second) {
+        if (first === second) {
+            return true;
         }
-
-        function after(code2) {
-            return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
+        if (safeIsNaN$1(first) && safeIsNaN$1(second)) {
+            return true;
         }
+        return false;
     }
-    const blockQuote = {
-        name: "blockQuote",
-        tokenize: tokenizeBlockQuoteStart,
-        continuation: {
-            tokenize: tokenizeBlockQuoteContinuation
-        },
-        exit: exit$1
-    };
-
-    function tokenizeBlockQuoteStart(effects, ok2, nok) {
-        const self2 = this;
-        return start2;
-
-        function start2(code2) {
-            if (code2 === 62) {
-                const state = self2.containerState;
-                if (!state.open) {
-                    effects.enter("blockQuote", {
-                        _container: true
-                    });
-                    state.open = true;
-                }
-                effects.enter("blockQuotePrefix");
-                effects.enter("blockQuoteMarker");
-                effects.consume(code2);
-                effects.exit("blockQuoteMarker");
-                return after;
-            }
-            return nok(code2);
-        }
 
-        function after(code2) {
-            if (markdownSpace(code2)) {
-                effects.enter("blockQuotePrefixWhitespace");
-                effects.consume(code2);
-                effects.exit("blockQuotePrefixWhitespace");
-                effects.exit("blockQuotePrefix");
-                return ok2;
-            }
-            effects.exit("blockQuotePrefix");
-            return ok2(code2);
+    function areInputsEqual$1(newInputs, lastInputs) {
+        if (newInputs.length !== lastInputs.length) {
+            return false;
         }
-    }
-
-    function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
-        const self2 = this;
-        return contStart;
-
-        function contStart(code2) {
-            if (markdownSpace(code2)) {
-                return factorySpace(
-                    effects,
-                    contBefore,
-                    "linePrefix",
-                    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
-                )(code2);
+        for (var i2 = 0; i2 < newInputs.length; i2++) {
+            if (!isEqual$1(newInputs[i2], lastInputs[i2])) {
+                return false;
             }
-            return contBefore(code2);
-        }
-
-        function contBefore(code2) {
-            return effects.attempt(blockQuote, ok2, nok)(code2);
         }
+        return true;
     }
 
-    function exit$1(effects) {
-        effects.exit("blockQuote");
-    }
-    const characterEscape = {
-        name: "characterEscape",
-        tokenize: tokenizeCharacterEscape
-    };
-
-    function tokenizeCharacterEscape(effects, ok2, nok) {
-        return start2;
-
-        function start2(code2) {
-            effects.enter("characterEscape");
-            effects.enter("escapeMarker");
-            effects.consume(code2);
-            effects.exit("escapeMarker");
-            return inside2;
+    function memoizeOne$1(resultFn, isEqual2) {
+        if (isEqual2 === void 0) {
+            isEqual2 = areInputsEqual$1;
         }
+        var cache2 = null;
 
-        function inside2(code2) {
-            if (asciiPunctuation(code2)) {
-                effects.enter("characterEscapeValue");
-                effects.consume(code2);
-                effects.exit("characterEscapeValue");
-                effects.exit("characterEscape");
-                return ok2;
+        function memoized() {
+            var newArgs = [];
+            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
+                newArgs[_i2] = arguments[_i2];
             }
-            return nok(code2);
+            if (cache2 && cache2.lastThis === this && isEqual2(newArgs, cache2.lastArgs)) {
+                return cache2.lastResult;
+            }
+            var lastResult = resultFn.apply(this, newArgs);
+            cache2 = {
+                lastResult,
+                lastArgs: newArgs,
+                lastThis: this
+            };
+            return lastResult;
         }
+        memoized.clear = function clear() {
+            cache2 = null;
+        };
+        return memoized;
     }
-    const characterReference = {
-        name: "characterReference",
-        tokenize: tokenizeCharacterReference
+    var reactTable = {
+        exports: {}
+    };
+    var reactTable_production_min = {
+        exports: {}
     };
+    (function(module2, exports3) {
+        ! function(e3, t2) {
+            t2(exports3, React__default.default);
+        }(commonjsGlobal, function(e3, t2) {
+            function n2(e4, t3, n3, o3, r3, i3, u3) {
+                try {
+                    var l3 = e4[i3](u3),
+                        s3 = l3.value;
+                } catch (e6) {
+                    return void n3(e6);
+                }
+                l3.done ? t3(s3) : Promise.resolve(s3).then(o3, r3);
+            }
 
-    function tokenizeCharacterReference(effects, ok2, nok) {
-        const self2 = this;
-        let size2 = 0;
-        let max2;
-        let test2;
-        return start2;
+            function o2(e4) {
+                return function() {
+                    var t3 = this,
+                        o3 = arguments;
+                    return new Promise(function(r3, i3) {
+                        var u3 = e4.apply(t3, o3);
 
-        function start2(code2) {
-            effects.enter("characterReference");
-            effects.enter("characterReferenceMarker");
-            effects.consume(code2);
-            effects.exit("characterReferenceMarker");
-            return open;
-        }
+                        function l3(e6) {
+                            n2(u3, r3, i3, l3, s3, "next", e6);
+                        }
 
-        function open(code2) {
-            if (code2 === 35) {
-                effects.enter("characterReferenceMarkerNumeric");
-                effects.consume(code2);
-                effects.exit("characterReferenceMarkerNumeric");
-                return numeric2;
+                        function s3(e6) {
+                            n2(u3, r3, i3, l3, s3, "throw", e6);
+                        }
+                        l3(void 0);
+                    });
+                };
             }
-            effects.enter("characterReferenceValue");
-            max2 = 31;
-            test2 = asciiAlphanumeric;
-            return value(code2);
-        }
 
-        function numeric2(code2) {
-            if (code2 === 88 || code2 === 120) {
-                effects.enter("characterReferenceMarkerHexadecimal");
-                effects.consume(code2);
-                effects.exit("characterReferenceMarkerHexadecimal");
-                effects.enter("characterReferenceValue");
-                max2 = 6;
-                test2 = asciiHexDigit;
-                return value;
+            function r2() {
+                return (r2 = Object.assign || function(e4) {
+                    for (var t3 = 1; t3 < arguments.length; t3++) {
+                        var n3 = arguments[t3];
+                        for (var o3 in n3)
+                            Object.prototype.hasOwnProperty.call(n3, o3) && (e4[o3] = n3[o3]);
+                    }
+                    return e4;
+                }).apply(this, arguments);
             }
-            effects.enter("characterReferenceValue");
-            max2 = 7;
-            test2 = asciiDigit;
-            return value(code2);
-        }
 
-        function value(code2) {
-            if (code2 === 59 && size2) {
-                const token = effects.exit("characterReferenceValue");
-                if (test2 === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
-                    return nok(code2);
-                }
-                effects.enter("characterReferenceMarker");
-                effects.consume(code2);
-                effects.exit("characterReferenceMarker");
-                effects.exit("characterReference");
-                return ok2;
-            }
-            if (test2(code2) && size2++ < max2) {
-                effects.consume(code2);
-                return value;
+            function i2(e4, t3) {
+                if (null == e4)
+                    return {};
+                var n3, o3, r3 = {},
+                    i3 = Object.keys(e4);
+                for (o3 = 0; o3 < i3.length; o3++)
+                    n3 = i3[o3], t3.indexOf(n3) >= 0 || (r3[n3] = e4[n3]);
+                return r3;
             }
-            return nok(code2);
-        }
-    }
-    const nonLazyContinuation = {
-        tokenize: tokenizeNonLazyContinuation,
-        partial: true
-    };
-    const codeFenced = {
-        name: "codeFenced",
-        tokenize: tokenizeCodeFenced,
-        concrete: true
-    };
-
-    function tokenizeCodeFenced(effects, ok2, nok) {
-        const self2 = this;
-        const closeStart = {
-            tokenize: tokenizeCloseStart,
-            partial: true
-        };
-        let initialPrefix = 0;
-        let sizeOpen = 0;
-        let marker;
-        return start2;
-
-        function start2(code2) {
-            return beforeSequenceOpen(code2);
-        }
-
-        function beforeSequenceOpen(code2) {
-            const tail = self2.events[self2.events.length - 1];
-            initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
-            marker = code2;
-            effects.enter("codeFenced");
-            effects.enter("codeFencedFence");
-            effects.enter("codeFencedFenceSequence");
-            return sequenceOpen(code2);
-        }
 
-        function sequenceOpen(code2) {
-            if (code2 === marker) {
-                sizeOpen++;
-                effects.consume(code2);
-                return sequenceOpen;
-            }
-            if (sizeOpen < 3) {
-                return nok(code2);
+            function u2(e4) {
+                var t3 = function(e6, t4) {
+                    if ("object" != typeof e6 || null === e6)
+                        return e6;
+                    var n3 = e6[Symbol.toPrimitive];
+                    if (void 0 !== n3) {
+                        var o3 = n3.call(e6, t4 || "default");
+                        if ("object" != typeof o3)
+                            return o3;
+                        throw new TypeError("@@toPrimitive must return a primitive value.");
+                    }
+                    return ("string" === t4 ? String : Number)(e6);
+                }(e4, "string");
+                return "symbol" == typeof t3 ? t3 : String(t3);
             }
-            effects.exit("codeFencedFenceSequence");
-            return markdownSpace(code2) ? factorySpace(effects, infoBefore, "whitespace")(code2) : infoBefore(code2);
-        }
+            t2 = t2 && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
+            var l2 = {
+                    init: "init"
+                },
+                s2 = function(e4) {
+                    var t3 = e4.value;
+                    return void 0 === t3 ? "" : t3;
+                },
+                a2 = function() {
+                    return t2.createElement(t2.Fragment, null, "\xA0");
+                },
+                c2 = {
+                    Cell: s2,
+                    width: 150,
+                    minWidth: 0,
+                    maxWidth: Number.MAX_SAFE_INTEGER
+                };
 
-        function infoBefore(code2) {
-            if (code2 === null || markdownLineEnding(code2)) {
-                effects.exit("codeFencedFence");
-                return self2.interrupt ? ok2(code2) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
+            function d2() {
+                for (var e4 = arguments.length, t3 = new Array(e4), n3 = 0; n3 < e4; n3++)
+                    t3[n3] = arguments[n3];
+                return t3.reduce(function(e6, t4) {
+                    var n4 = t4.style,
+                        o3 = t4.className;
+                    return e6 = r2({}, e6, {}, i2(t4, ["style", "className"])), n4 && (e6.style = e6.style ? r2({}, e6.style || {}, {}, n4 || {}) : n4), o3 && (e6.className = e6.className ? e6.className + " " + o3 : o3), "" === e6.className && delete e6.className, e6;
+                }, {});
             }
-            effects.enter("codeFencedFenceInfo");
-            effects.enter("chunkString", {
-                contentType: "string"
-            });
-            return info(code2);
-        }
+            var f2 = function(e4, t3) {
+                    return void 0 === t3 && (t3 = {}),
+                        function(n3) {
+                            return void 0 === n3 && (n3 = {}), [].concat(e4, [n3]).reduce(function(e6, o3) {
+                                return function e7(t4, n4, o4) {
+                                    return "function" == typeof n4 ? e7({}, n4(t4, o4)) : Array.isArray(n4) ? d2.apply(void 0, [t4].concat(n4)) : d2(t4, n4);
+                                }(e6, o3, r2({}, t3, {
+                                    userProps: n3
+                                }));
+                            }, {});
+                        };
+                },
+                p2 = function(e4, t3, n3, o3) {
+                    return void 0 === n3 && (n3 = {}), e4.reduce(function(e6, t4) {
+                        return t4(e6, n3);
+                    }, t3);
+                },
+                g2 = function(e4, t3, n3) {
+                    return void 0 === n3 && (n3 = {}), e4.forEach(function(e6) {
+                        e6(t3, n3);
+                    });
+                };
 
-        function info(code2) {
-            if (code2 === null || markdownLineEnding(code2)) {
-                effects.exit("chunkString");
-                effects.exit("codeFencedFenceInfo");
-                return infoBefore(code2);
-            }
-            if (markdownSpace(code2)) {
-                effects.exit("chunkString");
-                effects.exit("codeFencedFenceInfo");
-                return factorySpace(effects, metaBefore, "whitespace")(code2);
-            }
-            if (code2 === 96 && code2 === marker) {
-                return nok(code2);
+            function v2(e4, t3, n3, o3) {
+                e4.findIndex(function(e6) {
+                    return e6.pluginName === n3;
+                });
+                t3.forEach(function(t4) {
+                    e4.findIndex(function(e6) {
+                        return e6.pluginName === t4;
+                    });
+                });
             }
-            effects.consume(code2);
-            return info;
-        }
 
-        function metaBefore(code2) {
-            if (code2 === null || markdownLineEnding(code2)) {
-                return infoBefore(code2);
+            function m2(e4, t3) {
+                return "function" == typeof e4 ? e4(t3) : e4;
             }
-            effects.enter("codeFencedFenceMeta");
-            effects.enter("chunkString", {
-                contentType: "string"
-            });
-            return meta2(code2);
-        }
 
-        function meta2(code2) {
-            if (code2 === null || markdownLineEnding(code2)) {
-                effects.exit("chunkString");
-                effects.exit("codeFencedFenceMeta");
-                return infoBefore(code2);
-            }
-            if (code2 === 96 && code2 === marker) {
-                return nok(code2);
+            function h2(e4) {
+                var n3 = t2.useRef();
+                return n3.current = e4, t2.useCallback(function() {
+                    return n3.current;
+                }, []);
             }
-            effects.consume(code2);
-            return meta2;
-        }
-
-        function atNonLazyBreak(code2) {
-            return effects.attempt(closeStart, after, contentBefore)(code2);
-        }
-
-        function contentBefore(code2) {
-            effects.enter("lineEnding");
-            effects.consume(code2);
-            effects.exit("lineEnding");
-            return contentStart;
-        }
-
-        function contentStart(code2) {
-            return initialPrefix > 0 && markdownSpace(code2) ? factorySpace(
-                effects,
-                beforeContentChunk,
-                "linePrefix",
-                initialPrefix + 1
-            )(code2) : beforeContentChunk(code2);
-        }
+            var y2 = "undefined" != typeof document ? t2.useLayoutEffect : t2.useEffect;
 
-        function beforeContentChunk(code2) {
-            if (code2 === null || markdownLineEnding(code2)) {
-                return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
+            function w2(e4, n3) {
+                var o3 = t2.useRef(false);
+                y2(function() {
+                    o3.current && e4(), o3.current = true;
+                }, n3);
             }
-            effects.enter("codeFlowValue");
-            return contentChunk(code2);
-        }
 
-        function contentChunk(code2) {
-            if (code2 === null || markdownLineEnding(code2)) {
-                effects.exit("codeFlowValue");
-                return beforeContentChunk(code2);
+            function R2(e4, t3, n3) {
+                return void 0 === n3 && (n3 = {}),
+                    function(o3, i3) {
+                        void 0 === i3 && (i3 = {});
+                        var u3 = "string" == typeof o3 ? t3[o3] : o3;
+                        if (void 0 === u3)
+                            throw console.info(t3), new Error("Renderer Error \u261D\uFE0F");
+                        return b2(u3, r2({}, e4, {
+                            column: t3
+                        }, n3, {}, i3));
+                    };
             }
-            effects.consume(code2);
-            return contentChunk;
-        }
-
-        function after(code2) {
-            effects.exit("codeFenced");
-            return ok2(code2);
-        }
-
-        function tokenizeCloseStart(effects2, ok3, nok2) {
-            let size2 = 0;
-            return startBefore;
 
-            function startBefore(code2) {
-                effects2.enter("lineEnding");
-                effects2.consume(code2);
-                effects2.exit("lineEnding");
-                return start3;
+            function b2(e4, n3) {
+                return function(e6) {
+                    return "function" == typeof e6 && ((t3 = Object.getPrototypeOf(e6)).prototype && t3.prototype.isReactComponent);
+                    var t3;
+                }(o3 = e4) || "function" == typeof o3 || function(e6) {
+                    return "object" == typeof e6 && "symbol" == typeof e6.$$typeof && ["react.memo", "react.forward_ref"].includes(e6.$$typeof.description);
+                }(o3) ? t2.createElement(e4, n3) : e4;
+                var o3;
             }
 
-            function start3(code2) {
-                effects2.enter("codeFencedFence");
-                return markdownSpace(code2) ? factorySpace(
-                    effects2,
-                    beforeSequenceClose,
-                    "linePrefix",
-                    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
-                )(code2) : beforeSequenceClose(code2);
+            function S2(e4, t3, n3) {
+                return void 0 === n3 && (n3 = 0), e4.map(function(e6) {
+                    return x2(e6 = r2({}, e6, {
+                        parent: t3,
+                        depth: n3
+                    })), e6.columns && (e6.columns = S2(e6.columns, e6, n3 + 1)), e6;
+                });
             }
 
-            function beforeSequenceClose(code2) {
-                if (code2 === marker) {
-                    effects2.enter("codeFencedFenceSequence");
-                    return sequenceClose(code2);
-                }
-                return nok2(code2);
+            function C2(e4) {
+                return G2(e4, "columns");
             }
 
-            function sequenceClose(code2) {
-                if (code2 === marker) {
-                    size2++;
-                    effects2.consume(code2);
-                    return sequenceClose;
-                }
-                if (size2 >= sizeOpen) {
-                    effects2.exit("codeFencedFenceSequence");
-                    return markdownSpace(code2) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code2) : sequenceCloseAfter(code2);
+            function x2(e4) {
+                var t3 = e4.id,
+                    n3 = e4.accessor,
+                    o3 = e4.Header;
+                if ("string" == typeof n3) {
+                    t3 = t3 || n3;
+                    var r3 = n3.split(".");
+                    n3 = function(e6) {
+                        return function(e7, t4, n4) {
+                            if (!t4)
+                                return e7;
+                            var o4, r4 = "function" == typeof t4 ? t4 : JSON.stringify(t4),
+                                i3 = E2.get(r4) || function() {
+                                    var e8 = function(e9) {
+                                        return function e11(t5, n5) {
+                                            void 0 === n5 && (n5 = []);
+                                            if (Array.isArray(t5))
+                                                for (var o5 = 0; o5 < t5.length; o5 += 1)
+                                                    e11(t5[o5], n5);
+                                            else
+                                                n5.push(t5);
+                                            return n5;
+                                        }(e9).map(function(e11) {
+                                            return String(e11).replace(".", "_");
+                                        }).join(".").replace(W2, ".").replace(O2, "").split(".");
+                                    }(t4);
+                                    return E2.set(r4, e8), e8;
+                                }();
+                            try {
+                                o4 = i3.reduce(function(e8, t5) {
+                                    return e8[t5];
+                                }, e7);
+                            } catch (e8) {}
+                            return void 0 !== o4 ? o4 : n4;
+                        }(e6, r3);
+                    };
                 }
-                return nok2(code2);
+                if (!t3 && "string" == typeof o3 && o3 && (t3 = o3), !t3 && e4.columns)
+                    throw console.error(e4), new Error('A column ID (or unique "Header" value) is required!');
+                if (!t3)
+                    throw console.error(e4), new Error("A column ID (or string accessor) is required!");
+                return Object.assign(e4, {
+                    id: t3,
+                    accessor: n3
+                }), e4;
             }
 
-            function sequenceCloseAfter(code2) {
-                if (code2 === null || markdownLineEnding(code2)) {
-                    effects2.exit("codeFencedFence");
-                    return ok3(code2);
-                }
-                return nok2(code2);
+            function P2(e4, t3) {
+                if (!t3)
+                    throw new Error();
+                return Object.assign(e4, r2({
+                    Header: a2,
+                    Footer: a2
+                }, c2, {}, t3, {}, e4)), Object.assign(e4, {
+                    originalWidth: e4.width
+                }), e4;
             }
-        }
-    }
-
-    function tokenizeNonLazyContinuation(effects, ok2, nok) {
-        const self2 = this;
-        return start2;
 
-        function start2(code2) {
-            if (code2 === null) {
-                return nok(code2);
+            function B2(e4, t3, n3) {
+                void 0 === n3 && (n3 = function() {
+                    return {};
+                });
+                for (var o3 = [], i3 = e4, u3 = 0, l3 = function() {
+                        return u3++;
+                    }, s3 = function() {
+                        var e6 = {
+                                headers: []
+                            },
+                            u4 = [],
+                            s4 = i3.some(function(e7) {
+                                return e7.parent;
+                            });
+                        i3.forEach(function(o4) {
+                            var i4, a3 = [].concat(u4).reverse()[0];
+                            if (s4) {
+                                if (o4.parent)
+                                    i4 = r2({}, o4.parent, {
+                                        originalId: o4.parent.id,
+                                        id: o4.parent.id + "_" + l3(),
+                                        headers: [o4]
+                                    }, n3(o4));
+                                else
+                                    i4 = P2(r2({
+                                        originalId: o4.id + "_placeholder",
+                                        id: o4.id + "_placeholder_" + l3(),
+                                        placeholderOf: o4,
+                                        headers: [o4]
+                                    }, n3(o4)), t3);
+                                a3 && a3.originalId === i4.originalId ? a3.headers.push(o4) : u4.push(i4);
+                            }
+                            e6.headers.push(o4);
+                        }), o3.push(e6), i3 = u4;
+                    }; i3.length;)
+                    s3();
+                return o3.reverse();
             }
-            effects.enter("lineEnding");
-            effects.consume(code2);
-            effects.exit("lineEnding");
-            return lineStart;
-        }
-
-        function lineStart(code2) {
-            return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
-        }
-    }
-    const codeIndented = {
-        name: "codeIndented",
-        tokenize: tokenizeCodeIndented
-    };
-    const furtherStart = {
-        tokenize: tokenizeFurtherStart,
-        partial: true
-    };
-
-    function tokenizeCodeIndented(effects, ok2, nok) {
-        const self2 = this;
-        return start2;
-
-        function start2(code2) {
-            effects.enter("codeIndented");
-            return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
-        }
-
-        function afterPrefix(code2) {
-            const tail = self2.events[self2.events.length - 1];
-            return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code2) : nok(code2);
-        }
+            var E2 = /* @__PURE__ */ new Map();
 
-        function atBreak(code2) {
-            if (code2 === null) {
-                return after(code2);
-            }
-            if (markdownLineEnding(code2)) {
-                return effects.attempt(furtherStart, atBreak, after)(code2);
+            function I2() {
+                for (var e4 = arguments.length, t3 = new Array(e4), n3 = 0; n3 < e4; n3++)
+                    t3[n3] = arguments[n3];
+                for (var o3 = 0; o3 < t3.length; o3 += 1)
+                    if (void 0 !== t3[o3])
+                        return t3[o3];
             }
-            effects.enter("codeFlowValue");
-            return inside2(code2);
-        }
 
-        function inside2(code2) {
-            if (code2 === null || markdownLineEnding(code2)) {
-                effects.exit("codeFlowValue");
-                return atBreak(code2);
+            function F2(e4) {
+                if ("function" == typeof e4)
+                    return e4;
             }
-            effects.consume(code2);
-            return inside2;
-        }
 
-        function after(code2) {
-            effects.exit("codeIndented");
-            return ok2(code2);
-        }
-    }
+            function G2(e4, t3) {
+                var n3 = [];
+                return function e6(o3) {
+                    o3.forEach(function(o4) {
+                        o4[t3] ? e6(o4[t3]) : n3.push(o4);
+                    });
+                }(e4), n3;
+            }
 
-    function tokenizeFurtherStart(effects, ok2, nok) {
-        const self2 = this;
-        return furtherStart2;
+            function A2(e4, t3) {
+                var n3 = t3.manualExpandedKey,
+                    o3 = t3.expanded,
+                    r3 = t3.expandSubRows,
+                    i3 = void 0 === r3 || r3,
+                    u3 = [];
+                return e4.forEach(function(e6) {
+                    return function e7(t4, r4) {
+                        void 0 === r4 && (r4 = true), t4.isExpanded = t4.original && t4.original[n3] || o3[t4.id], t4.canExpand = t4.subRows && !!t4.subRows.length, r4 && u3.push(t4), t4.subRows && t4.subRows.length && t4.isExpanded && t4.subRows.forEach(function(t5) {
+                            return e7(t5, i3);
+                        });
+                    }(e6);
+                }), u3;
+            }
 
-        function furtherStart2(code2) {
-            if (self2.parser.lazy[self2.now().line]) {
-                return nok(code2);
+            function k2(e4, t3, n3) {
+                return F2(e4) || t3[e4] || n3[e4] || n3.text;
             }
-            if (markdownLineEnding(code2)) {
-                effects.enter("lineEnding");
-                effects.consume(code2);
-                effects.exit("lineEnding");
-                return furtherStart2;
+
+            function H2(e4, t3, n3) {
+                return e4 ? e4(t3, n3) : void 0 === t3;
             }
-            return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
-        }
 
-        function afterPrefix(code2) {
-            const tail = self2.events[self2.events.length - 1];
-            return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok2(code2) : markdownLineEnding(code2) ? furtherStart2(code2) : nok(code2);
-        }
-    }
-    const codeText = {
-        name: "codeText",
-        tokenize: tokenizeCodeText,
-        resolve: resolveCodeText,
-        previous: previous$1
-    };
+            function T2() {
+                throw new Error("React-Table: You have not called prepareRow(row) one or more rows you are attempting to render.");
+            }
+            var z2 = null;
+            var W2 = /\[/g,
+                O2 = /\]/g;
+            var M2 = function(e4) {
+                    return r2({
+                        role: "table"
+                    }, e4);
+                },
+                j2 = function(e4) {
+                    return r2({
+                        role: "rowgroup"
+                    }, e4);
+                },
+                N2 = function(e4, t3) {
+                    var n3 = t3.column;
+                    return r2({
+                        key: "header_" + n3.id,
+                        colSpan: n3.totalVisibleHeaderCount,
+                        role: "columnheader"
+                    }, e4);
+                },
+                L2 = function(e4, t3) {
+                    var n3 = t3.column;
+                    return r2({
+                        key: "footer_" + n3.id,
+                        colSpan: n3.totalVisibleHeaderCount
+                    }, e4);
+                },
+                D2 = function(e4, t3) {
+                    return r2({
+                        key: "headerGroup_" + t3.index,
+                        role: "row"
+                    }, e4);
+                },
+                V2 = function(e4, t3) {
+                    return r2({
+                        key: "footerGroup_" + t3.index
+                    }, e4);
+                },
+                _2 = function(e4, t3) {
+                    return r2({
+                        key: "row_" + t3.row.id,
+                        role: "row"
+                    }, e4);
+                },
+                X2 = function(e4, t3) {
+                    var n3 = t3.cell;
+                    return r2({
+                        key: "cell_" + n3.row.id + "_" + n3.column.id,
+                        role: "cell"
+                    }, e4);
+                };
 
-    function resolveCodeText(events2) {
-        let tailExitIndex = events2.length - 4;
-        let headEnterIndex = 3;
-        let index2;
-        let enter;
-        if ((events2[headEnterIndex][1].type === "lineEnding" || events2[headEnterIndex][1].type === "space") && (events2[tailExitIndex][1].type === "lineEnding" || events2[tailExitIndex][1].type === "space")) {
-            index2 = headEnterIndex;
-            while (++index2 < tailExitIndex) {
-                if (events2[index2][1].type === "codeTextData") {
-                    events2[headEnterIndex][1].type = "codeTextPadding";
-                    events2[tailExitIndex][1].type = "codeTextPadding";
-                    headEnterIndex += 2;
-                    tailExitIndex -= 2;
-                    break;
-                }
+            function q2() {
+                return {
+                    useOptions: [],
+                    stateReducers: [],
+                    useControlledState: [],
+                    columns: [],
+                    columnsDeps: [],
+                    allColumns: [],
+                    allColumnsDeps: [],
+                    accessValue: [],
+                    materializedColumns: [],
+                    materializedColumnsDeps: [],
+                    useInstanceAfterData: [],
+                    visibleColumns: [],
+                    visibleColumnsDeps: [],
+                    headerGroups: [],
+                    headerGroupsDeps: [],
+                    useInstanceBeforeDimensions: [],
+                    useInstance: [],
+                    prepareRow: [],
+                    getTableProps: [M2],
+                    getTableBodyProps: [j2],
+                    getHeaderGroupProps: [D2],
+                    getFooterGroupProps: [V2],
+                    getHeaderProps: [N2],
+                    getFooterProps: [L2],
+                    getRowProps: [_2],
+                    getCellProps: [X2],
+                    useFinalInstance: []
+                };
             }
-        }
-        index2 = headEnterIndex - 1;
-        tailExitIndex++;
-        while (++index2 <= tailExitIndex) {
-            if (enter === void 0) {
-                if (index2 !== tailExitIndex && events2[index2][1].type !== "lineEnding") {
-                    enter = index2;
-                }
-            } else if (index2 === tailExitIndex || events2[index2][1].type === "lineEnding") {
-                events2[enter][1].type = "codeTextData";
-                if (index2 !== enter + 2) {
-                    events2[enter][1].end = events2[index2 - 1][1].end;
-                    events2.splice(enter + 2, index2 - enter - 2);
-                    tailExitIndex -= index2 - enter - 2;
-                    index2 = enter + 2;
+            l2.resetHiddenColumns = "resetHiddenColumns", l2.toggleHideColumn = "toggleHideColumn", l2.setHiddenColumns = "setHiddenColumns", l2.toggleHideAllColumns = "toggleHideAllColumns";
+            var K2 = function(e4) {
+                e4.getToggleHiddenProps = [U2], e4.getToggleHideAllColumnsProps = [$2], e4.stateReducers.push(J2), e4.useInstanceBeforeDimensions.push(Y2), e4.headerGroupsDeps.push(function(e6, t3) {
+                    var n3 = t3.instance;
+                    return [].concat(e6, [n3.state.hiddenColumns]);
+                }), e4.useInstance.push(Q2);
+            };
+            K2.pluginName = "useColumnVisibility";
+            var U2 = function(e4, t3) {
+                    var n3 = t3.column;
+                    return [e4, {
+                        onChange: function(e6) {
+                            n3.toggleHidden(!e6.target.checked);
+                        },
+                        style: {
+                            cursor: "pointer"
+                        },
+                        checked: n3.isVisible,
+                        title: "Toggle Column Visible"
+                    }];
+                },
+                $2 = function(e4, t3) {
+                    var n3 = t3.instance;
+                    return [e4, {
+                        onChange: function(e6) {
+                            n3.toggleHideAllColumns(!e6.target.checked);
+                        },
+                        style: {
+                            cursor: "pointer"
+                        },
+                        checked: !n3.allColumnsHidden && !n3.state.hiddenColumns.length,
+                        title: "Toggle All Columns Hidden",
+                        indeterminate: !n3.allColumnsHidden && n3.state.hiddenColumns.length
+                    }];
+                };
+
+            function J2(e4, t3, n3, o3) {
+                if (t3.type === l2.init)
+                    return r2({
+                        hiddenColumns: []
+                    }, e4);
+                if (t3.type === l2.resetHiddenColumns)
+                    return r2({}, e4, {
+                        hiddenColumns: o3.initialState.hiddenColumns || []
+                    });
+                if (t3.type === l2.toggleHideColumn) {
+                    var i3 = (void 0 !== t3.value ? t3.value : !e4.hiddenColumns.includes(t3.columnId)) ? [].concat(e4.hiddenColumns, [t3.columnId]) : e4.hiddenColumns.filter(function(e6) {
+                        return e6 !== t3.columnId;
+                    });
+                    return r2({}, e4, {
+                        hiddenColumns: i3
+                    });
                 }
-                enter = void 0;
+                return t3.type === l2.setHiddenColumns ? r2({}, e4, {
+                    hiddenColumns: m2(t3.value, e4.hiddenColumns)
+                }) : t3.type === l2.toggleHideAllColumns ? r2({}, e4, {
+                    hiddenColumns: (void 0 !== t3.value ? t3.value : !e4.hiddenColumns.length) ? o3.allColumns.map(function(e6) {
+                        return e6.id;
+                    }) : []
+                }) : void 0;
             }
-        }
-        return events2;
-    }
-
-    function previous$1(code2) {
-        return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
-    }
-
-    function tokenizeCodeText(effects, ok2, nok) {
-        let sizeOpen = 0;
-        let size2;
-        let token;
-        return start2;
-
-        function start2(code2) {
-            effects.enter("codeText");
-            effects.enter("codeTextSequence");
-            return sequenceOpen(code2);
-        }
 
-        function sequenceOpen(code2) {
-            if (code2 === 96) {
-                effects.consume(code2);
-                sizeOpen++;
-                return sequenceOpen;
+            function Y2(e4) {
+                var n3 = e4.headers,
+                    o3 = e4.state.hiddenColumns;
+                t2.useRef(false).current;
+                var r3 = 0;
+                n3.forEach(function(e6) {
+                    return r3 += function e7(t3, n4) {
+                        t3.isVisible = n4 && !o3.includes(t3.id);
+                        var r4 = 0;
+                        return t3.headers && t3.headers.length ? t3.headers.forEach(function(n5) {
+                            return r4 += e7(n5, t3.isVisible);
+                        }) : r4 = t3.isVisible ? 1 : 0, t3.totalVisibleHeaderCount = r4, r4;
+                    }(e6, true);
+                });
             }
-            effects.exit("codeTextSequence");
-            return between(code2);
-        }
 
-        function between(code2) {
-            if (code2 === null) {
-                return nok(code2);
-            }
-            if (code2 === 32) {
-                effects.enter("space");
-                effects.consume(code2);
-                effects.exit("space");
-                return between;
-            }
-            if (code2 === 96) {
-                token = effects.enter("codeTextSequence");
-                size2 = 0;
-                return sequenceClose(code2);
-            }
-            if (markdownLineEnding(code2)) {
-                effects.enter("lineEnding");
-                effects.consume(code2);
-                effects.exit("lineEnding");
-                return between;
+            function Q2(e4) {
+                var n3 = e4.columns,
+                    o3 = e4.flatHeaders,
+                    r3 = e4.dispatch,
+                    i3 = e4.allColumns,
+                    u3 = e4.getHooks,
+                    s3 = e4.state.hiddenColumns,
+                    a3 = e4.autoResetHiddenColumns,
+                    c3 = void 0 === a3 || a3,
+                    d3 = h2(e4),
+                    p3 = i3.length === s3.length,
+                    g3 = t2.useCallback(function(e6, t3) {
+                        return r3({
+                            type: l2.toggleHideColumn,
+                            columnId: e6,
+                            value: t3
+                        });
+                    }, [r3]),
+                    v3 = t2.useCallback(function(e6) {
+                        return r3({
+                            type: l2.setHiddenColumns,
+                            value: e6
+                        });
+                    }, [r3]),
+                    m3 = t2.useCallback(function(e6) {
+                        return r3({
+                            type: l2.toggleHideAllColumns,
+                            value: e6
+                        });
+                    }, [r3]),
+                    y3 = f2(u3().getToggleHideAllColumnsProps, {
+                        instance: d3()
+                    });
+                o3.forEach(function(e6) {
+                    e6.toggleHidden = function(t3) {
+                        r3({
+                            type: l2.toggleHideColumn,
+                            columnId: e6.id,
+                            value: t3
+                        });
+                    }, e6.getToggleHiddenProps = f2(u3().getToggleHiddenProps, {
+                        instance: d3(),
+                        column: e6
+                    });
+                });
+                var R3 = h2(c3);
+                w2(function() {
+                    R3() && r3({
+                        type: l2.resetHiddenColumns
+                    });
+                }, [r3, n3]), Object.assign(e4, {
+                    allColumnsHidden: p3,
+                    toggleHideColumn: g3,
+                    setHiddenColumns: v3,
+                    toggleHideAllColumns: m3,
+                    getToggleHideAllColumnsProps: y3
+                });
             }
-            effects.enter("codeTextData");
-            return data2(code2);
-        }
+            var Z2 = {},
+                ee = {},
+                te2 = function(e4, t3, n3) {
+                    return e4;
+                },
+                ne = function(e4, t3) {
+                    return e4.subRows || [];
+                },
+                oe2 = function(e4, t3, n3) {
+                    return "" + (n3 ? [n3.id, t3].join(".") : t3);
+                },
+                re2 = function(e4) {
+                    return e4;
+                };
 
-        function data2(code2) {
-            if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
-                effects.exit("codeTextData");
-                return between(code2);
+            function ie2(e4) {
+                var t3 = e4.initialState,
+                    n3 = void 0 === t3 ? Z2 : t3,
+                    o3 = e4.defaultColumn,
+                    u3 = void 0 === o3 ? ee : o3,
+                    l3 = e4.getSubRows,
+                    s3 = void 0 === l3 ? ne : l3,
+                    a3 = e4.getRowId,
+                    c3 = void 0 === a3 ? oe2 : a3,
+                    d3 = e4.stateReducer,
+                    f3 = void 0 === d3 ? te2 : d3,
+                    p3 = e4.useControlledState,
+                    g3 = void 0 === p3 ? re2 : p3;
+                return r2({}, i2(e4, ["initialState", "defaultColumn", "getSubRows", "getRowId", "stateReducer", "useControlledState"]), {
+                    initialState: n3,
+                    defaultColumn: u3,
+                    getSubRows: s3,
+                    getRowId: c3,
+                    stateReducer: f3,
+                    useControlledState: g3
+                });
             }
-            effects.consume(code2);
-            return data2;
-        }
 
-        function sequenceClose(code2) {
-            if (code2 === 96) {
-                effects.consume(code2);
-                size2++;
-                return sequenceClose;
-            }
-            if (size2 === sizeOpen) {
-                effects.exit("codeTextSequence");
-                effects.exit("codeText");
-                return ok2(code2);
+            function ue2(e4, t3) {
+                void 0 === t3 && (t3 = 0);
+                var n3 = 0,
+                    o3 = 0,
+                    r3 = 0,
+                    i3 = 0;
+                return e4.forEach(function(e6) {
+                    var u3 = e6.headers;
+                    if (e6.totalLeft = t3, u3 && u3.length) {
+                        var l3 = ue2(u3, t3),
+                            s3 = l3[0],
+                            a3 = l3[1],
+                            c3 = l3[2],
+                            d3 = l3[3];
+                        e6.totalMinWidth = s3, e6.totalWidth = a3, e6.totalMaxWidth = c3, e6.totalFlexWidth = d3;
+                    } else
+                        e6.totalMinWidth = e6.minWidth, e6.totalWidth = Math.min(Math.max(e6.minWidth, e6.width), e6.maxWidth), e6.totalMaxWidth = e6.maxWidth, e6.totalFlexWidth = e6.canResize ? e6.totalWidth : 0;
+                    e6.isVisible && (t3 += e6.totalWidth, n3 += e6.totalMinWidth, o3 += e6.totalWidth, r3 += e6.totalMaxWidth, i3 += e6.totalFlexWidth);
+                }), [n3, o3, r3, i3];
             }
-            token.type = "codeTextData";
-            return data2(code2);
-        }
-    }
 
-    function subtokenize(events2) {
-        const jumps = {};
-        let index2 = -1;
-        let event2;
-        let lineIndex;
-        let otherIndex;
-        let otherEvent;
-        let parameters;
-        let subevents;
-        let more;
-        while (++index2 < events2.length) {
-            while (index2 in jumps) {
-                index2 = jumps[index2];
-            }
-            event2 = events2[index2];
-            if (index2 && event2[1].type === "chunkFlow" && events2[index2 - 1][1].type === "listItemPrefix") {
-                subevents = event2[1]._tokenizer.events;
-                otherIndex = 0;
-                if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
-                    otherIndex += 2;
-                }
-                if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
-                    while (++otherIndex < subevents.length) {
-                        if (subevents[otherIndex][1].type === "content") {
-                            break;
-                        }
-                        if (subevents[otherIndex][1].type === "chunkText") {
-                            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
-                            otherIndex++;
+            function le2(e4) {
+                var t3 = e4.data,
+                    n3 = e4.rows,
+                    o3 = e4.flatRows,
+                    r3 = e4.rowsById,
+                    i3 = e4.column,
+                    u3 = e4.getRowId,
+                    l3 = e4.getSubRows,
+                    s3 = e4.accessValueHooks,
+                    a3 = e4.getInstance;
+                t3.forEach(function(e6, c3) {
+                    return function e7(n4, c4, d3, f3, g3) {
+                        void 0 === d3 && (d3 = 0);
+                        var v3 = n4,
+                            m3 = u3(n4, c4, f3),
+                            h3 = r3[m3];
+                        if (h3)
+                            h3.subRows && h3.originalSubRows.forEach(function(t4, n5) {
+                                return e7(t4, n5, d3 + 1, h3);
+                            });
+                        else if ((h3 = {
+                                id: m3,
+                                original: v3,
+                                index: c4,
+                                depth: d3,
+                                cells: [{}]
+                            }).cells.map = T2, h3.cells.filter = T2, h3.cells.forEach = T2, h3.cells[0].getCellProps = T2, h3.values = {}, g3.push(h3), o3.push(h3), r3[m3] = h3, h3.originalSubRows = l3(n4, c4), h3.originalSubRows) {
+                            var y3 = [];
+                            h3.originalSubRows.forEach(function(t4, n5) {
+                                return e7(t4, n5, d3 + 1, h3, y3);
+                            }), h3.subRows = y3;
                         }
-                    }
-                }
+                        i3.accessor && (h3.values[i3.id] = i3.accessor(n4, c4, h3, g3, t3)), h3.values[i3.id] = p2(s3, h3.values[i3.id], {
+                            row: h3,
+                            column: i3,
+                            instance: a3()
+                        });
+                    }(e6, c3, 0, void 0, n3);
+                });
             }
-            if (event2[0] === "enter") {
-                if (event2[1].contentType) {
-                    Object.assign(jumps, subcontent(events2, index2));
-                    index2 = jumps[index2];
-                    more = true;
-                }
-            } else if (event2[1]._container) {
-                otherIndex = index2;
-                lineIndex = void 0;
-                while (otherIndex--) {
-                    otherEvent = events2[otherIndex];
-                    if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
-                        if (otherEvent[0] === "enter") {
-                            if (lineIndex) {
-                                events2[lineIndex][1].type = "lineEndingBlank";
-                            }
-                            otherEvent[1].type = "lineEnding";
-                            lineIndex = otherIndex;
-                        }
-                    } else {
-                        break;
+            l2.resetExpanded = "resetExpanded", l2.toggleRowExpanded = "toggleRowExpanded", l2.toggleAllRowsExpanded = "toggleAllRowsExpanded";
+            var se2 = function(e4) {
+                e4.getToggleAllRowsExpandedProps = [ae2], e4.getToggleRowExpandedProps = [ce2], e4.stateReducers.push(de2), e4.useInstance.push(fe2), e4.prepareRow.push(pe2);
+            };
+            se2.pluginName = "useExpanded";
+            var ae2 = function(e4, t3) {
+                    var n3 = t3.instance;
+                    return [e4, {
+                        onClick: function(e6) {
+                            n3.toggleAllRowsExpanded();
+                        },
+                        style: {
+                            cursor: "pointer"
+                        },
+                        title: "Toggle All Rows Expanded"
+                    }];
+                },
+                ce2 = function(e4, t3) {
+                    var n3 = t3.row;
+                    return [e4, {
+                        onClick: function() {
+                            n3.toggleRowExpanded();
+                        },
+                        style: {
+                            cursor: "pointer"
+                        },
+                        title: "Toggle Row Expanded"
+                    }];
+                };
+
+            function de2(e4, t3, n3, o3) {
+                if (t3.type === l2.init)
+                    return r2({
+                        expanded: {}
+                    }, e4);
+                if (t3.type === l2.resetExpanded)
+                    return r2({}, e4, {
+                        expanded: o3.initialState.expanded || {}
+                    });
+                if (t3.type === l2.toggleAllRowsExpanded) {
+                    var s3 = t3.value,
+                        a3 = o3.isAllRowsExpanded,
+                        c3 = o3.rowsById;
+                    if (void 0 !== s3 ? s3 : !a3) {
+                        var d3 = {};
+                        return Object.keys(c3).forEach(function(e6) {
+                            d3[e6] = true;
+                        }), r2({}, e4, {
+                            expanded: d3
+                        });
                     }
+                    return r2({}, e4, {
+                        expanded: {}
+                    });
                 }
-                if (lineIndex) {
-                    event2[1].end = Object.assign({}, events2[lineIndex][1].start);
-                    parameters = events2.slice(lineIndex, index2);
-                    parameters.unshift(event2);
-                    splice(events2, lineIndex, index2 - lineIndex + 1, parameters);
+                if (t3.type === l2.toggleRowExpanded) {
+                    var f3, p3 = t3.id,
+                        g3 = t3.value,
+                        v3 = e4.expanded[p3],
+                        m3 = void 0 !== g3 ? g3 : !v3;
+                    if (!v3 && m3)
+                        return r2({}, e4, {
+                            expanded: r2({}, e4.expanded, (f3 = {}, f3[p3] = true, f3))
+                        });
+                    if (v3 && !m3) {
+                        var h3 = e4.expanded;
+                        h3[p3];
+                        return r2({}, e4, {
+                            expanded: i2(h3, [p3].map(u2))
+                        });
+                    }
+                    return e4;
                 }
             }
-        }
-        return !more;
-    }
 
-    function subcontent(events2, eventIndex) {
-        const token = events2[eventIndex][1];
-        const context2 = events2[eventIndex][2];
-        let startPosition = eventIndex - 1;
-        const startPositions = [];
-        const tokenizer2 = token._tokenizer || context2.parser[token.contentType](token.start);
-        const childEvents = tokenizer2.events;
-        const jumps = [];
-        const gaps = {};
-        let stream;
-        let previous2;
-        let index2 = -1;
-        let current2 = token;
-        let adjust = 0;
-        let start2 = 0;
-        const breaks = [start2];
-        while (current2) {
-            while (events2[++startPosition][1] !== current2) {}
-            startPositions.push(startPosition);
-            if (!current2._tokenizer) {
-                stream = context2.sliceStream(current2);
-                if (!current2.next) {
-                    stream.push(null);
-                }
-                if (previous2) {
-                    tokenizer2.defineSkip(current2.start);
-                }
-                if (current2._isInFirstContentOfListItem) {
-                    tokenizer2._gfmTasklistFirstContentOfListItem = true;
-                }
-                tokenizer2.write(stream);
-                if (current2._isInFirstContentOfListItem) {
-                    tokenizer2._gfmTasklistFirstContentOfListItem = void 0;
-                }
-            }
-            previous2 = current2;
-            current2 = current2.next;
-        }
-        current2 = token;
-        while (++index2 < childEvents.length) {
-            if (childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line) {
-                start2 = index2 + 1;
-                breaks.push(start2);
-                current2._tokenizer = void 0;
-                current2.previous = void 0;
-                current2 = current2.next;
+            function fe2(e4) {
+                var n3 = e4.data,
+                    o3 = e4.rows,
+                    r3 = e4.rowsById,
+                    i3 = e4.manualExpandedKey,
+                    u3 = void 0 === i3 ? "expanded" : i3,
+                    s3 = e4.paginateExpandedRows,
+                    a3 = void 0 === s3 || s3,
+                    c3 = e4.expandSubRows,
+                    d3 = void 0 === c3 || c3,
+                    p3 = e4.autoResetExpanded,
+                    g3 = void 0 === p3 || p3,
+                    m3 = e4.getHooks,
+                    y3 = e4.plugins,
+                    R3 = e4.state.expanded,
+                    b3 = e4.dispatch;
+                v2(y3, ["useSortBy", "useGroupBy", "usePivotColumns", "useGlobalFilter"], "useExpanded");
+                var S3 = h2(g3),
+                    C3 = Boolean(Object.keys(r3).length && Object.keys(R3).length);
+                C3 && Object.keys(r3).some(function(e6) {
+                    return !R3[e6];
+                }) && (C3 = false), w2(function() {
+                    S3() && b3({
+                        type: l2.resetExpanded
+                    });
+                }, [b3, n3]);
+                var x3 = t2.useCallback(function(e6, t3) {
+                        b3({
+                            type: l2.toggleRowExpanded,
+                            id: e6,
+                            value: t3
+                        });
+                    }, [b3]),
+                    P3 = t2.useCallback(function(e6) {
+                        return b3({
+                            type: l2.toggleAllRowsExpanded,
+                            value: e6
+                        });
+                    }, [b3]),
+                    B3 = t2.useMemo(function() {
+                        return a3 ? A2(o3, {
+                            manualExpandedKey: u3,
+                            expanded: R3,
+                            expandSubRows: d3
+                        }) : o3;
+                    }, [a3, o3, u3, R3, d3]),
+                    E3 = t2.useMemo(function() {
+                        return function(e6) {
+                            var t3 = 0;
+                            return Object.keys(e6).forEach(function(e7) {
+                                var n4 = e7.split(".");
+                                t3 = Math.max(t3, n4.length);
+                            }), t3;
+                        }(R3);
+                    }, [R3]),
+                    I3 = h2(e4),
+                    F3 = f2(m3().getToggleAllRowsExpandedProps, {
+                        instance: I3()
+                    });
+                Object.assign(e4, {
+                    preExpandedRows: o3,
+                    expandedRows: B3,
+                    rows: B3,
+                    expandedDepth: E3,
+                    isAllRowsExpanded: C3,
+                    toggleRowExpanded: x3,
+                    toggleAllRowsExpanded: P3,
+                    getToggleAllRowsExpandedProps: F3
+                });
             }
-        }
-        tokenizer2.events = [];
-        if (current2) {
-            current2._tokenizer = void 0;
-            current2.previous = void 0;
-        } else {
-            breaks.pop();
-        }
-        index2 = breaks.length;
-        while (index2--) {
-            const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
-            const start3 = startPositions.pop();
-            jumps.unshift([start3, start3 + slice.length - 1]);
-            splice(events2, start3, 2, slice);
-        }
-        index2 = -1;
-        while (++index2 < jumps.length) {
-            gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
-            adjust += jumps[index2][1] - jumps[index2][0] - 1;
-        }
-        return gaps;
-    }
-    const content$1 = {
-        tokenize: tokenizeContent,
-        resolve: resolveContent
-    };
-    const continuationConstruct = {
-        tokenize: tokenizeContinuation,
-        partial: true
-    };
-
-    function resolveContent(events2) {
-        subtokenize(events2);
-        return events2;
-    }
-
-    function tokenizeContent(effects, ok2) {
-        let previous2;
-        return chunkStart;
-
-        function chunkStart(code2) {
-            effects.enter("content");
-            previous2 = effects.enter("chunkContent", {
-                contentType: "content"
-            });
-            return chunkInside(code2);
-        }
 
-        function chunkInside(code2) {
-            if (code2 === null) {
-                return contentEnd(code2);
-            }
-            if (markdownLineEnding(code2)) {
-                return effects.check(
-                    continuationConstruct,
-                    contentContinue,
-                    contentEnd
-                )(code2);
+            function pe2(e4, t3) {
+                var n3 = t3.instance.getHooks,
+                    o3 = t3.instance;
+                e4.toggleRowExpanded = function(t4) {
+                    return o3.toggleRowExpanded(e4.id, t4);
+                }, e4.getToggleRowExpandedProps = f2(n3().getToggleRowExpandedProps, {
+                    instance: o3,
+                    row: e4
+                });
             }
-            effects.consume(code2);
-            return chunkInside;
-        }
-
-        function contentEnd(code2) {
-            effects.exit("chunkContent");
-            effects.exit("content");
-            return ok2(code2);
-        }
-
-        function contentContinue(code2) {
-            effects.consume(code2);
-            effects.exit("chunkContent");
-            previous2.next = effects.enter("chunkContent", {
-                contentType: "content",
-                previous: previous2
+            var ge2 = function(e4, t3, n3) {
+                return e4 = e4.filter(function(e6) {
+                    return t3.some(function(t4) {
+                        var o3 = e6.values[t4];
+                        return String(o3).toLowerCase().includes(String(n3).toLowerCase());
+                    });
+                });
+            };
+            ge2.autoRemove = function(e4) {
+                return !e4;
+            };
+            var ve2 = function(e4, t3, n3) {
+                return e4.filter(function(e6) {
+                    return t3.some(function(t4) {
+                        var o3 = e6.values[t4];
+                        return void 0 === o3 || String(o3).toLowerCase() === String(n3).toLowerCase();
+                    });
+                });
+            };
+            ve2.autoRemove = function(e4) {
+                return !e4;
+            };
+            var me2 = function(e4, t3, n3) {
+                return e4.filter(function(e6) {
+                    return t3.some(function(t4) {
+                        var o3 = e6.values[t4];
+                        return void 0 === o3 || String(o3) === String(n3);
+                    });
+                });
+            };
+            me2.autoRemove = function(e4) {
+                return !e4;
+            };
+            var he2 = function(e4, t3, n3) {
+                return e4.filter(function(e6) {
+                    return t3.some(function(t4) {
+                        return e6.values[t4].includes(n3);
+                    });
+                });
+            };
+            he2.autoRemove = function(e4) {
+                return !e4 || !e4.length;
+            };
+            var ye2 = function(e4, t3, n3) {
+                return e4.filter(function(e6) {
+                    return t3.some(function(t4) {
+                        var o3 = e6.values[t4];
+                        return o3 && o3.length && n3.every(function(e7) {
+                            return o3.includes(e7);
+                        });
+                    });
+                });
+            };
+            ye2.autoRemove = function(e4) {
+                return !e4 || !e4.length;
+            };
+            var we2 = function(e4, t3, n3) {
+                return e4.filter(function(e6) {
+                    return t3.some(function(t4) {
+                        var o3 = e6.values[t4];
+                        return o3 && o3.length && n3.some(function(e7) {
+                            return o3.includes(e7);
+                        });
+                    });
+                });
+            };
+            we2.autoRemove = function(e4) {
+                return !e4 || !e4.length;
+            };
+            var Re2 = function(e4, t3, n3) {
+                return e4.filter(function(e6) {
+                    return t3.some(function(t4) {
+                        var o3 = e6.values[t4];
+                        return n3.includes(o3);
+                    });
+                });
+            };
+            Re2.autoRemove = function(e4) {
+                return !e4 || !e4.length;
+            };
+            var be2 = function(e4, t3, n3) {
+                return e4.filter(function(e6) {
+                    return t3.some(function(t4) {
+                        return e6.values[t4] === n3;
+                    });
+                });
+            };
+            be2.autoRemove = function(e4) {
+                return void 0 === e4;
+            };
+            var Se2 = function(e4, t3, n3) {
+                return e4.filter(function(e6) {
+                    return t3.some(function(t4) {
+                        return e6.values[t4] == n3;
+                    });
+                });
+            };
+            Se2.autoRemove = function(e4) {
+                return null == e4;
+            };
+            var Ce2 = function(e4, t3, n3) {
+                var o3 = n3 || [],
+                    r3 = o3[0],
+                    i3 = o3[1];
+                if ((r3 = "number" == typeof r3 ? r3 : -1 / 0) > (i3 = "number" == typeof i3 ? i3 : 1 / 0)) {
+                    var u3 = r3;
+                    r3 = i3, i3 = u3;
+                }
+                return e4.filter(function(e6) {
+                    return t3.some(function(t4) {
+                        var n4 = e6.values[t4];
+                        return n4 >= r3 && n4 <= i3;
+                    });
+                });
+            };
+            Ce2.autoRemove = function(e4) {
+                return !e4 || "number" != typeof e4[0] && "number" != typeof e4[1];
+            };
+            var xe2 = Object.freeze({
+                __proto__: null,
+                text: ge2,
+                exactText: ve2,
+                exactTextCase: me2,
+                includes: he2,
+                includesAll: ye2,
+                includesSome: we2,
+                includesValue: Re2,
+                exact: be2,
+                equals: Se2,
+                between: Ce2
             });
-            previous2 = previous2.next;
-            return chunkInside;
-        }
-    }
-
-    function tokenizeContinuation(effects, ok2, nok) {
-        const self2 = this;
-        return startLookahead;
-
-        function startLookahead(code2) {
-            effects.exit("chunkContent");
-            effects.enter("lineEnding");
-            effects.consume(code2);
-            effects.exit("lineEnding");
-            return factorySpace(effects, prefixed, "linePrefix");
-        }
+            l2.resetFilters = "resetFilters", l2.setFilter = "setFilter", l2.setAllFilters = "setAllFilters";
+            var Pe2 = function(e4) {
+                e4.stateReducers.push(Be2), e4.useInstance.push(Ee2);
+            };
 
-        function prefixed(code2) {
-            if (code2 === null || markdownLineEnding(code2)) {
-                return nok(code2);
-            }
-            const tail = self2.events[self2.events.length - 1];
-            if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
-                return ok2(code2);
+            function Be2(e4, t3, n3, o3) {
+                if (t3.type === l2.init)
+                    return r2({
+                        filters: []
+                    }, e4);
+                if (t3.type === l2.resetFilters)
+                    return r2({}, e4, {
+                        filters: o3.initialState.filters || []
+                    });
+                if (t3.type === l2.setFilter) {
+                    var i3 = t3.columnId,
+                        u3 = t3.filterValue,
+                        s3 = o3.allColumns,
+                        a3 = o3.filterTypes,
+                        c3 = s3.find(function(e6) {
+                            return e6.id === i3;
+                        });
+                    if (!c3)
+                        throw new Error("React-Table: Could not find a column with id: " + i3);
+                    var d3 = k2(c3.filter, a3 || {}, xe2),
+                        f3 = e4.filters.find(function(e6) {
+                            return e6.id === i3;
+                        }),
+                        p3 = m2(u3, f3 && f3.value);
+                    return H2(d3.autoRemove, p3, c3) ? r2({}, e4, {
+                        filters: e4.filters.filter(function(e6) {
+                            return e6.id !== i3;
+                        })
+                    }) : r2({}, e4, f3 ? {
+                        filters: e4.filters.map(function(e6) {
+                            return e6.id === i3 ? {
+                                id: i3,
+                                value: p3
+                            } : e6;
+                        })
+                    } : {
+                        filters: [].concat(e4.filters, [{
+                            id: i3,
+                            value: p3
+                        }])
+                    });
+                }
+                if (t3.type === l2.setAllFilters) {
+                    var g3 = t3.filters,
+                        v3 = o3.allColumns,
+                        h3 = o3.filterTypes;
+                    return r2({}, e4, {
+                        filters: m2(g3, e4.filters).filter(function(e6) {
+                            var t4 = v3.find(function(t5) {
+                                return t5.id === e6.id;
+                            });
+                            return !H2(k2(t4.filter, h3 || {}, xe2).autoRemove, e6.value, t4);
+                        })
+                    });
+                }
             }
-            return effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code2);
-        }
-    }
 
-    function factoryDestination(effects, ok2, nok, type2, literalType, literalMarkerType, rawType, stringType, max2) {
-        const limit = max2 || Number.POSITIVE_INFINITY;
-        let balance = 0;
-        return start2;
-
-        function start2(code2) {
-            if (code2 === 60) {
-                effects.enter(type2);
-                effects.enter(literalType);
-                effects.enter(literalMarkerType);
-                effects.consume(code2);
-                effects.exit(literalMarkerType);
-                return enclosedBefore;
-            }
-            if (code2 === null || code2 === 32 || code2 === 41 || asciiControl(code2)) {
-                return nok(code2);
+            function Ee2(e4) {
+                var n3 = e4.data,
+                    o3 = e4.rows,
+                    r3 = e4.flatRows,
+                    i3 = e4.rowsById,
+                    u3 = e4.allColumns,
+                    s3 = e4.filterTypes,
+                    a3 = e4.manualFilters,
+                    c3 = e4.defaultCanFilter,
+                    d3 = void 0 !== c3 && c3,
+                    f3 = e4.disableFilters,
+                    p3 = e4.state.filters,
+                    g3 = e4.dispatch,
+                    v3 = e4.autoResetFilters,
+                    m3 = void 0 === v3 || v3,
+                    y3 = t2.useCallback(function(e6, t3) {
+                        g3({
+                            type: l2.setFilter,
+                            columnId: e6,
+                            filterValue: t3
+                        });
+                    }, [g3]),
+                    R3 = t2.useCallback(function(e6) {
+                        g3({
+                            type: l2.setAllFilters,
+                            filters: e6
+                        });
+                    }, [g3]);
+                u3.forEach(function(e6) {
+                    var t3 = e6.id,
+                        n4 = e6.accessor,
+                        o4 = e6.defaultCanFilter,
+                        r4 = e6.disableFilters;
+                    e6.canFilter = n4 ? I2(true !== r4 && void 0, true !== f3 && void 0, true) : I2(o4, d3, false), e6.setFilter = function(t4) {
+                        return y3(e6.id, t4);
+                    };
+                    var i4 = p3.find(function(e7) {
+                        return e7.id === t3;
+                    });
+                    e6.filterValue = i4 && i4.value;
+                });
+                var b3 = t2.useMemo(function() {
+                        if (a3 || !p3.length)
+                            return [o3, r3, i3];
+                        var e6 = [],
+                            t3 = {};
+                        return [function n4(o4, r4) {
+                            void 0 === r4 && (r4 = 0);
+                            var i4 = o4;
+                            return (i4 = p3.reduce(function(e7, t4) {
+                                var n5 = t4.id,
+                                    o5 = t4.value,
+                                    i5 = u3.find(function(e8) {
+                                        return e8.id === n5;
+                                    });
+                                if (!i5)
+                                    return e7;
+                                0 === r4 && (i5.preFilteredRows = e7);
+                                var l3 = k2(i5.filter, s3 || {}, xe2);
+                                return l3 ? (i5.filteredRows = l3(e7, [n5], o5), i5.filteredRows) : (console.warn("Could not find a valid 'column.filter' for column with the ID: " + i5.id + "."), e7);
+                            }, o4)).forEach(function(o5) {
+                                e6.push(o5), t3[o5.id] = o5, o5.subRows && (o5.subRows = o5.subRows && o5.subRows.length > 0 ? n4(o5.subRows, r4 + 1) : o5.subRows);
+                            }), i4;
+                        }(o3), e6, t3];
+                    }, [a3, p3, o3, r3, i3, u3, s3]),
+                    S3 = b3[0],
+                    C3 = b3[1],
+                    x3 = b3[2];
+                t2.useMemo(function() {
+                    u3.filter(function(e6) {
+                        return !p3.find(function(t3) {
+                            return t3.id === e6.id;
+                        });
+                    }).forEach(function(e6) {
+                        e6.preFilteredRows = S3, e6.filteredRows = S3;
+                    });
+                }, [S3, p3, u3]);
+                var P3 = h2(m3);
+                w2(function() {
+                    P3() && g3({
+                        type: l2.resetFilters
+                    });
+                }, [g3, a3 ? null : n3]), Object.assign(e4, {
+                    preFilteredRows: o3,
+                    preFilteredFlatRows: r3,
+                    preFilteredRowsById: i3,
+                    filteredRows: S3,
+                    filteredFlatRows: C3,
+                    filteredRowsById: x3,
+                    rows: S3,
+                    flatRows: C3,
+                    rowsById: x3,
+                    setFilter: y3,
+                    setAllFilters: R3
+                });
             }
-            effects.enter(type2);
-            effects.enter(rawType);
-            effects.enter(stringType);
-            effects.enter("chunkString", {
-                contentType: "string"
-            });
-            return raw2(code2);
-        }
+            Pe2.pluginName = "useFilters", l2.resetGlobalFilter = "resetGlobalFilter", l2.setGlobalFilter = "setGlobalFilter";
+            var Ie2 = function(e4) {
+                e4.stateReducers.push(Fe2), e4.useInstance.push(Ge2);
+            };
 
-        function enclosedBefore(code2) {
-            if (code2 === 62) {
-                effects.enter(literalMarkerType);
-                effects.consume(code2);
-                effects.exit(literalMarkerType);
-                effects.exit(literalType);
-                effects.exit(type2);
-                return ok2;
+            function Fe2(e4, t3, n3, o3) {
+                if (t3.type === l2.resetGlobalFilter)
+                    return r2({}, e4, {
+                        globalFilter: o3.initialState.globalFilter || void 0
+                    });
+                if (t3.type === l2.setGlobalFilter) {
+                    var u3 = t3.filterValue,
+                        s3 = o3.userFilterTypes,
+                        a3 = k2(o3.globalFilter, s3 || {}, xe2),
+                        c3 = m2(u3, e4.globalFilter);
+                    if (H2(a3.autoRemove, c3)) {
+                        e4.globalFilter;
+                        return i2(e4, ["globalFilter"]);
+                    }
+                    return r2({}, e4, {
+                        globalFilter: c3
+                    });
+                }
             }
-            effects.enter(stringType);
-            effects.enter("chunkString", {
-                contentType: "string"
-            });
-            return enclosed(code2);
-        }
 
-        function enclosed(code2) {
-            if (code2 === 62) {
-                effects.exit("chunkString");
-                effects.exit(stringType);
-                return enclosedBefore(code2);
-            }
-            if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
-                return nok(code2);
+            function Ge2(e4) {
+                var n3 = e4.data,
+                    o3 = e4.rows,
+                    r3 = e4.flatRows,
+                    i3 = e4.rowsById,
+                    u3 = e4.allColumns,
+                    s3 = e4.filterTypes,
+                    a3 = e4.globalFilter,
+                    c3 = e4.manualGlobalFilter,
+                    d3 = e4.state.globalFilter,
+                    f3 = e4.dispatch,
+                    p3 = e4.autoResetGlobalFilter,
+                    g3 = void 0 === p3 || p3,
+                    v3 = e4.disableGlobalFilter,
+                    m3 = t2.useCallback(function(e6) {
+                        f3({
+                            type: l2.setGlobalFilter,
+                            filterValue: e6
+                        });
+                    }, [f3]),
+                    y3 = t2.useMemo(function() {
+                        if (c3 || void 0 === d3)
+                            return [o3, r3, i3];
+                        var e6 = [],
+                            t3 = {},
+                            n4 = k2(a3, s3 || {}, xe2);
+                        if (!n4)
+                            return console.warn("Could not find a valid 'globalFilter' option."), o3;
+                        u3.forEach(function(e7) {
+                            var t4 = e7.disableGlobalFilter;
+                            e7.canFilter = I2(true !== t4 && void 0, true !== v3 && void 0, true);
+                        });
+                        var l3 = u3.filter(function(e7) {
+                            return true === e7.canFilter;
+                        });
+                        return [function o4(r4) {
+                            return (r4 = n4(r4, l3.map(function(e7) {
+                                return e7.id;
+                            }), d3)).forEach(function(n5) {
+                                e6.push(n5), t3[n5.id] = n5, n5.subRows = n5.subRows && n5.subRows.length ? o4(n5.subRows) : n5.subRows;
+                            }), r4;
+                        }(o3), e6, t3];
+                    }, [c3, d3, a3, s3, u3, o3, r3, i3, v3]),
+                    R3 = y3[0],
+                    b3 = y3[1],
+                    S3 = y3[2],
+                    C3 = h2(g3);
+                w2(function() {
+                    C3() && f3({
+                        type: l2.resetGlobalFilter
+                    });
+                }, [f3, c3 ? null : n3]), Object.assign(e4, {
+                    preGlobalFilteredRows: o3,
+                    preGlobalFilteredFlatRows: r3,
+                    preGlobalFilteredRowsById: i3,
+                    globalFilteredRows: R3,
+                    globalFilteredFlatRows: b3,
+                    globalFilteredRowsById: S3,
+                    rows: R3,
+                    flatRows: b3,
+                    rowsById: S3,
+                    setGlobalFilter: m3,
+                    disableGlobalFilter: v3
+                });
             }
-            effects.consume(code2);
-            return code2 === 92 ? enclosedEscape : enclosed;
-        }
 
-        function enclosedEscape(code2) {
-            if (code2 === 60 || code2 === 62 || code2 === 92) {
-                effects.consume(code2);
-                return enclosed;
+            function Ae2(e4, t3) {
+                return t3.reduce(function(e6, t4) {
+                    return e6 + ("number" == typeof t4 ? t4 : 0);
+                }, 0);
             }
-            return enclosed(code2);
-        }
+            Ie2.pluginName = "useGlobalFilter";
+            var ke2 = Object.freeze({
+                    __proto__: null,
+                    sum: Ae2,
+                    min: function(e4) {
+                        var t3 = e4[0] || 0;
+                        return e4.forEach(function(e6) {
+                            "number" == typeof e6 && (t3 = Math.min(t3, e6));
+                        }), t3;
+                    },
+                    max: function(e4) {
+                        var t3 = e4[0] || 0;
+                        return e4.forEach(function(e6) {
+                            "number" == typeof e6 && (t3 = Math.max(t3, e6));
+                        }), t3;
+                    },
+                    minMax: function(e4) {
+                        var t3 = e4[0] || 0,
+                            n3 = e4[0] || 0;
+                        return e4.forEach(function(e6) {
+                            "number" == typeof e6 && (t3 = Math.min(t3, e6), n3 = Math.max(n3, e6));
+                        }), t3 + ".." + n3;
+                    },
+                    average: function(e4) {
+                        return Ae2(0, e4) / e4.length;
+                    },
+                    median: function(e4) {
+                        if (!e4.length)
+                            return null;
+                        var t3 = Math.floor(e4.length / 2),
+                            n3 = [].concat(e4).sort(function(e6, t4) {
+                                return e6 - t4;
+                            });
+                        return e4.length % 2 != 0 ? n3[t3] : (n3[t3 - 1] + n3[t3]) / 2;
+                    },
+                    unique: function(e4) {
+                        return Array.from(new Set(e4).values());
+                    },
+                    uniqueCount: function(e4) {
+                        return new Set(e4).size;
+                    },
+                    count: function(e4) {
+                        return e4.length;
+                    }
+                }),
+                He2 = [],
+                Te2 = {};
+            l2.resetGroupBy = "resetGroupBy", l2.setGroupBy = "setGroupBy", l2.toggleGroupBy = "toggleGroupBy";
+            var ze2 = function(e4) {
+                e4.getGroupByToggleProps = [We2], e4.stateReducers.push(Oe2), e4.visibleColumnsDeps.push(function(e6, t3) {
+                    var n3 = t3.instance;
+                    return [].concat(e6, [n3.state.groupBy]);
+                }), e4.visibleColumns.push(Me2), e4.useInstance.push(Ne2), e4.prepareRow.push(Le2);
+            };
+            ze2.pluginName = "useGroupBy";
+            var We2 = function(e4, t3) {
+                var n3 = t3.header;
+                return [e4, {
+                    onClick: n3.canGroupBy ? function(e6) {
+                        e6.persist(), n3.toggleGroupBy();
+                    } : void 0,
+                    style: {
+                        cursor: n3.canGroupBy ? "pointer" : void 0
+                    },
+                    title: "Toggle GroupBy"
+                }];
+            };
 
-        function raw2(code2) {
-            if (!balance && (code2 === null || code2 === 41 || markdownLineEndingOrSpace(code2))) {
-                effects.exit("chunkString");
-                effects.exit(stringType);
-                effects.exit(rawType);
-                effects.exit(type2);
-                return ok2(code2);
-            }
-            if (balance < limit && code2 === 40) {
-                effects.consume(code2);
-                balance++;
-                return raw2;
-            }
-            if (code2 === 41) {
-                effects.consume(code2);
-                balance--;
-                return raw2;
-            }
-            if (code2 === null || code2 === 32 || code2 === 40 || asciiControl(code2)) {
-                return nok(code2);
+            function Oe2(e4, t3, n3, o3) {
+                if (t3.type === l2.init)
+                    return r2({
+                        groupBy: []
+                    }, e4);
+                if (t3.type === l2.resetGroupBy)
+                    return r2({}, e4, {
+                        groupBy: o3.initialState.groupBy || []
+                    });
+                if (t3.type === l2.setGroupBy)
+                    return r2({}, e4, {
+                        groupBy: t3.value
+                    });
+                if (t3.type === l2.toggleGroupBy) {
+                    var i3 = t3.columnId,
+                        u3 = t3.value,
+                        s3 = void 0 !== u3 ? u3 : !e4.groupBy.includes(i3);
+                    return r2({}, e4, s3 ? {
+                        groupBy: [].concat(e4.groupBy, [i3])
+                    } : {
+                        groupBy: e4.groupBy.filter(function(e6) {
+                            return e6 !== i3;
+                        })
+                    });
+                }
             }
-            effects.consume(code2);
-            return code2 === 92 ? rawEscape : raw2;
-        }
 
-        function rawEscape(code2) {
-            if (code2 === 40 || code2 === 41 || code2 === 92) {
-                effects.consume(code2);
-                return raw2;
+            function Me2(e4, t3) {
+                var n3 = t3.instance.state.groupBy,
+                    o3 = n3.map(function(t4) {
+                        return e4.find(function(e6) {
+                            return e6.id === t4;
+                        });
+                    }).filter(Boolean),
+                    r3 = e4.filter(function(e6) {
+                        return !n3.includes(e6.id);
+                    });
+                return (e4 = [].concat(o3, r3)).forEach(function(e6) {
+                    e6.isGrouped = n3.includes(e6.id), e6.groupedIndex = n3.indexOf(e6.id);
+                }), e4;
             }
-            return raw2(code2);
-        }
-    }
-
-    function factoryLabel(effects, ok2, nok, type2, markerType, stringType) {
-        const self2 = this;
-        let size2 = 0;
-        let seen;
-        return start2;
-
-        function start2(code2) {
-            effects.enter(type2);
-            effects.enter(markerType);
-            effects.consume(code2);
-            effects.exit(markerType);
-            effects.enter(stringType);
-            return atBreak;
-        }
+            var je2 = {};
 
-        function atBreak(code2) {
-            if (size2 > 999 || code2 === null || code2 === 91 || code2 === 93 && !seen || code2 === 94 && !size2 && "_hiddenFootnoteSupport" in self2.parser.constructs) {
-                return nok(code2);
-            }
-            if (code2 === 93) {
-                effects.exit(stringType);
-                effects.enter(markerType);
-                effects.consume(code2);
-                effects.exit(markerType);
-                effects.exit(type2);
-                return ok2;
-            }
-            if (markdownLineEnding(code2)) {
-                effects.enter("lineEnding");
-                effects.consume(code2);
-                effects.exit("lineEnding");
-                return atBreak;
+            function Ne2(e4) {
+                var n3 = e4.data,
+                    o3 = e4.rows,
+                    r3 = e4.flatRows,
+                    i3 = e4.rowsById,
+                    u3 = e4.allColumns,
+                    s3 = e4.flatHeaders,
+                    a3 = e4.groupByFn,
+                    c3 = void 0 === a3 ? De2 : a3,
+                    d3 = e4.manualGroupBy,
+                    p3 = e4.aggregations,
+                    g3 = void 0 === p3 ? je2 : p3,
+                    m3 = e4.plugins,
+                    y3 = e4.state.groupBy,
+                    R3 = e4.dispatch,
+                    b3 = e4.autoResetGroupBy,
+                    S3 = void 0 === b3 || b3,
+                    C3 = e4.disableGroupBy,
+                    x3 = e4.defaultCanGroupBy,
+                    P3 = e4.getHooks;
+                v2(m3, ["useColumnOrder", "useFilters"], "useGroupBy");
+                var B3 = h2(e4);
+                u3.forEach(function(t3) {
+                    var n4 = t3.accessor,
+                        o4 = t3.defaultGroupBy,
+                        r4 = t3.disableGroupBy;
+                    t3.canGroupBy = n4 ? I2(t3.canGroupBy, true !== r4 && void 0, true !== C3 && void 0, true) : I2(t3.canGroupBy, o4, x3, false), t3.canGroupBy && (t3.toggleGroupBy = function() {
+                        return e4.toggleGroupBy(t3.id);
+                    }), t3.Aggregated = t3.Aggregated || t3.Cell;
+                });
+                var E3 = t2.useCallback(function(e6, t3) {
+                        R3({
+                            type: l2.toggleGroupBy,
+                            columnId: e6,
+                            value: t3
+                        });
+                    }, [R3]),
+                    F3 = t2.useCallback(function(e6) {
+                        R3({
+                            type: l2.setGroupBy,
+                            value: e6
+                        });
+                    }, [R3]);
+                s3.forEach(function(e6) {
+                    e6.getGroupByToggleProps = f2(P3().getGroupByToggleProps, {
+                        instance: B3(),
+                        header: e6
+                    });
+                });
+                var A3 = t2.useMemo(function() {
+                        if (d3 || !y3.length)
+                            return [o3, r3, i3, He2, Te2, r3, i3];
+                        var e6 = y3.filter(function(e7) {
+                                return u3.find(function(t4) {
+                                    return t4.id === e7;
+                                });
+                            }),
+                            t3 = [],
+                            n4 = {},
+                            l3 = [],
+                            s4 = {},
+                            a4 = [],
+                            f3 = {},
+                            p4 = function o4(r4, i4, d4) {
+                                if (void 0 === i4 && (i4 = 0), i4 === e6.length)
+                                    return r4;
+                                var p5 = e6[i4],
+                                    v3 = c3(r4, p5);
+                                return Object.entries(v3).map(function(r5, c4) {
+                                    var v4 = r5[0],
+                                        m4 = r5[1],
+                                        h3 = p5 + ":" + v4,
+                                        y4 = o4(m4, i4 + 1, h3 = d4 ? d4 + ">" + h3 : h3),
+                                        w3 = i4 ? G2(m4, "leafRows") : m4,
+                                        R4 = function(t4, n5, o5) {
+                                            var r6 = {};
+                                            return u3.forEach(function(i5) {
+                                                if (e6.includes(i5.id))
+                                                    r6[i5.id] = n5[0] ? n5[0].values[i5.id] : null;
+                                                else {
+                                                    var u4 = "function" == typeof i5.aggregate ? i5.aggregate : g3[i5.aggregate] || ke2[i5.aggregate];
+                                                    if (u4) {
+                                                        var l4 = n5.map(function(e7) {
+                                                                return e7.values[i5.id];
+                                                            }),
+                                                            s5 = t4.map(function(e7) {
+                                                                var t5 = e7.values[i5.id];
+                                                                if (!o5 && i5.aggregateValue) {
+                                                                    var n6 = "function" == typeof i5.aggregateValue ? i5.aggregateValue : g3[i5.aggregateValue] || ke2[i5.aggregateValue];
+                                                                    if (!n6)
+                                                                        throw console.info({
+                                                                            column: i5
+                                                                        }), new Error("React Table: Invalid column.aggregateValue option for column listed above");
+                                                                    t5 = n6(t5, e7, i5);
+                                                                }
+                                                                return t5;
+                                                            });
+                                                        r6[i5.id] = u4(s5, l4);
+                                                    } else {
+                                                        if (i5.aggregate)
+                                                            throw console.info({
+                                                                column: i5
+                                                            }), new Error("React Table: Invalid column.aggregate option for column listed above");
+                                                        r6[i5.id] = null;
+                                                    }
+                                                }
+                                            }), r6;
+                                        }(w3, m4, i4),
+                                        b4 = {
+                                            id: h3,
+                                            isGrouped: true,
+                                            groupByID: p5,
+                                            groupByVal: v4,
+                                            values: R4,
+                                            subRows: y4,
+                                            leafRows: w3,
+                                            depth: i4,
+                                            index: c4
+                                        };
+                                    return y4.forEach(function(e7) {
+                                        t3.push(e7), n4[e7.id] = e7, e7.isGrouped ? (l3.push(e7), s4[e7.id] = e7) : (a4.push(e7), f3[e7.id] = e7);
+                                    }), b4;
+                                });
+                            }(o3);
+                        return p4.forEach(function(e7) {
+                            t3.push(e7), n4[e7.id] = e7, e7.isGrouped ? (l3.push(e7), s4[e7.id] = e7) : (a4.push(e7), f3[e7.id] = e7);
+                        }), [p4, t3, n4, l3, s4, a4, f3];
+                    }, [d3, y3, o3, r3, i3, u3, g3, c3]),
+                    k3 = A3[0],
+                    H3 = A3[1],
+                    T3 = A3[2],
+                    z3 = A3[3],
+                    W3 = A3[4],
+                    O3 = A3[5],
+                    M3 = A3[6],
+                    j3 = h2(S3);
+                w2(function() {
+                    j3() && R3({
+                        type: l2.resetGroupBy
+                    });
+                }, [R3, d3 ? null : n3]), Object.assign(e4, {
+                    preGroupedRows: o3,
+                    preGroupedFlatRow: r3,
+                    preGroupedRowsById: i3,
+                    groupedRows: k3,
+                    groupedFlatRows: H3,
+                    groupedRowsById: T3,
+                    onlyGroupedFlatRows: z3,
+                    onlyGroupedRowsById: W3,
+                    nonGroupedFlatRows: O3,
+                    nonGroupedRowsById: M3,
+                    rows: k3,
+                    flatRows: H3,
+                    rowsById: T3,
+                    toggleGroupBy: E3,
+                    setGroupBy: F3
+                });
             }
-            effects.enter("chunkString", {
-                contentType: "string"
-            });
-            return labelInside(code2);
-        }
 
-        function labelInside(code2) {
-            if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size2++ > 999) {
-                effects.exit("chunkString");
-                return atBreak(code2);
+            function Le2(e4) {
+                e4.allCells.forEach(function(t3) {
+                    var n3;
+                    t3.isGrouped = t3.column.isGrouped && t3.column.id === e4.groupByID, t3.isPlaceholder = !t3.isGrouped && t3.column.isGrouped, t3.isAggregated = !t3.isGrouped && !t3.isPlaceholder && (null == (n3 = e4.subRows) ? void 0 : n3.length);
+                });
             }
-            effects.consume(code2);
-            if (!seen)
-                seen = !markdownSpace(code2);
-            return code2 === 92 ? labelEscape : labelInside;
-        }
 
-        function labelEscape(code2) {
-            if (code2 === 91 || code2 === 92 || code2 === 93) {
-                effects.consume(code2);
-                size2++;
-                return labelInside;
+            function De2(e4, t3) {
+                return e4.reduce(function(e6, n3, o3) {
+                    var r3 = "" + n3.values[t3];
+                    return e6[r3] = Array.isArray(e6[r3]) ? e6[r3] : [], e6[r3].push(n3), e6;
+                }, {});
             }
-            return labelInside(code2);
-        }
-    }
-
-    function factoryTitle(effects, ok2, nok, type2, markerType, stringType) {
-        let marker;
-        return start2;
+            var Ve2 = /([0-9]+)/gm;
 
-        function start2(code2) {
-            if (code2 === 34 || code2 === 39 || code2 === 40) {
-                effects.enter(type2);
-                effects.enter(markerType);
-                effects.consume(code2);
-                effects.exit(markerType);
-                marker = code2 === 40 ? 41 : code2;
-                return begin2;
+            function _e2(e4, t3) {
+                return e4 === t3 ? 0 : e4 > t3 ? 1 : -1;
             }
-            return nok(code2);
-        }
 
-        function begin2(code2) {
-            if (code2 === marker) {
-                effects.enter(markerType);
-                effects.consume(code2);
-                effects.exit(markerType);
-                effects.exit(type2);
-                return ok2;
+            function Xe2(e4, t3, n3) {
+                return [e4.values[n3], t3.values[n3]];
             }
-            effects.enter(stringType);
-            return atBreak(code2);
-        }
 
-        function atBreak(code2) {
-            if (code2 === marker) {
-                effects.exit(stringType);
-                return begin2(marker);
-            }
-            if (code2 === null) {
-                return nok(code2);
-            }
-            if (markdownLineEnding(code2)) {
-                effects.enter("lineEnding");
-                effects.consume(code2);
-                effects.exit("lineEnding");
-                return factorySpace(effects, atBreak, "linePrefix");
+            function qe2(e4) {
+                return "number" == typeof e4 ? isNaN(e4) || e4 === 1 / 0 || e4 === -1 / 0 ? "" : String(e4) : "string" == typeof e4 ? e4 : "";
             }
-            effects.enter("chunkString", {
-                contentType: "string"
+            var Ke2 = Object.freeze({
+                __proto__: null,
+                alphanumeric: function(e4, t3, n3) {
+                    var o3 = Xe2(e4, t3, n3),
+                        r3 = o3[0],
+                        i3 = o3[1];
+                    for (r3 = qe2(r3), i3 = qe2(i3), r3 = r3.split(Ve2).filter(Boolean), i3 = i3.split(Ve2).filter(Boolean); r3.length && i3.length;) {
+                        var u3 = r3.shift(),
+                            l3 = i3.shift(),
+                            s3 = parseInt(u3, 10),
+                            a3 = parseInt(l3, 10),
+                            c3 = [s3, a3].sort();
+                        if (isNaN(c3[0])) {
+                            if (u3 > l3)
+                                return 1;
+                            if (l3 > u3)
+                                return -1;
+                        } else {
+                            if (isNaN(c3[1]))
+                                return isNaN(s3) ? -1 : 1;
+                            if (s3 > a3)
+                                return 1;
+                            if (a3 > s3)
+                                return -1;
+                        }
+                    }
+                    return r3.length - i3.length;
+                },
+                datetime: function(e4, t3, n3) {
+                    var o3 = Xe2(e4, t3, n3),
+                        r3 = o3[0],
+                        i3 = o3[1];
+                    return _e2(r3 = r3.getTime(), i3 = i3.getTime());
+                },
+                basic: function(e4, t3, n3) {
+                    var o3 = Xe2(e4, t3, n3);
+                    return _e2(o3[0], o3[1]);
+                },
+                string: function(e4, t3, n3) {
+                    var o3 = Xe2(e4, t3, n3),
+                        r3 = o3[0],
+                        i3 = o3[1];
+                    for (r3 = r3.split("").filter(Boolean), i3 = i3.split("").filter(Boolean); r3.length && i3.length;) {
+                        var u3 = r3.shift(),
+                            l3 = i3.shift(),
+                            s3 = u3.toLowerCase(),
+                            a3 = l3.toLowerCase();
+                        if (s3 > a3)
+                            return 1;
+                        if (a3 > s3)
+                            return -1;
+                        if (u3 > l3)
+                            return 1;
+                        if (l3 > u3)
+                            return -1;
+                    }
+                    return r3.length - i3.length;
+                },
+                number: function(e4, t3, n3) {
+                    var o3 = Xe2(e4, t3, n3),
+                        r3 = o3[0],
+                        i3 = o3[1],
+                        u3 = /[^0-9.]/gi;
+                    return _e2(r3 = Number(String(r3).replace(u3, "")), i3 = Number(String(i3).replace(u3, "")));
+                }
             });
-            return inside2(code2);
-        }
-
-        function inside2(code2) {
-            if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
-                effects.exit("chunkString");
-                return atBreak(code2);
-            }
-            effects.consume(code2);
-            return code2 === 92 ? escape2 : inside2;
-        }
+            l2.resetSortBy = "resetSortBy", l2.setSortBy = "setSortBy", l2.toggleSortBy = "toggleSortBy", l2.clearSortBy = "clearSortBy", c2.sortType = "alphanumeric", c2.sortDescFirst = false;
+            var Ue2 = function(e4) {
+                e4.getSortByToggleProps = [$e2], e4.stateReducers.push(Je2), e4.useInstance.push(Ye2);
+            };
+            Ue2.pluginName = "useSortBy";
+            var $e2 = function(e4, t3) {
+                var n3 = t3.instance,
+                    o3 = t3.column,
+                    r3 = n3.isMultiSortEvent,
+                    i3 = void 0 === r3 ? function(e6) {
+                        return e6.shiftKey;
+                    } : r3;
+                return [e4, {
+                    onClick: o3.canSort ? function(e6) {
+                        e6.persist(), o3.toggleSortBy(void 0, !n3.disableMultiSort && i3(e6));
+                    } : void 0,
+                    style: {
+                        cursor: o3.canSort ? "pointer" : void 0
+                    },
+                    title: o3.canSort ? "Toggle SortBy" : void 0
+                }];
+            };
 
-        function escape2(code2) {
-            if (code2 === marker || code2 === 92) {
-                effects.consume(code2);
-                return inside2;
+            function Je2(e4, t3, n3, o3) {
+                if (t3.type === l2.init)
+                    return r2({
+                        sortBy: []
+                    }, e4);
+                if (t3.type === l2.resetSortBy)
+                    return r2({}, e4, {
+                        sortBy: o3.initialState.sortBy || []
+                    });
+                if (t3.type === l2.clearSortBy)
+                    return r2({}, e4, {
+                        sortBy: e4.sortBy.filter(function(e6) {
+                            return e6.id !== t3.columnId;
+                        })
+                    });
+                if (t3.type === l2.setSortBy)
+                    return r2({}, e4, {
+                        sortBy: t3.sortBy
+                    });
+                if (t3.type === l2.toggleSortBy) {
+                    var i3, u3 = t3.columnId,
+                        s3 = t3.desc,
+                        a3 = t3.multi,
+                        c3 = o3.allColumns,
+                        d3 = o3.disableMultiSort,
+                        f3 = o3.disableSortRemove,
+                        p3 = o3.disableMultiRemove,
+                        g3 = o3.maxMultiSortColCount,
+                        v3 = void 0 === g3 ? Number.MAX_SAFE_INTEGER : g3,
+                        m3 = e4.sortBy,
+                        h3 = c3.find(function(e6) {
+                            return e6.id === u3;
+                        }).sortDescFirst,
+                        y3 = m3.find(function(e6) {
+                            return e6.id === u3;
+                        }),
+                        w3 = m3.findIndex(function(e6) {
+                            return e6.id === u3;
+                        }),
+                        R3 = null != s3,
+                        b3 = [];
+                    return "toggle" !== (i3 = !d3 && a3 ? y3 ? "toggle" : "add" : w3 !== m3.length - 1 || 1 !== m3.length ? "replace" : y3 ? "toggle" : "replace") || f3 || R3 || a3 && p3 || !(y3 && y3.desc && !h3 || !y3.desc && h3) || (i3 = "remove"), "replace" === i3 ? b3 = [{
+                        id: u3,
+                        desc: R3 ? s3 : h3
+                    }] : "add" === i3 ? (b3 = [].concat(m3, [{
+                        id: u3,
+                        desc: R3 ? s3 : h3
+                    }])).splice(0, b3.length - v3) : "toggle" === i3 ? b3 = m3.map(function(e6) {
+                        return e6.id === u3 ? r2({}, e6, {
+                            desc: R3 ? s3 : !y3.desc
+                        }) : e6;
+                    }) : "remove" === i3 && (b3 = m3.filter(function(e6) {
+                        return e6.id !== u3;
+                    })), r2({}, e4, {
+                        sortBy: b3
+                    });
+                }
             }
-            return inside2(code2);
-        }
-    }
-
-    function factoryWhitespace(effects, ok2) {
-        let seen;
-        return start2;
 
-        function start2(code2) {
-            if (markdownLineEnding(code2)) {
-                effects.enter("lineEnding");
-                effects.consume(code2);
-                effects.exit("lineEnding");
-                seen = true;
-                return start2;
-            }
-            if (markdownSpace(code2)) {
-                return factorySpace(
-                    effects,
-                    start2,
-                    seen ? "linePrefix" : "lineSuffix"
-                )(code2);
+            function Ye2(e4) {
+                var n3 = e4.data,
+                    o3 = e4.rows,
+                    r3 = e4.flatRows,
+                    i3 = e4.allColumns,
+                    u3 = e4.orderByFn,
+                    s3 = void 0 === u3 ? Qe2 : u3,
+                    a3 = e4.sortTypes,
+                    c3 = e4.manualSortBy,
+                    d3 = e4.defaultCanSort,
+                    p3 = e4.disableSortBy,
+                    g3 = e4.flatHeaders,
+                    m3 = e4.state.sortBy,
+                    y3 = e4.dispatch,
+                    R3 = e4.plugins,
+                    b3 = e4.getHooks,
+                    S3 = e4.autoResetSortBy,
+                    C3 = void 0 === S3 || S3;
+                v2(R3, ["useFilters", "useGlobalFilter", "useGroupBy", "usePivotColumns"], "useSortBy");
+                var x3 = t2.useCallback(function(e6) {
+                        y3({
+                            type: l2.setSortBy,
+                            sortBy: e6
+                        });
+                    }, [y3]),
+                    P3 = t2.useCallback(function(e6, t3, n4) {
+                        y3({
+                            type: l2.toggleSortBy,
+                            columnId: e6,
+                            desc: t3,
+                            multi: n4
+                        });
+                    }, [y3]),
+                    B3 = h2(e4);
+                g3.forEach(function(e6) {
+                    var t3 = e6.accessor,
+                        n4 = e6.canSort,
+                        o4 = e6.disableSortBy,
+                        r4 = e6.id,
+                        i4 = t3 ? I2(true !== o4 && void 0, true !== p3 && void 0, true) : I2(d3, n4, false);
+                    e6.canSort = i4, e6.canSort && (e6.toggleSortBy = function(t4, n5) {
+                        return P3(e6.id, t4, n5);
+                    }, e6.clearSortBy = function() {
+                        y3({
+                            type: l2.clearSortBy,
+                            columnId: e6.id
+                        });
+                    }), e6.getSortByToggleProps = f2(b3().getSortByToggleProps, {
+                        instance: B3(),
+                        column: e6
+                    });
+                    var u4 = m3.find(function(e7) {
+                        return e7.id === r4;
+                    });
+                    e6.isSorted = !!u4, e6.sortedIndex = m3.findIndex(function(e7) {
+                        return e7.id === r4;
+                    }), e6.isSortedDesc = e6.isSorted ? u4.desc : void 0;
+                });
+                var E3 = t2.useMemo(function() {
+                        if (c3 || !m3.length)
+                            return [o3, r3];
+                        var e6 = [],
+                            t3 = m3.filter(function(e7) {
+                                return i3.find(function(t4) {
+                                    return t4.id === e7.id;
+                                });
+                            });
+                        return [function n4(o4) {
+                            var r4 = s3(o4, t3.map(function(e7) {
+                                var t4 = i3.find(function(t5) {
+                                    return t5.id === e7.id;
+                                });
+                                if (!t4)
+                                    throw new Error("React-Table: Could not find a column with id: " + e7.id + " while sorting");
+                                var n5 = t4.sortType,
+                                    o5 = F2(n5) || (a3 || {})[n5] || Ke2[n5];
+                                if (!o5)
+                                    throw new Error("React-Table: Could not find a valid sortType of '" + n5 + "' for column '" + e7.id + "'.");
+                                return function(t5, n6) {
+                                    return o5(t5, n6, e7.id, e7.desc);
+                                };
+                            }), t3.map(function(e7) {
+                                var t4 = i3.find(function(t5) {
+                                    return t5.id === e7.id;
+                                });
+                                return t4 && t4.sortInverted ? e7.desc : !e7.desc;
+                            }));
+                            return r4.forEach(function(t4) {
+                                e6.push(t4), t4.subRows && 0 !== t4.subRows.length && (t4.subRows = n4(t4.subRows));
+                            }), r4;
+                        }(o3), e6];
+                    }, [c3, m3, o3, r3, i3, s3, a3]),
+                    G3 = E3[0],
+                    A3 = E3[1],
+                    k3 = h2(C3);
+                w2(function() {
+                    k3() && y3({
+                        type: l2.resetSortBy
+                    });
+                }, [c3 ? null : n3]), Object.assign(e4, {
+                    preSortedRows: o3,
+                    preSortedFlatRows: r3,
+                    sortedRows: G3,
+                    sortedFlatRows: A3,
+                    rows: G3,
+                    flatRows: A3,
+                    setSortBy: x3,
+                    toggleSortBy: P3
+                });
             }
-            return ok2(code2);
-        }
-    }
-    const definition$1 = {
-        name: "definition",
-        tokenize: tokenizeDefinition
-    };
-    const titleBefore = {
-        tokenize: tokenizeTitleBefore,
-        partial: true
-    };
-
-    function tokenizeDefinition(effects, ok2, nok) {
-        const self2 = this;
-        let identifier;
-        return start2;
-
-        function start2(code2) {
-            effects.enter("definition");
-            return before(code2);
-        }
-
-        function before(code2) {
-            return factoryLabel.call(
-                self2,
-                effects,
-                labelAfter,
-                nok,
-                "definitionLabel",
-                "definitionLabelMarker",
-                "definitionLabelString"
-            )(code2);
-        }
 
-        function labelAfter(code2) {
-            identifier = normalizeIdentifier(
-                self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
-            );
-            if (code2 === 58) {
-                effects.enter("definitionMarker");
-                effects.consume(code2);
-                effects.exit("definitionMarker");
-                return markerAfter;
+            function Qe2(e4, t3, n3) {
+                return [].concat(e4).sort(function(e6, o3) {
+                    for (var r3 = 0; r3 < t3.length; r3 += 1) {
+                        var i3 = t3[r3],
+                            u3 = false === n3[r3] || "desc" === n3[r3],
+                            l3 = i3(e6, o3);
+                        if (0 !== l3)
+                            return u3 ? -l3 : l3;
+                    }
+                    return n3[0] ? e6.index - o3.index : o3.index - e6.index;
+                });
             }
-            return nok(code2);
-        }
-
-        function markerAfter(code2) {
-            return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, destinationBefore)(code2) : destinationBefore(code2);
-        }
-
-        function destinationBefore(code2) {
-            return factoryDestination(
-                effects,
-                destinationAfter,
-                nok,
-                "definitionDestination",
-                "definitionDestinationLiteral",
-                "definitionDestinationLiteralMarker",
-                "definitionDestinationRaw",
-                "definitionDestinationString"
-            )(code2);
-        }
-
-        function destinationAfter(code2) {
-            return effects.attempt(titleBefore, after, after)(code2);
-        }
-
-        function after(code2) {
-            return markdownSpace(code2) ? factorySpace(effects, afterWhitespace, "whitespace")(code2) : afterWhitespace(code2);
-        }
+            l2.resetPage = "resetPage", l2.gotoPage = "gotoPage", l2.setPageSize = "setPageSize";
+            var Ze2 = function(e4) {
+                e4.stateReducers.push(et2), e4.useInstance.push(tt2);
+            };
 
-        function afterWhitespace(code2) {
-            if (code2 === null || markdownLineEnding(code2)) {
-                effects.exit("definition");
-                self2.parser.defined.push(identifier);
-                return ok2(code2);
+            function et2(e4, t3, n3, o3) {
+                if (t3.type === l2.init)
+                    return r2({
+                        pageSize: 10,
+                        pageIndex: 0
+                    }, e4);
+                if (t3.type === l2.resetPage)
+                    return r2({}, e4, {
+                        pageIndex: o3.initialState.pageIndex || 0
+                    });
+                if (t3.type === l2.gotoPage) {
+                    var i3 = o3.pageCount,
+                        u3 = o3.page,
+                        s3 = m2(t3.pageIndex, e4.pageIndex),
+                        a3 = false;
+                    return s3 > e4.pageIndex ? a3 = -1 === i3 ? u3.length >= e4.pageSize : s3 < i3 : s3 < e4.pageIndex && (a3 = s3 > -1), a3 ? r2({}, e4, {
+                        pageIndex: s3
+                    }) : e4;
+                }
+                if (t3.type === l2.setPageSize) {
+                    var c3 = t3.pageSize,
+                        d3 = e4.pageSize * e4.pageIndex;
+                    return r2({}, e4, {
+                        pageIndex: Math.floor(d3 / c3),
+                        pageSize: c3
+                    });
+                }
             }
-            return nok(code2);
-        }
-    }
-
-    function tokenizeTitleBefore(effects, ok2, nok) {
-        return titleBefore2;
-
-        function titleBefore2(code2) {
-            return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, beforeMarker)(code2) : nok(code2);
-        }
-
-        function beforeMarker(code2) {
-            return factoryTitle(
-                effects,
-                titleAfter,
-                nok,
-                "definitionTitle",
-                "definitionTitleMarker",
-                "definitionTitleString"
-            )(code2);
-        }
-
-        function titleAfter(code2) {
-            return markdownSpace(code2) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code2) : titleAfterOptionalWhitespace(code2);
-        }
-
-        function titleAfterOptionalWhitespace(code2) {
-            return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
-        }
-    }
-    const hardBreakEscape = {
-        name: "hardBreakEscape",
-        tokenize: tokenizeHardBreakEscape
-    };
-
-    function tokenizeHardBreakEscape(effects, ok2, nok) {
-        return start2;
-
-        function start2(code2) {
-            effects.enter("hardBreakEscape");
-            effects.consume(code2);
-            return after;
-        }
 
-        function after(code2) {
-            if (markdownLineEnding(code2)) {
-                effects.exit("hardBreakEscape");
-                return ok2(code2);
+            function tt2(e4) {
+                var n3 = e4.rows,
+                    o3 = e4.autoResetPage,
+                    r3 = void 0 === o3 || o3,
+                    i3 = e4.manualExpandedKey,
+                    u3 = void 0 === i3 ? "expanded" : i3,
+                    s3 = e4.plugins,
+                    a3 = e4.pageCount,
+                    c3 = e4.paginateExpandedRows,
+                    d3 = void 0 === c3 || c3,
+                    f3 = e4.expandSubRows,
+                    p3 = void 0 === f3 || f3,
+                    g3 = e4.state,
+                    m3 = g3.pageSize,
+                    y3 = g3.pageIndex,
+                    R3 = g3.expanded,
+                    b3 = g3.globalFilter,
+                    S3 = g3.filters,
+                    C3 = g3.groupBy,
+                    x3 = g3.sortBy,
+                    P3 = e4.dispatch,
+                    B3 = e4.data,
+                    E3 = e4.manualPagination;
+                v2(s3, ["useGlobalFilter", "useFilters", "useGroupBy", "useSortBy", "useExpanded"], "usePagination");
+                var I3 = h2(r3);
+                w2(function() {
+                    I3() && P3({
+                        type: l2.resetPage
+                    });
+                }, [P3, E3 ? null : B3, b3, S3, C3, x3]);
+                var F3 = E3 ? a3 : Math.ceil(n3.length / m3),
+                    G3 = t2.useMemo(function() {
+                        return F3 > 0 ? [].concat(new Array(F3)).fill(null).map(function(e6, t3) {
+                            return t3;
+                        }) : [];
+                    }, [F3]),
+                    k3 = t2.useMemo(function() {
+                        var e6;
+                        if (E3)
+                            e6 = n3;
+                        else {
+                            var t3 = m3 * y3,
+                                o4 = t3 + m3;
+                            e6 = n3.slice(t3, o4);
+                        }
+                        return d3 ? e6 : A2(e6, {
+                            manualExpandedKey: u3,
+                            expanded: R3,
+                            expandSubRows: p3
+                        });
+                    }, [p3, R3, u3, E3, y3, m3, d3, n3]),
+                    H3 = y3 > 0,
+                    T3 = -1 === F3 ? k3.length >= m3 : y3 < F3 - 1,
+                    z3 = t2.useCallback(function(e6) {
+                        P3({
+                            type: l2.gotoPage,
+                            pageIndex: e6
+                        });
+                    }, [P3]),
+                    W3 = t2.useCallback(function() {
+                        return z3(function(e6) {
+                            return e6 - 1;
+                        });
+                    }, [z3]),
+                    O3 = t2.useCallback(function() {
+                        return z3(function(e6) {
+                            return e6 + 1;
+                        });
+                    }, [z3]),
+                    M3 = t2.useCallback(function(e6) {
+                        P3({
+                            type: l2.setPageSize,
+                            pageSize: e6
+                        });
+                    }, [P3]);
+                Object.assign(e4, {
+                    pageOptions: G3,
+                    pageCount: F3,
+                    page: k3,
+                    canPreviousPage: H3,
+                    canNextPage: T3,
+                    gotoPage: z3,
+                    previousPage: W3,
+                    nextPage: O3,
+                    setPageSize: M3
+                });
             }
-            return nok(code2);
-        }
-    }
-    const headingAtx = {
-        name: "headingAtx",
-        tokenize: tokenizeHeadingAtx,
-        resolve: resolveHeadingAtx
-    };
-
-    function resolveHeadingAtx(events2, context2) {
-        let contentEnd = events2.length - 2;
-        let contentStart = 3;
-        let content2;
-        let text2;
-        if (events2[contentStart][1].type === "whitespace") {
-            contentStart += 2;
-        }
-        if (contentEnd - 2 > contentStart && events2[contentEnd][1].type === "whitespace") {
-            contentEnd -= 2;
-        }
-        if (events2[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events2[contentEnd - 2][1].type === "whitespace")) {
-            contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
-        }
-        if (contentEnd > contentStart) {
-            content2 = {
-                type: "atxHeadingText",
-                start: events2[contentStart][1].start,
-                end: events2[contentEnd][1].end
-            };
-            text2 = {
-                type: "chunkText",
-                start: events2[contentStart][1].start,
-                end: events2[contentEnd][1].end,
-                contentType: "text"
+            Ze2.pluginName = "usePagination", l2.resetPivot = "resetPivot", l2.togglePivot = "togglePivot";
+            var nt2 = function(e4) {
+                e4.getPivotToggleProps = [rt2], e4.stateReducers.push(it2), e4.useInstanceAfterData.push(ut2), e4.allColumns.push(lt2), e4.accessValue.push(st2), e4.materializedColumns.push(at2), e4.materializedColumnsDeps.push(ct2), e4.visibleColumns.push(dt2), e4.visibleColumnsDeps.push(ft2), e4.useInstance.push(pt2), e4.prepareRow.push(gt2);
             };
-            splice(events2, contentStart, contentEnd - contentStart + 1, [
-                ["enter", content2, context2],
-                ["enter", text2, context2],
-                ["exit", text2, context2],
-                ["exit", content2, context2]
-            ]);
-        }
-        return events2;
-    }
-
-    function tokenizeHeadingAtx(effects, ok2, nok) {
-        let size2 = 0;
-        return start2;
-
-        function start2(code2) {
-            effects.enter("atxHeading");
-            return before(code2);
-        }
-
-        function before(code2) {
-            effects.enter("atxHeadingSequence");
-            return sequenceOpen(code2);
-        }
+            nt2.pluginName = "usePivotColumns";
+            var ot2 = [],
+                rt2 = function(e4, t3) {
+                    var n3 = t3.header;
+                    return [e4, {
+                        onClick: n3.canPivot ? function(e6) {
+                            e6.persist(), n3.togglePivot();
+                        } : void 0,
+                        style: {
+                            cursor: n3.canPivot ? "pointer" : void 0
+                        },
+                        title: "Toggle Pivot"
+                    }];
+                };
 
-        function sequenceOpen(code2) {
-            if (code2 === 35 && size2++ < 6) {
-                effects.consume(code2);
-                return sequenceOpen;
-            }
-            if (code2 === null || markdownLineEndingOrSpace(code2)) {
-                effects.exit("atxHeadingSequence");
-                return atBreak(code2);
+            function it2(e4, t3, n3, o3) {
+                if (t3.type === l2.init)
+                    return r2({
+                        pivotColumns: ot2
+                    }, e4);
+                if (t3.type === l2.resetPivot)
+                    return r2({}, e4, {
+                        pivotColumns: o3.initialState.pivotColumns || ot2
+                    });
+                if (t3.type === l2.togglePivot) {
+                    var i3 = t3.columnId,
+                        u3 = t3.value,
+                        s3 = void 0 !== u3 ? u3 : !e4.pivotColumns.includes(i3);
+                    return r2({}, e4, s3 ? {
+                        pivotColumns: [].concat(e4.pivotColumns, [i3])
+                    } : {
+                        pivotColumns: e4.pivotColumns.filter(function(e6) {
+                            return e6 !== i3;
+                        })
+                    });
+                }
             }
-            return nok(code2);
-        }
 
-        function atBreak(code2) {
-            if (code2 === 35) {
-                effects.enter("atxHeadingSequence");
-                return sequenceFurther(code2);
-            }
-            if (code2 === null || markdownLineEnding(code2)) {
-                effects.exit("atxHeading");
-                return ok2(code2);
-            }
-            if (markdownSpace(code2)) {
-                return factorySpace(effects, atBreak, "whitespace")(code2);
+            function ut2(e4) {
+                e4.allColumns.forEach(function(t3) {
+                    t3.isPivotSource = e4.state.pivotColumns.includes(t3.id);
+                });
             }
-            effects.enter("atxHeadingText");
-            return data2(code2);
-        }
 
-        function sequenceFurther(code2) {
-            if (code2 === 35) {
-                effects.consume(code2);
-                return sequenceFurther;
+            function lt2(e4, t3) {
+                var n3 = t3.instance;
+                return e4.forEach(function(e6) {
+                    e6.isPivotSource = n3.state.pivotColumns.includes(e6.id), e6.uniqueValues = /* @__PURE__ */ new Set();
+                }), e4;
             }
-            effects.exit("atxHeadingSequence");
-            return atBreak(code2);
-        }
 
-        function data2(code2) {
-            if (code2 === null || code2 === 35 || markdownLineEndingOrSpace(code2)) {
-                effects.exit("atxHeadingText");
-                return atBreak(code2);
+            function st2(e4, t3) {
+                var n3 = t3.column;
+                return n3.uniqueValues && void 0 !== e4 && n3.uniqueValues.add(e4), e4;
             }
-            effects.consume(code2);
-            return data2;
-        }
-    }
-    const htmlBlockNames = [
-        "address",
-        "article",
-        "aside",
-        "base",
-        "basefont",
-        "blockquote",
-        "body",
-        "caption",
-        "center",
-        "col",
-        "colgroup",
-        "dd",
-        "details",
-        "dialog",
-        "dir",
-        "div",
-        "dl",
-        "dt",
-        "fieldset",
-        "figcaption",
-        "figure",
-        "footer",
-        "form",
-        "frame",
-        "frameset",
-        "h1",
-        "h2",
-        "h3",
-        "h4",
-        "h5",
-        "h6",
-        "head",
-        "header",
-        "hr",
-        "html",
-        "iframe",
-        "legend",
-        "li",
-        "link",
-        "main",
-        "menu",
-        "menuitem",
-        "nav",
-        "noframes",
-        "ol",
-        "optgroup",
-        "option",
-        "p",
-        "param",
-        "search",
-        "section",
-        "summary",
-        "table",
-        "tbody",
-        "td",
-        "tfoot",
-        "th",
-        "thead",
-        "title",
-        "tr",
-        "track",
-        "ul"
-    ];
-    const htmlRawNames = ["pre", "script", "style", "textarea"];
-    const htmlFlow = {
-        name: "htmlFlow",
-        tokenize: tokenizeHtmlFlow,
-        resolveTo: resolveToHtmlFlow,
-        concrete: true
-    };
-    const blankLineBefore = {
-        tokenize: tokenizeBlankLineBefore,
-        partial: true
-    };
-    const nonLazyContinuationStart = {
-        tokenize: tokenizeNonLazyContinuationStart,
-        partial: true
-    };
 
-    function resolveToHtmlFlow(events2) {
-        let index2 = events2.length;
-        while (index2--) {
-            if (events2[index2][0] === "enter" && events2[index2][1].type === "htmlFlow") {
-                break;
+            function at2(e4, t3) {
+                var n3 = t3.instance,
+                    o3 = n3.allColumns,
+                    i3 = n3.state;
+                if (!i3.pivotColumns.length || !i3.groupBy || !i3.groupBy.length)
+                    return e4;
+                var u3 = i3.pivotColumns.map(function(e6) {
+                        return o3.find(function(t4) {
+                            return t4.id === e6;
+                        });
+                    }).filter(Boolean),
+                    l3 = o3.filter(function(e6) {
+                        return !e6.isPivotSource && !i3.groupBy.includes(e6.id) && !i3.pivotColumns.includes(e6.id);
+                    }),
+                    s3 = C2(function e6(t4, n4, o4) {
+                        void 0 === t4 && (t4 = 0), void 0 === o4 && (o4 = []);
+                        var i4 = u3[t4];
+                        return i4 ? Array.from(i4.uniqueValues).sort().map(function(u4) {
+                            var l4 = r2({}, i4, {
+                                Header: i4.PivotHeader || "string" == typeof i4.header ? i4.Header + ": " + u4 : u4,
+                                isPivotGroup: true,
+                                parent: n4,
+                                depth: t4,
+                                id: n4 ? n4.id + "." + i4.id + "." + u4 : i4.id + "." + u4,
+                                pivotValue: u4
+                            });
+                            return l4.columns = e6(t4 + 1, l4, [].concat(o4, [function(e7) {
+                                return e7.values[i4.id] === u4;
+                            }])), l4;
+                        }) : l3.map(function(e7) {
+                            return r2({}, e7, {
+                                canPivot: false,
+                                isPivoted: true,
+                                parent: n4,
+                                depth: t4,
+                                id: "" + (n4 ? n4.id + "." + e7.id : e7.id),
+                                accessor: function(t5, n5, r3) {
+                                    if (o4.every(function(e8) {
+                                            return e8(r3);
+                                        }))
+                                        return r3.values[e7.id];
+                                }
+                            });
+                        });
+                    }());
+                return [].concat(e4, s3);
             }
-        }
-        if (index2 > 1 && events2[index2 - 2][1].type === "linePrefix") {
-            events2[index2][1].start = events2[index2 - 2][1].start;
-            events2[index2 + 1][1].start = events2[index2 - 2][1].start;
-            events2.splice(index2 - 2, 2);
-        }
-        return events2;
-    }
-
-    function tokenizeHtmlFlow(effects, ok2, nok) {
-        const self2 = this;
-        let marker;
-        let closingTag;
-        let buffer;
-        let index2;
-        let markerB;
-        return start2;
-
-        function start2(code2) {
-            return before(code2);
-        }
-
-        function before(code2) {
-            effects.enter("htmlFlow");
-            effects.enter("htmlFlowData");
-            effects.consume(code2);
-            return open;
-        }
 
-        function open(code2) {
-            if (code2 === 33) {
-                effects.consume(code2);
-                return declarationOpen;
-            }
-            if (code2 === 47) {
-                effects.consume(code2);
-                closingTag = true;
-                return tagCloseStart;
-            }
-            if (code2 === 63) {
-                effects.consume(code2);
-                marker = 3;
-                return self2.interrupt ? ok2 : continuationDeclarationInside;
-            }
-            if (asciiAlpha(code2)) {
-                effects.consume(code2);
-                buffer = String.fromCharCode(code2);
-                return tagName;
+            function ct2(e4, t3) {
+                var n3 = t3.instance.state,
+                    o3 = n3.pivotColumns,
+                    r3 = n3.groupBy;
+                return [].concat(e4, [o3, r3]);
             }
-            return nok(code2);
-        }
 
-        function declarationOpen(code2) {
-            if (code2 === 45) {
-                effects.consume(code2);
-                marker = 2;
-                return commentOpenInside;
-            }
-            if (code2 === 91) {
-                effects.consume(code2);
-                marker = 5;
-                index2 = 0;
-                return cdataOpenInside;
-            }
-            if (asciiAlpha(code2)) {
-                effects.consume(code2);
-                marker = 4;
-                return self2.interrupt ? ok2 : continuationDeclarationInside;
+            function dt2(e4, t3) {
+                var n3 = t3.instance.state;
+                return e4 = e4.filter(function(e6) {
+                    return !e6.isPivotSource;
+                }), n3.pivotColumns.length && n3.groupBy && n3.groupBy.length && (e4 = e4.filter(function(e6) {
+                    return e6.isGrouped || e6.isPivoted;
+                })), e4;
             }
-            return nok(code2);
-        }
 
-        function commentOpenInside(code2) {
-            if (code2 === 45) {
-                effects.consume(code2);
-                return self2.interrupt ? ok2 : continuationDeclarationInside;
+            function ft2(e4, t3) {
+                var n3 = t3.instance;
+                return [].concat(e4, [n3.state.pivotColumns, n3.state.groupBy]);
             }
-            return nok(code2);
-        }
 
-        function cdataOpenInside(code2) {
-            const value = "CDATA[";
-            if (code2 === value.charCodeAt(index2++)) {
-                effects.consume(code2);
-                if (index2 === value.length) {
-                    return self2.interrupt ? ok2 : continuation;
-                }
-                return cdataOpenInside;
+            function pt2(e4) {
+                var t3 = e4.columns,
+                    n3 = e4.allColumns,
+                    o3 = e4.flatHeaders,
+                    r3 = e4.getHooks,
+                    i3 = e4.plugins,
+                    u3 = e4.dispatch,
+                    s3 = e4.autoResetPivot,
+                    a3 = void 0 === s3 || s3,
+                    c3 = e4.manaulPivot,
+                    d3 = e4.disablePivot,
+                    p3 = e4.defaultCanPivot;
+                v2(i3, ["useGroupBy"], "usePivotColumns");
+                var g3 = h2(e4);
+                n3.forEach(function(t4) {
+                    var n4 = t4.accessor,
+                        o4 = t4.defaultPivot,
+                        r4 = t4.disablePivot;
+                    t4.canPivot = n4 ? I2(t4.canPivot, true !== r4 && void 0, true !== d3 && void 0, true) : I2(t4.canPivot, o4, p3, false), t4.canPivot && (t4.togglePivot = function() {
+                        return e4.togglePivot(t4.id);
+                    }), t4.Aggregated = t4.Aggregated || t4.Cell;
+                });
+                o3.forEach(function(e6) {
+                    e6.getPivotToggleProps = f2(r3().getPivotToggleProps, {
+                        instance: g3(),
+                        header: e6
+                    });
+                });
+                var m3 = h2(a3);
+                w2(function() {
+                    m3() && u3({
+                        type: l2.resetPivot
+                    });
+                }, [u3, c3 ? null : t3]), Object.assign(e4, {
+                    togglePivot: function(e6, t4) {
+                        u3({
+                            type: l2.togglePivot,
+                            columnId: e6,
+                            value: t4
+                        });
+                    }
+                });
             }
-            return nok(code2);
-        }
 
-        function tagCloseStart(code2) {
-            if (asciiAlpha(code2)) {
-                effects.consume(code2);
-                buffer = String.fromCharCode(code2);
-                return tagName;
+            function gt2(e4) {
+                e4.allCells.forEach(function(e6) {
+                    e6.isPivoted = e6.column.isPivoted;
+                });
             }
-            return nok(code2);
-        }
+            l2.resetSelectedRows = "resetSelectedRows", l2.toggleAllRowsSelected = "toggleAllRowsSelected", l2.toggleRowSelected = "toggleRowSelected", l2.toggleAllPageRowsSelected = "toggleAllPageRowsSelected";
+            var vt2 = function(e4) {
+                e4.getToggleRowSelectedProps = [mt2], e4.getToggleAllRowsSelectedProps = [ht2], e4.getToggleAllPageRowsSelectedProps = [yt2], e4.stateReducers.push(wt2), e4.useInstance.push(Rt2), e4.prepareRow.push(bt2);
+            };
+            vt2.pluginName = "useRowSelect";
+            var mt2 = function(e4, t3) {
+                    var n3 = t3.instance,
+                        o3 = t3.row,
+                        r3 = n3.manualRowSelectedKey,
+                        i3 = void 0 === r3 ? "isSelected" : r3;
+                    return [e4, {
+                        onChange: function(e6) {
+                            o3.toggleRowSelected(e6.target.checked);
+                        },
+                        style: {
+                            cursor: "pointer"
+                        },
+                        checked: !(!o3.original || !o3.original[i3]) || o3.isSelected,
+                        title: "Toggle Row Selected",
+                        indeterminate: o3.isSomeSelected
+                    }];
+                },
+                ht2 = function(e4, t3) {
+                    var n3 = t3.instance;
+                    return [e4, {
+                        onChange: function(e6) {
+                            n3.toggleAllRowsSelected(e6.target.checked);
+                        },
+                        style: {
+                            cursor: "pointer"
+                        },
+                        checked: n3.isAllRowsSelected,
+                        title: "Toggle All Rows Selected",
+                        indeterminate: Boolean(!n3.isAllRowsSelected && Object.keys(n3.state.selectedRowIds).length)
+                    }];
+                },
+                yt2 = function(e4, t3) {
+                    var n3 = t3.instance;
+                    return [e4, {
+                        onChange: function(e6) {
+                            n3.toggleAllPageRowsSelected(e6.target.checked);
+                        },
+                        style: {
+                            cursor: "pointer"
+                        },
+                        checked: n3.isAllPageRowsSelected,
+                        title: "Toggle All Current Page Rows Selected",
+                        indeterminate: Boolean(!n3.isAllPageRowsSelected && n3.page.some(function(e6) {
+                            var t4 = e6.id;
+                            return n3.state.selectedRowIds[t4];
+                        }))
+                    }];
+                };
 
-        function tagName(code2) {
-            if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
-                const slash = code2 === 47;
-                const name2 = buffer.toLowerCase();
-                if (!slash && !closingTag && htmlRawNames.includes(name2)) {
-                    marker = 1;
-                    return self2.interrupt ? ok2(code2) : continuation(code2);
+            function wt2(e4, t3, n3, o3) {
+                if (t3.type === l2.init)
+                    return r2({
+                        selectedRowIds: {}
+                    }, e4);
+                if (t3.type === l2.resetSelectedRows)
+                    return r2({}, e4, {
+                        selectedRowIds: o3.initialState.selectedRowIds || {}
+                    });
+                if (t3.type === l2.toggleAllRowsSelected) {
+                    var i3 = t3.value,
+                        u3 = o3.isAllRowsSelected,
+                        s3 = o3.rowsById,
+                        a3 = o3.nonGroupedRowsById,
+                        c3 = void 0 === a3 ? s3 : a3,
+                        d3 = void 0 !== i3 ? i3 : !u3,
+                        f3 = Object.assign({}, e4.selectedRowIds);
+                    return d3 ? Object.keys(c3).forEach(function(e6) {
+                        f3[e6] = true;
+                    }) : Object.keys(c3).forEach(function(e6) {
+                        delete f3[e6];
+                    }), r2({}, e4, {
+                        selectedRowIds: f3
+                    });
                 }
-                if (htmlBlockNames.includes(buffer.toLowerCase())) {
-                    marker = 6;
-                    if (slash) {
-                        effects.consume(code2);
-                        return basicSelfClosing;
-                    }
-                    return self2.interrupt ? ok2(code2) : continuation(code2);
+                if (t3.type === l2.toggleRowSelected) {
+                    var p3 = t3.id,
+                        g3 = t3.value,
+                        v3 = o3.rowsById,
+                        m3 = o3.selectSubRows,
+                        h3 = void 0 === m3 || m3,
+                        y3 = o3.getSubRows,
+                        w3 = e4.selectedRowIds[p3],
+                        R3 = void 0 !== g3 ? g3 : !w3;
+                    if (w3 === R3)
+                        return e4;
+                    var b3 = r2({}, e4.selectedRowIds);
+                    return function e6(t4) {
+                        var n4 = v3[t4];
+                        if (n4.isGrouped || (R3 ? b3[t4] = true : delete b3[t4]), h3 && y3(n4))
+                            return y3(n4).forEach(function(t5) {
+                                return e6(t5.id);
+                            });
+                    }(p3), r2({}, e4, {
+                        selectedRowIds: b3
+                    });
                 }
-                marker = 7;
-                return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2);
-            }
-            if (code2 === 45 || asciiAlphanumeric(code2)) {
-                effects.consume(code2);
-                buffer += String.fromCharCode(code2);
-                return tagName;
-            }
-            return nok(code2);
-        }
-
-        function basicSelfClosing(code2) {
-            if (code2 === 62) {
-                effects.consume(code2);
-                return self2.interrupt ? ok2 : continuation;
+                if (t3.type === l2.toggleAllPageRowsSelected) {
+                    var S3 = t3.value,
+                        C3 = o3.page,
+                        x3 = o3.rowsById,
+                        P3 = o3.selectSubRows,
+                        B3 = void 0 === P3 || P3,
+                        E3 = o3.isAllPageRowsSelected,
+                        I3 = o3.getSubRows,
+                        F3 = void 0 !== S3 ? S3 : !E3,
+                        G3 = r2({}, e4.selectedRowIds);
+                    return C3.forEach(function(e6) {
+                        return function e7(t4) {
+                            var n4 = x3[t4];
+                            if (n4.isGrouped || (F3 ? G3[t4] = true : delete G3[t4]), B3 && I3(n4))
+                                return I3(n4).forEach(function(t5) {
+                                    return e7(t5.id);
+                                });
+                        }(e6.id);
+                    }), r2({}, e4, {
+                        selectedRowIds: G3
+                    });
+                }
+                return e4;
             }
-            return nok(code2);
-        }
 
-        function completeClosingTagAfter(code2) {
-            if (markdownSpace(code2)) {
-                effects.consume(code2);
-                return completeClosingTagAfter;
+            function Rt2(e4) {
+                var n3 = e4.data,
+                    o3 = e4.rows,
+                    r3 = e4.getHooks,
+                    i3 = e4.plugins,
+                    u3 = e4.rowsById,
+                    s3 = e4.nonGroupedRowsById,
+                    a3 = void 0 === s3 ? u3 : s3,
+                    c3 = e4.autoResetSelectedRows,
+                    d3 = void 0 === c3 || c3,
+                    p3 = e4.state.selectedRowIds,
+                    g3 = e4.selectSubRows,
+                    m3 = void 0 === g3 || g3,
+                    y3 = e4.dispatch,
+                    R3 = e4.page,
+                    b3 = e4.getSubRows;
+                v2(i3, ["useFilters", "useGroupBy", "useSortBy", "useExpanded", "usePagination"], "useRowSelect");
+                var S3 = t2.useMemo(function() {
+                        var e6 = [];
+                        return o3.forEach(function(t3) {
+                            var n4 = m3 ? function e7(t4, n5, o4) {
+                                if (n5[t4.id])
+                                    return true;
+                                var r4 = o4(t4);
+                                if (r4 && r4.length) {
+                                    var i4 = true,
+                                        u4 = false;
+                                    return r4.forEach(function(t5) {
+                                        u4 && !i4 || (e7(t5, n5, o4) ? u4 = true : i4 = false);
+                                    }), !!i4 || !!u4 && null;
+                                }
+                                return false;
+                            }(t3, p3, b3) : !!p3[t3.id];
+                            t3.isSelected = !!n4, t3.isSomeSelected = null === n4, n4 && e6.push(t3);
+                        }), e6;
+                    }, [o3, m3, p3, b3]),
+                    C3 = Boolean(Object.keys(a3).length && Object.keys(p3).length),
+                    x3 = C3;
+                C3 && Object.keys(a3).some(function(e6) {
+                    return !p3[e6];
+                }) && (C3 = false), C3 || R3 && R3.length && R3.some(function(e6) {
+                    var t3 = e6.id;
+                    return !p3[t3];
+                }) && (x3 = false);
+                var P3 = h2(d3);
+                w2(function() {
+                    P3() && y3({
+                        type: l2.resetSelectedRows
+                    });
+                }, [y3, n3]);
+                var B3 = t2.useCallback(function(e6) {
+                        return y3({
+                            type: l2.toggleAllRowsSelected,
+                            value: e6
+                        });
+                    }, [y3]),
+                    E3 = t2.useCallback(function(e6) {
+                        return y3({
+                            type: l2.toggleAllPageRowsSelected,
+                            value: e6
+                        });
+                    }, [y3]),
+                    I3 = t2.useCallback(function(e6, t3) {
+                        return y3({
+                            type: l2.toggleRowSelected,
+                            id: e6,
+                            value: t3
+                        });
+                    }, [y3]),
+                    F3 = h2(e4),
+                    G3 = f2(r3().getToggleAllRowsSelectedProps, {
+                        instance: F3()
+                    }),
+                    A3 = f2(r3().getToggleAllPageRowsSelectedProps, {
+                        instance: F3()
+                    });
+                Object.assign(e4, {
+                    selectedFlatRows: S3,
+                    isAllRowsSelected: C3,
+                    isAllPageRowsSelected: x3,
+                    toggleRowSelected: I3,
+                    toggleAllRowsSelected: B3,
+                    getToggleAllRowsSelectedProps: G3,
+                    getToggleAllPageRowsSelectedProps: A3,
+                    toggleAllPageRowsSelected: E3
+                });
             }
-            return completeEnd(code2);
-        }
 
-        function completeAttributeNameBefore(code2) {
-            if (code2 === 47) {
-                effects.consume(code2);
-                return completeEnd;
-            }
-            if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
-                effects.consume(code2);
-                return completeAttributeName;
-            }
-            if (markdownSpace(code2)) {
-                effects.consume(code2);
-                return completeAttributeNameBefore;
+            function bt2(e4, t3) {
+                var n3 = t3.instance;
+                e4.toggleRowSelected = function(t4) {
+                    return n3.toggleRowSelected(e4.id, t4);
+                }, e4.getToggleRowSelectedProps = f2(n3.getHooks().getToggleRowSelectedProps, {
+                    instance: n3,
+                    row: e4
+                });
             }
-            return completeEnd(code2);
-        }
+            var St2 = function(e4) {
+                    return {};
+                },
+                Ct2 = function(e4) {
+                    return {};
+                };
+            l2.setRowState = "setRowState", l2.setCellState = "setCellState", l2.resetRowState = "resetRowState";
+            var xt2 = function(e4) {
+                e4.stateReducers.push(Pt2), e4.useInstance.push(Bt2), e4.prepareRow.push(Et2);
+            };
 
-        function completeAttributeName(code2) {
-            if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
-                effects.consume(code2);
-                return completeAttributeName;
+            function Pt2(e4, t3, n3, o3) {
+                var i3 = o3.initialRowStateAccessor,
+                    u3 = void 0 === i3 ? St2 : i3,
+                    s3 = o3.initialCellStateAccessor,
+                    a3 = void 0 === s3 ? Ct2 : s3,
+                    c3 = o3.rowsById;
+                if (t3.type === l2.init)
+                    return r2({
+                        rowState: {}
+                    }, e4);
+                if (t3.type === l2.resetRowState)
+                    return r2({}, e4, {
+                        rowState: o3.initialState.rowState || {}
+                    });
+                if (t3.type === l2.setRowState) {
+                    var d3, f3 = t3.rowId,
+                        p3 = t3.value,
+                        g3 = void 0 !== e4.rowState[f3] ? e4.rowState[f3] : u3(c3[f3]);
+                    return r2({}, e4, {
+                        rowState: r2({}, e4.rowState, (d3 = {}, d3[f3] = m2(p3, g3), d3))
+                    });
+                }
+                if (t3.type === l2.setCellState) {
+                    var v3, h3, y3, w3, R3, b3 = t3.rowId,
+                        S3 = t3.columnId,
+                        C3 = t3.value,
+                        x3 = void 0 !== e4.rowState[b3] ? e4.rowState[b3] : u3(c3[b3]),
+                        P3 = void 0 !== (null == x3 ? void 0 : null == (v3 = x3.cellState) ? void 0 : v3[S3]) ? x3.cellState[S3] : a3(null == (h3 = c3[b3]) ? void 0 : null == (y3 = h3.cells) ? void 0 : y3.find(function(e6) {
+                            return e6.column.id === S3;
+                        }));
+                    return r2({}, e4, {
+                        rowState: r2({}, e4.rowState, (R3 = {}, R3[b3] = r2({}, x3, {
+                            cellState: r2({}, x3.cellState || {}, (w3 = {}, w3[S3] = m2(C3, P3), w3))
+                        }), R3))
+                    });
+                }
             }
-            return completeAttributeNameAfter(code2);
-        }
 
-        function completeAttributeNameAfter(code2) {
-            if (code2 === 61) {
-                effects.consume(code2);
-                return completeAttributeValueBefore;
-            }
-            if (markdownSpace(code2)) {
-                effects.consume(code2);
-                return completeAttributeNameAfter;
+            function Bt2(e4) {
+                var n3 = e4.autoResetRowState,
+                    o3 = void 0 === n3 || n3,
+                    r3 = e4.data,
+                    i3 = e4.dispatch,
+                    u3 = t2.useCallback(function(e6, t3) {
+                        return i3({
+                            type: l2.setRowState,
+                            rowId: e6,
+                            value: t3
+                        });
+                    }, [i3]),
+                    s3 = t2.useCallback(function(e6, t3, n4) {
+                        return i3({
+                            type: l2.setCellState,
+                            rowId: e6,
+                            columnId: t3,
+                            value: n4
+                        });
+                    }, [i3]),
+                    a3 = h2(o3);
+                w2(function() {
+                    a3() && i3({
+                        type: l2.resetRowState
+                    });
+                }, [r3]), Object.assign(e4, {
+                    setRowState: u3,
+                    setCellState: s3
+                });
             }
-            return completeAttributeNameBefore(code2);
-        }
 
-        function completeAttributeValueBefore(code2) {
-            if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
-                return nok(code2);
-            }
-            if (code2 === 34 || code2 === 39) {
-                effects.consume(code2);
-                markerB = code2;
-                return completeAttributeValueQuoted;
-            }
-            if (markdownSpace(code2)) {
-                effects.consume(code2);
-                return completeAttributeValueBefore;
+            function Et2(e4, t3) {
+                var n3 = t3.instance,
+                    o3 = n3.initialRowStateAccessor,
+                    r3 = void 0 === o3 ? St2 : o3,
+                    i3 = n3.initialCellStateAccessor,
+                    u3 = void 0 === i3 ? Ct2 : i3,
+                    l3 = n3.state.rowState;
+                e4 && (e4.state = void 0 !== l3[e4.id] ? l3[e4.id] : r3(e4), e4.setState = function(t4) {
+                    return n3.setRowState(e4.id, t4);
+                }, e4.cells.forEach(function(t4) {
+                    e4.state.cellState || (e4.state.cellState = {}), t4.state = void 0 !== e4.state.cellState[t4.column.id] ? e4.state.cellState[t4.column.id] : u3(t4), t4.setState = function(o4) {
+                        return n3.setCellState(e4.id, t4.column.id, o4);
+                    };
+                }));
             }
-            return completeAttributeValueUnquoted(code2);
-        }
+            xt2.pluginName = "useRowState", l2.resetColumnOrder = "resetColumnOrder", l2.setColumnOrder = "setColumnOrder";
+            var It2 = function(e4) {
+                e4.stateReducers.push(Ft2), e4.visibleColumnsDeps.push(function(e6, t3) {
+                    var n3 = t3.instance;
+                    return [].concat(e6, [n3.state.columnOrder]);
+                }), e4.visibleColumns.push(Gt2), e4.useInstance.push(At2);
+            };
 
-        function completeAttributeValueQuoted(code2) {
-            if (code2 === markerB) {
-                effects.consume(code2);
-                markerB = null;
-                return completeAttributeValueQuotedAfter;
-            }
-            if (code2 === null || markdownLineEnding(code2)) {
-                return nok(code2);
+            function Ft2(e4, t3, n3, o3) {
+                return t3.type === l2.init ? r2({
+                    columnOrder: []
+                }, e4) : t3.type === l2.resetColumnOrder ? r2({}, e4, {
+                    columnOrder: o3.initialState.columnOrder || []
+                }) : t3.type === l2.setColumnOrder ? r2({}, e4, {
+                    columnOrder: m2(t3.columnOrder, e4.columnOrder)
+                }) : void 0;
             }
-            effects.consume(code2);
-            return completeAttributeValueQuoted;
-        }
 
-        function completeAttributeValueUnquoted(code2) {
-            if (code2 === null || code2 === 34 || code2 === 39 || code2 === 47 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace(code2)) {
-                return completeAttributeNameAfter(code2);
+            function Gt2(e4, t3) {
+                var n3 = t3.instance.state.columnOrder;
+                if (!n3 || !n3.length)
+                    return e4;
+                for (var o3 = [].concat(n3), r3 = [].concat(e4), i3 = [], u3 = function() {
+                        var e6 = o3.shift(),
+                            t4 = r3.findIndex(function(t5) {
+                                return t5.id === e6;
+                            });
+                        t4 > -1 && i3.push(r3.splice(t4, 1)[0]);
+                    }; r3.length && o3.length;)
+                    u3();
+                return [].concat(i3, r3);
             }
-            effects.consume(code2);
-            return completeAttributeValueUnquoted;
-        }
 
-        function completeAttributeValueQuotedAfter(code2) {
-            if (code2 === 47 || code2 === 62 || markdownSpace(code2)) {
-                return completeAttributeNameBefore(code2);
+            function At2(e4) {
+                var n3 = e4.dispatch;
+                e4.setColumnOrder = t2.useCallback(function(e6) {
+                    return n3({
+                        type: l2.setColumnOrder,
+                        columnOrder: e6
+                    });
+                }, [n3]);
             }
-            return nok(code2);
-        }
+            It2.pluginName = "useColumnOrder", c2.canResize = true, l2.columnStartResizing = "columnStartResizing", l2.columnResizing = "columnResizing", l2.columnDoneResizing = "columnDoneResizing", l2.resetResize = "resetResize";
+            var kt2 = function(e4) {
+                    e4.getResizerProps = [Ht2], e4.getHeaderProps.push({
+                        style: {
+                            position: "relative"
+                        }
+                    }), e4.stateReducers.push(Tt2), e4.useInstance.push(Wt2), e4.useInstanceBeforeDimensions.push(zt2);
+                },
+                Ht2 = function(e4, t3) {
+                    var n3 = t3.instance,
+                        o3 = t3.header,
+                        r3 = n3.dispatch,
+                        i3 = function(e6, t4) {
+                            var n4 = false;
+                            if ("touchstart" === e6.type) {
+                                if (e6.touches && e6.touches.length > 1)
+                                    return;
+                                n4 = true;
+                            }
+                            var o4 = function(e7) {
+                                    var t5 = [];
+                                    return function e8(n5) {
+                                        n5.columns && n5.columns.length && n5.columns.map(e8);
+                                        t5.push(n5);
+                                    }(e7), t5;
+                                }(t4).map(function(e7) {
+                                    return [e7.id, e7.totalWidth];
+                                }),
+                                i4 = n4 ? Math.round(e6.touches[0].clientX) : e6.clientX,
+                                u3 = function(e7) {
+                                    r3({
+                                        type: l2.columnResizing,
+                                        clientX: e7
+                                    });
+                                },
+                                s3 = function() {
+                                    return r3({
+                                        type: l2.columnDoneResizing
+                                    });
+                                },
+                                a3 = {
+                                    mouse: {
+                                        moveEvent: "mousemove",
+                                        moveHandler: function(e7) {
+                                            return u3(e7.clientX);
+                                        },
+                                        upEvent: "mouseup",
+                                        upHandler: function(e7) {
+                                            document.removeEventListener("mousemove", a3.mouse.moveHandler), document.removeEventListener("mouseup", a3.mouse.upHandler), s3();
+                                        }
+                                    },
+                                    touch: {
+                                        moveEvent: "touchmove",
+                                        moveHandler: function(e7) {
+                                            return e7.cancelable && (e7.preventDefault(), e7.stopPropagation()), u3(e7.touches[0].clientX), false;
+                                        },
+                                        upEvent: "touchend",
+                                        upHandler: function(e7) {
+                                            document.removeEventListener(a3.touch.moveEvent, a3.touch.moveHandler), document.removeEventListener(a3.touch.upEvent, a3.touch.moveHandler), s3();
+                                        }
+                                    }
+                                },
+                                c3 = n4 ? a3.touch : a3.mouse,
+                                d3 = !! function() {
+                                    if ("boolean" == typeof z2)
+                                        return z2;
+                                    var e7 = false;
+                                    try {
+                                        var t5 = {
+                                            get passive() {
+                                                return e7 = true, false;
+                                            }
+                                        };
+                                        window.addEventListener("test", null, t5), window.removeEventListener("test", null, t5);
+                                    } catch (t6) {
+                                        e7 = false;
+                                    }
+                                    return z2 = e7;
+                                }() && {
+                                    passive: false
+                                };
+                            document.addEventListener(c3.moveEvent, c3.moveHandler, d3), document.addEventListener(c3.upEvent, c3.upHandler, d3), r3({
+                                type: l2.columnStartResizing,
+                                columnId: t4.id,
+                                columnWidth: t4.totalWidth,
+                                headerIdWidths: o4,
+                                clientX: i4
+                            });
+                        };
+                    return [e4, {
+                        onMouseDown: function(e6) {
+                            return e6.persist() || i3(e6, o3);
+                        },
+                        onTouchStart: function(e6) {
+                            return e6.persist() || i3(e6, o3);
+                        },
+                        style: {
+                            cursor: "col-resize"
+                        },
+                        draggable: false,
+                        role: "separator"
+                    }];
+                };
 
-        function completeEnd(code2) {
-            if (code2 === 62) {
-                effects.consume(code2);
-                return completeAfter;
+            function Tt2(e4, t3) {
+                if (t3.type === l2.init)
+                    return r2({
+                        columnResizing: {
+                            columnWidths: {}
+                        }
+                    }, e4);
+                if (t3.type === l2.resetResize)
+                    return r2({}, e4, {
+                        columnResizing: {
+                            columnWidths: {}
+                        }
+                    });
+                if (t3.type === l2.columnStartResizing) {
+                    var n3 = t3.clientX,
+                        o3 = t3.columnId,
+                        i3 = t3.columnWidth,
+                        u3 = t3.headerIdWidths;
+                    return r2({}, e4, {
+                        columnResizing: r2({}, e4.columnResizing, {
+                            startX: n3,
+                            headerIdWidths: u3,
+                            columnWidth: i3,
+                            isResizingColumn: o3
+                        })
+                    });
+                }
+                if (t3.type === l2.columnResizing) {
+                    var s3 = t3.clientX,
+                        a3 = e4.columnResizing,
+                        c3 = a3.startX,
+                        d3 = a3.columnWidth,
+                        f3 = a3.headerIdWidths,
+                        p3 = (s3 - c3) / d3,
+                        g3 = {};
+                    return (void 0 === f3 ? [] : f3).forEach(function(e6) {
+                        var t4 = e6[0],
+                            n4 = e6[1];
+                        g3[t4] = Math.max(n4 + n4 * p3, 0);
+                    }), r2({}, e4, {
+                        columnResizing: r2({}, e4.columnResizing, {
+                            columnWidths: r2({}, e4.columnResizing.columnWidths, {}, g3)
+                        })
+                    });
+                }
+                return t3.type === l2.columnDoneResizing ? r2({}, e4, {
+                    columnResizing: r2({}, e4.columnResizing, {
+                        startX: null,
+                        isResizingColumn: null
+                    })
+                }) : void 0;
             }
-            return nok(code2);
-        }
+            kt2.pluginName = "useResizeColumns";
+            var zt2 = function(e4) {
+                var t3 = e4.flatHeaders,
+                    n3 = e4.disableResizing,
+                    o3 = e4.getHooks,
+                    r3 = e4.state.columnResizing,
+                    i3 = h2(e4);
+                t3.forEach(function(e6) {
+                    var t4 = I2(true !== e6.disableResizing && void 0, true !== n3 && void 0, true);
+                    e6.canResize = t4, e6.width = r3.columnWidths[e6.id] || e6.originalWidth || e6.width, e6.isResizing = r3.isResizingColumn === e6.id, t4 && (e6.getResizerProps = f2(o3().getResizerProps, {
+                        instance: i3(),
+                        header: e6
+                    }));
+                });
+            };
 
-        function completeAfter(code2) {
-            if (code2 === null || markdownLineEnding(code2)) {
-                return continuation(code2);
-            }
-            if (markdownSpace(code2)) {
-                effects.consume(code2);
-                return completeAfter;
+            function Wt2(e4) {
+                var n3 = e4.plugins,
+                    o3 = e4.dispatch,
+                    r3 = e4.autoResetResize,
+                    i3 = void 0 === r3 || r3,
+                    u3 = e4.columns;
+                v2(n3, ["useAbsoluteLayout"], "useResizeColumns");
+                var s3 = h2(i3);
+                w2(function() {
+                    s3() && o3({
+                        type: l2.resetResize
+                    });
+                }, [u3]);
+                var a3 = t2.useCallback(function() {
+                    return o3({
+                        type: l2.resetResize
+                    });
+                }, [o3]);
+                Object.assign(e4, {
+                    resetResizing: a3
+                });
             }
-            return nok(code2);
-        }
+            var Ot2 = {
+                    position: "absolute",
+                    top: 0
+                },
+                Mt2 = function(e4) {
+                    e4.getTableBodyProps.push(jt2), e4.getRowProps.push(jt2), e4.getHeaderGroupProps.push(jt2), e4.getFooterGroupProps.push(jt2), e4.getHeaderProps.push(function(e6, t3) {
+                        var n3 = t3.column;
+                        return [e6, {
+                            style: r2({}, Ot2, {
+                                left: n3.totalLeft + "px",
+                                width: n3.totalWidth + "px"
+                            })
+                        }];
+                    }), e4.getCellProps.push(function(e6, t3) {
+                        var n3 = t3.cell;
+                        return [e6, {
+                            style: r2({}, Ot2, {
+                                left: n3.column.totalLeft + "px",
+                                width: n3.column.totalWidth + "px"
+                            })
+                        }];
+                    }), e4.getFooterProps.push(function(e6, t3) {
+                        var n3 = t3.column;
+                        return [e6, {
+                            style: r2({}, Ot2, {
+                                left: n3.totalLeft + "px",
+                                width: n3.totalWidth + "px"
+                            })
+                        }];
+                    });
+                };
+            Mt2.pluginName = "useAbsoluteLayout";
+            var jt2 = function(e4, t3) {
+                    return [e4, {
+                        style: {
+                            position: "relative",
+                            width: t3.instance.totalColumnsWidth + "px"
+                        }
+                    }];
+                },
+                Nt2 = {
+                    display: "inline-block",
+                    boxSizing: "border-box"
+                },
+                Lt2 = function(e4, t3) {
+                    return [e4, {
+                        style: {
+                            display: "flex",
+                            width: t3.instance.totalColumnsWidth + "px"
+                        }
+                    }];
+                },
+                Dt2 = function(e4) {
+                    e4.getRowProps.push(Lt2), e4.getHeaderGroupProps.push(Lt2), e4.getFooterGroupProps.push(Lt2), e4.getHeaderProps.push(function(e6, t3) {
+                        var n3 = t3.column;
+                        return [e6, {
+                            style: r2({}, Nt2, {
+                                width: n3.totalWidth + "px"
+                            })
+                        }];
+                    }), e4.getCellProps.push(function(e6, t3) {
+                        var n3 = t3.cell;
+                        return [e6, {
+                            style: r2({}, Nt2, {
+                                width: n3.column.totalWidth + "px"
+                            })
+                        }];
+                    }), e4.getFooterProps.push(function(e6, t3) {
+                        var n3 = t3.column;
+                        return [e6, {
+                            style: r2({}, Nt2, {
+                                width: n3.totalWidth + "px"
+                            })
+                        }];
+                    });
+                };
 
-        function continuation(code2) {
-            if (code2 === 45 && marker === 2) {
-                effects.consume(code2);
-                return continuationCommentInside;
-            }
-            if (code2 === 60 && marker === 1) {
-                effects.consume(code2);
-                return continuationRawTagOpen;
-            }
-            if (code2 === 62 && marker === 4) {
-                effects.consume(code2);
-                return continuationClose;
-            }
-            if (code2 === 63 && marker === 3) {
-                effects.consume(code2);
-                return continuationDeclarationInside;
-            }
-            if (code2 === 93 && marker === 5) {
-                effects.consume(code2);
-                return continuationCdataInside;
-            }
-            if (markdownLineEnding(code2) && (marker === 6 || marker === 7)) {
-                effects.exit("htmlFlowData");
-                return effects.check(
-                    blankLineBefore,
-                    continuationAfter,
-                    continuationStart
-                )(code2);
-            }
-            if (code2 === null || markdownLineEnding(code2)) {
-                effects.exit("htmlFlowData");
-                return continuationStart(code2);
+            function Vt2(e4) {
+                e4.getTableProps.push(_t2), e4.getRowProps.push(Xt2), e4.getHeaderGroupProps.push(Xt2), e4.getFooterGroupProps.push(Xt2), e4.getHeaderProps.push(qt2), e4.getCellProps.push(Kt2), e4.getFooterProps.push(Ut2);
             }
-            effects.consume(code2);
-            return continuation;
-        }
-
-        function continuationStart(code2) {
-            return effects.check(
-                nonLazyContinuationStart,
-                continuationStartNonLazy,
-                continuationAfter
-            )(code2);
-        }
-
-        function continuationStartNonLazy(code2) {
-            effects.enter("lineEnding");
-            effects.consume(code2);
-            effects.exit("lineEnding");
-            return continuationBefore;
-        }
+            Dt2.pluginName = "useBlockLayout", Vt2.pluginName = "useFlexLayout";
+            var _t2 = function(e4, t3) {
+                    return [e4, {
+                        style: {
+                            minWidth: t3.instance.totalColumnsMinWidth + "px"
+                        }
+                    }];
+                },
+                Xt2 = function(e4, t3) {
+                    return [e4, {
+                        style: {
+                            display: "flex",
+                            flex: "1 0 auto",
+                            minWidth: t3.instance.totalColumnsMinWidth + "px"
+                        }
+                    }];
+                },
+                qt2 = function(e4, t3) {
+                    var n3 = t3.column;
+                    return [e4, {
+                        style: {
+                            boxSizing: "border-box",
+                            flex: n3.totalFlexWidth ? n3.totalFlexWidth + " 0 auto" : void 0,
+                            minWidth: n3.totalMinWidth + "px",
+                            width: n3.totalWidth + "px"
+                        }
+                    }];
+                },
+                Kt2 = function(e4, t3) {
+                    var n3 = t3.cell;
+                    return [e4, {
+                        style: {
+                            boxSizing: "border-box",
+                            flex: n3.column.totalFlexWidth + " 0 auto",
+                            minWidth: n3.column.totalMinWidth + "px",
+                            width: n3.column.totalWidth + "px"
+                        }
+                    }];
+                },
+                Ut2 = function(e4, t3) {
+                    var n3 = t3.column;
+                    return [e4, {
+                        style: {
+                            boxSizing: "border-box",
+                            flex: n3.totalFlexWidth ? n3.totalFlexWidth + " 0 auto" : void 0,
+                            minWidth: n3.totalMinWidth + "px",
+                            width: n3.totalWidth + "px"
+                        }
+                    }];
+                };
 
-        function continuationBefore(code2) {
-            if (code2 === null || markdownLineEnding(code2)) {
-                return continuationStart(code2);
+            function $t2(e4) {
+                e4.stateReducers.push(Qt2), e4.getTableProps.push(Jt), e4.getHeaderProps.push(Yt2);
             }
-            effects.enter("htmlFlowData");
-            return continuation(code2);
-        }
+            $t2.pluginName = "useGridLayout";
+            var Jt = function(e4, t3) {
+                    return [e4, {
+                        style: {
+                            display: "grid",
+                            gridTemplateColumns: t3.instance.state.gridLayout.columnWidths.map(function(e6) {
+                                return e6;
+                            }).join(" ")
+                        }
+                    }];
+                },
+                Yt2 = function(e4, t3) {
+                    return [e4, {
+                        id: "header-cell-" + t3.column.id,
+                        style: {
+                            position: "sticky"
+                        }
+                    }];
+                };
 
-        function continuationCommentInside(code2) {
-            if (code2 === 45) {
-                effects.consume(code2);
-                return continuationDeclarationInside;
+            function Qt2(e4, t3, n3, o3) {
+                if ("init" === t3.type)
+                    return r2({
+                        gridLayout: {
+                            columnWidths: o3.columns.map(function() {
+                                return "auto";
+                            })
+                        }
+                    }, e4);
+                if ("columnStartResizing" === t3.type) {
+                    var i3 = t3.columnId,
+                        u3 = o3.visibleColumns.findIndex(function(e6) {
+                            return e6.id === i3;
+                        }),
+                        l3 = function(e6) {
+                            var t4, n4 = null == (t4 = document.getElementById("header-cell-" + e6)) ? void 0 : t4.offsetWidth;
+                            if (void 0 !== n4)
+                                return n4;
+                        }(i3);
+                    return void 0 !== l3 ? r2({}, e4, {
+                        gridLayout: r2({}, e4.gridLayout, {
+                            columnId: i3,
+                            columnIndex: u3,
+                            startingWidth: l3
+                        })
+                    }) : e4;
+                }
+                if ("columnResizing" === t3.type) {
+                    var s3 = e4.gridLayout,
+                        a3 = s3.columnIndex,
+                        c3 = s3.startingWidth,
+                        d3 = s3.columnWidths,
+                        f3 = c3 - (e4.columnResizing.startX - t3.clientX),
+                        p3 = [].concat(d3);
+                    return p3[a3] = f3 + "px", r2({}, e4, {
+                        gridLayout: r2({}, e4.gridLayout, {
+                            columnWidths: p3
+                        })
+                    });
+                }
             }
-            return continuation(code2);
+            e3._UNSTABLE_usePivotColumns = nt2, e3.actions = l2, e3.defaultColumn = c2, e3.defaultGroupByFn = De2, e3.defaultOrderByFn = Qe2, e3.defaultRenderer = s2, e3.emptyRenderer = a2, e3.ensurePluginOrder = v2, e3.flexRender = b2, e3.functionalUpdate = m2, e3.loopHooks = g2, e3.makePropGetter = f2, e3.makeRenderer = R2, e3.reduceHooks = p2, e3.safeUseLayoutEffect = y2, e3.useAbsoluteLayout = Mt2, e3.useAsyncDebounce = function(e4, n3) {
+                void 0 === n3 && (n3 = 0);
+                var r3 = t2.useRef({}),
+                    i3 = h2(e4),
+                    u3 = h2(n3);
+                return t2.useCallback(function() {
+                    var e6 = o2(regeneratorRuntime.mark(function e7() {
+                        var t3, n4, l3, s3 = arguments;
+                        return regeneratorRuntime.wrap(function(e8) {
+                            for (;;)
+                                switch (e8.prev = e8.next) {
+                                    case 0:
+                                        for (t3 = s3.length, n4 = new Array(t3), l3 = 0; l3 < t3; l3++)
+                                            n4[l3] = s3[l3];
+                                        return r3.current.promise || (r3.current.promise = new Promise(function(e9, t4) {
+                                            r3.current.resolve = e9, r3.current.reject = t4;
+                                        })), r3.current.timeout && clearTimeout(r3.current.timeout), r3.current.timeout = setTimeout(o2(regeneratorRuntime.mark(function e9() {
+                                            return regeneratorRuntime.wrap(function(e11) {
+                                                for (;;)
+                                                    switch (e11.prev = e11.next) {
+                                                        case 0:
+                                                            return delete r3.current.timeout, e11.prev = 1, e11.t0 = r3.current, e11.next = 5, i3().apply(void 0, n4);
+                                                        case 5:
+                                                            e11.t1 = e11.sent, e11.t0.resolve.call(e11.t0, e11.t1), e11.next = 12;
+                                                            break;
+                                                        case 9:
+                                                            e11.prev = 9, e11.t2 = e11.catch(1), r3.current.reject(e11.t2);
+                                                        case 12:
+                                                            return e11.prev = 12, delete r3.current.promise, e11.finish(12);
+                                                        case 15:
+                                                        case "end":
+                                                            return e11.stop();
+                                                    }
+                                            }, e9, null, [
+                                                [1, 9, 12, 15]
+                                            ]);
+                                        })), u3()), e8.abrupt("return", r3.current.promise);
+                                    case 5:
+                                    case "end":
+                                        return e8.stop();
+                                }
+                        }, e7);
+                    }));
+                    return function() {
+                        return e6.apply(this, arguments);
+                    };
+                }(), [i3, u3]);
+            }, e3.useBlockLayout = Dt2, e3.useColumnOrder = It2, e3.useExpanded = se2, e3.useFilters = Pe2, e3.useFlexLayout = Vt2, e3.useGetLatest = h2, e3.useGlobalFilter = Ie2, e3.useGridLayout = $t2, e3.useGroupBy = ze2, e3.useMountedLayoutEffect = w2, e3.usePagination = Ze2, e3.useResizeColumns = kt2, e3.useRowSelect = vt2, e3.useRowState = xt2, e3.useSortBy = Ue2, e3.useTable = function(e4) {
+                for (var n3 = arguments.length, o3 = new Array(n3 > 1 ? n3 - 1 : 0), i3 = 1; i3 < n3; i3++)
+                    o3[i3 - 1] = arguments[i3];
+                e4 = ie2(e4), o3 = [K2].concat(o3);
+                var u3 = t2.useRef({}),
+                    s3 = h2(u3.current);
+                Object.assign(s3(), r2({}, e4, {
+                    plugins: o3,
+                    hooks: q2()
+                })), o3.filter(Boolean).forEach(function(e6) {
+                    e6(s3().hooks);
+                });
+                var a3 = h2(s3().hooks);
+                s3().getHooks = a3, delete s3().hooks, Object.assign(s3(), p2(a3().useOptions, ie2(e4)));
+                var c3 = s3(),
+                    d3 = c3.data,
+                    v3 = c3.columns,
+                    m3 = c3.initialState,
+                    y3 = c3.defaultColumn,
+                    w3 = c3.getSubRows,
+                    b3 = c3.getRowId,
+                    E3 = c3.stateReducer,
+                    I3 = c3.useControlledState,
+                    F3 = h2(E3),
+                    G3 = t2.useCallback(function(e6, t3) {
+                        if (!t3.type)
+                            throw console.info({
+                                action: t3
+                            }), new Error("Unknown Action \u{1F446}");
+                        return [].concat(a3().stateReducers, Array.isArray(F3()) ? F3() : [F3()]).reduce(function(n4, o4) {
+                            return o4(n4, t3, e6, s3()) || n4;
+                        }, e6);
+                    }, [a3, F3, s3]),
+                    A3 = t2.useReducer(G3, void 0, function() {
+                        return G3(m3, {
+                            type: l2.init
+                        });
+                    }),
+                    k3 = A3[0],
+                    H3 = A3[1],
+                    T3 = p2([].concat(a3().useControlledState, [I3]), k3, {
+                        instance: s3()
+                    });
+                Object.assign(s3(), {
+                    state: T3,
+                    dispatch: H3
+                });
+                var z3 = t2.useMemo(function() {
+                    return S2(p2(a3().columns, v3, {
+                        instance: s3()
+                    }));
+                }, [a3, s3, v3].concat(p2(a3().columnsDeps, [], {
+                    instance: s3()
+                })));
+                s3().columns = z3;
+                var W3 = t2.useMemo(function() {
+                    return p2(a3().allColumns, C2(z3), {
+                        instance: s3()
+                    }).map(x2);
+                }, [z3, a3, s3].concat(p2(a3().allColumnsDeps, [], {
+                    instance: s3()
+                })));
+                s3().allColumns = W3;
+                var O3 = t2.useMemo(function() {
+                        for (var e6 = [], t3 = [], n4 = {}, o4 = [].concat(W3); o4.length;) {
+                            var r3 = o4.shift();
+                            le2({
+                                data: d3,
+                                rows: e6,
+                                flatRows: t3,
+                                rowsById: n4,
+                                column: r3,
+                                getRowId: b3,
+                                getSubRows: w3,
+                                accessValueHooks: a3().accessValue,
+                                getInstance: s3
+                            });
+                        }
+                        return [e6, t3, n4];
+                    }, [W3, d3, b3, w3, a3, s3]),
+                    M3 = O3[0],
+                    j3 = O3[1],
+                    N3 = O3[2];
+                Object.assign(s3(), {
+                    rows: M3,
+                    initialRows: [].concat(M3),
+                    flatRows: j3,
+                    rowsById: N3
+                }), g2(a3().useInstanceAfterData, s3());
+                var L3 = t2.useMemo(function() {
+                    return p2(a3().visibleColumns, W3, {
+                        instance: s3()
+                    }).map(function(e6) {
+                        return P2(e6, y3);
+                    });
+                }, [a3, W3, s3, y3].concat(p2(a3().visibleColumnsDeps, [], {
+                    instance: s3()
+                })));
+                W3 = t2.useMemo(function() {
+                    var e6 = [].concat(L3);
+                    return W3.forEach(function(t3) {
+                        e6.find(function(e7) {
+                            return e7.id === t3.id;
+                        }) || e6.push(t3);
+                    }), e6;
+                }, [W3, L3]), s3().allColumns = W3;
+                var D3 = t2.useMemo(function() {
+                    return p2(a3().headerGroups, B2(L3, y3), s3());
+                }, [a3, L3, y3, s3].concat(p2(a3().headerGroupsDeps, [], {
+                    instance: s3()
+                })));
+                s3().headerGroups = D3;
+                var V3 = t2.useMemo(function() {
+                    return D3.length ? D3[0].headers : [];
+                }, [D3]);
+                s3().headers = V3, s3().flatHeaders = D3.reduce(function(e6, t3) {
+                    return [].concat(e6, t3.headers);
+                }, []), g2(a3().useInstanceBeforeDimensions, s3());
+                var _3 = L3.filter(function(e6) {
+                    return e6.isVisible;
+                }).map(function(e6) {
+                    return e6.id;
+                }).sort().join("_");
+                L3 = t2.useMemo(function() {
+                    return L3.filter(function(e6) {
+                        return e6.isVisible;
+                    });
+                }, [L3, _3]), s3().visibleColumns = L3;
+                var X3 = ue2(V3),
+                    U3 = X3[0],
+                    $3 = X3[1],
+                    J3 = X3[2];
+                return s3().totalColumnsMinWidth = U3, s3().totalColumnsWidth = $3, s3().totalColumnsMaxWidth = J3, g2(a3().useInstance, s3()), [].concat(s3().flatHeaders, s3().allColumns).forEach(function(e6) {
+                    e6.render = R2(s3(), e6), e6.getHeaderProps = f2(a3().getHeaderProps, {
+                        instance: s3(),
+                        column: e6
+                    }), e6.getFooterProps = f2(a3().getFooterProps, {
+                        instance: s3(),
+                        column: e6
+                    });
+                }), s3().headerGroups = t2.useMemo(function() {
+                    return D3.filter(function(e6, t3) {
+                        return e6.headers = e6.headers.filter(function(e7) {
+                            return e7.headers ? function e8(t4) {
+                                return t4.filter(function(t5) {
+                                    return t5.headers ? e8(t5.headers) : t5.isVisible;
+                                }).length;
+                            }(e7.headers) : e7.isVisible;
+                        }), !!e6.headers.length && (e6.getHeaderGroupProps = f2(a3().getHeaderGroupProps, {
+                            instance: s3(),
+                            headerGroup: e6,
+                            index: t3
+                        }), e6.getFooterGroupProps = f2(a3().getFooterGroupProps, {
+                            instance: s3(),
+                            headerGroup: e6,
+                            index: t3
+                        }), true);
+                    });
+                }, [D3, s3, a3]), s3().footerGroups = [].concat(s3().headerGroups).reverse(), s3().prepareRow = t2.useCallback(function(e6) {
+                    e6.getRowProps = f2(a3().getRowProps, {
+                        instance: s3(),
+                        row: e6
+                    }), e6.allCells = W3.map(function(t3) {
+                        var n4 = e6.values[t3.id],
+                            o4 = {
+                                column: t3,
+                                row: e6,
+                                value: n4
+                            };
+                        return o4.getCellProps = f2(a3().getCellProps, {
+                            instance: s3(),
+                            cell: o4
+                        }), o4.render = R2(s3(), t3, {
+                            row: e6,
+                            cell: o4,
+                            value: n4
+                        }), o4;
+                    }), e6.cells = L3.map(function(t3) {
+                        return e6.allCells.find(function(e7) {
+                            return e7.column.id === t3.id;
+                        });
+                    }), g2(a3().prepareRow, e6, {
+                        instance: s3()
+                    });
+                }, [a3, s3, W3, L3]), s3().getTableProps = f2(a3().getTableProps, {
+                    instance: s3()
+                }), s3().getTableBodyProps = f2(a3().getTableBodyProps, {
+                    instance: s3()
+                }), g2(a3().useFinalInstance, s3()), s3();
+            }, Object.defineProperty(e3, "__esModule", {
+                value: true
+            });
+        });
+    })(reactTable_production_min, reactTable_production_min.exports);
+    (function(module2) {
+        {
+            module2.exports = reactTable_production_min.exports;
         }
-
-        function continuationRawTagOpen(code2) {
-            if (code2 === 47) {
-                effects.consume(code2);
-                buffer = "";
-                return continuationRawEndTag;
+    })(reactTable);
+    var build = {};
+    (function(exports3) {
+        Object.defineProperty(exports3, "__esModule", {
+            value: true
+        });
+        exports3.checkErrors = (columns) => {
+            const hasGroups = !!columns.find((column) => column.parent);
+            const stickyColumnsWithoutGroup = columns.filter((column) => column.sticky && !column.parent).map(({
+                Header: Header2
+            }) => `'${Header2}'`);
+            if (hasGroups && stickyColumnsWithoutGroup.length) {
+                throw new Error(`WARNING react-table-sticky:
+      
+Your ReactTable has group and sticky columns outside groups, and that will break UI.
+      
+You must place ${stickyColumnsWithoutGroup.join(" and ")} columns into a group (even a group with an empty Header label)
+`);
             }
-            return continuation(code2);
-        }
+            const bugWithUnderColumnsSticky = columns.find((parentCol) => !parentCol.sticky && parentCol.columns && parentCol.columns.find((col) => col.sticky));
+            if (!bugWithUnderColumnsSticky)
+                return;
+            const childBugs = bugWithUnderColumnsSticky.columns.find(({
+                sticky
+            }) => sticky);
+            if (!childBugs)
+                return;
+            throw new Error(`WARNING react-table-sticky:
+    
+Your ReactTable contain columns group with at least one child columns sticky.
+    
+When ReactTable has columns groups, only columns groups can be sticky
+    
+You must set sticky: 'left' | 'right' for the '${bugWithUnderColumnsSticky.Header}'
+    column, or remove the sticky property of '${childBugs.Header}' column.`);
+        };
 
-        function continuationRawEndTag(code2) {
-            if (code2 === 62) {
-                const name2 = buffer.toLowerCase();
-                if (htmlRawNames.includes(name2)) {
-                    effects.consume(code2);
-                    return continuationClose;
-                }
-                return continuation(code2);
+        function getStickyValue(column) {
+            if (column.sticky === "left" || column.sticky === "right") {
+                return column.sticky;
             }
-            if (asciiAlpha(code2) && buffer.length < 8) {
-                effects.consume(code2);
-                buffer += String.fromCharCode(code2);
-                return continuationRawEndTag;
+            if (column.parent) {
+                return getStickyValue(column.parent);
             }
-            return continuation(code2);
+            return null;
         }
+        exports3.getStickyValue = getStickyValue;
 
-        function continuationCdataInside(code2) {
-            if (code2 === 93) {
-                effects.consume(code2);
-                return continuationDeclarationInside;
-            }
-            return continuation(code2);
+        function columnIsLastLeftSticky(columnId, columns) {
+            const index2 = columns.findIndex(({
+                id: id2
+            }) => id2 === columnId);
+            const column = columns[index2];
+            const nextColumn = columns[index2 + 1];
+            const columnIsLeftSticky = getStickyValue(column) === "left";
+            const nextColumnIsLeftSticky = nextColumn && getStickyValue(nextColumn) === "left";
+            return columnIsLeftSticky && !nextColumnIsLeftSticky;
         }
+        exports3.columnIsLastLeftSticky = columnIsLastLeftSticky;
 
-        function continuationDeclarationInside(code2) {
-            if (code2 === 62) {
-                effects.consume(code2);
-                return continuationClose;
-            }
-            if (code2 === 45 && marker === 2) {
-                effects.consume(code2);
-                return continuationDeclarationInside;
-            }
-            return continuation(code2);
+        function columnIsFirstRightSticky(columnId, columns) {
+            const index2 = columns.findIndex(({
+                id: id2
+            }) => id2 === columnId);
+            const column = columns[index2];
+            const prevColumn = columns[index2 - 1];
+            const columnIsRightSticky = getStickyValue(column) === "right";
+            const prevColumnIsRightSticky = prevColumn && getStickyValue(prevColumn) === "right";
+            return columnIsRightSticky && !prevColumnIsRightSticky;
         }
+        exports3.columnIsFirstRightSticky = columnIsFirstRightSticky;
 
-        function continuationClose(code2) {
-            if (code2 === null || markdownLineEnding(code2)) {
-                effects.exit("htmlFlowData");
-                return continuationAfter(code2);
+        function getMarginRight(columnId, columns) {
+            const currentIndex = columns.findIndex(({
+                id: id2
+            }) => id2 === columnId);
+            let rightMargin = 0;
+            for (let i2 = currentIndex + 1; i2 < columns.length; i2 += 1) {
+                if (columns[i2].isVisible !== false) {
+                    rightMargin += columns[i2].width;
+                }
             }
-            effects.consume(code2);
-            return continuationClose;
+            return rightMargin;
         }
+        exports3.getMarginRight = getMarginRight;
+        const cellStylesSticky = {
+            position: "sticky",
+            zIndex: 3
+        };
 
-        function continuationAfter(code2) {
-            effects.exit("htmlFlow");
-            return ok2(code2);
+        function findHeadersSameLevel(header, headers) {
+            return headers.filter((flatHeaderItem) => {
+                return flatHeaderItem.depth === header.depth;
+            });
         }
-    }
-
-    function tokenizeNonLazyContinuationStart(effects, ok2, nok) {
-        const self2 = this;
-        return start2;
 
-        function start2(code2) {
-            if (markdownLineEnding(code2)) {
-                effects.enter("lineEnding");
-                effects.consume(code2);
-                effects.exit("lineEnding");
-                return after;
+        function getStickyProps(header, instance2) {
+            let style2 = {};
+            const dataAttrs = {};
+            exports3.checkErrors(instance2.columns);
+            const sticky = getStickyValue(header);
+            if (sticky) {
+                style2 = Object.assign({}, cellStylesSticky);
+                dataAttrs["data-sticky-td"] = true;
+                const headers = findHeadersSameLevel(header, instance2.flatHeaders);
+                const margin = sticky === "left" ? header.totalLeft : getMarginRight(header.id, headers);
+                style2 = Object.assign(Object.assign({}, style2), {
+                    [sticky]: `${margin}px`
+                });
+                const isLastLeftSticky = columnIsLastLeftSticky(header.id, headers);
+                if (isLastLeftSticky) {
+                    dataAttrs["data-sticky-last-left-td"] = true;
+                }
+                const isFirstRightSticky = columnIsFirstRightSticky(header.id, headers);
+                if (isFirstRightSticky) {
+                    dataAttrs["data-sticky-first-right-td"] = true;
+                }
             }
-            return nok(code2);
-        }
-
-        function after(code2) {
-            return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
+            return Object.assign({
+                style: style2
+            }, dataAttrs);
         }
-    }
-
-    function tokenizeBlankLineBefore(effects, ok2, nok) {
-        return start2;
-
-        function start2(code2) {
-            effects.enter("lineEnding");
-            effects.consume(code2);
-            effects.exit("lineEnding");
-            return effects.attempt(blankLine, ok2, nok);
+        exports3.useSticky = (hooks) => {
+            hooks.getHeaderProps.push((props, {
+                instance: instance2,
+                column
+            }) => {
+                const nextProps = getStickyProps(column, instance2);
+                return [props, nextProps];
+            });
+            hooks.getCellProps.push((props, {
+                instance: instance2,
+                cell
+            }) => {
+                const nextProps = getStickyProps(cell.column, instance2);
+                return [props, nextProps];
+            });
+        };
+        exports3.useSticky.pluginName = "useSticky";
+    })(build);
+    var classCallCheck = function(instance2, Constructor) {
+        if (!(instance2 instanceof Constructor)) {
+            throw new TypeError("Cannot call a class as a function");
         }
-    }
-    const htmlText = {
-        name: "htmlText",
-        tokenize: tokenizeHtmlText
     };
-
-    function tokenizeHtmlText(effects, ok2, nok) {
-        const self2 = this;
-        let marker;
-        let index2;
-        let returnState;
-        return start2;
-
-        function start2(code2) {
-            effects.enter("htmlText");
-            effects.enter("htmlTextData");
-            effects.consume(code2);
-            return open;
-        }
-
-        function open(code2) {
-            if (code2 === 33) {
-                effects.consume(code2);
-                return declarationOpen;
-            }
-            if (code2 === 47) {
-                effects.consume(code2);
-                return tagCloseStart;
-            }
-            if (code2 === 63) {
-                effects.consume(code2);
-                return instruction;
-            }
-            if (asciiAlpha(code2)) {
-                effects.consume(code2);
-                return tagOpen;
+    var createClass = function() {
+        function defineProperties(target, props) {
+            for (var i2 = 0; i2 < props.length; i2++) {
+                var descriptor = props[i2];
+                descriptor.enumerable = descriptor.enumerable || false;
+                descriptor.configurable = true;
+                if ("value" in descriptor)
+                    descriptor.writable = true;
+                Object.defineProperty(target, descriptor.key, descriptor);
             }
-            return nok(code2);
         }
-
-        function declarationOpen(code2) {
-            if (code2 === 45) {
-                effects.consume(code2);
-                return commentOpenInside;
-            }
-            if (code2 === 91) {
-                effects.consume(code2);
-                index2 = 0;
-                return cdataOpenInside;
-            }
-            if (asciiAlpha(code2)) {
-                effects.consume(code2);
-                return declaration;
+        return function(Constructor, protoProps, staticProps) {
+            if (protoProps)
+                defineProperties(Constructor.prototype, protoProps);
+            if (staticProps)
+                defineProperties(Constructor, staticProps);
+            return Constructor;
+        };
+    }();
+    var _extends$2 = Object.assign || function(target) {
+        for (var i2 = 1; i2 < arguments.length; i2++) {
+            var source = arguments[i2];
+            for (var key in source) {
+                if (Object.prototype.hasOwnProperty.call(source, key)) {
+                    target[key] = source[key];
+                }
             }
-            return nok(code2);
         }
-
-        function commentOpenInside(code2) {
-            if (code2 === 45) {
-                effects.consume(code2);
-                return commentEnd;
-            }
-            return nok(code2);
+        return target;
+    };
+    var inherits = function(subClass, superClass) {
+        if (typeof superClass !== "function" && superClass !== null) {
+            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
         }
-
-        function comment2(code2) {
-            if (code2 === null) {
-                return nok(code2);
-            }
-            if (code2 === 45) {
-                effects.consume(code2);
-                return commentClose;
-            }
-            if (markdownLineEnding(code2)) {
-                returnState = comment2;
-                return lineEndingBefore(code2);
+        subClass.prototype = Object.create(superClass && superClass.prototype, {
+            constructor: {
+                value: subClass,
+                enumerable: false,
+                writable: true,
+                configurable: true
             }
-            effects.consume(code2);
-            return comment2;
+        });
+        if (superClass)
+            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
+    };
+    var possibleConstructorReturn = function(self2, call2) {
+        if (!self2) {
+            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
         }
-
-        function commentClose(code2) {
-            if (code2 === 45) {
-                effects.consume(code2);
-                return commentEnd;
+        return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
+    };
+    var slicedToArray = function() {
+        function sliceIterator(arr, i2) {
+            var _arr = [];
+            var _n2 = true;
+            var _d = false;
+            var _e2 = void 0;
+            try {
+                for (var _i2 = arr[Symbol.iterator](), _s; !(_n2 = (_s = _i2.next()).done); _n2 = true) {
+                    _arr.push(_s.value);
+                    if (i2 && _arr.length === i2)
+                        break;
+                }
+            } catch (err) {
+                _d = true;
+                _e2 = err;
+            } finally {
+                try {
+                    if (!_n2 && _i2["return"])
+                        _i2["return"]();
+                } finally {
+                    if (_d)
+                        throw _e2;
+                }
             }
-            return comment2(code2);
-        }
-
-        function commentEnd(code2) {
-            return code2 === 62 ? end2(code2) : code2 === 45 ? commentClose(code2) : comment2(code2);
+            return _arr;
         }
+        return function(arr, i2) {
+            if (Array.isArray(arr)) {
+                return arr;
+            } else if (Symbol.iterator in Object(arr)) {
+                return sliceIterator(arr, i2);
+            } else {
+                throw new TypeError("Invalid attempt to destructure non-iterable instance");
+            }
+        };
+    }();
+    var windowObject = void 0;
+    if (typeof window !== "undefined") {
+        windowObject = window;
+    } else if (typeof self !== "undefined") {
+        windowObject = self;
+    } else {
+        windowObject = global;
+    }
+    var cancelFrame = null;
+    var requestFrame = null;
+    var TIMEOUT_DURATION = 20;
+    var clearTimeoutFn = windowObject.clearTimeout;
+    var setTimeoutFn = windowObject.setTimeout;
+    var cancelAnimationFrameFn = windowObject.cancelAnimationFrame || windowObject.mozCancelAnimationFrame || windowObject.webkitCancelAnimationFrame;
+    var requestAnimationFrameFn = windowObject.requestAnimationFrame || windowObject.mozRequestAnimationFrame || windowObject.webkitRequestAnimationFrame;
+    if (cancelAnimationFrameFn == null || requestAnimationFrameFn == null) {
+        cancelFrame = clearTimeoutFn;
+        requestFrame = function requestAnimationFrameViaSetTimeout(callback) {
+            return setTimeoutFn(callback, TIMEOUT_DURATION);
+        };
+    } else {
+        cancelFrame = function cancelFrame2(_ref2) {
+            var _ref22 = slicedToArray(_ref2, 2),
+                animationFrameID = _ref22[0],
+                timeoutID = _ref22[1];
+            cancelAnimationFrameFn(animationFrameID);
+            clearTimeoutFn(timeoutID);
+        };
+        requestFrame = function requestAnimationFrameWithSetTimeoutFallback(callback) {
+            var animationFrameID = requestAnimationFrameFn(function animationFrameCallback() {
+                clearTimeoutFn(timeoutID);
+                callback();
+            });
+            var timeoutID = setTimeoutFn(function timeoutCallback() {
+                cancelAnimationFrameFn(animationFrameID);
+                callback();
+            }, TIMEOUT_DURATION);
+            return [animationFrameID, timeoutID];
+        };
+    }
 
-        function cdataOpenInside(code2) {
-            const value = "CDATA[";
-            if (code2 === value.charCodeAt(index2++)) {
-                effects.consume(code2);
-                return index2 === value.length ? cdata : cdataOpenInside;
+    function createDetectElementResize(nonce) {
+        var animationKeyframes = void 0;
+        var animationName = void 0;
+        var animationStartEvent = void 0;
+        var animationStyle = void 0;
+        var checkTriggers = void 0;
+        var resetTriggers = void 0;
+        var scrollListener = void 0;
+        var attachEvent = typeof document !== "undefined" && document.attachEvent;
+        if (!attachEvent) {
+            resetTriggers = function resetTriggers2(element2) {
+                var triggers = element2.__resizeTriggers__,
+                    expand2 = triggers.firstElementChild,
+                    contract2 = triggers.lastElementChild,
+                    expandChild = expand2.firstElementChild;
+                contract2.scrollLeft = contract2.scrollWidth;
+                contract2.scrollTop = contract2.scrollHeight;
+                expandChild.style.width = expand2.offsetWidth + 1 + "px";
+                expandChild.style.height = expand2.offsetHeight + 1 + "px";
+                expand2.scrollLeft = expand2.scrollWidth;
+                expand2.scrollTop = expand2.scrollHeight;
+            };
+            checkTriggers = function checkTriggers2(element2) {
+                return element2.offsetWidth !== element2.__resizeLast__.width || element2.offsetHeight !== element2.__resizeLast__.height;
+            };
+            scrollListener = function scrollListener2(e3) {
+                if (e3.target.className && typeof e3.target.className.indexOf === "function" && e3.target.className.indexOf("contract-trigger") < 0 && e3.target.className.indexOf("expand-trigger") < 0) {
+                    return;
+                }
+                var element2 = this;
+                resetTriggers(this);
+                if (this.__resizeRAF__) {
+                    cancelFrame(this.__resizeRAF__);
+                }
+                this.__resizeRAF__ = requestFrame(function animationFrame() {
+                    if (checkTriggers(element2)) {
+                        element2.__resizeLast__.width = element2.offsetWidth;
+                        element2.__resizeLast__.height = element2.offsetHeight;
+                        element2.__resizeListeners__.forEach(function forEachResizeListener(fn2) {
+                            fn2.call(element2, e3);
+                        });
+                    }
+                });
+            };
+            var animation = false;
+            var keyframeprefix = "";
+            animationStartEvent = "animationstart";
+            var domPrefixes = "Webkit Moz O ms".split(" ");
+            var startEvents = "webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(" ");
+            var pfx = "";
+            {
+                var elm = document.createElement("fakeelement");
+                if (elm.style.animationName !== void 0) {
+                    animation = true;
+                }
+                if (animation === false) {
+                    for (var i2 = 0; i2 < domPrefixes.length; i2++) {
+                        if (elm.style[domPrefixes[i2] + "AnimationName"] !== void 0) {
+                            pfx = domPrefixes[i2];
+                            keyframeprefix = "-" + pfx.toLowerCase() + "-";
+                            animationStartEvent = startEvents[i2];
+                            animation = true;
+                            break;
+                        }
+                    }
+                }
             }
-            return nok(code2);
+            animationName = "resizeanim";
+            animationKeyframes = "@" + keyframeprefix + "keyframes " + animationName + " { from { opacity: 0; } to { opacity: 0; } } ";
+            animationStyle = keyframeprefix + "animation: 1ms " + animationName + "; ";
         }
-
-        function cdata(code2) {
-            if (code2 === null) {
-                return nok(code2);
+        var createStyles = function createStyles2(doc2) {
+            if (!doc2.getElementById("detectElementResize")) {
+                var css2 = (animationKeyframes ? animationKeyframes : "") + ".resize-triggers { " + (animationStyle ? animationStyle : "") + 'visibility: hidden; opacity: 0; } .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',
+                    head = doc2.head || doc2.getElementsByTagName("head")[0],
+                    style2 = doc2.createElement("style");
+                style2.id = "detectElementResize";
+                style2.type = "text/css";
+                if (nonce != null) {
+                    style2.setAttribute("nonce", nonce);
+                }
+                if (style2.styleSheet) {
+                    style2.styleSheet.cssText = css2;
+                } else {
+                    style2.appendChild(doc2.createTextNode(css2));
+                }
+                head.appendChild(style2);
             }
-            if (code2 === 93) {
-                effects.consume(code2);
-                return cdataClose;
+        };
+        var addResizeListener = function addResizeListener2(element2, fn2) {
+            if (attachEvent) {
+                element2.attachEvent("onresize", fn2);
+            } else {
+                if (!element2.__resizeTriggers__) {
+                    var doc2 = element2.ownerDocument;
+                    var elementStyle = windowObject.getComputedStyle(element2);
+                    if (elementStyle && elementStyle.position === "static") {
+                        element2.style.position = "relative";
+                    }
+                    createStyles(doc2);
+                    element2.__resizeLast__ = {};
+                    element2.__resizeListeners__ = [];
+                    (element2.__resizeTriggers__ = doc2.createElement("div")).className = "resize-triggers";
+                    var expandTrigger = doc2.createElement("div");
+                    expandTrigger.className = "expand-trigger";
+                    expandTrigger.appendChild(doc2.createElement("div"));
+                    var contractTrigger = doc2.createElement("div");
+                    contractTrigger.className = "contract-trigger";
+                    element2.__resizeTriggers__.appendChild(expandTrigger);
+                    element2.__resizeTriggers__.appendChild(contractTrigger);
+                    element2.appendChild(element2.__resizeTriggers__);
+                    resetTriggers(element2);
+                    element2.addEventListener("scroll", scrollListener, true);
+                    if (animationStartEvent) {
+                        element2.__resizeTriggers__.__animationListener__ = function animationListener(e3) {
+                            if (e3.animationName === animationName) {
+                                resetTriggers(element2);
+                            }
+                        };
+                        element2.__resizeTriggers__.addEventListener(animationStartEvent, element2.__resizeTriggers__.__animationListener__);
+                    }
+                }
+                element2.__resizeListeners__.push(fn2);
             }
-            if (markdownLineEnding(code2)) {
-                returnState = cdata;
-                return lineEndingBefore(code2);
+        };
+        var removeResizeListener = function removeResizeListener2(element2, fn2) {
+            if (attachEvent) {
+                element2.detachEvent("onresize", fn2);
+            } else {
+                element2.__resizeListeners__.splice(element2.__resizeListeners__.indexOf(fn2), 1);
+                if (!element2.__resizeListeners__.length) {
+                    element2.removeEventListener("scroll", scrollListener, true);
+                    if (element2.__resizeTriggers__.__animationListener__) {
+                        element2.__resizeTriggers__.removeEventListener(animationStartEvent, element2.__resizeTriggers__.__animationListener__);
+                        element2.__resizeTriggers__.__animationListener__ = null;
+                    }
+                    try {
+                        element2.__resizeTriggers__ = !element2.removeChild(element2.__resizeTriggers__);
+                    } catch (e3) {}
+                }
             }
-            effects.consume(code2);
-            return cdata;
-        }
+        };
+        return {
+            addResizeListener,
+            removeResizeListener
+        };
+    }
+    var AutoSizer = function(_React$PureComponent) {
+        inherits(AutoSizer2, _React$PureComponent);
 
-        function cdataClose(code2) {
-            if (code2 === 93) {
-                effects.consume(code2);
-                return cdataEnd;
+        function AutoSizer2() {
+            var _ref2;
+            var _temp, _this, _ret;
+            classCallCheck(this, AutoSizer2);
+            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
             }
-            return cdata(code2);
+            return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref2 = AutoSizer2.__proto__ || Object.getPrototypeOf(AutoSizer2)).call.apply(_ref2, [this].concat(args))), _this), _this.state = {
+                height: _this.props.defaultHeight || 0,
+                width: _this.props.defaultWidth || 0
+            }, _this._onResize = function() {
+                var _this$props = _this.props,
+                    disableHeight = _this$props.disableHeight,
+                    disableWidth = _this$props.disableWidth,
+                    onResize = _this$props.onResize;
+                if (_this._parentNode) {
+                    var _height = _this._parentNode.offsetHeight || 0;
+                    var _width = _this._parentNode.offsetWidth || 0;
+                    var _style = window.getComputedStyle(_this._parentNode) || {};
+                    var paddingLeft = parseInt(_style.paddingLeft, 10) || 0;
+                    var paddingRight = parseInt(_style.paddingRight, 10) || 0;
+                    var paddingTop = parseInt(_style.paddingTop, 10) || 0;
+                    var paddingBottom = parseInt(_style.paddingBottom, 10) || 0;
+                    var newHeight = _height - paddingTop - paddingBottom;
+                    var newWidth = _width - paddingLeft - paddingRight;
+                    if (!disableHeight && _this.state.height !== newHeight || !disableWidth && _this.state.width !== newWidth) {
+                        _this.setState({
+                            height: _height - paddingTop - paddingBottom,
+                            width: _width - paddingLeft - paddingRight
+                        });
+                        onResize({
+                            height: _height,
+                            width: _width
+                        });
+                    }
+                }
+            }, _this._setRef = function(autoSizer) {
+                _this._autoSizer = autoSizer;
+            }, _temp), possibleConstructorReturn(_this, _ret);
         }
-
-        function cdataEnd(code2) {
-            if (code2 === 62) {
-                return end2(code2);
-            }
-            if (code2 === 93) {
-                effects.consume(code2);
-                return cdataEnd;
+        createClass(AutoSizer2, [{
+            key: "componentDidMount",
+            value: function componentDidMount() {
+                var nonce = this.props.nonce;
+                if (this._autoSizer && this._autoSizer.parentNode && this._autoSizer.parentNode.ownerDocument && this._autoSizer.parentNode.ownerDocument.defaultView && this._autoSizer.parentNode instanceof this._autoSizer.parentNode.ownerDocument.defaultView.HTMLElement) {
+                    this._parentNode = this._autoSizer.parentNode;
+                    this._detectElementResize = createDetectElementResize(nonce);
+                    this._detectElementResize.addResizeListener(this._parentNode, this._onResize);
+                    this._onResize();
+                }
             }
-            return cdata(code2);
-        }
-
-        function declaration(code2) {
-            if (code2 === null || code2 === 62) {
-                return end2(code2);
+        }, {
+            key: "componentWillUnmount",
+            value: function componentWillUnmount() {
+                if (this._detectElementResize && this._parentNode) {
+                    this._detectElementResize.removeResizeListener(this._parentNode, this._onResize);
+                }
             }
-            if (markdownLineEnding(code2)) {
-                returnState = declaration;
-                return lineEndingBefore(code2);
+        }, {
+            key: "render",
+            value: function render2() {
+                var _props = this.props,
+                    children2 = _props.children,
+                    className = _props.className,
+                    disableHeight = _props.disableHeight,
+                    disableWidth = _props.disableWidth,
+                    style2 = _props.style;
+                var _state = this.state,
+                    height = _state.height,
+                    width = _state.width;
+                var outerStyle = {
+                    overflow: "visible"
+                };
+                var childParams = {};
+                var bailoutOnChildren = false;
+                if (!disableHeight) {
+                    if (height === 0) {
+                        bailoutOnChildren = true;
+                    }
+                    outerStyle.height = 0;
+                    childParams.height = height;
+                }
+                if (!disableWidth) {
+                    if (width === 0) {
+                        bailoutOnChildren = true;
+                    }
+                    outerStyle.width = 0;
+                    childParams.width = width;
+                }
+                return React.createElement(
+                    "div", {
+                        className,
+                        ref: this._setRef,
+                        style: _extends$2({}, outerStyle, style2)
+                    },
+                    !bailoutOnChildren && children2(childParams)
+                );
             }
-            effects.consume(code2);
-            return declaration;
-        }
+        }]);
+        return AutoSizer2;
+    }(React.PureComponent);
+    AutoSizer.defaultProps = {
+        onResize: function onResize() {},
+        disableHeight: false,
+        disableWidth: false,
+        style: {}
+    };
 
-        function instruction(code2) {
-            if (code2 === null) {
-                return nok(code2);
-            }
-            if (code2 === 63) {
-                effects.consume(code2);
-                return instructionClose;
-            }
-            if (markdownLineEnding(code2)) {
-                returnState = instruction;
-                return lineEndingBefore(code2);
+    function _extends$1() {
+        _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
+            for (var i2 = 1; i2 < arguments.length; i2++) {
+                var source = arguments[i2];
+                for (var key in source) {
+                    if (Object.prototype.hasOwnProperty.call(source, key)) {
+                        target[key] = source[key];
+                    }
+                }
             }
-            effects.consume(code2);
-            return instruction;
-        }
+            return target;
+        };
+        return _extends$1.apply(this, arguments);
+    }
 
-        function instructionClose(code2) {
-            return code2 === 62 ? end2(code2) : instruction(code2);
+    function _assertThisInitialized(self2) {
+        if (self2 === void 0) {
+            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
         }
+        return self2;
+    }
 
-        function tagCloseStart(code2) {
-            if (asciiAlpha(code2)) {
-                effects.consume(code2);
-                return tagClose;
-            }
-            return nok(code2);
-        }
+    function _setPrototypeOf(o2, p2) {
+        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
+            o3.__proto__ = p3;
+            return o3;
+        };
+        return _setPrototypeOf(o2, p2);
+    }
 
-        function tagClose(code2) {
-            if (code2 === 45 || asciiAlphanumeric(code2)) {
-                effects.consume(code2);
-                return tagClose;
-            }
-            return tagCloseBetween(code2);
-        }
+    function _inheritsLoose(subClass, superClass) {
+        subClass.prototype = Object.create(superClass.prototype);
+        subClass.prototype.constructor = subClass;
+        _setPrototypeOf(subClass, superClass);
+    }
+    var safeIsNaN = Number.isNaN || function ponyfill(value) {
+        return typeof value === "number" && value !== value;
+    };
 
-        function tagCloseBetween(code2) {
-            if (markdownLineEnding(code2)) {
-                returnState = tagCloseBetween;
-                return lineEndingBefore(code2);
-            }
-            if (markdownSpace(code2)) {
-                effects.consume(code2);
-                return tagCloseBetween;
-            }
-            return end2(code2);
+    function isEqual(first, second) {
+        if (first === second) {
+            return true;
         }
-
-        function tagOpen(code2) {
-            if (code2 === 45 || asciiAlphanumeric(code2)) {
-                effects.consume(code2);
-                return tagOpen;
-            }
-            if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
-                return tagOpenBetween(code2);
-            }
-            return nok(code2);
+        if (safeIsNaN(first) && safeIsNaN(second)) {
+            return true;
         }
+        return false;
+    }
 
-        function tagOpenBetween(code2) {
-            if (code2 === 47) {
-                effects.consume(code2);
-                return end2;
-            }
-            if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
-                effects.consume(code2);
-                return tagOpenAttributeName;
-            }
-            if (markdownLineEnding(code2)) {
-                returnState = tagOpenBetween;
-                return lineEndingBefore(code2);
-            }
-            if (markdownSpace(code2)) {
-                effects.consume(code2);
-                return tagOpenBetween;
-            }
-            return end2(code2);
+    function areInputsEqual(newInputs, lastInputs) {
+        if (newInputs.length !== lastInputs.length) {
+            return false;
         }
-
-        function tagOpenAttributeName(code2) {
-            if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
-                effects.consume(code2);
-                return tagOpenAttributeName;
+        for (var i2 = 0; i2 < newInputs.length; i2++) {
+            if (!isEqual(newInputs[i2], lastInputs[i2])) {
+                return false;
             }
-            return tagOpenAttributeNameAfter(code2);
         }
+        return true;
+    }
 
-        function tagOpenAttributeNameAfter(code2) {
-            if (code2 === 61) {
-                effects.consume(code2);
-                return tagOpenAttributeValueBefore;
-            }
-            if (markdownLineEnding(code2)) {
-                returnState = tagOpenAttributeNameAfter;
-                return lineEndingBefore(code2);
-            }
-            if (markdownSpace(code2)) {
-                effects.consume(code2);
-                return tagOpenAttributeNameAfter;
-            }
-            return tagOpenBetween(code2);
+    function memoizeOne(resultFn, isEqual2) {
+        if (isEqual2 === void 0) {
+            isEqual2 = areInputsEqual;
         }
+        var lastThis;
+        var lastArgs = [];
+        var lastResult;
+        var calledOnce = false;
 
-        function tagOpenAttributeValueBefore(code2) {
-            if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
-                return nok(code2);
-            }
-            if (code2 === 34 || code2 === 39) {
-                effects.consume(code2);
-                marker = code2;
-                return tagOpenAttributeValueQuoted;
-            }
-            if (markdownLineEnding(code2)) {
-                returnState = tagOpenAttributeValueBefore;
-                return lineEndingBefore(code2);
+        function memoized() {
+            var newArgs = [];
+            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
+                newArgs[_i2] = arguments[_i2];
             }
-            if (markdownSpace(code2)) {
-                effects.consume(code2);
-                return tagOpenAttributeValueBefore;
+            if (calledOnce && lastThis === this && isEqual2(newArgs, lastArgs)) {
+                return lastResult;
             }
-            effects.consume(code2);
-            return tagOpenAttributeValueUnquoted;
+            lastResult = resultFn.apply(this, newArgs);
+            calledOnce = true;
+            lastThis = this;
+            lastArgs = newArgs;
+            return lastResult;
         }
+        return memoized;
+    }
 
-        function tagOpenAttributeValueQuoted(code2) {
-            if (code2 === marker) {
-                effects.consume(code2);
-                marker = void 0;
-                return tagOpenAttributeValueQuotedAfter;
-            }
-            if (code2 === null) {
-                return nok(code2);
-            }
-            if (markdownLineEnding(code2)) {
-                returnState = tagOpenAttributeValueQuoted;
-                return lineEndingBefore(code2);
-            }
-            effects.consume(code2);
-            return tagOpenAttributeValueQuoted;
+    function _objectWithoutPropertiesLoose$1(source, excluded) {
+        if (source == null)
+            return {};
+        var target = {};
+        var sourceKeys = Object.keys(source);
+        var key, i2;
+        for (i2 = 0; i2 < sourceKeys.length; i2++) {
+            key = sourceKeys[i2];
+            if (excluded.indexOf(key) >= 0)
+                continue;
+            target[key] = source[key];
         }
+        return target;
+    }
+    var hasNativePerformanceNow = typeof performance === "object" && typeof performance.now === "function";
+    var now$1 = hasNativePerformanceNow ? function() {
+        return performance.now();
+    } : function() {
+        return Date.now();
+    };
 
-        function tagOpenAttributeValueUnquoted(code2) {
-            if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
-                return nok(code2);
-            }
-            if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
-                return tagOpenBetween(code2);
-            }
-            effects.consume(code2);
-            return tagOpenAttributeValueUnquoted;
-        }
+    function cancelTimeout(timeoutID) {
+        cancelAnimationFrame(timeoutID.id);
+    }
 
-        function tagOpenAttributeValueQuotedAfter(code2) {
-            if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
-                return tagOpenBetween(code2);
-            }
-            return nok(code2);
-        }
+    function requestTimeout(callback, delay) {
+        var start2 = now$1();
 
-        function end2(code2) {
-            if (code2 === 62) {
-                effects.consume(code2);
-                effects.exit("htmlTextData");
-                effects.exit("htmlText");
-                return ok2;
+        function tick() {
+            if (now$1() - start2 >= delay) {
+                callback.call(null);
+            } else {
+                timeoutID.id = requestAnimationFrame(tick);
             }
-            return nok(code2);
-        }
-
-        function lineEndingBefore(code2) {
-            effects.exit("htmlTextData");
-            effects.enter("lineEnding");
-            effects.consume(code2);
-            effects.exit("lineEnding");
-            return lineEndingAfter;
         }
+        var timeoutID = {
+            id: requestAnimationFrame(tick)
+        };
+        return timeoutID;
+    }
+    var size = -1;
 
-        function lineEndingAfter(code2) {
-            return markdownSpace(code2) ? factorySpace(
-                effects,
-                lineEndingAfterPrefix,
-                "linePrefix",
-                self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
-            )(code2) : lineEndingAfterPrefix(code2);
+    function getScrollbarSize(recalculate) {
+        if (recalculate === void 0) {
+            recalculate = false;
         }
-
-        function lineEndingAfterPrefix(code2) {
-            effects.enter("htmlTextData");
-            return returnState(code2);
+        if (size === -1 || recalculate) {
+            var div2 = document.createElement("div");
+            var style2 = div2.style;
+            style2.width = "50px";
+            style2.height = "50px";
+            style2.overflow = "scroll";
+            document.body.appendChild(div2);
+            size = div2.offsetWidth - div2.clientWidth;
+            document.body.removeChild(div2);
         }
+        return size;
     }
-    const labelEnd = {
-        name: "labelEnd",
-        tokenize: tokenizeLabelEnd,
-        resolveTo: resolveToLabelEnd,
-        resolveAll: resolveAllLabelEnd
-    };
-    const resourceConstruct = {
-        tokenize: tokenizeResource
-    };
-    const referenceFullConstruct = {
-        tokenize: tokenizeReferenceFull
-    };
-    const referenceCollapsedConstruct = {
-        tokenize: tokenizeReferenceCollapsed
-    };
+    var cachedRTLResult = null;
 
-    function resolveAllLabelEnd(events2) {
-        let index2 = -1;
-        while (++index2 < events2.length) {
-            const token = events2[index2][1];
-            if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
-                events2.splice(index2 + 1, token.type === "labelImage" ? 4 : 2);
-                token.type = "data";
-                index2++;
+    function getRTLOffsetType(recalculate) {
+        if (recalculate === void 0) {
+            recalculate = false;
+        }
+        if (cachedRTLResult === null || recalculate) {
+            var outerDiv = document.createElement("div");
+            var outerStyle = outerDiv.style;
+            outerStyle.width = "50px";
+            outerStyle.height = "50px";
+            outerStyle.overflow = "scroll";
+            outerStyle.direction = "rtl";
+            var innerDiv = document.createElement("div");
+            var innerStyle = innerDiv.style;
+            innerStyle.width = "100px";
+            innerStyle.height = "100px";
+            outerDiv.appendChild(innerDiv);
+            document.body.appendChild(outerDiv);
+            if (outerDiv.scrollLeft > 0) {
+                cachedRTLResult = "positive-descending";
+            } else {
+                outerDiv.scrollLeft = 1;
+                if (outerDiv.scrollLeft === 0) {
+                    cachedRTLResult = "negative";
+                } else {
+                    cachedRTLResult = "positive-ascending";
+                }
             }
+            document.body.removeChild(outerDiv);
+            return cachedRTLResult;
         }
-        return events2;
+        return cachedRTLResult;
     }
+    var IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;
+    var defaultItemKey$1 = function defaultItemKey(index2, data2) {
+        return index2;
+    };
 
-    function resolveToLabelEnd(events2, context2) {
-        let index2 = events2.length;
-        let offset2 = 0;
-        let token;
-        let open;
-        let close;
-        let media;
-        while (index2--) {
-            token = events2[index2][1];
-            if (open) {
-                if (token.type === "link" || token.type === "labelLink" && token._inactive) {
-                    break;
+    function createListComponent(_ref2) {
+        var _class;
+        var getItemOffset = _ref2.getItemOffset,
+            getEstimatedTotalSize = _ref2.getEstimatedTotalSize,
+            getItemSize = _ref2.getItemSize,
+            getOffsetForIndexAndAlignment = _ref2.getOffsetForIndexAndAlignment,
+            getStartIndexForOffset = _ref2.getStartIndexForOffset,
+            getStopIndexForStartIndex = _ref2.getStopIndexForStartIndex,
+            initInstanceProps = _ref2.initInstanceProps,
+            shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,
+            validateProps = _ref2.validateProps;
+        return _class = /* @__PURE__ */ function(_PureComponent) {
+            _inheritsLoose(List2, _PureComponent);
+
+            function List2(props) {
+                var _this;
+                _this = _PureComponent.call(this, props) || this;
+                _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));
+                _this._outerRef = void 0;
+                _this._resetIsScrollingTimeoutId = null;
+                _this.state = {
+                    instance: _assertThisInitialized(_this),
+                    isScrolling: false,
+                    scrollDirection: "forward",
+                    scrollOffset: typeof _this.props.initialScrollOffset === "number" ? _this.props.initialScrollOffset : 0,
+                    scrollUpdateWasRequested: false
+                };
+                _this._callOnItemsRendered = void 0;
+                _this._callOnItemsRendered = memoizeOne(function(overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {
+                    return _this.props.onItemsRendered({
+                        overscanStartIndex,
+                        overscanStopIndex,
+                        visibleStartIndex,
+                        visibleStopIndex
+                    });
+                });
+                _this._callOnScroll = void 0;
+                _this._callOnScroll = memoizeOne(function(scrollDirection, scrollOffset, scrollUpdateWasRequested) {
+                    return _this.props.onScroll({
+                        scrollDirection,
+                        scrollOffset,
+                        scrollUpdateWasRequested
+                    });
+                });
+                _this._getItemStyle = void 0;
+                _this._getItemStyle = function(index2) {
+                    var _this$props = _this.props,
+                        direction = _this$props.direction,
+                        itemSize = _this$props.itemSize,
+                        layout2 = _this$props.layout;
+                    var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout2, shouldResetStyleCacheOnItemSizeChange && direction);
+                    var style2;
+                    if (itemStyleCache.hasOwnProperty(index2)) {
+                        style2 = itemStyleCache[index2];
+                    } else {
+                        var _offset = getItemOffset(_this.props, index2, _this._instanceProps);
+                        var size2 = getItemSize(_this.props, index2, _this._instanceProps);
+                        var isHorizontal = direction === "horizontal" || layout2 === "horizontal";
+                        var isRtl = direction === "rtl";
+                        var offsetHorizontal = isHorizontal ? _offset : 0;
+                        itemStyleCache[index2] = style2 = {
+                            position: "absolute",
+                            left: isRtl ? void 0 : offsetHorizontal,
+                            right: isRtl ? offsetHorizontal : void 0,
+                            top: !isHorizontal ? _offset : 0,
+                            height: !isHorizontal ? size2 : "100%",
+                            width: isHorizontal ? size2 : "100%"
+                        };
+                    }
+                    return style2;
+                };
+                _this._getItemStyleCache = void 0;
+                _this._getItemStyleCache = memoizeOne(function(_2, __, ___) {
+                    return {};
+                });
+                _this._onScrollHorizontal = function(event2) {
+                    var _event$currentTarget = event2.currentTarget,
+                        clientWidth = _event$currentTarget.clientWidth,
+                        scrollLeft = _event$currentTarget.scrollLeft,
+                        scrollWidth = _event$currentTarget.scrollWidth;
+                    _this.setState(function(prevState) {
+                        if (prevState.scrollOffset === scrollLeft) {
+                            return null;
+                        }
+                        var direction = _this.props.direction;
+                        var scrollOffset = scrollLeft;
+                        if (direction === "rtl") {
+                            switch (getRTLOffsetType()) {
+                                case "negative":
+                                    scrollOffset = -scrollLeft;
+                                    break;
+                                case "positive-descending":
+                                    scrollOffset = scrollWidth - clientWidth - scrollLeft;
+                                    break;
+                            }
+                        }
+                        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
+                        return {
+                            isScrolling: true,
+                            scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
+                            scrollOffset,
+                            scrollUpdateWasRequested: false
+                        };
+                    }, _this._resetIsScrollingDebounced);
+                };
+                _this._onScrollVertical = function(event2) {
+                    var _event$currentTarget2 = event2.currentTarget,
+                        clientHeight = _event$currentTarget2.clientHeight,
+                        scrollHeight = _event$currentTarget2.scrollHeight,
+                        scrollTop = _event$currentTarget2.scrollTop;
+                    _this.setState(function(prevState) {
+                        if (prevState.scrollOffset === scrollTop) {
+                            return null;
+                        }
+                        var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
+                        return {
+                            isScrolling: true,
+                            scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
+                            scrollOffset,
+                            scrollUpdateWasRequested: false
+                        };
+                    }, _this._resetIsScrollingDebounced);
+                };
+                _this._outerRefSetter = function(ref2) {
+                    var outerRef = _this.props.outerRef;
+                    _this._outerRef = ref2;
+                    if (typeof outerRef === "function") {
+                        outerRef(ref2);
+                    } else if (outerRef != null && typeof outerRef === "object" && outerRef.hasOwnProperty("current")) {
+                        outerRef.current = ref2;
+                    }
+                };
+                _this._resetIsScrollingDebounced = function() {
+                    if (_this._resetIsScrollingTimeoutId !== null) {
+                        cancelTimeout(_this._resetIsScrollingTimeoutId);
+                    }
+                    _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);
+                };
+                _this._resetIsScrolling = function() {
+                    _this._resetIsScrollingTimeoutId = null;
+                    _this.setState({
+                        isScrolling: false
+                    }, function() {
+                        _this._getItemStyleCache(-1, null);
+                    });
+                };
+                return _this;
+            }
+            List2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
+                validateSharedProps$1(nextProps, prevState);
+                validateProps(nextProps);
+                return null;
+            };
+            var _proto = List2.prototype;
+            _proto.scrollTo = function scrollTo(scrollOffset) {
+                scrollOffset = Math.max(0, scrollOffset);
+                this.setState(function(prevState) {
+                    if (prevState.scrollOffset === scrollOffset) {
+                        return null;
+                    }
+                    return {
+                        scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
+                        scrollOffset,
+                        scrollUpdateWasRequested: true
+                    };
+                }, this._resetIsScrollingDebounced);
+            };
+            _proto.scrollToItem = function scrollToItem(index2, align) {
+                if (align === void 0) {
+                    align = "auto";
                 }
-                if (events2[index2][0] === "enter" && token.type === "labelLink") {
-                    token._inactive = true;
+                var _this$props2 = this.props,
+                    itemCount = _this$props2.itemCount,
+                    layout2 = _this$props2.layout;
+                var scrollOffset = this.state.scrollOffset;
+                index2 = Math.max(0, Math.min(index2, itemCount - 1));
+                var scrollbarSize = 0;
+                if (this._outerRef) {
+                    var outerRef = this._outerRef;
+                    if (layout2 === "vertical") {
+                        scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;
+                    } else {
+                        scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;
+                    }
                 }
-            } else if (close) {
-                if (events2[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
-                    open = index2;
-                    if (token.type !== "labelLink") {
-                        offset2 = 2;
-                        break;
+                this.scrollTo(getOffsetForIndexAndAlignment(this.props, index2, align, scrollOffset, this._instanceProps, scrollbarSize));
+            };
+            _proto.componentDidMount = function componentDidMount() {
+                var _this$props3 = this.props,
+                    direction = _this$props3.direction,
+                    initialScrollOffset = _this$props3.initialScrollOffset,
+                    layout2 = _this$props3.layout;
+                if (typeof initialScrollOffset === "number" && this._outerRef != null) {
+                    var outerRef = this._outerRef;
+                    if (direction === "horizontal" || layout2 === "horizontal") {
+                        outerRef.scrollLeft = initialScrollOffset;
+                    } else {
+                        outerRef.scrollTop = initialScrollOffset;
                     }
                 }
-            } else if (token.type === "labelEnd") {
-                close = index2;
-            }
-        }
-        const group = {
-            type: events2[open][1].type === "labelLink" ? "link" : "image",
-            start: Object.assign({}, events2[open][1].start),
-            end: Object.assign({}, events2[events2.length - 1][1].end)
-        };
-        const label = {
-            type: "label",
-            start: Object.assign({}, events2[open][1].start),
-            end: Object.assign({}, events2[close][1].end)
-        };
-        const text2 = {
-            type: "labelText",
-            start: Object.assign({}, events2[open + offset2 + 2][1].end),
-            end: Object.assign({}, events2[close - 2][1].start)
-        };
-        media = [
-            ["enter", group, context2],
-            ["enter", label, context2]
-        ];
-        media = push$2(media, events2.slice(open + 1, open + offset2 + 3));
-        media = push$2(media, [
-            ["enter", text2, context2]
-        ]);
-        media = push$2(
-            media,
-            resolveAll(
-                context2.parser.constructs.insideSpan.null,
-                events2.slice(open + offset2 + 4, close - 3),
-                context2
-            )
-        );
-        media = push$2(media, [
-            ["exit", text2, context2],
-            events2[close - 2],
-            events2[close - 1],
-            ["exit", label, context2]
-        ]);
-        media = push$2(media, events2.slice(close + 1));
-        media = push$2(media, [
-            ["exit", group, context2]
-        ]);
-        splice(events2, open, events2.length, media);
-        return events2;
+                this._callPropsCallbacks();
+            };
+            _proto.componentDidUpdate = function componentDidUpdate() {
+                var _this$props4 = this.props,
+                    direction = _this$props4.direction,
+                    layout2 = _this$props4.layout;
+                var _this$state = this.state,
+                    scrollOffset = _this$state.scrollOffset,
+                    scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;
+                if (scrollUpdateWasRequested && this._outerRef != null) {
+                    var outerRef = this._outerRef;
+                    if (direction === "horizontal" || layout2 === "horizontal") {
+                        if (direction === "rtl") {
+                            switch (getRTLOffsetType()) {
+                                case "negative":
+                                    outerRef.scrollLeft = -scrollOffset;
+                                    break;
+                                case "positive-ascending":
+                                    outerRef.scrollLeft = scrollOffset;
+                                    break;
+                                default:
+                                    var clientWidth = outerRef.clientWidth,
+                                        scrollWidth = outerRef.scrollWidth;
+                                    outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;
+                                    break;
+                            }
+                        } else {
+                            outerRef.scrollLeft = scrollOffset;
+                        }
+                    } else {
+                        outerRef.scrollTop = scrollOffset;
+                    }
+                }
+                this._callPropsCallbacks();
+            };
+            _proto.componentWillUnmount = function componentWillUnmount() {
+                if (this._resetIsScrollingTimeoutId !== null) {
+                    cancelTimeout(this._resetIsScrollingTimeoutId);
+                }
+            };
+            _proto.render = function render2() {
+                var _this$props5 = this.props,
+                    children2 = _this$props5.children,
+                    className = _this$props5.className,
+                    direction = _this$props5.direction,
+                    height = _this$props5.height,
+                    innerRef = _this$props5.innerRef,
+                    innerElementType = _this$props5.innerElementType,
+                    innerTagName = _this$props5.innerTagName,
+                    itemCount = _this$props5.itemCount,
+                    itemData = _this$props5.itemData,
+                    _this$props5$itemKey = _this$props5.itemKey,
+                    itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey,
+                    layout2 = _this$props5.layout,
+                    outerElementType = _this$props5.outerElementType,
+                    outerTagName = _this$props5.outerTagName,
+                    style2 = _this$props5.style,
+                    useIsScrolling = _this$props5.useIsScrolling,
+                    width = _this$props5.width;
+                var isScrolling = this.state.isScrolling;
+                var isHorizontal = direction === "horizontal" || layout2 === "horizontal";
+                var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;
+                var _this$_getRangeToRend = this._getRangeToRender(),
+                    startIndex = _this$_getRangeToRend[0],
+                    stopIndex = _this$_getRangeToRend[1];
+                var items = [];
+                if (itemCount > 0) {
+                    for (var _index = startIndex; _index <= stopIndex; _index++) {
+                        items.push(React.createElement(children2, {
+                            data: itemData,
+                            key: itemKey(_index, itemData),
+                            index: _index,
+                            isScrolling: useIsScrolling ? isScrolling : void 0,
+                            style: this._getItemStyle(_index)
+                        }));
+                    }
+                }
+                var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);
+                return React.createElement(outerElementType || outerTagName || "div", {
+                    className,
+                    onScroll,
+                    ref: this._outerRefSetter,
+                    style: _extends$1({
+                        position: "relative",
+                        height,
+                        width,
+                        overflow: "auto",
+                        WebkitOverflowScrolling: "touch",
+                        willChange: "transform",
+                        direction
+                    }, style2)
+                }, React.createElement(innerElementType || innerTagName || "div", {
+                    children: items,
+                    ref: innerRef,
+                    style: {
+                        height: isHorizontal ? "100%" : estimatedTotalSize,
+                        pointerEvents: isScrolling ? "none" : void 0,
+                        width: isHorizontal ? estimatedTotalSize : "100%"
+                    }
+                }));
+            };
+            _proto._callPropsCallbacks = function _callPropsCallbacks() {
+                if (typeof this.props.onItemsRendered === "function") {
+                    var itemCount = this.props.itemCount;
+                    if (itemCount > 0) {
+                        var _this$_getRangeToRend2 = this._getRangeToRender(),
+                            _overscanStartIndex = _this$_getRangeToRend2[0],
+                            _overscanStopIndex = _this$_getRangeToRend2[1],
+                            _visibleStartIndex = _this$_getRangeToRend2[2],
+                            _visibleStopIndex = _this$_getRangeToRend2[3];
+                        this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);
+                    }
+                }
+                if (typeof this.props.onScroll === "function") {
+                    var _this$state2 = this.state,
+                        _scrollDirection = _this$state2.scrollDirection,
+                        _scrollOffset = _this$state2.scrollOffset,
+                        _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;
+                    this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);
+                }
+            };
+            _proto._getRangeToRender = function _getRangeToRender() {
+                var _this$props6 = this.props,
+                    itemCount = _this$props6.itemCount,
+                    overscanCount = _this$props6.overscanCount;
+                var _this$state3 = this.state,
+                    isScrolling = _this$state3.isScrolling,
+                    scrollDirection = _this$state3.scrollDirection,
+                    scrollOffset = _this$state3.scrollOffset;
+                if (itemCount === 0) {
+                    return [0, 0, 0, 0];
+                }
+                var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);
+                var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps);
+                var overscanBackward = !isScrolling || scrollDirection === "backward" ? Math.max(1, overscanCount) : 1;
+                var overscanForward = !isScrolling || scrollDirection === "forward" ? Math.max(1, overscanCount) : 1;
+                return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
+            };
+            return List2;
+        }(React.PureComponent), _class.defaultProps = {
+            direction: "ltr",
+            itemData: void 0,
+            layout: "vertical",
+            overscanCount: 2,
+            useIsScrolling: false
+        }, _class;
     }
-
-    function tokenizeLabelEnd(effects, ok2, nok) {
-        const self2 = this;
-        let index2 = self2.events.length;
-        let labelStart;
-        let defined;
-        while (index2--) {
-            if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
-                labelStart = self2.events[index2][1];
-                break;
-            }
-        }
-        return start2;
-
-        function start2(code2) {
-            if (!labelStart) {
-                return nok(code2);
+    var validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {
+        _ref2.children;
+        _ref2.direction;
+        _ref2.height;
+        _ref2.layout;
+        _ref2.innerTagName;
+        _ref2.outerTagName;
+        _ref2.width;
+        _ref3.instance;
+    };
+    var FixedSizeList = /* @__PURE__ */ createListComponent({
+        getItemOffset: function getItemOffset(_ref2, index2) {
+            var itemSize = _ref2.itemSize;
+            return index2 * itemSize;
+        },
+        getItemSize: function getItemSize(_ref2, index2) {
+            var itemSize = _ref2.itemSize;
+            return itemSize;
+        },
+        getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {
+            var itemCount = _ref3.itemCount,
+                itemSize = _ref3.itemSize;
+            return itemSize * itemCount;
+        },
+        getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index2, align, scrollOffset, instanceProps, scrollbarSize) {
+            var direction = _ref4.direction,
+                height = _ref4.height,
+                itemCount = _ref4.itemCount,
+                itemSize = _ref4.itemSize,
+                layout2 = _ref4.layout,
+                width = _ref4.width;
+            var isHorizontal = direction === "horizontal" || layout2 === "horizontal";
+            var size2 = isHorizontal ? width : height;
+            var lastItemOffset = Math.max(0, itemCount * itemSize - size2);
+            var maxOffset2 = Math.min(lastItemOffset, index2 * itemSize);
+            var minOffset = Math.max(0, index2 * itemSize - size2 + itemSize + scrollbarSize);
+            if (align === "smart") {
+                if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset2 + size2) {
+                    align = "auto";
+                } else {
+                    align = "center";
+                }
             }
-            if (labelStart._inactive) {
-                return labelEndNok(code2);
+            switch (align) {
+                case "start":
+                    return maxOffset2;
+                case "end":
+                    return minOffset;
+                case "center": {
+                    var middleOffset = Math.round(minOffset + (maxOffset2 - minOffset) / 2);
+                    if (middleOffset < Math.ceil(size2 / 2)) {
+                        return 0;
+                    } else if (middleOffset > lastItemOffset + Math.floor(size2 / 2)) {
+                        return lastItemOffset;
+                    } else {
+                        return middleOffset;
+                    }
+                }
+                case "auto":
+                default:
+                    if (scrollOffset >= minOffset && scrollOffset <= maxOffset2) {
+                        return scrollOffset;
+                    } else if (scrollOffset < minOffset) {
+                        return minOffset;
+                    } else {
+                        return maxOffset2;
+                    }
             }
-            defined = self2.parser.defined.includes(
-                normalizeIdentifier(
-                    self2.sliceSerialize({
-                        start: labelStart.end,
-                        end: self2.now()
-                    })
-                )
-            );
-            effects.enter("labelEnd");
-            effects.enter("labelMarker");
-            effects.consume(code2);
-            effects.exit("labelMarker");
-            effects.exit("labelEnd");
-            return after;
+        },
+        getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset2) {
+            var itemCount = _ref5.itemCount,
+                itemSize = _ref5.itemSize;
+            return Math.max(0, Math.min(itemCount - 1, Math.floor(offset2 / itemSize)));
+        },
+        getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {
+            var direction = _ref6.direction,
+                height = _ref6.height,
+                itemCount = _ref6.itemCount,
+                itemSize = _ref6.itemSize,
+                layout2 = _ref6.layout,
+                width = _ref6.width;
+            var isHorizontal = direction === "horizontal" || layout2 === "horizontal";
+            var offset2 = startIndex * itemSize;
+            var size2 = isHorizontal ? width : height;
+            var numVisibleItems = Math.ceil((size2 + scrollOffset - offset2) / itemSize);
+            return Math.max(0, Math.min(
+                itemCount - 1,
+                startIndex + numVisibleItems - 1
+            ));
+        },
+        initInstanceProps: function initInstanceProps(props) {},
+        shouldResetStyleCacheOnItemSizeChange: true,
+        validateProps: function validateProps(_ref7) {
+            _ref7.itemSize;
         }
+    });
 
-        function after(code2) {
-            if (code2 === 40) {
-                return effects.attempt(
-                    resourceConstruct,
-                    labelEndOk,
-                    defined ? labelEndOk : labelEndNok
-                )(code2);
-            }
-            if (code2 === 91) {
-                return effects.attempt(
-                    referenceFullConstruct,
-                    labelEndOk,
-                    defined ? referenceNotFull : labelEndNok
-                )(code2);
+    function shallowDiffers(prev, next2) {
+        for (var attribute in prev) {
+            if (!(attribute in next2)) {
+                return true;
             }
-            return defined ? labelEndOk(code2) : labelEndNok(code2);
-        }
-
-        function referenceNotFull(code2) {
-            return effects.attempt(
-                referenceCollapsedConstruct,
-                labelEndOk,
-                labelEndNok
-            )(code2);
         }
-
-        function labelEndOk(code2) {
-            return ok2(code2);
+        for (var _attribute in next2) {
+            if (prev[_attribute] !== next2[_attribute]) {
+                return true;
+            }
         }
+        return false;
+    }
+    var _excluded$1 = ["style"],
+        _excluded2 = ["style"];
 
-        function labelEndNok(code2) {
-            labelStart._balanced = true;
-            return nok(code2);
-        }
+    function areEqual(prevProps, nextProps) {
+        var prevStyle = prevProps.style,
+            prevRest = _objectWithoutPropertiesLoose$1(prevProps, _excluded$1);
+        var nextStyle = nextProps.style,
+            nextRest = _objectWithoutPropertiesLoose$1(nextProps, _excluded2);
+        return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);
     }
+    const GlobalStyle = styled.createGlobalStyle`
+    body {
+        /* stylelint-disable-next-line -- external classname */
+        .DatetimeFilterSelect {
+            background-color: ${(props) => props.theme.colors.grey1};
 
-    function tokenizeResource(effects, ok2, nok) {
-        return resourceStart;
+            span {
+                background-color: ${(props) => props.theme.colors.grey1};
+                border-bottom: 1px solid ${(props) => props.theme.colors.grey1};
 
-        function resourceStart(code2) {
-            effects.enter("resource");
-            effects.enter("resourceMarker");
-            effects.consume(code2);
-            effects.exit("resourceMarker");
-            return resourceBefore;
-        }
+                &[aria-selected="true"] {
+                    background-color: ${(props) => props.theme.colors.primary};
+                }
 
-        function resourceBefore(code2) {
-            return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
-        }
+                :hover {
+                    background-color: ${(props) => props.theme.colors.grey3};
+                }
 
-        function resourceOpen(code2) {
-            if (code2 === 41) {
-                return resourceEnd(code2);
+                :active {
+                    background-color: ${(props) => props.theme.colors.grey4};
+                }
             }
-            return factoryDestination(
-                effects,
-                resourceDestinationAfter,
-                resourceDestinationMissing,
-                "resourceDestination",
-                "resourceDestinationLiteral",
-                "resourceDestinationLiteralMarker",
-                "resourceDestinationRaw",
-                "resourceDestinationString",
-                32
-            )(code2);
-        }
-
-        function resourceDestinationAfter(code2) {
-            return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
         }
+    }
+`;
+    const DatetimeFilterWrapper = styled__default.default(FilterWrapper)`
+    gap: 0;
+`;
+    const DatepickerWrapper = styled__default.default.div`
+    height: auto;
 
-        function resourceDestinationMissing(code2) {
-            return nok(code2);
-        }
+    div:has(input) {
+        width: 6.7rem;
+    }
 
-        function resourceBetween(code2) {
-            if (code2 === 34 || code2 === 39 || code2 === 40) {
-                return factoryTitle(
-                    effects,
-                    resourceTitleAfter,
-                    nok,
-                    "resourceTitle",
-                    "resourceTitleMarker",
-                    "resourceTitleString"
-                )(code2);
-            }
-            return resourceEnd(code2);
-        }
+    input {
+        width: 6.7rem;
+        padding: 0;
+        background-color: ${(props) => props.theme.colors.background};
+        border: 1px solid ${(props) => props.theme.colors.background};
 
-        function resourceTitleAfter(code2) {
-            return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
+        ::after {
+            width: 5rem;
         }
 
-        function resourceEnd(code2) {
-            if (code2 === 41) {
-                effects.enter("resourceMarker");
-                effects.consume(code2);
-                effects.exit("resourceMarker");
-                effects.exit("resource");
-                return ok2;
-            }
-            return nok(code2);
+        :hover:not(:disabled) {
+            background-color: ${(props) => props.theme.colors.background};
+            border: 1px solid ${(props) => props.theme.colors.grey4};
         }
     }
 
-    function tokenizeReferenceFull(effects, ok2, nok) {
-        const self2 = this;
-        return referenceFull;
-
-        function referenceFull(code2) {
-            return factoryLabel.call(
-                self2,
-                effects,
-                referenceFullAfter,
-                referenceFullMissing,
-                "reference",
-                "referenceMarker",
-                "referenceString"
-            )(code2);
-        }
+    div:has(> button) {
+        border: 1px solid ${(props) => props.theme.colors.grey1};
 
-        function referenceFullAfter(code2) {
-            return self2.parser.defined.includes(
-                normalizeIdentifier(
-                    self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
-                )
-            ) ? ok2(code2) : nok(code2);
+        :hover {
+            border: 1px solid ${(props) => props.theme.colors.grey1};
         }
 
-        function referenceFullMissing(code2) {
-            return nok(code2);
+        :focus-within {
+            border: 1px solid ${(props) => props.theme.colors.grey1};
         }
     }
 
-    function tokenizeReferenceCollapsed(effects, ok2, nok) {
-        return referenceCollapsedStart;
-
-        function referenceCollapsedStart(code2) {
-            effects.enter("reference");
-            effects.enter("referenceMarker");
-            effects.consume(code2);
-            effects.exit("referenceMarker");
-            return referenceCollapsedOpen;
-        }
+    button {
+        background-color: ${(props) => props.theme.colors.grey1};
 
-        function referenceCollapsedOpen(code2) {
-            if (code2 === 93) {
-                effects.enter("referenceMarker");
-                effects.consume(code2);
-                effects.exit("referenceMarker");
-                effects.exit("reference");
-                return ok2;
-            }
-            return nok(code2);
+        :hover:enabled {
+            background-color: ${(props) => props.theme.colors.grey2};
         }
     }
-    const labelStartImage = {
-        name: "labelStartImage",
-        tokenize: tokenizeLabelStartImage,
-        resolveAll: labelEnd.resolveAll
-    };
 
-    function tokenizeLabelStartImage(effects, ok2, nok) {
-        const self2 = this;
-        return start2;
+    .react-datepicker {
+        margin-bottom: -1rem;
+        margin-left: -0.5rem;
 
-        function start2(code2) {
-            effects.enter("labelImage");
-            effects.enter("labelImageMarker");
-            effects.consume(code2);
-            effects.exit("labelImageMarker");
-            return open;
-        }
+        background-color: ${(props) => props.theme.colors.grey1};
+        border: none;
+        box-shadow: none;
 
-        function open(code2) {
-            if (code2 === 91) {
-                effects.enter("labelMarker");
-                effects.consume(code2);
-                effects.exit("labelMarker");
-                effects.exit("labelImage");
-                return after;
+        /* stylelint-disable -- external classnames */
+        .react-datepicker__month-container {
+            .react-datepicker__header {
+                background-color: ${(props) => props.theme.colors.grey1};
             }
-            return nok(code2);
-        }
 
-        function after(code2) {
-            return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
+            .react-datepicker__month {
+                background-color: ${(props) => props.theme.colors.grey1};
+            }
         }
     }
-    const labelStartLink = {
-        name: "labelStartLink",
-        tokenize: tokenizeLabelStartLink,
-        resolveAll: labelEnd.resolveAll
-    };
+`;
+    const StyledSelect$1 = styled__default.default(Select$1)`
+    margin-bottom: 0.25rem;
+    border: 1px solid ${(props) => props.theme.colors.background};
 
-    function tokenizeLabelStartLink(effects, ok2, nok) {
-        const self2 = this;
-        return start2;
+    button {
+        background-color: ${(props) => props.theme.colors.background};
 
-        function start2(code2) {
-            effects.enter("labelLink");
-            effects.enter("labelMarker");
-            effects.consume(code2);
-            effects.exit("labelMarker");
-            effects.exit("labelLink");
-            return after;
+        :hover:enabled {
+            background-color: ${(props) => props.theme.colors.background};
         }
+    }
+`;
+    const StyledApply = styled__default.default(ApplyButton)`
+    width: 4rem;
+    height: 2rem;
+    padding: 0;
+`;
+    const DatetimeFilterItems = [{
+        label: "None",
+        value: "None"
+    }, {
+        label: "Before",
+        value: "Before"
+    }, {
+        label: "After",
+        value: "After"
+    }, {
+        label: "On date",
+        value: "On date"
+    }, {
+        label: "Between",
+        value: "Between"
+    }];
 
-        function after(code2) {
-            return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
-        }
+    function DatetimeFilter(props) {
+        const [selected, setSelected] = React.useState(null);
+        const [dateValues, setDateValues] = React.useState(props.values);
+        const filteredValues = React.useMemo(() => {
+            let filterDate = dateValues;
+            if ((selected === null || selected === void 0 ? void 0 : selected.value) !== "Between" && Array.isArray(dateValues)) {
+                [filterDate] = dateValues;
+            }
+            return {
+                selected: selected === null || selected === void 0 ? void 0 : selected.label,
+                value: filterDate
+            };
+        }, [dateValues, selected]);
+        const [previousFilter, setPreviousFilter] = React.useState(filteredValues);
+        const disableApply = React.useMemo(() => {
+            if (props.disabled || previousFilter === filteredValues) {
+                return true;
+            }
+            if (!dateValues || selected.label === "Between" && Array.isArray(dateValues) && (!dateValues[0] || !dateValues[1]) || selected.label === "Between" && !Array.isArray(dateValues)) {
+                return true;
+            }
+            return false;
+        }, [props.disabled, previousFilter, filteredValues, dateValues, selected]);
+        return jsxRuntime.exports.jsxs(DatetimeFilterWrapper, {
+            className: props.className,
+            children: [jsxRuntime.exports.jsx(GlobalStyle, {}), jsxRuntime.exports.jsxs(FilterHeader, {
+                children: [jsxRuntime.exports.jsx(StyledSelect$1, {
+                    dropdownRef: (element2) => {
+                        if (props.portalsRef) {
+                            props.portalsRef.current[2] = element2;
+                        }
+                    },
+                    initialValue: {
+                        label: "None",
+                        value: "None"
+                    },
+                    items: DatetimeFilterItems,
+                    onSelect: setSelected
+                }), jsxRuntime.exports.jsx(DatepickerWrapper, {
+                    children: selected && selected.label !== "None" && jsxRuntime.exports.jsx(DatePicker, {
+                        inline: true,
+                        onChange: setDateValues,
+                        portalsRef: props.portalsRef,
+                        selectItemClass: "DatetimeFilterSelect",
+                        selectsRange: (selected === null || selected === void 0 ? void 0 : selected.value) === "Between",
+                        shouldCloseOnSelect: false,
+                        showTimeInput: props.showTimeInput
+                    })
+                })]
+            }), jsxRuntime.exports.jsx(StyledApply, {
+                disabled: disableApply,
+                onClick: (e3) => {
+                    var _a3, _b;
+                    (_a3 = props.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, filteredValues, e3);
+                    (_b = props === null || props === void 0 ? void 0 : props.column) === null || _b === void 0 ? void 0 : _b.setFilter(filteredValues || void 0);
+                    setPreviousFilter(filteredValues);
+                },
+                children: "Apply"
+            })]
+        });
     }
-    const lineEnding = {
-        name: "lineEnding",
-        tokenize: tokenizeLineEnding
-    };
+    var Action;
+    (function(Action2) {
+        Action2["COPY"] = "copy";
+        Action2["DELETE"] = "delete";
+        Action2["SELECT"] = "select";
+        Action2["SELECT_ALL"] = "select_all";
+        Action2["SWITCH"] = "switch";
+        Action2["UNSELECT_ALL"] = "unselect_all";
+    })(Action || (Action = {}));
+    const SelectCheck = styled__default.default(CheckSquare)`
+    color: ${(props) => props.theme.colors.primary};
+`;
 
-    function tokenizeLineEnding(effects, ok2) {
-        return start2;
+    function getSelectIcon(row) {
+        return row.selected ? SelectCheck : Square;
+    }
+    const SwitchOn = styled__default.default(ToggleOn)`
+    color: ${(props) => props.theme.colors.primary};
+`;
 
-        function start2(code2) {
-            effects.enter("lineEnding");
-            effects.consume(code2);
-            effects.exit("lineEnding");
-            return factorySpace(effects, ok2, "linePrefix");
-        }
+    function getSwitchIcon(row) {
+        return row.active ? SwitchOn : ToggleOff;
     }
-    const thematicBreak$2 = {
-        name: "thematicBreak",
-        tokenize: tokenizeThematicBreak
+    const Actions = {
+        COPY: {
+            icon: Copy,
+            id: Action.COPY,
+            label: "Copy"
+        },
+        DELETE: {
+            icon: Trash,
+            id: Action.DELETE,
+            label: "Delete"
+        },
+        SELECT: {
+            getIcon: getSelectIcon,
+            id: Action.SELECT,
+            label: "Select Row"
+        },
+        SELECT_ALL: {
+            id: Action.SELECT_ALL,
+            label: "Select All Rows"
+        },
+        SWITCH: {
+            getIcon: getSwitchIcon,
+            id: Action.SWITCH,
+            label: "Switch On/Off"
+        },
+        UNSELECT_ALL: {
+            id: Action.UNSELECT_ALL,
+            label: "Unselect All Rows"
+        }
     };
+    const ActionWrapper = styled__default.default.div`
+    display: flex;
+    align-items: center;
+    justify-content: flex-end;
 
-    function tokenizeThematicBreak(effects, ok2, nok) {
-        let size2 = 0;
-        let marker;
-        return start2;
+    width: 100%;
+    padding: 0 1rem;
 
-        function start2(code2) {
-            effects.enter("thematicBreak");
-            return before(code2);
-        }
+    svg:not(:last-of-type) {
+        margin-right: 0.7rem;
+    }
+`;
 
-        function before(code2) {
-            marker = code2;
-            return atBreak(code2);
+    function ActionCell(props) {
+        if (!props.column.actions) {
+            throw new Error("Must pass an array of actions to the column def when using the ActionCell");
         }
+        return jsxRuntime.exports.jsx(ActionWrapper, {
+            className: "table-action-cell",
+            children: props.column.actions.map((action) => {
+                const Icon2 = action.getIcon ? action.getIcon(props.row.original) : action.icon;
+                if (Icon2 === void 0) {
+                    return;
+                }
+                const label = action.getLabel ? action.getLabel(props.row.original) : action.label;
+                const onClick = (e3) => {
+                    var _a3;
+                    e3.stopPropagation();
+                    (_a3 = props.onAction) === null || _a3 === void 0 ? void 0 : _a3.call(props, action.id, props.row.original);
+                };
+                return jsxRuntime.exports.jsx(Icon2, {
+                    asButton: true,
+                    onClick,
+                    title: label
+                }, action.label);
+            })
+        });
+    }
 
-        function atBreak(code2) {
-            if (code2 === marker) {
-                effects.enter("thematicBreakSequence");
-                return sequence(code2);
-            }
-            if (size2 >= 3 && (code2 === null || markdownLineEnding(code2))) {
-                effects.exit("thematicBreak");
-                return ok2(code2);
+    function DatetimeCell(fmt = "yyyy-MM-dd HH:mm") {
+        return ({
+            value
+        }) => {
+            if (!value) {
+                return "";
             }
-            return nok(code2);
-        }
-
-        function sequence(code2) {
-            if (code2 === marker) {
-                effects.consume(code2);
-                size2++;
-                return sequence;
+            const parsed = parseISO$1(value);
+            if (Number.isNaN(parsed.getTime())) {
+                return "";
             }
-            effects.exit("thematicBreakSequence");
-            return markdownSpace(code2) ? factorySpace(effects, atBreak, "whitespace")(code2) : atBreak(code2);
-        }
+            return format$2(parsed, fmt);
+        };
     }
-    const list$2 = {
-        name: "list",
-        tokenize: tokenizeListStart,
-        continuation: {
-            tokenize: tokenizeListContinuation
-        },
-        exit: tokenizeListEnd
-    };
-    const listItemPrefixWhitespaceConstruct = {
-        tokenize: tokenizeListItemPrefixWhitespace,
-        partial: true
-    };
-    const indentConstruct = {
-        tokenize: tokenizeIndent$1,
-        partial: true
-    };
-
-    function tokenizeListStart(effects, ok2, nok) {
-        const self2 = this;
-        const tail = self2.events[self2.events.length - 1];
-        let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
-        let size2 = 0;
-        return start2;
-
-        function start2(code2) {
-            const kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
-            if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
-                if (!self2.containerState.type) {
-                    self2.containerState.type = kind;
-                    effects.enter(kind, {
-                        _container: true
-                    });
-                }
-                if (kind === "listUnordered") {
-                    effects.enter("listItemPrefix");
-                    return code2 === 42 || code2 === 45 ? effects.check(thematicBreak$2, nok, atMarker)(code2) : atMarker(code2);
-                }
-                if (!self2.interrupt || code2 === 49) {
-                    effects.enter("listItemPrefix");
-                    effects.enter("listItemValue");
-                    return inside2(code2);
-                }
-            }
-            return nok(code2);
-        }
+    const InputWrapper = styled__default.default.div`
+    display: flex;
+    width: calc(100% + 22px);
+    margin: 0 -1rem;
+`;
+    const ValueWrapper$1 = styled__default.default.span`
+    display: flex;
+    flex: 1 1 auto;
+    align-items: center;
+    height: 100%;
+`;
 
-        function inside2(code2) {
-            if (asciiDigit(code2) && ++size2 < 10) {
-                effects.consume(code2);
-                return inside2;
-            }
-            if ((!self2.interrupt || size2 < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
-                effects.exit("listItemValue");
-                return atMarker(code2);
+    function EditInputCell() {
+        return function InputCell(props) {
+            const [value, setValue] = React.useState(props.value);
+            React.useEffect(() => {
+                setValue(props.value);
+            }, [props.value]);
+            if (isEqual_1(props.currentEditCell, [props.rowIdx, props.column.id])) {
+                const onComplete = () => {
+                    if (props.onChange && value !== props.value) {
+                        props.onChange(value, props.rowIdx, props.column.id);
+                    }
+                    props.onStopEdit();
+                };
+                const onChange2 = (val) => {
+                    setValue(val);
+                };
+                return jsxRuntime.exports.jsx(InputWrapper, {
+                    children: jsxRuntime.exports.jsx(Input$3, {
+                        autoFocus: true,
+                        initialValue: props.value,
+                        onBlur: onComplete,
+                        onChange: onChange2,
+                        onComplete,
+                        style: {
+                            maxWidth: "100%"
+                        }
+                    })
+                });
             }
-            return nok(code2);
-        }
-
-        function atMarker(code2) {
-            effects.enter("listItemMarker");
-            effects.consume(code2);
-            effects.exit("listItemMarker");
-            self2.containerState.marker = self2.containerState.marker || code2;
-            return effects.check(
-                blankLine,
-                self2.interrupt ? nok : onBlank,
-                effects.attempt(
-                    listItemPrefixWhitespaceConstruct,
-                    endOfPrefix,
-                    otherPrefix
-                )
-            );
-        }
-
-        function onBlank(code2) {
-            self2.containerState.initialBlankLine = true;
-            initialSize++;
-            return endOfPrefix(code2);
-        }
+            return jsxRuntime.exports.jsx(ValueWrapper$1, {
+                "data-cell": [props.rowIdx, props.column.id],
+                onClick: props.onStartEdit,
+                children: props.value
+            });
+        };
+    }
+    const SelectWrapper = styled__default.default.div`
+    display: flex;
+    width: calc(100% + 22px);
+    margin: 0 -1rem;
+`;
+    const ValueWrapper = styled__default.default.span`
+    display: flex;
+    flex: 1 1 auto;
+    align-items: center;
+    height: 100%;
+`;
 
-        function otherPrefix(code2) {
-            if (markdownSpace(code2)) {
-                effects.enter("listItemPrefixWhitespace");
-                effects.consume(code2);
-                effects.exit("listItemPrefixWhitespace");
-                return endOfPrefix;
+    function EditSelectCell(items) {
+        return function SelectCell(props) {
+            const selectedItem = items.find((item) => item.value === props.value);
+            if (isEqual_1(props.currentEditCell, [props.rowIdx, props.column.id])) {
+                const onSelect = (item) => {
+                    if (props.onChange && item.value !== props.value) {
+                        props.onChange(item.value, props.rowIdx, props.column.id);
+                    }
+                    props.onStopEdit();
+                };
+                return jsxRuntime.exports.jsx(SelectWrapper, {
+                    children: jsxRuntime.exports.jsx(Select$1, {
+                        initialIsOpen: true,
+                        initialValue: selectedItem,
+                        items,
+                        onSelect,
+                        style: {
+                            flex: "1 1 auto"
+                        }
+                    })
+                });
             }
-            return nok(code2);
-        }
-
-        function endOfPrefix(code2) {
-            self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
-            return ok2(code2);
-        }
+            return jsxRuntime.exports.jsx(ValueWrapper, {
+                "data-cell": [props.rowIdx, props.column.id],
+                onClick: props.onStartEdit,
+                children: selectedItem ? selectedItem.label : ""
+            });
+        };
     }
+    const FilterIcon = styled__default.default(FontAwesomeIcon)`
+    cursor: pointer;
+    color: ${(props) => props.$hasFilter ? props.theme.colors.primary : props.theme.colors.grey3};
+`;
+    const HeaderIconWrapper = styled__default.default.div`
+    display: flex;
+    align-items: center;
+    justify-content: center;
 
-    function tokenizeListContinuation(effects, ok2, nok) {
-        const self2 = this;
-        self2.containerState._closeFlow = void 0;
-        return effects.check(blankLine, onBlank, notBlank);
+    width: 1.5rem;
+    height: 1.5rem;
 
-        function onBlank(code2) {
-            self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
-            return factorySpace(
-                effects,
-                ok2,
-                "listItemIndent",
-                self2.containerState.size + 1
-            )(code2);
-        }
+    border-radius: 0.25rem;
 
-        function notBlank(code2) {
-            if (self2.containerState.furtherBlankLines || !markdownSpace(code2)) {
-                self2.containerState.furtherBlankLines = void 0;
-                self2.containerState.initialBlankLine = void 0;
-                return notInCurrentItem(code2);
-            }
-            self2.containerState.furtherBlankLines = void 0;
-            self2.containerState.initialBlankLine = void 0;
-            return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2);
-        }
+    :hover {
+        background-color: ${(props) => curriedTransparentize$2(0.9, props.theme.colors.primaryHover)};
 
-        function notInCurrentItem(code2) {
-            self2.containerState._closeFlow = true;
-            self2.interrupt = void 0;
-            return factorySpace(
-                effects,
-                effects.attempt(list$2, ok2, nok),
-                "linePrefix",
-                self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
-            )(code2);
+        svg {
+            color: ${(props) => props.hasFilter ? props.theme.colors.primary : props.theme.colors.grey3};
         }
     }
 
-    function tokenizeIndent$1(effects, ok2, nok) {
-        const self2 = this;
-        return factorySpace(
-            effects,
-            afterPrefix,
-            "listItemIndent",
-            self2.containerState.size + 1
-        );
-
-        function afterPrefix(code2) {
-            const tail = self2.events[self2.events.length - 1];
-            return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok2(code2) : nok(code2);
-        }
+    :active {
+        background-color: ${(props) => curriedTransparentize$2(0.8, props.theme.colors.primaryDown)};
     }
+`;
+    var NumericOperator;
+    (function(NumericOperator2) {
+        NumericOperator2["BT"] = "Between";
+        NumericOperator2["EQ"] = "Equal to";
+        NumericOperator2["GT"] = "Greater than";
+        NumericOperator2["LT"] = "Less than";
+        NumericOperator2["NE"] = "Not equal to";
+    })(NumericOperator || (NumericOperator = {}));
+    var DateOperator;
+    (function(DateOperator2) {
+        DateOperator2["BT"] = "Between";
+        DateOperator2["EQ"] = "On date";
+        DateOperator2["GT"] = "After";
+        DateOperator2["LT"] = "Before";
+    })(DateOperator || (DateOperator = {}));
 
-    function tokenizeListEnd(effects) {
-        effects.exit(this.containerState.type);
+    function isValidOperator(op) {
+        return Object.keys(NumericOperator).map((key) => NumericOperator[key]).includes(op);
     }
 
-    function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
-        const self2 = this;
-        return factorySpace(
-            effects,
-            afterPrefix,
-            "listItemPrefixWhitespace",
-            self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1
-        );
-
-        function afterPrefix(code2) {
-            const tail = self2.events[self2.events.length - 1];
-            return !markdownSpace(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok2(code2) : nok(code2);
-        }
+    function isValidDatetimeOperator(op) {
+        return Object.keys(DateOperator).map((key) => DateOperator[key]).includes(op);
     }
-    const setextUnderline = {
-        name: "setextUnderline",
-        tokenize: tokenizeSetextUnderline,
-        resolveTo: resolveToSetextUnderline
-    };
 
-    function resolveToSetextUnderline(events2, context2) {
-        let index2 = events2.length;
-        let content2;
-        let text2;
-        let definition2;
-        while (index2--) {
-            if (events2[index2][0] === "enter") {
-                if (events2[index2][1].type === "content") {
-                    content2 = index2;
-                    break;
-                }
-                if (events2[index2][1].type === "paragraph") {
-                    text2 = index2;
+    function applyNumericOperator(operator2, value, filterValue) {
+        switch (operator2) {
+            case NumericOperator.EQ:
+                return value === filterValue;
+            case NumericOperator.GT:
+                if (Array.isArray(filterValue)) {
+                    throw new Error("Cannot use array for GT operator");
                 }
-            } else {
-                if (events2[index2][1].type === "content") {
-                    events2.splice(index2, 1);
+                return value > filterValue;
+            case NumericOperator.LT:
+                if (Array.isArray(filterValue)) {
+                    throw new Error("Cannot use array for LT operator");
                 }
-                if (!definition2 && events2[index2][1].type === "definition") {
-                    definition2 = index2;
+                return value < filterValue;
+            case NumericOperator.NE:
+                return value !== filterValue;
+            case NumericOperator.BT:
+                if (Array.isArray(filterValue)) {
+                    return value <= filterValue[1] && value >= filterValue[0];
                 }
-            }
-        }
-        const heading2 = {
-            type: "setextHeading",
-            start: Object.assign({}, events2[text2][1].start),
-            end: Object.assign({}, events2[events2.length - 1][1].end)
-        };
-        events2[text2][1].type = "setextHeadingText";
-        if (definition2) {
-            events2.splice(text2, 0, ["enter", heading2, context2]);
-            events2.splice(definition2 + 1, 0, ["exit", events2[content2][1], context2]);
-            events2[content2][1].end = Object.assign({}, events2[definition2][1].end);
-        } else {
-            events2[content2][1] = heading2;
+                break;
+            default:
+                return true;
         }
-        events2.push(["exit", heading2, context2]);
-        return events2;
     }
 
-    function tokenizeSetextUnderline(effects, ok2, nok) {
-        const self2 = this;
-        let marker;
-        return start2;
-
-        function start2(code2) {
-            let index2 = self2.events.length;
-            let paragraph2;
-            while (index2--) {
-                if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
-                    paragraph2 = self2.events[index2][1].type === "paragraph";
-                    break;
-                }
-            }
-            if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
-                effects.enter("setextHeadingLine");
-                marker = code2;
-                return before(code2);
+    function applyDatetimeOperator(operator2, value, filterValue) {
+        const parsedValue = parseISO$1(value);
+        if (Array.isArray(filterValue)) {
+            if (operator2 === DateOperator.BT) {
+                return isWithinInterval$1(parsedValue, {
+                    end: filterValue[1],
+                    start: filterValue[0]
+                });
             }
-            return nok(code2);
-        }
-
-        function before(code2) {
-            effects.enter("setextHeadingLineSequence");
-            return inside2(code2);
+            return true;
         }
-
-        function inside2(code2) {
-            if (code2 === marker) {
-                effects.consume(code2);
-                return inside2;
-            }
-            effects.exit("setextHeadingLineSequence");
-            return markdownSpace(code2) ? factorySpace(effects, after, "lineSuffix")(code2) : after(code2);
+        switch (operator2) {
+            case DateOperator.EQ:
+                return isEqual$3(parsedValue, filterValue);
+            case DateOperator.GT:
+                return isAfter$1(parsedValue, filterValue);
+            case DateOperator.LT:
+                return isBefore$1(parsedValue, filterValue);
+            default:
+                return true;
         }
+    }
 
-        function after(code2) {
-            if (code2 === null || markdownLineEnding(code2)) {
-                effects.exit("setextHeadingLine");
-                return ok2(code2);
-            }
-            return nok(code2);
+    function numeric(rows, columnIds, filterValue) {
+        const {
+            selected,
+            value
+        } = filterValue;
+        const [colId] = columnIds;
+        if (!isValidOperator(selected) || !value && value !== 0) {
+            return rows;
         }
+        return rows.filter((row) => applyNumericOperator(selected, row.values[colId], value));
     }
-    const flow$1 = {
-        tokenize: initializeFlow
-    };
-
-    function initializeFlow(effects) {
-        const self2 = this;
-        const initial2 = effects.attempt(
-            blankLine,
-            atBlankEnding,
-            effects.attempt(
-                this.parser.constructs.flowInitial,
-                afterConstruct,
-                factorySpace(
-                    effects,
-                    effects.attempt(
-                        this.parser.constructs.flow,
-                        afterConstruct,
-                        effects.attempt(content$1, afterConstruct)
-                    ),
-                    "linePrefix"
-                )
-            )
-        );
-        return initial2;
 
-        function atBlankEnding(code2) {
-            if (code2 === null) {
-                effects.consume(code2);
-                return;
-            }
-            effects.enter("lineEndingBlank");
-            effects.consume(code2);
-            effects.exit("lineEndingBlank");
-            self2.currentConstruct = void 0;
-            return initial2;
+    function datetime(rows, columnIds, filterValue) {
+        const {
+            selected,
+            value
+        } = filterValue;
+        const [colId] = columnIds;
+        if (!isValidDatetimeOperator(selected) || !value) {
+            return rows;
         }
+        return rows.filter((row) => applyDatetimeOperator(selected, row.values[colId], value));
+    }
 
-        function afterConstruct(code2) {
-            if (code2 === null) {
-                effects.consume(code2);
-                return;
-            }
-            effects.enter("lineEnding");
-            effects.consume(code2);
-            effects.exit("lineEnding");
-            self2.currentConstruct = void 0;
-            return initial2;
+    function categorical(rows, columnIds, filterItems) {
+        const [colId] = columnIds;
+        const filteredItems = filterItems.map((item) => item.value);
+        if (filteredItems.length === 0) {
+            return rows;
         }
+        return rows.filter((row) => filteredItems.includes(row.values[colId]));
     }
-    const resolver$1 = {
-        resolveAll: createResolver()
-    };
-    const string$3 = initializeFactory("string");
-    const text$5 = initializeFactory("text");
-
-    function initializeFactory(field) {
-        return {
-            tokenize: initializeText,
-            resolveAll: createResolver(
-                field === "text" ? resolveAllLineSuffixes : void 0
-            )
-        };
 
-        function initializeText(effects) {
-            const self2 = this;
-            const constructs2 = this.parser.constructs[field];
-            const text2 = effects.attempt(constructs2, start2, notText);
-            return start2;
+    function TextFilter(props) {
+        return jsxRuntime.exports.jsx(FilterWrapper, {
+            children: jsxRuntime.exports.jsx(StyledSearchBar, {
+                onChange: (val) => props.column.setFilter(val || void 0),
+                placeholder: "Rows containing value...",
+                value: props.column.filterValue || ""
+            })
+        });
+    }
 
-            function start2(code2) {
-                return atBreak(code2) ? text2(code2) : notText(code2);
+    function FilterContainer(props) {
+        var _a3;
+        const [visible, setVisible] = React.useState(false);
+        const show = () => setVisible(true);
+        const hide2 = () => setVisible(false);
+        const hasFilter = !(props.col.filterValue === void 0 || ((_a3 = props.col.filterValue) === null || _a3 === void 0 ? void 0 : _a3.selected) === "None" || Array.isArray(props.col.filterValue) && props.col.filterValue.length === 0);
+        const items = React.useMemo(() => {
+            var _a4;
+            if ((_a4 = props.col) === null || _a4 === void 0 ? void 0 : _a4.uniqueItems) {
+                return props.col.uniqueItems.map((item) => ({
+                    label: item,
+                    value: item
+                }));
             }
+        }, [props.col]);
+        const portalsRef = React.useRef([]);
 
-            function notText(code2) {
-                if (code2 === null) {
-                    effects.consume(code2);
+        function onClickOutside(instance2, event2) {
+            const target = event2.target;
+            for (const portal of portalsRef.current) {
+                if (portal === null || portal === void 0 ? void 0 : portal.contains(target)) {
                     return;
                 }
-                effects.enter("data");
-                effects.consume(code2);
-                return data2;
             }
+            hide2();
+        }
+        return jsxRuntime.exports.jsx(Tooltip$1, {
+            content: props.col.render("Filter", {
+                items,
+                onChange: hide2,
+                portalsRef
+            }),
+            hidden: true,
+            interactive: true,
+            onClickOutside,
+            visible,
+            children: jsxRuntime.exports.jsx("span", {
+                children: jsxRuntime.exports.jsx(HeaderIconWrapper, {
+                    hasFilter,
+                    children: jsxRuntime.exports.jsx(FilterIcon, {
+                        "$hasFilter": hasFilter,
+                        icon: faFilter,
+                        onClick: show
+                    })
+                })
+            })
+        });
+    }
+    var CheckboxState;
+    (function(CheckboxState2) {
+        CheckboxState2["CHECKED"] = "checked";
+        CheckboxState2["INDETERMINATE"] = "indeterminate";
+        CheckboxState2["UNCHECKED"] = "unchecked";
+    })(CheckboxState || (CheckboxState = {}));
+    const StyledTriStateCheckbox = styled__default.default.div`
+    ${(props) => {
+    if (props.state === CheckboxState.INDETERMINATE) {
+      return `
+                    span:after {
+                        display: block ;
+                        left: 0.07rem;
+                        top: 0.4rem;
+                        width: 0.75rem;
+                        border-radius: 0.25rem;
+                        height: 0px;
+                        border: 1px solid ${props.theme.colors.grey6};
+                        transform: rotate(0deg)
+                    }
 
-            function data2(code2) {
-                if (atBreak(code2)) {
-                    effects.exit("data");
-                    return text2(code2);
-                }
-                effects.consume(code2);
-                return data2;
-            }
+            `;
+    }
+  }}
+`;
 
-            function atBreak(code2) {
-                if (code2 === null) {
-                    return true;
-                }
-                const list2 = constructs2[code2];
-                let index2 = -1;
-                if (list2) {
-                    while (++index2 < list2.length) {
-                        const item = list2[index2];
-                        if (!item.previous || item.previous.call(self2, self2.previous)) {
-                            return true;
-                        }
-                    }
-                }
-                return false;
-            }
+    function computeState(allSelected, noneSelected) {
+        if (noneSelected) {
+            return CheckboxState.UNCHECKED;
         }
+        return allSelected ? CheckboxState.CHECKED : CheckboxState.INDETERMINATE;
     }
 
-    function createResolver(extraResolver) {
-        return resolveAllText;
-
-        function resolveAllText(events2, context2) {
-            let index2 = -1;
-            let enter;
-            while (++index2 <= events2.length) {
-                if (enter === void 0) {
-                    if (events2[index2] && events2[index2][1].type === "data") {
-                        enter = index2;
-                        index2++;
-                    }
-                } else if (!events2[index2] || events2[index2][1].type !== "data") {
-                    if (index2 !== enter + 2) {
-                        events2[enter][1].end = events2[index2 - 1][1].end;
-                        events2.splice(enter + 2, index2 - enter - 2);
-                        index2 = enter + 2;
-                    }
-                    enter = void 0;
-                }
-            }
-            return extraResolver ? extraResolver(events2, context2) : events2;
+    function getControlledState(allSelected, noneSelected) {
+        if (allSelected) {
+            return allSelected;
+        }
+        if (noneSelected) {
+            return false;
         }
+        return void 0;
     }
 
-    function resolveAllLineSuffixes(events2, context2) {
-        let eventIndex = 0;
-        while (++eventIndex <= events2.length) {
-            if ((eventIndex === events2.length || events2[eventIndex][1].type === "lineEnding") && events2[eventIndex - 1][1].type === "data") {
-                const data2 = events2[eventIndex - 1][1];
-                const chunks = context2.sliceStream(data2);
-                let index2 = chunks.length;
-                let bufferIndex = -1;
-                let size2 = 0;
-                let tabs;
-                while (index2--) {
-                    const chunk = chunks[index2];
-                    if (typeof chunk === "string") {
-                        bufferIndex = chunk.length;
-                        while (chunk.charCodeAt(bufferIndex - 1) === 32) {
-                            size2++;
-                            bufferIndex--;
-                        }
-                        if (bufferIndex)
-                            break;
-                        bufferIndex = -1;
-                    } else if (chunk === -2) {
-                        tabs = true;
-                        size2++;
-                    } else if (chunk === -1)
-                    ;
-                    else {
-                        index2++;
-                        break;
-                    }
-                }
-                if (size2) {
-                    const token = {
-                        type: eventIndex === events2.length || tabs || size2 < 2 ? "lineSuffix" : "hardBreakTrailing",
-                        start: {
-                            line: data2.end.line,
-                            column: data2.end.column - size2,
-                            offset: data2.end.offset - size2,
-                            _index: data2.start._index + index2,
-                            _bufferIndex: index2 ? bufferIndex : data2.start._bufferIndex + bufferIndex
-                        },
-                        end: Object.assign({}, data2.end)
-                    };
-                    data2.end = Object.assign({}, token.start);
-                    if (data2.start.offset === data2.end.offset) {
-                        Object.assign(data2, token);
-                    } else {
-                        events2.splice(
-                            eventIndex,
-                            0,
-                            ["enter", token, context2],
-                            ["exit", token, context2]
-                        );
-                        eventIndex += 2;
-                    }
+    function TriStateCheckbox(props) {
+        const [state, setState] = React.useState(computeState(props.allSelected, props.noneSelected));
+        React.useEffect(() => {
+            setState(computeState(props.allSelected, props.noneSelected));
+        }, [props.allSelected, props.noneSelected]);
+        const onClick = (checked, e3) => {
+            setState(checked ? CheckboxState.CHECKED : CheckboxState.UNCHECKED);
+            if (props.onChange) {
+                if (state === CheckboxState.UNCHECKED) {
+                    props.onChange(CheckboxState.CHECKED, e3);
+                } else {
+                    props.onChange(CheckboxState.UNCHECKED, e3);
                 }
-                eventIndex++;
             }
-        }
-        return events2;
+        };
+        return jsxRuntime.exports.jsx(StyledTriStateCheckbox, {
+            state,
+            style: props.style,
+            children: jsxRuntime.exports.jsx(Checkbox, {
+                className: props.className,
+                disabled: props.disabled,
+                initialValue: state === CheckboxState.CHECKED,
+                onChange: (checked, event2) => {
+                    onClick(checked, event2);
+                },
+                selected: getControlledState(props.allSelected, props.noneSelected)
+            })
+        });
     }
 
-    function createTokenizer(parser2, initialize, from) {
-        let point2 = Object.assign(
-            from ? Object.assign({}, from) : {
-                line: 1,
-                column: 1,
-                offset: 0
-            }, {
-                _index: 0,
-                _bufferIndex: -1
+    function SelectHeader(props) {
+        const allValues = props.rows.map((r2) => r2.original.selected);
+        const countSelected = allValues.filter(Boolean).length;
+        const allSelected = countSelected > 0 && countSelected === allValues.length;
+        const noneSelected = countSelected === 0;
+        const onChange2 = (state) => {
+            if (state === CheckboxState.UNCHECKED) {
+                props.onAction(Action.UNSELECT_ALL);
+            } else if (state === CheckboxState.CHECKED) {
+                props.onAction(Action.SELECT_ALL, props.rows.map((r2) => r2.original));
             }
-        );
-        const columnStart = {};
-        const resolveAllConstructs = [];
-        let chunks = [];
-        let stack = [];
-        const effects = {
-            consume,
-            enter,
-            exit: exit2,
-            attempt: constructFactory(onsuccessfulconstruct),
-            check: constructFactory(onsuccessfulcheck),
-            interrupt: constructFactory(onsuccessfulcheck, {
-                interrupt: true
-            })
-        };
-        const context2 = {
-            previous: null,
-            code: null,
-            containerState: {},
-            events: [],
-            parser: parser2,
-            sliceStream,
-            sliceSerialize,
-            now: now2,
-            defineSkip,
-            write: write2
         };
-        let state = initialize.tokenize.call(context2, effects);
-        if (initialize.resolveAll) {
-            resolveAllConstructs.push(initialize);
-        }
-        return context2;
-
-        function write2(slice) {
-            chunks = push$2(chunks, slice);
-            main2();
-            if (chunks[chunks.length - 1] !== null) {
-                return [];
+        return jsxRuntime.exports.jsx(TriStateCheckbox, {
+            allSelected,
+            noneSelected,
+            onChange: onChange2,
+            style: {
+                display: "flex",
+                justifyContent: "center"
             }
-            addResult(initialize, 0);
-            context2.events = resolveAll(resolveAllConstructs, context2.events, context2);
-            return context2.events;
-        }
-
-        function sliceSerialize(token, expandTabs) {
-            return serializeChunks(sliceStream(token), expandTabs);
-        }
+        });
+    }
+    const HeaderOptionsIcon = styled__default.default(FontAwesomeIcon)`
+    cursor: pointer;
+    align-items: center;
+    color: ${(props) => props.theme.colors.grey5};
+`;
+    const HeaderOptions = styled__default.default.div`
+    display: flex;
+    align-items: center;
+    justify-content: center;
 
-        function sliceStream(token) {
-            return sliceChunks(chunks, token);
-        }
+    width: 12px;
 
-        function now2() {
-            const {
-                line,
-                column,
-                offset: offset2,
-                _index,
-                _bufferIndex
-            } = point2;
+    background-color: ${(props) => props.theme.colors.grey3};
+`;
+    const OptionsDropdownList = styled__default.default(List)`
+    background-color: ${(props) => props.theme.colors.background};
+    box-shadow: ${(props) => props.theme.shadow.light};
+`;
+    const OptionsMenu = ({
+        allColumns,
+        allowColumnHiding,
+        numVisibleColumns,
+        resetResizing,
+        setAllFilters,
+        style: style2
+    }) => {
+        const [optionsElement, setOptionsElement] = React.useState(null);
+        const [popperElement, setPopperElement] = React.useState(null);
+        const [showOptions, setShowOptions] = React.useState(false);
+        const {
+            styles: styles2,
+            attributes: attributes2,
+            update: update2
+        } = usePopper$1(optionsElement, popperElement, {
+            placement: "left-end"
+        });
+        const toggleOptions = () => {
+            setShowOptions(!showOptions);
+        };
+        const onOptionSelect = (option) => {
+            option.onClick();
+        };
+        const clickOutsideOptionsHandler = () => {
+            if (showOptions) {
+                toggleOptions();
+            }
+        };
+        useOnClickOutside(popperElement, clickOutsideOptionsHandler);
+        React.useEffect(() => {
+            if (showOptions) {
+                update2();
+            }
+        }, [showOptions, update2]);
+        const resetFunctions = React.useMemo(() => {
+            const functions2 = {
+                items: [{
+                    label: "Reset Column Widths",
+                    onClick: resetResizing,
+                    value: "resetResizing"
+                }, {
+                    label: "Reset Filters",
+                    onClick: () => setAllFilters([]),
+                    value: "resetFilters"
+                }],
+                label: "Reset"
+            };
+            if (allowColumnHiding) {
+                functions2.items.push({
+                    label: "Show All Columns",
+                    onClick: () => {
+                        allColumns.forEach((column) => {
+                            if (!column.isVisible) {
+                                column.toggleHidden();
+                            }
+                        });
+                    },
+                    value: "showAllColumns"
+                });
+            }
+            return functions2;
+        }, [resetResizing, setAllFilters, allColumns, allowColumnHiding]);
+        const columnToggles = React.useMemo(() => {
             return {
-                line,
-                column,
-                offset: offset2,
-                _index,
-                _bufferIndex
+                items: allColumns.filter((column) => typeof column.Header === "string").map((column) => ({
+                    label: `${column.isVisible ? "Hide" : "Show"} ${String(column.Header)}`,
+                    onClick: () => !(column.isVisible && numVisibleColumns === 1) ? column.toggleHidden() : null,
+                    value: `${column.isVisible ? "hide" : "show"}${String(column.Header)}`
+                })),
+                label: "Columns"
             };
+        }, [allColumns, allowColumnHiding, numVisibleColumns]);
+        return jsxRuntime.exports.jsxs(HeaderOptions, {
+            ref: setOptionsElement,
+            children: [jsxRuntime.exports.jsx(HeaderOptionsIcon, {
+                icon: faEllipsisV,
+                onClick: toggleOptions
+            }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(OptionsDropdownList, Object.assign({}, attributes2.popper, {
+                isOpen: showOptions,
+                ref: setPopperElement,
+                style: Object.assign(Object.assign(Object.assign({}, styles2.popper), {
+                    maxHeight: 800,
+                    minWidth: 150,
+                    zIndex: 9999
+                }), style2),
+                children: jsxRuntime.exports.jsx(SectionedList, {
+                    items: allowColumnHiding ? [resetFunctions, columnToggles] : [resetFunctions],
+                    onSelect: onOptionSelect
+                })
+            })), document.body)]
+        });
+    };
+    var __rest$7 = globalThis && globalThis.__rest || function(s2, e3) {
+        var t2 = {};
+        for (var p2 in s2)
+            if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
+                t2[p2] = s2[p2];
+        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
+            for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
+                if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
+                    t2[p2[i2]] = s2[p2[i2]];
+            }
+        return t2;
+    };
+    const {
+        fontSize
+    } = window.getComputedStyle(document.documentElement);
+    const ROW_HEIGHT = parseFloat(fontSize) * 2.5;
+    const shouldForwardProp = (prop) => !["isSorted", "onClickRow"].includes(prop);
+    const Row$1 = styled__default.default.div.withConfig({
+        shouldForwardProp
+    })`
+    cursor: ${(props) => props.onClickRow ? "pointer" : "default"};
+    display: flex;
+
+    :hover {
+        div {
+            background-color: ${(props) => props.theme.colors.grey1};
         }
+    }
 
-        function defineSkip(value) {
-            columnStart[value.line] = value.column;
-            accountForPotentialSkip();
+    :active,
+    :focus {
+        div {
+            background-color: ${(props) => props.theme.colors.grey2};
         }
+    }
+`;
+    const RowPlaceholder = styled__default.default(Row$1)`
+    position: absolute;
+    left: 0;
 
-        function main2() {
-            let chunkIndex;
-            while (point2._index < chunks.length) {
-                const chunk = chunks[point2._index];
-                if (typeof chunk === "string") {
-                    chunkIndex = point2._index;
-                    if (point2._bufferIndex < 0) {
-                        point2._bufferIndex = 0;
-                    }
-                    while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
-                        go2(chunk.charCodeAt(point2._bufferIndex));
-                    }
-                } else {
-                    go2(chunk);
-                }
-            }
+    display: flex;
+    align-items: center;
+    justify-content: center;
+`;
+    const CellPlaceholder = styled__default.default.div`
+    min-width: 80px;
+    height: 0.7rem;
+    margin: 0.5rem;
+
+    background: ${(props) => `linear-gradient(to right, ${props.theme.colors.grey2}, ${curriedTransparentize$2(0.2, props.theme.colors.grey3)}, ${props.theme.colors.grey2});`};
+    background-size: 50%;
+    border-radius: 0.5rem;
+
+    animation-name: ani-horizontal;
+    animation-duration: 3.5s;
+    animation-timing-function: linear;
+    animation-iteration-count: infinite;
+
+    @keyframes ani-horizontal {
+        0% {
+            background-position: -100% 0;
         }
 
-        function go2(code2) {
-            state = state(code2);
+        100% {
+            background-position: 100% 0;
         }
+    }
+`;
+    const Cell = styled__default.default.div`
+    display: flex !important;
+    align-items: center;
 
-        function consume(code2) {
-            if (markdownLineEnding(code2)) {
-                point2.line++;
-                point2.column = 1;
-                point2.offset += code2 === -3 ? 2 : 1;
-                accountForPotentialSkip();
-            } else if (code2 !== -1) {
-                point2.column++;
-                point2.offset++;
-            }
-            if (point2._bufferIndex < 0) {
-                point2._index++;
+    min-width: 80px;
+    height: ${() => `${ROW_HEIGHT}px`};
+
+    color: ${(props) => props.theme.colors.grey6};
+
+    background-color: ${(props) => props.theme.colors.blue1};
+    border-bottom: 1px solid ${(props) => props.theme.colors.grey3};
+
+    :last-child {
+        border-right: 0;
+    }
+`;
+    const CellContent = styled__default.default.span`
+    overflow: hidden;
+
+    width: 100%;
+    padding: 0 1rem;
+
+    text-overflow: ellipsis;
+    white-space: nowrap;
+`;
+    const arePropsEqual = (prevProps, nextProps) => {
+        var _a3;
+        return areEqual(prevProps, nextProps) && !(((_a3 = nextProps.data) === null || _a3 === void 0 ? void 0 : _a3.headerGroups) || []).some((headerGroup) => ((headerGroup === null || headerGroup === void 0 ? void 0 : headerGroup.headers) || []).some((header) => header.isResizing));
+    };
+    const RenderRow = React__namespace.memo(({
+        data: {
+            width,
+            currentEditCell,
+            headerGroups,
+            rows,
+            prepareRow,
+            getItem,
+            totalColumnsWidth,
+            onClickRow,
+            throttledClickRow,
+            backgroundColor,
+            mappedColumns
+        },
+        index: index2,
+        style: renderRowStyle
+    }) => {
+        let row = rows[index2];
+        if (getItem) {
+            const value = getItem(index2);
+            if (!value) {
+                row = null;
             } else {
-                point2._bufferIndex++;
-                if (point2._bufferIndex === chunks[point2._index].length) {
-                    point2._bufferIndex = -1;
-                    point2._index++;
-                }
+                row.original = value;
+                row.values = value;
             }
-            context2.previous = code2;
         }
-
-        function enter(type2, fields) {
-            const token = fields || {};
-            token.type = type2;
-            token.start = now2();
-            context2.events.push(["enter", token, context2]);
-            stack.push(token);
-            return token;
+        if (!row) {
+            return jsxRuntime.exports.jsx("div", {
+                children: headerGroups.map((headerGroup, gidx) => jsxRuntime.exports.jsx(RowPlaceholder, {
+                    style: {
+                        height: ROW_HEIGHT,
+                        top: (index2 + 1) * ROW_HEIGHT,
+                        width: totalColumnsWidth > width ? totalColumnsWidth : "100%"
+                    },
+                    children: headerGroup === null || headerGroup === void 0 ? void 0 : headerGroup.headers.map((col, cidx) => {
+                        const headerProps = col.getHeaderProps();
+                        const headerWidth = headerProps.style.width === "NaNpx" ? mappedColumns[cidx].width : headerProps.style.width;
+                        return jsxRuntime.exports.jsx(CellPlaceholder, {
+                            style: {
+                                maxWidth: col.maxWidth,
+                                width: headerWidth
+                            }
+                        }, `col-${index2}-${cidx}`);
+                    })
+                }, `row-${gidx}`))
+            });
         }
+        prepareRow(row);
+        const onClick = () => {
+            if (onClickRow) {
+                throttledClickRow(row.original);
+            }
+        };
+        const _a3 = row.getRowProps({
+                style: renderRowStyle
+            }),
+            {
+                style: rowStyle
+            } = _a3,
+            restRow = __rest$7(_a3, ["style"]);
+        return React.createElement(Row$1, Object.assign({}, restRow, {
+            key: `row-${index2}`,
+            onClick,
+            onClickRow,
+            style: Object.assign(Object.assign({}, rowStyle), {
+                top: (index2 + 1) * ROW_HEIGHT,
+                width: totalColumnsWidth > width ? totalColumnsWidth : "100%"
+            })
+        }), row.cells.map((cell, colIdx) => {
+            var _a4;
+            const cellProps = cell.getCellProps();
+            return React.createElement(
+                Cell,
+                Object.assign({}, cellProps, {
+                    key: `cell-${index2}-${colIdx}`,
+                    style: Object.assign(Object.assign({}, cellProps.style), {
+                        backgroundColor,
+                        justifyContent: mappedColumns[colIdx].align,
+                        maxWidth: (_a4 = cell.column) === null || _a4 === void 0 ? void 0 : _a4.maxWidth,
+                        width: cellProps.style.width === "NaNpx" ? mappedColumns[colIdx].width : cellProps.style.width
+                    })
+                }),
+                jsxRuntime.exports.jsx(CellContent, {
+                    children: cell.render("Cell", {
+                        colIdx,
+                        currentEditCell,
+                        rowIdx: index2
+                    })
+                })
+            );
+        }));
+    }, arePropsEqual);
+    var __rest$6 = globalThis && globalThis.__rest || function(s2, e3) {
+        var t2 = {};
+        for (var p2 in s2)
+            if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
+                t2[p2] = s2[p2];
+        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
+            for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
+                if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
+                    t2[p2[i2]] = s2[p2[i2]];
+            }
+        return t2;
+    };
+    const Wrapper$4 = styled__default.default.div`
+    display: inline-block;
+    width: 100%;
+    max-width: 100%;
+    padding: 1rem;
 
-        function exit2(type2) {
-            const token = stack.pop();
-            token.end = now2();
-            context2.events.push(["exit", token, context2]);
-            return token;
+    ${(props) => !props.$hasMaxRows && `flex: 1 1 auto;`}
+    &.sticky {
+        [data-sticky-td] {
+            position: sticky;
         }
 
-        function onsuccessfulconstruct(construct, info) {
-            addResult(construct, info.from);
+        [data-sticky-last-left-td] {
+            box-shadow: 4px 0 4px -3px ${(props) => props.theme.colors.shadowMedium};
         }
 
-        function onsuccessfulcheck(_2, info) {
-            info.restore();
+        [data-sticky-first-right-td] {
+            box-shadow: -4px 0 4px -3px ${(props) => props.theme.colors.shadowMedium};
         }
+    }
+`;
+    const StyledFixedSizeList = styled__default.default(FixedSizeList)`
+    /* this adds a fixed box shadow underneath the header */
+    ::before {
+        content: '';
 
-        function constructFactory(onreturn, fields) {
-            return hook;
-
-            function hook(constructs2, returnState, bogusState) {
-                let listOfConstructs;
-                let constructIndex;
-                let currentConstruct;
-                let info;
-                return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? handleListOfConstructs([constructs2]) : handleMapOfConstructs(constructs2);
+        position: sticky;
+        z-index: 5;
+        inset: calc(2.5rem - 2px) 0 0 0;
 
-                function handleMapOfConstructs(map2) {
-                    return start2;
+        display: block;
 
-                    function start2(code2) {
-                        const def = code2 !== null && map2[code2];
-                        const all2 = code2 !== null && map2.null;
-                        const list2 = [
-                            ...Array.isArray(def) ? def : def ? [def] : [],
-                            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
-                        ];
-                        return handleListOfConstructs(list2)(code2);
-                    }
-                }
+        height: 1px;
 
-                function handleListOfConstructs(list2) {
-                    listOfConstructs = list2;
-                    constructIndex = 0;
-                    if (list2.length === 0) {
-                        return bogusState;
-                    }
-                    return handleConstruct(list2[constructIndex]);
-                }
+        box-shadow: 0 3px 3px ${(props) => props.theme.colors.shadowLight};
+    }
+`;
+    const Header = styled__default.default.div`
+    position: sticky;
+    z-index: 4;
+    top: 0;
 
-                function handleConstruct(construct) {
-                    return start2;
+    flex-direction: column;
 
-                    function start2(code2) {
-                        info = store();
-                        currentConstruct = construct;
-                        if (!construct.partial) {
-                            context2.currentConstruct = construct;
-                        }
-                        if (construct.name && context2.parser.constructs.disable.null.includes(construct.name)) {
-                            return nok();
-                        }
-                        return construct.tokenize.call(
-                            fields ? Object.assign(Object.create(context2), fields) : context2,
-                            effects,
-                            ok2,
-                            nok
-                        )(code2);
-                    }
-                }
+    width: fit-content;
+    min-width: 80px;
 
-                function ok2(code2) {
-                    onreturn(currentConstruct, info);
-                    return returnState;
-                }
+    /* needed as before box shadow pushes this dows by 1px */
+    margin-top: -1px;
+`;
+    const HeaderRow = styled__default.default.div`
+    display: flex;
+`;
+    const HeaderCell = styled__default.default.div`
+    user-select: none;
 
-                function nok(code2) {
-                    info.restore();
-                    if (++constructIndex < listOfConstructs.length) {
-                        return handleConstruct(listOfConstructs[constructIndex]);
-                    }
-                    return bogusState;
-                }
-            }
-        }
+    display: flex !important;
+    align-items: center;
+    justify-content: space-between;
 
-        function addResult(construct, from2) {
-            if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
-                resolveAllConstructs.push(construct);
-            }
-            if (construct.resolve) {
-                splice(
-                    context2.events,
-                    from2,
-                    context2.events.length - from2,
-                    construct.resolve(context2.events.slice(from2), context2)
-                );
-            }
-            if (construct.resolveTo) {
-                context2.events = construct.resolveTo(context2.events, context2);
-            }
-        }
+    min-width: 80px;
+    height: ${ROW_HEIGHT}px;
 
-        function store() {
-            const startPoint = now2();
-            const startPrevious = context2.previous;
-            const startCurrentConstruct = context2.currentConstruct;
-            const startEventsIndex = context2.events.length;
-            const startStack = Array.from(stack);
-            return {
-                restore,
-                from: startEventsIndex
-            };
+    color: ${(props) => props.theme.colors.text};
 
-            function restore() {
-                point2 = startPoint;
-                context2.previous = startPrevious;
-                context2.currentConstruct = startCurrentConstruct;
-                context2.events.length = startEventsIndex;
-                stack = startStack;
-                accountForPotentialSkip();
-            }
-        }
+    background-color: ${(props) => props.theme.colors.blue3};
 
-        function accountForPotentialSkip() {
-            if (point2.line in columnStart && point2.column < 2) {
-                point2.column = columnStart[point2.line];
-                point2.offset += columnStart[point2.line] - 1;
-            }
-        }
+    :not(:last-child) {
+        border-right: 1px solid ${(props) => props.theme.colors.background};
     }
 
-    function sliceChunks(chunks, token) {
-        const startIndex = token.start._index;
-        const startBufferIndex = token.start._bufferIndex;
-        const endIndex = token.end._index;
-        const endBufferIndex = token.end._bufferIndex;
-        let view;
-        if (startIndex === endIndex) {
-            view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
-        } else {
-            view = chunks.slice(startIndex, endIndex);
-            if (startBufferIndex > -1) {
-                const head = view[0];
-                if (typeof head === "string") {
-                    view[0] = head.slice(startBufferIndex);
-                } else {
-                    view.shift();
-                }
-            }
-            if (endBufferIndex > 0) {
-                view.push(chunks[endIndex].slice(0, endBufferIndex));
-            }
+    :hover {
+        /* stylelint-disable-next-line -- hard-coded classname */
+        .tableSortArrow {
+            color: ${(props) => props.theme.colors.grey3};
         }
-        return view;
     }
+`;
+    const HeaderContentWrapper = styled__default.default.span`
+    overflow: hidden;
+    flex: 1 1 auto;
 
-    function serializeChunks(chunks, expandTabs) {
-        let index2 = -1;
-        const result = [];
-        let atTab;
-        while (++index2 < chunks.length) {
-            const chunk = chunks[index2];
-            let value;
-            if (typeof chunk === "string") {
-                value = chunk;
-            } else
-                switch (chunk) {
-                    case -5: {
-                        value = "\r";
-                        break;
-                    }
-                    case -4: {
-                        value = "\n";
-                        break;
-                    }
-                    case -3: {
-                        value = "\r\n";
-                        break;
-                    }
-                    case -2: {
-                        value = expandTabs ? " " : "	";
-                        break;
-                    }
-                    case -1: {
-                        if (!expandTabs && atTab)
-                            continue;
-                        value = " ";
-                        break;
-                    }
-                    default: {
-                        value = String.fromCharCode(chunk);
-                    }
-                }
-            atTab = chunk === -2;
-            result.push(value);
+    padding-left: ${(props) => props.isPrimitiveHeader ? "1rem" : void 0};
+
+    text-overflow: ellipsis;
+    white-space: nowrap;
+`;
+    const HeaderTooltipContainer = styled__default.default.div`
+    display: flex;
+    gap: 0.5rem;
+    align-items: center;
+    justify-content: center;
+
+    width: ${(props) => props.isPrimitiveHeader ? void 0 : "100%"};
+    max-width: ${(props) => props.isPrimitiveHeader ? "calc(100% - 3rem)" : void 0};
+`;
+    const HeaderCellButtonContainer = styled__default.default.div`
+    display: flex;
+    flex-direction: row;
+    height: 100%;
+`;
+    const HeaderIconsWrapper = styled__default.default.div`
+    display: flex;
+    align-items: center;
+    justify-content: space-between;
+    justify-self: flex-end;
+`;
+    const ResizeBorder = styled__default.default.div`
+    /* prevents from scrolling while dragging on touch devices */
+    touch-action: none;
+    width: 10px;
+    height: 100%;
+`;
+    const SortIcon = styled__default.default(FontAwesomeIcon).withConfig({
+        shouldForwardProp
+    })`
+    color: ${(props) => props.isSorted ? props.theme.colors.grey3 : props.theme.colors.blue3};
+`;
+    const TooltipIcon = styled__default.default(FontAwesomeIcon)`
+    color: ${(props) => props.theme.colors.grey4};
+`;
+    const getSortIcon = (isSorted, isSortedDesc) => {
+        if (!isSorted) {
+            return faArrowUp;
         }
-        return result.join("");
-    }
-    const document$1 = {
-        [42]: list$2,
-        [43]: list$2,
-        [45]: list$2,
-        [48]: list$2,
-        [49]: list$2,
-        [50]: list$2,
-        [51]: list$2,
-        [52]: list$2,
-        [53]: list$2,
-        [54]: list$2,
-        [55]: list$2,
-        [56]: list$2,
-        [57]: list$2,
-        [62]: blockQuote
-    };
-    const contentInitial = {
-        [91]: definition$1
-    };
-    const flowInitial = {
-        [-2]: codeIndented,
-        [-1]: codeIndented,
-        [32]: codeIndented
-    };
-    const flow = {
-        [35]: headingAtx,
-        [42]: thematicBreak$2,
-        [45]: [setextUnderline, thematicBreak$2],
-        [60]: htmlFlow,
-        [61]: setextUnderline,
-        [95]: thematicBreak$2,
-        [96]: codeFenced,
-        [126]: codeFenced
+        return isSortedDesc ? faArrowDown : faArrowUp;
     };
-    const string$2 = {
-        [38]: characterReference,
-        [92]: characterEscape
+    const getSortKey = (sortBy, columns) => {
+        return sortBy.map((sort) => {
+            var _a3;
+            return Object.assign(Object.assign({}, sort), {
+                id: ((_a3 = columns.find((col) => col.accessor === sort.id)) === null || _a3 === void 0 ? void 0 : _a3.sortKey) || sort.id
+            });
+        });
     };
-    const text$4 = {
-        [-5]: lineEnding,
-        [-4]: lineEnding,
-        [-3]: lineEnding,
-        [33]: labelStartImage,
-        [38]: characterReference,
-        [42]: attention,
-        [60]: [autolink, htmlText],
-        [91]: labelStartLink,
-        [92]: [hardBreakEscape, characterEscape],
-        [93]: labelEnd,
-        [95]: attention,
-        [96]: codeText
+    const orderStickyCols = (columns) => {
+        const leftStickyCols = [];
+        const nonStickyCols = [];
+        const rightStickyCols = [];
+        columns.forEach((col) => {
+            if (col.sticky === "left") {
+                leftStickyCols.push(col);
+            } else if (col.sticky === "right") {
+                rightStickyCols.push(col);
+            } else {
+                nonStickyCols.push(col);
+            }
+        });
+        return [...leftStickyCols, ...nonStickyCols, ...rightStickyCols];
     };
-    const insideSpan = {
-        null: [attention, resolver$1]
+    const filterComponentMap = {
+        categorical: CategoricalFilter,
+        datetime: DatetimeFilter,
+        numeric: NumericFilter,
+        text: TextFilter
     };
-    const attentionMarkers = {
-        null: [42, 95]
+    const appendFilterComponents = (columns) => {
+        return columns.map((col) => {
+            if (!col.filter) {
+                return col;
+            }
+            if (!(col.filter in filterComponentMap)) {
+                throw new Error(`Invalid filter ${col.filter} encountered in column ${col.id}, only ${Object.keys(filterComponentMap).join(",")} are supported`);
+            }
+            return Object.assign(Object.assign({}, col), {
+                Filter: filterComponentMap[col.filter]
+            });
+        });
     };
-    const disable = {
-        null: []
+    const cells = {
+        DATETIME: DatetimeCell,
+        EDIT_INPUT: EditInputCell,
+        EDIT_SELECT: EditSelectCell
     };
-    const defaultConstructs = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
-        __proto__: null,
-        document: document$1,
-        contentInitial,
-        flowInitial,
-        flow,
-        string: string$2,
-        text: text$4,
-        insideSpan,
-        attentionMarkers,
-        disable
-    }, Symbol.toStringTag, {
-        value: "Module"
+    const createItemData = memoizeOne$1((width, currentEditCell, headerGroups, rows, prepareRow, getItem, totalColumnsWidth, onClickRow, throttledClickRow, backgroundColor, mappedColumns) => ({
+        backgroundColor,
+        currentEditCell,
+        getItem,
+        headerGroups,
+        mappedColumns,
+        onClickRow,
+        prepareRow,
+        rows,
+        throttledClickRow,
+        totalColumnsWidth,
+        width
     }));
-
-    function parse$5(options) {
-        const settings2 = options || {};
-        const constructs2 = combineExtensions([defaultConstructs, ...settings2.extensions || []]);
-        const parser2 = {
-            defined: [],
-            lazy: {},
-            constructs: constructs2,
-            content: create2(content$2),
-            document: create2(document$2),
-            flow: create2(flow$1),
-            string: create2(string$3),
-            text: create2(text$5)
+    const Table$1 = React.forwardRef(({
+        allowHiding,
+        backgroundColor,
+        className,
+        columns,
+        data: data2,
+        getItem,
+        initialSort = [],
+        itemCount,
+        maxRows,
+        onAction,
+        onChange: onChange2,
+        onClickRow,
+        onItemsRendered,
+        onFilter,
+        onSort,
+        showTableOptions,
+        style: style2,
+        tableOptionsStyle
+    }, ref2) => {
+        const [currentSortBy, setCurrentSortBy] = React.useState(initialSort);
+        React.useEffect(
+            () => {
+                setCurrentSortBy(initialSort);
+            },
+            useDeepCompare([initialSort])
+        );
+        if (!data2 && !getItem) {
+            throw new Error("One of data and getItem must be passed to the table component");
+        }
+        if (getItem && (!onItemsRendered || !Number.isFinite(itemCount))) {
+            throw new Error("itemCount and onItemsRendered must also be passed when using the table in infinite mode");
+        }
+        const [currentEditCell, throttledSetEditCell, immediateSetEditCell] = useThrottledState(void 0, 500);
+        const throttledClickRow = useThrottle(onClickRow, 500);
+        const onStopEdit = () => {
+            throttledSetEditCell(void 0);
         };
-        return parser2;
+        const onStartEdit = (e3) => {
+            var _a3, _b;
+            const cell = (_b = (_a3 = e3 === null || e3 === void 0 ? void 0 : e3.currentTarget) === null || _a3 === void 0 ? void 0 : _a3.getAttribute("data-cell")) === null || _b === void 0 ? void 0 : _b.split(",");
+            if (!cell || (cell === null || cell === void 0 ? void 0 : cell.length) !== 2) {
+                throttledSetEditCell(void 0);
+                return;
+            }
+            immediateSetEditCell([Number(cell[0]), cell[1]]);
+            throttledSetEditCell([Number(cell[0]), cell[1]]);
+        };
+        const infiniteData = React.useMemo(() => Array(itemCount).fill(0), [itemCount]);
+        const mappedColumns = React.useMemo(() => appendFilterComponents(orderStickyCols(columns)), [columns]);
+        const hasFixedColumns = React.useMemo(() => mappedColumns.some((column) => "sticky" in column), [mappedColumns]);
+        const totalColumnsWidth = React.useMemo(() => mappedColumns.reduce((acc, column) => acc + (parseInt(column.width) || 150), 0), [mappedColumns]);
+        const filterTypes = React.useMemo(() => ({
+            categorical,
+            datetime,
+            numeric
+        }), []);
+        const {
+            getTableProps,
+            getTableBodyProps,
+            headerGroups,
+            rows,
+            prepareRow,
+            state: {
+                sortBy,
+                filters: filters2
+            },
+            setAllFilters,
+            resetResizing,
+            allColumns
+        } = reactTable.exports.useTable({
+            columns: mappedColumns,
+            data: data2 || infiniteData,
+            filterTypes,
+            initialState: {
+                sortBy: currentSortBy.map((sort) => Object.assign(Object.assign({}, sort), {
+                    id: mappedColumns.find((col) => [col.sortKey, col.accessor].includes(sort.id)).accessor
+                }))
+            },
+            manualFilters: !data2,
+            manualSortBy: !!onSort,
+            onAction,
+            onChange: onChange2,
+            onStartEdit,
+            onStopEdit
+        }, reactTable.exports.useFilters, reactTable.exports.useFlexLayout, reactTable.exports.useSortBy, reactTable.exports.useResizeColumns, ...hasFixedColumns ? [build.useSticky] : []);
+        React.useImperativeHandle(ref2, () => ({
+            resetFilters() {
+                setAllFilters([]);
+            }
+        }));
+        React.useEffect(() => {
+            if (onSort) {
+                onSort(getSortKey(sortBy, mappedColumns));
+            } else {
+                setCurrentSortBy(sortBy);
+            }
+        }, [onSort, sortBy]);
+        React.useEffect(() => {
+            if (onFilter) {
+                onFilter(filters2);
+            }
+        }, [onFilter, filters2]);
+        const tableProps = getTableBodyProps();
+        const renderTable = React.useCallback(
+            (_a3) => {
+                var {
+                    children: children2,
+                    style: tableStyle
+                } = _a3, rest = __rest$6(_a3, ["children", "style"]);
+                return jsxRuntime.exports.jsxs("div", {
+                    children: [jsxRuntime.exports.jsx(Header, {
+                        style: {
+                            width: `max(${totalColumnsWidth}px, 100%)`
+                        },
+                        children: headerGroups.map((headerGroup, gidx) => React.createElement(HeaderRow, Object.assign({}, headerGroup.getHeaderGroupProps(), {
+                            key: `group-${gidx}`
+                        }), headerGroup.headers.map((col, cidx) => {
+                            const headerProps = col.getHeaderProps();
+                            const sortProps = col.getSortByToggleProps();
+                            const headerContent = col.render("Header");
+                            const resizerProps = col.getResizerProps();
+                            const numVisibleColumns = allColumns.filter((column) => column.isVisible).length;
+                            const showSort = !col.disableSortBy;
+                            const showFilter = col.canFilter && col.filter;
+                            const showOptions = cidx === numVisibleColumns - 1 && showTableOptions;
+                            const showHeaderCellButtonContainer = showSort || showFilter || showOptions;
+                            return React.createElement(
+                                HeaderCell,
+                                Object.assign({}, headerProps, {
+                                    key: `col-${gidx}-${cidx}`,
+                                    style: Object.assign(Object.assign({}, headerProps.style), {
+                                        maxWidth: col.maxWidth,
+                                        width: headerProps.style.width === "NaNpx" ? mappedColumns[cidx].width : headerProps.style.width
+                                    })
+                                }),
+                                jsxRuntime.exports.jsxs(HeaderTooltipContainer, {
+                                    isPrimitiveHeader: typeof headerContent === "string",
+                                    children: [jsxRuntime.exports.jsx(HeaderContentWrapper, Object.assign({}, sortProps, {
+                                        isPrimitiveHeader: typeof headerContent === "string",
+                                        title: typeof headerContent === "string" ? headerContent : "",
+                                        children: headerContent
+                                    })), col.tooltip && jsxRuntime.exports.jsx(Tooltip$1, {
+                                        content: col.tooltip,
+                                        children: jsxRuntime.exports.jsx(TooltipIcon, {
+                                            icon: faCircleQuestion
+                                        })
+                                    })]
+                                }),
+                                showHeaderCellButtonContainer && jsxRuntime.exports.jsxs(HeaderCellButtonContainer, {
+                                    children: [jsxRuntime.exports.jsxs(HeaderIconsWrapper, {
+                                        children: [showSort && jsxRuntime.exports.jsx(HeaderIconWrapper, {
+                                            children: jsxRuntime.exports.jsx(SortIcon, Object.assign({}, sortProps, {
+                                                className: "tableSortArrow",
+                                                icon: getSortIcon(col.isSorted, col.isSortedDesc),
+                                                isSorted: col.isSorted
+                                            }))
+                                        }), showFilter ? jsxRuntime.exports.jsx(FilterContainer, {
+                                            col
+                                        }) : null, showOptions && jsxRuntime.exports.jsx(OptionsMenu, {
+                                            allColumns,
+                                            allowColumnHiding: allowHiding,
+                                            numVisibleColumns,
+                                            resetResizing,
+                                            setAllFilters,
+                                            style: tableOptionsStyle
+                                        })]
+                                    }), jsxRuntime.exports.jsx(ResizeBorder, Object.assign({}, resizerProps))]
+                                })
+                            );
+                        })))
+                    }), React.createElement("div", Object.assign({}, tableProps, rest, {
+                        key: "table-body-inner",
+                        style: tableStyle
+                    }), children2)]
+                }, "table-inner");
+            },
+            useDeepCompare([tableProps, totalColumnsWidth, headerGroups])
+        );
+        return jsxRuntime.exports.jsx(Wrapper$4, Object.assign({}, getTableProps(), {
+            "$hasMaxRows": !!maxRows,
+            className: `${className} ${hasFixedColumns ? "sticky" : ""}`,
+            style: Object.assign({
+                height: maxRows ? (Math.min(rows.length, maxRows) + 1) * ROW_HEIGHT : "100%"
+            }, style2),
+            children: jsxRuntime.exports.jsx(AutoSizer, {
+                children: ({
+                    height,
+                    width
+                }) => {
+                    return jsxRuntime.exports.jsx(StyledFixedSizeList, {
+                        height,
+                        innerElementType: renderTable,
+                        itemCount: itemCount || rows.length,
+                        itemData: createItemData(width, currentEditCell, headerGroups, rows, prepareRow, getItem, totalColumnsWidth, onClickRow, throttledClickRow, backgroundColor, mappedColumns),
+                        itemSize: ROW_HEIGHT,
+                        onItemsRendered,
+                        style: {
+                            overflowX: width < totalColumnsWidth ? "auto" : "hidden",
+                            overflowY: height < (rows.length + 1) * ROW_HEIGHT ? "auto" : "hidden"
+                        },
+                        width,
+                        children: RenderRow
+                    }, "table-list");
+                }
+            })
+        }));
+    });
+    Table$1.displayName = "Table";
+    Table$1.ActionColumn = (actions, accessor, sticky, disableSelectAll = false) => {
+        const width = actions.includes(Actions.SELECT) ? 52 : actions.length * 24 + 24;
+        return {
+            Cell: ActionCell,
+            Header: actions.includes(Actions.SELECT) && !disableSelectAll ? SelectHeader : "",
+            accessor: accessor || "actions",
+            actions,
+            disableSortBy: true,
+            maxWidth: width,
+            minWidth: actions.includes(Actions.SELECT) ? 52 : 48,
+            sticky: sticky || null,
+            width
+        };
+    };
+    Table$1.Actions = Actions;
+    Table$1.cells = cells;
+    const TabWrapper = styled__default.default.div`
+    overflow: hidden;
+    display: flex;
 
-        function create2(initial2) {
-            return creator2;
+    /* This is needed as the content of a TabbedCard overflows for the wrapper to not shrink */
+    flex-shrink: 0;
 
-            function creator2(from) {
-                return createTokenizer(parser2, initial2, from);
-            }
-        }
-    }
+    width: 100%;
 
-    function postprocess(events2) {
-        while (!subtokenize(events2)) {}
-        return events2;
-    }
-    const search$1 = /[\0\t\n\r]/g;
+    border-radius: 1rem 1rem 0 0;
+`;
+    const TabComponent = styled__default.default.span`
+    cursor: pointer;
+    user-select: none;
 
-    function preprocess() {
-        let column = 1;
-        let buffer = "";
-        let start2 = true;
-        let atCarriageReturn;
-        return preprocessor2;
+    overflow: hidden;
+    display: flex;
+    flex: 1 1 0;
+    align-items: center;
+    justify-content: center;
 
-        function preprocessor2(value, encoding, end2) {
-            const chunks = [];
-            let match2;
-            let next2;
-            let startPosition;
-            let endPosition;
-            let code2;
-            value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
-            startPosition = 0;
-            buffer = "";
-            if (start2) {
-                if (value.charCodeAt(0) === 65279) {
-                    startPosition++;
-                }
-                start2 = void 0;
-            }
-            while (startPosition < value.length) {
-                search$1.lastIndex = startPosition;
-                match2 = search$1.exec(value);
-                endPosition = match2 && match2.index !== void 0 ? match2.index : value.length;
-                code2 = value.charCodeAt(endPosition);
-                if (!match2) {
-                    buffer = value.slice(startPosition);
-                    break;
-                }
-                if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
-                    chunks.push(-3);
-                    atCarriageReturn = void 0;
-                } else {
-                    if (atCarriageReturn) {
-                        chunks.push(-5);
-                        atCarriageReturn = void 0;
-                    }
-                    if (startPosition < endPosition) {
-                        chunks.push(value.slice(startPosition, endPosition));
-                        column += endPosition - startPosition;
-                    }
-                    switch (code2) {
-                        case 0: {
-                            chunks.push(65533);
-                            column++;
-                            break;
-                        }
-                        case 9: {
-                            next2 = Math.ceil(column / 4) * 4;
-                            chunks.push(-2);
-                            while (column++ < next2)
-                                chunks.push(-1);
-                            break;
-                        }
-                        case 10: {
-                            chunks.push(-4);
-                            column = 1;
-                            break;
-                        }
-                        default: {
-                            atCarriageReturn = true;
-                            column = 1;
-                        }
-                    }
-                }
-                startPosition = endPosition + 1;
-            }
-            if (end2) {
-                if (atCarriageReturn)
-                    chunks.push(-5);
-                if (buffer)
-                    chunks.push(buffer);
-                chunks.push(null);
-            }
-            return chunks;
-        }
-    }
-    const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
+    box-sizing: border-box;
+    height: 2.5rem;
 
-    function decodeString(value) {
-        return value.replace(characterEscapeOrReference, decode$1);
+    color: ${(props) => props.selected ? props.theme.colors.primary : props.theme.colors.grey3};
+
+    background-color: ${(props) => props.theme.colors.blue1};
+    border-bottom: ${(props) => props.selected ? `2px solid ${props.theme.colors.primary}` : `1px solid ${props.theme.colors.grey3}`};
+
+    :hover {
+        color: ${(props) => props.selected ? props.theme.colors.primary : props.theme.colors.text};
+        background-color: ${(props) => props.selected ? props.theme.colors.blue1 : props.theme.colors.grey1};
     }
 
-    function decode$1($0, $1, $2) {
-        if ($1) {
-            return $1;
-        }
-        const head = $2.charCodeAt(0);
-        if (head === 35) {
-            const head2 = $2.charCodeAt(1);
-            const hex2 = head2 === 120 || head2 === 88;
-            return decodeNumericCharacterReference($2.slice(hex2 ? 2 : 1), hex2 ? 16 : 10);
-        }
-        return decodeNamedCharacterReference($2) || $0;
+    h2 {
+        font-weight: ${(props) => props.selected ? "700" : "400"};
     }
-    const own$6 = {}.hasOwnProperty;
+`;
+    const Title$2 = styled__default.default.h2`
+    overflow: hidden;
 
-    function fromMarkdown(value, encoding, options) {
-        if (typeof encoding !== "string") {
-            options = encoding;
-            encoding = void 0;
-        }
-        return compiler(options)(
-            postprocess(
-                parse$5(options).document().write(preprocess()(value, encoding, true))
-            )
-        );
+    width: 100%;
+    margin: 0;
+    padding: 0 1rem;
+
+    font-size: 1rem;
+    font-weight: 300;
+    text-align: center;
+    text-overflow: ellipsis;
+    white-space: nowrap;
+`;
+
+    function instanceOfTab(tab2) {
+        return typeof tab2 === "string" ? false : "title" in tab2;
     }
 
-    function compiler(options) {
-        const config2 = {
-            transforms: [],
-            canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
-            enter: {
-                autolink: opener(link2),
-                autolinkProtocol: onenterdata,
-                autolinkEmail: onenterdata,
-                atxHeading: opener(heading2),
-                blockQuote: opener(blockQuote2),
-                characterEscape: onenterdata,
-                characterReference: onenterdata,
-                codeFenced: opener(codeFlow),
-                codeFencedFenceInfo: buffer,
-                codeFencedFenceMeta: buffer,
-                codeIndented: opener(codeFlow, buffer),
-                codeText: opener(codeText2, buffer),
-                codeTextData: onenterdata,
-                data: onenterdata,
-                codeFlowValue: onenterdata,
-                definition: opener(definition2),
-                definitionDestinationString: buffer,
-                definitionLabelString: buffer,
-                definitionTitleString: buffer,
-                emphasis: opener(emphasis2),
-                hardBreakEscape: opener(hardBreak2),
-                hardBreakTrailing: opener(hardBreak2),
-                htmlFlow: opener(html2, buffer),
-                htmlFlowData: onenterdata,
-                htmlText: opener(html2, buffer),
-                htmlTextData: onenterdata,
-                image: opener(image2),
-                label: buffer,
-                link: opener(link2),
-                listItem: opener(listItem2),
-                listItemValue: onenterlistitemvalue,
-                listOrdered: opener(list2, onenterlistordered),
-                listUnordered: opener(list2),
-                paragraph: opener(paragraph2),
-                reference: onenterreference,
-                referenceString: buffer,
-                resourceDestinationString: buffer,
-                resourceTitleString: buffer,
-                setextHeading: opener(heading2),
-                strong: opener(strong2),
-                thematicBreak: opener(thematicBreak2)
-            },
-            exit: {
-                atxHeading: closer(),
-                atxHeadingSequence: onexitatxheadingsequence,
-                autolink: closer(),
-                autolinkEmail: onexitautolinkemail,
-                autolinkProtocol: onexitautolinkprotocol,
-                blockQuote: closer(),
-                characterEscapeValue: onexitdata,
-                characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
-                characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
-                characterReferenceValue: onexitcharacterreferencevalue,
-                codeFenced: closer(onexitcodefenced),
-                codeFencedFence: onexitcodefencedfence,
-                codeFencedFenceInfo: onexitcodefencedfenceinfo,
-                codeFencedFenceMeta: onexitcodefencedfencemeta,
-                codeFlowValue: onexitdata,
-                codeIndented: closer(onexitcodeindented),
-                codeText: closer(onexitcodetext),
-                codeTextData: onexitdata,
-                data: onexitdata,
-                definition: closer(),
-                definitionDestinationString: onexitdefinitiondestinationstring,
-                definitionLabelString: onexitdefinitionlabelstring,
-                definitionTitleString: onexitdefinitiontitlestring,
-                emphasis: closer(),
-                hardBreakEscape: closer(onexithardbreak),
-                hardBreakTrailing: closer(onexithardbreak),
-                htmlFlow: closer(onexithtmlflow),
-                htmlFlowData: onexitdata,
-                htmlText: closer(onexithtmltext),
-                htmlTextData: onexitdata,
-                image: closer(onexitimage),
-                label: onexitlabel,
-                labelText: onexitlabeltext,
-                lineEnding: onexitlineending,
-                link: closer(onexitlink),
-                listItem: closer(),
-                listOrdered: closer(),
-                listUnordered: closer(),
-                paragraph: closer(),
-                referenceString: onexitreferencestring,
-                resourceDestinationString: onexitresourcedestinationstring,
-                resourceTitleString: onexitresourcetitlestring,
-                resource: onexitresource,
-                setextHeading: closer(onexitsetextheading),
-                setextHeadingLineSequence: onexitsetextheadinglinesequence,
-                setextHeadingText: onexitsetextheadingtext,
-                strong: closer(),
-                thematicBreak: closer()
+    function Tabs({
+        className,
+        onSelectTab,
+        selectedTab,
+        tabs
+    }) {
+        const objectTabs = tabs.map((tab2) => instanceOfTab(tab2) ? tab2 : {
+            title: tab2
+        });
+        const tabSelected = instanceOfTab(selectedTab) ? selectedTab : {
+            title: selectedTab
+        };
+        const onClick = (tab2) => () => {
+            if (onSelectTab) {
+                onSelectTab(tab2);
             }
         };
-        configure(config2, (options || {}).mdastExtensions || []);
-        const data2 = {};
-        return compile;
+        return jsxRuntime.exports.jsx(TabWrapper, {
+            className,
+            children: objectTabs.map((tab2, idx) => jsxRuntime.exports.jsx(TabComponent, {
+                onClick: onClick(instanceOfTab(selectedTab) ? tab2 : tab2.title),
+                selected: isEqual_1(tab2, tabSelected || objectTabs[0]),
+                children: jsxRuntime.exports.jsx(Title$2, {
+                    children: tab2.title
+                })
+            }, `tab-${objectTabs[idx].title}`))
+        });
+    }
+    const StyledHeader = styled__default.default.div`
+    display: flex;
+    align-items: center;
+    justify-content: space-between;
 
-        function compile(events2) {
-            let tree = {
-                type: "root",
-                children: []
-            };
-            const context2 = {
-                stack: [tree],
-                tokenStack: [],
-                config: config2,
-                enter,
-                exit: exit2,
-                buffer,
-                resume,
-                data: data2
-            };
-            const listStack = [];
-            let index2 = -1;
-            while (++index2 < events2.length) {
-                if (events2[index2][1].type === "listOrdered" || events2[index2][1].type === "listUnordered") {
-                    if (events2[index2][0] === "enter") {
-                        listStack.push(index2);
-                    } else {
-                        const tail = listStack.pop();
-                        index2 = prepareList(events2, tail, index2);
-                    }
-                }
-            }
-            index2 = -1;
-            while (++index2 < events2.length) {
-                const handler = config2[events2[index2][0]];
-                if (own$6.call(handler, events2[index2][1].type)) {
-                    handler[events2[index2][1].type].call(
-                        Object.assign({
-                                sliceSerialize: events2[index2][2].sliceSerialize
-                            },
-                            context2
-                        ),
-                        events2[index2][1]
-                    );
-                }
-            }
-            if (context2.tokenStack.length > 0) {
-                const tail = context2.tokenStack[context2.tokenStack.length - 1];
-                const handler = tail[1] || defaultOnError;
-                handler.call(context2, void 0, tail[0]);
-            }
-            tree.position = {
-                start: point$2(
-                    events2.length > 0 ? events2[0][1].start : {
-                        line: 1,
-                        column: 1,
-                        offset: 0
-                    }
-                ),
-                end: point$2(
-                    events2.length > 0 ? events2[events2.length - 2][1].end : {
-                        line: 1,
-                        column: 1,
-                        offset: 0
-                    }
-                )
-            };
-            index2 = -1;
-            while (++index2 < config2.transforms.length) {
-                tree = config2.transforms[index2](tree) || tree;
-            }
-            return tree;
-        }
+    width: 100%;
+    padding-right: 0.5rem;
+`;
+    const StyledAccordion = core$2.injectCss(Accordion$1);
 
-        function prepareList(events2, start2, length) {
-            let index2 = start2 - 1;
-            let containerBalance = -1;
-            let listSpread = false;
-            let listItem3;
-            let lineIndex;
-            let firstBlankLineIndex;
-            let atMarker;
-            while (++index2 <= length) {
-                const event2 = events2[index2];
-                switch (event2[1].type) {
-                    case "listUnordered":
-                    case "listOrdered":
-                    case "blockQuote": {
-                        if (event2[0] === "enter") {
-                            containerBalance++;
-                        } else {
-                            containerBalance--;
-                        }
-                        atMarker = void 0;
-                        break;
-                    }
-                    case "lineEndingBlank": {
-                        if (event2[0] === "enter") {
-                            if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
-                                firstBlankLineIndex = index2;
-                            }
-                            atMarker = void 0;
-                        }
-                        break;
-                    }
-                    case "linePrefix":
-                    case "listItemValue":
-                    case "listItemMarker":
-                    case "listItemPrefix":
-                    case "listItemPrefixWhitespace": {
-                        break;
-                    }
-                    default: {
-                        atMarker = void 0;
-                    }
-                }
-                if (!containerBalance && event2[0] === "enter" && event2[1].type === "listItemPrefix" || containerBalance === -1 && event2[0] === "exit" && (event2[1].type === "listUnordered" || event2[1].type === "listOrdered")) {
-                    if (listItem3) {
-                        let tailIndex = index2;
-                        lineIndex = void 0;
-                        while (tailIndex--) {
-                            const tailEvent = events2[tailIndex];
-                            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
-                                if (tailEvent[0] === "exit")
-                                    continue;
-                                if (lineIndex) {
-                                    events2[lineIndex][1].type = "lineEndingBlank";
-                                    listSpread = true;
-                                }
-                                tailEvent[1].type = "lineEnding";
-                                lineIndex = tailIndex;
-                            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent")
-                            ;
-                            else {
-                                break;
-                            }
-                        }
-                        if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
-                            listItem3._spread = true;
-                        }
-                        listItem3.end = Object.assign({},
-                            lineIndex ? events2[lineIndex][1].start : event2[1].end
-                        );
-                        events2.splice(lineIndex || index2, 0, ["exit", listItem3, event2[2]]);
-                        index2++;
-                        length++;
-                    }
-                    if (event2[1].type === "listItemPrefix") {
-                        const item = {
-                            type: "listItem",
-                            _spread: false,
-                            start: Object.assign({}, event2[1].start),
-                            end: void 0
-                        };
-                        listItem3 = item;
-                        events2.splice(index2, 0, ["enter", item, event2[2]]);
-                        index2++;
-                        length++;
-                        firstBlankLineIndex = void 0;
-                        atMarker = true;
-                    }
-                }
-            }
-            events2[start2][1]._spread = listSpread;
-            return length;
-        }
+    function headerRenderer(item) {
+        const theme2 = useClTheme();
+        return /* @__PURE__ */ React__default.default.createElement(StyledHeader, null, typeof item.label === "string" ? /* @__PURE__ */ React__default.default.createElement("span", null, item.label) : /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
+            component: item.label
+        }), item.badge && /* @__PURE__ */ React__default.default.createElement(Badge, {
+            color: item.badge.color || theme2.colors.primary,
+            height: 24,
+            width: "10rem"
+        }, item.badge.label));
+    }
+    const innerRender = (item) => {
+        return /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
+            component: item.content
+        });
+    };
 
-        function opener(create2, and) {
-            return open;
+    function Accordion(props) {
+        const [style2, css2] = core$2.useComponentStyles(props);
+        const [value, setValue] = core$2.useVariable(props.value);
+        const [onCarouselAction] = core$2.useAction(props.onchange);
 
-            function open(token) {
-                enter.call(this, create2(token), token);
-                if (and)
-                    and.call(this, token);
-            }
+        function handleChange(val) {
+            setValue(val);
+            onCarouselAction(val);
         }
+        return /* @__PURE__ */ React__default.default.createElement(
+            StyledAccordion, {
+                $rawCss: css2,
+                className: props.className,
+                headerRenderer,
+                initialOpenItems: props.initial,
+                innerRenderer: innerRender,
+                items: props.items,
+                multi: props.multi,
+                onChange: handleChange,
+                style: style2,
+                value
+            }
+        );
+    }
+    var ComponentType = /* @__PURE__ */ ((ComponentType2) => {
+        ComponentType2["ANCHOR"] = "anchor";
+        ComponentType2["BUTTON"] = "button";
+        ComponentType2["CAROUSEL"] = "carousel";
+        ComponentType2["CODE"] = "code";
+        ComponentType2["COMPONENT_SELECT_LIST"] = "component_select_list";
+        ComponentType2["FORM_PAGE"] = "form_page";
+        ComponentType2["HEADING"] = "heading";
+        ComponentType2["HTML_RAW"] = "html_raw";
+        ComponentType2["ICON"] = "icon";
+        ComponentType2["PARAGRAPH"] = "paragraph";
+        ComponentType2["PROGRESS_BAR"] = "progress_bar";
+        ComponentType2["SPACER"] = "spacer";
+        ComponentType2["STACK"] = "stack";
+        ComponentType2["TABLE"] = "table";
+        ComponentType2["TEXT"] = "text";
+        ComponentType2["TOOLTIP"] = "tooltip";
+        return ComponentType2;
+    })(ComponentType || {});
+    const StyledA = core$2.injectCss(styled__default.default.a`
+    :visited {
+        color: ${(props) => props.theme.colors.secondary};
+    }
 
-        function buffer() {
-            this.stack.push({
-                type: "fragment",
-                children: []
-            });
-        }
+    :link {
+        color: ${(props) => props.theme.colors.primary};
+    }
 
-        function enter(node2, token, errorHandler) {
-            const parent = this.stack[this.stack.length - 1];
-            const siblings = parent.children;
-            siblings.push(node2);
-            this.stack.push(node2);
-            this.tokenStack.push([token, errorHandler]);
-            node2.position = {
-                start: point$2(token.start),
-                end: void 0
-            };
-        }
+    :hover {
+        color: ${(props) => props.theme.colors.primaryHover};
+    }
 
-        function closer(and) {
-            return close;
+    :active {
+        color: ${(props) => props.theme.colors.primaryDown};
+    }
+`);
 
-            function close(token) {
-                if (and)
-                    and.call(this, token);
-                exit2.call(this, token);
+    function Anchor(props) {
+        const [style2, css2] = core$2.useComponentStyles(props);
+        const isRelative = React.useMemo(() => {
+            var _a3;
+            return (_a3 = props.href) == null ? void 0 : _a3.startsWith("/");
+        }, [props.href]);
+        const extraProps = React.useMemo(() => {
+            if (!isRelative) {
+                return {};
             }
-        }
-
-        function exit2(token, onExitError) {
-            const node2 = this.stack.pop();
-            const open = this.tokenStack.pop();
-            if (!open) {
-                throw new Error(
-                    "Cannot close `" + token.type + "` (" + stringifyPosition({
-                        start: token.start,
-                        end: token.end
-                    }) + "): it\u2019s not open"
-                );
-            } else if (open[0].type !== token.type) {
-                if (onExitError) {
-                    onExitError.call(this, token, open[0]);
-                } else {
-                    const handler = open[1] || defaultOnError;
-                    handler.call(this, token, open[0]);
+            return {
+                href: void 0,
+                to: props.href
+            };
+        }, [isRelative, props.href]);
+        const AsComponent = React.useMemo(() => isRelative ? core$2.ReactRouter.Link : "a", [isRelative]);
+        return /* @__PURE__ */ React__default.default.createElement(
+            StyledA, {
+                $rawCss: css2,
+                as: AsComponent,
+                className: props.clean ? "report-clean-anchor" : props.className,
+                href: props.href,
+                id: props.name,
+                rel: "noreferrer",
+                style: style2,
+                target: props.new_tab ? "_blank" : "_self",
+                ...extraProps
+            },
+            /* @__PURE__ */
+            React__default.default.createElement(core$2.DisplayCtx.Provider, {
+                value: {
+                    component: ComponentType.ANCHOR,
+                    direction: "horizontal"
                 }
-            }
-            node2.position.end = point$2(token.end);
-        }
-
-        function resume() {
-            return toString$4(this.stack.pop());
-        }
-
-        function onenterlistordered() {
-            this.data.expectingFirstListItemValue = true;
-        }
+            }, props.children.map((child, idx) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
+                component: child,
+                key: `stack-${idx}-${child.name}`
+            })))
+        );
+    }
+    const StyledTag$2 = core$2.injectCss("div");
 
-        function onenterlistitemvalue(token) {
-            if (this.data.expectingFirstListItemValue) {
-                const ancestor = this.stack[this.stack.length - 2];
-                ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
-                this.data.expectingFirstListItemValue = void 0;
+    function BulletList(props) {
+        const items = core$2.useVariable(props.items)[0];
+        const [style2, css2] = core$2.useComponentStyles(props);
+        const tag = props.numbered ? "ol" : "ul";
+        return /* @__PURE__ */ React__default.default.createElement(StyledTag$2, {
+            $rawCss: css2,
+            as: tag,
+            style: style2
+        }, items.map((item, index2) => /* @__PURE__ */ React__default.default.createElement("li", {
+            key: `li-${index2}`,
+            style: {
+                textAlign: "left"
             }
-        }
+        }, item)));
+    }
 
-        function onexitcodefencedfenceinfo() {
-            const data3 = this.resume();
-            const node2 = this.stack[this.stack.length - 1];
-            node2.lang = data3;
+    function isConditionTrue(operator2, value, other) {
+        if (operator2 === core$2.ConditionOperator.EQUAL) {
+            return value === other;
         }
-
-        function onexitcodefencedfencemeta() {
-            const data3 = this.resume();
-            const node2 = this.stack[this.stack.length - 1];
-            node2.meta = data3;
+        if (operator2 === core$2.ConditionOperator.NOT_EQUAL) {
+            return value !== other;
         }
-
-        function onexitcodefencedfence() {
-            if (this.data.flowCodeInside)
-                return;
-            this.buffer();
-            this.data.flowCodeInside = true;
+        if (operator2 === core$2.ConditionOperator.GREATER_EQUAL) {
+            return value >= other;
         }
-
-        function onexitcodefenced() {
-            const data3 = this.resume();
-            const node2 = this.stack[this.stack.length - 1];
-            node2.value = data3.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
-            this.data.flowCodeInside = void 0;
+        if (operator2 === core$2.ConditionOperator.GREATER_THAN) {
+            return value > other;
         }
-
-        function onexitcodeindented() {
-            const data3 = this.resume();
-            const node2 = this.stack[this.stack.length - 1];
-            node2.value = data3.replace(/(\r?\n|\r)$/g, "");
+        if (operator2 === core$2.ConditionOperator.LESS_EQUAL) {
+            return value <= other;
         }
-
-        function onexitdefinitionlabelstring(token) {
-            const label = this.resume();
-            const node2 = this.stack[this.stack.length - 1];
-            node2.label = label;
-            node2.identifier = normalizeIdentifier(
-                this.sliceSerialize(token)
-            ).toLowerCase();
+        if (operator2 === core$2.ConditionOperator.LESS_THAN) {
+            return value < other;
         }
-
-        function onexitdefinitiontitlestring() {
-            const data3 = this.resume();
-            const node2 = this.stack[this.stack.length - 1];
-            node2.title = data3;
+        if (operator2 === core$2.ConditionOperator.TRUTHY) {
+            return !!value;
         }
+        throw new Error(`Unexpected operator ${String(operator2)} passed to conditional (If) component`);
+    }
 
-        function onexitdefinitiondestinationstring() {
-            const data3 = this.resume();
-            const node2 = this.stack[this.stack.length - 1];
-            node2.url = data3;
-        }
+    function If(props) {
+        const value = core$2.useAnyVariable(props.condition.variable);
+        const other = core$2.useAnyVariable(props.condition.other);
+        const conditionResult = React.useMemo(
+            () => isConditionTrue(props.condition.operator, value, other),
+            [props.condition, value, other]
+        );
+        const children2 = React.useMemo(() => {
+            return conditionResult ? props.true_children : props.false_children;
+        }, [conditionResult]);
+        return /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, children2.map((child, idx) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
+            component: child,
+            key: `if-${idx}-${child.name}-${String(conditionResult)}`
+        })));
+    }
 
-        function onexitatxheadingsequence(token) {
-            const node2 = this.stack[this.stack.length - 1];
-            if (!node2.depth) {
-                const depth = this.sliceSerialize(token).length;
-                node2.depth = depth;
-            }
-        }
+    function isCondition(condition) {
+        return condition && !!condition.operator;
+    }
 
-        function onexitsetextheadingtext() {
-            this.data.setextHeadingSlurpLineEnding = true;
+    function useConditionOrVariable(arg) {
+        if (isCondition(arg)) {
+            const value = core$2.useVariable(arg.variable)[0];
+            const other = core$2.useVariable(arg.other)[0];
+            return isConditionTrue(arg.operator, value, other);
         }
+        return core$2.useVariable(arg)[0];
+    }
+    const StyledButton$1 = core$2.injectCss(styled__default.default(Button$3)`
+    flex: ${(props) => props.isSimpleButton ? void 0 : "1 1 100%"};
+`);
 
-        function onexitsetextheadinglinesequence(token) {
-            const node2 = this.stack[this.stack.length - 1];
-            node2.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;
-        }
+    function Button(props) {
+        var _a3, _b, _c, _d;
+        const [style2, css2] = core$2.useComponentStyles(props);
+        const [onClick, loading] = core$2.useAction(props.onclick);
+        const disabled2 = useConditionOrVariable(props.disabled);
+        const Icon2 = props.icon ? core$2.getIcon(props.icon) : null;
+        const iconColor = Array.isArray(props.children) ? ((_c = (_b = (_a3 = props.children) == null ? void 0 : _a3[0]) == null ? void 0 : _b.props) == null ? void 0 : _c.color) || "inherit" : "inherit";
+        return /* @__PURE__ */ React__default.default.createElement(
+            StyledButton$1, {
+                $rawCss: css2,
+                className: props.className,
+                disabled: disabled2,
+                isSimpleButton: typeof props.children === "string" || ((_d = props.children[0]) == null ? void 0 : _d.name) === "Text",
+                loading,
+                onClick: () => onClick(null),
+                outline: props.outline,
+                style: {
+                    gap: "0.75rem",
+                    ...style2
+                },
+                styling: props.styling
+            },
+            props.icon && /* @__PURE__ */ React__default.default.createElement(
+                Icon2, {
+                    style: {
+                        color: iconColor,
+                        cursor: "pointer"
+                    }
+                }
+            ),
+            /* @__PURE__ */
+            React__default.default.createElement(core$2.DisplayCtx.Provider, {
+                value: {
+                    component: ComponentType.BUTTON,
+                    direction: "horizontal"
+                }
+            }, typeof props.children === "string" ? props.children : props.children.map((child) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
+                component: child,
+                key: `button-${child.uid}`
+            })))
+        );
+    }
+    const formCtx = React.createContext(null);
 
-        function onexitsetextheading() {
-            this.data.setextHeadingSlurpLineEnding = void 0;
+    function useFormContext(props) {
+        const formContext = React.useContext(formCtx);
+        const idRef = React.useRef(null);
+        const isMounted = React.useRef(false);
+        if (formContext === null) {
+            return {
+                resolveInitialValue: (defaultValue2) => {
+                    var _a3;
+                    return (_a3 = props.value) != null ? _a3 : defaultValue2;
+                },
+                updateForm: () => {}
+            };
         }
-
-        function onenterdata(token) {
-            const node2 = this.stack[this.stack.length - 1];
-            const siblings = node2.children;
-            let tail = siblings[siblings.length - 1];
-            if (!tail || tail.type !== "text") {
-                tail = text2();
-                tail.position = {
-                    start: point$2(token.start),
-                    end: void 0
-                };
-                siblings.push(tail);
+        if (isMounted.current === false) {
+            isMounted.current = true;
+            if (!props.id) {
+                throw new Error("Attempted to add a form interactive component without an id");
             }
-            this.stack.push(tail);
-        }
-
-        function onexitdata(token) {
-            const tail = this.stack.pop();
-            tail.value += this.sliceSerialize(token);
-            tail.position.end = point$2(token.end);
+            idRef.current = props.id;
         }
+        const updateForm = (value) => formContext.updateForm(value, idRef.current);
+        const resolveInitialValue = (defaultValue2) => formContext.resolveInitialValue(defaultValue2, props.value, idRef.current);
+        return {
+            resolveInitialValue,
+            updateForm
+        };
+    }
+    const StyledButtonBar = core$2.injectCss(ButtonBar$1);
 
-        function onexitlineending(token) {
-            const context2 = this.stack[this.stack.length - 1];
-            if (this.data.atHardBreak) {
-                const tail = context2.children[context2.children.length - 1];
-                tail.position.end = point$2(token.end);
-                this.data.atHardBreak = void 0;
-                return;
-            }
-            if (!this.data.setextHeadingSlurpLineEnding && config2.canContainEols.includes(context2.type)) {
-                onenterdata.call(this, token);
-                onexitdata.call(this, token);
+    function ButtonBar(props) {
+        const formCtx2 = useFormContext(props);
+        const [style2, css2] = core$2.useComponentStyles(props);
+        const [value, setValue] = core$2.useVariable(formCtx2.resolveInitialValue(props.items[0].value));
+        const [onChangeAction] = core$2.useAction(props.onchange);
+        const onSelect = React.useCallback(
+            (item) => {
+                setValue(item.value);
+                onChangeAction(item.value);
+                formCtx2.updateForm(item.value);
+            },
+            [setValue, onChangeAction]
+        );
+        return /* @__PURE__ */ React__default.default.createElement(
+            StyledButtonBar, {
+                $rawCss: css2,
+                className: props.className,
+                items: props.items,
+                onSelect,
+                style: style2,
+                styling: props.styling,
+                value: props.items.find((item) => item.value === value)
             }
-        }
+        );
+    }
 
-        function onexithardbreak() {
-            this.data.atHardBreak = true;
-        }
+    function _getPrototypeOf(o2) {
+        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
+            return o3.__proto__ || Object.getPrototypeOf(o3);
+        };
+        return _getPrototypeOf(o2);
+    }
 
-        function onexithtmlflow() {
-            const data3 = this.resume();
-            const node2 = this.stack[this.stack.length - 1];
-            node2.value = data3;
+    function _isNativeFunction(fn2) {
+        try {
+            return Function.toString.call(fn2).indexOf("[native code]") !== -1;
+        } catch (e3) {
+            return typeof fn2 === "function";
         }
+    }
 
-        function onexithtmltext() {
-            const data3 = this.resume();
-            const node2 = this.stack[this.stack.length - 1];
-            node2.value = data3;
+    function _isNativeReflectConstruct() {
+        if (typeof Reflect === "undefined" || !Reflect.construct)
+            return false;
+        if (Reflect.construct.sham)
+            return false;
+        if (typeof Proxy === "function")
+            return true;
+        try {
+            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
+            return true;
+        } catch (e3) {
+            return false;
         }
+    }
 
-        function onexitcodetext() {
-            const data3 = this.resume();
-            const node2 = this.stack[this.stack.length - 1];
-            node2.value = data3;
+    function _construct(Parent, args, Class) {
+        if (_isNativeReflectConstruct()) {
+            _construct = Reflect.construct.bind();
+        } else {
+            _construct = function _construct2(Parent2, args2, Class2) {
+                var a2 = [null];
+                a2.push.apply(a2, args2);
+                var Constructor = Function.bind.apply(Parent2, a2);
+                var instance2 = new Constructor();
+                if (Class2)
+                    _setPrototypeOf(instance2, Class2.prototype);
+                return instance2;
+            };
         }
+        return _construct.apply(null, arguments);
+    }
 
-        function onexitlink() {
-            const node2 = this.stack[this.stack.length - 1];
-            if (this.data.inReference) {
-                const referenceType = this.data.referenceType || "shortcut";
-                node2.type += "Reference";
-                node2.referenceType = referenceType;
-                delete node2.url;
-                delete node2.title;
-            } else {
-                delete node2.identifier;
-                delete node2.label;
+    function _wrapNativeSuper(Class) {
+        var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
+        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
+            if (Class2 === null || !_isNativeFunction(Class2))
+                return Class2;
+            if (typeof Class2 !== "function") {
+                throw new TypeError("Super expression must either be null or a function");
             }
-            this.data.referenceType = void 0;
-        }
-
-        function onexitimage() {
-            const node2 = this.stack[this.stack.length - 1];
-            if (this.data.inReference) {
-                const referenceType = this.data.referenceType || "shortcut";
-                node2.type += "Reference";
-                node2.referenceType = referenceType;
-                delete node2.url;
-                delete node2.title;
-            } else {
-                delete node2.identifier;
-                delete node2.label;
+            if (typeof _cache !== "undefined") {
+                if (_cache.has(Class2))
+                    return _cache.get(Class2);
+                _cache.set(Class2, Wrapper2);
             }
-            this.data.referenceType = void 0;
-        }
-
-        function onexitlabeltext(token) {
-            const string2 = this.sliceSerialize(token);
-            const ancestor = this.stack[this.stack.length - 2];
-            ancestor.label = decodeString(string2);
-            ancestor.identifier = normalizeIdentifier(string2).toLowerCase();
-        }
 
-        function onexitlabel() {
-            const fragment2 = this.stack[this.stack.length - 1];
-            const value = this.resume();
-            const node2 = this.stack[this.stack.length - 1];
-            this.data.inReference = true;
-            if (node2.type === "link") {
-                const children2 = fragment2.children;
-                node2.children = children2;
-            } else {
-                node2.alt = value;
+            function Wrapper2() {
+                return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
             }
-        }
-
-        function onexitresourcedestinationstring() {
-            const data3 = this.resume();
-            const node2 = this.stack[this.stack.length - 1];
-            node2.url = data3;
-        }
-
-        function onexitresourcetitlestring() {
-            const data3 = this.resume();
-            const node2 = this.stack[this.stack.length - 1];
-            node2.title = data3;
-        }
+            Wrapper2.prototype = Object.create(Class2.prototype, {
+                constructor: {
+                    value: Wrapper2,
+                    enumerable: false,
+                    writable: true,
+                    configurable: true
+                }
+            });
+            return _setPrototypeOf(Wrapper2, Class2);
+        };
+        return _wrapNativeSuper(Class);
+    }
+    var PolishedError$1 = /* @__PURE__ */ function(_Error) {
+        _inheritsLoose(PolishedError2, _Error);
 
-        function onexitresource() {
-            this.data.inReference = void 0;
+        function PolishedError2(code2) {
+            var _this;
+            {
+                _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + code2 + " for more information.") || this;
+            }
+            return _assertThisInitialized(_this);
         }
+        return PolishedError2;
+    }( /* @__PURE__ */ _wrapNativeSuper(Error));
 
-        function onenterreference() {
-            this.data.referenceType = "collapsed";
-        }
+    function colorToInt$1(color2) {
+        return Math.round(color2 * 255);
+    }
 
-        function onexitreferencestring(token) {
-            const label = this.resume();
-            const node2 = this.stack[this.stack.length - 1];
-            node2.label = label;
-            node2.identifier = normalizeIdentifier(
-                this.sliceSerialize(token)
-            ).toLowerCase();
-            this.data.referenceType = "full";
-        }
+    function convertToInt$1(red, green, blue) {
+        return colorToInt$1(red) + "," + colorToInt$1(green) + "," + colorToInt$1(blue);
+    }
 
-        function onexitcharacterreferencemarker(token) {
-            this.data.characterReferenceType = token.type;
+    function hslToRgb$1(hue, saturation, lightness, convert2) {
+        if (convert2 === void 0) {
+            convert2 = convertToInt$1;
         }
-
-        function onexitcharacterreferencevalue(token) {
-            const data3 = this.sliceSerialize(token);
-            const type2 = this.data.characterReferenceType;
-            let value;
-            if (type2) {
-                value = decodeNumericCharacterReference(
-                    data3,
-                    type2 === "characterReferenceMarkerNumeric" ? 10 : 16
-                );
-                this.data.characterReferenceType = void 0;
-            } else {
-                const result = decodeNamedCharacterReference(data3);
-                value = result;
-            }
-            const tail = this.stack.pop();
-            tail.value += value;
-            tail.position.end = point$2(token.end);
+        if (saturation === 0) {
+            return convert2(lightness, lightness, lightness);
         }
-
-        function onexitautolinkprotocol(token) {
-            onexitdata.call(this, token);
-            const node2 = this.stack[this.stack.length - 1];
-            node2.url = this.sliceSerialize(token);
+        var huePrime = (hue % 360 + 360) % 360 / 60;
+        var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
+        var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
+        var red = 0;
+        var green = 0;
+        var blue = 0;
+        if (huePrime >= 0 && huePrime < 1) {
+            red = chroma;
+            green = secondComponent;
+        } else if (huePrime >= 1 && huePrime < 2) {
+            red = secondComponent;
+            green = chroma;
+        } else if (huePrime >= 2 && huePrime < 3) {
+            green = chroma;
+            blue = secondComponent;
+        } else if (huePrime >= 3 && huePrime < 4) {
+            green = secondComponent;
+            blue = chroma;
+        } else if (huePrime >= 4 && huePrime < 5) {
+            red = secondComponent;
+            blue = chroma;
+        } else if (huePrime >= 5 && huePrime < 6) {
+            red = chroma;
+            blue = secondComponent;
         }
+        var lightnessModification = lightness - chroma / 2;
+        var finalRed = red + lightnessModification;
+        var finalGreen = green + lightnessModification;
+        var finalBlue = blue + lightnessModification;
+        return convert2(finalRed, finalGreen, finalBlue);
+    }
+    var namedColorMap$1 = {
+        aliceblue: "f0f8ff",
+        antiquewhite: "faebd7",
+        aqua: "00ffff",
+        aquamarine: "7fffd4",
+        azure: "f0ffff",
+        beige: "f5f5dc",
+        bisque: "ffe4c4",
+        black: "000",
+        blanchedalmond: "ffebcd",
+        blue: "0000ff",
+        blueviolet: "8a2be2",
+        brown: "a52a2a",
+        burlywood: "deb887",
+        cadetblue: "5f9ea0",
+        chartreuse: "7fff00",
+        chocolate: "d2691e",
+        coral: "ff7f50",
+        cornflowerblue: "6495ed",
+        cornsilk: "fff8dc",
+        crimson: "dc143c",
+        cyan: "00ffff",
+        darkblue: "00008b",
+        darkcyan: "008b8b",
+        darkgoldenrod: "b8860b",
+        darkgray: "a9a9a9",
+        darkgreen: "006400",
+        darkgrey: "a9a9a9",
+        darkkhaki: "bdb76b",
+        darkmagenta: "8b008b",
+        darkolivegreen: "556b2f",
+        darkorange: "ff8c00",
+        darkorchid: "9932cc",
+        darkred: "8b0000",
+        darksalmon: "e9967a",
+        darkseagreen: "8fbc8f",
+        darkslateblue: "483d8b",
+        darkslategray: "2f4f4f",
+        darkslategrey: "2f4f4f",
+        darkturquoise: "00ced1",
+        darkviolet: "9400d3",
+        deeppink: "ff1493",
+        deepskyblue: "00bfff",
+        dimgray: "696969",
+        dimgrey: "696969",
+        dodgerblue: "1e90ff",
+        firebrick: "b22222",
+        floralwhite: "fffaf0",
+        forestgreen: "228b22",
+        fuchsia: "ff00ff",
+        gainsboro: "dcdcdc",
+        ghostwhite: "f8f8ff",
+        gold: "ffd700",
+        goldenrod: "daa520",
+        gray: "808080",
+        green: "008000",
+        greenyellow: "adff2f",
+        grey: "808080",
+        honeydew: "f0fff0",
+        hotpink: "ff69b4",
+        indianred: "cd5c5c",
+        indigo: "4b0082",
+        ivory: "fffff0",
+        khaki: "f0e68c",
+        lavender: "e6e6fa",
+        lavenderblush: "fff0f5",
+        lawngreen: "7cfc00",
+        lemonchiffon: "fffacd",
+        lightblue: "add8e6",
+        lightcoral: "f08080",
+        lightcyan: "e0ffff",
+        lightgoldenrodyellow: "fafad2",
+        lightgray: "d3d3d3",
+        lightgreen: "90ee90",
+        lightgrey: "d3d3d3",
+        lightpink: "ffb6c1",
+        lightsalmon: "ffa07a",
+        lightseagreen: "20b2aa",
+        lightskyblue: "87cefa",
+        lightslategray: "789",
+        lightslategrey: "789",
+        lightsteelblue: "b0c4de",
+        lightyellow: "ffffe0",
+        lime: "0f0",
+        limegreen: "32cd32",
+        linen: "faf0e6",
+        magenta: "f0f",
+        maroon: "800000",
+        mediumaquamarine: "66cdaa",
+        mediumblue: "0000cd",
+        mediumorchid: "ba55d3",
+        mediumpurple: "9370db",
+        mediumseagreen: "3cb371",
+        mediumslateblue: "7b68ee",
+        mediumspringgreen: "00fa9a",
+        mediumturquoise: "48d1cc",
+        mediumvioletred: "c71585",
+        midnightblue: "191970",
+        mintcream: "f5fffa",
+        mistyrose: "ffe4e1",
+        moccasin: "ffe4b5",
+        navajowhite: "ffdead",
+        navy: "000080",
+        oldlace: "fdf5e6",
+        olive: "808000",
+        olivedrab: "6b8e23",
+        orange: "ffa500",
+        orangered: "ff4500",
+        orchid: "da70d6",
+        palegoldenrod: "eee8aa",
+        palegreen: "98fb98",
+        paleturquoise: "afeeee",
+        palevioletred: "db7093",
+        papayawhip: "ffefd5",
+        peachpuff: "ffdab9",
+        peru: "cd853f",
+        pink: "ffc0cb",
+        plum: "dda0dd",
+        powderblue: "b0e0e6",
+        purple: "800080",
+        rebeccapurple: "639",
+        red: "f00",
+        rosybrown: "bc8f8f",
+        royalblue: "4169e1",
+        saddlebrown: "8b4513",
+        salmon: "fa8072",
+        sandybrown: "f4a460",
+        seagreen: "2e8b57",
+        seashell: "fff5ee",
+        sienna: "a0522d",
+        silver: "c0c0c0",
+        skyblue: "87ceeb",
+        slateblue: "6a5acd",
+        slategray: "708090",
+        slategrey: "708090",
+        snow: "fffafa",
+        springgreen: "00ff7f",
+        steelblue: "4682b4",
+        tan: "d2b48c",
+        teal: "008080",
+        thistle: "d8bfd8",
+        tomato: "ff6347",
+        turquoise: "40e0d0",
+        violet: "ee82ee",
+        wheat: "f5deb3",
+        white: "fff",
+        whitesmoke: "f5f5f5",
+        yellow: "ff0",
+        yellowgreen: "9acd32"
+    };
 
-        function onexitautolinkemail(token) {
-            onexitdata.call(this, token);
-            const node2 = this.stack[this.stack.length - 1];
-            node2.url = "mailto:" + this.sliceSerialize(token);
-        }
+    function nameToHex$1(color2) {
+        if (typeof color2 !== "string")
+            return color2;
+        var normalizedColorName = color2.toLowerCase();
+        return namedColorMap$1[normalizedColorName] ? "#" + namedColorMap$1[normalizedColorName] : color2;
+    }
+    var hexRegex$1 = /^#[a-fA-F0-9]{6}$/;
+    var hexRgbaRegex$1 = /^#[a-fA-F0-9]{8}$/;
+    var reducedHexRegex$1 = /^#[a-fA-F0-9]{3}$/;
+    var reducedRgbaHexRegex$1 = /^#[a-fA-F0-9]{4}$/;
+    var rgbRegex$1 = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i;
+    var rgbaRegex$1 = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
+    var hslRegex$1 = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
+    var hslaRegex$1 = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
 
-        function blockQuote2() {
-            return {
-                type: "blockquote",
-                children: []
-            };
+    function parseToRgb$1(color2) {
+        if (typeof color2 !== "string") {
+            throw new PolishedError$1(3);
         }
-
-        function codeFlow() {
+        var normalizedColor = nameToHex$1(color2);
+        if (normalizedColor.match(hexRegex$1)) {
             return {
-                type: "code",
-                lang: null,
-                meta: null,
-                value: ""
+                red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
+                green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
+                blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
             };
         }
-
-        function codeText2() {
+        if (normalizedColor.match(hexRgbaRegex$1)) {
+            var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
             return {
-                type: "inlineCode",
-                value: ""
+                red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
+                green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
+                blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
+                alpha
             };
         }
-
-        function definition2() {
+        if (normalizedColor.match(reducedHexRegex$1)) {
             return {
-                type: "definition",
-                identifier: "",
-                label: null,
-                title: null,
-                url: ""
+                red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
+                green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
+                blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
             };
         }
-
-        function emphasis2() {
+        if (normalizedColor.match(reducedRgbaHexRegex$1)) {
+            var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));
             return {
-                type: "emphasis",
-                children: []
+                red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
+                green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
+                blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
+                alpha: _alpha
             };
         }
-
-        function heading2() {
+        var rgbMatched = rgbRegex$1.exec(normalizedColor);
+        if (rgbMatched) {
             return {
-                type: "heading",
-                depth: 0,
-                children: []
+                red: parseInt("" + rgbMatched[1], 10),
+                green: parseInt("" + rgbMatched[2], 10),
+                blue: parseInt("" + rgbMatched[3], 10)
             };
         }
-
-        function hardBreak2() {
+        var rgbaMatched = rgbaRegex$1.exec(normalizedColor.substring(0, 50));
+        if (rgbaMatched) {
             return {
-                type: "break"
+                red: parseInt("" + rgbaMatched[1], 10),
+                green: parseInt("" + rgbaMatched[2], 10),
+                blue: parseInt("" + rgbaMatched[3], 10),
+                alpha: parseFloat("" + rgbaMatched[4]) > 1 ? parseFloat("" + rgbaMatched[4]) / 100 : parseFloat("" + rgbaMatched[4])
             };
         }
-
-        function html2() {
+        var hslMatched = hslRegex$1.exec(normalizedColor);
+        if (hslMatched) {
+            var hue = parseInt("" + hslMatched[1], 10);
+            var saturation = parseInt("" + hslMatched[2], 10) / 100;
+            var lightness = parseInt("" + hslMatched[3], 10) / 100;
+            var rgbColorString = "rgb(" + hslToRgb$1(hue, saturation, lightness) + ")";
+            var hslRgbMatched = rgbRegex$1.exec(rgbColorString);
+            if (!hslRgbMatched) {
+                throw new PolishedError$1(4, normalizedColor, rgbColorString);
+            }
             return {
-                type: "html",
-                value: ""
+                red: parseInt("" + hslRgbMatched[1], 10),
+                green: parseInt("" + hslRgbMatched[2], 10),
+                blue: parseInt("" + hslRgbMatched[3], 10)
             };
         }
-
-        function image2() {
+        var hslaMatched = hslaRegex$1.exec(normalizedColor.substring(0, 50));
+        if (hslaMatched) {
+            var _hue = parseInt("" + hslaMatched[1], 10);
+            var _saturation = parseInt("" + hslaMatched[2], 10) / 100;
+            var _lightness = parseInt("" + hslaMatched[3], 10) / 100;
+            var _rgbColorString = "rgb(" + hslToRgb$1(_hue, _saturation, _lightness) + ")";
+            var _hslRgbMatched = rgbRegex$1.exec(_rgbColorString);
+            if (!_hslRgbMatched) {
+                throw new PolishedError$1(4, normalizedColor, _rgbColorString);
+            }
             return {
-                type: "image",
-                title: null,
-                url: "",
-                alt: null
+                red: parseInt("" + _hslRgbMatched[1], 10),
+                green: parseInt("" + _hslRgbMatched[2], 10),
+                blue: parseInt("" + _hslRgbMatched[3], 10),
+                alpha: parseFloat("" + hslaMatched[4]) > 1 ? parseFloat("" + hslaMatched[4]) / 100 : parseFloat("" + hslaMatched[4])
             };
         }
-
-        function link2() {
-            return {
-                type: "link",
-                title: null,
-                url: "",
-                children: []
-            };
+        throw new PolishedError$1(5);
+    }
+    var reduceHexValue$2 = function reduceHexValue2(value) {
+        if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
+            return "#" + value[1] + value[3] + value[5];
         }
+        return value;
+    };
+    var reduceHexValue$1$1 = reduceHexValue$2;
 
-        function list2(token) {
-            return {
-                type: "list",
-                ordered: token.type === "listOrdered",
-                start: null,
-                spread: token._spread,
-                children: []
-            };
-        }
+    function numberToHex$1(value) {
+        var hex2 = value.toString(16);
+        return hex2.length === 1 ? "0" + hex2 : hex2;
+    }
 
-        function listItem2(token) {
-            return {
-                type: "listItem",
-                spread: token._spread,
-                checked: null,
-                children: []
-            };
+    function rgb$2(value, green, blue) {
+        if (typeof value === "number" && typeof green === "number" && typeof blue === "number") {
+            return reduceHexValue$1$1("#" + numberToHex$1(value) + numberToHex$1(green) + numberToHex$1(blue));
+        } else if (typeof value === "object" && green === void 0 && blue === void 0) {
+            return reduceHexValue$1$1("#" + numberToHex$1(value.red) + numberToHex$1(value.green) + numberToHex$1(value.blue));
         }
+        throw new PolishedError$1(6);
+    }
 
-        function paragraph2() {
-            return {
-                type: "paragraph",
-                children: []
-            };
+    function rgba$3(firstValue, secondValue, thirdValue, fourthValue) {
+        if (typeof firstValue === "string" && typeof secondValue === "number") {
+            var rgbValue = parseToRgb$1(firstValue);
+            return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
+        } else if (typeof firstValue === "number" && typeof secondValue === "number" && typeof thirdValue === "number" && typeof fourthValue === "number") {
+            return fourthValue >= 1 ? rgb$2(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
+        } else if (typeof firstValue === "object" && secondValue === void 0 && thirdValue === void 0 && fourthValue === void 0) {
+            return firstValue.alpha >= 1 ? rgb$2(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
         }
+        throw new PolishedError$1(7);
+    }
 
-        function strong2() {
-            return {
-                type: "strong",
-                children: []
-            };
-        }
+    function curried$1(f2, length, acc) {
+        return function fn2() {
+            var combined = acc.concat(Array.prototype.slice.call(arguments));
+            return combined.length >= length ? f2.apply(this, combined) : curried$1(f2, length, combined);
+        };
+    }
 
-        function text2() {
-            return {
-                type: "text",
-                value: ""
-            };
-        }
+    function curry$1(f2) {
+        return curried$1(f2, f2.length, []);
+    }
 
-        function thematicBreak2() {
-            return {
-                type: "thematicBreak"
-            };
-        }
+    function guard$1(lowerBoundary, upperBoundary, value) {
+        return Math.max(lowerBoundary, Math.min(upperBoundary, value));
     }
 
-    function point$2(d2) {
-        return {
-            line: d2.line,
-            column: d2.column,
-            offset: d2.offset
+    function mix$2(weight, color2, otherColor) {
+        if (color2 === "transparent")
+            return otherColor;
+        if (otherColor === "transparent")
+            return color2;
+        if (weight === 0)
+            return otherColor;
+        var parsedColor1 = parseToRgb$1(color2);
+        var color1 = _extends$1({}, parsedColor1, {
+            alpha: typeof parsedColor1.alpha === "number" ? parsedColor1.alpha : 1
+        });
+        var parsedColor2 = parseToRgb$1(otherColor);
+        var color22 = _extends$1({}, parsedColor2, {
+            alpha: typeof parsedColor2.alpha === "number" ? parsedColor2.alpha : 1
+        });
+        var alphaDelta = color1.alpha - color22.alpha;
+        var x2 = parseFloat(weight) * 2 - 1;
+        var y2 = x2 * alphaDelta === -1 ? x2 : x2 + alphaDelta;
+        var z2 = 1 + x2 * alphaDelta;
+        var weight1 = (y2 / z2 + 1) / 2;
+        var weight2 = 1 - weight1;
+        var mixedColor = {
+            red: Math.floor(color1.red * weight1 + color22.red * weight2),
+            green: Math.floor(color1.green * weight1 + color22.green * weight2),
+            blue: Math.floor(color1.blue * weight1 + color22.blue * weight2),
+            alpha: color1.alpha * parseFloat(weight) + color22.alpha * (1 - parseFloat(weight))
         };
+        return rgba$3(mixedColor);
     }
+    var curriedMix$1 = /* @__PURE__ */ curry$1(mix$2);
+    var mix$1$1 = curriedMix$1;
 
-    function configure(combined, extensions2) {
-        let index2 = -1;
-        while (++index2 < extensions2.length) {
-            const value = extensions2[index2];
-            if (Array.isArray(value)) {
-                configure(combined, value);
-            } else {
-                extension$1(combined, value);
-            }
-        }
+    function transparentize$1(amount, color2) {
+        if (color2 === "transparent")
+            return color2;
+        var parsedColor = parseToRgb$1(color2);
+        var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
+        var colorWithAlpha = _extends$1({}, parsedColor, {
+            alpha: guard$1(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)
+        });
+        return rgba$3(colorWithAlpha);
     }
+    var curriedTransparentize = /* @__PURE__ */ curry$1(transparentize$1);
+    var curriedTransparentize$1 = curriedTransparentize;
+    const CardDiv = core$2.injectCss(styled__default.default.div`
+    display: flex;
+    flex: 1 1 auto;
+    flex-direction: column;
 
-    function extension$1(combined, extension2) {
-        let key;
-        for (key in extension2) {
-            if (own$6.call(extension2, key)) {
-                switch (key) {
-                    case "canContainEols": {
-                        const right2 = extension2[key];
-                        if (right2) {
-                            combined[key].push(...right2);
-                        }
-                        break;
-                    }
-                    case "transforms": {
-                        const right2 = extension2[key];
-                        if (right2) {
-                            combined[key].push(...right2);
-                        }
-                        break;
-                    }
-                    case "enter":
-                    case "exit": {
-                        const right2 = extension2[key];
-                        if (right2) {
-                            Object.assign(combined[key], right2);
-                        }
-                        break;
-                    }
-                }
-            }
-        }
-    }
+    width: 100%;
+    padding: 1.5rem;
 
-    function defaultOnError(left2, right2) {
-        if (left2) {
-            throw new Error(
-                "Cannot close `" + left2.type + "` (" + stringifyPosition({
-                    start: left2.start,
-                    end: left2.end
-                }) + "): a different token (`" + right2.type + "`, " + stringifyPosition({
-                    start: right2.start,
-                    end: right2.end
-                }) + ") is open"
-            );
-        } else {
-            throw new Error(
-                "Cannot close document, a token (`" + right2.type + "`, " + stringifyPosition({
-                    start: right2.start,
-                    end: right2.end
-                }) + ") is still open"
-            );
-        }
-    }
+    color: ${(props) => props.theme.colors.text};
 
-    function remarkParse(options) {
-        const self2 = this;
-        self2.parser = parser2;
+    background: ${(props) => props.accent ? `radial-gradient(circle closest-corner at 50% 40%, ${curriedTransparentize$1(
+    0.9,
+    props.theme.colors.background
+  )} 0%, ${curriedTransparentize$1(
+    0.8,
+    props.theme.colors.blue4
+  )} 70%),radial-gradient(circle closest-corner at 20% 150%, ${curriedTransparentize$1(
+    0.8,
+    props.theme.colors.error
+  )} 0%, ${curriedTransparentize$1(0.2, props.theme.colors.blue4)} 230%)` : props.theme.colors.blue1};
+    border-radius: 1rem;
+    box-shadow: ${(props) => props.theme.shadow.medium};
+`);
+    const ChildrenWrapper = styled__default.default.div`
+    display: flex;
+    flex-direction: column;
+    gap: 0.75rem;
 
-        function parser2(doc2) {
-            return fromMarkdown(doc2, {
-                ...self2.data("settings"),
-                ...options,
-                extensions: self2.data("micromarkExtensions") || [],
-                mdastExtensions: self2.data("fromMarkdownExtensions") || []
-            });
-        }
-    }
+    width: 100%;
+    height: 100%;
+    margin-top: ${(props) => props.hasTitle || props.hasSubtitle ? "0.75rem" : "0rem"};
+`;
+    const Title$1 = styled__default.default.span`
+    font-size: 1.2rem;
+    font-weight: 400;
+    text-align: left;
+`;
+    const Subtitle = styled__default.default.span`
+    margin-top: ${(props) => props.hasTitle ? "0.25rem" : "0rem"};
 
-    function blockquote$1(state, node2) {
-        const result = {
-            type: "element",
-            tagName: "blockquote",
-            properties: {},
-            children: state.wrap(state.all(node2), true)
-        };
-        state.patch(node2, result);
-        return state.applyData(node2, result);
-    }
+    font-size: 1rem;
+    font-weight: 400;
+    color: ${(props) => props.theme.colors.grey4};
+    text-align: left;
+`;
 
-    function hardBreak$1(state, node2) {
-        const result = {
-            type: "element",
-            tagName: "br",
-            properties: {},
-            children: []
-        };
-        state.patch(node2, result);
-        return [state.applyData(node2, result), {
-            type: "text",
-            value: "\n"
-        }];
+    function Card$1(props) {
+        const [style2, css2] = core$2.useComponentStyles(props);
+        return /* @__PURE__ */ React__default.default.createElement(CardDiv, {
+            $rawCss: css2,
+            accent: props.accent,
+            style: style2
+        }, props.title && /* @__PURE__ */ React__default.default.createElement(Title$1, null, props.title), props.subtitle && /* @__PURE__ */ React__default.default.createElement(Subtitle, {
+            hasTitle: props.title !== null
+        }, props.subtitle), /* @__PURE__ */ React__default.default.createElement(
+            ChildrenWrapper, {
+                "data-type": "children-wrapper",
+                hasSubtitle: props.subtitle !== null,
+                hasTitle: props.title !== null,
+                style: {
+                    alignItems: props.align,
+                    justifyContent: props.justify
+                }
+            },
+            /* @__PURE__ */
+            React__default.default.createElement(core$2.DisplayCtx.Provider, {
+                value: {
+                    component: "card",
+                    direction: "vertical"
+                }
+            }, props.children.map((child, idx) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
+                component: child,
+                key: `card-${idx}-${child.name}`
+            })))
+        ));
     }
+    const StyledCarousel = core$2.injectCss(Carousel$1);
 
-    function code$3(state, node2) {
-        const value = node2.value ? node2.value + "\n" : "";
-        const properties = {};
-        if (node2.lang) {
-            properties.className = ["language-" + node2.lang];
+    function Carousel(props) {
+        const [items] = core$2.useVariable(props.items);
+        const [value, setValue] = core$2.useVariable(props.value);
+        const [onCarouselAction] = core$2.useAction(props.onchange);
+
+        function handleChange(val) {
+            setValue(val);
+            onCarouselAction(val);
         }
-        let result = {
-            type: "element",
-            tagName: "code",
-            properties,
-            children: [{
-                type: "text",
+        const remappedItems = React.useMemo(
+            () => items.map((item) => {
+                const {
+                    component,
+                    ...rest
+                } = item;
+                if (component) {
+                    return {
+                        ...rest,
+                        component: /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
+                            component
+                        }),
+                        imageAlt: item.image_alt,
+                        imageHeight: item.image_height,
+                        imageWidth: item.image_width
+                    };
+                }
+                return {
+                    ...rest,
+                    imageAlt: item.image_alt,
+                    imageHeight: item.image_height,
+                    imageWidth: item.image_width
+                };
+            }),
+            [items]
+        );
+        const [style2, css2] = core$2.useComponentStyles(props);
+        return /* @__PURE__ */ React__default.default.createElement(
+            StyledCarousel, {
+                $rawCss: css2,
+                className: props.className,
+                items: remappedItems,
+                onChange: handleChange,
+                style: style2,
                 value
-            }]
-        };
-        if (node2.meta) {
-            result.data = {
-                meta: node2.meta
-            };
-        }
-        state.patch(node2, result);
-        result = state.applyData(node2, result);
-        result = {
-            type: "element",
-            tagName: "pre",
-            properties: {},
-            children: [result]
-        };
-        state.patch(node2, result);
-        return result;
+            }
+        );
     }
+    const ColumnComponent = core$2.injectCss(styled__default.default.div`
+    overflow: visible;
+    display: flex;
+    flex: 1 1 auto;
+    flex-direction: ${(props) => props.direction === "horizontal" ? "row" : "column"};
+    gap: 0.75rem;
+`);
+    const StyledColumn$1 = core$2.injectCss(ColumnComponent);
 
-    function strikethrough(state, node2) {
-        const result = {
-            type: "element",
-            tagName: "del",
-            properties: {},
-            children: state.all(node2)
-        };
-        state.patch(node2, result);
-        return state.applyData(node2, result);
+    function Column(props) {
+        const [style2, css2] = core$2.useComponentStyles(props);
+        return /* @__PURE__ */ React__default.default.createElement(
+            StyledColumn$1, {
+                $rawCss: css2,
+                className: props.className,
+                direction: props.direction,
+                style: {
+                    alignItems: props.align,
+                    justifyContent: props.justify,
+                    ...style2
+                }
+            },
+            /* @__PURE__ */
+            React__default.default.createElement(core$2.DisplayCtx.Provider, {
+                value: {
+                    component: "column",
+                    direction: props.direction
+                }
+            }, props.children.map((child, idx) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
+                component: child,
+                key: `cell-${idx}-${child.uid}`
+            })))
+        );
     }
+    const StyledCheckbox = core$2.injectCss(CheckboxGroup$1);
 
-    function emphasis$1(state, node2) {
-        const result = {
-            type: "element",
-            tagName: "em",
-            properties: {},
-            children: state.all(node2)
-        };
-        state.patch(node2, result);
-        return state.applyData(node2, result);
+    function CheckboxGroup(props) {
+        const formCtx2 = useFormContext(props);
+        const [items] = core$2.useVariable(props.items);
+        const [value, setValue] = core$2.useVariable(formCtx2.resolveInitialValue([]));
+        const [style2, css2] = core$2.useComponentStyles(props);
+        const [onChangeAction] = core$2.useAction(props.onchange);
+        const onChange2 = React.useCallback(
+            (values) => {
+                let newValues;
+                if (Array.isArray(values)) {
+                    newValues = values.map((item) => item.value);
+                } else {
+                    newValues = values.value;
+                }
+                setValue(newValues);
+                onChangeAction(newValues);
+                formCtx2.updateForm(newValues);
+            },
+            [setValue]
+        );
+        return /* @__PURE__ */ React__default.default.createElement(
+            StyledCheckbox, {
+                $rawCss: css2,
+                className: props.className,
+                isListStyle: props.list_styling,
+                items,
+                onChange: onChange2,
+                selectMax: props.select_max,
+                selectMin: props.select_min,
+                style: style2,
+                values: items.filter((item) => value.includes(item.value))
+            }
+        );
     }
-
-    function footnoteReference$1(state, node2) {
-        const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
-        const id2 = String(node2.identifier).toUpperCase();
-        const safeId = normalizeUri(id2.toLowerCase());
-        const index2 = state.footnoteOrder.indexOf(id2);
-        let counter2;
-        let reuseCounter = state.footnoteCounts.get(id2);
-        if (reuseCounter === void 0) {
-            reuseCounter = 0;
-            state.footnoteOrder.push(id2);
-            counter2 = state.footnoteOrder.length;
-        } else {
-            counter2 = index2 + 1;
-        }
-        reuseCounter += 1;
-        state.footnoteCounts.set(id2, reuseCounter);
-        const link2 = {
-            type: "element",
-            tagName: "a",
-            properties: {
-                href: "#" + clobberPrefix + "fn-" + safeId,
-                id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
-                dataFootnoteRef: true,
-                ariaDescribedBy: ["footnote-label"]
+    /**
+     * Prism: Lightweight, robust, elegant syntax highlighting
+     *
+     * @license MIT <https://opensource.org/licenses/MIT>
+     * @author Lea Verou <https://lea.verou.me>
+     * @namespace
+     * @public
+     */
+    var Prism = function() {
+        var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
+        var uniqueId = 0;
+        var plainTextGrammar = {};
+        var _2 = {
+            util: {
+                encode: function encode2(tokens2) {
+                    if (tokens2 instanceof Token) {
+                        return new Token(tokens2.type, encode2(tokens2.content), tokens2.alias);
+                    } else if (Array.isArray(tokens2)) {
+                        return tokens2.map(encode2);
+                    } else {
+                        return tokens2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
+                    }
+                },
+                type: function(o2) {
+                    return Object.prototype.toString.call(o2).slice(8, -1);
+                },
+                objId: function(obj) {
+                    if (!obj["__id"]) {
+                        Object.defineProperty(obj, "__id", {
+                            value: ++uniqueId
+                        });
+                    }
+                    return obj["__id"];
+                },
+                clone: function deepClone(o2, visited) {
+                    visited = visited || {};
+                    var clone2;
+                    var id2;
+                    switch (_2.util.type(o2)) {
+                        case "Object":
+                            id2 = _2.util.objId(o2);
+                            if (visited[id2]) {
+                                return visited[id2];
+                            }
+                            clone2 = {};
+                            visited[id2] = clone2;
+                            for (var key in o2) {
+                                if (o2.hasOwnProperty(key)) {
+                                    clone2[key] = deepClone(o2[key], visited);
+                                }
+                            }
+                            return clone2;
+                        case "Array":
+                            id2 = _2.util.objId(o2);
+                            if (visited[id2]) {
+                                return visited[id2];
+                            }
+                            clone2 = [];
+                            visited[id2] = clone2;
+                            o2.forEach(function(v2, i2) {
+                                clone2[i2] = deepClone(v2, visited);
+                            });
+                            return clone2;
+                        default:
+                            return o2;
+                    }
+                },
+                getLanguage: function(element2) {
+                    while (element2) {
+                        var m2 = lang.exec(element2.className);
+                        if (m2) {
+                            return m2[1].toLowerCase();
+                        }
+                        element2 = element2.parentElement;
+                    }
+                    return "none";
+                },
+                setLanguage: function(element2, language2) {
+                    element2.className = element2.className.replace(RegExp(lang, "gi"), "");
+                    element2.classList.add("language-" + language2);
+                },
+                isActive: function(element2, className, defaultActivation) {
+                    var no = "no-" + className;
+                    while (element2) {
+                        var classList2 = element2.classList;
+                        if (classList2.contains(className)) {
+                            return true;
+                        }
+                        if (classList2.contains(no)) {
+                            return false;
+                        }
+                        element2 = element2.parentElement;
+                    }
+                    return !!defaultActivation;
+                }
             },
-            children: [{
-                type: "text",
-                value: String(counter2)
-            }]
-        };
-        state.patch(node2, link2);
-        const sup = {
-            type: "element",
-            tagName: "sup",
-            properties: {},
-            children: [link2]
+            languages: {
+                plain: plainTextGrammar,
+                plaintext: plainTextGrammar,
+                text: plainTextGrammar,
+                txt: plainTextGrammar,
+                extend: function(id2, redef) {
+                    var lang2 = _2.util.clone(_2.languages[id2]);
+                    for (var key in redef) {
+                        lang2[key] = redef[key];
+                    }
+                    return lang2;
+                },
+                insertBefore: function(inside2, before, insert2, root2) {
+                    root2 = root2 || _2.languages;
+                    var grammar = root2[inside2];
+                    var ret = {};
+                    for (var token in grammar) {
+                        if (grammar.hasOwnProperty(token)) {
+                            if (token == before) {
+                                for (var newToken in insert2) {
+                                    if (insert2.hasOwnProperty(newToken)) {
+                                        ret[newToken] = insert2[newToken];
+                                    }
+                                }
+                            }
+                            if (!insert2.hasOwnProperty(token)) {
+                                ret[token] = grammar[token];
+                            }
+                        }
+                    }
+                    var old = root2[inside2];
+                    root2[inside2] = ret;
+                    _2.languages.DFS(_2.languages, function(key, value) {
+                        if (value === old && key != inside2) {
+                            this[key] = ret;
+                        }
+                    });
+                    return ret;
+                },
+                DFS: function DFS(o2, callback, type2, visited) {
+                    visited = visited || {};
+                    var objId = _2.util.objId;
+                    for (var i2 in o2) {
+                        if (o2.hasOwnProperty(i2)) {
+                            callback.call(o2, i2, o2[i2], type2 || i2);
+                            var property = o2[i2];
+                            var propertyType = _2.util.type(property);
+                            if (propertyType === "Object" && !visited[objId(property)]) {
+                                visited[objId(property)] = true;
+                                DFS(property, callback, null, visited);
+                            } else if (propertyType === "Array" && !visited[objId(property)]) {
+                                visited[objId(property)] = true;
+                                DFS(property, callback, i2, visited);
+                            }
+                        }
+                    }
+                }
+            },
+            plugins: {},
+            highlight: function(text2, grammar, language2) {
+                var env2 = {
+                    code: text2,
+                    grammar,
+                    language: language2
+                };
+                _2.hooks.run("before-tokenize", env2);
+                env2.tokens = _2.tokenize(env2.code, env2.grammar);
+                _2.hooks.run("after-tokenize", env2);
+                return Token.stringify(_2.util.encode(env2.tokens), env2.language);
+            },
+            tokenize: function(text2, grammar) {
+                var rest = grammar.rest;
+                if (rest) {
+                    for (var token in rest) {
+                        grammar[token] = rest[token];
+                    }
+                    delete grammar.rest;
+                }
+                var tokenList = new LinkedList();
+                addAfter(tokenList, tokenList.head, text2);
+                matchGrammar(text2, tokenList, grammar, tokenList.head, 0);
+                return toArray2(tokenList);
+            },
+            hooks: {
+                all: {},
+                add: function(name2, callback) {
+                    var hooks = _2.hooks.all;
+                    hooks[name2] = hooks[name2] || [];
+                    hooks[name2].push(callback);
+                },
+                run: function(name2, env2) {
+                    var callbacks = _2.hooks.all[name2];
+                    if (!callbacks || !callbacks.length) {
+                        return;
+                    }
+                    for (var i2 = 0, callback; callback = callbacks[i2++];) {
+                        callback(env2);
+                    }
+                }
+            },
+            Token
         };
-        state.patch(node2, sup);
-        return state.applyData(node2, sup);
-    }
 
-    function heading$2(state, node2) {
-        const result = {
-            type: "element",
-            tagName: "h" + node2.depth,
-            properties: {},
-            children: state.all(node2)
+        function Token(type2, content2, alias, matchedStr) {
+            this.type = type2;
+            this.content = content2;
+            this.alias = alias;
+            this.length = (matchedStr || "").length | 0;
+        }
+        Token.stringify = function stringify2(o2, language2) {
+            if (typeof o2 == "string") {
+                return o2;
+            }
+            if (Array.isArray(o2)) {
+                var s2 = "";
+                o2.forEach(function(e3) {
+                    s2 += stringify2(e3, language2);
+                });
+                return s2;
+            }
+            var env2 = {
+                type: o2.type,
+                content: stringify2(o2.content, language2),
+                tag: "span",
+                classes: ["token", o2.type],
+                attributes: {},
+                language: language2
+            };
+            var aliases = o2.alias;
+            if (aliases) {
+                if (Array.isArray(aliases)) {
+                    Array.prototype.push.apply(env2.classes, aliases);
+                } else {
+                    env2.classes.push(aliases);
+                }
+            }
+            _2.hooks.run("wrap", env2);
+            var attributes2 = "";
+            for (var name2 in env2.attributes) {
+                attributes2 += " " + name2 + '="' + (env2.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
+            }
+            return "<" + env2.tag + ' class="' + env2.classes.join(" ") + '"' + attributes2 + ">" + env2.content + "</" + env2.tag + ">";
         };
-        state.patch(node2, result);
-        return state.applyData(node2, result);
-    }
 
-    function html$2(state, node2) {
-        if (state.options.allowDangerousHtml) {
-            const result = {
-                type: "raw",
-                value: node2.value
-            };
-            state.patch(node2, result);
-            return state.applyData(node2, result);
+        function matchPattern(pattern, pos, text2, lookbehind) {
+            pattern.lastIndex = pos;
+            var match2 = pattern.exec(text2);
+            if (match2 && lookbehind && match2[1]) {
+                var lookbehindLength = match2[1].length;
+                match2.index += lookbehindLength;
+                match2[0] = match2[0].slice(lookbehindLength);
+            }
+            return match2;
         }
-        return void 0;
-    }
 
-    function revert(state, node2) {
-        const subtype = node2.referenceType;
-        let suffix = "]";
-        if (subtype === "collapsed") {
-            suffix += "[]";
-        } else if (subtype === "full") {
-            suffix += "[" + (node2.label || node2.identifier) + "]";
+        function matchGrammar(text2, tokenList, grammar, startNode, startPos, rematch) {
+            for (var token in grammar) {
+                if (!grammar.hasOwnProperty(token) || !grammar[token]) {
+                    continue;
+                }
+                var patterns2 = grammar[token];
+                patterns2 = Array.isArray(patterns2) ? patterns2 : [patterns2];
+                for (var j2 = 0; j2 < patterns2.length; ++j2) {
+                    if (rematch && rematch.cause == token + "," + j2) {
+                        return;
+                    }
+                    var patternObj = patterns2[j2];
+                    var inside2 = patternObj.inside;
+                    var lookbehind = !!patternObj.lookbehind;
+                    var greedy = !!patternObj.greedy;
+                    var alias = patternObj.alias;
+                    if (greedy && !patternObj.pattern.global) {
+                        var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
+                        patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
+                    }
+                    var pattern = patternObj.pattern || patternObj;
+                    for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
+                        if (rematch && pos >= rematch.reach) {
+                            break;
+                        }
+                        var str = currentNode.value;
+                        if (tokenList.length > text2.length) {
+                            return;
+                        }
+                        if (str instanceof Token) {
+                            continue;
+                        }
+                        var removeCount = 1;
+                        var match2;
+                        if (greedy) {
+                            match2 = matchPattern(pattern, pos, text2, lookbehind);
+                            if (!match2 || match2.index >= text2.length) {
+                                break;
+                            }
+                            var from = match2.index;
+                            var to2 = match2.index + match2[0].length;
+                            var p2 = pos;
+                            p2 += currentNode.value.length;
+                            while (from >= p2) {
+                                currentNode = currentNode.next;
+                                p2 += currentNode.value.length;
+                            }
+                            p2 -= currentNode.value.length;
+                            pos = p2;
+                            if (currentNode.value instanceof Token) {
+                                continue;
+                            }
+                            for (var k2 = currentNode; k2 !== tokenList.tail && (p2 < to2 || typeof k2.value === "string"); k2 = k2.next) {
+                                removeCount++;
+                                p2 += k2.value.length;
+                            }
+                            removeCount--;
+                            str = text2.slice(pos, p2);
+                            match2.index -= pos;
+                        } else {
+                            match2 = matchPattern(pattern, 0, str, lookbehind);
+                            if (!match2) {
+                                continue;
+                            }
+                        }
+                        var from = match2.index;
+                        var matchStr = match2[0];
+                        var before = str.slice(0, from);
+                        var after = str.slice(from + matchStr.length);
+                        var reach = pos + str.length;
+                        if (rematch && reach > rematch.reach) {
+                            rematch.reach = reach;
+                        }
+                        var removeFrom = currentNode.prev;
+                        if (before) {
+                            removeFrom = addAfter(tokenList, removeFrom, before);
+                            pos += before.length;
+                        }
+                        removeRange(tokenList, removeFrom, removeCount);
+                        var wrapped = new Token(token, inside2 ? _2.tokenize(matchStr, inside2) : matchStr, alias, matchStr);
+                        currentNode = addAfter(tokenList, removeFrom, wrapped);
+                        if (after) {
+                            addAfter(tokenList, currentNode, after);
+                        }
+                        if (removeCount > 1) {
+                            var nestedRematch = {
+                                cause: token + "," + j2,
+                                reach
+                            };
+                            matchGrammar(text2, tokenList, grammar, currentNode.prev, pos, nestedRematch);
+                            if (rematch && nestedRematch.reach > rematch.reach) {
+                                rematch.reach = nestedRematch.reach;
+                            }
+                        }
+                    }
+                }
+            }
         }
-        if (node2.type === "imageReference") {
-            return [{
-                type: "text",
-                value: "![" + node2.alt + suffix
-            }];
+
+        function LinkedList() {
+            var head = {
+                value: null,
+                prev: null,
+                next: null
+            };
+            var tail = {
+                value: null,
+                prev: head,
+                next: null
+            };
+            head.next = tail;
+            this.head = head;
+            this.tail = tail;
+            this.length = 0;
         }
-        const contents = state.all(node2);
-        const head = contents[0];
-        if (head && head.type === "text") {
-            head.value = "[" + head.value;
-        } else {
-            contents.unshift({
-                type: "text",
-                value: "["
-            });
+
+        function addAfter(list2, node2, value) {
+            var next2 = node2.next;
+            var newNode = {
+                value,
+                prev: node2,
+                next: next2
+            };
+            node2.next = newNode;
+            next2.prev = newNode;
+            list2.length++;
+            return newNode;
         }
-        const tail = contents[contents.length - 1];
-        if (tail && tail.type === "text") {
-            tail.value += suffix;
-        } else {
-            contents.push({
-                type: "text",
-                value: suffix
-            });
+
+        function removeRange(list2, node2, count2) {
+            var next2 = node2.next;
+            for (var i2 = 0; i2 < count2 && next2 !== list2.tail; i2++) {
+                next2 = next2.next;
+            }
+            node2.next = next2;
+            next2.prev = node2;
+            list2.length -= i2;
         }
-        return contents;
-    }
 
-    function imageReference$1(state, node2) {
-        const id2 = String(node2.identifier).toUpperCase();
-        const def = state.definitionById.get(id2);
-        if (!def) {
-            return revert(state, node2);
+        function toArray2(list2) {
+            var array2 = [];
+            var node2 = list2.head.next;
+            while (node2 !== list2.tail) {
+                array2.push(node2.value);
+                node2 = node2.next;
+            }
+            return array2;
         }
-        const properties = {
-            src: normalizeUri(def.url || ""),
-            alt: node2.alt
-        };
-        if (def.title !== null && def.title !== void 0) {
-            properties.title = def.title;
+        return _2;
+    }();
+    var prism = Prism;
+    Prism.default = Prism;
+    prism.languages.markup = {
+        "comment": {
+            pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
+            greedy: true
+        },
+        "prolog": {
+            pattern: /<\?[\s\S]+?\?>/,
+            greedy: true
+        },
+        "doctype": {
+            pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
+            greedy: true,
+            inside: {
+                "internal-subset": {
+                    pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
+                    lookbehind: true,
+                    greedy: true,
+                    inside: null
+                },
+                "string": {
+                    pattern: /"[^"]*"|'[^']*'/,
+                    greedy: true
+                },
+                "punctuation": /^<!|>$|[[\]]/,
+                "doctype-tag": /^DOCTYPE/i,
+                "name": /[^\s<>'"]+/
+            }
+        },
+        "cdata": {
+            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
+            greedy: true
+        },
+        "tag": {
+            pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
+            greedy: true,
+            inside: {
+                "tag": {
+                    pattern: /^<\/?[^\s>\/]+/,
+                    inside: {
+                        "punctuation": /^<\/?/,
+                        "namespace": /^[^\s>\/:]+:/
+                    }
+                },
+                "special-attr": [],
+                "attr-value": {
+                    pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
+                    inside: {
+                        "punctuation": [{
+                            pattern: /^=/,
+                            alias: "attr-equals"
+                        }, /"|'/]
+                    }
+                },
+                "punctuation": /\/?>/,
+                "attr-name": {
+                    pattern: /[^\s>\/]+/,
+                    inside: {
+                        "namespace": /^[^\s>\/:]+:/
+                    }
+                }
+            }
+        },
+        "entity": [{
+            pattern: /&[\da-z]{1,8};/i,
+            alias: "named-entity"
+        }, /&#x?[\da-f]{1,8};/i]
+    };
+    prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = prism.languages.markup["entity"];
+    prism.languages.markup["doctype"].inside["internal-subset"].inside = prism.languages.markup;
+    prism.hooks.add("wrap", function(env2) {
+        if (env2.type === "entity") {
+            env2.attributes["title"] = env2.content.replace(/&amp;/, "&");
         }
-        const result = {
-            type: "element",
-            tagName: "img",
-            properties,
-            children: []
-        };
-        state.patch(node2, result);
-        return state.applyData(node2, result);
-    }
-
-    function image$1(state, node2) {
-        const properties = {
-            src: normalizeUri(node2.url)
-        };
-        if (node2.alt !== null && node2.alt !== void 0) {
-            properties.alt = node2.alt;
+    });
+    Object.defineProperty(prism.languages.markup.tag, "addInlined", {
+        value: function addInlined(tagName, lang) {
+            var includedCdataInside = {};
+            includedCdataInside["language-" + lang] = {
+                pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
+                lookbehind: true,
+                inside: prism.languages[lang]
+            };
+            includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
+            var inside2 = {
+                "included-cdata": {
+                    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
+                    inside: includedCdataInside
+                }
+            };
+            inside2["language-" + lang] = {
+                pattern: /[\s\S]+/,
+                inside: prism.languages[lang]
+            };
+            var def = {};
+            def[tagName] = {
+                pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
+                    return tagName;
+                }), "i"),
+                lookbehind: true,
+                greedy: true,
+                inside: inside2
+            };
+            prism.languages.insertBefore("markup", "cdata", def);
         }
-        if (node2.title !== null && node2.title !== void 0) {
-            properties.title = node2.title;
+    });
+    Object.defineProperty(prism.languages.markup.tag, "addAttribute", {
+        value: function(attrName, lang) {
+            prism.languages.markup.tag.inside["special-attr"].push({
+                pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
+                lookbehind: true,
+                inside: {
+                    "attr-name": /^[^\s=]+/,
+                    "attr-value": {
+                        pattern: /=[\s\S]+/,
+                        inside: {
+                            "value": {
+                                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
+                                lookbehind: true,
+                                alias: [lang, "language-" + lang],
+                                inside: prism.languages[lang]
+                            },
+                            "punctuation": [{
+                                pattern: /^=/,
+                                alias: "attr-equals"
+                            }, /"|'/]
+                        }
+                    }
+                }
+            });
         }
-        const result = {
-            type: "element",
-            tagName: "img",
-            properties,
-            children: []
+    });
+    prism.languages.html = prism.languages.markup;
+    prism.languages.mathml = prism.languages.markup;
+    prism.languages.svg = prism.languages.markup;
+    prism.languages.xml = prism.languages.extend("markup", {});
+    prism.languages.ssml = prism.languages.xml;
+    prism.languages.atom = prism.languages.xml;
+    prism.languages.rss = prism.languages.xml;
+    (function(Prism2) {
+        var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
+        var commandAfterHeredoc = {
+            pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
+            lookbehind: true,
+            alias: "punctuation",
+            inside: null
         };
-        state.patch(node2, result);
-        return state.applyData(node2, result);
-    }
-
-    function inlineCode$1(state, node2) {
-        const text2 = {
-            type: "text",
-            value: node2.value.replace(/\r?\n|\r/g, " ")
+        var insideString = {
+            "bash": commandAfterHeredoc,
+            "environment": {
+                pattern: RegExp("\\$" + envVars),
+                alias: "constant"
+            },
+            "variable": [{
+                    pattern: /\$?\(\([\s\S]+?\)\)/,
+                    greedy: true,
+                    inside: {
+                        "variable": [{
+                            pattern: /(^\$\(\([\s\S]+)\)\)/,
+                            lookbehind: true
+                        }, /^\$\(\(/],
+                        "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
+                        "operator": /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
+                        "punctuation": /\(\(?|\)\)?|,|;/
+                    }
+                }, {
+                    pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
+                    greedy: true,
+                    inside: {
+                        "variable": /^\$\(|^`|\)$|`$/
+                    }
+                }, {
+                    pattern: /\$\{[^}]+\}/,
+                    greedy: true,
+                    inside: {
+                        "operator": /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
+                        "punctuation": /[\[\]]/,
+                        "environment": {
+                            pattern: RegExp("(\\{)" + envVars),
+                            lookbehind: true,
+                            alias: "constant"
+                        }
+                    }
+                },
+                /\$(?:\w+|[#?*!@$])/
+            ],
+            "entity": /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
         };
-        state.patch(node2, text2);
-        const result = {
-            type: "element",
-            tagName: "code",
-            properties: {},
-            children: [text2]
+        Prism2.languages.bash = {
+            "shebang": {
+                pattern: /^#!\s*\/.*/,
+                alias: "important"
+            },
+            "comment": {
+                pattern: /(^|[^"{\\$])#.*/,
+                lookbehind: true
+            },
+            "function-name": [{
+                pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
+                lookbehind: true,
+                alias: "function"
+            }, {
+                pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
+                alias: "function"
+            }],
+            "for-or-select": {
+                pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
+                alias: "variable",
+                lookbehind: true
+            },
+            "assign-left": {
+                pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,
+                inside: {
+                    "environment": {
+                        pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
+                        lookbehind: true,
+                        alias: "constant"
+                    }
+                },
+                alias: "variable",
+                lookbehind: true
+            },
+            "string": [{
+                pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
+                lookbehind: true,
+                greedy: true,
+                inside: insideString
+            }, {
+                pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
+                lookbehind: true,
+                greedy: true,
+                inside: {
+                    "bash": commandAfterHeredoc
+                }
+            }, {
+                pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
+                lookbehind: true,
+                greedy: true,
+                inside: insideString
+            }, {
+                pattern: /(^|[^$\\])'[^']*'/,
+                lookbehind: true,
+                greedy: true
+            }, {
+                pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
+                greedy: true,
+                inside: {
+                    "entity": insideString.entity
+                }
+            }],
+            "environment": {
+                pattern: RegExp("\\$?" + envVars),
+                alias: "constant"
+            },
+            "variable": insideString.variable,
+            "function": {
+                pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
+                lookbehind: true
+            },
+            "keyword": {
+                pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
+                lookbehind: true
+            },
+            "builtin": {
+                pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
+                lookbehind: true,
+                alias: "class-name"
+            },
+            "boolean": {
+                pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
+                lookbehind: true
+            },
+            "file-descriptor": {
+                pattern: /\B&\d\b/,
+                alias: "important"
+            },
+            "operator": {
+                pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
+                inside: {
+                    "file-descriptor": {
+                        pattern: /^\d/,
+                        alias: "important"
+                    }
+                }
+            },
+            "punctuation": /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
+            "number": {
+                pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
+                lookbehind: true
+            }
         };
-        state.patch(node2, result);
-        return state.applyData(node2, result);
-    }
-
-    function linkReference$1(state, node2) {
-        const id2 = String(node2.identifier).toUpperCase();
-        const def = state.definitionById.get(id2);
-        if (!def) {
-            return revert(state, node2);
+        commandAfterHeredoc.inside = Prism2.languages.bash;
+        var toBeCopied = ["comment", "function-name", "for-or-select", "assign-left", "string", "environment", "function", "keyword", "builtin", "boolean", "file-descriptor", "operator", "punctuation", "number"];
+        var inside2 = insideString.variable[1].inside;
+        for (var i2 = 0; i2 < toBeCopied.length; i2++) {
+            inside2[toBeCopied[i2]] = Prism2.languages.bash[toBeCopied[i2]];
         }
-        const properties = {
-            href: normalizeUri(def.url || "")
-        };
-        if (def.title !== null && def.title !== void 0) {
-            properties.title = def.title;
+        Prism2.languages.shell = Prism2.languages.bash;
+    })(prism);
+    prism.languages.clike = {
+        "comment": [{
+            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
+            lookbehind: true,
+            greedy: true
+        }, {
+            pattern: /(^|[^\\:])\/\/.*/,
+            lookbehind: true,
+            greedy: true
+        }],
+        "string": {
+            pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
+            greedy: true
+        },
+        "class-name": {
+            pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
+            lookbehind: true,
+            inside: {
+                "punctuation": /[.\\]/
+            }
+        },
+        "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
+        "boolean": /\b(?:false|true)\b/,
+        "function": /\b\w+(?=\()/,
+        "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
+        "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
+        "punctuation": /[{}[\];(),.:]/
+    };
+    prism.languages.c = prism.languages.extend("clike", {
+        "comment": {
+            pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
+            greedy: true
+        },
+        "string": {
+            pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
+            greedy: true
+        },
+        "class-name": {
+            pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
+            lookbehind: true
+        },
+        "keyword": /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
+        "function": /\b[a-z_]\w*(?=\s*\()/i,
+        "number": /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
+        "operator": />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
+    });
+    prism.languages.insertBefore("c", "string", {
+        "char": {
+            pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
+            greedy: true
         }
-        const result = {
-            type: "element",
-            tagName: "a",
-            properties,
-            children: state.all(node2)
-        };
-        state.patch(node2, result);
-        return state.applyData(node2, result);
-    }
-
-    function link$2(state, node2) {
-        const properties = {
-            href: normalizeUri(node2.url)
-        };
-        if (node2.title !== null && node2.title !== void 0) {
-            properties.title = node2.title;
+    });
+    prism.languages.insertBefore("c", "string", {
+        "macro": {
+            pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
+            lookbehind: true,
+            greedy: true,
+            alias: "property",
+            inside: {
+                "string": [{
+                    pattern: /^(#\s*include\s*)<[^>]+>/,
+                    lookbehind: true
+                }, prism.languages.c["string"]],
+                "char": prism.languages.c["char"],
+                "comment": prism.languages.c["comment"],
+                "macro-name": [{
+                    pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
+                    lookbehind: true
+                }, {
+                    pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
+                    lookbehind: true,
+                    alias: "function"
+                }],
+                "directive": {
+                    pattern: /^(#\s*)[a-z]+/,
+                    lookbehind: true,
+                    alias: "keyword"
+                },
+                "directive-hash": /^#/,
+                "punctuation": /##|\\(?=[\r\n])/,
+                "expression": {
+                    pattern: /\S[\s\S]*/,
+                    inside: prism.languages.c
+                }
+            }
         }
-        const result = {
-            type: "element",
-            tagName: "a",
-            properties,
-            children: state.all(node2)
-        };
-        state.patch(node2, result);
-        return state.applyData(node2, result);
-    }
-
-    function listItem$1(state, node2, parent) {
-        const results = state.all(node2);
-        const loose = parent ? listLoose(parent) : listItemLoose(node2);
-        const properties = {};
-        const children2 = [];
-        if (typeof node2.checked === "boolean") {
-            const head = results[0];
-            let paragraph2;
-            if (head && head.type === "element" && head.tagName === "p") {
-                paragraph2 = head;
-            } else {
-                paragraph2 = {
-                    type: "element",
-                    tagName: "p",
-                    properties: {},
-                    children: []
-                };
-                results.unshift(paragraph2);
+    });
+    prism.languages.insertBefore("c", "function", {
+        "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
+    });
+    delete prism.languages.c["boolean"];
+    (function(Prism2) {
+        var keyword2 = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
+        var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
+            return keyword2.source;
+        });
+        Prism2.languages.cpp = Prism2.languages.extend("c", {
+            "class-name": [{
+                    pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
+                        return keyword2.source;
+                    })),
+                    lookbehind: true
+                },
+                /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
+                /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
+                /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
+            ],
+            "keyword": keyword2,
+            "number": {
+                pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
+                greedy: true
+            },
+            "operator": />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
+            "boolean": /\b(?:false|true)\b/
+        });
+        Prism2.languages.insertBefore("cpp", "string", {
+            "module": {
+                pattern: RegExp(/(\b(?:import|module)\s+)/.source + "(?:" + /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
+                    return modName;
+                }) + ")"),
+                lookbehind: true,
+                greedy: true,
+                inside: {
+                    "string": /^[<"][\s\S]+/,
+                    "operator": /:/,
+                    "punctuation": /\./
+                }
+            },
+            "raw-string": {
+                pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
+                alias: "string",
+                greedy: true
             }
-            if (paragraph2.children.length > 0) {
-                paragraph2.children.unshift({
-                    type: "text",
-                    value: " "
-                });
+        });
+        Prism2.languages.insertBefore("cpp", "keyword", {
+            "generic-function": {
+                pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
+                inside: {
+                    "function": /^\w+/,
+                    "generic": {
+                        pattern: /<[\s\S]+/,
+                        alias: "class-name",
+                        inside: Prism2.languages.cpp
+                    }
+                }
             }
-            paragraph2.children.unshift({
-                type: "element",
-                tagName: "input",
-                properties: {
-                    type: "checkbox",
-                    checked: node2.checked,
-                    disabled: true
-                },
-                children: []
-            });
-            properties.className = ["task-list-item"];
-        }
-        let index2 = -1;
-        while (++index2 < results.length) {
-            const child = results[index2];
-            if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
-                children2.push({
-                    type: "text",
-                    value: "\n"
-                });
+        });
+        Prism2.languages.insertBefore("cpp", "operator", {
+            "double-colon": {
+                pattern: /::/,
+                alias: "punctuation"
             }
-            if (child.type === "element" && child.tagName === "p" && !loose) {
-                children2.push(...child.children);
-            } else {
-                children2.push(child);
+        });
+        Prism2.languages.insertBefore("cpp", "class-name", {
+            "base-clause": {
+                pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
+                lookbehind: true,
+                greedy: true,
+                inside: Prism2.languages.extend("cpp", {})
             }
-        }
-        const tail = results[results.length - 1];
-        if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
-            children2.push({
-                type: "text",
-                value: "\n"
-            });
-        }
-        const result = {
-            type: "element",
-            tagName: "li",
-            properties,
-            children: children2
+        });
+        Prism2.languages.insertBefore("inside", "double-colon", {
+            "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
+        }, Prism2.languages.cpp["base-clause"]);
+    })(prism);
+    (function(Prism2) {
+        var string2 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
+        Prism2.languages.css = {
+            "comment": /\/\*[\s\S]*?\*\//,
+            "atrule": {
+                pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
+                inside: {
+                    "rule": /^@[\w-]+/,
+                    "selector-function-argument": {
+                        pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
+                        lookbehind: true,
+                        alias: "selector"
+                    },
+                    "keyword": {
+                        pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
+                        lookbehind: true
+                    }
+                }
+            },
+            "url": {
+                pattern: RegExp("\\burl\\((?:" + string2.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
+                greedy: true,
+                inside: {
+                    "function": /^url/i,
+                    "punctuation": /^\(|\)$/,
+                    "string": {
+                        pattern: RegExp("^" + string2.source + "$"),
+                        alias: "url"
+                    }
+                }
+            },
+            "selector": {
+                pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string2.source + ")*(?=\\s*\\{)"),
+                lookbehind: true
+            },
+            "string": {
+                pattern: string2,
+                greedy: true
+            },
+            "property": {
+                pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
+                lookbehind: true
+            },
+            "important": /!important\b/i,
+            "function": {
+                pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
+                lookbehind: true
+            },
+            "punctuation": /[(){};:,]/
         };
-        state.patch(node2, result);
-        return state.applyData(node2, result);
-    }
-
-    function listLoose(node2) {
-        let loose = false;
-        if (node2.type === "list") {
-            loose = node2.spread || false;
-            const children2 = node2.children;
-            let index2 = -1;
-            while (!loose && ++index2 < children2.length) {
-                loose = listItemLoose(children2[index2]);
-            }
-        }
-        return loose;
-    }
-
-    function listItemLoose(node2) {
-        const spread = node2.spread;
-        return spread === null || spread === void 0 ? node2.children.length > 1 : spread;
-    }
-
-    function list$1(state, node2) {
-        const properties = {};
-        const results = state.all(node2);
-        let index2 = -1;
-        if (typeof node2.start === "number" && node2.start !== 1) {
-            properties.start = node2.start;
+        Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
+        var markup = Prism2.languages.markup;
+        if (markup) {
+            markup.tag.addInlined("style", "css");
+            markup.tag.addAttribute("style", "css");
         }
-        while (++index2 < results.length) {
-            const child = results[index2];
-            if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
-                properties.className = ["contains-task-list"];
-                break;
+    })(prism);
+    (function(Prism2) {
+        var string2 = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
+        var selectorInside;
+        Prism2.languages.css.selector = {
+            pattern: Prism2.languages.css.selector.pattern,
+            lookbehind: true,
+            inside: selectorInside = {
+                "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,
+                "pseudo-class": /:[-\w]+/,
+                "class": /\.[-\w]+/,
+                "id": /#[-\w]+/,
+                "attribute": {
+                    pattern: RegExp(`\\[(?:[^[\\]"']|` + string2.source + ")*\\]"),
+                    greedy: true,
+                    inside: {
+                        "punctuation": /^\[|\]$/,
+                        "case-sensitivity": {
+                            pattern: /(\s)[si]$/i,
+                            lookbehind: true,
+                            alias: "keyword"
+                        },
+                        "namespace": {
+                            pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/,
+                            lookbehind: true,
+                            inside: {
+                                "punctuation": /\|$/
+                            }
+                        },
+                        "attr-name": {
+                            pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/,
+                            lookbehind: true
+                        },
+                        "attr-value": [string2, {
+                            pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/,
+                            lookbehind: true
+                        }],
+                        "operator": /[|~*^$]?=/
+                    }
+                },
+                "n-th": [{
+                    pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/,
+                    lookbehind: true,
+                    inside: {
+                        "number": /[\dn]+/,
+                        "operator": /[+-]/
+                    }
+                }, {
+                    pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i,
+                    lookbehind: true
+                }],
+                "combinator": />|\+|~|\|\|/,
+                "punctuation": /[(),]/
             }
-        }
-        const result = {
-            type: "element",
-            tagName: node2.ordered ? "ol" : "ul",
-            properties,
-            children: state.wrap(results, true)
-        };
-        state.patch(node2, result);
-        return state.applyData(node2, result);
-    }
-
-    function paragraph$1(state, node2) {
-        const result = {
-            type: "element",
-            tagName: "p",
-            properties: {},
-            children: state.all(node2)
-        };
-        state.patch(node2, result);
-        return state.applyData(node2, result);
-    }
-
-    function root$3(state, node2) {
-        const result = {
-            type: "root",
-            children: state.wrap(state.all(node2))
         };
-        state.patch(node2, result);
-        return state.applyData(node2, result);
-    }
-
-    function strong$1(state, node2) {
-        const result = {
-            type: "element",
-            tagName: "strong",
-            properties: {},
-            children: state.all(node2)
+        Prism2.languages.css["atrule"].inside["selector-function-argument"].inside = selectorInside;
+        Prism2.languages.insertBefore("css", "property", {
+            "variable": {
+                pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i,
+                lookbehind: true
+            }
+        });
+        var unit = {
+            pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/,
+            lookbehind: true
         };
-        state.patch(node2, result);
-        return state.applyData(node2, result);
-    }
-
-    function table(state, node2) {
-        const rows = state.all(node2);
-        const firstRow = rows.shift();
-        const tableContent = [];
-        if (firstRow) {
-            const head = {
-                type: "element",
-                tagName: "thead",
-                properties: {},
-                children: state.wrap([firstRow], true)
-            };
-            state.patch(node2.children[0], head);
-            tableContent.push(head);
-        }
-        if (rows.length > 0) {
-            const body = {
-                type: "element",
-                tagName: "tbody",
-                properties: {},
-                children: state.wrap(rows, true)
-            };
-            const start2 = pointStart$1(node2.children[1]);
-            const end2 = pointEnd$1(node2.children[node2.children.length - 1]);
-            if (start2 && end2)
-                body.position = {
-                    start: start2,
-                    end: end2
-                };
-            tableContent.push(body);
-        }
-        const result = {
-            type: "element",
-            tagName: "table",
-            properties: {},
-            children: state.wrap(tableContent, true)
+        var number2 = {
+            pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
+            lookbehind: true
         };
-        state.patch(node2, result);
-        return state.applyData(node2, result);
-    }
-
-    function tableRow(state, node2, parent) {
-        const siblings = parent ? parent.children : void 0;
-        const rowIndex = siblings ? siblings.indexOf(node2) : 1;
-        const tagName = rowIndex === 0 ? "th" : "td";
-        const align = parent && parent.type === "table" ? parent.align : void 0;
-        const length = align ? align.length : node2.children.length;
-        let cellIndex = -1;
-        const cells2 = [];
-        while (++cellIndex < length) {
-            const cell = node2.children[cellIndex];
-            const properties = {};
-            const alignValue = align ? align[cellIndex] : void 0;
-            if (alignValue) {
-                properties.align = alignValue;
+        Prism2.languages.insertBefore("css", "function", {
+            "operator": {
+                pattern: /(\s)[+\-*\/](?=\s)/,
+                lookbehind: true
+            },
+            "hexcode": {
+                pattern: /\B#[\da-f]{3,8}\b/i,
+                alias: "color"
+            },
+            "color": [{
+                pattern: /(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i,
+                lookbehind: true
+            }, {
+                pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
+                inside: {
+                    "unit": unit,
+                    "number": number2,
+                    "function": /[\w-]+(?=\()/,
+                    "punctuation": /[(),]/
+                }
+            }],
+            "entity": /\\[\da-f]{1,8}/i,
+            "unit": unit,
+            "number": number2
+        });
+    })(prism);
+    prism.languages.javascript = prism.languages.extend("clike", {
+        "class-name": [prism.languages.clike["class-name"], {
+            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
+            lookbehind: true
+        }],
+        "keyword": [{
+            pattern: /((?:^|\})\s*)catch\b/,
+            lookbehind: true
+        }, {
+            pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
+            lookbehind: true
+        }],
+        "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
+        "number": {
+            pattern: RegExp(/(^|[^\w$])/.source + "(?:" + (/NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
+            lookbehind: true
+        },
+        "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
+    });
+    prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
+    prism.languages.insertBefore("javascript", "keyword", {
+        "regex": {
+            pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
+            lookbehind: true,
+            greedy: true,
+            inside: {
+                "regex-source": {
+                    pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
+                    lookbehind: true,
+                    alias: "language-regex",
+                    inside: prism.languages.regex
+                },
+                "regex-delimiter": /^\/|\/$/,
+                "regex-flags": /^[a-z]+$/
             }
-            let result2 = {
-                type: "element",
-                tagName,
-                properties,
-                children: []
-            };
-            if (cell) {
-                result2.children = state.all(cell);
-                state.patch(cell, result2);
-                result2 = state.applyData(cell, result2);
+        },
+        "function-variable": {
+            pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
+            alias: "function"
+        },
+        "parameter": [{
+            pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
+            lookbehind: true,
+            inside: prism.languages.javascript
+        }, {
+            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
+            lookbehind: true,
+            inside: prism.languages.javascript
+        }, {
+            pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
+            lookbehind: true,
+            inside: prism.languages.javascript
+        }, {
+            pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
+            lookbehind: true,
+            inside: prism.languages.javascript
+        }],
+        "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
+    });
+    prism.languages.insertBefore("javascript", "string", {
+        "hashbang": {
+            pattern: /^#!.*/,
+            greedy: true,
+            alias: "comment"
+        },
+        "template-string": {
+            pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
+            greedy: true,
+            inside: {
+                "template-punctuation": {
+                    pattern: /^`|`$/,
+                    alias: "string"
+                },
+                "interpolation": {
+                    pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
+                    lookbehind: true,
+                    inside: {
+                        "interpolation-punctuation": {
+                            pattern: /^\$\{|\}$/,
+                            alias: "punctuation"
+                        },
+                        rest: prism.languages.javascript
+                    }
+                },
+                "string": /[\s\S]+/
             }
-            cells2.push(result2);
+        },
+        "string-property": {
+            pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
+            lookbehind: true,
+            greedy: true,
+            alias: "property"
         }
-        const result = {
-            type: "element",
-            tagName: "tr",
-            properties: {},
-            children: state.wrap(cells2, true)
-        };
-        state.patch(node2, result);
-        return state.applyData(node2, result);
-    }
-
-    function tableCell(state, node2) {
-        const result = {
-            type: "element",
-            tagName: "td",
-            properties: {},
-            children: state.all(node2)
-        };
-        state.patch(node2, result);
-        return state.applyData(node2, result);
-    }
-    const tab$1 = 9;
-    const space$1 = 32;
-
-    function trimLines(value) {
-        const source = String(value);
-        const search2 = /\r?\n|\r/g;
-        let match2 = search2.exec(source);
-        let last = 0;
-        const lines = [];
-        while (match2) {
-            lines.push(
-                trimLine(source.slice(last, match2.index), last > 0, true),
-                match2[0]
-            );
-            last = match2.index + match2[0].length;
-            match2 = search2.exec(source);
+    });
+    prism.languages.insertBefore("javascript", "operator", {
+        "literal-property": {
+            pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
+            lookbehind: true,
+            alias: "property"
         }
-        lines.push(trimLine(source.slice(last), last > 0, false));
-        return lines.join("");
+    });
+    if (prism.languages.markup) {
+        prism.languages.markup.tag.addInlined("script", "javascript");
+        prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
     }
-
-    function trimLine(value, start2, end2) {
-        let startIndex = 0;
-        let endIndex = value.length;
-        if (start2) {
-            let code2 = value.codePointAt(startIndex);
-            while (code2 === tab$1 || code2 === space$1) {
-                startIndex++;
-                code2 = value.codePointAt(startIndex);
+    prism.languages.js = prism.languages.javascript;
+    (function(Prism2) {
+        var comment2 = /#(?!\{).+/;
+        var interpolation = {
+            pattern: /#\{[^}]+\}/,
+            alias: "variable"
+        };
+        Prism2.languages.coffeescript = Prism2.languages.extend("javascript", {
+            "comment": comment2,
+            "string": [{
+                pattern: /'(?:\\[\s\S]|[^\\'])*'/,
+                greedy: true
+            }, {
+                pattern: /"(?:\\[\s\S]|[^\\"])*"/,
+                greedy: true,
+                inside: {
+                    "interpolation": interpolation
+                }
+            }],
+            "keyword": /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
+            "class-member": {
+                pattern: /@(?!\d)\w+/,
+                alias: "variable"
             }
-        }
-        if (end2) {
-            let code2 = value.codePointAt(endIndex - 1);
-            while (code2 === tab$1 || code2 === space$1) {
-                endIndex--;
-                code2 = value.codePointAt(endIndex - 1);
+        });
+        Prism2.languages.insertBefore("coffeescript", "comment", {
+            "multiline-comment": {
+                pattern: /###[\s\S]+?###/,
+                alias: "comment"
+            },
+            "block-regex": {
+                pattern: /\/{3}[\s\S]*?\/{3}/,
+                alias: "regex",
+                inside: {
+                    "comment": comment2,
+                    "interpolation": interpolation
+                }
             }
-        }
-        return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
-    }
-
-    function text$3(state, node2) {
-        const result = {
-            type: "text",
-            value: trimLines(String(node2.value))
-        };
-        state.patch(node2, result);
-        return state.applyData(node2, result);
-    }
+        });
+        Prism2.languages.insertBefore("coffeescript", "string", {
+            "inline-javascript": {
+                pattern: /`(?:\\[\s\S]|[^\\`])*`/,
+                inside: {
+                    "delimiter": {
+                        pattern: /^`|`$/,
+                        alias: "punctuation"
+                    },
+                    "script": {
+                        pattern: /[\s\S]+/,
+                        alias: "language-javascript",
+                        inside: Prism2.languages.javascript
+                    }
+                }
+            },
+            "multiline-string": [{
+                pattern: /'''[\s\S]*?'''/,
+                greedy: true,
+                alias: "string"
+            }, {
+                pattern: /"""[\s\S]*?"""/,
+                greedy: true,
+                alias: "string",
+                inside: {
+                    interpolation
+                }
+            }]
+        });
+        Prism2.languages.insertBefore("coffeescript", "keyword", {
+            "property": /(?!\d)\w+(?=\s*:(?!:))/
+        });
+        delete Prism2.languages.coffeescript["template-string"];
+        Prism2.languages.coffee = Prism2.languages.coffeescript;
+    })(prism);
+    (function(Prism2) {
+        var anchorOrAlias = /[*&][^\s[\]{},]+/;
+        var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
+        var properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)";
+        var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
+            return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
+        });
+        var string2 = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
 
-    function thematicBreak$1(state, node2) {
-        const result = {
-            type: "element",
-            tagName: "hr",
-            properties: {},
-            children: []
+        function createValuePattern(value, flags) {
+            flags = (flags || "").replace(/m/g, "") + "m";
+            var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
+                return properties;
+            }).replace(/<<value>>/g, function() {
+                return value;
+            });
+            return RegExp(pattern, flags);
+        }
+        Prism2.languages.yaml = {
+            "scalar": {
+                pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
+                    return properties;
+                })),
+                lookbehind: true,
+                alias: "string"
+            },
+            "comment": /#.*/,
+            "key": {
+                pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
+                    return properties;
+                }).replace(/<<key>>/g, function() {
+                    return "(?:" + plainKey + "|" + string2 + ")";
+                })),
+                lookbehind: true,
+                greedy: true,
+                alias: "atrule"
+            },
+            "directive": {
+                pattern: /(^[ \t]*)%.+/m,
+                lookbehind: true,
+                alias: "important"
+            },
+            "datetime": {
+                pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
+                lookbehind: true,
+                alias: "number"
+            },
+            "boolean": {
+                pattern: createValuePattern(/false|true/.source, "i"),
+                lookbehind: true,
+                alias: "important"
+            },
+            "null": {
+                pattern: createValuePattern(/null|~/.source, "i"),
+                lookbehind: true,
+                alias: "important"
+            },
+            "string": {
+                pattern: createValuePattern(string2),
+                lookbehind: true,
+                greedy: true
+            },
+            "number": {
+                pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
+                lookbehind: true
+            },
+            "tag": tag,
+            "important": anchorOrAlias,
+            "punctuation": /---|[:[\]{}\-,|>?]|\.\.\./
         };
-        state.patch(node2, result);
-        return state.applyData(node2, result);
-    }
-    const handlers$1 = {
-        blockquote: blockquote$1,
-        break: hardBreak$1,
-        code: code$3,
-        delete: strikethrough,
-        emphasis: emphasis$1,
-        footnoteReference: footnoteReference$1,
-        heading: heading$2,
-        html: html$2,
-        imageReference: imageReference$1,
-        image: image$1,
-        inlineCode: inlineCode$1,
-        linkReference: linkReference$1,
-        link: link$2,
-        listItem: listItem$1,
-        list: list$1,
-        paragraph: paragraph$1,
-        root: root$3,
-        strong: strong$1,
-        table,
-        tableCell,
-        tableRow,
-        text: text$3,
-        thematicBreak: thematicBreak$1,
-        toml: ignore,
-        yaml: ignore,
-        definition: ignore,
-        footnoteDefinition: ignore
-    };
+        Prism2.languages.yml = Prism2.languages.yaml;
+    })(prism);
+    (function(Prism2) {
+        var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
 
-    function ignore() {
-        return void 0;
-    }
-    const VOID = -1;
-    const PRIMITIVE = 0;
-    const ARRAY = 1;
-    const OBJECT = 2;
-    const DATE = 3;
-    const REGEXP = 4;
-    const MAP = 5;
-    const SET$1 = 6;
-    const ERROR = 7;
-    const BIGINT = 8;
-    const env = typeof self === "object" ? self : globalThis;
-    const deserializer = ($2, _2) => {
-        const as = (out, index2) => {
-            $2.set(index2, out);
-            return out;
-        };
-        const unpair = (index2) => {
-            if ($2.has(index2))
-                return $2.get(index2);
-            const [type2, value] = _2[index2];
-            switch (type2) {
-                case PRIMITIVE:
-                case VOID:
-                    return as(value, index2);
-                case ARRAY: {
-                    const arr = as([], index2);
-                    for (const index3 of value)
-                        arr.push(unpair(index3));
-                    return arr;
+        function createInline(pattern) {
+            pattern = pattern.replace(/<inner>/g, function() {
+                return inner;
+            });
+            return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
+        }
+        var tableCell2 = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
+        var tableRow2 = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
+            return tableCell2;
+        });
+        var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
+        Prism2.languages.markdown = Prism2.languages.extend("markup", {});
+        Prism2.languages.insertBefore("markdown", "prolog", {
+            "front-matter-block": {
+                pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
+                lookbehind: true,
+                greedy: true,
+                inside: {
+                    "punctuation": /^---|---$/,
+                    "front-matter": {
+                        pattern: /\S+(?:\s+\S+)*/,
+                        alias: ["yaml", "language-yaml"],
+                        inside: Prism2.languages.yaml
+                    }
                 }
-                case OBJECT: {
-                    const object2 = as({}, index2);
-                    for (const [key, index3] of value)
-                        object2[unpair(key)] = unpair(index3);
-                    return object2;
+            },
+            "blockquote": {
+                pattern: /^>(?:[\t ]*>)*/m,
+                alias: "punctuation"
+            },
+            "table": {
+                pattern: RegExp("^" + tableRow2 + tableLine + "(?:" + tableRow2 + ")*", "m"),
+                inside: {
+                    "table-data-rows": {
+                        pattern: RegExp("^(" + tableRow2 + tableLine + ")(?:" + tableRow2 + ")*$"),
+                        lookbehind: true,
+                        inside: {
+                            "table-data": {
+                                pattern: RegExp(tableCell2),
+                                inside: Prism2.languages.markdown
+                            },
+                            "punctuation": /\|/
+                        }
+                    },
+                    "table-line": {
+                        pattern: RegExp("^(" + tableRow2 + ")" + tableLine + "$"),
+                        lookbehind: true,
+                        inside: {
+                            "punctuation": /\||:?-{3,}:?/
+                        }
+                    },
+                    "table-header-row": {
+                        pattern: RegExp("^" + tableRow2 + "$"),
+                        inside: {
+                            "table-header": {
+                                pattern: RegExp(tableCell2),
+                                alias: "important",
+                                inside: Prism2.languages.markdown
+                            },
+                            "punctuation": /\|/
+                        }
+                    }
                 }
-                case DATE:
-                    return as(new Date(value), index2);
-                case REGEXP: {
-                    const {
-                        source,
-                        flags
-                    } = value;
-                    return as(new RegExp(source, flags), index2);
+            },
+            "code": [{
+                pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
+                lookbehind: true,
+                alias: "keyword"
+            }, {
+                pattern: /^```[\s\S]*?^```$/m,
+                greedy: true,
+                inside: {
+                    "code-block": {
+                        pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
+                        lookbehind: true
+                    },
+                    "code-language": {
+                        pattern: /^(```).+/,
+                        lookbehind: true
+                    },
+                    "punctuation": /```/
                 }
-                case MAP: {
-                    const map2 = as( /* @__PURE__ */ new Map(), index2);
-                    for (const [key, index3] of value)
-                        map2.set(unpair(key), unpair(index3));
-                    return map2;
+            }],
+            "title": [{
+                pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
+                alias: "important",
+                inside: {
+                    punctuation: /==+$|--+$/
                 }
-                case SET$1: {
-                    const set2 = as( /* @__PURE__ */ new Set(), index2);
-                    for (const index3 of value)
-                        set2.add(unpair(index3));
-                    return set2;
+            }, {
+                pattern: /(^\s*)#.+/m,
+                lookbehind: true,
+                alias: "important",
+                inside: {
+                    punctuation: /^#+|#+$/
                 }
-                case ERROR: {
-                    const {
-                        name: name2,
-                        message
-                    } = value;
-                    return as(new env[name2](message), index2);
+            }],
+            "hr": {
+                pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
+                lookbehind: true,
+                alias: "punctuation"
+            },
+            "list": {
+                pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
+                lookbehind: true,
+                alias: "punctuation"
+            },
+            "url-reference": {
+                pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
+                inside: {
+                    "variable": {
+                        pattern: /^(!?\[)[^\]]+/,
+                        lookbehind: true
+                    },
+                    "string": /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
+                    "punctuation": /^[\[\]!:]|[<>]/
+                },
+                alias: "url"
+            },
+            "bold": {
+                pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
+                lookbehind: true,
+                greedy: true,
+                inside: {
+                    "content": {
+                        pattern: /(^..)[\s\S]+(?=..$)/,
+                        lookbehind: true,
+                        inside: {}
+                    },
+                    "punctuation": /\*\*|__/
                 }
-                case BIGINT:
-                    return as(BigInt(value), index2);
-                case "BigInt":
-                    return as(Object(BigInt(value)), index2);
-            }
-            return as(new env[type2](value), index2);
-        };
-        return unpair;
-    };
-    const deserialize = (serialized) => deserializer( /* @__PURE__ */ new Map(), serialized)(0);
-    const EMPTY = "";
-    const {
-        toString: toString$3
-    } = {};
-    const {
-        keys: keys$2
-    } = Object;
-    const typeOf = (value) => {
-        const type2 = typeof value;
-        if (type2 !== "object" || !value)
-            return [PRIMITIVE, type2];
-        const asString = toString$3.call(value).slice(8, -1);
-        switch (asString) {
-            case "Array":
-                return [ARRAY, EMPTY];
-            case "Object":
-                return [OBJECT, EMPTY];
-            case "Date":
-                return [DATE, EMPTY];
-            case "RegExp":
-                return [REGEXP, EMPTY];
-            case "Map":
-                return [MAP, EMPTY];
-            case "Set":
-                return [SET$1, EMPTY];
-        }
-        if (asString.includes("Array"))
-            return [ARRAY, asString];
-        if (asString.includes("Error"))
-            return [ERROR, asString];
-        return [OBJECT, asString];
-    };
-    const shouldSkip = ([TYPE, type2]) => TYPE === PRIMITIVE && (type2 === "function" || type2 === "symbol");
-    const serializer = (strict, json2, $2, _2) => {
-        const as = (out, value) => {
-            const index2 = _2.push(out) - 1;
-            $2.set(value, index2);
-            return index2;
-        };
-        const pair2 = (value) => {
-            if ($2.has(value))
-                return $2.get(value);
-            let [TYPE, type2] = typeOf(value);
-            switch (TYPE) {
-                case PRIMITIVE: {
-                    let entry = value;
-                    switch (type2) {
-                        case "bigint":
-                            TYPE = BIGINT;
-                            entry = value.toString();
-                            break;
-                        case "function":
-                        case "symbol":
-                            if (strict)
-                                throw new TypeError("unable to serialize " + type2);
-                            entry = null;
-                            break;
-                        case "undefined":
-                            return as([VOID], value);
-                    }
-                    return as([TYPE, entry], value);
+            },
+            "italic": {
+                pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
+                lookbehind: true,
+                greedy: true,
+                inside: {
+                    "content": {
+                        pattern: /(^.)[\s\S]+(?=.$)/,
+                        lookbehind: true,
+                        inside: {}
+                    },
+                    "punctuation": /[*_]/
                 }
-                case ARRAY: {
-                    if (type2)
-                        return as([type2, [...value]], value);
-                    const arr = [];
-                    const index2 = as([TYPE, arr], value);
-                    for (const entry of value)
-                        arr.push(pair2(entry));
-                    return index2;
+            },
+            "strike": {
+                pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
+                lookbehind: true,
+                greedy: true,
+                inside: {
+                    "content": {
+                        pattern: /(^~~?)[\s\S]+(?=\1$)/,
+                        lookbehind: true,
+                        inside: {}
+                    },
+                    "punctuation": /~~?/
                 }
-                case OBJECT: {
-                    if (type2) {
-                        switch (type2) {
-                            case "BigInt":
-                                return as([type2, value.toString()], value);
-                            case "Boolean":
-                            case "Number":
-                            case "String":
-                                return as([type2, value.valueOf()], value);
-                        }
-                    }
-                    if (json2 && "toJSON" in value)
-                        return pair2(value.toJSON());
-                    const entries = [];
-                    const index2 = as([TYPE, entries], value);
-                    for (const key of keys$2(value)) {
-                        if (strict || !shouldSkip(typeOf(value[key])))
-                            entries.push([pair2(key), pair2(value[key])]);
+            },
+            "code-snippet": {
+                pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
+                lookbehind: true,
+                greedy: true,
+                alias: ["code", "keyword"]
+            },
+            "url": {
+                pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
+                lookbehind: true,
+                greedy: true,
+                inside: {
+                    "operator": /^!/,
+                    "content": {
+                        pattern: /(^\[)[^\]]+(?=\])/,
+                        lookbehind: true,
+                        inside: {}
+                    },
+                    "variable": {
+                        pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
+                        lookbehind: true
+                    },
+                    "url": {
+                        pattern: /(^\]\()[^\s)]+/,
+                        lookbehind: true
+                    },
+                    "string": {
+                        pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
+                        lookbehind: true
                     }
-                    return index2;
                 }
-                case DATE:
-                    return as([TYPE, value.toISOString()], value);
-                case REGEXP: {
-                    const {
-                        source,
-                        flags
-                    } = value;
-                    return as([TYPE, {
-                        source,
-                        flags
-                    }], value);
+            }
+        });
+        ["url", "bold", "italic", "strike"].forEach(function(token) {
+            ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside2) {
+                if (token !== inside2) {
+                    Prism2.languages.markdown[token].inside.content.inside[inside2] = Prism2.languages.markdown[inside2];
                 }
-                case MAP: {
-                    const entries = [];
-                    const index2 = as([TYPE, entries], value);
-                    for (const [key, entry] of value) {
-                        if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))
-                            entries.push([pair2(key), pair2(entry)]);
-                    }
-                    return index2;
+            });
+        });
+        Prism2.hooks.add("after-tokenize", function(env2) {
+            if (env2.language !== "markdown" && env2.language !== "md") {
+                return;
+            }
+
+            function walkTokens(tokens2) {
+                if (!tokens2 || typeof tokens2 === "string") {
+                    return;
                 }
-                case SET$1: {
-                    const entries = [];
-                    const index2 = as([TYPE, entries], value);
-                    for (const entry of value) {
-                        if (strict || !shouldSkip(typeOf(entry)))
-                            entries.push(pair2(entry));
+                for (var i2 = 0, l2 = tokens2.length; i2 < l2; i2++) {
+                    var token = tokens2[i2];
+                    if (token.type !== "code") {
+                        walkTokens(token.content);
+                        continue;
+                    }
+                    var codeLang = token.content[1];
+                    var codeBlock = token.content[3];
+                    if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
+                        var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
+                        lang = (/[a-z][\w-]*/i.exec(lang) || [""])[0].toLowerCase();
+                        var alias = "language-" + lang;
+                        if (!codeBlock.alias) {
+                            codeBlock.alias = [alias];
+                        } else if (typeof codeBlock.alias === "string") {
+                            codeBlock.alias = [codeBlock.alias, alias];
+                        } else {
+                            codeBlock.alias.push(alias);
+                        }
                     }
-                    return index2;
                 }
             }
-            const {
-                message
-            } = value;
-            return as([TYPE, {
-                name: type2,
-                message
-            }], value);
-        };
-        return pair2;
-    };
-    const serialize$1 = (value, {
-        json: json2,
-        lossy
-    } = {}) => {
-        const _2 = [];
-        return serializer(!(json2 || lossy), !!json2, /* @__PURE__ */ new Map(), _2)(value), _2;
-    };
-    const structuredClone$1 = typeof structuredClone === "function" ? (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize$1(any, options)) : structuredClone(any) : (any, options) => deserialize(serialize$1(any, options));
-
-    function defaultFootnoteBackContent(_2, rereferenceIndex) {
-        const result = [{
-            type: "text",
-            value: "\u21A9"
-        }];
-        if (rereferenceIndex > 1) {
-            result.push({
-                type: "element",
-                tagName: "sup",
-                properties: {},
-                children: [{
-                    type: "text",
-                    value: String(rereferenceIndex)
-                }]
-            });
-        }
-        return result;
-    }
-
-    function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
-        return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
-    }
-
-    function footer(state) {
-        const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
-        const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
-        const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
-        const footnoteLabel = state.options.footnoteLabel || "Footnotes";
-        const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
-        const footnoteLabelProperties = state.options.footnoteLabelProperties || {
-            className: ["sr-only"]
-        };
-        const listItems = [];
-        let referenceIndex = -1;
-        while (++referenceIndex < state.footnoteOrder.length) {
-            const def = state.footnoteById.get(state.footnoteOrder[referenceIndex]);
-            if (!def) {
-                continue;
+            walkTokens(env2.tokens);
+        });
+        Prism2.hooks.add("wrap", function(env2) {
+            if (env2.type !== "code-block") {
+                return;
             }
-            const content2 = state.all(def);
-            const id2 = String(def.identifier).toUpperCase();
-            const safeId = normalizeUri(id2.toLowerCase());
-            let rereferenceIndex = 0;
-            const backReferences = [];
-            const counts = state.footnoteCounts.get(id2);
-            while (counts !== void 0 && ++rereferenceIndex <= counts) {
-                if (backReferences.length > 0) {
-                    backReferences.push({
-                        type: "text",
-                        value: " "
-                    });
-                }
-                let children2 = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
-                if (typeof children2 === "string") {
-                    children2 = {
-                        type: "text",
-                        value: children2
-                    };
+            var codeLang = "";
+            for (var i2 = 0, l2 = env2.classes.length; i2 < l2; i2++) {
+                var cls = env2.classes[i2];
+                var match2 = /language-(.+)/.exec(cls);
+                if (match2) {
+                    codeLang = match2[1];
+                    break;
                 }
-                backReferences.push({
-                    type: "element",
-                    tagName: "a",
-                    properties: {
-                        href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
-                        dataFootnoteBackref: "",
-                        ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
-                        className: ["data-footnote-backref"]
-                    },
-                    children: Array.isArray(children2) ? children2 : [children2]
-                });
             }
-            const tail = content2[content2.length - 1];
-            if (tail && tail.type === "element" && tail.tagName === "p") {
-                const tailTail = tail.children[tail.children.length - 1];
-                if (tailTail && tailTail.type === "text") {
-                    tailTail.value += " ";
-                } else {
-                    tail.children.push({
-                        type: "text",
-                        value: " "
+            var grammar = Prism2.languages[codeLang];
+            if (!grammar) {
+                if (codeLang && codeLang !== "none" && Prism2.plugins.autoloader) {
+                    var id2 = "md-" + new Date().valueOf() + "-" + Math.floor(Math.random() * 1e16);
+                    env2.attributes["id"] = id2;
+                    Prism2.plugins.autoloader.loadLanguages(codeLang, function() {
+                        var ele = document.getElementById(id2);
+                        if (ele) {
+                            ele.innerHTML = Prism2.highlight(ele.textContent, Prism2.languages[codeLang], codeLang);
+                        }
                     });
                 }
-                tail.children.push(...backReferences);
             } else {
-                content2.push(...backReferences);
+                env2.content = Prism2.highlight(textContent(env2.content), grammar, codeLang);
             }
-            const listItem2 = {
-                type: "element",
-                tagName: "li",
-                properties: {
-                    id: clobberPrefix + "fn-" + safeId
-                },
-                children: state.wrap(content2, true)
-            };
-            state.patch(def, listItem2);
-            listItems.push(listItem2);
-        }
-        if (listItems.length === 0) {
-            return;
-        }
-        return {
-            type: "element",
-            tagName: "section",
-            properties: {
-                dataFootnotes: true,
-                className: ["footnotes"]
-            },
-            children: [{
-                type: "element",
-                tagName: footnoteLabelTagName,
-                properties: {
-                    ...structuredClone$1(footnoteLabelProperties),
-                    id: "footnote-label"
-                },
-                children: [{
-                    type: "text",
-                    value: footnoteLabel
-                }]
-            }, {
-                type: "text",
-                value: "\n"
-            }, {
-                type: "element",
-                tagName: "ol",
-                properties: {},
-                children: state.wrap(listItems, true)
-            }, {
-                type: "text",
-                value: "\n"
-            }]
+        });
+        var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, "gi");
+        var KNOWN_ENTITY_NAMES = {
+            "amp": "&",
+            "lt": "<",
+            "gt": ">",
+            "quot": '"'
         };
-    }
-    const convert$1 = function(test2) {
-        if (test2 === null || test2 === void 0) {
-            return ok$1;
-        }
-        if (typeof test2 === "function") {
-            return castFactory$1(test2);
-        }
-        if (typeof test2 === "object") {
-            return Array.isArray(test2) ? anyFactory$1(test2) : propsFactory$1(test2);
-        }
-        if (typeof test2 === "string") {
-            return typeFactory$1(test2);
-        }
-        throw new Error("Expected function, string, or object as test");
-    };
+        var fromCodePoint2 = String.fromCodePoint || String.fromCharCode;
 
-    function anyFactory$1(tests) {
-        const checks2 = [];
-        let index2 = -1;
-        while (++index2 < tests.length) {
-            checks2[index2] = convert$1(tests[index2]);
+        function textContent(html2) {
+            var text2 = html2.replace(tagPattern, "");
+            text2 = text2.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m2, code2) {
+                code2 = code2.toLowerCase();
+                if (code2[0] === "#") {
+                    var value;
+                    if (code2[1] === "x") {
+                        value = parseInt(code2.slice(2), 16);
+                    } else {
+                        value = Number(code2.slice(1));
+                    }
+                    return fromCodePoint2(value);
+                } else {
+                    var known = KNOWN_ENTITY_NAMES[code2];
+                    if (known) {
+                        return known;
+                    }
+                    return m2;
+                }
+            });
+            return text2;
         }
-        return castFactory$1(any);
-
-        function any(...parameters) {
-            let index3 = -1;
-            while (++index3 < checks2.length) {
-                if (checks2[index3].apply(this, parameters))
-                    return true;
+        Prism2.languages.md = Prism2.languages.markdown;
+    })(prism);
+    prism.languages.graphql = {
+        "comment": /#.*/,
+        "description": {
+            pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i,
+            greedy: true,
+            alias: "string",
+            inside: {
+                "language-markdown": {
+                    pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/,
+                    lookbehind: true,
+                    inside: prism.languages.markdown
+                }
             }
-            return false;
+        },
+        "string": {
+            pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/,
+            greedy: true
+        },
+        "number": /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
+        "boolean": /\b(?:false|true)\b/,
+        "variable": /\$[a-z_]\w*/i,
+        "directive": {
+            pattern: /@[a-z_]\w*/i,
+            alias: "function"
+        },
+        "attr-name": {
+            pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i,
+            greedy: true
+        },
+        "atom-input": {
+            pattern: /\b[A-Z]\w*Input\b/,
+            alias: "class-name"
+        },
+        "scalar": /\b(?:Boolean|Float|ID|Int|String)\b/,
+        "constant": /\b[A-Z][A-Z_\d]*\b/,
+        "class-name": {
+            pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/,
+            lookbehind: true
+        },
+        "fragment": {
+            pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/,
+            lookbehind: true,
+            alias: "function"
+        },
+        "definition-mutation": {
+            pattern: /(\bmutation\s+)[a-zA-Z_]\w*/,
+            lookbehind: true,
+            alias: "function"
+        },
+        "definition-query": {
+            pattern: /(\bquery\s+)[a-zA-Z_]\w*/,
+            lookbehind: true,
+            alias: "function"
+        },
+        "keyword": /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/,
+        "operator": /[!=|&]|\.{3}/,
+        "property-query": /\w+(?=\s*\()/,
+        "object": /\w+(?=\s*\{)/,
+        "punctuation": /[!(){}\[\]:=,]/,
+        "property": /\w+/
+    };
+    prism.hooks.add("after-tokenize", function afterTokenizeGraphql(env2) {
+        if (env2.language !== "graphql") {
+            return;
         }
-    }
+        var validTokens = env2.tokens.filter(function(token) {
+            return typeof token !== "string" && token.type !== "comment" && token.type !== "scalar";
+        });
+        var currentIndex = 0;
 
-    function propsFactory$1(check) {
-        const checkAsRecord = check;
-        return castFactory$1(all2);
+        function getToken(offset2) {
+            return validTokens[currentIndex + offset2];
+        }
 
-        function all2(node2) {
-            const nodeAsRecord = node2;
-            let key;
-            for (key in check) {
-                if (nodeAsRecord[key] !== checkAsRecord[key])
+        function isTokenType(types2, offset2) {
+            offset2 = offset2 || 0;
+            for (var i3 = 0; i3 < types2.length; i3++) {
+                var token = getToken(i3 + offset2);
+                if (!token || token.type !== types2[i3]) {
                     return false;
+                }
             }
             return true;
         }
-    }
-
-    function typeFactory$1(check) {
-        return castFactory$1(type2);
-
-        function type2(node2) {
-            return node2 && node2.type === check;
-        }
-    }
-
-    function castFactory$1(testFunction) {
-        return check;
-
-        function check(value, index2, parent) {
-            return Boolean(
-                looksLikeANode(value) && testFunction.call(
-                    this,
-                    value,
-                    typeof index2 === "number" ? index2 : void 0,
-                    parent || void 0
-                )
-            );
-        }
-    }
-
-    function ok$1() {
-        return true;
-    }
-
-    function looksLikeANode(value) {
-        return value !== null && typeof value === "object" && "type" in value;
-    }
-
-    function color$2(d2) {
-        return d2;
-    }
-    const empty$2 = [];
-    const CONTINUE$1 = true;
-    const EXIT$1 = false;
-    const SKIP$1 = "skip";
 
-    function visitParents$1(tree, test2, visitor, reverse) {
-        let check;
-        if (typeof test2 === "function" && typeof visitor !== "function") {
-            reverse = visitor;
-            visitor = test2;
-        } else {
-            check = test2;
+        function findClosingBracket(open, close) {
+            var stackHeight = 1;
+            for (var i3 = currentIndex; i3 < validTokens.length; i3++) {
+                var token = validTokens[i3];
+                var content2 = token.content;
+                if (token.type === "punctuation" && typeof content2 === "string") {
+                    if (open.test(content2)) {
+                        stackHeight++;
+                    } else if (close.test(content2)) {
+                        stackHeight--;
+                        if (stackHeight === 0) {
+                            return i3;
+                        }
+                    }
+                }
+            }
+            return -1;
         }
-        const is2 = convert$1(check);
-        const step2 = reverse ? -1 : 1;
-        factory2(tree, void 0, [])();
 
-        function factory2(node2, index2, parents) {
-            const value = node2 && typeof node2 === "object" ? node2 : {};
-            if (typeof value.type === "string") {
-                const name2 = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
-                Object.defineProperty(visit2, "name", {
-                    value: "node (" + color$2(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
-                });
+        function addAlias(token, alias) {
+            var aliases = token.alias;
+            if (!aliases) {
+                token.alias = aliases = [];
+            } else if (!Array.isArray(aliases)) {
+                token.alias = aliases = [aliases];
             }
-            return visit2;
-
-            function visit2() {
-                let result = empty$2;
-                let subresult;
-                let offset2;
-                let grandparents;
-                if (!test2 || is2(node2, index2, parents[parents.length - 1] || void 0)) {
-                    result = toResult$1(visitor(node2, parents));
-                    if (result[0] === EXIT$1) {
-                        return result;
+            aliases.push(alias);
+        }
+        for (; currentIndex < validTokens.length;) {
+            var startToken = validTokens[currentIndex++];
+            if (startToken.type === "keyword" && startToken.content === "mutation") {
+                var inputVariables = [];
+                if (isTokenType(["definition-mutation", "punctuation"]) && getToken(1).content === "(") {
+                    currentIndex += 2;
+                    var definitionEnd = findClosingBracket(/^\($/, /^\)$/);
+                    if (definitionEnd === -1) {
+                        continue;
+                    }
+                    for (; currentIndex < definitionEnd; currentIndex++) {
+                        var t2 = getToken(0);
+                        if (t2.type === "variable") {
+                            addAlias(t2, "variable-input");
+                            inputVariables.push(t2.content);
+                        }
                     }
+                    currentIndex = definitionEnd + 1;
                 }
-                if ("children" in node2 && node2.children) {
-                    const nodeAsParent = node2;
-                    if (nodeAsParent.children && result[0] !== SKIP$1) {
-                        offset2 = (reverse ? nodeAsParent.children.length : -1) + step2;
-                        grandparents = parents.concat(nodeAsParent);
-                        while (offset2 > -1 && offset2 < nodeAsParent.children.length) {
-                            const child = nodeAsParent.children[offset2];
-                            subresult = factory2(child, offset2, grandparents)();
-                            if (subresult[0] === EXIT$1) {
-                                return subresult;
+                if (isTokenType(["punctuation", "property-query"]) && getToken(0).content === "{") {
+                    currentIndex++;
+                    addAlias(getToken(0), "property-mutation");
+                    if (inputVariables.length > 0) {
+                        var mutationEnd = findClosingBracket(/^\{$/, /^\}$/);
+                        if (mutationEnd === -1) {
+                            continue;
+                        }
+                        for (var i2 = currentIndex; i2 < mutationEnd; i2++) {
+                            var varToken = validTokens[i2];
+                            if (varToken.type === "variable" && inputVariables.indexOf(varToken.content) >= 0) {
+                                addAlias(varToken, "variable-input");
                             }
-                            offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step2;
                         }
                     }
                 }
-                return result;
             }
         }
-    }
+    });
+    prism.languages.sql = {
+        "comment": {
+            pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
+            lookbehind: true
+        },
+        "variable": [{
+            pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
+            greedy: true
+        }, /@[\w.$]+/],
+        "string": {
+            pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
+            greedy: true,
+            lookbehind: true
+        },
+        "identifier": {
+            pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
+            greedy: true,
+            lookbehind: true,
+            inside: {
+                "punctuation": /^`|`$/
+            }
+        },
+        "function": /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
+        "keyword": /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
+        "boolean": /\b(?:FALSE|NULL|TRUE)\b/i,
+        "number": /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
+        "operator": /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
+        "punctuation": /[;[\]()`,.]/
+    };
+    (function(Prism2) {
+        var templateString = Prism2.languages.javascript["template-string"];
+        var templateLiteralPattern = templateString.pattern.source;
+        var interpolationObject = templateString.inside["interpolation"];
+        var interpolationPunctuationObject = interpolationObject.inside["interpolation-punctuation"];
+        var interpolationPattern = interpolationObject.pattern.source;
 
-    function toResult$1(value) {
-        if (Array.isArray(value)) {
-            return value;
-        }
-        if (typeof value === "number") {
-            return [CONTINUE$1, value];
+        function createTemplate(language2, tag) {
+            if (!Prism2.languages[language2]) {
+                return void 0;
+            }
+            return {
+                pattern: RegExp("((?:" + tag + ")\\s*)" + templateLiteralPattern),
+                lookbehind: true,
+                greedy: true,
+                inside: {
+                    "template-punctuation": {
+                        pattern: /^`|`$/,
+                        alias: "string"
+                    },
+                    "embedded-code": {
+                        pattern: /[\s\S]+/,
+                        alias: language2
+                    }
+                }
+            };
         }
-        return value === null || value === void 0 ? empty$2 : [value];
-    }
+        Prism2.languages.javascript["template-string"] = [
+            createTemplate("css", /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),
+            createTemplate("html", /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source),
+            createTemplate("svg", /\bsvg/.source),
+            createTemplate("markdown", /\b(?:markdown|md)/.source),
+            createTemplate("graphql", /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source),
+            createTemplate("sql", /\bsql/.source),
+            templateString
+        ].filter(Boolean);
 
-    function visit$1(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
-        let reverse;
-        let test2;
-        let visitor;
-        if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
-            test2 = void 0;
-            visitor = testOrVisitor;
-            reverse = visitorOrReverse;
-        } else {
-            test2 = testOrVisitor;
-            visitor = visitorOrReverse;
-            reverse = maybeReverse;
+        function getPlaceholder(counter2, language2) {
+            return "___" + language2.toUpperCase() + "_" + counter2 + "___";
         }
-        visitParents$1(tree, test2, overload, reverse);
 
-        function overload(node2, parents) {
-            const parent = parents[parents.length - 1];
-            const index2 = parent ? parent.children.indexOf(node2) : void 0;
-            return visitor(node2, index2, parent);
+        function tokenizeWithHooks(code2, grammar, language2) {
+            var env2 = {
+                code: code2,
+                grammar,
+                language: language2
+            };
+            Prism2.hooks.run("before-tokenize", env2);
+            env2.tokens = Prism2.tokenize(env2.code, env2.grammar);
+            Prism2.hooks.run("after-tokenize", env2);
+            return env2.tokens;
         }
-    }
-    const own$5 = {}.hasOwnProperty;
-    const emptyOptions$1 = {};
 
-    function createState(tree, options) {
-        const settings2 = options || emptyOptions$1;
-        const definitionById = /* @__PURE__ */ new Map();
-        const footnoteById = /* @__PURE__ */ new Map();
-        const footnoteCounts = /* @__PURE__ */ new Map();
-        const handlers2 = {
-            ...handlers$1,
-            ...settings2.handlers
-        };
-        const state = {
-            all: all2,
-            applyData,
-            definitionById,
-            footnoteById,
-            footnoteCounts,
-            footnoteOrder: [],
-            handlers: handlers2,
-            one: one2,
-            options: settings2,
-            patch: patch$2,
-            wrap: wrap$1
-        };
-        visit$1(tree, function(node2) {
-            if (node2.type === "definition" || node2.type === "footnoteDefinition") {
-                const map2 = node2.type === "definition" ? definitionById : footnoteById;
-                const id2 = String(node2.identifier).toUpperCase();
-                if (!map2.has(id2)) {
-                    map2.set(id2, node2);
-                }
+        function tokenizeInterpolationExpression(expression) {
+            var tempGrammar = {};
+            tempGrammar["interpolation-punctuation"] = interpolationPunctuationObject;
+            var tokens2 = Prism2.tokenize(expression, tempGrammar);
+            if (tokens2.length === 3) {
+                var args = [1, 1];
+                args.push.apply(args, tokenizeWithHooks(tokens2[1], Prism2.languages.javascript, "javascript"));
+                tokens2.splice.apply(tokens2, args);
             }
-        });
-        return state;
+            return new Prism2.Token("interpolation", tokens2, interpolationObject.alias, expression);
+        }
 
-        function one2(node2, parent) {
-            const type2 = node2.type;
-            const handle2 = state.handlers[type2];
-            if (own$5.call(state.handlers, type2) && handle2) {
-                return handle2(state, node2, parent);
-            }
-            if (state.options.passThrough && state.options.passThrough.includes(type2)) {
-                if ("children" in node2) {
-                    const {
-                        children: children2,
-                        ...shallow
-                    } = node2;
-                    const result = structuredClone$1(shallow);
-                    result.children = state.all(node2);
-                    return result;
+        function tokenizeEmbedded(code2, grammar, language2) {
+            var _tokens = Prism2.tokenize(code2, {
+                "interpolation": {
+                    pattern: RegExp(interpolationPattern),
+                    lookbehind: true
                 }
-                return structuredClone$1(node2);
-            }
-            const unknown2 = state.options.unknownHandler || defaultUnknownHandler;
-            return unknown2(state, node2, parent);
-        }
+            });
+            var placeholderCounter = 0;
+            var placeholderMap = {};
+            var embeddedCode = _tokens.map(function(token) {
+                if (typeof token === "string") {
+                    return token;
+                } else {
+                    var interpolationExpression = token.content;
+                    var placeholder;
+                    while (code2.indexOf(placeholder = getPlaceholder(placeholderCounter++, language2)) !== -1) {}
+                    placeholderMap[placeholder] = interpolationExpression;
+                    return placeholder;
+                }
+            }).join("");
+            var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language2);
+            var placeholders = Object.keys(placeholderMap);
+            placeholderCounter = 0;
 
-        function all2(parent) {
-            const values = [];
-            if ("children" in parent) {
-                const nodes = parent.children;
-                let index2 = -1;
-                while (++index2 < nodes.length) {
-                    const result = state.one(nodes[index2], parent);
-                    if (result) {
-                        if (index2 && nodes[index2 - 1].type === "break") {
-                            if (!Array.isArray(result) && result.type === "text") {
-                                result.value = trimMarkdownSpaceStart(result.value);
+            function walkTokens(tokens2) {
+                for (var i2 = 0; i2 < tokens2.length; i2++) {
+                    if (placeholderCounter >= placeholders.length) {
+                        return;
+                    }
+                    var token = tokens2[i2];
+                    if (typeof token === "string" || typeof token.content === "string") {
+                        var placeholder = placeholders[placeholderCounter];
+                        var s2 = typeof token === "string" ? token : token.content;
+                        var index2 = s2.indexOf(placeholder);
+                        if (index2 !== -1) {
+                            ++placeholderCounter;
+                            var before = s2.substring(0, index2);
+                            var middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);
+                            var after = s2.substring(index2 + placeholder.length);
+                            var replacement = [];
+                            if (before) {
+                                replacement.push(before);
                             }
-                            if (!Array.isArray(result) && result.type === "element") {
-                                const head = result.children[0];
-                                if (head && head.type === "text") {
-                                    head.value = trimMarkdownSpaceStart(head.value);
-                                }
+                            replacement.push(middle);
+                            if (after) {
+                                var afterTokens = [after];
+                                walkTokens(afterTokens);
+                                replacement.push.apply(replacement, afterTokens);
+                            }
+                            if (typeof token === "string") {
+                                tokens2.splice.apply(tokens2, [i2, 1].concat(replacement));
+                                i2 += replacement.length - 1;
+                            } else {
+                                token.content = replacement;
                             }
                         }
-                        if (Array.isArray(result)) {
-                            values.push(...result);
+                    } else {
+                        var content2 = token.content;
+                        if (Array.isArray(content2)) {
+                            walkTokens(content2);
                         } else {
-                            values.push(result);
+                            walkTokens([content2]);
                         }
                     }
                 }
             }
-            return values;
-        }
-    }
-
-    function patch$2(from, to2) {
-        if (from.position)
-            to2.position = position$3(from);
-    }
-
-    function applyData(from, to2) {
-        let result = to2;
-        if (from && from.data) {
-            const hName = from.data.hName;
-            const hChildren = from.data.hChildren;
-            const hProperties = from.data.hProperties;
-            if (typeof hName === "string") {
-                if (result.type === "element") {
-                    result.tagName = hName;
-                } else {
-                    const children2 = "children" in result ? result.children : [result];
-                    result = {
-                        type: "element",
-                        tagName: hName,
-                        properties: {},
-                        children: children2
-                    };
-                }
-            }
-            if (result.type === "element" && hProperties) {
-                Object.assign(result.properties, structuredClone$1(hProperties));
-            }
-            if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
-                result.children = hChildren;
-            }
-        }
-        return result;
-    }
-
-    function defaultUnknownHandler(state, node2) {
-        const data2 = node2.data || {};
-        const result = "value" in node2 && !(own$5.call(data2, "hProperties") || own$5.call(data2, "hChildren")) ? {
-            type: "text",
-            value: node2.value
-        } : {
-            type: "element",
-            tagName: "div",
-            properties: {},
-            children: state.all(node2)
-        };
-        state.patch(node2, result);
-        return state.applyData(node2, result);
-    }
-
-    function wrap$1(nodes, loose) {
-        const result = [];
-        let index2 = -1;
-        if (loose) {
-            result.push({
-                type: "text",
-                value: "\n"
-            });
-        }
-        while (++index2 < nodes.length) {
-            if (index2)
-                result.push({
-                    type: "text",
-                    value: "\n"
-                });
-            result.push(nodes[index2]);
-        }
-        if (loose && nodes.length > 0) {
-            result.push({
-                type: "text",
-                value: "\n"
-            });
-        }
-        return result;
-    }
-
-    function trimMarkdownSpaceStart(value) {
-        let index2 = 0;
-        let code2 = value.charCodeAt(index2);
-        while (code2 === 9 || code2 === 32) {
-            index2++;
-            code2 = value.charCodeAt(index2);
-        }
-        return value.slice(index2);
-    }
-
-    function toHast(tree, options) {
-        const state = createState(tree, options);
-        const node2 = state.one(tree, void 0);
-        const foot = footer(state);
-        const result = Array.isArray(node2) ? {
-            type: "root",
-            children: node2
-        } : node2 || {
-            type: "root",
-            children: []
-        };
-        if (foot) {
-            result.children.push({
-                type: "text",
-                value: "\n"
-            }, foot);
-        }
-        return result;
-    }
-
-    function remarkRehype(destination, options) {
-        if (destination && "run" in destination) {
-            return async function(tree, file) {
-                const hastTree = toHast(tree, {
-                    file,
-                    ...options
-                });
-                await destination.run(hastTree, file);
-            };
+            walkTokens(embeddedTokens);
+            return new Prism2.Token(language2, embeddedTokens, "language-" + language2, code2);
         }
-        return function(tree, file) {
-            return toHast(tree, {
-                file,
-                ...options || destination
-            });
+        var supportedLanguages = {
+            "javascript": true,
+            "js": true,
+            "typescript": true,
+            "ts": true,
+            "jsx": true,
+            "tsx": true
         };
-    }
-
-    function bail(error2) {
-        if (error2) {
-            throw error2;
-        }
-    }
-    var hasOwn$2 = Object.prototype.hasOwnProperty;
-    var toStr$2 = Object.prototype.toString;
-    var defineProperty$2 = Object.defineProperty;
-    var gOPD$1 = Object.getOwnPropertyDescriptor;
-    var isArray$9 = function isArray2(arr) {
-        if (typeof Array.isArray === "function") {
-            return Array.isArray(arr);
-        }
-        return toStr$2.call(arr) === "[object Array]";
-    };
-    var isPlainObject$4 = function isPlainObject2(obj) {
-        if (!obj || toStr$2.call(obj) !== "[object Object]") {
-            return false;
-        }
-        var hasOwnConstructor = hasOwn$2.call(obj, "constructor");
-        var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn$2.call(obj.constructor.prototype, "isPrototypeOf");
-        if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
-            return false;
-        }
-        var key;
-        for (key in obj) {}
-        return typeof key === "undefined" || hasOwn$2.call(obj, key);
-    };
-    var setProperty = function setProperty2(target, options) {
-        if (defineProperty$2 && options.name === "__proto__") {
-            defineProperty$2(target, options.name, {
-                enumerable: true,
-                configurable: true,
-                value: options.newValue,
-                writable: true
-            });
-        } else {
-            target[options.name] = options.newValue;
-        }
-    };
-    var getProperty = function getProperty2(obj, name2) {
-        if (name2 === "__proto__") {
-            if (!hasOwn$2.call(obj, name2)) {
-                return void 0;
-            } else if (gOPD$1) {
-                return gOPD$1(obj, name2).value;
+        Prism2.hooks.add("after-tokenize", function(env2) {
+            if (!(env2.language in supportedLanguages)) {
+                return;
             }
-        }
-        return obj[name2];
-    };
-    var extend$3 = function extend2() {
-        var options, name2, src, copy2, copyIsArray, clone2;
-        var target = arguments[0];
-        var i2 = 1;
-        var length = arguments.length;
-        var deep = false;
-        if (typeof target === "boolean") {
-            deep = target;
-            target = arguments[1] || {};
-            i2 = 2;
-        }
-        if (target == null || typeof target !== "object" && typeof target !== "function") {
-            target = {};
-        }
-        for (; i2 < length; ++i2) {
-            options = arguments[i2];
-            if (options != null) {
-                for (name2 in options) {
-                    src = getProperty(target, name2);
-                    copy2 = getProperty(options, name2);
-                    if (target !== copy2) {
-                        if (deep && copy2 && (isPlainObject$4(copy2) || (copyIsArray = isArray$9(copy2)))) {
-                            if (copyIsArray) {
-                                copyIsArray = false;
-                                clone2 = src && isArray$9(src) ? src : [];
-                            } else {
-                                clone2 = src && isPlainObject$4(src) ? src : {};
+
+            function findTemplateStrings(tokens2) {
+                for (var i2 = 0, l2 = tokens2.length; i2 < l2; i2++) {
+                    var token = tokens2[i2];
+                    if (typeof token === "string") {
+                        continue;
+                    }
+                    var content2 = token.content;
+                    if (!Array.isArray(content2)) {
+                        if (typeof content2 !== "string") {
+                            findTemplateStrings([content2]);
+                        }
+                        continue;
+                    }
+                    if (token.type === "template-string") {
+                        var embedded = content2[1];
+                        if (content2.length === 3 && typeof embedded !== "string" && embedded.type === "embedded-code") {
+                            var code2 = stringContent2(embedded);
+                            var alias = embedded.alias;
+                            var language2 = Array.isArray(alias) ? alias[0] : alias;
+                            var grammar = Prism2.languages[language2];
+                            if (!grammar) {
+                                continue;
                             }
-                            setProperty(target, {
-                                name: name2,
-                                newValue: extend2(deep, clone2, copy2)
-                            });
-                        } else if (typeof copy2 !== "undefined") {
-                            setProperty(target, {
-                                name: name2,
-                                newValue: copy2
-                            });
+                            content2[1] = tokenizeEmbedded(code2, grammar, language2);
                         }
+                    } else {
+                        findTemplateStrings(content2);
                     }
                 }
             }
-        }
-        return target;
-    };
-
-    function isPlainObject$3(value) {
-        if (typeof value !== "object" || value === null) {
-            return false;
-        }
-        const prototype = Object.getPrototypeOf(value);
-        return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
-    }
-
-    function trough() {
-        const fns = [];
-        const pipeline = {
-            run,
-            use
-        };
-        return pipeline;
+            findTemplateStrings(env2.tokens);
+        });
 
-        function run(...values) {
-            let middlewareIndex = -1;
-            const callback = values.pop();
-            if (typeof callback !== "function") {
-                throw new TypeError("Expected function as last argument, not " + callback);
+        function stringContent2(value) {
+            if (typeof value === "string") {
+                return value;
+            } else if (Array.isArray(value)) {
+                return value.map(stringContent2).join("");
+            } else {
+                return stringContent2(value.content);
             }
-            next2(null, ...values);
-
-            function next2(error2, ...output2) {
-                const fn2 = fns[++middlewareIndex];
-                let index2 = -1;
-                if (error2) {
-                    callback(error2);
-                    return;
+        }
+    })(prism);
+    (function(Prism2) {
+        Prism2.languages.typescript = Prism2.languages.extend("javascript", {
+            "class-name": {
+                pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
+                lookbehind: true,
+                greedy: true,
+                inside: null
+            },
+            "builtin": /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
+        });
+        Prism2.languages.typescript.keyword.push(
+            /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
+            /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
+            /\btype\b(?=\s*(?:[\{*]|$))/
+        );
+        delete Prism2.languages.typescript["parameter"];
+        delete Prism2.languages.typescript["literal-property"];
+        var typeInside = Prism2.languages.extend("typescript", {});
+        delete typeInside["class-name"];
+        Prism2.languages.typescript["class-name"].inside = typeInside;
+        Prism2.languages.insertBefore("typescript", "function", {
+            "decorator": {
+                pattern: /@[$\w\xA0-\uFFFF]+/,
+                inside: {
+                    "at": {
+                        pattern: /^@/,
+                        alias: "operator"
+                    },
+                    "function": /^[\s\S]+/
                 }
-                while (++index2 < values.length) {
-                    if (output2[index2] === null || output2[index2] === void 0) {
-                        output2[index2] = values[index2];
+            },
+            "generic-function": {
+                pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
+                greedy: true,
+                inside: {
+                    "function": /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
+                    "generic": {
+                        pattern: /<[\s\S]+/,
+                        alias: "class-name",
+                        inside: typeInside
                     }
                 }
-                values = output2;
-                if (fn2) {
-                    wrap(fn2, next2)(...output2);
-                } else {
-                    callback(null, ...output2);
-                }
             }
-        }
-
-        function use(middelware) {
-            if (typeof middelware !== "function") {
-                throw new TypeError(
-                    "Expected `middelware` to be a function, not " + middelware
-                );
+        });
+        Prism2.languages.ts = Prism2.languages.typescript;
+    })(prism);
+    (function(Prism2) {
+        Prism2.languages.insertBefore("javascript", "function-variable", {
+            "method-variable": {
+                pattern: RegExp("(\\.\\s*)" + Prism2.languages.javascript["function-variable"].pattern.source),
+                lookbehind: true,
+                alias: ["function-variable", "method", "function", "property-access"]
             }
-            fns.push(middelware);
-            return pipeline;
-        }
-    }
-
-    function wrap(middleware, callback) {
-        let called;
-        return wrapped;
+        });
+        Prism2.languages.insertBefore("javascript", "function", {
+            "method": {
+                pattern: RegExp("(\\.\\s*)" + Prism2.languages.javascript["function"].source),
+                lookbehind: true,
+                alias: ["function", "property-access"]
+            }
+        });
+        Prism2.languages.insertBefore("javascript", "constant", {
+            "known-class-name": [{
+                pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/,
+                alias: "class-name"
+            }, {
+                pattern: /\b(?:[A-Z]\w*)Error\b/,
+                alias: "class-name"
+            }]
+        });
 
-        function wrapped(...parameters) {
-            const fnExpectsCallback = middleware.length > parameters.length;
-            let result;
-            if (fnExpectsCallback) {
-                parameters.push(done);
+        function withId(source, flags) {
+            return RegExp(source.replace(/<ID>/g, function() {
+                return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
+            }), flags);
+        }
+        Prism2.languages.insertBefore("javascript", "keyword", {
+            "imports": {
+                pattern: withId(/(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source),
+                lookbehind: true,
+                inside: Prism2.languages.javascript
+            },
+            "exports": {
+                pattern: withId(/(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source),
+                lookbehind: true,
+                inside: Prism2.languages.javascript
             }
-            try {
-                result = middleware.apply(this, parameters);
-            } catch (error2) {
-                const exception = error2;
-                if (fnExpectsCallback && called) {
-                    throw exception;
-                }
-                return done(exception);
+        });
+        Prism2.languages.javascript["keyword"].unshift({
+            pattern: /\b(?:as|default|export|from|import)\b/,
+            alias: "module"
+        }, {
+            pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,
+            alias: "control-flow"
+        }, {
+            pattern: /\bnull\b/,
+            alias: ["null", "nil"]
+        }, {
+            pattern: /\bundefined\b/,
+            alias: "nil"
+        });
+        Prism2.languages.insertBefore("javascript", "operator", {
+            "spread": {
+                pattern: /\.{3}/,
+                alias: "operator"
+            },
+            "arrow": {
+                pattern: /=>/,
+                alias: "operator"
             }
-            if (!fnExpectsCallback) {
-                if (result instanceof Promise) {
-                    result.then(then, done);
-                } else if (result instanceof Error) {
-                    done(result);
-                } else {
-                    then(result);
-                }
+        });
+        Prism2.languages.insertBefore("javascript", "punctuation", {
+            "property-access": {
+                pattern: withId(/(\.\s*)#?<ID>/.source),
+                lookbehind: true
+            },
+            "maybe-class-name": {
+                pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/,
+                lookbehind: true
+            },
+            "dom": {
+                pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/,
+                alias: "variable"
+            },
+            "console": {
+                pattern: /\bconsole(?=\s*\.)/,
+                alias: "class-name"
             }
-        }
-
-        function done(error2, ...output2) {
-            if (!called) {
-                called = true;
-                callback(error2, ...output2);
+        });
+        var maybeClassNameTokens = ["function", "function-variable", "method", "method-variable", "property-access"];
+        for (var i2 = 0; i2 < maybeClassNameTokens.length; i2++) {
+            var token = maybeClassNameTokens[i2];
+            var value = Prism2.languages.javascript[token];
+            if (Prism2.util.type(value) === "RegExp") {
+                value = Prism2.languages.javascript[token] = {
+                    pattern: value
+                };
             }
+            var inside2 = value.inside || {};
+            value.inside = inside2;
+            inside2["maybe-class-name"] = /^[A-Z][\s\S]*/;
         }
+    })(prism);
+    (function(Prism2) {
+        var javascript = Prism2.util.clone(Prism2.languages.javascript);
+        var space2 = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
+        var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
+        var spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
 
-        function then(value) {
-            done(null, value);
-        }
-    }
-    const path$2 = {
-        basename,
-        dirname,
-        extname,
-        join,
-        sep: "/"
-    };
-
-    function basename(path2, ext) {
-        if (ext !== void 0 && typeof ext !== "string") {
-            throw new TypeError('"ext" argument must be a string');
+        function re2(source, flags) {
+            source = source.replace(/<S>/g, function() {
+                return space2;
+            }).replace(/<BRACES>/g, function() {
+                return braces;
+            }).replace(/<SPREAD>/g, function() {
+                return spread;
+            });
+            return RegExp(source, flags);
         }
-        assertPath$2(path2);
-        let start2 = 0;
-        let end2 = -1;
-        let index2 = path2.length;
-        let seenNonSlash;
-        if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
-            while (index2--) {
-                if (path2.codePointAt(index2) === 47) {
-                    if (seenNonSlash) {
-                        start2 = index2 + 1;
-                        break;
-                    }
-                } else if (end2 < 0) {
-                    seenNonSlash = true;
-                    end2 = index2 + 1;
-                }
+        spread = re2(spread).source;
+        Prism2.languages.jsx = Prism2.languages.extend("markup", javascript);
+        Prism2.languages.jsx.tag.pattern = re2(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source);
+        Prism2.languages.jsx.tag.inside["tag"].pattern = /^<\/?[^\s>\/]*/;
+        Prism2.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
+        Prism2.languages.jsx.tag.inside["tag"].inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
+        Prism2.languages.jsx.tag.inside["comment"] = javascript["comment"];
+        Prism2.languages.insertBefore("inside", "attr-name", {
+            "spread": {
+                pattern: re2(/<SPREAD>/.source),
+                inside: Prism2.languages.jsx
             }
-            return end2 < 0 ? "" : path2.slice(start2, end2);
-        }
-        if (ext === path2) {
-            return "";
-        }
-        let firstNonSlashEnd = -1;
-        let extIndex = ext.length - 1;
-        while (index2--) {
-            if (path2.codePointAt(index2) === 47) {
-                if (seenNonSlash) {
-                    start2 = index2 + 1;
-                    break;
-                }
-            } else {
-                if (firstNonSlashEnd < 0) {
-                    seenNonSlash = true;
-                    firstNonSlashEnd = index2 + 1;
+        }, Prism2.languages.jsx.tag);
+        Prism2.languages.insertBefore("inside", "special-attr", {
+            "script": {
+                pattern: re2(/=<BRACES>/.source),
+                alias: "language-javascript",
+                inside: {
+                    "script-punctuation": {
+                        pattern: /^=(?=\{)/,
+                        alias: "punctuation"
+                    },
+                    rest: Prism2.languages.jsx
                 }
-                if (extIndex > -1) {
-                    if (path2.codePointAt(index2) === ext.codePointAt(extIndex--)) {
-                        if (extIndex < 0) {
-                            end2 = index2;
+            }
+        }, Prism2.languages.jsx.tag);
+        var stringifyToken = function(token) {
+            if (!token) {
+                return "";
+            }
+            if (typeof token === "string") {
+                return token;
+            }
+            if (typeof token.content === "string") {
+                return token.content;
+            }
+            return token.content.map(stringifyToken).join("");
+        };
+        var walkTokens = function(tokens2) {
+            var openedTags = [];
+            for (var i2 = 0; i2 < tokens2.length; i2++) {
+                var token = tokens2[i2];
+                var notTagNorBrace = false;
+                if (typeof token !== "string") {
+                    if (token.type === "tag" && token.content[0] && token.content[0].type === "tag") {
+                        if (token.content[0].content[0].content === "</") {
+                            if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {
+                                openedTags.pop();
+                            }
+                        } else {
+                            if (token.content[token.content.length - 1].content === "/>")
+                            ;
+                            else {
+                                openedTags.push({
+                                    tagName: stringifyToken(token.content[0].content[1]),
+                                    openedBraces: 0
+                                });
+                            }
                         }
+                    } else if (openedTags.length > 0 && token.type === "punctuation" && token.content === "{") {
+                        openedTags[openedTags.length - 1].openedBraces++;
+                    } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === "punctuation" && token.content === "}") {
+                        openedTags[openedTags.length - 1].openedBraces--;
                     } else {
-                        extIndex = -1;
-                        end2 = firstNonSlashEnd;
+                        notTagNorBrace = true;
                     }
                 }
-            }
-        }
-        if (start2 === end2) {
-            end2 = firstNonSlashEnd;
-        } else if (end2 < 0) {
-            end2 = path2.length;
-        }
-        return path2.slice(start2, end2);
-    }
-
-    function dirname(path2) {
-        assertPath$2(path2);
-        if (path2.length === 0) {
-            return ".";
-        }
-        let end2 = -1;
-        let index2 = path2.length;
-        let unmatchedSlash;
-        while (--index2) {
-            if (path2.codePointAt(index2) === 47) {
-                if (unmatchedSlash) {
-                    end2 = index2;
-                    break;
+                if (notTagNorBrace || typeof token === "string") {
+                    if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
+                        var plainText = stringifyToken(token);
+                        if (i2 < tokens2.length - 1 && (typeof tokens2[i2 + 1] === "string" || tokens2[i2 + 1].type === "plain-text")) {
+                            plainText += stringifyToken(tokens2[i2 + 1]);
+                            tokens2.splice(i2 + 1, 1);
+                        }
+                        if (i2 > 0 && (typeof tokens2[i2 - 1] === "string" || tokens2[i2 - 1].type === "plain-text")) {
+                            plainText = stringifyToken(tokens2[i2 - 1]) + plainText;
+                            tokens2.splice(i2 - 1, 1);
+                            i2--;
+                        }
+                        tokens2[i2] = new Prism2.Token("plain-text", plainText, null, plainText);
+                    }
                 }
-            } else if (!unmatchedSlash) {
-                unmatchedSlash = true;
-            }
-        }
-        return end2 < 0 ? path2.codePointAt(0) === 47 ? "/" : "." : end2 === 1 && path2.codePointAt(0) === 47 ? "//" : path2.slice(0, end2);
-    }
-
-    function extname(path2) {
-        assertPath$2(path2);
-        let index2 = path2.length;
-        let end2 = -1;
-        let startPart = 0;
-        let startDot = -1;
-        let preDotState = 0;
-        let unmatchedSlash;
-        while (index2--) {
-            const code2 = path2.codePointAt(index2);
-            if (code2 === 47) {
-                if (unmatchedSlash) {
-                    startPart = index2 + 1;
-                    break;
+                if (token.content && typeof token.content !== "string") {
+                    walkTokens(token.content);
                 }
-                continue;
             }
-            if (end2 < 0) {
-                unmatchedSlash = true;
-                end2 = index2 + 1;
+        };
+        Prism2.hooks.add("after-tokenize", function(env2) {
+            if (env2.language !== "jsx" && env2.language !== "tsx") {
+                return;
             }
-            if (code2 === 46) {
-                if (startDot < 0) {
-                    startDot = index2;
-                } else if (preDotState !== 1) {
-                    preDotState = 1;
-                }
-            } else if (startDot > -1) {
-                preDotState = -1;
+            walkTokens(env2.tokens);
+        });
+    })(prism);
+    (function(Prism2) {
+        Prism2.languages.diff = {
+            "coord": [
+                /^(?:\*{3}|-{3}|\+{3}).*$/m,
+                /^@@.*@@$/m,
+                /^\d.*$/m
+            ]
+        };
+        var PREFIXES2 = {
+            "deleted-sign": "-",
+            "deleted-arrow": "<",
+            "inserted-sign": "+",
+            "inserted-arrow": ">",
+            "unchanged": " ",
+            "diff": "!"
+        };
+        Object.keys(PREFIXES2).forEach(function(name2) {
+            var prefix = PREFIXES2[name2];
+            var alias = [];
+            if (!/^\w+$/.test(name2)) {
+                alias.push(/\w+/.exec(name2)[0]);
             }
-        }
-        if (startDot < 0 || end2 < 0 || preDotState === 0 || preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1) {
-            return "";
-        }
-        return path2.slice(startDot, end2);
-    }
-
-    function join(...segments) {
-        let index2 = -1;
-        let joined;
-        while (++index2 < segments.length) {
-            assertPath$2(segments[index2]);
-            if (segments[index2]) {
-                joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
+            if (name2 === "diff") {
+                alias.push("bold");
             }
+            Prism2.languages.diff[name2] = {
+                pattern: RegExp("^(?:[" + prefix + "].*(?:\r\n?|\n|(?![\\s\\S])))+", "m"),
+                alias,
+                inside: {
+                    "line": {
+                        pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
+                        lookbehind: true
+                    },
+                    "prefix": {
+                        pattern: /[\s\S]/,
+                        alias: /\w+/.exec(name2)[0]
+                    }
+                }
+            };
+        });
+        Object.defineProperty(Prism2.languages.diff, "PREFIXES", {
+            value: PREFIXES2
+        });
+    })(prism);
+    prism.languages.git = {
+        "comment": /^#.*/m,
+        "deleted": /^[-–].*/m,
+        "inserted": /^\+.*/m,
+        "string": /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
+        "command": {
+            pattern: /^.*\$ git .*$/m,
+            inside: {
+                "parameter": /\s--?\w+/
+            }
+        },
+        "coord": /^@@.*@@$/m,
+        "commit-sha1": /^commit \w{40}$/m
+    };
+    prism.languages.go = prism.languages.extend("clike", {
+        "string": {
+            pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
+            lookbehind: true,
+            greedy: true
+        },
+        "keyword": /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
+        "boolean": /\b(?:_|false|iota|nil|true)\b/,
+        "number": [
+            /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
+            /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
+            /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
+        ],
+        "operator": /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
+        "builtin": /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
+    });
+    prism.languages.insertBefore("go", "string", {
+        "char": {
+            pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
+            greedy: true
         }
-        return joined === void 0 ? "." : normalize$1(joined);
-    }
-
-    function normalize$1(path2) {
-        assertPath$2(path2);
-        const absolute = path2.codePointAt(0) === 47;
-        let value = normalizeString(path2, !absolute);
-        if (value.length === 0 && !absolute) {
-            value = ".";
-        }
-        if (value.length > 0 && path2.codePointAt(path2.length - 1) === 47) {
-            value += "/";
+    });
+    delete prism.languages.go["class-name"];
+    (function(Prism2) {
+        function getPlaceholder(language2, index2) {
+            return "___" + language2.toUpperCase() + index2 + "___";
         }
-        return absolute ? "/" + value : value;
-    }
+        Object.defineProperties(Prism2.languages["markup-templating"] = {}, {
+            buildPlaceholders: {
+                value: function(env2, language2, placeholderPattern, replaceFilter) {
+                    if (env2.language !== language2) {
+                        return;
+                    }
+                    var tokenStack = env2.tokenStack = [];
+                    env2.code = env2.code.replace(placeholderPattern, function(match2) {
+                        if (typeof replaceFilter === "function" && !replaceFilter(match2)) {
+                            return match2;
+                        }
+                        var i2 = tokenStack.length;
+                        var placeholder;
+                        while (env2.code.indexOf(placeholder = getPlaceholder(language2, i2)) !== -1) {
+                            ++i2;
+                        }
+                        tokenStack[i2] = match2;
+                        return placeholder;
+                    });
+                    env2.grammar = Prism2.languages.markup;
+                }
+            },
+            tokenizePlaceholders: {
+                value: function(env2, language2) {
+                    if (env2.language !== language2 || !env2.tokenStack) {
+                        return;
+                    }
+                    env2.grammar = Prism2.languages[language2];
+                    var j2 = 0;
+                    var keys2 = Object.keys(env2.tokenStack);
 
-    function normalizeString(path2, allowAboveRoot) {
-        let result = "";
-        let lastSegmentLength = 0;
-        let lastSlash = -1;
-        let dots = 0;
-        let index2 = -1;
-        let code2;
-        let lastSlashIndex;
-        while (++index2 <= path2.length) {
-            if (index2 < path2.length) {
-                code2 = path2.codePointAt(index2);
-            } else if (code2 === 47) {
-                break;
-            } else {
-                code2 = 47;
-            }
-            if (code2 === 47) {
-                if (lastSlash === index2 - 1 || dots === 1)
-                ;
-                else if (lastSlash !== index2 - 1 && dots === 2) {
-                    if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
-                        if (result.length > 2) {
-                            lastSlashIndex = result.lastIndexOf("/");
-                            if (lastSlashIndex !== result.length - 1) {
-                                if (lastSlashIndex < 0) {
-                                    result = "";
-                                    lastSegmentLength = 0;
-                                } else {
-                                    result = result.slice(0, lastSlashIndex);
-                                    lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
+                    function walkTokens(tokens2) {
+                        for (var i2 = 0; i2 < tokens2.length; i2++) {
+                            if (j2 >= keys2.length) {
+                                break;
+                            }
+                            var token = tokens2[i2];
+                            if (typeof token === "string" || token.content && typeof token.content === "string") {
+                                var k2 = keys2[j2];
+                                var t2 = env2.tokenStack[k2];
+                                var s2 = typeof token === "string" ? token : token.content;
+                                var placeholder = getPlaceholder(language2, k2);
+                                var index2 = s2.indexOf(placeholder);
+                                if (index2 > -1) {
+                                    ++j2;
+                                    var before = s2.substring(0, index2);
+                                    var middle = new Prism2.Token(language2, Prism2.tokenize(t2, env2.grammar), "language-" + language2, t2);
+                                    var after = s2.substring(index2 + placeholder.length);
+                                    var replacement = [];
+                                    if (before) {
+                                        replacement.push.apply(replacement, walkTokens([before]));
+                                    }
+                                    replacement.push(middle);
+                                    if (after) {
+                                        replacement.push.apply(replacement, walkTokens([after]));
+                                    }
+                                    if (typeof token === "string") {
+                                        tokens2.splice.apply(tokens2, [i2, 1].concat(replacement));
+                                    } else {
+                                        token.content = replacement;
+                                    }
                                 }
-                                lastSlash = index2;
-                                dots = 0;
-                                continue;
+                            } else if (token.content) {
+                                walkTokens(token.content);
                             }
-                        } else if (result.length > 0) {
-                            result = "";
-                            lastSegmentLength = 0;
-                            lastSlash = index2;
-                            dots = 0;
-                            continue;
                         }
+                        return tokens2;
                     }
-                    if (allowAboveRoot) {
-                        result = result.length > 0 ? result + "/.." : "..";
-                        lastSegmentLength = 2;
-                    }
-                } else {
-                    if (result.length > 0) {
-                        result += "/" + path2.slice(lastSlash + 1, index2);
-                    } else {
-                        result = path2.slice(lastSlash + 1, index2);
-                    }
-                    lastSegmentLength = index2 - lastSlash - 1;
+                    walkTokens(env2.tokens);
                 }
-                lastSlash = index2;
-                dots = 0;
-            } else if (code2 === 46 && dots > -1) {
-                dots++;
-            } else {
-                dots = -1;
             }
+        });
+    })(prism);
+    (function(Prism2) {
+        Prism2.languages.handlebars = {
+            "comment": /\{\{![\s\S]*?\}\}/,
+            "delimiter": {
+                pattern: /^\{\{\{?|\}\}\}?$/,
+                alias: "punctuation"
+            },
+            "string": /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
+            "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][+-]?\d+)?/,
+            "boolean": /\b(?:false|true)\b/,
+            "block": {
+                pattern: /^(\s*(?:~\s*)?)[#\/]\S+?(?=\s*(?:~\s*)?$|\s)/,
+                lookbehind: true,
+                alias: "keyword"
+            },
+            "brackets": {
+                pattern: /\[[^\]]+\]/,
+                inside: {
+                    punctuation: /\[|\]/,
+                    variable: /[\s\S]+/
+                }
+            },
+            "punctuation": /[!"#%&':()*+,.\/;<=>@\[\\\]^`{|}~]/,
+            "variable": /[^!"#%&'()*+,\/;<=>@\[\\\]^`{|}~\s]+/
+        };
+        Prism2.hooks.add("before-tokenize", function(env2) {
+            var handlebarsPattern = /\{\{\{[\s\S]+?\}\}\}|\{\{[\s\S]+?\}\}/g;
+            Prism2.languages["markup-templating"].buildPlaceholders(env2, "handlebars", handlebarsPattern);
+        });
+        Prism2.hooks.add("after-tokenize", function(env2) {
+            Prism2.languages["markup-templating"].tokenizePlaceholders(env2, "handlebars");
+        });
+        Prism2.languages.hbs = Prism2.languages.handlebars;
+    })(prism);
+    prism.languages.json = {
+        "property": {
+            pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
+            lookbehind: true,
+            greedy: true
+        },
+        "string": {
+            pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
+            lookbehind: true,
+            greedy: true
+        },
+        "comment": {
+            pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
+            greedy: true
+        },
+        "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
+        "punctuation": /[{}[\],]/,
+        "operator": /:/,
+        "boolean": /\b(?:false|true)\b/,
+        "null": {
+            pattern: /\bnull\b/,
+            alias: "keyword"
         }
-        return result;
-    }
-
-    function assertPath$2(path2) {
-        if (typeof path2 !== "string") {
-            throw new TypeError(
-                "Path must be a string. Received " + JSON.stringify(path2)
-            );
-        }
-    }
-    const proc = {
-        cwd
     };
-
-    function cwd() {
-        return "/";
-    }
-
-    function isUrl(fileUrlOrPath) {
-        return Boolean(
-            fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && fileUrlOrPath.auth === void 0
-        );
-    }
-
-    function urlToPath(path2) {
-        if (typeof path2 === "string") {
-            path2 = new URL(path2);
-        } else if (!isUrl(path2)) {
-            const error2 = new TypeError(
-                'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
-            );
-            error2.code = "ERR_INVALID_ARG_TYPE";
-            throw error2;
-        }
-        if (path2.protocol !== "file:") {
-            const error2 = new TypeError("The URL must be of scheme file");
-            error2.code = "ERR_INVALID_URL_SCHEME";
-            throw error2;
-        }
-        return getPathFromURLPosix(path2);
-    }
-
-    function getPathFromURLPosix(url2) {
-        if (url2.hostname !== "") {
-            const error2 = new TypeError(
-                'File URL host must be "localhost" or empty on darwin'
-            );
-            error2.code = "ERR_INVALID_FILE_URL_HOST";
-            throw error2;
-        }
-        const pathname = url2.pathname;
-        let index2 = -1;
-        while (++index2 < pathname.length) {
-            if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
-                const third = pathname.codePointAt(index2 + 2);
-                if (third === 70 || third === 102) {
-                    const error2 = new TypeError(
-                        "File URL path must not include encoded / characters"
-                    );
-                    error2.code = "ERR_INVALID_FILE_URL_PATH";
-                    throw error2;
+    prism.languages.webmanifest = prism.languages.json;
+    prism.languages.less = prism.languages.extend("css", {
+        "comment": [/\/\*[\s\S]*?\*\//, {
+            pattern: /(^|[^\\])\/\/.*/,
+            lookbehind: true
+        }],
+        "atrule": {
+            pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
+            inside: {
+                "punctuation": /[:()]/
+            }
+        },
+        "selector": {
+            pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
+            inside: {
+                "variable": /@+[\w-]+/
+            }
+        },
+        "property": /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
+        "operator": /[+\-*\/]/
+    });
+    prism.languages.insertBefore("less", "property", {
+        "variable": [{
+                pattern: /@[\w-]+\s*:/,
+                inside: {
+                    "punctuation": /:/
                 }
+            },
+            /@@?[\w-]+/
+        ],
+        "mixin-usage": {
+            pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
+            lookbehind: true,
+            alias: "function"
+        }
+    });
+    prism.languages.makefile = {
+        "comment": {
+            pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
+            lookbehind: true
+        },
+        "string": {
+            pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
+            greedy: true
+        },
+        "builtin-target": {
+            pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
+            alias: "builtin"
+        },
+        "target": {
+            pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
+            alias: "symbol",
+            inside: {
+                "variable": /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/
+            }
+        },
+        "variable": /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
+        "keyword": /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
+        "function": {
+            pattern: /(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
+            lookbehind: true
+        },
+        "operator": /(?:::|[?:+!])?=|[|@]/,
+        "punctuation": /[:;(){}]/
+    };
+    prism.languages.objectivec = prism.languages.extend("c", {
+        "string": {
+            pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
+            greedy: true
+        },
+        "keyword": /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
+        "operator": /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
+    });
+    delete prism.languages.objectivec["class-name"];
+    prism.languages.objc = prism.languages.objectivec;
+    prism.languages.ocaml = {
+        "comment": {
+            pattern: /\(\*[\s\S]*?\*\)/,
+            greedy: true
+        },
+        "char": {
+            pattern: /'(?:[^\\\r\n']|\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,
+            greedy: true
+        },
+        "string": [{
+            pattern: /"(?:\\(?:[\s\S]|\r\n)|[^\\\r\n"])*"/,
+            greedy: true
+        }, {
+            pattern: /\{([a-z_]*)\|[\s\S]*?\|\1\}/,
+            greedy: true
+        }],
+        "number": [
+            /\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\b/i,
+            /\b0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]*)?(?:p[+-]?\d[\d_]*)?(?!\w)/i,
+            /\b\d[\d_]*(?:\.[\d_]*)?(?:e[+-]?\d[\d_]*)?(?!\w)/i
+        ],
+        "directive": {
+            pattern: /\B#\w+/,
+            alias: "property"
+        },
+        "label": {
+            pattern: /\B~\w+/,
+            alias: "property"
+        },
+        "type-variable": {
+            pattern: /\B'\w+/,
+            alias: "function"
+        },
+        "variant": {
+            pattern: /`\w+/,
+            alias: "symbol"
+        },
+        "keyword": /\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\b/,
+        "boolean": /\b(?:false|true)\b/,
+        "operator-like-punctuation": {
+            pattern: /\[[<>|]|[>|]\]|\{<|>\}/,
+            alias: "punctuation"
+        },
+        "operator": /\.[.~]|:[=>]|[=<>@^|&+\-*\/$%!?~][!$%&*+\-.\/:<=>?@^|~]*|\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\b/,
+        "punctuation": /;;|::|[(){}\[\].,:;#]|\b_\b/
+    };
+    prism.languages.python = {
+        "comment": {
+            pattern: /(^|[^\\])#.*/,
+            lookbehind: true,
+            greedy: true
+        },
+        "string-interpolation": {
+            pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
+            greedy: true,
+            inside: {
+                "interpolation": {
+                    pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
+                    lookbehind: true,
+                    inside: {
+                        "format-spec": {
+                            pattern: /(:)[^:(){}]+(?=\}$)/,
+                            lookbehind: true
+                        },
+                        "conversion-option": {
+                            pattern: /![sra](?=[:}]$)/,
+                            alias: "punctuation"
+                        },
+                        rest: null
+                    }
+                },
+                "string": /[\s\S]+/
+            }
+        },
+        "triple-quoted-string": {
+            pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
+            greedy: true,
+            alias: "string"
+        },
+        "string": {
+            pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
+            greedy: true
+        },
+        "function": {
+            pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
+            lookbehind: true
+        },
+        "class-name": {
+            pattern: /(\bclass\s+)\w+/i,
+            lookbehind: true
+        },
+        "decorator": {
+            pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
+            lookbehind: true,
+            alias: ["annotation", "punctuation"],
+            inside: {
+                "punctuation": /\./
             }
+        },
+        "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
+        "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
+        "boolean": /\b(?:False|None|True)\b/,
+        "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
+        "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
+        "punctuation": /[{}[\];(),.:]/
+    };
+    prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = prism.languages.python;
+    prism.languages.py = prism.languages.python;
+    prism.languages.reason = prism.languages.extend("clike", {
+        "string": {
+            pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
+            greedy: true
+        },
+        "class-name": /\b[A-Z]\w*/,
+        "keyword": /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/,
+        "operator": /\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/
+    });
+    prism.languages.insertBefore("reason", "class-name", {
+        "char": {
+            pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/,
+            greedy: true
+        },
+        "constructor": /\b[A-Z]\w*\b(?!\s*\.)/,
+        "label": {
+            pattern: /\b[a-z]\w*(?=::)/,
+            alias: "symbol"
         }
-        return decodeURIComponent(pathname);
-    }
-    const order = [
-        "history",
-        "path",
-        "basename",
-        "stem",
-        "extname",
-        "dirname"
-    ];
-    class VFile {
-        constructor(value) {
-            let options;
-            if (!value) {
-                options = {};
-            } else if (isUrl(value)) {
-                options = {
-                    path: value
-                };
-            } else if (typeof value === "string" || isUint8Array$1(value)) {
-                options = {
-                    value
-                };
-            } else {
-                options = value;
+    });
+    delete prism.languages.reason.function;
+    (function(Prism2) {
+        Prism2.languages.sass = Prism2.languages.extend("css", {
+            "comment": {
+                pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
+                lookbehind: true,
+                greedy: true
             }
-            this.cwd = proc.cwd();
-            this.data = {};
-            this.history = [];
-            this.messages = [];
-            this.value;
-            this.map;
-            this.result;
-            this.stored;
-            let index2 = -1;
-            while (++index2 < order.length) {
-                const prop2 = order[index2];
-                if (prop2 in options && options[prop2] !== void 0 && options[prop2] !== null) {
-                    this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
+        });
+        Prism2.languages.insertBefore("sass", "atrule", {
+            "atrule-line": {
+                pattern: /^(?:[ \t]*)[@+=].+/m,
+                greedy: true,
+                inside: {
+                    "atrule": /(?:@[\w-]+|[+=])/
                 }
             }
-            let prop;
-            for (prop in options) {
-                if (!order.includes(prop)) {
-                    this[prop] = options[prop];
+        });
+        delete Prism2.languages.sass.atrule;
+        var variable = /\$[-\w]+|#\{\$[-\w]+\}/;
+        var operator2 = [/[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/, {
+            pattern: /(\s)-(?=\s)/,
+            lookbehind: true
+        }];
+        Prism2.languages.insertBefore("sass", "property", {
+            "variable-line": {
+                pattern: /^[ \t]*\$.+/m,
+                greedy: true,
+                inside: {
+                    "punctuation": /:/,
+                    "variable": variable,
+                    "operator": operator2
+                }
+            },
+            "property-line": {
+                pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
+                greedy: true,
+                inside: {
+                    "property": [/[^:\s]+(?=\s*:)/, {
+                        pattern: /(:)[^:\s]+/,
+                        lookbehind: true
+                    }],
+                    "punctuation": /:/,
+                    "variable": variable,
+                    "operator": operator2,
+                    "important": Prism2.languages.sass.important
                 }
             }
+        });
+        delete Prism2.languages.sass.property;
+        delete Prism2.languages.sass.important;
+        Prism2.languages.insertBefore("sass", "punctuation", {
+            "selector": {
+                pattern: /^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
+                lookbehind: true,
+                greedy: true
+            }
+        });
+    })(prism);
+    prism.languages.scss = prism.languages.extend("css", {
+        "comment": {
+            pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
+            lookbehind: true
+        },
+        "atrule": {
+            pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
+            inside: {
+                "rule": /@[\w-]+/
+            }
+        },
+        "url": /(?:[-a-z]+-)?url(?=\()/i,
+        "selector": {
+            pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
+            inside: {
+                "parent": {
+                    pattern: /&/,
+                    alias: "important"
+                },
+                "placeholder": /%[-\w]+/,
+                "variable": /\$[-\w]+|#\{\$[-\w]+\}/
+            }
+        },
+        "property": {
+            pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
+            inside: {
+                "variable": /\$[-\w]+|#\{\$[-\w]+\}/
+            }
         }
-        get basename() {
-            return typeof this.path === "string" ? path$2.basename(this.path) : void 0;
-        }
-        set basename(basename2) {
-            assertNonEmpty(basename2, "basename");
-            assertPart(basename2, "basename");
-            this.path = path$2.join(this.dirname || "", basename2);
-        }
-        get dirname() {
-            return typeof this.path === "string" ? path$2.dirname(this.path) : void 0;
-        }
-        set dirname(dirname2) {
-            assertPath$1(this.basename, "dirname");
-            this.path = path$2.join(dirname2 || "", this.basename);
-        }
-        get extname() {
-            return typeof this.path === "string" ? path$2.extname(this.path) : void 0;
+    });
+    prism.languages.insertBefore("scss", "atrule", {
+        "keyword": [/@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i, {
+            pattern: /( )(?:from|through)(?= )/,
+            lookbehind: true
+        }]
+    });
+    prism.languages.insertBefore("scss", "important", {
+        "variable": /\$[-\w]+|#\{\$[-\w]+\}/
+    });
+    prism.languages.insertBefore("scss", "function", {
+        "module-modifier": {
+            pattern: /\b(?:as|hide|show|with)\b/i,
+            alias: "keyword"
+        },
+        "placeholder": {
+            pattern: /%[-\w]+/,
+            alias: "selector"
+        },
+        "statement": {
+            pattern: /\B!(?:default|optional)\b/i,
+            alias: "keyword"
+        },
+        "boolean": /\b(?:false|true)\b/,
+        "null": {
+            pattern: /\bnull\b/,
+            alias: "keyword"
+        },
+        "operator": {
+            pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
+            lookbehind: true
         }
-        set extname(extname2) {
-            assertPart(extname2, "extname");
-            assertPath$1(this.dirname, "extname");
-            if (extname2) {
-                if (extname2.codePointAt(0) !== 46) {
-                    throw new Error("`extname` must start with `.`");
+    });
+    prism.languages.scss["atrule"].inside.rest = prism.languages.scss;
+    (function(Prism2) {
+        var unit = {
+            pattern: /(\b\d+)(?:%|[a-z]+)/,
+            lookbehind: true
+        };
+        var number2 = {
+            pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
+            lookbehind: true
+        };
+        var inside2 = {
+            "comment": {
+                pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
+                lookbehind: true
+            },
+            "url": {
+                pattern: /\burl\((["']?).*?\1\)/i,
+                greedy: true
+            },
+            "string": {
+                pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
+                greedy: true
+            },
+            "interpolation": null,
+            "func": null,
+            "important": /\B!(?:important|optional)\b/i,
+            "keyword": {
+                pattern: /(^|\s+)(?:(?:else|for|if|return|unless)(?=\s|$)|@[\w-]+)/,
+                lookbehind: true
+            },
+            "hexcode": /#[\da-f]{3,6}/i,
+            "color": [/\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i, {
+                pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
+                inside: {
+                    "unit": unit,
+                    "number": number2,
+                    "function": /[\w-]+(?=\()/,
+                    "punctuation": /[(),]/
                 }
-                if (extname2.includes(".", 1)) {
-                    throw new Error("`extname` cannot contain multiple dots");
+            }],
+            "entity": /\\[\da-f]{1,8}/i,
+            "unit": unit,
+            "boolean": /\b(?:false|true)\b/,
+            "operator": [
+                /~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.{2,3}|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/
+            ],
+            "number": number2,
+            "punctuation": /[{}()\[\];:,]/
+        };
+        inside2["interpolation"] = {
+            pattern: /\{[^\r\n}:]+\}/,
+            alias: "variable",
+            inside: {
+                "delimiter": {
+                    pattern: /^\{|\}$/,
+                    alias: "punctuation"
+                },
+                rest: inside2
+            }
+        };
+        inside2["func"] = {
+            pattern: /[\w-]+\([^)]*\).*/,
+            inside: {
+                "function": /^[^(]+/,
+                rest: inside2
+            }
+        };
+        Prism2.languages.stylus = {
+            "atrule-declaration": {
+                pattern: /(^[ \t]*)@.+/m,
+                lookbehind: true,
+                inside: {
+                    "atrule": /^@[\w-]+/,
+                    rest: inside2
+                }
+            },
+            "variable-declaration": {
+                pattern: /(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:\{[^{}]*\}|\S.*|$)/m,
+                lookbehind: true,
+                inside: {
+                    "variable": /^\S+/,
+                    rest: inside2
+                }
+            },
+            "statement": {
+                pattern: /(^[ \t]*)(?:else|for|if|return|unless)[ \t].+/m,
+                lookbehind: true,
+                inside: {
+                    "keyword": /^\S+/,
+                    rest: inside2
+                }
+            },
+            "property-declaration": {
+                pattern: /((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)(?!\s)[^{\r\n]*(?:;|[^{\r\n,]$(?!(?:\r?\n|\r)(?:\{|\2[ \t])))/m,
+                lookbehind: true,
+                inside: {
+                    "property": {
+                        pattern: /^[^\s:]+/,
+                        inside: {
+                            "interpolation": inside2.interpolation
+                        }
+                    },
+                    rest: inside2
+                }
+            },
+            "selector": {
+                pattern: /(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t])))/m,
+                lookbehind: true,
+                inside: {
+                    "interpolation": inside2.interpolation,
+                    "comment": inside2.comment,
+                    "punctuation": /[{},]/
                 }
+            },
+            "func": inside2.func,
+            "string": inside2.string,
+            "comment": {
+                pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
+                lookbehind: true,
+                greedy: true
+            },
+            "interpolation": inside2.interpolation,
+            "punctuation": /[{}()\[\];:.]/
+        };
+    })(prism);
+    (function(Prism2) {
+        var typescript = Prism2.util.clone(Prism2.languages.typescript);
+        Prism2.languages.tsx = Prism2.languages.extend("jsx", typescript);
+        delete Prism2.languages.tsx["parameter"];
+        delete Prism2.languages.tsx["literal-property"];
+        var tag = Prism2.languages.tsx.tag;
+        tag.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + tag.pattern.source + ")", tag.pattern.flags);
+        tag.lookbehind = true;
+    })(prism);
+    prism.languages.wasm = {
+        "comment": [/\(;[\s\S]*?;\)/, {
+            pattern: /;;.*/,
+            greedy: true
+        }],
+        "string": {
+            pattern: /"(?:\\[\s\S]|[^"\\])*"/,
+            greedy: true
+        },
+        "keyword": [{
+            pattern: /\b(?:align|offset)=/,
+            inside: {
+                "operator": /=/
             }
-            this.path = path$2.join(this.dirname, this.stem + (extname2 || ""));
-        }
-        get path() {
-            return this.history[this.history.length - 1];
-        }
-        set path(path2) {
-            if (isUrl(path2)) {
-                path2 = urlToPath(path2);
+        }, {
+            pattern: /\b(?:(?:f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|neg?|nearest|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|sqrt|store(?:8|16|32)?|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))?|memory\.(?:grow|size))\b/,
+            inside: {
+                "punctuation": /\./
             }
-            assertNonEmpty(path2, "path");
-            if (this.path !== path2) {
-                this.history.push(path2);
+        }, /\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\b/],
+        "variable": /\$[\w!#$%&'*+\-./:<=>?@\\^`|~]+/,
+        "number": /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/,
+        "punctuation": /[()]/
+    };
+    const prism$1 = prism;
+    var theme$2 = {
+        plain: {
+            backgroundColor: "#2a2734",
+            color: "#9a86fd"
+        },
+        styles: [{
+            types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
+            style: {
+                color: "#6c6783"
             }
-        }
-        get stem() {
-            return typeof this.path === "string" ? path$2.basename(this.path, this.extname) : void 0;
-        }
-        set stem(stem) {
-            assertNonEmpty(stem, "stem");
-            assertPart(stem, "stem");
-            this.path = path$2.join(this.dirname || "", stem + (this.extname || ""));
-        }
-        fail(causeOrReason, optionsOrParentOrPlace, origin) {
-            const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
-            message.fatal = true;
-            throw message;
-        }
-        info(causeOrReason, optionsOrParentOrPlace, origin) {
-            const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
-            message.fatal = void 0;
-            return message;
-        }
-        message(causeOrReason, optionsOrParentOrPlace, origin) {
-            const message = new VFileMessage(
-                causeOrReason,
-                optionsOrParentOrPlace,
-                origin
-            );
-            if (this.path) {
-                message.name = this.path + ":" + message.name;
-                message.file = this.path;
+        }, {
+            types: ["namespace"],
+            style: {
+                opacity: 0.7
             }
-            message.fatal = false;
-            this.messages.push(message);
-            return message;
-        }
-        toString(encoding) {
-            if (this.value === void 0) {
-                return "";
+        }, {
+            types: ["tag", "operator", "number"],
+            style: {
+                color: "#e09142"
             }
-            if (typeof this.value === "string") {
-                return this.value;
+        }, {
+            types: ["property", "function"],
+            style: {
+                color: "#9a86fd"
             }
-            const decoder = new TextDecoder(encoding || void 0);
-            return decoder.decode(this.value);
-        }
-    }
-
-    function assertPart(part, name2) {
-        if (part && part.includes(path$2.sep)) {
-            throw new Error(
-                "`" + name2 + "` cannot be a path: did not expect `" + path$2.sep + "`"
-            );
-        }
-    }
-
-    function assertNonEmpty(part, name2) {
-        if (!part) {
-            throw new Error("`" + name2 + "` cannot be empty");
-        }
-    }
+        }, {
+            types: ["tag-id", "selector", "atrule-id"],
+            style: {
+                color: "#eeebff"
+            }
+        }, {
+            types: ["attr-name"],
+            style: {
+                color: "#c4b9fe"
+            }
+        }, {
+            types: ["boolean", "string", "entity", "url", "attr-value", "keyword", "control", "directive", "unit", "statement", "regex", "atrule", "placeholder", "variable"],
+            style: {
+                color: "#ffcc99"
+            }
+        }, {
+            types: ["deleted"],
+            style: {
+                textDecorationLine: "line-through"
+            }
+        }, {
+            types: ["inserted"],
+            style: {
+                textDecorationLine: "underline"
+            }
+        }, {
+            types: ["italic"],
+            style: {
+                fontStyle: "italic"
+            }
+        }, {
+            types: ["important", "bold"],
+            style: {
+                fontWeight: "bold"
+            }
+        }, {
+            types: ["important"],
+            style: {
+                color: "#c4b9fe"
+            }
+        }]
+    };
+    const duotoneDark = theme$2;
+    var defaultProps = {
+        Prism: prism$1,
+        theme: duotoneDark
+    };
 
-    function assertPath$1(path2, name2) {
-        if (!path2) {
-            throw new Error("Setting `" + name2 + "` requires `path` to be set too");
+    function _defineProperty$l(obj, key, value) {
+        if (key in obj) {
+            Object.defineProperty(obj, key, {
+                value,
+                enumerable: true,
+                configurable: true,
+                writable: true
+            });
+        } else {
+            obj[key] = value;
         }
+        return obj;
     }
 
-    function isUint8Array$1(value) {
-        return Boolean(
-            value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
-        );
-    }
-    const CallableInstance = function(property) {
-        const self2 = this;
-        const constr = self2.constructor;
-        const proto2 = constr.prototype;
-        const func = proto2[property];
-        const apply = function() {
-            return func.apply(apply, arguments);
+    function _extends() {
+        _extends = Object.assign || function(target) {
+            for (var i2 = 1; i2 < arguments.length; i2++) {
+                var source = arguments[i2];
+                for (var key in source) {
+                    if (Object.prototype.hasOwnProperty.call(source, key)) {
+                        target[key] = source[key];
+                    }
+                }
+            }
+            return target;
         };
-        Object.setPrototypeOf(apply, proto2);
-        const names = Object.getOwnPropertyNames(func);
-        for (const p2 of names) {
-            const descriptor = Object.getOwnPropertyDescriptor(func, p2);
-            if (descriptor)
-                Object.defineProperty(apply, p2, descriptor);
+        return _extends.apply(this, arguments);
+    }
+    var newlineRe = /\r\n|\r|\n/;
+    var normalizeEmptyLines = function(line) {
+        if (line.length === 0) {
+            line.push({
+                types: ["plain"],
+                content: "\n",
+                empty: true
+            });
+        } else if (line.length === 1 && line[0].content === "") {
+            line[0].content = "\n";
+            line[0].empty = true;
         }
-        return apply;
     };
-    const own$4 = {}.hasOwnProperty;
-    class Processor extends CallableInstance {
-        constructor() {
-            super("copy");
-            this.Compiler = void 0;
-            this.Parser = void 0;
-            this.attachers = [];
-            this.compiler = void 0;
-            this.freezeIndex = -1;
-            this.frozen = void 0;
-            this.namespace = {};
-            this.parser = void 0;
-            this.transformers = trough();
-        }
-        copy() {
-            const destination = new Processor();
-            let index2 = -1;
-            while (++index2 < this.attachers.length) {
-                const attacher = this.attachers[index2];
-                destination.use(...attacher);
-            }
-            destination.data(extend$3(true, {}, this.namespace));
-            return destination;
+    var appendTypes = function(types2, add2) {
+        var typesSize = types2.length;
+        if (typesSize > 0 && types2[typesSize - 1] === add2) {
+            return types2;
         }
-        data(key, value) {
-            if (typeof key === "string") {
-                if (arguments.length === 2) {
-                    assertUnfrozen("data", this.frozen);
-                    this.namespace[key] = value;
-                    return this;
+        return types2.concat(add2);
+    };
+    var normalizeTokens = function(tokens2) {
+        var typeArrStack = [
+            []
+        ];
+        var tokenArrStack = [tokens2];
+        var tokenArrIndexStack = [0];
+        var tokenArrSizeStack = [tokens2.length];
+        var i2 = 0;
+        var stackIndex = 0;
+        var currentLine = [];
+        var acc = [currentLine];
+        while (stackIndex > -1) {
+            while ((i2 = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {
+                var content2 = void 0;
+                var types2 = typeArrStack[stackIndex];
+                var tokenArr = tokenArrStack[stackIndex];
+                var token = tokenArr[i2];
+                if (typeof token === "string") {
+                    types2 = stackIndex > 0 ? types2 : ["plain"];
+                    content2 = token;
+                } else {
+                    types2 = appendTypes(types2, token.type);
+                    if (token.alias) {
+                        types2 = appendTypes(types2, token.alias);
+                    }
+                    content2 = token.content;
                 }
-                return own$4.call(this.namespace, key) && this.namespace[key] || void 0;
-            }
-            if (key) {
-                assertUnfrozen("data", this.frozen);
-                this.namespace = key;
-                return this;
-            }
-            return this.namespace;
-        }
-        freeze() {
-            if (this.frozen) {
-                return this;
-            }
-            const self2 = this;
-            while (++this.freezeIndex < this.attachers.length) {
-                const [attacher, ...options] = this.attachers[this.freezeIndex];
-                if (options[0] === false) {
+                if (typeof content2 !== "string") {
+                    stackIndex++;
+                    typeArrStack.push(types2);
+                    tokenArrStack.push(content2);
+                    tokenArrIndexStack.push(0);
+                    tokenArrSizeStack.push(content2.length);
                     continue;
                 }
-                if (options[0] === true) {
-                    options[0] = void 0;
-                }
-                const transformer = attacher.call(self2, ...options);
-                if (typeof transformer === "function") {
-                    this.transformers.use(transformer);
+                var splitByNewlines = content2.split(newlineRe);
+                var newlineCount = splitByNewlines.length;
+                currentLine.push({
+                    types: types2,
+                    content: splitByNewlines[0]
+                });
+                for (var i$12 = 1; i$12 < newlineCount; i$12++) {
+                    normalizeEmptyLines(currentLine);
+                    acc.push(currentLine = []);
+                    currentLine.push({
+                        types: types2,
+                        content: splitByNewlines[i$12]
+                    });
                 }
             }
-            this.frozen = true;
-            this.freezeIndex = Number.POSITIVE_INFINITY;
-            return this;
-        }
-        parse(file) {
-            this.freeze();
-            const realFile = vfile(file);
-            const parser2 = this.parser || this.Parser;
-            assertParser("parse", parser2);
-            return parser2(String(realFile), realFile);
+            stackIndex--;
+            typeArrStack.pop();
+            tokenArrStack.pop();
+            tokenArrIndexStack.pop();
+            tokenArrSizeStack.pop();
         }
-        process(file, done) {
-            const self2 = this;
-            this.freeze();
-            assertParser("process", this.parser || this.Parser);
-            assertCompiler("process", this.compiler || this.Compiler);
-            return done ? executor(void 0, done) : new Promise(executor);
+        normalizeEmptyLines(currentLine);
+        return acc;
+    };
+    var themeToDict = function(theme2, language2) {
+        var plain = theme2.plain;
+        var base2 = /* @__PURE__ */ Object.create(null);
+        var themeDict = theme2.styles.reduce(function(acc, themeEntry) {
+            var languages = themeEntry.languages;
+            var style2 = themeEntry.style;
+            if (languages && !languages.includes(language2)) {
+                return acc;
+            }
+            themeEntry.types.forEach(function(type2) {
+                var accStyle = _extends({}, acc[type2], style2);
+                acc[type2] = accStyle;
+            });
+            return acc;
+        }, base2);
+        themeDict.root = plain;
+        themeDict.plain = _extends({}, plain, {
+            backgroundColor: null
+        });
+        return themeDict;
+    };
 
-            function executor(resolve2, reject) {
-                const realFile = vfile(file);
-                const parseTree = self2.parse(realFile);
-                self2.run(parseTree, realFile, function(error2, tree, file2) {
-                    if (error2 || !tree || !file2) {
-                        return realDone(error2);
-                    }
-                    const compileTree = tree;
-                    const compileResult = self2.stringify(compileTree, file2);
-                    if (looksLikeAValue(compileResult)) {
-                        file2.value = compileResult;
-                    } else {
-                        file2.result = compileResult;
-                    }
-                    realDone(error2, file2);
+    function objectWithoutProperties(obj, exclude) {
+        var target = {};
+        for (var k2 in obj)
+            if (Object.prototype.hasOwnProperty.call(obj, k2) && exclude.indexOf(k2) === -1)
+                target[k2] = obj[k2];
+        return target;
+    }
+    var Highlight = /* @__PURE__ */ function(Component) {
+        function Highlight2() {
+            var this$1$1 = this;
+            var args = [],
+                len = arguments.length;
+            while (len--)
+                args[len] = arguments[len];
+            Component.apply(this, args);
+            _defineProperty$l(this, "getThemeDict", function(props) {
+                if (this$1$1.themeDict !== void 0 && props.theme === this$1$1.prevTheme && props.language === this$1$1.prevLanguage) {
+                    return this$1$1.themeDict;
+                }
+                this$1$1.prevTheme = props.theme;
+                this$1$1.prevLanguage = props.language;
+                var themeDict = props.theme ? themeToDict(props.theme, props.language) : void 0;
+                return this$1$1.themeDict = themeDict;
+            });
+            _defineProperty$l(this, "getLineProps", function(ref2) {
+                var key = ref2.key;
+                var className = ref2.className;
+                var style2 = ref2.style;
+                var rest$1 = objectWithoutProperties(ref2, ["key", "className", "style", "line"]);
+                var rest = rest$1;
+                var output2 = _extends({}, rest, {
+                    className: "token-line",
+                    style: void 0,
+                    key: void 0
                 });
-
-                function realDone(error2, file2) {
-                    if (error2 || !file2) {
-                        reject(error2);
-                    } else if (resolve2) {
-                        resolve2(file2);
-                    } else {
-                        done(void 0, file2);
-                    }
+                var themeDict = this$1$1.getThemeDict(this$1$1.props);
+                if (themeDict !== void 0) {
+                    output2.style = themeDict.plain;
                 }
-            }
+                if (style2 !== void 0) {
+                    output2.style = output2.style !== void 0 ? _extends({}, output2.style, style2) : style2;
+                }
+                if (key !== void 0) {
+                    output2.key = key;
+                }
+                if (className) {
+                    output2.className += " " + className;
+                }
+                return output2;
+            });
+            _defineProperty$l(this, "getStyleForToken", function(ref2) {
+                var types2 = ref2.types;
+                var empty2 = ref2.empty;
+                var typesSize = types2.length;
+                var themeDict = this$1$1.getThemeDict(this$1$1.props);
+                if (themeDict === void 0) {
+                    return void 0;
+                } else if (typesSize === 1 && types2[0] === "plain") {
+                    return empty2 ? {
+                        display: "inline-block"
+                    } : void 0;
+                } else if (typesSize === 1 && !empty2) {
+                    return themeDict[types2[0]];
+                }
+                var baseStyle = empty2 ? {
+                    display: "inline-block"
+                } : {};
+                var typeStyles = types2.map(function(type2) {
+                    return themeDict[type2];
+                });
+                return Object.assign.apply(Object, [baseStyle].concat(typeStyles));
+            });
+            _defineProperty$l(this, "getTokenProps", function(ref2) {
+                var key = ref2.key;
+                var className = ref2.className;
+                var style2 = ref2.style;
+                var token = ref2.token;
+                var rest$1 = objectWithoutProperties(ref2, ["key", "className", "style", "token"]);
+                var rest = rest$1;
+                var output2 = _extends({}, rest, {
+                    className: "token " + token.types.join(" "),
+                    children: token.content,
+                    style: this$1$1.getStyleForToken(token),
+                    key: void 0
+                });
+                if (style2 !== void 0) {
+                    output2.style = output2.style !== void 0 ? _extends({}, output2.style, style2) : style2;
+                }
+                if (key !== void 0) {
+                    output2.key = key;
+                }
+                if (className) {
+                    output2.className += " " + className;
+                }
+                return output2;
+            });
+            _defineProperty$l(this, "tokenize", function(Prism2, code2, grammar, language2) {
+                var env2 = {
+                    code: code2,
+                    grammar,
+                    language: language2,
+                    tokens: []
+                };
+                Prism2.hooks.run("before-tokenize", env2);
+                var tokens2 = env2.tokens = Prism2.tokenize(env2.code, env2.grammar, env2.language);
+                Prism2.hooks.run("after-tokenize", env2);
+                return tokens2;
+            });
         }
-        processSync(file) {
-            let complete = false;
-            let result;
-            this.freeze();
-            assertParser("processSync", this.parser || this.Parser);
-            assertCompiler("processSync", this.compiler || this.Compiler);
-            this.process(file, realDone);
-            assertDone("processSync", "process", complete);
-            return result;
-
-            function realDone(error2, file2) {
-                complete = true;
-                bail(error2);
-                result = file2;
+        if (Component)
+            Highlight2.__proto__ = Component;
+        Highlight2.prototype = Object.create(Component && Component.prototype);
+        Highlight2.prototype.constructor = Highlight2;
+        Highlight2.prototype.render = function render2() {
+            var ref2 = this.props;
+            var Prism2 = ref2.Prism;
+            var language2 = ref2.language;
+            var code2 = ref2.code;
+            var children2 = ref2.children;
+            var themeDict = this.getThemeDict(this.props);
+            var grammar = Prism2.languages[language2];
+            var mixedTokens = grammar !== void 0 ? this.tokenize(Prism2, code2, grammar, language2) : [code2];
+            var tokens2 = normalizeTokens(mixedTokens);
+            return children2({
+                tokens: tokens2,
+                className: "prism-code language-" + language2,
+                style: themeDict !== void 0 ? themeDict.root : {},
+                getLineProps: this.getLineProps,
+                getTokenProps: this.getTokenProps
+            });
+        };
+        return Highlight2;
+    }(React.Component);
+    const Highlight$1 = Highlight;
+    var theme$1 = {
+        plain: {
+            backgroundColor: "#faf8f5",
+            color: "#728fcb"
+        },
+        styles: [{
+            types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
+            style: {
+                color: "#b6ad9a"
             }
-        }
-        run(tree, file, done) {
-            assertNode(tree);
-            this.freeze();
-            const transformers = this.transformers;
-            if (!done && typeof file === "function") {
-                done = file;
-                file = void 0;
+        }, {
+            types: ["namespace"],
+            style: {
+                opacity: 0.7
             }
-            return done ? executor(void 0, done) : new Promise(executor);
+        }, {
+            types: ["tag", "operator", "number"],
+            style: {
+                color: "#063289"
+            }
+        }, {
+            types: ["property", "function"],
+            style: {
+                color: "#b29762"
+            }
+        }, {
+            types: ["tag-id", "selector", "atrule-id"],
+            style: {
+                color: "#2d2006"
+            }
+        }, {
+            types: ["attr-name"],
+            style: {
+                color: "#896724"
+            }
+        }, {
+            types: ["boolean", "string", "entity", "url", "attr-value", "keyword", "control", "directive", "unit", "statement", "regex", "atrule"],
+            style: {
+                color: "#728fcb"
+            }
+        }, {
+            types: ["placeholder", "variable"],
+            style: {
+                color: "#93abdc"
+            }
+        }, {
+            types: ["deleted"],
+            style: {
+                textDecorationLine: "line-through"
+            }
+        }, {
+            types: ["inserted"],
+            style: {
+                textDecorationLine: "underline"
+            }
+        }, {
+            types: ["italic"],
+            style: {
+                fontStyle: "italic"
+            }
+        }, {
+            types: ["important", "bold"],
+            style: {
+                fontWeight: "bold"
+            }
+        }, {
+            types: ["important"],
+            style: {
+                color: "#896724"
+            }
+        }]
+    };
+    const duotoneLight = theme$1;
+    const StyledPre = styled__default.default.pre`
+    min-width: fit-content;
+    margin: 0;
+    padding: 1rem;
 
-            function executor(resolve2, reject) {
-                const realFile = vfile(file);
-                transformers.run(tree, realFile, realDone);
+    background-color: ${(props) => props.isLightTheme ? theme$3.colors.blue1 : darkTheme$1.colors.blue1} !important;
+    border-radius: 0.25rem;
+`;
+    const StyledCode = core$2.injectCss(StyledPre);
 
-                function realDone(error2, outputTree, file2) {
-                    const resultingTree = outputTree || tree;
-                    if (error2) {
-                        reject(error2);
-                    } else if (resolve2) {
-                        resolve2(resultingTree);
-                    } else {
-                        done(void 0, resultingTree, file2);
-                    }
+    function Code(props) {
+        const themeCtx = useClTheme();
+        const [rootStyle, css2] = core$2.useComponentStyles(props);
+        const [code2] = core$2.useVariable(props.code);
+
+        function getTheme() {
+            if (props.theme) {
+                if (props.theme === "light") {
+                    return duotoneLight;
                 }
+                return duotoneDark;
             }
+            if (themeCtx.themeType === "dark") {
+                return duotoneDark;
+            }
+            return duotoneLight;
         }
-        runSync(tree, file) {
-            let complete = false;
-            let result;
-            this.run(tree, file, realDone);
-            assertDone("runSync", "run", complete);
-            return result;
+        return /* @__PURE__ */ React__default.default.createElement(Highlight$1, {
+            ...defaultProps,
+            code: code2,
+            language: props.language,
+            theme: getTheme()
+        }, ({
+            className,
+            style: style2,
+            tokens: tokens2,
+            getLineProps,
+            getTokenProps
+        }) => /* @__PURE__ */ React__default.default.createElement(
+            StyledCode, {
+                $rawCss: css2,
+                className,
+                isLightTheme: props.theme !== "dark",
+                style: {
+                    ...rootStyle,
+                    ...style2
+                }
+            },
+            tokens2.map((line, i2) => /* @__PURE__ */ React__default.default.createElement("div", {
+                ...getLineProps({
+                    key: i2,
+                    line
+                }),
+                key: i2
+            }, line.map((token, key) => /* @__PURE__ */ React__default.default.createElement("span", {
+                ...getTokenProps({
+                    key,
+                    token
+                }),
+                key
+            }))))
+        ));
+    }
+    const StyledComponentSelectList = core$2.injectCss(ComponentSelectList$1);
 
-            function realDone(error2, tree2) {
-                bail(error2);
-                result = tree2;
-                complete = true;
+    function ComponentSelectList(props) {
+        const [style2, css2] = core$2.useComponentStyles(props);
+        const [selectedItems, setSelectedItems] = core$2.useVariable(props.selected_items);
+        const [onSelect] = core$2.useAction(props.on_select);
+        const updateSelectedItems2 = React.useCallback(
+            (items) => {
+                const newSelectedItems = props.multi_select ? items : items[0] || null;
+                setSelectedItems == null ? void 0 : setSelectedItems(newSelectedItems);
+                onSelect == null ? void 0 : onSelect(newSelectedItems);
+            },
+            [onSelect, props.multi_select, setSelectedItems]
+        );
+        const remappedItems = props.items.map((item) => {
+            return {
+                ...item,
+                component: /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
+                    component: item.component
+                })
+            };
+        });
+        return /* @__PURE__ */ React__default.default.createElement(
+            StyledComponentSelectList, {
+                $rawCss: css2,
+                items: remappedItems,
+                itemsPerRow: props.items_per_row,
+                multiSelect: props.multi_select,
+                onSelect: updateSelectedItems2,
+                selectedItems: selectedItems && castArray_1(selectedItems),
+                style: style2
             }
+        );
+    }
+    const DatepickerDiv = styled__default.default.div`
+    display: flex;
+    flex-direction: row;
+    align-items: center;
+`;
+    const StyledDatepickerDiv = core$2.injectCss(DatepickerDiv);
+
+    function parseDateString$1(date) {
+        if (!date) {
+            return;
         }
-        stringify(tree, file) {
-            this.freeze();
-            const realFile = vfile(file);
-            const compiler2 = this.compiler || this.Compiler;
-            assertCompiler("stringify", compiler2);
-            assertNode(tree);
-            return compiler2(tree, realFile);
+        if (date instanceof Date) {
+            return date;
         }
-        use(value, ...parameters) {
-            const attachers = this.attachers;
-            const namespace2 = this.namespace;
-            assertUnfrozen("use", this.frozen);
-            if (value === null || value === void 0)
-            ;
-            else if (typeof value === "function") {
-                addPlugin(value, parameters);
-            } else if (typeof value === "object") {
-                if (Array.isArray(value)) {
-                    addList(value);
-                } else {
-                    addPreset(value);
-                }
-            } else {
-                throw new TypeError("Expected usable value, not `" + value + "`");
-            }
-            return this;
+        const parsed = parseISO$1(date);
+        if (Number.isNaN(parsed.getTime())) {
+            return;
+        }
+        return parsed;
+    }
 
-            function add2(value2) {
-                if (typeof value2 === "function") {
-                    addPlugin(value2, []);
-                } else if (typeof value2 === "object") {
-                    if (Array.isArray(value2)) {
-                        const [plugin, ...parameters2] = value2;
-                        addPlugin(plugin, parameters2);
-                    } else {
-                        addPreset(value2);
-                    }
+    function Datepicker(props) {
+        const formCtx2 = useFormContext(props);
+        const [style2, css2] = core$2.useComponentStyles(props);
+        const [value, setValue] = core$2.useVariable(formCtx2.resolveInitialValue());
+        const [onChangeAction] = core$2.useAction(props.onchange);
+        const isFirstRender = React.useRef(true);
+        const onChange2 = (date) => {
+            if (!isFirstRender.current && (!Array.isArray(date) && date || Array.isArray(date) && date[0] && date[1])) {
+                let newDate;
+                if (Array.isArray(date)) {
+                    newDate = [formatISO(date[0]), formatISO(date[1])];
                 } else {
-                    throw new TypeError("Expected usable value, not `" + value2 + "`");
+                    newDate = formatISO(date);
                 }
+                setValue(newDate);
+                onChangeAction(newDate);
+                formCtx2.updateForm(newDate);
+            }
+        };
+        React.useEffect(() => {
+            if (isFirstRender.current) {
+                isFirstRender.current = false;
             }
+        }, []);
+        const formattedValue = React.useMemo(() => {
+            if (props.range && value) {
+                return [parseDateString$1(value == null ? void 0 : value[0]), parseDateString$1(value == null ? void 0 : value[1])];
+            }
+            return parseDateString$1(value);
+        }, [value, props.range]);
+        return /* @__PURE__ */ React__default.default.createElement(StyledDatepickerDiv, {
+            $rawCss: css2,
+            style: style2
+        }, /* @__PURE__ */ React__default.default.createElement(
+            DatePicker, {
+                dateFormat: props.date_format,
+                maxDate: parseDateString$1(props.max_date),
+                minDate: parseDateString$1(props.min_date),
+                onChange: onChange2,
+                popperStrategy: "fixed",
+                selectsRange: props.range,
+                shouldCloseOnSelect: props.select_close,
+                showTimeInput: props.enable_time,
+                value: formattedValue
+            }
+        ));
+    }
+    const status = {
+        FAILED: "FAILED",
+        INITIALIZED: "INITIALIZED",
+        LOADING: "LOADING",
+        SUCCESS: "SUCCESS"
+    };
+    const StyledCheck = styled__default.default(Check)`
+    color: ${(props) => props.theme.colors.success};
+`;
+    const Heading$2 = styled__default.default.h2`
+    margin-bottom: 1rem;
+    color: ${(props) => props.theme.colors.text};
+`;
+    async function uploadFileToExtension(file, extras, variableId, resolver_id) {
+        const formData = new FormData();
+        formData.append("data", file);
+        if (resolver_id) {
+            formData.append("resolver_id", resolver_id);
+        }
+        const url2 = new URL("/api/core/data/upload", window.location.origin);
+        if (variableId) {
+            url2.searchParams.set("data_uid", variableId);
+        }
+        const res = await core$2.request(
+            url2, {
+                body: formData,
+                method: HTTP_METHOD.POST
+            },
+            extras
+        );
+        await core$2.handleAuthErrors(res, true);
+        await validateResponse(res, `Failed to upload file: ${file.name}`);
+        const result = await res.json();
+        return {
+            newStatus: result.status
+        };
+    }
+    const StyledDropzone = core$2.injectCss(UploadDropzone$1);
+    const StyledCenter = core$2.injectCss(core$2.Center);
 
-            function addPreset(result) {
-                if (!("plugins" in result) && !("settings" in result)) {
-                    throw new Error(
-                        "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
+    function UploadDropzone(props) {
+        const theme2 = useClTheme();
+        const [style2, css2] = core$2.useComponentStyles(props);
+        const [currentStatus, setCurrentStatus] = React.useState(status.INITIALIZED);
+        const [errorMessage, setErrorMessage] = React.useState();
+        const [onFileDrop] = core$2.useAction(props.on_drop);
+        const extras = core$2.useRequestExtras();
+        const onDrop = async (acceptedFiles) => {
+            var _a3;
+            if (acceptedFiles.length === 1) {
+                setCurrentStatus(status.LOADING);
+                try {
+                    const {
+                        newStatus
+                    } = await uploadFileToExtension(
+                        acceptedFiles[0],
+                        extras,
+                        (_a3 = props.target) == null ? void 0 : _a3.uid,
+                        props.resolver_id
                     );
+                    setCurrentStatus(newStatus);
+                } catch (err) {
+                    setErrorMessage(err.message);
+                    setCurrentStatus(status.FAILED);
+                    throw err;
                 }
-                addList(result.plugins);
-                if (result.settings) {
-                    namespace2.settings = extend$3(true, namespace2.settings, result.settings);
-                }
+                onFileDrop(acceptedFiles[0]);
+            } else {
+                setErrorMessage("Upload failed. Please individually drop CSV files");
+                setCurrentStatus(status.FAILED);
             }
-
-            function addList(plugins2) {
-                let index2 = -1;
-                if (plugins2 === null || plugins2 === void 0)
-                ;
-                else if (Array.isArray(plugins2)) {
-                    while (++index2 < plugins2.length) {
-                        const thing = plugins2[index2];
-                        add2(thing);
-                    }
-                } else {
-                    throw new TypeError("Expected a list of plugins, not `" + plugins2 + "`");
+        };
+        const onReset = () => {
+            setCurrentStatus(status.INITIALIZED);
+            setErrorMessage(void 0);
+        };
+        if (currentStatus === status.SUCCESS) {
+            return /* @__PURE__ */ React__default.default.createElement(StyledCenter, {
+                $rawCss: css2,
+                style: style2
+            }, /* @__PURE__ */ React__default.default.createElement(StyledCheck, {
+                size: "10x"
+            }), /* @__PURE__ */ React__default.default.createElement(Heading$2, null, "Upload Successful"), /* @__PURE__ */ React__default.default.createElement(Button$3, {
+                onClick: onReset,
+                styling: "secondary"
+            }, "Upload Again"));
+        }
+        if (currentStatus === status.FAILED) {
+            return /* @__PURE__ */ React__default.default.createElement(StyledCenter, {
+                $rawCss: css2,
+                style: style2
+            }, /* @__PURE__ */ React__default.default.createElement("span", {
+                style: {
+                    color: theme2.colors.error,
+                    textAlign: "center"
                 }
+            }, errorMessage), /* @__PURE__ */ React__default.default.createElement(Heading$2, null, "Upload Failed"), /* @__PURE__ */ React__default.default.createElement(Button$3, {
+                onClick: onReset,
+                styling: "ghost"
+            }, "Upload Again"));
+        }
+        if (currentStatus === status.LOADING) {
+            return /* @__PURE__ */ React__default.default.createElement(core$2.DefaultFallback, null);
+        }
+        return /* @__PURE__ */ React__default.default.createElement(
+            StyledDropzone, {
+                $rawCss: css2,
+                accept: props.accept,
+                enablePaste: props.enable_paste,
+                onDrop,
+                style: style2
             }
+        );
+    }
+    const GridComponent = styled__default.default.div`
+    display: flex;
+    flex: 1 1 auto;
+    flex-direction: column;
+`;
+    const StyledGrid = core$2.injectCss(GridComponent);
 
-            function addPlugin(plugin, parameters2) {
-                let index2 = -1;
-                let entryIndex = -1;
-                while (++index2 < attachers.length) {
-                    if (attachers[index2][0] === plugin) {
-                        entryIndex = index2;
-                        break;
-                    }
+    function Grid(props) {
+        var _a3, _b, _c, _d, _e2, _f, _g, _h, _i2, _j;
+        const breakpoints = {
+            lg: (_b = (_a3 = props == null ? void 0 : props.breakpoints) == null ? void 0 : _a3.lg) != null ? _b : 992,
+            md: (_d = (_c = props == null ? void 0 : props.breakpoints) == null ? void 0 : _c.md) != null ? _d : 768,
+            sm: (_f = (_e2 = props == null ? void 0 : props.breakpoints) == null ? void 0 : _e2.sm) != null ? _f : 576,
+            xl: (_h = (_g = props == null ? void 0 : props.breakpoints) == null ? void 0 : _g.xl) != null ? _h : 1200,
+            xs: (_j = (_i2 = props == null ? void 0 : props.breakpoints) == null ? void 0 : _i2.xs) != null ? _j : 0
+        };
+        const [style2, css2] = core$2.useComponentStyles(props);
+        const _children = props.children.map((child) => {
+            return {
+                ...child,
+                props: {
+                    ...child.props,
+                    breakpoints,
+                    row_gap: props.row_gap
                 }
-                if (entryIndex === -1) {
-                    attachers.push([plugin, ...parameters2]);
-                } else if (parameters2.length > 0) {
-                    let [primary, ...rest] = parameters2;
-                    const currentPrimary = attachers[entryIndex][1];
-                    if (isPlainObject$3(currentPrimary) && isPlainObject$3(primary)) {
-                        primary = extend$3(true, currentPrimary, primary);
-                    }
-                    attachers[entryIndex] = [plugin, primary, ...rest];
+            };
+        });
+        return /* @__PURE__ */ React__default.default.createElement(
+            StyledGrid, {
+                $rawCss: css2,
+                className: props.className,
+                style: {
+                    alignItems: props.align,
+                    justifyContent: props.justify,
+                    rowGap: props.row_gap,
+                    ...style2
                 }
-            }
-        }
-    }
-    const unified = new Processor().freeze();
-
-    function assertParser(name2, value) {
-        if (typeof value !== "function") {
-            throw new TypeError("Cannot `" + name2 + "` without `parser`");
-        }
+            },
+            /* @__PURE__ */
+            React__default.default.createElement(core$2.DisplayCtx.Provider, {
+                value: {
+                    component: "grid",
+                    direction: "vertical",
+                    hug: props.hug
+                }
+            }, _children.map((child, idx) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
+                component: child,
+                key: `grid-${idx}-${child.uid}`
+            })))
+        );
     }
+    const StyledTag$1 = core$2.injectCss("h1");
+    const anchorName = (text2) => text2.toLowerCase().replace(/\s+/g, "-");
 
-    function assertCompiler(name2, value) {
-        if (typeof value !== "function") {
-            throw new TypeError("Cannot `" + name2 + "` without `compiler`");
-        }
+    function Heading$1(props) {
+        const theme2 = useClTheme();
+        const [style2, css2] = core$2.useComponentStyles(props);
+        const [heading2] = core$2.useVariable(props.heading);
+        const tag = `h${props.level}`;
+        return /* @__PURE__ */ React__default.default.createElement(
+            StyledTag$1, {
+                $rawCss: css2,
+                as: tag,
+                className: props.className,
+                id: anchorName(heading2),
+                style: {
+                    color: theme2.colors.text,
+                    textAlign: props.align,
+                    ...style2
+                }
+            },
+            heading2
+        );
     }
+    const _Wrapper = styled__default.default.div`
+    display: flex;
+    width: 100%;
+    height: 100%;
+`;
+    const Wrapper$3 = core$2.injectCss(_Wrapper);
 
-    function assertUnfrozen(name2, frozen) {
-        if (frozen) {
-            throw new Error(
-                "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
-            );
-        }
+    function HtmlRaw(props) {
+        const [style2, css2] = core$2.useComponentStyles(props);
+        return /* @__PURE__ */ React__default.default.createElement(
+            Wrapper$3, {
+                $rawCss: css2,
+                className: props.className,
+                dangerouslySetInnerHTML: {
+                    __html: props.html
+                },
+                style: style2
+            }
+        );
     }
+    const ButtonWrapper = styled__default.default.section`
+    display: flex;
+    flex-direction: row-reverse;
+    gap: 0.75rem;
+    justify-content: space-between;
 
-    function assertNode(node2) {
-        if (!isPlainObject$3(node2) || typeof node2.type !== "string") {
-            throw new TypeError("Expected node, got `" + node2 + "`");
-        }
+    button {
+        width: 6rem;
     }
+`;
+    const FormWrapper = styled__default.default.div`
+    display: flex;
+    flex-direction: column;
+    gap: 0.75rem;
+`;
+    const StyledForm = core$2.injectCss("div");
 
-    function assertDone(name2, asyncName, complete) {
-        if (!complete) {
-            throw new Error(
-                "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
-            );
-        }
+    function Form(props) {
+        const [formState, setFormState] = core$2.useVariable(props.value);
+        const [onSubmit] = core$2.useAction(props.onsubmit);
+        const [style2, css2] = core$2.useComponentStyles(props);
+        const updateForm = React.useCallback(
+            (value, id2) => {
+                setFormState((oldFormState) => ({
+                    ...oldFormState,
+                    [id2]: value
+                }));
+            },
+            [setFormState]
+        );
+        const resolveInitialValue = React.useCallback(
+            (defaultValue2, variable, id2) => {
+                if (formState == null ? void 0 : formState[id2]) {
+                    if (variable) {
+                        return {
+                            ...variable,
+                            default: formState == null ? void 0 : formState[id2]
+                        };
+                    }
+                    return formState == null ? void 0 : formState[id2];
+                }
+                return variable != null ? variable : defaultValue2;
+            },
+            [formState]
+        );
+        const pages = React.useMemo(() => {
+            return props.children.filter((child) => child.name === "FormPage");
+        }, [props.children]);
+        const [currentPage, setCurrentPage] = React.useState(0);
+        return /* @__PURE__ */ React__default.default.createElement(formCtx.Provider, {
+            value: {
+                formValues: formState,
+                resolveInitialValue,
+                updateForm
+            }
+        }, /* @__PURE__ */ React__default.default.createElement(StyledForm, {
+            $rawCss: css2,
+            className: props.className,
+            style: style2
+        }, pages.length === 0 && /* @__PURE__ */ React__default.default.createElement(FormWrapper, {
+            style: {
+                alignItems: props.align,
+                justifyContent: props.justify
+            }
+        }, props.children.map((child, idx) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
+            component: child,
+            key: `form-${idx}-${child.uid}`
+        })), /* @__PURE__ */ React__default.default.createElement(ButtonWrapper, null, props.onsubmit && /* @__PURE__ */ React__default.default.createElement(Button$3, {
+            onClick: () => onSubmit(formState),
+            styling: "primary"
+        }, "Submit"))), pages.length > 0 && /* @__PURE__ */ React__default.default.createElement(FormWrapper, null, /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
+            component: props.children[currentPage]
+        }), /* @__PURE__ */ React__default.default.createElement(ButtonWrapper, null, currentPage < pages.length - 1 && /* @__PURE__ */ React__default.default.createElement(Button$3, {
+            onClick: () => setCurrentPage(currentPage + 1),
+            styling: "primary"
+        }, "Next"), currentPage === pages.length - 1 && props.onsubmit && /* @__PURE__ */ React__default.default.createElement(Button$3, {
+            onClick: () => onSubmit(formState),
+            styling: "primary"
+        }, "Submit"), currentPage > 0 && pages.length > 1 && /* @__PURE__ */ React__default.default.createElement(Button$3, {
+            onClick: () => setCurrentPage(currentPage - 1),
+            outline: true,
+            styling: "primary"
+        }, "Back")))));
     }
+    const PageWrapper = styled__default.default.section`
+    display: flex;
+    flex-direction: column;
+    gap: 0.75rem;
+`;
+    const PageTitle = styled__default.default.h2`
+    font-size: 1.4rem;
+`;
+    const StyledWrapper = core$2.injectCss(PageWrapper);
 
-    function vfile(value) {
-        return looksLikeAVFile(value) ? value : new VFile(value);
+    function FormPage(props) {
+        const [style2, css2] = core$2.useComponentStyles(props);
+        return /* @__PURE__ */ React__default.default.createElement(StyledWrapper, {
+            $rawCss: css2,
+            className: props.className,
+            style: style2
+        }, props.title && /* @__PURE__ */ React__default.default.createElement(PageTitle, null, props.title), props.children.map((child, idx) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
+            component: child,
+            key: `form-page-${idx}-${child.uid}`
+        })));
     }
 
-    function looksLikeAVFile(value) {
-        return Boolean(
-            value && typeof value === "object" && "message" in value && "messages" in value
+    function Icon$1(props) {
+        const [style2, css2] = core$2.useComponentStyles(props);
+        const IconComponent = core$2.getIcon(props.icon);
+        const validStyle = {
+            ...style2
+        };
+        delete validStyle.fontWeight;
+        return /* @__PURE__ */ React__default.default.createElement(
+            IconComponent, {
+                $rawCss: css2,
+                style: {
+                    alignItems: "center",
+                    display: "flex",
+                    ...validStyle,
+                    color: props.color
+                }
+            }
         );
     }
+    const ImageComponent = styled__default.default.div`
+    display: flex;
+`;
+    const StyledImg$1 = core$2.injectCss(ImageComponent);
 
-    function looksLikeAValue(value) {
-        return typeof value === "string" || isUint8Array(value);
+    function Image$1(props) {
+        const [style2, css2] = core$2.useComponentStyles(props);
+        const source = core$2.prependBaseUrl(props.src);
+        return /* @__PURE__ */ React__default.default.createElement(StyledImg$1, {
+            $rawCss: css2,
+            style: style2
+        }, /* @__PURE__ */ React__default.default.createElement("img", {
+            alt: `Could not load ${source}`,
+            loading: "lazy",
+            src: source
+        }));
     }
+    const StyledInput$2 = core$2.injectCss(Input$3);
+    const StyledNumericInput = core$2.injectCss(NumericInput);
 
-    function isUint8Array(value) {
-        return Boolean(
-            value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
-        );
+    function getNumericValue(value) {
+        return value == null || Number.isNaN(Number(value)) ? null : Number(value);
     }
-    const changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
-    const emptyPlugins = [];
-    const emptyRemarkRehypeOptions = {
-        allowDangerousHtml: true
-    };
-    const safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i;
-    const deprecations = [{
-        from: "astPlugins",
-        id: "remove-buggy-html-in-markdown-parser"
-    }, {
-        from: "allowDangerousHtml",
-        id: "remove-buggy-html-in-markdown-parser"
-    }, {
-        from: "allowNode",
-        id: "replace-allownode-allowedtypes-and-disallowedtypes",
-        to: "allowElement"
-    }, {
-        from: "allowedTypes",
-        id: "replace-allownode-allowedtypes-and-disallowedtypes",
-        to: "allowedElements"
-    }, {
-        from: "disallowedTypes",
-        id: "replace-allownode-allowedtypes-and-disallowedtypes",
-        to: "disallowedElements"
-    }, {
-        from: "escapeHtml",
-        id: "remove-buggy-html-in-markdown-parser"
-    }, {
-        from: "includeElementIndex",
-        id: "#remove-includeelementindex"
-    }, {
-        from: "includeNodeIndex",
-        id: "change-includenodeindex-to-includeelementindex"
-    }, {
-        from: "linkTarget",
-        id: "remove-linktarget"
-    }, {
-        from: "plugins",
-        id: "change-plugins-to-remarkplugins",
-        to: "remarkPlugins"
-    }, {
-        from: "rawSourcePos",
-        id: "#remove-rawsourcepos"
-    }, {
-        from: "renderers",
-        id: "change-renderers-to-components",
-        to: "components"
-    }, {
-        from: "source",
-        id: "change-source-to-children",
-        to: "children"
-    }, {
-        from: "sourcePos",
-        id: "#remove-sourcepos"
-    }, {
-        from: "transformImageUri",
-        id: "#add-urltransform",
-        to: "urlTransform"
-    }, {
-        from: "transformLinkUri",
-        id: "#add-urltransform",
-        to: "urlTransform"
-    }];
 
-    function Markdown$1(options) {
-        const allowedElements = options.allowedElements;
-        const allowElement = options.allowElement;
-        const children2 = options.children || "";
-        const className = options.className;
-        const components = options.components;
-        const disallowedElements = options.disallowedElements;
-        const rehypePlugins = options.rehypePlugins || emptyPlugins;
-        const remarkPlugins = options.remarkPlugins || emptyPlugins;
-        const remarkRehypeOptions = options.remarkRehypeOptions ? {
-            ...options.remarkRehypeOptions,
-            ...emptyRemarkRehypeOptions
-        } : emptyRemarkRehypeOptions;
-        const skipHtml = options.skipHtml;
-        const unwrapDisallowed = options.unwrapDisallowed;
-        const urlTransform = options.urlTransform || defaultUrlTransform;
-        const processor = unified().use(remarkParse).use(remarkPlugins).use(remarkRehype, remarkRehypeOptions).use(rehypePlugins);
-        const file = new VFile();
-        if (typeof children2 === "string") {
-            file.value = children2;
-        }
-        for (const deprecation2 of deprecations) {
-            if (Object.hasOwn(options, deprecation2.from)) {
-                unreachable(
-                    "Unexpected `" + deprecation2.from + "` prop, " + (deprecation2.to ? "use `" + deprecation2.to + "` instead" : "remove it") + " (see <" + changelog + "#" + deprecation2.id + "> for more info)"
-                );
-            }
-        }
-        const mdastTree = processor.parse(file);
-        let hastTree = processor.runSync(mdastTree, file);
-        if (className) {
-            hastTree = {
-                type: "element",
-                tagName: "div",
-                properties: {
-                    className
-                },
-                children: hastTree.type === "root" ? hastTree.children : [hastTree]
-            };
-        }
-        visit$1(hastTree, transform);
-        return toJsxRuntime(hastTree, {
-            Fragment: jsxRuntime.exports.Fragment,
-            components,
-            ignoreInvalidStyle: true,
-            jsx: jsxRuntime.exports.jsx,
-            jsxs: jsxRuntime.exports.jsxs,
-            passKeys: true,
-            passNode: true
-        });
+    function Input(props) {
+        const formCtx2 = useFormContext(props);
+        const [style2, css2] = core$2.useComponentStyles(props);
+        const [value, setValue] = core$2.useVariable(formCtx2.resolveInitialValue());
+        const [internalValue, setInternalValue] = React.useState(value);
+        const [onInputAction] = core$2.useAction(props.onchange);
+        const debouncedAction = React.useMemo(() => debounce_1(onInputAction, 500), [onInputAction]);
+        const debouncedSetValue = React.useMemo(() => debounce_1(setValue, 500), [setValue]);
+        const debouncedUpdateForm = React.useMemo(() => debounce_1(formCtx2.updateForm, 500), [formCtx2.updateForm]);
 
-        function transform(node2, index2, parent) {
-            if (node2.type === "raw" && parent && typeof index2 === "number") {
-                if (skipHtml) {
-                    parent.children.splice(index2, 1);
-                } else {
-                    parent.children[index2] = {
-                        type: "text",
-                        value: node2.value
-                    };
-                }
-                return index2;
+        function handleChange(val) {
+            let newValue = val;
+            if (props.type === "number") {
+                newValue = getNumericValue(newValue);
             }
-            if (node2.type === "element") {
-                let key;
-                for (key in urlAttributes) {
-                    if (Object.hasOwn(urlAttributes, key) && Object.hasOwn(node2.properties, key)) {
-                        const value = node2.properties[key];
-                        const test2 = urlAttributes[key];
-                        if (test2 === null || test2.includes(node2.tagName)) {
-                            node2.properties[key] = urlTransform(String(value || ""), key, node2);
-                        }
-                    }
-                }
+            setInternalValue(newValue);
+            debouncedSetValue(newValue);
+            debouncedAction(val);
+            debouncedUpdateForm(val);
+        }
+        React.useEffect(() => {
+            debouncedAction.cancel();
+            debouncedSetValue.cancel();
+            debouncedUpdateForm.cancel();
+            let newValue = value;
+            if (props.type === "number") {
+                newValue = getNumericValue(newValue);
             }
-            if (node2.type === "element") {
-                let remove2 = allowedElements ? !allowedElements.includes(node2.tagName) : disallowedElements ? disallowedElements.includes(node2.tagName) : false;
-                if (!remove2 && allowElement && typeof index2 === "number") {
-                    remove2 = !allowElement(node2, index2, parent);
-                }
-                if (remove2 && parent && typeof index2 === "number") {
-                    if (unwrapDisallowed && node2.children) {
-                        parent.children.splice(index2, 1, ...node2.children);
-                    } else {
-                        parent.children.splice(index2, 1);
-                    }
-                    return index2;
+            setInternalValue(newValue);
+        }, [value]);
+        if (props.type === "number") {
+            return /* @__PURE__ */ React__default.default.createElement(
+                StyledNumericInput, {
+                    $rawCss: css2,
+                    className: props.className,
+                    onChange: (e3) => handleChange(String(e3)),
+                    placeholder: props.placeholder,
+                    stepper: true,
+                    style: style2,
+                    value: internalValue
                 }
-            }
+            );
         }
+        return /* @__PURE__ */ React__default.default.createElement(
+            StyledInput$2, {
+                $rawCss: css2,
+                className: props.className,
+                onChange: handleChange,
+                placeholder: props.placeholder,
+                style: style2,
+                type: props.type,
+                value: internalValue
+            }
+        );
     }
+    const StyledLabel = core$2.injectCss(styled__default.default.label`
+    display: flex;
+    flex-grow: 0 !important;
+    gap: 0.5rem;
+    align-items: flex-start;
 
-    function defaultUrlTransform(value) {
-        const colon = value.indexOf(":");
-        const questionMark = value.indexOf("?");
-        const numberSign = value.indexOf("#");
-        const slash = value.indexOf("/");
-        if (colon < 0 || slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign || safeProtocol.test(value.slice(0, colon))) {
-            return value;
-        }
-        return "";
+    font-size: 1rem;
+`);
+
+    function Label(props) {
+        var _a3;
+        const [style2, css2] = core$2.useComponentStyles(props);
+        return /* @__PURE__ */ React__default.default.createElement(
+            StyledLabel, {
+                $rawCss: css2,
+                className: props.className,
+                style: {
+                    flexDirection: props.direction === "horizontal" ? "row" : "column",
+                    ...style2
+                }
+            },
+            typeof props.value === "string" ? /* @__PURE__ */ React__default.default.createElement(
+                "span", {
+                    style: {
+                        alignItems: "center",
+                        display: "flex",
+                        height: props.direction === "horizontal" ? "2.5rem" : "auto",
+                        width: (_a3 = props.label_width) != null ? _a3 : "auto"
+                    }
+                },
+                props.value
+            ) : /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
+                component: props.value
+            }),
+            props.children.map((child, idx) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
+                component: child,
+                key: `cell-${idx}-${child.uid}`
+            }))
+        );
     }
     var unicode$3 = {};
     const UNDEFINED_CODE_POINTS = [
         65534,
         65535,
         131070,
         131071,
@@ -63509,39 +67064,39 @@
             if (token.attrs[i2].name === attrName) {
                 return token.attrs[i2].value;
             }
         }
         return null;
     };
     var tokenizer = Tokenizer$4;
-    var html$1 = {};
-    const NS$3 = html$1.NAMESPACES = {
+    var html = {};
+    const NS$3 = html.NAMESPACES = {
         HTML: "http://www.w3.org/1999/xhtml",
         MATHML: "http://www.w3.org/1998/Math/MathML",
         SVG: "http://www.w3.org/2000/svg",
         XLINK: "http://www.w3.org/1999/xlink",
         XML: "http://www.w3.org/XML/1998/namespace",
         XMLNS: "http://www.w3.org/2000/xmlns/"
     };
-    html$1.ATTRS = {
+    html.ATTRS = {
         TYPE: "type",
         ACTION: "action",
         ENCODING: "encoding",
         PROMPT: "prompt",
         NAME: "name",
         COLOR: "color",
         FACE: "face",
         SIZE: "size"
     };
-    html$1.DOCUMENT_MODE = {
+    html.DOCUMENT_MODE = {
         NO_QUIRKS: "no-quirks",
         QUIRKS: "quirks",
         LIMITED_QUIRKS: "limited-quirks"
     };
-    const $$6 = html$1.TAG_NAMES = {
+    const $$6 = html.TAG_NAMES = {
         A: "a",
         ADDRESS: "address",
         ANNOTATION_XML: "annotation-xml",
         APPLET: "applet",
         AREA: "area",
         ARTICLE: "article",
         ASIDE: "aside",
@@ -63657,15 +67212,15 @@
         U: "u",
         UL: "ul",
         SVG: "svg",
         VAR: "var",
         WBR: "wbr",
         XMP: "xmp"
     };
-    html$1.SPECIAL_ELEMENTS = {
+    html.SPECIAL_ELEMENTS = {
         [NS$3.HTML]: {
             [$$6.ADDRESS]: true,
             [$$6.APPLET]: true,
             [$$6.AREA]: true,
             [$$6.ARTICLE]: true,
             [$$6.ASIDE]: true,
             [$$6.BASE]: true,
@@ -63755,15 +67310,15 @@
         },
         [NS$3.SVG]: {
             [$$6.TITLE]: true,
             [$$6.FOREIGN_OBJECT]: true,
             [$$6.DESC]: true
         }
     };
-    const HTML$4 = html$1;
+    const HTML$4 = html;
     const $$5 = HTML$4.TAG_NAMES;
     const NS$2 = HTML$4.NAMESPACES;
 
     function isImpliedEndTagRequired(tn) {
         switch (tn.length) {
             case 1:
                 return tn === $$5.P;
@@ -64435,15 +67990,15 @@
         }
     }
     var openElementStackMixin = LocationInfoOpenElementStackMixin$1;
     const Mixin$5 = mixin;
     const Tokenizer$2 = tokenizer;
     const LocationInfoTokenizerMixin$1 = tokenizerMixin$1;
     const LocationInfoOpenElementStackMixin = openElementStackMixin;
-    const HTML$3 = html$1;
+    const HTML$3 = html;
     const $$4 = HTML$3.TAG_NAMES;
     class LocationInfoParserMixin$1 extends Mixin$5 {
         constructor(parser2) {
             super(parser2);
             this.parser = parser2;
             this.treeAdapter = this.parser.treeAdapter;
             this.posTracker = null;
@@ -64693,15 +68248,15 @@
             };
         }
     }
     var parserMixin = ErrorReportingParserMixin$1;
     var _default = {};
     const {
         DOCUMENT_MODE: DOCUMENT_MODE$1
-    } = html$1;
+    } = html;
     _default.createDocument = function() {
         return {
             nodeName: "#document",
             mode: DOCUMENT_MODE$1.NO_QUIRKS,
             childNodes: []
         };
     };
@@ -64875,15 +68430,15 @@
             });
             return merged;
         }, /* @__PURE__ */ Object.create(null));
     };
     var doctype$2 = {};
     const {
         DOCUMENT_MODE
-    } = html$1;
+    } = html;
     const VALID_DOCTYPE_NAME = "html";
     const VALID_SYSTEM_ID = "about:legacy-compat";
     const QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
     const QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
         "+//silmaril//dtd html pro v0r11 19970101//",
         "-//as//dtd html 3.0 aswedit + extensions//",
         "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
@@ -65005,15 +68560,15 @@
         if (systemId !== null) {
             str += " " + enquoteDoctypeId(systemId);
         }
         return str;
     };
     var foreignContent$1 = {};
     const Tokenizer$1 = tokenizer;
-    const HTML$2 = html$1;
+    const HTML$2 = html;
     const $$3 = HTML$2.TAG_NAMES;
     const NS$1 = HTML$2.NAMESPACES;
     const ATTRS$1 = HTML$2.ATTRS;
     const MIME_TYPES = {
         TEXT_HTML: "text/html",
         APPLICATION_XML: "application/xhtml+xml"
     };
@@ -65295,15 +68850,15 @@
     const Mixin = mixin;
     const defaultTreeAdapter = _default;
     const mergeOptions = mergeOptions$1;
     const doctype$1 = doctype$2;
     const foreignContent = foreignContent$1;
     const ERR = errorCodes;
     const unicode = unicode$3;
-    const HTML$1 = html$1;
+    const HTML$1 = html;
     const $$2 = HTML$1.TAG_NAMES;
     const NS = HTML$1.NAMESPACES;
     const ATTRS = HTML$1.ATTRS;
     const DEFAULT_OPTIONS = {
         scriptingEnabled: true,
         sourceCodeLocationInfo: false,
         onParseError: null,
@@ -66993,4936 +70548,1807 @@
                 } else {
                     genericEndTagInBody(p2, token);
                 }
                 break;
             case 8:
                 if (tn === $$2.FIELDSET) {
                     addressEndTagInBody(p2, token);
-                } else if (tn === $$2.TEMPLATE) {
-                    endTagInHead(p2, token);
-                } else {
-                    genericEndTagInBody(p2, token);
-                }
-                break;
-            case 10:
-                if (tn === $$2.BLOCKQUOTE || tn === $$2.FIGCAPTION) {
-                    addressEndTagInBody(p2, token);
-                } else {
-                    genericEndTagInBody(p2, token);
-                }
-                break;
-            default:
-                genericEndTagInBody(p2, token);
-        }
-    }
-
-    function eofInBody(p2, token) {
-        if (p2.tmplInsertionModeStackTop > -1) {
-            eofInTemplate(p2, token);
-        } else {
-            p2.stopped = true;
-        }
-    }
-
-    function endTagInText(p2, token) {
-        if (token.tagName === $$2.SCRIPT) {
-            p2.pendingScript = p2.openElements.current;
-        }
-        p2.openElements.pop();
-        p2.insertionMode = p2.originalInsertionMode;
-    }
-
-    function eofInText(p2, token) {
-        p2._err(ERR.eofInElementThatCanContainOnlyText);
-        p2.openElements.pop();
-        p2.insertionMode = p2.originalInsertionMode;
-        p2._processToken(token);
-    }
-
-    function characterInTable(p2, token) {
-        const curTn = p2.openElements.currentTagName;
-        if (curTn === $$2.TABLE || curTn === $$2.TBODY || curTn === $$2.TFOOT || curTn === $$2.THEAD || curTn === $$2.TR) {
-            p2.pendingCharacterTokens = [];
-            p2.hasNonWhitespacePendingCharacterToken = false;
-            p2.originalInsertionMode = p2.insertionMode;
-            p2.insertionMode = IN_TABLE_TEXT_MODE;
-            p2._processToken(token);
-        } else {
-            tokenInTable(p2, token);
-        }
-    }
-
-    function captionStartTagInTable(p2, token) {
-        p2.openElements.clearBackToTableContext();
-        p2.activeFormattingElements.insertMarker();
-        p2._insertElement(token, NS.HTML);
-        p2.insertionMode = IN_CAPTION_MODE;
-    }
-
-    function colgroupStartTagInTable(p2, token) {
-        p2.openElements.clearBackToTableContext();
-        p2._insertElement(token, NS.HTML);
-        p2.insertionMode = IN_COLUMN_GROUP_MODE;
-    }
-
-    function colStartTagInTable(p2, token) {
-        p2.openElements.clearBackToTableContext();
-        p2._insertFakeElement($$2.COLGROUP);
-        p2.insertionMode = IN_COLUMN_GROUP_MODE;
-        p2._processToken(token);
-    }
-
-    function tbodyStartTagInTable(p2, token) {
-        p2.openElements.clearBackToTableContext();
-        p2._insertElement(token, NS.HTML);
-        p2.insertionMode = IN_TABLE_BODY_MODE;
-    }
-
-    function tdStartTagInTable(p2, token) {
-        p2.openElements.clearBackToTableContext();
-        p2._insertFakeElement($$2.TBODY);
-        p2.insertionMode = IN_TABLE_BODY_MODE;
-        p2._processToken(token);
-    }
-
-    function tableStartTagInTable(p2, token) {
-        if (p2.openElements.hasInTableScope($$2.TABLE)) {
-            p2.openElements.popUntilTagNamePopped($$2.TABLE);
-            p2._resetInsertionMode();
-            p2._processToken(token);
-        }
-    }
-
-    function inputStartTagInTable(p2, token) {
-        const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);
-        if (inputType && inputType.toLowerCase() === HIDDEN_INPUT_TYPE) {
-            p2._appendElement(token, NS.HTML);
-        } else {
-            tokenInTable(p2, token);
-        }
-        token.ackSelfClosing = true;
-    }
-
-    function formStartTagInTable(p2, token) {
-        if (!p2.formElement && p2.openElements.tmplCount === 0) {
-            p2._insertElement(token, NS.HTML);
-            p2.formElement = p2.openElements.current;
-            p2.openElements.pop();
-        }
-    }
-
-    function startTagInTable(p2, token) {
-        const tn = token.tagName;
-        switch (tn.length) {
-            case 2:
-                if (tn === $$2.TD || tn === $$2.TH || tn === $$2.TR) {
-                    tdStartTagInTable(p2, token);
-                } else {
-                    tokenInTable(p2, token);
-                }
-                break;
-            case 3:
-                if (tn === $$2.COL) {
-                    colStartTagInTable(p2, token);
-                } else {
-                    tokenInTable(p2, token);
-                }
-                break;
-            case 4:
-                if (tn === $$2.FORM) {
-                    formStartTagInTable(p2, token);
-                } else {
-                    tokenInTable(p2, token);
-                }
-                break;
-            case 5:
-                if (tn === $$2.TABLE) {
-                    tableStartTagInTable(p2, token);
-                } else if (tn === $$2.STYLE) {
-                    startTagInHead(p2, token);
-                } else if (tn === $$2.TBODY || tn === $$2.TFOOT || tn === $$2.THEAD) {
-                    tbodyStartTagInTable(p2, token);
-                } else if (tn === $$2.INPUT) {
-                    inputStartTagInTable(p2, token);
-                } else {
-                    tokenInTable(p2, token);
-                }
-                break;
-            case 6:
-                if (tn === $$2.SCRIPT) {
-                    startTagInHead(p2, token);
-                } else {
-                    tokenInTable(p2, token);
-                }
-                break;
-            case 7:
-                if (tn === $$2.CAPTION) {
-                    captionStartTagInTable(p2, token);
-                } else {
-                    tokenInTable(p2, token);
-                }
-                break;
-            case 8:
-                if (tn === $$2.COLGROUP) {
-                    colgroupStartTagInTable(p2, token);
-                } else if (tn === $$2.TEMPLATE) {
-                    startTagInHead(p2, token);
-                } else {
-                    tokenInTable(p2, token);
-                }
-                break;
-            default:
-                tokenInTable(p2, token);
-        }
-    }
-
-    function endTagInTable(p2, token) {
-        const tn = token.tagName;
-        if (tn === $$2.TABLE) {
-            if (p2.openElements.hasInTableScope($$2.TABLE)) {
-                p2.openElements.popUntilTagNamePopped($$2.TABLE);
-                p2._resetInsertionMode();
-            }
-        } else if (tn === $$2.TEMPLATE) {
-            endTagInHead(p2, token);
-        } else if (tn !== $$2.BODY && tn !== $$2.CAPTION && tn !== $$2.COL && tn !== $$2.COLGROUP && tn !== $$2.HTML && tn !== $$2.TBODY && tn !== $$2.TD && tn !== $$2.TFOOT && tn !== $$2.TH && tn !== $$2.THEAD && tn !== $$2.TR) {
-            tokenInTable(p2, token);
-        }
-    }
-
-    function tokenInTable(p2, token) {
-        const savedFosterParentingState = p2.fosterParentingEnabled;
-        p2.fosterParentingEnabled = true;
-        p2._processTokenInBodyMode(token);
-        p2.fosterParentingEnabled = savedFosterParentingState;
-    }
-
-    function whitespaceCharacterInTableText(p2, token) {
-        p2.pendingCharacterTokens.push(token);
-    }
-
-    function characterInTableText(p2, token) {
-        p2.pendingCharacterTokens.push(token);
-        p2.hasNonWhitespacePendingCharacterToken = true;
-    }
-
-    function tokenInTableText(p2, token) {
-        let i2 = 0;
-        if (p2.hasNonWhitespacePendingCharacterToken) {
-            for (; i2 < p2.pendingCharacterTokens.length; i2++) {
-                tokenInTable(p2, p2.pendingCharacterTokens[i2]);
-            }
-        } else {
-            for (; i2 < p2.pendingCharacterTokens.length; i2++) {
-                p2._insertCharacters(p2.pendingCharacterTokens[i2]);
-            }
-        }
-        p2.insertionMode = p2.originalInsertionMode;
-        p2._processToken(token);
-    }
-
-    function startTagInCaption(p2, token) {
-        const tn = token.tagName;
-        if (tn === $$2.CAPTION || tn === $$2.COL || tn === $$2.COLGROUP || tn === $$2.TBODY || tn === $$2.TD || tn === $$2.TFOOT || tn === $$2.TH || tn === $$2.THEAD || tn === $$2.TR) {
-            if (p2.openElements.hasInTableScope($$2.CAPTION)) {
-                p2.openElements.generateImpliedEndTags();
-                p2.openElements.popUntilTagNamePopped($$2.CAPTION);
-                p2.activeFormattingElements.clearToLastMarker();
-                p2.insertionMode = IN_TABLE_MODE;
-                p2._processToken(token);
-            }
-        } else {
-            startTagInBody(p2, token);
-        }
-    }
-
-    function endTagInCaption(p2, token) {
-        const tn = token.tagName;
-        if (tn === $$2.CAPTION || tn === $$2.TABLE) {
-            if (p2.openElements.hasInTableScope($$2.CAPTION)) {
-                p2.openElements.generateImpliedEndTags();
-                p2.openElements.popUntilTagNamePopped($$2.CAPTION);
-                p2.activeFormattingElements.clearToLastMarker();
-                p2.insertionMode = IN_TABLE_MODE;
-                if (tn === $$2.TABLE) {
-                    p2._processToken(token);
-                }
-            }
-        } else if (tn !== $$2.BODY && tn !== $$2.COL && tn !== $$2.COLGROUP && tn !== $$2.HTML && tn !== $$2.TBODY && tn !== $$2.TD && tn !== $$2.TFOOT && tn !== $$2.TH && tn !== $$2.THEAD && tn !== $$2.TR) {
-            endTagInBody(p2, token);
-        }
-    }
-
-    function startTagInColumnGroup(p2, token) {
-        const tn = token.tagName;
-        if (tn === $$2.HTML) {
-            startTagInBody(p2, token);
-        } else if (tn === $$2.COL) {
-            p2._appendElement(token, NS.HTML);
-            token.ackSelfClosing = true;
-        } else if (tn === $$2.TEMPLATE) {
-            startTagInHead(p2, token);
-        } else {
-            tokenInColumnGroup(p2, token);
-        }
-    }
-
-    function endTagInColumnGroup(p2, token) {
-        const tn = token.tagName;
-        if (tn === $$2.COLGROUP) {
-            if (p2.openElements.currentTagName === $$2.COLGROUP) {
-                p2.openElements.pop();
-                p2.insertionMode = IN_TABLE_MODE;
-            }
-        } else if (tn === $$2.TEMPLATE) {
-            endTagInHead(p2, token);
-        } else if (tn !== $$2.COL) {
-            tokenInColumnGroup(p2, token);
-        }
-    }
-
-    function tokenInColumnGroup(p2, token) {
-        if (p2.openElements.currentTagName === $$2.COLGROUP) {
-            p2.openElements.pop();
-            p2.insertionMode = IN_TABLE_MODE;
-            p2._processToken(token);
-        }
-    }
-
-    function startTagInTableBody(p2, token) {
-        const tn = token.tagName;
-        if (tn === $$2.TR) {
-            p2.openElements.clearBackToTableBodyContext();
-            p2._insertElement(token, NS.HTML);
-            p2.insertionMode = IN_ROW_MODE;
-        } else if (tn === $$2.TH || tn === $$2.TD) {
-            p2.openElements.clearBackToTableBodyContext();
-            p2._insertFakeElement($$2.TR);
-            p2.insertionMode = IN_ROW_MODE;
-            p2._processToken(token);
-        } else if (tn === $$2.CAPTION || tn === $$2.COL || tn === $$2.COLGROUP || tn === $$2.TBODY || tn === $$2.TFOOT || tn === $$2.THEAD) {
-            if (p2.openElements.hasTableBodyContextInTableScope()) {
-                p2.openElements.clearBackToTableBodyContext();
-                p2.openElements.pop();
-                p2.insertionMode = IN_TABLE_MODE;
-                p2._processToken(token);
-            }
-        } else {
-            startTagInTable(p2, token);
-        }
-    }
-
-    function endTagInTableBody(p2, token) {
-        const tn = token.tagName;
-        if (tn === $$2.TBODY || tn === $$2.TFOOT || tn === $$2.THEAD) {
-            if (p2.openElements.hasInTableScope(tn)) {
-                p2.openElements.clearBackToTableBodyContext();
-                p2.openElements.pop();
-                p2.insertionMode = IN_TABLE_MODE;
-            }
-        } else if (tn === $$2.TABLE) {
-            if (p2.openElements.hasTableBodyContextInTableScope()) {
-                p2.openElements.clearBackToTableBodyContext();
-                p2.openElements.pop();
-                p2.insertionMode = IN_TABLE_MODE;
-                p2._processToken(token);
-            }
-        } else if (tn !== $$2.BODY && tn !== $$2.CAPTION && tn !== $$2.COL && tn !== $$2.COLGROUP || tn !== $$2.HTML && tn !== $$2.TD && tn !== $$2.TH && tn !== $$2.TR) {
-            endTagInTable(p2, token);
-        }
-    }
-
-    function startTagInRow(p2, token) {
-        const tn = token.tagName;
-        if (tn === $$2.TH || tn === $$2.TD) {
-            p2.openElements.clearBackToTableRowContext();
-            p2._insertElement(token, NS.HTML);
-            p2.insertionMode = IN_CELL_MODE;
-            p2.activeFormattingElements.insertMarker();
-        } else if (tn === $$2.CAPTION || tn === $$2.COL || tn === $$2.COLGROUP || tn === $$2.TBODY || tn === $$2.TFOOT || tn === $$2.THEAD || tn === $$2.TR) {
-            if (p2.openElements.hasInTableScope($$2.TR)) {
-                p2.openElements.clearBackToTableRowContext();
-                p2.openElements.pop();
-                p2.insertionMode = IN_TABLE_BODY_MODE;
-                p2._processToken(token);
-            }
-        } else {
-            startTagInTable(p2, token);
-        }
-    }
-
-    function endTagInRow(p2, token) {
-        const tn = token.tagName;
-        if (tn === $$2.TR) {
-            if (p2.openElements.hasInTableScope($$2.TR)) {
-                p2.openElements.clearBackToTableRowContext();
-                p2.openElements.pop();
-                p2.insertionMode = IN_TABLE_BODY_MODE;
-            }
-        } else if (tn === $$2.TABLE) {
-            if (p2.openElements.hasInTableScope($$2.TR)) {
-                p2.openElements.clearBackToTableRowContext();
-                p2.openElements.pop();
-                p2.insertionMode = IN_TABLE_BODY_MODE;
-                p2._processToken(token);
-            }
-        } else if (tn === $$2.TBODY || tn === $$2.TFOOT || tn === $$2.THEAD) {
-            if (p2.openElements.hasInTableScope(tn) || p2.openElements.hasInTableScope($$2.TR)) {
-                p2.openElements.clearBackToTableRowContext();
-                p2.openElements.pop();
-                p2.insertionMode = IN_TABLE_BODY_MODE;
-                p2._processToken(token);
-            }
-        } else if (tn !== $$2.BODY && tn !== $$2.CAPTION && tn !== $$2.COL && tn !== $$2.COLGROUP || tn !== $$2.HTML && tn !== $$2.TD && tn !== $$2.TH) {
-            endTagInTable(p2, token);
-        }
-    }
-
-    function startTagInCell(p2, token) {
-        const tn = token.tagName;
-        if (tn === $$2.CAPTION || tn === $$2.COL || tn === $$2.COLGROUP || tn === $$2.TBODY || tn === $$2.TD || tn === $$2.TFOOT || tn === $$2.TH || tn === $$2.THEAD || tn === $$2.TR) {
-            if (p2.openElements.hasInTableScope($$2.TD) || p2.openElements.hasInTableScope($$2.TH)) {
-                p2._closeTableCell();
-                p2._processToken(token);
-            }
-        } else {
-            startTagInBody(p2, token);
-        }
-    }
-
-    function endTagInCell(p2, token) {
-        const tn = token.tagName;
-        if (tn === $$2.TD || tn === $$2.TH) {
-            if (p2.openElements.hasInTableScope(tn)) {
-                p2.openElements.generateImpliedEndTags();
-                p2.openElements.popUntilTagNamePopped(tn);
-                p2.activeFormattingElements.clearToLastMarker();
-                p2.insertionMode = IN_ROW_MODE;
-            }
-        } else if (tn === $$2.TABLE || tn === $$2.TBODY || tn === $$2.TFOOT || tn === $$2.THEAD || tn === $$2.TR) {
-            if (p2.openElements.hasInTableScope(tn)) {
-                p2._closeTableCell();
-                p2._processToken(token);
-            }
-        } else if (tn !== $$2.BODY && tn !== $$2.CAPTION && tn !== $$2.COL && tn !== $$2.COLGROUP && tn !== $$2.HTML) {
-            endTagInBody(p2, token);
-        }
-    }
-
-    function startTagInSelect(p2, token) {
-        const tn = token.tagName;
-        if (tn === $$2.HTML) {
-            startTagInBody(p2, token);
-        } else if (tn === $$2.OPTION) {
-            if (p2.openElements.currentTagName === $$2.OPTION) {
-                p2.openElements.pop();
-            }
-            p2._insertElement(token, NS.HTML);
-        } else if (tn === $$2.OPTGROUP) {
-            if (p2.openElements.currentTagName === $$2.OPTION) {
-                p2.openElements.pop();
-            }
-            if (p2.openElements.currentTagName === $$2.OPTGROUP) {
-                p2.openElements.pop();
-            }
-            p2._insertElement(token, NS.HTML);
-        } else if (tn === $$2.INPUT || tn === $$2.KEYGEN || tn === $$2.TEXTAREA || tn === $$2.SELECT) {
-            if (p2.openElements.hasInSelectScope($$2.SELECT)) {
-                p2.openElements.popUntilTagNamePopped($$2.SELECT);
-                p2._resetInsertionMode();
-                if (tn !== $$2.SELECT) {
-                    p2._processToken(token);
-                }
-            }
-        } else if (tn === $$2.SCRIPT || tn === $$2.TEMPLATE) {
-            startTagInHead(p2, token);
-        }
-    }
-
-    function endTagInSelect(p2, token) {
-        const tn = token.tagName;
-        if (tn === $$2.OPTGROUP) {
-            const prevOpenElement = p2.openElements.items[p2.openElements.stackTop - 1];
-            const prevOpenElementTn = prevOpenElement && p2.treeAdapter.getTagName(prevOpenElement);
-            if (p2.openElements.currentTagName === $$2.OPTION && prevOpenElementTn === $$2.OPTGROUP) {
-                p2.openElements.pop();
-            }
-            if (p2.openElements.currentTagName === $$2.OPTGROUP) {
-                p2.openElements.pop();
-            }
-        } else if (tn === $$2.OPTION) {
-            if (p2.openElements.currentTagName === $$2.OPTION) {
-                p2.openElements.pop();
-            }
-        } else if (tn === $$2.SELECT && p2.openElements.hasInSelectScope($$2.SELECT)) {
-            p2.openElements.popUntilTagNamePopped($$2.SELECT);
-            p2._resetInsertionMode();
-        } else if (tn === $$2.TEMPLATE) {
-            endTagInHead(p2, token);
-        }
-    }
-
-    function startTagInSelectInTable(p2, token) {
-        const tn = token.tagName;
-        if (tn === $$2.CAPTION || tn === $$2.TABLE || tn === $$2.TBODY || tn === $$2.TFOOT || tn === $$2.THEAD || tn === $$2.TR || tn === $$2.TD || tn === $$2.TH) {
-            p2.openElements.popUntilTagNamePopped($$2.SELECT);
-            p2._resetInsertionMode();
-            p2._processToken(token);
-        } else {
-            startTagInSelect(p2, token);
-        }
-    }
-
-    function endTagInSelectInTable(p2, token) {
-        const tn = token.tagName;
-        if (tn === $$2.CAPTION || tn === $$2.TABLE || tn === $$2.TBODY || tn === $$2.TFOOT || tn === $$2.THEAD || tn === $$2.TR || tn === $$2.TD || tn === $$2.TH) {
-            if (p2.openElements.hasInTableScope(tn)) {
-                p2.openElements.popUntilTagNamePopped($$2.SELECT);
-                p2._resetInsertionMode();
-                p2._processToken(token);
-            }
-        } else {
-            endTagInSelect(p2, token);
-        }
-    }
-
-    function startTagInTemplate(p2, token) {
-        const tn = token.tagName;
-        if (tn === $$2.BASE || tn === $$2.BASEFONT || tn === $$2.BGSOUND || tn === $$2.LINK || tn === $$2.META || tn === $$2.NOFRAMES || tn === $$2.SCRIPT || tn === $$2.STYLE || tn === $$2.TEMPLATE || tn === $$2.TITLE) {
-            startTagInHead(p2, token);
-        } else {
-            const newInsertionMode = TEMPLATE_INSERTION_MODE_SWITCH_MAP[tn] || IN_BODY_MODE;
-            p2._popTmplInsertionMode();
-            p2._pushTmplInsertionMode(newInsertionMode);
-            p2.insertionMode = newInsertionMode;
-            p2._processToken(token);
-        }
-    }
-
-    function endTagInTemplate(p2, token) {
-        if (token.tagName === $$2.TEMPLATE) {
-            endTagInHead(p2, token);
-        }
-    }
-
-    function eofInTemplate(p2, token) {
-        if (p2.openElements.tmplCount > 0) {
-            p2.openElements.popUntilTagNamePopped($$2.TEMPLATE);
-            p2.activeFormattingElements.clearToLastMarker();
-            p2._popTmplInsertionMode();
-            p2._resetInsertionMode();
-            p2._processToken(token);
-        } else {
-            p2.stopped = true;
-        }
-    }
-
-    function startTagAfterBody(p2, token) {
-        if (token.tagName === $$2.HTML) {
-            startTagInBody(p2, token);
-        } else {
-            tokenAfterBody(p2, token);
-        }
-    }
-
-    function endTagAfterBody(p2, token) {
-        if (token.tagName === $$2.HTML) {
-            if (!p2.fragmentContext) {
-                p2.insertionMode = AFTER_AFTER_BODY_MODE;
-            }
-        } else {
-            tokenAfterBody(p2, token);
-        }
-    }
-
-    function tokenAfterBody(p2, token) {
-        p2.insertionMode = IN_BODY_MODE;
-        p2._processToken(token);
-    }
-
-    function startTagInFrameset(p2, token) {
-        const tn = token.tagName;
-        if (tn === $$2.HTML) {
-            startTagInBody(p2, token);
-        } else if (tn === $$2.FRAMESET) {
-            p2._insertElement(token, NS.HTML);
-        } else if (tn === $$2.FRAME) {
-            p2._appendElement(token, NS.HTML);
-            token.ackSelfClosing = true;
-        } else if (tn === $$2.NOFRAMES) {
-            startTagInHead(p2, token);
-        }
-    }
-
-    function endTagInFrameset(p2, token) {
-        if (token.tagName === $$2.FRAMESET && !p2.openElements.isRootHtmlElementCurrent()) {
-            p2.openElements.pop();
-            if (!p2.fragmentContext && p2.openElements.currentTagName !== $$2.FRAMESET) {
-                p2.insertionMode = AFTER_FRAMESET_MODE;
-            }
-        }
-    }
-
-    function startTagAfterFrameset(p2, token) {
-        const tn = token.tagName;
-        if (tn === $$2.HTML) {
-            startTagInBody(p2, token);
-        } else if (tn === $$2.NOFRAMES) {
-            startTagInHead(p2, token);
-        }
-    }
-
-    function endTagAfterFrameset(p2, token) {
-        if (token.tagName === $$2.HTML) {
-            p2.insertionMode = AFTER_AFTER_FRAMESET_MODE;
-        }
-    }
-
-    function startTagAfterAfterBody(p2, token) {
-        if (token.tagName === $$2.HTML) {
-            startTagInBody(p2, token);
-        } else {
-            tokenAfterAfterBody(p2, token);
-        }
-    }
-
-    function tokenAfterAfterBody(p2, token) {
-        p2.insertionMode = IN_BODY_MODE;
-        p2._processToken(token);
-    }
-
-    function startTagAfterAfterFrameset(p2, token) {
-        const tn = token.tagName;
-        if (tn === $$2.HTML) {
-            startTagInBody(p2, token);
-        } else if (tn === $$2.NOFRAMES) {
-            startTagInHead(p2, token);
-        }
-    }
-
-    function nullCharacterInForeignContent(p2, token) {
-        token.chars = unicode.REPLACEMENT_CHARACTER;
-        p2._insertCharacters(token);
-    }
-
-    function characterInForeignContent(p2, token) {
-        p2._insertCharacters(token);
-        p2.framesetOk = false;
-    }
-
-    function startTagInForeignContent(p2, token) {
-        if (foreignContent.causesExit(token) && !p2.fragmentContext) {
-            while (p2.treeAdapter.getNamespaceURI(p2.openElements.current) !== NS.HTML && !p2._isIntegrationPoint(p2.openElements.current)) {
-                p2.openElements.pop();
-            }
-            p2._processToken(token);
-        } else {
-            const current2 = p2._getAdjustedCurrentElement();
-            const currentNs = p2.treeAdapter.getNamespaceURI(current2);
-            if (currentNs === NS.MATHML) {
-                foreignContent.adjustTokenMathMLAttrs(token);
-            } else if (currentNs === NS.SVG) {
-                foreignContent.adjustTokenSVGTagName(token);
-                foreignContent.adjustTokenSVGAttrs(token);
-            }
-            foreignContent.adjustTokenXMLAttrs(token);
-            if (token.selfClosing) {
-                p2._appendElement(token, currentNs);
-            } else {
-                p2._insertElement(token, currentNs);
-            }
-            token.ackSelfClosing = true;
-        }
-    }
-
-    function endTagInForeignContent(p2, token) {
-        for (let i2 = p2.openElements.stackTop; i2 > 0; i2--) {
-            const element2 = p2.openElements.items[i2];
-            if (p2.treeAdapter.getNamespaceURI(element2) === NS.HTML) {
-                p2._processToken(token);
-                break;
-            }
-            if (p2.treeAdapter.getTagName(element2).toLowerCase() === token.tagName) {
-                p2.openElements.popUntilElementPopped(element2);
-                break;
-            }
-        }
-    }
-    const pointStart = point$1("start");
-    const pointEnd = point$1("end");
-
-    function point$1(type2) {
-        return point2;
-
-        function point2(node2) {
-            const point3 = node2 && node2.position && node2.position[type2] || {};
-            return {
-                line: point3.line || null,
-                column: point3.column || null,
-                offset: point3.offset > -1 ? point3.offset : null
-            };
-        }
-    }
-    const convert = function(test2) {
-        if (test2 === void 0 || test2 === null) {
-            return ok;
-        }
-        if (typeof test2 === "string") {
-            return typeFactory(test2);
-        }
-        if (typeof test2 === "object") {
-            return Array.isArray(test2) ? anyFactory(test2) : propsFactory(test2);
-        }
-        if (typeof test2 === "function") {
-            return castFactory(test2);
-        }
-        throw new Error("Expected function, string, or object as test");
-    };
-
-    function anyFactory(tests) {
-        const checks2 = [];
-        let index2 = -1;
-        while (++index2 < tests.length) {
-            checks2[index2] = convert(tests[index2]);
-        }
-        return castFactory(any);
-
-        function any(...parameters) {
-            let index3 = -1;
-            while (++index3 < checks2.length) {
-                if (checks2[index3].call(this, ...parameters))
-                    return true;
-            }
-            return false;
-        }
-    }
-
-    function propsFactory(check) {
-        return castFactory(all2);
-
-        function all2(node2) {
-            let key;
-            for (key in check) {
-                if (node2[key] !== check[key])
-                    return false;
-            }
-            return true;
-        }
-    }
-
-    function typeFactory(check) {
-        return castFactory(type2);
-
-        function type2(node2) {
-            return node2 && node2.type === check;
-        }
-    }
-
-    function castFactory(check) {
-        return assertion;
-
-        function assertion(node2, ...parameters) {
-            return Boolean(
-                node2 && typeof node2 === "object" && "type" in node2 && Boolean(check.call(this, node2, ...parameters))
-            );
-        }
-    }
-
-    function ok() {
-        return true;
-    }
-
-    function color$1(d2) {
-        return d2;
-    }
-    const CONTINUE = true;
-    const EXIT = false;
-    const SKIP = "skip";
-    const visitParents = function(tree, test2, visitor, reverse) {
-        if (typeof test2 === "function" && typeof visitor !== "function") {
-            reverse = visitor;
-            visitor = test2;
-            test2 = null;
-        }
-        const is2 = convert(test2);
-        const step2 = reverse ? -1 : 1;
-        factory2(tree, void 0, [])();
-
-        function factory2(node2, index2, parents) {
-            const value = node2 && typeof node2 === "object" ? node2 : {};
-            if (typeof value.type === "string") {
-                const name2 = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
-                Object.defineProperty(visit2, "name", {
-                    value: "node (" + color$1(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
-                });
-            }
-            return visit2;
-
-            function visit2() {
-                let result = [];
-                let subresult;
-                let offset2;
-                let grandparents;
-                if (!test2 || is2(node2, index2, parents[parents.length - 1] || null)) {
-                    result = toResult(visitor(node2, parents));
-                    if (result[0] === EXIT) {
-                        return result;
-                    }
-                }
-                if (node2.children && result[0] !== SKIP) {
-                    offset2 = (reverse ? node2.children.length : -1) + step2;
-                    grandparents = parents.concat(node2);
-                    while (offset2 > -1 && offset2 < node2.children.length) {
-                        subresult = factory2(node2.children[offset2], offset2, grandparents)();
-                        if (subresult[0] === EXIT) {
-                            return subresult;
-                        }
-                        offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step2;
-                    }
-                }
-                return result;
-            }
-        }
-    };
-
-    function toResult(value) {
-        if (Array.isArray(value)) {
-            return value;
-        }
-        if (typeof value === "number") {
-            return [CONTINUE, value];
-        }
-        return [value];
-    }
-    const visit = function(tree, test2, visitor, reverse) {
-        if (typeof test2 === "function" && typeof visitor !== "function") {
-            reverse = visitor;
-            visitor = test2;
-            test2 = null;
-        }
-        visitParents(tree, test2, overload, reverse);
-
-        function overload(node2, parents) {
-            const parent = parents[parents.length - 1];
-            return visitor(
-                node2,
-                parent ? parent.children.indexOf(node2) : null,
-                parent
-            );
-        }
-    };
-    const search = /[#.]/g;
-
-    function parseSelector(selector2, defaultTagName) {
-        const value = selector2 || "";
-        const props = {};
-        let start2 = 0;
-        let previous2;
-        let tagName;
-        while (start2 < value.length) {
-            search.lastIndex = start2;
-            const match2 = search.exec(value);
-            const subvalue = value.slice(start2, match2 ? match2.index : value.length);
-            if (subvalue) {
-                if (!previous2) {
-                    tagName = subvalue;
-                } else if (previous2 === "#") {
-                    props.id = subvalue;
-                } else if (Array.isArray(props.className)) {
-                    props.className.push(subvalue);
-                } else {
-                    props.className = [subvalue];
-                }
-                start2 += subvalue.length;
-            }
-            if (match2) {
-                previous2 = match2[0];
-                start2++;
-            }
-        }
-        return {
-            type: "element",
-            tagName: tagName || defaultTagName || "div",
-            properties: props,
-            children: []
-        };
-    }
-    const buttonTypes = /* @__PURE__ */ new Set(["menu", "submit", "reset", "button"]);
-    const own$3 = {}.hasOwnProperty;
-
-    function core$1(schema, defaultTagName, caseSensitive) {
-        const adjust = caseSensitive && createAdjustMap(caseSensitive);
-        const h2 = function(selector2, properties, ...children2) {
-            let index2 = -1;
-            let node2;
-            if (selector2 === void 0 || selector2 === null) {
-                node2 = {
-                    type: "root",
-                    children: []
-                };
-                children2.unshift(properties);
-            } else {
-                node2 = parseSelector(selector2, defaultTagName);
-                node2.tagName = node2.tagName.toLowerCase();
-                if (adjust && own$3.call(adjust, node2.tagName)) {
-                    node2.tagName = adjust[node2.tagName];
-                }
-                if (isProperties(properties, node2.tagName)) {
-                    let key;
-                    for (key in properties) {
-                        if (own$3.call(properties, key)) {
-                            addProperty(schema, node2.properties, key, properties[key]);
-                        }
-                    }
-                } else {
-                    children2.unshift(properties);
-                }
-            }
-            while (++index2 < children2.length) {
-                addChild(node2.children, children2[index2]);
-            }
-            if (node2.type === "element" && node2.tagName === "template") {
-                node2.content = {
-                    type: "root",
-                    children: node2.children
-                };
-                node2.children = [];
-            }
-            return node2;
-        };
-        return h2;
-    }
-
-    function isProperties(value, name2) {
-        if (value === null || value === void 0 || typeof value !== "object" || Array.isArray(value)) {
-            return false;
-        }
-        if (name2 === "input" || !value.type || typeof value.type !== "string") {
-            return true;
-        }
-        if ("children" in value && Array.isArray(value.children)) {
-            return false;
-        }
-        if (name2 === "button") {
-            return buttonTypes.has(value.type.toLowerCase());
-        }
-        return !("value" in value);
-    }
-
-    function addProperty(schema, properties, key, value) {
-        const info = find$3(schema, key);
-        let index2 = -1;
-        let result;
-        if (value === void 0 || value === null)
-            return;
-        if (typeof value === "number") {
-            if (Number.isNaN(value))
-                return;
-            result = value;
-        } else if (typeof value === "boolean") {
-            result = value;
-        } else if (typeof value === "string") {
-            if (info.spaceSeparated) {
-                result = parse$6(value);
-            } else if (info.commaSeparated) {
-                result = parse$7(value);
-            } else if (info.commaOrSpaceSeparated) {
-                result = parse$6(parse$7(value).join(" "));
-            } else {
-                result = parsePrimitive(info, info.property, value);
-            }
-        } else if (Array.isArray(value)) {
-            result = value.concat();
-        } else {
-            result = info.property === "style" ? style(value) : String(value);
-        }
-        if (Array.isArray(result)) {
-            const finalResult = [];
-            while (++index2 < result.length) {
-                finalResult[index2] = parsePrimitive(info, info.property, result[index2]);
-            }
-            result = finalResult;
-        }
-        if (info.property === "className" && Array.isArray(properties.className)) {
-            result = properties.className.concat(result);
-        }
-        properties[info.property] = result;
-    }
-
-    function addChild(nodes, value) {
-        let index2 = -1;
-        if (value === void 0 || value === null)
-        ;
-        else if (typeof value === "string" || typeof value === "number") {
-            nodes.push({
-                type: "text",
-                value: String(value)
-            });
-        } else if (Array.isArray(value)) {
-            while (++index2 < value.length) {
-                addChild(nodes, value[index2]);
-            }
-        } else if (typeof value === "object" && "type" in value) {
-            if (value.type === "root") {
-                addChild(nodes, value.children);
-            } else {
-                nodes.push(value);
-            }
-        } else {
-            throw new Error("Expected node, nodes, or string, got `" + value + "`");
-        }
-    }
-
-    function parsePrimitive(info, name2, value) {
-        if (typeof value === "string") {
-            if (info.number && value && !Number.isNaN(Number(value))) {
-                return Number(value);
-            }
-            if ((info.boolean || info.overloadedBoolean) && (value === "" || normalize$2(value) === normalize$2(name2))) {
-                return true;
-            }
-        }
-        return value;
-    }
-
-    function style(value) {
-        const result = [];
-        let key;
-        for (key in value) {
-            if (own$3.call(value, key)) {
-                result.push([key, value[key]].join(": "));
-            }
-        }
-        return result.join("; ");
-    }
-
-    function createAdjustMap(values) {
-        const result = {};
-        let index2 = -1;
-        while (++index2 < values.length) {
-            result[values[index2].toLowerCase()] = values[index2];
-        }
-        return result;
-    }
-    const h$1 = core$1(html$3, "div");
-    const svgCaseSensitiveTagNames = [
-        "altGlyph",
-        "altGlyphDef",
-        "altGlyphItem",
-        "animateColor",
-        "animateMotion",
-        "animateTransform",
-        "clipPath",
-        "feBlend",
-        "feColorMatrix",
-        "feComponentTransfer",
-        "feComposite",
-        "feConvolveMatrix",
-        "feDiffuseLighting",
-        "feDisplacementMap",
-        "feDistantLight",
-        "feDropShadow",
-        "feFlood",
-        "feFuncA",
-        "feFuncB",
-        "feFuncG",
-        "feFuncR",
-        "feGaussianBlur",
-        "feImage",
-        "feMerge",
-        "feMergeNode",
-        "feMorphology",
-        "feOffset",
-        "fePointLight",
-        "feSpecularLighting",
-        "feSpotLight",
-        "feTile",
-        "feTurbulence",
-        "foreignObject",
-        "glyphRef",
-        "linearGradient",
-        "radialGradient",
-        "solidColor",
-        "textArea",
-        "textPath"
-    ];
-    const s$1 = core$1(svg, "g", svgCaseSensitiveTagNames);
-
-    function location(file) {
-        const value = String(file);
-        const indices2 = [];
-        const search2 = /\r?\n|\r/g;
-        while (search2.test(value)) {
-            indices2.push(search2.lastIndex);
-        }
-        indices2.push(value.length + 1);
-        return {
-            toPoint,
-            toOffset
-        };
-
-        function toPoint(offset2) {
-            let index2 = -1;
-            if (typeof offset2 === "number" && offset2 > -1 && offset2 < indices2[indices2.length - 1]) {
-                while (++index2 < indices2.length) {
-                    if (indices2[index2] > offset2) {
-                        return {
-                            line: index2 + 1,
-                            column: offset2 - (index2 > 0 ? indices2[index2 - 1] : 0) + 1,
-                            offset: offset2
-                        };
-                    }
-                }
-            }
-            return {
-                line: void 0,
-                column: void 0,
-                offset: void 0
-            };
-        }
-
-        function toOffset(point2) {
-            const line = point2 && point2.line;
-            const column = point2 && point2.column;
-            if (typeof line === "number" && typeof column === "number" && !Number.isNaN(line) && !Number.isNaN(column) && line - 1 in indices2) {
-                const offset2 = (indices2[line - 2] || 0) + column - 1 || 0;
-                if (offset2 > -1 && offset2 < indices2[indices2.length - 1]) {
-                    return offset2;
-                }
-            }
-            return -1;
-        }
-    }
-    const webNamespaces = {
-        html: "http://www.w3.org/1999/xhtml",
-        mathml: "http://www.w3.org/1998/Math/MathML",
-        svg: "http://www.w3.org/2000/svg",
-        xlink: "http://www.w3.org/1999/xlink",
-        xml: "http://www.w3.org/XML/1998/namespace",
-        xmlns: "http://www.w3.org/2000/xmlns/"
-    };
-    const own$2 = {}.hasOwnProperty;
-    const proto = Object.prototype;
-
-    function fromParse5(tree, options) {
-        const options_ = options || {};
-        let settings2;
-        let file;
-        if (isFile(options_)) {
-            file = options_;
-            settings2 = {};
-        } else {
-            file = options_.file || void 0;
-            settings2 = options_;
-        }
-        return one$2({
-                schema: settings2.space === "svg" ? svg : html$3,
-                file,
-                verbose: settings2.verbose,
-                location: false
-            },
-            tree
-        );
-    }
-
-    function one$2(state, node2) {
-        let result;
-        switch (node2.nodeName) {
-            case "#comment": {
-                const reference2 = node2;
-                result = {
-                    type: "comment",
-                    value: reference2.data
-                };
-                patch$1(state, reference2, result);
-                return result;
-            }
-            case "#document":
-            case "#document-fragment": {
-                const reference2 = node2;
-                const quirksMode = "mode" in reference2 ? reference2.mode === "quirks" || reference2.mode === "limited-quirks" : false;
-                result = {
-                    type: "root",
-                    children: all$1(state, node2.childNodes),
-                    data: {
-                        quirksMode
-                    }
-                };
-                if (state.file && state.location) {
-                    const doc2 = String(state.file);
-                    const loc = location(doc2);
-                    const start2 = loc.toPoint(0);
-                    const end2 = loc.toPoint(doc2.length);
-                    result.position = {
-                        start: start2,
-                        end: end2
-                    };
-                }
-                return result;
-            }
-            case "#documentType": {
-                const reference2 = node2;
-                result = {
-                    type: "doctype"
-                };
-                patch$1(state, reference2, result);
-                return result;
-            }
-            case "#text": {
-                const reference2 = node2;
-                result = {
-                    type: "text",
-                    value: reference2.value
-                };
-                patch$1(state, reference2, result);
-                return result;
-            }
-            default: {
-                const reference2 = node2;
-                result = element$2(state, reference2);
-                return result;
-            }
-        }
-    }
-
-    function all$1(state, nodes) {
-        let index2 = -1;
-        const result = [];
-        while (++index2 < nodes.length) {
-            result[index2] = one$2(state, nodes[index2]);
-        }
-        return result;
-    }
-
-    function element$2(state, node2) {
-        const schema = state.schema;
-        state.schema = node2.namespaceURI === webNamespaces.svg ? svg : html$3;
-        let index2 = -1;
-        const props = {};
-        while (++index2 < node2.attrs.length) {
-            const attribute = node2.attrs[index2];
-            const name2 = (attribute.prefix ? attribute.prefix + ":" : "") + attribute.name;
-            if (!own$2.call(proto, name2)) {
-                props[name2] = attribute.value;
-            }
-        }
-        const fn2 = state.schema.space === "svg" ? s$1 : h$1;
-        const result = fn2(node2.tagName, props, all$1(state, node2.childNodes));
-        patch$1(state, node2, result);
-        if (result.tagName === "template") {
-            const reference2 = node2;
-            const pos = reference2.sourceCodeLocation;
-            const startTag2 = pos && pos.startTag && position$1(pos.startTag);
-            const endTag2 = pos && pos.endTag && position$1(pos.endTag);
-            const content2 = one$2(state, reference2.content);
-            if (startTag2 && endTag2 && state.file) {
-                content2.position = {
-                    start: startTag2.end,
-                    end: endTag2.start
-                };
-            }
-            result.content = content2;
-        }
-        state.schema = schema;
-        return result;
-    }
-
-    function patch$1(state, from, to2) {
-        if ("sourceCodeLocation" in from && from.sourceCodeLocation && state.file) {
-            const position2 = createLocation(state, to2, from.sourceCodeLocation);
-            if (position2) {
-                state.location = true;
-                to2.position = position2;
-            }
-        }
-    }
-
-    function createLocation(state, node2, location2) {
-        const result = position$1(location2);
-        if (node2.type === "element") {
-            const tail = node2.children[node2.children.length - 1];
-            if (result && !location2.endTag && tail && tail.position && tail.position.end) {
-                result.end = Object.assign({}, tail.position.end);
-            }
-            if (state.verbose) {
-                const props = {};
-                let key;
-                if (location2.attrs) {
-                    for (key in location2.attrs) {
-                        if (own$2.call(location2.attrs, key)) {
-                            props[find$3(state.schema, key).property] = position$1(
-                                location2.attrs[key]
-                            );
-                        }
-                    }
-                }
-                node2.data = {
-                    position: {
-                        opening: position$1(location2.startTag),
-                        closing: location2.endTag ? position$1(location2.endTag) : null,
-                        properties: props
-                    }
-                };
-            }
-        }
-        return result;
-    }
-
-    function position$1(loc) {
-        const start2 = point({
-            line: loc.startLine,
-            column: loc.startCol,
-            offset: loc.startOffset
-        });
-        const end2 = point({
-            line: loc.endLine,
-            column: loc.endCol,
-            offset: loc.endOffset
-        });
-        return start2 || end2 ? {
-            start: start2,
-            end: end2
-        } : void 0;
-    }
-
-    function point(point2) {
-        return point2.line && point2.column ? point2 : void 0;
-    }
-
-    function isFile(value) {
-        return "messages" in value;
-    }
-    const own$1 = {}.hasOwnProperty;
-
-    function zwitch(key, options) {
-        const settings2 = options || {};
-
-        function one2(value, ...parameters) {
-            let fn2 = one2.invalid;
-            const handlers2 = one2.handlers;
-            if (value && own$1.call(value, key)) {
-                const id2 = String(value[key]);
-                fn2 = own$1.call(handlers2, id2) ? handlers2[id2] : one2.unknown;
-            }
-            if (fn2) {
-                return fn2.call(this, value, ...parameters);
-            }
-        }
-        one2.handlers = settings2.handlers || {};
-        one2.invalid = settings2.invalid;
-        one2.unknown = settings2.unknown;
-        return one2;
-    }
-    const own = {}.hasOwnProperty;
-    const one$1 = zwitch("type", {
-        handlers: {
-            root: root$2,
-            element: element$1,
-            text: text$2,
-            comment: comment$1,
-            doctype
-        }
-    });
-
-    function toParse5(tree, options) {
-        const space2 = options && typeof options === "object" ? options.space : options;
-        return one$1(tree, space2 === "svg" ? svg : html$3);
-    }
-
-    function root$2(node2, schema) {
-        const result = {
-            nodeName: "#document",
-            mode: (node2.data || {}).quirksMode ? "quirks" : "no-quirks",
-            childNodes: []
-        };
-        result.childNodes = all(node2.children, result, schema);
-        patch(node2, result);
-        return result;
-    }
-
-    function fragment$8(node2, schema) {
-        const result = {
-            nodeName: "#document-fragment",
-            childNodes: []
-        };
-        result.childNodes = all(node2.children, result, schema);
-        patch(node2, result);
-        return result;
-    }
-
-    function doctype(node2) {
-        const result = {
-            nodeName: "#documentType",
-            name: "html",
-            publicId: "",
-            systemId: "",
-            parentNode: void 0
-        };
-        patch(node2, result);
-        return result;
-    }
-
-    function text$2(node2) {
-        const result = {
-            nodeName: "#text",
-            value: node2.value,
-            parentNode: void 0
-        };
-        patch(node2, result);
-        return result;
-    }
-
-    function comment$1(node2) {
-        const result = {
-            nodeName: "#comment",
-            data: node2.value,
-            parentNode: void 0
-        };
-        patch(node2, result);
-        return result;
-    }
-
-    function element$1(node2, schema) {
-        const parentSchema = schema;
-        let currentSchema = parentSchema;
-        if (node2.type === "element" && node2.tagName.toLowerCase() === "svg" && parentSchema.space === "html") {
-            currentSchema = svg;
-        }
-        const attrs2 = [];
-        let prop;
-        if (node2.properties) {
-            for (prop in node2.properties) {
-                if (prop !== "children" && own.call(node2.properties, prop)) {
-                    const result2 = createProperty(
-                        currentSchema,
-                        prop,
-                        node2.properties[prop]
-                    );
-                    if (result2) {
-                        attrs2.push(result2);
-                    }
-                }
-            }
-        }
-        const result = {
-            nodeName: node2.tagName,
-            tagName: node2.tagName,
-            attrs: attrs2,
-            namespaceURI: webNamespaces[currentSchema.space],
-            childNodes: [],
-            parentNode: void 0
-        };
-        result.childNodes = all(node2.children, result, currentSchema);
-        patch(node2, result);
-        if (node2.tagName === "template" && node2.content) {
-            result.content = fragment$8(node2.content, currentSchema);
-        }
-        return result;
-    }
-
-    function createProperty(schema, prop, value) {
-        const info = find$3(schema, prop);
-        if (value === void 0 || value === null || value === false || typeof value === "number" && Number.isNaN(value) || !value && info.boolean) {
-            return;
-        }
-        if (Array.isArray(value)) {
-            value = info.commaSeparated ? stringify$3(value) : stringify$2(value);
-        }
-        const attribute = {
-            name: info.attribute,
-            value: value === true ? "" : String(value)
-        };
-        if (info.space && info.space !== "html" && info.space !== "svg") {
-            const index2 = attribute.name.indexOf(":");
-            if (index2 < 0) {
-                attribute.prefix = "";
-            } else {
-                attribute.name = attribute.name.slice(index2 + 1);
-                attribute.prefix = info.attribute.slice(0, index2);
-            }
-            attribute.namespace = webNamespaces[info.space];
-        }
-        return attribute;
-    }
-
-    function all(children2, parentNode, schema) {
-        let index2 = -1;
-        const results = [];
-        if (children2) {
-            while (++index2 < children2.length) {
-                const child = one$1(children2[index2], schema);
-                child.parentNode = parentNode;
-                results.push(child);
-            }
-        }
-        return results;
-    }
-
-    function patch(from, to2) {
-        const position2 = from.position;
-        if (position2 && position2.start && position2.end) {
-            to2.sourceCodeLocation = {
-                startLine: position2.start.line,
-                startCol: position2.start.column,
-                startOffset: position2.start.offset,
-                endLine: position2.end.line,
-                endCol: position2.end.column,
-                endOffset: position2.end.offset
-            };
-        }
-    }
-    const htmlVoidElements = [
-        "area",
-        "base",
-        "basefont",
-        "bgsound",
-        "br",
-        "col",
-        "command",
-        "embed",
-        "frame",
-        "hr",
-        "image",
-        "img",
-        "input",
-        "isindex",
-        "keygen",
-        "link",
-        "menuitem",
-        "meta",
-        "nextid",
-        "param",
-        "source",
-        "track",
-        "wbr"
-    ];
-    const inTemplateMode = "IN_TEMPLATE_MODE";
-    const dataState = "DATA_STATE";
-    const characterToken = "CHARACTER_TOKEN";
-    const startTagToken = "START_TAG_TOKEN";
-    const endTagToken = "END_TAG_TOKEN";
-    const commentToken = "COMMENT_TOKEN";
-    const doctypeToken = "DOCTYPE_TOKEN";
-    const parseOptions = {
-        sourceCodeLocationInfo: true,
-        scriptingEnabled: false
-    };
-    const raw = function(tree, file, options) {
-        let index2 = -1;
-        const parser2 = new parser$3(parseOptions);
-        const one2 = zwitch("type", {
-            handlers: {
-                root: root2,
-                element: element2,
-                text: text2,
-                comment: comment2,
-                doctype: doctype2,
-                raw: handleRaw
-            },
-            unknown
-        });
-        let stitches;
-        let tokenizer2;
-        let preprocessor2;
-        let posTracker;
-        let locationTracker;
-        if (isOptions(file)) {
-            options = file;
-            file = void 0;
-        }
-        if (options && options.passThrough) {
-            while (++index2 < options.passThrough.length) {
-                one2.handlers[options.passThrough[index2]] = stitch;
-            }
-        }
-        const result = fromParse5(
-            documentMode(tree) ? document2() : fragment2(),
-            file
-        );
-        if (stitches) {
-            visit(result, "comment", (node2, index3, parent) => {
-                const stitch2 = node2;
-                if (stitch2.value.stitch && parent !== null && index3 !== null) {
-                    parent.children[index3] = stitch2.value.stitch;
-                    return index3;
-                }
-            });
-        }
-        if (tree.type !== "root" && result.type === "root" && result.children.length === 1) {
-            return result.children[0];
-        }
-        return result;
-
-        function fragment2() {
-            const context2 = {
-                nodeName: "template",
-                tagName: "template",
-                attrs: [],
-                namespaceURI: webNamespaces.html,
-                childNodes: []
-            };
-            const mock = {
-                nodeName: "documentmock",
-                tagName: "documentmock",
-                attrs: [],
-                namespaceURI: webNamespaces.html,
-                childNodes: []
-            };
-            const doc2 = {
-                nodeName: "#document-fragment",
-                childNodes: []
-            };
-            parser2._bootstrap(mock, context2);
-            parser2._pushTmplInsertionMode(inTemplateMode);
-            parser2._initTokenizerForFragmentParsing();
-            parser2._insertFakeRootElement();
-            parser2._resetInsertionMode();
-            parser2._findFormInFragmentContext();
-            tokenizer2 = parser2.tokenizer;
-            if (!tokenizer2)
-                throw new Error("Expected `tokenizer`");
-            preprocessor2 = tokenizer2.preprocessor;
-            locationTracker = tokenizer2.__mixins[0];
-            posTracker = locationTracker.posTracker;
-            one2(tree);
-            resetTokenizer();
-            parser2._adoptNodes(mock.childNodes[0], doc2);
-            return doc2;
-        }
-
-        function document2() {
-            const doc2 = parser2.treeAdapter.createDocument();
-            parser2._bootstrap(doc2, void 0);
-            tokenizer2 = parser2.tokenizer;
-            if (!tokenizer2)
-                throw new Error("Expected `tokenizer`");
-            preprocessor2 = tokenizer2.preprocessor;
-            locationTracker = tokenizer2.__mixins[0];
-            posTracker = locationTracker.posTracker;
-            one2(tree);
-            resetTokenizer();
-            return doc2;
-        }
-
-        function all2(nodes) {
-            let index3 = -1;
-            if (nodes) {
-                while (++index3 < nodes.length) {
-                    one2(nodes[index3]);
-                }
-            }
-        }
-
-        function root2(node2) {
-            all2(node2.children);
-        }
-
-        function element2(node2) {
-            resetTokenizer();
-            parser2._processInputToken(startTag(node2));
-            all2(node2.children);
-            if (!htmlVoidElements.includes(node2.tagName)) {
-                resetTokenizer();
-                parser2._processInputToken(endTag(node2));
-            }
-        }
-
-        function text2(node2) {
-            resetTokenizer();
-            parser2._processInputToken({
-                type: characterToken,
-                chars: node2.value,
-                location: createParse5Location(node2)
-            });
-        }
-
-        function doctype2(node2) {
-            resetTokenizer();
-            parser2._processInputToken({
-                type: doctypeToken,
-                name: "html",
-                forceQuirks: false,
-                publicId: "",
-                systemId: "",
-                location: createParse5Location(node2)
-            });
-        }
-
-        function comment2(node2) {
-            resetTokenizer();
-            parser2._processInputToken({
-                type: commentToken,
-                data: node2.value,
-                location: createParse5Location(node2)
-            });
-        }
-
-        function handleRaw(node2) {
-            const start2 = pointStart(node2);
-            const line = start2.line || 1;
-            const column = start2.column || 1;
-            const offset2 = start2.offset || 0;
-            if (!preprocessor2)
-                throw new Error("Expected `preprocessor`");
-            if (!tokenizer2)
-                throw new Error("Expected `tokenizer`");
-            if (!posTracker)
-                throw new Error("Expected `posTracker`");
-            if (!locationTracker)
-                throw new Error("Expected `locationTracker`");
-            preprocessor2.html = void 0;
-            preprocessor2.pos = -1;
-            preprocessor2.lastGapPos = -1;
-            preprocessor2.lastCharPos = -1;
-            preprocessor2.gapStack = [];
-            preprocessor2.skipNextNewLine = false;
-            preprocessor2.lastChunkWritten = false;
-            preprocessor2.endOfChunkHit = false;
-            posTracker.isEol = false;
-            posTracker.lineStartPos = -column + 1;
-            posTracker.droppedBufferSize = offset2;
-            posTracker.offset = 0;
-            posTracker.col = 1;
-            posTracker.line = line;
-            locationTracker.currentAttrLocation = void 0;
-            locationTracker.ctLoc = createParse5Location(node2);
-            tokenizer2.write(node2.value);
-            parser2._runParsingLoop(null);
-            if (tokenizer2.state === "NAMED_CHARACTER_REFERENCE_STATE" || tokenizer2.state === "NUMERIC_CHARACTER_REFERENCE_END_STATE") {
-                preprocessor2.lastChunkWritten = true;
-                tokenizer2[tokenizer2.state](tokenizer2._consume());
-            }
-        }
-
-        function stitch(node2) {
-            stitches = true;
-            let clone2;
-            if ("children" in node2) {
-                clone2 = {
-                    ...node2,
-                    children: raw({
-                            type: "root",
-                            children: node2.children
-                        },
-                        file,
-                        options
-                    ).children
-                };
-            } else {
-                clone2 = {
-                    ...node2
-                };
-            }
-            comment2({
-                type: "comment",
-                value: {
-                    stitch: clone2
-                }
-            });
-        }
-
-        function resetTokenizer() {
-            if (!tokenizer2)
-                throw new Error("Expected `tokenizer`");
-            if (!posTracker)
-                throw new Error("Expected `posTracker`");
-            const token = tokenizer2.currentCharacterToken;
-            if (token) {
-                token.location.endLine = posTracker.line;
-                token.location.endCol = posTracker.col + 1;
-                token.location.endOffset = posTracker.offset + 1;
-                parser2._processInputToken(token);
-            }
-            tokenizer2.tokenQueue = [];
-            tokenizer2.state = dataState;
-            tokenizer2.returnState = "";
-            tokenizer2.charRefCode = -1;
-            tokenizer2.tempBuff = [];
-            tokenizer2.lastStartTagName = "";
-            tokenizer2.consumedAfterSnapshot = -1;
-            tokenizer2.active = false;
-            tokenizer2.currentCharacterToken = void 0;
-            tokenizer2.currentToken = void 0;
-            tokenizer2.currentAttr = void 0;
-        }
-    };
-
-    function startTag(node2) {
-        const location2 = Object.assign(createParse5Location(node2));
-        location2.startTag = Object.assign({}, location2);
-        return {
-            type: startTagToken,
-            tagName: node2.tagName,
-            selfClosing: false,
-            attrs: attributes(node2),
-            location: location2
-        };
-    }
-
-    function attributes(node2) {
-        return toParse5({
-            tagName: node2.tagName,
-            type: "element",
-            properties: node2.properties,
-            children: []
-        }).attrs;
-    }
-
-    function endTag(node2) {
-        const location2 = Object.assign(createParse5Location(node2));
-        location2.startTag = Object.assign({}, location2);
-        return {
-            type: endTagToken,
-            tagName: node2.tagName,
-            attrs: [],
-            location: location2
-        };
-    }
-
-    function unknown(node2) {
-        throw new Error("Cannot compile `" + node2.type + "` node");
-    }
-
-    function documentMode(node2) {
-        const head = node2.type === "root" ? node2.children[0] : node2;
-        return Boolean(
-            head && (head.type === "doctype" || head.type === "element" && head.tagName === "html")
-        );
-    }
-
-    function createParse5Location(node2) {
-        const start2 = pointStart(node2);
-        const end2 = pointEnd(node2);
-        return {
-            startLine: start2.line,
-            startCol: start2.column,
-            startOffset: start2.offset,
-            endLine: end2.line,
-            endCol: end2.column,
-            endOffset: end2.offset
-        };
-    }
-
-    function isOptions(value) {
-        return Boolean(value && !("message" in value && "messages" in value));
-    }
-
-    function rehypeRaw(options = {}) {
-        return (tree, file) => {
-            const result = raw(tree, file, options);
-            return result;
-        };
-    }
-
-    function ccount(value, character) {
-        const source = String(value);
-        if (typeof character !== "string") {
-            throw new TypeError("Expected character");
-        }
-        let count2 = 0;
-        let index2 = source.indexOf(character);
-        while (index2 !== -1) {
-            count2++;
-            index2 = source.indexOf(character, index2 + character.length);
-        }
-        return count2;
-    }
-
-    function escapeStringRegexp(string2) {
-        if (typeof string2 !== "string") {
-            throw new TypeError("Expected a string");
-        }
-        return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
-    }
-
-    function findAndReplace(tree, list2, options) {
-        const settings2 = options || {};
-        const ignored = convert$1(settings2.ignore || []);
-        const pairs = toPairs(list2);
-        let pairIndex = -1;
-        while (++pairIndex < pairs.length) {
-            visitParents$1(tree, "text", visitor);
-        }
-
-        function visitor(node2, parents) {
-            let index2 = -1;
-            let grandparent;
-            while (++index2 < parents.length) {
-                const parent = parents[index2];
-                const siblings = grandparent ? grandparent.children : void 0;
-                if (ignored(
-                        parent,
-                        siblings ? siblings.indexOf(parent) : void 0,
-                        grandparent
-                    )) {
-                    return;
-                }
-                grandparent = parent;
-            }
-            if (grandparent) {
-                return handler(node2, parents);
-            }
-        }
-
-        function handler(node2, parents) {
-            const parent = parents[parents.length - 1];
-            const find2 = pairs[pairIndex][0];
-            const replace2 = pairs[pairIndex][1];
-            let start2 = 0;
-            const siblings = parent.children;
-            const index2 = siblings.indexOf(node2);
-            let change = false;
-            let nodes = [];
-            find2.lastIndex = 0;
-            let match2 = find2.exec(node2.value);
-            while (match2) {
-                const position2 = match2.index;
-                const matchObject = {
-                    index: match2.index,
-                    input: match2.input,
-                    stack: [...parents, node2]
-                };
-                let value = replace2(...match2, matchObject);
-                if (typeof value === "string") {
-                    value = value.length > 0 ? {
-                        type: "text",
-                        value
-                    } : void 0;
-                }
-                if (value === false) {
-                    find2.lastIndex = position2 + 1;
-                } else {
-                    if (start2 !== position2) {
-                        nodes.push({
-                            type: "text",
-                            value: node2.value.slice(start2, position2)
-                        });
-                    }
-                    if (Array.isArray(value)) {
-                        nodes.push(...value);
-                    } else if (value) {
-                        nodes.push(value);
-                    }
-                    start2 = position2 + match2[0].length;
-                    change = true;
-                }
-                if (!find2.global) {
-                    break;
-                }
-                match2 = find2.exec(node2.value);
-            }
-            if (change) {
-                if (start2 < node2.value.length) {
-                    nodes.push({
-                        type: "text",
-                        value: node2.value.slice(start2)
-                    });
-                }
-                parent.children.splice(index2, 1, ...nodes);
-            } else {
-                nodes = [node2];
-            }
-            return index2 + nodes.length;
-        }
-    }
-
-    function toPairs(tupleOrList) {
-        const result = [];
-        if (!Array.isArray(tupleOrList)) {
-            throw new TypeError("Expected find and replace tuple or list of tuples");
-        }
-        const list2 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
-        let index2 = -1;
-        while (++index2 < list2.length) {
-            const tuple = list2[index2];
-            result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
-        }
-        return result;
-    }
-
-    function toExpression(find2) {
-        return typeof find2 === "string" ? new RegExp(escapeStringRegexp(find2), "g") : find2;
-    }
-
-    function toFunction(replace2) {
-        return typeof replace2 === "function" ? replace2 : function() {
-            return replace2;
-        };
-    }
-    const inConstruct = "phrasing";
-    const notInConstruct = ["autolink", "link", "image", "label"];
-
-    function gfmAutolinkLiteralFromMarkdown() {
-        return {
-            transforms: [transformGfmAutolinkLiterals],
-            enter: {
-                literalAutolink: enterLiteralAutolink,
-                literalAutolinkEmail: enterLiteralAutolinkValue,
-                literalAutolinkHttp: enterLiteralAutolinkValue,
-                literalAutolinkWww: enterLiteralAutolinkValue
-            },
-            exit: {
-                literalAutolink: exitLiteralAutolink,
-                literalAutolinkEmail: exitLiteralAutolinkEmail,
-                literalAutolinkHttp: exitLiteralAutolinkHttp,
-                literalAutolinkWww: exitLiteralAutolinkWww
-            }
-        };
-    }
-
-    function gfmAutolinkLiteralToMarkdown() {
-        return {
-            unsafe: [{
-                character: "@",
-                before: "[+\\-.\\w]",
-                after: "[\\-.\\w]",
-                inConstruct,
-                notInConstruct
-            }, {
-                character: ".",
-                before: "[Ww]",
-                after: "[\\-.\\w]",
-                inConstruct,
-                notInConstruct
-            }, {
-                character: ":",
-                before: "[ps]",
-                after: "\\/",
-                inConstruct,
-                notInConstruct
-            }]
-        };
-    }
-
-    function enterLiteralAutolink(token) {
-        this.enter({
-            type: "link",
-            title: null,
-            url: "",
-            children: []
-        }, token);
-    }
-
-    function enterLiteralAutolinkValue(token) {
-        this.config.enter.autolinkProtocol.call(this, token);
-    }
-
-    function exitLiteralAutolinkHttp(token) {
-        this.config.exit.autolinkProtocol.call(this, token);
-    }
-
-    function exitLiteralAutolinkWww(token) {
-        this.config.exit.data.call(this, token);
-        const node2 = this.stack[this.stack.length - 1];
-        ok$2(node2.type === "link");
-        node2.url = "http://" + this.sliceSerialize(token);
-    }
-
-    function exitLiteralAutolinkEmail(token) {
-        this.config.exit.autolinkEmail.call(this, token);
-    }
-
-    function exitLiteralAutolink(token) {
-        this.exit(token);
-    }
-
-    function transformGfmAutolinkLiterals(tree) {
-        findAndReplace(
-            tree,
-            [
-                [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
-                [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
-            ], {
-                ignore: ["link", "linkReference"]
-            }
-        );
-    }
-
-    function findUrl(_2, protocol, domain2, path2, match2) {
-        let prefix = "";
-        if (!previous(match2)) {
-            return false;
-        }
-        if (/^w/i.test(protocol)) {
-            domain2 = protocol + domain2;
-            protocol = "";
-            prefix = "http://";
-        }
-        if (!isCorrectDomain(domain2)) {
-            return false;
-        }
-        const parts = splitUrl(domain2 + path2);
-        if (!parts[0])
-            return false;
-        const result = {
-            type: "link",
-            title: null,
-            url: prefix + protocol + parts[0],
-            children: [{
-                type: "text",
-                value: protocol + parts[0]
-            }]
-        };
-        if (parts[1]) {
-            return [result, {
-                type: "text",
-                value: parts[1]
-            }];
-        }
-        return result;
-    }
-
-    function findEmail(_2, atext, label, match2) {
-        if (!previous(match2, true) || /[-\d_]$/.test(label)) {
-            return false;
-        }
-        return {
-            type: "link",
-            title: null,
-            url: "mailto:" + atext + "@" + label,
-            children: [{
-                type: "text",
-                value: atext + "@" + label
-            }]
-        };
-    }
-
-    function isCorrectDomain(domain2) {
-        const parts = domain2.split(".");
-        if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
-            return false;
-        }
-        return true;
-    }
-
-    function splitUrl(url2) {
-        const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url2);
-        if (!trailExec) {
-            return [url2, void 0];
-        }
-        url2 = url2.slice(0, trailExec.index);
-        let trail2 = trailExec[0];
-        let closingParenIndex = trail2.indexOf(")");
-        const openingParens = ccount(url2, "(");
-        let closingParens = ccount(url2, ")");
-        while (closingParenIndex !== -1 && openingParens > closingParens) {
-            url2 += trail2.slice(0, closingParenIndex + 1);
-            trail2 = trail2.slice(closingParenIndex + 1);
-            closingParenIndex = trail2.indexOf(")");
-            closingParens++;
-        }
-        return [url2, trail2];
-    }
-
-    function previous(match2, email) {
-        const code2 = match2.input.charCodeAt(match2.index - 1);
-        return (match2.index === 0 || unicodeWhitespace(code2) || unicodePunctuation(code2)) && (!email || code2 !== 47);
-    }
-    footnoteReference.peek = footnoteReferencePeek;
-
-    function gfmFootnoteFromMarkdown() {
-        return {
-            enter: {
-                gfmFootnoteDefinition: enterFootnoteDefinition,
-                gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
-                gfmFootnoteCall: enterFootnoteCall,
-                gfmFootnoteCallString: enterFootnoteCallString
-            },
-            exit: {
-                gfmFootnoteDefinition: exitFootnoteDefinition,
-                gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
-                gfmFootnoteCall: exitFootnoteCall,
-                gfmFootnoteCallString: exitFootnoteCallString
-            }
-        };
-    }
-
-    function gfmFootnoteToMarkdown() {
-        return {
-            unsafe: [{
-                character: "[",
-                inConstruct: ["phrasing", "label", "reference"]
-            }],
-            handlers: {
-                footnoteDefinition,
-                footnoteReference
-            }
-        };
-    }
-
-    function enterFootnoteDefinition(token) {
-        this.enter({
-                type: "footnoteDefinition",
-                identifier: "",
-                label: "",
-                children: []
-            },
-            token
-        );
-    }
-
-    function enterFootnoteDefinitionLabelString() {
-        this.buffer();
-    }
-
-    function exitFootnoteDefinitionLabelString(token) {
-        const label = this.resume();
-        const node2 = this.stack[this.stack.length - 1];
-        ok$2(node2.type === "footnoteDefinition");
-        node2.label = label;
-        node2.identifier = normalizeIdentifier(
-            this.sliceSerialize(token)
-        ).toLowerCase();
-    }
-
-    function exitFootnoteDefinition(token) {
-        this.exit(token);
-    }
-
-    function enterFootnoteCall(token) {
-        this.enter({
-            type: "footnoteReference",
-            identifier: "",
-            label: ""
-        }, token);
-    }
-
-    function enterFootnoteCallString() {
-        this.buffer();
-    }
-
-    function exitFootnoteCallString(token) {
-        const label = this.resume();
-        const node2 = this.stack[this.stack.length - 1];
-        ok$2(node2.type === "footnoteReference");
-        node2.label = label;
-        node2.identifier = normalizeIdentifier(
-            this.sliceSerialize(token)
-        ).toLowerCase();
-    }
-
-    function exitFootnoteCall(token) {
-        this.exit(token);
-    }
-
-    function footnoteReference(node2, _2, state, info) {
-        const tracker = state.createTracker(info);
-        let value = tracker.move("[^");
-        const exit2 = state.enter("footnoteReference");
-        const subexit = state.enter("reference");
-        value += tracker.move(
-            state.safe(state.associationId(node2), {
-                ...tracker.current(),
-                before: value,
-                after: "]"
-            })
-        );
-        subexit();
-        exit2();
-        value += tracker.move("]");
-        return value;
-    }
-
-    function footnoteReferencePeek() {
-        return "[";
-    }
-
-    function footnoteDefinition(node2, _2, state, info) {
-        const tracker = state.createTracker(info);
-        let value = tracker.move("[^");
-        const exit2 = state.enter("footnoteDefinition");
-        const subexit = state.enter("label");
-        value += tracker.move(
-            state.safe(state.associationId(node2), {
-                ...tracker.current(),
-                before: value,
-                after: "]"
-            })
-        );
-        subexit();
-        value += tracker.move(
-            "]:" + (node2.children && node2.children.length > 0 ? " " : "")
-        );
-        tracker.shift(4);
-        value += tracker.move(
-            state.indentLines(state.containerFlow(node2, tracker.current()), map$4)
-        );
-        exit2();
-        return value;
-    }
-
-    function map$4(line, index2, blank) {
-        if (index2 === 0) {
-            return line;
-        }
-        return (blank ? "" : "    ") + line;
-    }
-    const constructsWithoutStrikethrough = [
-        "autolink",
-        "destinationLiteral",
-        "destinationRaw",
-        "reference",
-        "titleQuote",
-        "titleApostrophe"
-    ];
-    handleDelete.peek = peekDelete;
-
-    function gfmStrikethroughFromMarkdown() {
-        return {
-            canContainEols: ["delete"],
-            enter: {
-                strikethrough: enterStrikethrough
-            },
-            exit: {
-                strikethrough: exitStrikethrough
-            }
-        };
-    }
-
-    function gfmStrikethroughToMarkdown() {
-        return {
-            unsafe: [{
-                character: "~",
-                inConstruct: "phrasing",
-                notInConstruct: constructsWithoutStrikethrough
-            }],
-            handlers: {
-                delete: handleDelete
-            }
-        };
-    }
-
-    function enterStrikethrough(token) {
-        this.enter({
-            type: "delete",
-            children: []
-        }, token);
-    }
-
-    function exitStrikethrough(token) {
-        this.exit(token);
-    }
-
-    function handleDelete(node2, _2, state, info) {
-        const tracker = state.createTracker(info);
-        const exit2 = state.enter("strikethrough");
-        let value = tracker.move("~~");
-        value += state.containerPhrasing(node2, {
-            ...tracker.current(),
-            before: value,
-            after: "~"
-        });
-        value += tracker.move("~~");
-        exit2();
-        return value;
-    }
-
-    function peekDelete() {
-        return "~";
-    }
-
-    function markdownTable(table2, options = {}) {
-        const align = (options.align || []).concat();
-        const stringLength = options.stringLength || defaultStringLength;
-        const alignments = [];
-        const cellMatrix = [];
-        const sizeMatrix = [];
-        const longestCellByColumn = [];
-        let mostCellsPerRow = 0;
-        let rowIndex = -1;
-        while (++rowIndex < table2.length) {
-            const row2 = [];
-            const sizes2 = [];
-            let columnIndex2 = -1;
-            if (table2[rowIndex].length > mostCellsPerRow) {
-                mostCellsPerRow = table2[rowIndex].length;
-            }
-            while (++columnIndex2 < table2[rowIndex].length) {
-                const cell = serialize(table2[rowIndex][columnIndex2]);
-                if (options.alignDelimiters !== false) {
-                    const size2 = stringLength(cell);
-                    sizes2[columnIndex2] = size2;
-                    if (longestCellByColumn[columnIndex2] === void 0 || size2 > longestCellByColumn[columnIndex2]) {
-                        longestCellByColumn[columnIndex2] = size2;
-                    }
-                }
-                row2.push(cell);
-            }
-            cellMatrix[rowIndex] = row2;
-            sizeMatrix[rowIndex] = sizes2;
-        }
-        let columnIndex = -1;
-        if (typeof align === "object" && "length" in align) {
-            while (++columnIndex < mostCellsPerRow) {
-                alignments[columnIndex] = toAlignment(align[columnIndex]);
-            }
-        } else {
-            const code2 = toAlignment(align);
-            while (++columnIndex < mostCellsPerRow) {
-                alignments[columnIndex] = code2;
-            }
-        }
-        columnIndex = -1;
-        const row = [];
-        const sizes = [];
-        while (++columnIndex < mostCellsPerRow) {
-            const code2 = alignments[columnIndex];
-            let before = "";
-            let after = "";
-            if (code2 === 99) {
-                before = ":";
-                after = ":";
-            } else if (code2 === 108) {
-                before = ":";
-            } else if (code2 === 114) {
-                after = ":";
-            }
-            let size2 = options.alignDelimiters === false ? 1 : Math.max(
-                1,
-                longestCellByColumn[columnIndex] - before.length - after.length
-            );
-            const cell = before + "-".repeat(size2) + after;
-            if (options.alignDelimiters !== false) {
-                size2 = before.length + size2 + after.length;
-                if (size2 > longestCellByColumn[columnIndex]) {
-                    longestCellByColumn[columnIndex] = size2;
-                }
-                sizes[columnIndex] = size2;
-            }
-            row[columnIndex] = cell;
-        }
-        cellMatrix.splice(1, 0, row);
-        sizeMatrix.splice(1, 0, sizes);
-        rowIndex = -1;
-        const lines = [];
-        while (++rowIndex < cellMatrix.length) {
-            const row2 = cellMatrix[rowIndex];
-            const sizes2 = sizeMatrix[rowIndex];
-            columnIndex = -1;
-            const line = [];
-            while (++columnIndex < mostCellsPerRow) {
-                const cell = row2[columnIndex] || "";
-                let before = "";
-                let after = "";
-                if (options.alignDelimiters !== false) {
-                    const size2 = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
-                    const code2 = alignments[columnIndex];
-                    if (code2 === 114) {
-                        before = " ".repeat(size2);
-                    } else if (code2 === 99) {
-                        if (size2 % 2) {
-                            before = " ".repeat(size2 / 2 + 0.5);
-                            after = " ".repeat(size2 / 2 - 0.5);
-                        } else {
-                            before = " ".repeat(size2 / 2);
-                            after = before;
-                        }
-                    } else {
-                        after = " ".repeat(size2);
-                    }
-                }
-                if (options.delimiterStart !== false && !columnIndex) {
-                    line.push("|");
-                }
-                if (options.padding !== false && !(options.alignDelimiters === false && cell === "") && (options.delimiterStart !== false || columnIndex)) {
-                    line.push(" ");
-                }
-                if (options.alignDelimiters !== false) {
-                    line.push(before);
-                }
-                line.push(cell);
-                if (options.alignDelimiters !== false) {
-                    line.push(after);
-                }
-                if (options.padding !== false) {
-                    line.push(" ");
-                }
-                if (options.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
-                    line.push("|");
-                }
-            }
-            lines.push(
-                options.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join("")
-            );
-        }
-        return lines.join("\n");
-    }
-
-    function serialize(value) {
-        return value === null || value === void 0 ? "" : String(value);
-    }
-
-    function defaultStringLength(value) {
-        return value.length;
-    }
-
-    function toAlignment(value) {
-        const code2 = typeof value === "string" ? value.codePointAt(0) : 0;
-        return code2 === 67 || code2 === 99 ? 99 : code2 === 76 || code2 === 108 ? 108 : code2 === 82 || code2 === 114 ? 114 : 0;
-    }
-
-    function blockquote(node2, _2, state, info) {
-        const exit2 = state.enter("blockquote");
-        const tracker = state.createTracker(info);
-        tracker.move("> ");
-        tracker.shift(2);
-        const value = state.indentLines(
-            state.containerFlow(node2, tracker.current()),
-            map$3
-        );
-        exit2();
-        return value;
-    }
-
-    function map$3(line, _2, blank) {
-        return ">" + (blank ? "" : " ") + line;
-    }
-
-    function patternInScope(stack, pattern) {
-        return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
-    }
-
-    function listInScope(stack, list2, none2) {
-        if (typeof list2 === "string") {
-            list2 = [list2];
-        }
-        if (!list2 || list2.length === 0) {
-            return none2;
-        }
-        let index2 = -1;
-        while (++index2 < list2.length) {
-            if (stack.includes(list2[index2])) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    function hardBreak(_2, _1, state, info) {
-        let index2 = -1;
-        while (++index2 < state.unsafe.length) {
-            if (state.unsafe[index2].character === "\n" && patternInScope(state.stack, state.unsafe[index2])) {
-                return /[ \t]/.test(info.before) ? "" : " ";
-            }
-        }
-        return "\\\n";
-    }
-
-    function longestStreak(value, substring) {
-        const source = String(value);
-        let index2 = source.indexOf(substring);
-        let expected = index2;
-        let count2 = 0;
-        let max2 = 0;
-        if (typeof substring !== "string") {
-            throw new TypeError("Expected substring");
-        }
-        while (index2 !== -1) {
-            if (index2 === expected) {
-                if (++count2 > max2) {
-                    max2 = count2;
-                }
-            } else {
-                count2 = 1;
-            }
-            expected = index2 + substring.length;
-            index2 = source.indexOf(substring, expected);
-        }
-        return max2;
-    }
-
-    function formatCodeAsIndented(node2, state) {
-        return Boolean(
-            state.options.fences === false && node2.value && !node2.lang && /[^ \r\n]/.test(node2.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
-        );
-    }
-
-    function checkFence(state) {
-        const marker = state.options.fence || "`";
-        if (marker !== "`" && marker !== "~") {
-            throw new Error(
-                "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
-            );
-        }
-        return marker;
-    }
-
-    function code$2(node2, _2, state, info) {
-        const marker = checkFence(state);
-        const raw2 = node2.value || "";
-        const suffix = marker === "`" ? "GraveAccent" : "Tilde";
-        if (formatCodeAsIndented(node2, state)) {
-            const exit3 = state.enter("codeIndented");
-            const value2 = state.indentLines(raw2, map$2);
-            exit3();
-            return value2;
-        }
-        const tracker = state.createTracker(info);
-        const sequence = marker.repeat(Math.max(longestStreak(raw2, marker) + 1, 3));
-        const exit2 = state.enter("codeFenced");
-        let value = tracker.move(sequence);
-        if (node2.lang) {
-            const subexit = state.enter(`codeFencedLang${suffix}`);
-            value += tracker.move(
-                state.safe(node2.lang, {
-                    before: value,
-                    after: " ",
-                    encode: ["`"],
-                    ...tracker.current()
-                })
-            );
-            subexit();
-        }
-        if (node2.lang && node2.meta) {
-            const subexit = state.enter(`codeFencedMeta${suffix}`);
-            value += tracker.move(" ");
-            value += tracker.move(
-                state.safe(node2.meta, {
-                    before: value,
-                    after: "\n",
-                    encode: ["`"],
-                    ...tracker.current()
-                })
-            );
-            subexit();
-        }
-        value += tracker.move("\n");
-        if (raw2) {
-            value += tracker.move(raw2 + "\n");
-        }
-        value += tracker.move(sequence);
-        exit2();
-        return value;
-    }
-
-    function map$2(line, _2, blank) {
-        return (blank ? "" : "    ") + line;
-    }
-
-    function checkQuote(state) {
-        const marker = state.options.quote || '"';
-        if (marker !== '"' && marker !== "'") {
-            throw new Error(
-                "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
-            );
-        }
-        return marker;
-    }
-
-    function definition(node2, _2, state, info) {
-        const quote2 = checkQuote(state);
-        const suffix = quote2 === '"' ? "Quote" : "Apostrophe";
-        const exit2 = state.enter("definition");
-        let subexit = state.enter("label");
-        const tracker = state.createTracker(info);
-        let value = tracker.move("[");
-        value += tracker.move(
-            state.safe(state.associationId(node2), {
-                before: value,
-                after: "]",
-                ...tracker.current()
-            })
-        );
-        value += tracker.move("]: ");
-        subexit();
-        if (!node2.url || /[\0- \u007F]/.test(node2.url)) {
-            subexit = state.enter("destinationLiteral");
-            value += tracker.move("<");
-            value += tracker.move(
-                state.safe(node2.url, {
-                    before: value,
-                    after: ">",
-                    ...tracker.current()
-                })
-            );
-            value += tracker.move(">");
-        } else {
-            subexit = state.enter("destinationRaw");
-            value += tracker.move(
-                state.safe(node2.url, {
-                    before: value,
-                    after: node2.title ? " " : "\n",
-                    ...tracker.current()
-                })
-            );
-        }
-        subexit();
-        if (node2.title) {
-            subexit = state.enter(`title${suffix}`);
-            value += tracker.move(" " + quote2);
-            value += tracker.move(
-                state.safe(node2.title, {
-                    before: value,
-                    after: quote2,
-                    ...tracker.current()
-                })
-            );
-            value += tracker.move(quote2);
-            subexit();
-        }
-        exit2();
-        return value;
-    }
-
-    function checkEmphasis(state) {
-        const marker = state.options.emphasis || "*";
-        if (marker !== "*" && marker !== "_") {
-            throw new Error(
-                "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
-            );
-        }
-        return marker;
-    }
-    emphasis.peek = emphasisPeek;
-
-    function emphasis(node2, _2, state, info) {
-        const marker = checkEmphasis(state);
-        const exit2 = state.enter("emphasis");
-        const tracker = state.createTracker(info);
-        let value = tracker.move(marker);
-        value += tracker.move(
-            state.containerPhrasing(node2, {
-                before: value,
-                after: marker,
-                ...tracker.current()
-            })
-        );
-        value += tracker.move(marker);
-        exit2();
-        return value;
-    }
-
-    function emphasisPeek(_2, _1, state) {
-        return state.options.emphasis || "*";
-    }
-
-    function formatHeadingAsSetext(node2, state) {
-        let literalWithBreak = false;
-        visit$1(node2, function(node3) {
-            if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
-                literalWithBreak = true;
-                return EXIT$1;
-            }
-        });
-        return Boolean(
-            (!node2.depth || node2.depth < 3) && toString$4(node2) && (state.options.setext || literalWithBreak)
-        );
-    }
-
-    function heading$1(node2, _2, state, info) {
-        const rank = Math.max(Math.min(6, node2.depth || 1), 1);
-        const tracker = state.createTracker(info);
-        if (formatHeadingAsSetext(node2, state)) {
-            const exit3 = state.enter("headingSetext");
-            const subexit2 = state.enter("phrasing");
-            const value2 = state.containerPhrasing(node2, {
-                ...tracker.current(),
-                before: "\n",
-                after: "\n"
-            });
-            subexit2();
-            exit3();
-            return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
-                value2.length - (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
-            );
-        }
-        const sequence = "#".repeat(rank);
-        const exit2 = state.enter("headingAtx");
-        const subexit = state.enter("phrasing");
-        tracker.move(sequence + " ");
-        let value = state.containerPhrasing(node2, {
-            before: "# ",
-            after: "\n",
-            ...tracker.current()
-        });
-        if (/^[\t ]/.test(value)) {
-            value = "&#x" + value.charCodeAt(0).toString(16).toUpperCase() + ";" + value.slice(1);
-        }
-        value = value ? sequence + " " + value : sequence;
-        if (state.options.closeAtx) {
-            value += " " + sequence;
-        }
-        subexit();
-        exit2();
-        return value;
-    }
-    html.peek = htmlPeek;
-
-    function html(node2) {
-        return node2.value || "";
-    }
-
-    function htmlPeek() {
-        return "<";
-    }
-    image.peek = imagePeek;
-
-    function image(node2, _2, state, info) {
-        const quote2 = checkQuote(state);
-        const suffix = quote2 === '"' ? "Quote" : "Apostrophe";
-        const exit2 = state.enter("image");
-        let subexit = state.enter("label");
-        const tracker = state.createTracker(info);
-        let value = tracker.move("![");
-        value += tracker.move(
-            state.safe(node2.alt, {
-                before: value,
-                after: "]",
-                ...tracker.current()
-            })
-        );
-        value += tracker.move("](");
-        subexit();
-        if (!node2.url && node2.title || /[\0- \u007F]/.test(node2.url)) {
-            subexit = state.enter("destinationLiteral");
-            value += tracker.move("<");
-            value += tracker.move(
-                state.safe(node2.url, {
-                    before: value,
-                    after: ">",
-                    ...tracker.current()
-                })
-            );
-            value += tracker.move(">");
-        } else {
-            subexit = state.enter("destinationRaw");
-            value += tracker.move(
-                state.safe(node2.url, {
-                    before: value,
-                    after: node2.title ? " " : ")",
-                    ...tracker.current()
-                })
-            );
-        }
-        subexit();
-        if (node2.title) {
-            subexit = state.enter(`title${suffix}`);
-            value += tracker.move(" " + quote2);
-            value += tracker.move(
-                state.safe(node2.title, {
-                    before: value,
-                    after: quote2,
-                    ...tracker.current()
-                })
-            );
-            value += tracker.move(quote2);
-            subexit();
-        }
-        value += tracker.move(")");
-        exit2();
-        return value;
-    }
-
-    function imagePeek() {
-        return "!";
-    }
-    imageReference.peek = imageReferencePeek;
-
-    function imageReference(node2, _2, state, info) {
-        const type2 = node2.referenceType;
-        const exit2 = state.enter("imageReference");
-        let subexit = state.enter("label");
-        const tracker = state.createTracker(info);
-        let value = tracker.move("![");
-        const alt = state.safe(node2.alt, {
-            before: value,
-            after: "]",
-            ...tracker.current()
-        });
-        value += tracker.move(alt + "][");
-        subexit();
-        const stack = state.stack;
-        state.stack = [];
-        subexit = state.enter("reference");
-        const reference2 = state.safe(state.associationId(node2), {
-            before: value,
-            after: "]",
-            ...tracker.current()
-        });
-        subexit();
-        state.stack = stack;
-        exit2();
-        if (type2 === "full" || !alt || alt !== reference2) {
-            value += tracker.move(reference2 + "]");
-        } else if (type2 === "shortcut") {
-            value = value.slice(0, -1);
-        } else {
-            value += tracker.move("]");
-        }
-        return value;
-    }
-
-    function imageReferencePeek() {
-        return "!";
-    }
-    inlineCode.peek = inlineCodePeek;
-
-    function inlineCode(node2, _2, state) {
-        let value = node2.value || "";
-        let sequence = "`";
-        let index2 = -1;
-        while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
-            sequence += "`";
-        }
-        if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
-            value = " " + value + " ";
-        }
-        while (++index2 < state.unsafe.length) {
-            const pattern = state.unsafe[index2];
-            const expression = state.compilePattern(pattern);
-            let match2;
-            if (!pattern.atBreak)
-                continue;
-            while (match2 = expression.exec(value)) {
-                let position2 = match2.index;
-                if (value.charCodeAt(position2) === 10 && value.charCodeAt(position2 - 1) === 13) {
-                    position2--;
-                }
-                value = value.slice(0, position2) + " " + value.slice(match2.index + 1);
-            }
-        }
-        return sequence + value + sequence;
-    }
-
-    function inlineCodePeek() {
-        return "`";
-    }
-
-    function formatLinkAsAutolink(node2, state) {
-        const raw2 = toString$4(node2);
-        return Boolean(
-            !state.options.resourceLink && node2.url && !node2.title && node2.children && node2.children.length === 1 && node2.children[0].type === "text" && (raw2 === node2.url || "mailto:" + raw2 === node2.url) && /^[a-z][a-z+.-]+:/i.test(node2.url) && !/[\0- <>\u007F]/.test(node2.url)
-        );
-    }
-    link$1.peek = linkPeek;
-
-    function link$1(node2, _2, state, info) {
-        const quote2 = checkQuote(state);
-        const suffix = quote2 === '"' ? "Quote" : "Apostrophe";
-        const tracker = state.createTracker(info);
-        let exit2;
-        let subexit;
-        if (formatLinkAsAutolink(node2, state)) {
-            const stack = state.stack;
-            state.stack = [];
-            exit2 = state.enter("autolink");
-            let value2 = tracker.move("<");
-            value2 += tracker.move(
-                state.containerPhrasing(node2, {
-                    before: value2,
-                    after: ">",
-                    ...tracker.current()
-                })
-            );
-            value2 += tracker.move(">");
-            exit2();
-            state.stack = stack;
-            return value2;
-        }
-        exit2 = state.enter("link");
-        subexit = state.enter("label");
-        let value = tracker.move("[");
-        value += tracker.move(
-            state.containerPhrasing(node2, {
-                before: value,
-                after: "](",
-                ...tracker.current()
-            })
-        );
-        value += tracker.move("](");
-        subexit();
-        if (!node2.url && node2.title || /[\0- \u007F]/.test(node2.url)) {
-            subexit = state.enter("destinationLiteral");
-            value += tracker.move("<");
-            value += tracker.move(
-                state.safe(node2.url, {
-                    before: value,
-                    after: ">",
-                    ...tracker.current()
-                })
-            );
-            value += tracker.move(">");
-        } else {
-            subexit = state.enter("destinationRaw");
-            value += tracker.move(
-                state.safe(node2.url, {
-                    before: value,
-                    after: node2.title ? " " : ")",
-                    ...tracker.current()
-                })
-            );
-        }
-        subexit();
-        if (node2.title) {
-            subexit = state.enter(`title${suffix}`);
-            value += tracker.move(" " + quote2);
-            value += tracker.move(
-                state.safe(node2.title, {
-                    before: value,
-                    after: quote2,
-                    ...tracker.current()
-                })
-            );
-            value += tracker.move(quote2);
-            subexit();
-        }
-        value += tracker.move(")");
-        exit2();
-        return value;
-    }
-
-    function linkPeek(node2, _2, state) {
-        return formatLinkAsAutolink(node2, state) ? "<" : "[";
-    }
-    linkReference.peek = linkReferencePeek;
-
-    function linkReference(node2, _2, state, info) {
-        const type2 = node2.referenceType;
-        const exit2 = state.enter("linkReference");
-        let subexit = state.enter("label");
-        const tracker = state.createTracker(info);
-        let value = tracker.move("[");
-        const text2 = state.containerPhrasing(node2, {
-            before: value,
-            after: "]",
-            ...tracker.current()
-        });
-        value += tracker.move(text2 + "][");
-        subexit();
-        const stack = state.stack;
-        state.stack = [];
-        subexit = state.enter("reference");
-        const reference2 = state.safe(state.associationId(node2), {
-            before: value,
-            after: "]",
-            ...tracker.current()
-        });
-        subexit();
-        state.stack = stack;
-        exit2();
-        if (type2 === "full" || !text2 || text2 !== reference2) {
-            value += tracker.move(reference2 + "]");
-        } else if (type2 === "shortcut") {
-            value = value.slice(0, -1);
-        } else {
-            value += tracker.move("]");
-        }
-        return value;
-    }
-
-    function linkReferencePeek() {
-        return "[";
-    }
-
-    function checkBullet(state) {
-        const marker = state.options.bullet || "*";
-        if (marker !== "*" && marker !== "+" && marker !== "-") {
-            throw new Error(
-                "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
-            );
-        }
-        return marker;
-    }
-
-    function checkBulletOther(state) {
-        const bullet = checkBullet(state);
-        const bulletOther = state.options.bulletOther;
-        if (!bulletOther) {
-            return bullet === "*" ? "-" : "*";
-        }
-        if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
-            throw new Error(
-                "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
-            );
-        }
-        if (bulletOther === bullet) {
-            throw new Error(
-                "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
-            );
-        }
-        return bulletOther;
-    }
-
-    function checkBulletOrdered(state) {
-        const marker = state.options.bulletOrdered || ".";
-        if (marker !== "." && marker !== ")") {
-            throw new Error(
-                "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
-            );
-        }
-        return marker;
-    }
-
-    function checkRule(state) {
-        const marker = state.options.rule || "*";
-        if (marker !== "*" && marker !== "-" && marker !== "_") {
-            throw new Error(
-                "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
-            );
-        }
-        return marker;
-    }
-
-    function list(node2, parent, state, info) {
-        const exit2 = state.enter("list");
-        const bulletCurrent = state.bulletCurrent;
-        let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
-        const bulletOther = node2.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
-        let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
-        if (!node2.ordered) {
-            const firstListItem = node2.children ? node2.children[0] : void 0;
-            if ((bullet === "*" || bullet === "-") && firstListItem && (!firstListItem.children || !firstListItem.children[0]) && state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0) {
-                useDifferentMarker = true;
-            }
-            if (checkRule(state) === bullet && firstListItem) {
-                let index2 = -1;
-                while (++index2 < node2.children.length) {
-                    const item = node2.children[index2];
-                    if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
-                        useDifferentMarker = true;
-                        break;
-                    }
-                }
-            }
-        }
-        if (useDifferentMarker) {
-            bullet = bulletOther;
-        }
-        state.bulletCurrent = bullet;
-        const value = state.containerFlow(node2, info);
-        state.bulletLastUsed = bullet;
-        state.bulletCurrent = bulletCurrent;
-        exit2();
-        return value;
-    }
-
-    function checkListItemIndent(state) {
-        const style2 = state.options.listItemIndent || "one";
-        if (style2 !== "tab" && style2 !== "one" && style2 !== "mixed") {
-            throw new Error(
-                "Cannot serialize items with `" + style2 + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
-            );
-        }
-        return style2;
-    }
-
-    function listItem(node2, parent, state, info) {
-        const listItemIndent = checkListItemIndent(state);
-        let bullet = state.bulletCurrent || checkBullet(state);
-        if (parent && parent.type === "list" && parent.ordered) {
-            bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
-        }
-        let size2 = bullet.length + 1;
-        if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
-            size2 = Math.ceil(size2 / 4) * 4;
-        }
-        const tracker = state.createTracker(info);
-        tracker.move(bullet + " ".repeat(size2 - bullet.length));
-        tracker.shift(size2);
-        const exit2 = state.enter("listItem");
-        const value = state.indentLines(
-            state.containerFlow(node2, tracker.current()),
-            map2
-        );
-        exit2();
-        return value;
-
-        function map2(line, index2, blank) {
-            if (index2) {
-                return (blank ? "" : " ".repeat(size2)) + line;
-            }
-            return (blank ? bullet : bullet + " ".repeat(size2 - bullet.length)) + line;
-        }
-    }
-
-    function paragraph(node2, _2, state, info) {
-        const exit2 = state.enter("paragraph");
-        const subexit = state.enter("phrasing");
-        const value = state.containerPhrasing(node2, info);
-        subexit();
-        exit2();
-        return value;
-    }
-    const phrasing = convert$1([
-        "break",
-        "delete",
-        "emphasis",
-        "footnote",
-        "footnoteReference",
-        "image",
-        "imageReference",
-        "inlineCode",
-        "inlineMath",
-        "link",
-        "linkReference",
-        "mdxJsxTextElement",
-        "mdxTextExpression",
-        "strong",
-        "text",
-        "textDirective"
-    ]);
-
-    function root$1(node2, _2, state, info) {
-        const hasPhrasing = node2.children.some(function(d2) {
-            return phrasing(d2);
-        });
-        const fn2 = hasPhrasing ? state.containerPhrasing : state.containerFlow;
-        return fn2.call(state, node2, info);
-    }
-
-    function checkStrong(state) {
-        const marker = state.options.strong || "*";
-        if (marker !== "*" && marker !== "_") {
-            throw new Error(
-                "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
-            );
-        }
-        return marker;
-    }
-    strong.peek = strongPeek;
-
-    function strong(node2, _2, state, info) {
-        const marker = checkStrong(state);
-        const exit2 = state.enter("strong");
-        const tracker = state.createTracker(info);
-        let value = tracker.move(marker + marker);
-        value += tracker.move(
-            state.containerPhrasing(node2, {
-                before: value,
-                after: marker,
-                ...tracker.current()
-            })
-        );
-        value += tracker.move(marker + marker);
-        exit2();
-        return value;
-    }
-
-    function strongPeek(_2, _1, state) {
-        return state.options.strong || "*";
-    }
-
-    function text$1(node2, _2, state, info) {
-        return state.safe(node2.value, info);
-    }
-
-    function checkRuleRepetition(state) {
-        const repetition = state.options.ruleRepetition || 3;
-        if (repetition < 3) {
-            throw new Error(
-                "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
-            );
-        }
-        return repetition;
-    }
-
-    function thematicBreak(_2, _1, state) {
-        const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
-        return state.options.ruleSpaces ? value.slice(0, -1) : value;
-    }
-    const handle = {
-        blockquote,
-        break: hardBreak,
-        code: code$2,
-        definition,
-        emphasis,
-        hardBreak,
-        heading: heading$1,
-        html,
-        image,
-        imageReference,
-        inlineCode,
-        link: link$1,
-        linkReference,
-        list,
-        listItem,
-        paragraph,
-        root: root$1,
-        strong,
-        text: text$1,
-        thematicBreak
-    };
-
-    function gfmTableFromMarkdown() {
-        return {
-            enter: {
-                table: enterTable,
-                tableData: enterCell,
-                tableHeader: enterCell,
-                tableRow: enterRow
-            },
-            exit: {
-                codeText: exitCodeText,
-                table: exitTable,
-                tableData: exit,
-                tableHeader: exit,
-                tableRow: exit
-            }
-        };
-    }
-
-    function enterTable(token) {
-        const align = token._align;
-        this.enter({
-                type: "table",
-                align: align.map(function(d2) {
-                    return d2 === "none" ? null : d2;
-                }),
-                children: []
-            },
-            token
-        );
-        this.data.inTable = true;
-    }
-
-    function exitTable(token) {
-        this.exit(token);
-        this.data.inTable = void 0;
-    }
-
-    function enterRow(token) {
-        this.enter({
-            type: "tableRow",
-            children: []
-        }, token);
-    }
-
-    function exit(token) {
-        this.exit(token);
-    }
-
-    function enterCell(token) {
-        this.enter({
-            type: "tableCell",
-            children: []
-        }, token);
-    }
-
-    function exitCodeText(token) {
-        let value = this.resume();
-        if (this.data.inTable) {
-            value = value.replace(/\\([\\|])/g, replace$1);
-        }
-        const node2 = this.stack[this.stack.length - 1];
-        ok$2(node2.type === "inlineCode");
-        node2.value = value;
-        this.exit(token);
-    }
-
-    function replace$1($0, $1) {
-        return $1 === "|" ? $1 : $0;
-    }
-
-    function gfmTableToMarkdown(options) {
-        const settings2 = options || {};
-        const padding = settings2.tableCellPadding;
-        const alignDelimiters = settings2.tablePipeAlign;
-        const stringLength = settings2.stringLength;
-        const around = padding ? " " : "|";
-        return {
-            unsafe: [{
-                character: "\r",
-                inConstruct: "tableCell"
-            }, {
-                character: "\n",
-                inConstruct: "tableCell"
-            }, {
-                atBreak: true,
-                character: "|",
-                after: "[	 :-]"
-            }, {
-                character: "|",
-                inConstruct: "tableCell"
-            }, {
-                atBreak: true,
-                character: ":",
-                after: "-"
-            }, {
-                atBreak: true,
-                character: "-",
-                after: "[:|-]"
-            }],
-            handlers: {
-                inlineCode: inlineCodeWithTable,
-                table: handleTable,
-                tableCell: handleTableCell,
-                tableRow: handleTableRow
-            }
-        };
-
-        function handleTable(node2, _2, state, info) {
-            return serializeData(handleTableAsData(node2, state, info), node2.align);
-        }
-
-        function handleTableRow(node2, _2, state, info) {
-            const row = handleTableRowAsData(node2, state, info);
-            const value = serializeData([row]);
-            return value.slice(0, value.indexOf("\n"));
-        }
-
-        function handleTableCell(node2, _2, state, info) {
-            const exit2 = state.enter("tableCell");
-            const subexit = state.enter("phrasing");
-            const value = state.containerPhrasing(node2, {
-                ...info,
-                before: around,
-                after: around
-            });
-            subexit();
-            exit2();
-            return value;
-        }
-
-        function serializeData(matrix, align) {
-            return markdownTable(matrix, {
-                align,
-                alignDelimiters,
-                padding,
-                stringLength
-            });
-        }
-
-        function handleTableAsData(node2, state, info) {
-            const children2 = node2.children;
-            let index2 = -1;
-            const result = [];
-            const subexit = state.enter("table");
-            while (++index2 < children2.length) {
-                result[index2] = handleTableRowAsData(children2[index2], state, info);
-            }
-            subexit();
-            return result;
-        }
-
-        function handleTableRowAsData(node2, state, info) {
-            const children2 = node2.children;
-            let index2 = -1;
-            const result = [];
-            const subexit = state.enter("tableRow");
-            while (++index2 < children2.length) {
-                result[index2] = handleTableCell(children2[index2], node2, state, info);
-            }
-            subexit();
-            return result;
-        }
-
-        function inlineCodeWithTable(node2, parent, state) {
-            let value = handle.inlineCode(node2, parent, state);
-            if (state.stack.includes("tableCell")) {
-                value = value.replace(/\|/g, "\\$&");
-            }
-            return value;
+                } else if (tn === $$2.TEMPLATE) {
+                    endTagInHead(p2, token);
+                } else {
+                    genericEndTagInBody(p2, token);
+                }
+                break;
+            case 10:
+                if (tn === $$2.BLOCKQUOTE || tn === $$2.FIGCAPTION) {
+                    addressEndTagInBody(p2, token);
+                } else {
+                    genericEndTagInBody(p2, token);
+                }
+                break;
+            default:
+                genericEndTagInBody(p2, token);
         }
     }
 
-    function gfmTaskListItemFromMarkdown() {
-        return {
-            exit: {
-                taskListCheckValueChecked: exitCheck,
-                taskListCheckValueUnchecked: exitCheck,
-                paragraph: exitParagraphWithTaskListItem
-            }
-        };
+    function eofInBody(p2, token) {
+        if (p2.tmplInsertionModeStackTop > -1) {
+            eofInTemplate(p2, token);
+        } else {
+            p2.stopped = true;
+        }
     }
 
-    function gfmTaskListItemToMarkdown() {
-        return {
-            unsafe: [{
-                atBreak: true,
-                character: "-",
-                after: "[:|-]"
-            }],
-            handlers: {
-                listItem: listItemWithTaskListItem
-            }
-        };
+    function endTagInText(p2, token) {
+        if (token.tagName === $$2.SCRIPT) {
+            p2.pendingScript = p2.openElements.current;
+        }
+        p2.openElements.pop();
+        p2.insertionMode = p2.originalInsertionMode;
     }
 
-    function exitCheck(token) {
-        const node2 = this.stack[this.stack.length - 2];
-        ok$2(node2.type === "listItem");
-        node2.checked = token.type === "taskListCheckValueChecked";
+    function eofInText(p2, token) {
+        p2._err(ERR.eofInElementThatCanContainOnlyText);
+        p2.openElements.pop();
+        p2.insertionMode = p2.originalInsertionMode;
+        p2._processToken(token);
     }
 
-    function exitParagraphWithTaskListItem(token) {
-        const parent = this.stack[this.stack.length - 2];
-        if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
-            const node2 = this.stack[this.stack.length - 1];
-            ok$2(node2.type === "paragraph");
-            const head = node2.children[0];
-            if (head && head.type === "text") {
-                const siblings = parent.children;
-                let index2 = -1;
-                let firstParaghraph;
-                while (++index2 < siblings.length) {
-                    const sibling = siblings[index2];
-                    if (sibling.type === "paragraph") {
-                        firstParaghraph = sibling;
-                        break;
-                    }
-                }
-                if (firstParaghraph === node2) {
-                    head.value = head.value.slice(1);
-                    if (head.value.length === 0) {
-                        node2.children.shift();
-                    } else if (node2.position && head.position && typeof head.position.start.offset === "number") {
-                        head.position.start.column++;
-                        head.position.start.offset++;
-                        node2.position.start = Object.assign({}, head.position.start);
-                    }
-                }
-            }
+    function characterInTable(p2, token) {
+        const curTn = p2.openElements.currentTagName;
+        if (curTn === $$2.TABLE || curTn === $$2.TBODY || curTn === $$2.TFOOT || curTn === $$2.THEAD || curTn === $$2.TR) {
+            p2.pendingCharacterTokens = [];
+            p2.hasNonWhitespacePendingCharacterToken = false;
+            p2.originalInsertionMode = p2.insertionMode;
+            p2.insertionMode = IN_TABLE_TEXT_MODE;
+            p2._processToken(token);
+        } else {
+            tokenInTable(p2, token);
         }
-        this.exit(token);
     }
 
-    function listItemWithTaskListItem(node2, parent, state, info) {
-        const head = node2.children[0];
-        const checkable = typeof node2.checked === "boolean" && head && head.type === "paragraph";
-        const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
-        const tracker = state.createTracker(info);
-        if (checkable) {
-            tracker.move(checkbox);
-        }
-        let value = handle.listItem(node2, parent, state, {
-            ...info,
-            ...tracker.current()
-        });
-        if (checkable) {
-            value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
-        }
-        return value;
-
-        function check($0) {
-            return $0 + checkbox;
-        }
+    function captionStartTagInTable(p2, token) {
+        p2.openElements.clearBackToTableContext();
+        p2.activeFormattingElements.insertMarker();
+        p2._insertElement(token, NS.HTML);
+        p2.insertionMode = IN_CAPTION_MODE;
     }
 
-    function gfmFromMarkdown() {
-        return [
-            gfmAutolinkLiteralFromMarkdown(),
-            gfmFootnoteFromMarkdown(),
-            gfmStrikethroughFromMarkdown(),
-            gfmTableFromMarkdown(),
-            gfmTaskListItemFromMarkdown()
-        ];
+    function colgroupStartTagInTable(p2, token) {
+        p2.openElements.clearBackToTableContext();
+        p2._insertElement(token, NS.HTML);
+        p2.insertionMode = IN_COLUMN_GROUP_MODE;
     }
 
-    function gfmToMarkdown(options) {
-        return {
-            extensions: [
-                gfmAutolinkLiteralToMarkdown(),
-                gfmFootnoteToMarkdown(),
-                gfmStrikethroughToMarkdown(),
-                gfmTableToMarkdown(options),
-                gfmTaskListItemToMarkdown()
-            ]
-        };
+    function colStartTagInTable(p2, token) {
+        p2.openElements.clearBackToTableContext();
+        p2._insertFakeElement($$2.COLGROUP);
+        p2.insertionMode = IN_COLUMN_GROUP_MODE;
+        p2._processToken(token);
     }
-    const wwwPrefix = {
-        tokenize: tokenizeWwwPrefix,
-        partial: true
-    };
-    const domain = {
-        tokenize: tokenizeDomain,
-        partial: true
-    };
-    const path$1 = {
-        tokenize: tokenizePath,
-        partial: true
-    };
-    const trail = {
-        tokenize: tokenizeTrail,
-        partial: true
-    };
-    const emailDomainDotTrail = {
-        tokenize: tokenizeEmailDomainDotTrail,
-        partial: true
-    };
-    const wwwAutolink = {
-        tokenize: tokenizeWwwAutolink,
-        previous: previousWww
-    };
-    const protocolAutolink = {
-        tokenize: tokenizeProtocolAutolink,
-        previous: previousProtocol
-    };
-    const emailAutolink = {
-        tokenize: tokenizeEmailAutolink,
-        previous: previousEmail
-    };
-    const text = {};
 
-    function gfmAutolinkLiteral() {
-        return {
-            text
-        };
-    }
-    let code$1 = 48;
-    while (code$1 < 123) {
-        text[code$1] = emailAutolink;
-        code$1++;
-        if (code$1 === 58)
-            code$1 = 65;
-        else if (code$1 === 91)
-            code$1 = 97;
+    function tbodyStartTagInTable(p2, token) {
+        p2.openElements.clearBackToTableContext();
+        p2._insertElement(token, NS.HTML);
+        p2.insertionMode = IN_TABLE_BODY_MODE;
     }
-    text[43] = emailAutolink;
-    text[45] = emailAutolink;
-    text[46] = emailAutolink;
-    text[95] = emailAutolink;
-    text[72] = [emailAutolink, protocolAutolink];
-    text[104] = [emailAutolink, protocolAutolink];
-    text[87] = [emailAutolink, wwwAutolink];
-    text[119] = [emailAutolink, wwwAutolink];
 
-    function tokenizeEmailAutolink(effects, ok2, nok) {
-        const self2 = this;
-        let dot2;
-        let data2;
-        return start2;
+    function tdStartTagInTable(p2, token) {
+        p2.openElements.clearBackToTableContext();
+        p2._insertFakeElement($$2.TBODY);
+        p2.insertionMode = IN_TABLE_BODY_MODE;
+        p2._processToken(token);
+    }
 
-        function start2(code2) {
-            if (!gfmAtext(code2) || !previousEmail.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
-                return nok(code2);
-            }
-            effects.enter("literalAutolink");
-            effects.enter("literalAutolinkEmail");
-            return atext(code2);
+    function tableStartTagInTable(p2, token) {
+        if (p2.openElements.hasInTableScope($$2.TABLE)) {
+            p2.openElements.popUntilTagNamePopped($$2.TABLE);
+            p2._resetInsertionMode();
+            p2._processToken(token);
         }
+    }
 
-        function atext(code2) {
-            if (gfmAtext(code2)) {
-                effects.consume(code2);
-                return atext;
-            }
-            if (code2 === 64) {
-                effects.consume(code2);
-                return emailDomain;
-            }
-            return nok(code2);
+    function inputStartTagInTable(p2, token) {
+        const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);
+        if (inputType && inputType.toLowerCase() === HIDDEN_INPUT_TYPE) {
+            p2._appendElement(token, NS.HTML);
+        } else {
+            tokenInTable(p2, token);
         }
+        token.ackSelfClosing = true;
+    }
 
-        function emailDomain(code2) {
-            if (code2 === 46) {
-                return effects.check(
-                    emailDomainDotTrail,
-                    emailDomainAfter,
-                    emailDomainDot
-                )(code2);
-            }
-            if (code2 === 45 || code2 === 95 || asciiAlphanumeric(code2)) {
-                data2 = true;
-                effects.consume(code2);
-                return emailDomain;
-            }
-            return emailDomainAfter(code2);
+    function formStartTagInTable(p2, token) {
+        if (!p2.formElement && p2.openElements.tmplCount === 0) {
+            p2._insertElement(token, NS.HTML);
+            p2.formElement = p2.openElements.current;
+            p2.openElements.pop();
         }
+    }
 
-        function emailDomainDot(code2) {
-            effects.consume(code2);
-            dot2 = true;
-            return emailDomain;
+    function startTagInTable(p2, token) {
+        const tn = token.tagName;
+        switch (tn.length) {
+            case 2:
+                if (tn === $$2.TD || tn === $$2.TH || tn === $$2.TR) {
+                    tdStartTagInTable(p2, token);
+                } else {
+                    tokenInTable(p2, token);
+                }
+                break;
+            case 3:
+                if (tn === $$2.COL) {
+                    colStartTagInTable(p2, token);
+                } else {
+                    tokenInTable(p2, token);
+                }
+                break;
+            case 4:
+                if (tn === $$2.FORM) {
+                    formStartTagInTable(p2, token);
+                } else {
+                    tokenInTable(p2, token);
+                }
+                break;
+            case 5:
+                if (tn === $$2.TABLE) {
+                    tableStartTagInTable(p2, token);
+                } else if (tn === $$2.STYLE) {
+                    startTagInHead(p2, token);
+                } else if (tn === $$2.TBODY || tn === $$2.TFOOT || tn === $$2.THEAD) {
+                    tbodyStartTagInTable(p2, token);
+                } else if (tn === $$2.INPUT) {
+                    inputStartTagInTable(p2, token);
+                } else {
+                    tokenInTable(p2, token);
+                }
+                break;
+            case 6:
+                if (tn === $$2.SCRIPT) {
+                    startTagInHead(p2, token);
+                } else {
+                    tokenInTable(p2, token);
+                }
+                break;
+            case 7:
+                if (tn === $$2.CAPTION) {
+                    captionStartTagInTable(p2, token);
+                } else {
+                    tokenInTable(p2, token);
+                }
+                break;
+            case 8:
+                if (tn === $$2.COLGROUP) {
+                    colgroupStartTagInTable(p2, token);
+                } else if (tn === $$2.TEMPLATE) {
+                    startTagInHead(p2, token);
+                } else {
+                    tokenInTable(p2, token);
+                }
+                break;
+            default:
+                tokenInTable(p2, token);
         }
+    }
 
-        function emailDomainAfter(code2) {
-            if (data2 && dot2 && asciiAlpha(self2.previous)) {
-                effects.exit("literalAutolinkEmail");
-                effects.exit("literalAutolink");
-                return ok2(code2);
+    function endTagInTable(p2, token) {
+        const tn = token.tagName;
+        if (tn === $$2.TABLE) {
+            if (p2.openElements.hasInTableScope($$2.TABLE)) {
+                p2.openElements.popUntilTagNamePopped($$2.TABLE);
+                p2._resetInsertionMode();
             }
-            return nok(code2);
+        } else if (tn === $$2.TEMPLATE) {
+            endTagInHead(p2, token);
+        } else if (tn !== $$2.BODY && tn !== $$2.CAPTION && tn !== $$2.COL && tn !== $$2.COLGROUP && tn !== $$2.HTML && tn !== $$2.TBODY && tn !== $$2.TD && tn !== $$2.TFOOT && tn !== $$2.TH && tn !== $$2.THEAD && tn !== $$2.TR) {
+            tokenInTable(p2, token);
         }
     }
 
-    function tokenizeWwwAutolink(effects, ok2, nok) {
-        const self2 = this;
-        return wwwStart;
-
-        function wwwStart(code2) {
-            if (code2 !== 87 && code2 !== 119 || !previousWww.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
-                return nok(code2);
-            }
-            effects.enter("literalAutolink");
-            effects.enter("literalAutolinkWww");
-            return effects.check(
-                wwwPrefix,
-                effects.attempt(domain, effects.attempt(path$1, wwwAfter), nok),
-                nok
-            )(code2);
-        }
+    function tokenInTable(p2, token) {
+        const savedFosterParentingState = p2.fosterParentingEnabled;
+        p2.fosterParentingEnabled = true;
+        p2._processTokenInBodyMode(token);
+        p2.fosterParentingEnabled = savedFosterParentingState;
+    }
 
-        function wwwAfter(code2) {
-            effects.exit("literalAutolinkWww");
-            effects.exit("literalAutolink");
-            return ok2(code2);
-        }
+    function whitespaceCharacterInTableText(p2, token) {
+        p2.pendingCharacterTokens.push(token);
     }
 
-    function tokenizeProtocolAutolink(effects, ok2, nok) {
-        const self2 = this;
-        let buffer = "";
-        let seen = false;
-        return protocolStart;
+    function characterInTableText(p2, token) {
+        p2.pendingCharacterTokens.push(token);
+        p2.hasNonWhitespacePendingCharacterToken = true;
+    }
 
-        function protocolStart(code2) {
-            if ((code2 === 72 || code2 === 104) && previousProtocol.call(self2, self2.previous) && !previousUnbalanced(self2.events)) {
-                effects.enter("literalAutolink");
-                effects.enter("literalAutolinkHttp");
-                buffer += String.fromCodePoint(code2);
-                effects.consume(code2);
-                return protocolPrefixInside;
+    function tokenInTableText(p2, token) {
+        let i2 = 0;
+        if (p2.hasNonWhitespacePendingCharacterToken) {
+            for (; i2 < p2.pendingCharacterTokens.length; i2++) {
+                tokenInTable(p2, p2.pendingCharacterTokens[i2]);
+            }
+        } else {
+            for (; i2 < p2.pendingCharacterTokens.length; i2++) {
+                p2._insertCharacters(p2.pendingCharacterTokens[i2]);
             }
-            return nok(code2);
         }
+        p2.insertionMode = p2.originalInsertionMode;
+        p2._processToken(token);
+    }
 
-        function protocolPrefixInside(code2) {
-            if (asciiAlpha(code2) && buffer.length < 5) {
-                buffer += String.fromCodePoint(code2);
-                effects.consume(code2);
-                return protocolPrefixInside;
-            }
-            if (code2 === 58) {
-                const protocol = buffer.toLowerCase();
-                if (protocol === "http" || protocol === "https") {
-                    effects.consume(code2);
-                    return protocolSlashesInside;
-                }
+    function startTagInCaption(p2, token) {
+        const tn = token.tagName;
+        if (tn === $$2.CAPTION || tn === $$2.COL || tn === $$2.COLGROUP || tn === $$2.TBODY || tn === $$2.TD || tn === $$2.TFOOT || tn === $$2.TH || tn === $$2.THEAD || tn === $$2.TR) {
+            if (p2.openElements.hasInTableScope($$2.CAPTION)) {
+                p2.openElements.generateImpliedEndTags();
+                p2.openElements.popUntilTagNamePopped($$2.CAPTION);
+                p2.activeFormattingElements.clearToLastMarker();
+                p2.insertionMode = IN_TABLE_MODE;
+                p2._processToken(token);
             }
-            return nok(code2);
+        } else {
+            startTagInBody(p2, token);
         }
+    }
 
-        function protocolSlashesInside(code2) {
-            if (code2 === 47) {
-                effects.consume(code2);
-                if (seen) {
-                    return afterProtocol;
+    function endTagInCaption(p2, token) {
+        const tn = token.tagName;
+        if (tn === $$2.CAPTION || tn === $$2.TABLE) {
+            if (p2.openElements.hasInTableScope($$2.CAPTION)) {
+                p2.openElements.generateImpliedEndTags();
+                p2.openElements.popUntilTagNamePopped($$2.CAPTION);
+                p2.activeFormattingElements.clearToLastMarker();
+                p2.insertionMode = IN_TABLE_MODE;
+                if (tn === $$2.TABLE) {
+                    p2._processToken(token);
                 }
-                seen = true;
-                return protocolSlashesInside;
             }
-            return nok(code2);
-        }
-
-        function afterProtocol(code2) {
-            return code2 === null || asciiControl(code2) || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || unicodePunctuation(code2) ? nok(code2) : effects.attempt(domain, effects.attempt(path$1, protocolAfter), nok)(code2);
+        } else if (tn !== $$2.BODY && tn !== $$2.COL && tn !== $$2.COLGROUP && tn !== $$2.HTML && tn !== $$2.TBODY && tn !== $$2.TD && tn !== $$2.TFOOT && tn !== $$2.TH && tn !== $$2.THEAD && tn !== $$2.TR) {
+            endTagInBody(p2, token);
         }
+    }
 
-        function protocolAfter(code2) {
-            effects.exit("literalAutolinkHttp");
-            effects.exit("literalAutolink");
-            return ok2(code2);
+    function startTagInColumnGroup(p2, token) {
+        const tn = token.tagName;
+        if (tn === $$2.HTML) {
+            startTagInBody(p2, token);
+        } else if (tn === $$2.COL) {
+            p2._appendElement(token, NS.HTML);
+            token.ackSelfClosing = true;
+        } else if (tn === $$2.TEMPLATE) {
+            startTagInHead(p2, token);
+        } else {
+            tokenInColumnGroup(p2, token);
         }
     }
 
-    function tokenizeWwwPrefix(effects, ok2, nok) {
-        let size2 = 0;
-        return wwwPrefixInside;
-
-        function wwwPrefixInside(code2) {
-            if ((code2 === 87 || code2 === 119) && size2 < 3) {
-                size2++;
-                effects.consume(code2);
-                return wwwPrefixInside;
-            }
-            if (code2 === 46 && size2 === 3) {
-                effects.consume(code2);
-                return wwwPrefixAfter;
+    function endTagInColumnGroup(p2, token) {
+        const tn = token.tagName;
+        if (tn === $$2.COLGROUP) {
+            if (p2.openElements.currentTagName === $$2.COLGROUP) {
+                p2.openElements.pop();
+                p2.insertionMode = IN_TABLE_MODE;
             }
-            return nok(code2);
+        } else if (tn === $$2.TEMPLATE) {
+            endTagInHead(p2, token);
+        } else if (tn !== $$2.COL) {
+            tokenInColumnGroup(p2, token);
         }
+    }
 
-        function wwwPrefixAfter(code2) {
-            return code2 === null ? nok(code2) : ok2(code2);
+    function tokenInColumnGroup(p2, token) {
+        if (p2.openElements.currentTagName === $$2.COLGROUP) {
+            p2.openElements.pop();
+            p2.insertionMode = IN_TABLE_MODE;
+            p2._processToken(token);
         }
     }
 
-    function tokenizeDomain(effects, ok2, nok) {
-        let underscoreInLastSegment;
-        let underscoreInLastLastSegment;
-        let seen;
-        return domainInside;
-
-        function domainInside(code2) {
-            if (code2 === 46 || code2 === 95) {
-                return effects.check(trail, domainAfter, domainAtPunctuation)(code2);
-            }
-            if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || code2 !== 45 && unicodePunctuation(code2)) {
-                return domainAfter(code2);
+    function startTagInTableBody(p2, token) {
+        const tn = token.tagName;
+        if (tn === $$2.TR) {
+            p2.openElements.clearBackToTableBodyContext();
+            p2._insertElement(token, NS.HTML);
+            p2.insertionMode = IN_ROW_MODE;
+        } else if (tn === $$2.TH || tn === $$2.TD) {
+            p2.openElements.clearBackToTableBodyContext();
+            p2._insertFakeElement($$2.TR);
+            p2.insertionMode = IN_ROW_MODE;
+            p2._processToken(token);
+        } else if (tn === $$2.CAPTION || tn === $$2.COL || tn === $$2.COLGROUP || tn === $$2.TBODY || tn === $$2.TFOOT || tn === $$2.THEAD) {
+            if (p2.openElements.hasTableBodyContextInTableScope()) {
+                p2.openElements.clearBackToTableBodyContext();
+                p2.openElements.pop();
+                p2.insertionMode = IN_TABLE_MODE;
+                p2._processToken(token);
             }
-            seen = true;
-            effects.consume(code2);
-            return domainInside;
+        } else {
+            startTagInTable(p2, token);
         }
+    }
 
-        function domainAtPunctuation(code2) {
-            if (code2 === 95) {
-                underscoreInLastSegment = true;
-            } else {
-                underscoreInLastLastSegment = underscoreInLastSegment;
-                underscoreInLastSegment = void 0;
+    function endTagInTableBody(p2, token) {
+        const tn = token.tagName;
+        if (tn === $$2.TBODY || tn === $$2.TFOOT || tn === $$2.THEAD) {
+            if (p2.openElements.hasInTableScope(tn)) {
+                p2.openElements.clearBackToTableBodyContext();
+                p2.openElements.pop();
+                p2.insertionMode = IN_TABLE_MODE;
             }
-            effects.consume(code2);
-            return domainInside;
+        } else if (tn === $$2.TABLE) {
+            if (p2.openElements.hasTableBodyContextInTableScope()) {
+                p2.openElements.clearBackToTableBodyContext();
+                p2.openElements.pop();
+                p2.insertionMode = IN_TABLE_MODE;
+                p2._processToken(token);
+            }
+        } else if (tn !== $$2.BODY && tn !== $$2.CAPTION && tn !== $$2.COL && tn !== $$2.COLGROUP || tn !== $$2.HTML && tn !== $$2.TD && tn !== $$2.TH && tn !== $$2.TR) {
+            endTagInTable(p2, token);
         }
+    }
 
-        function domainAfter(code2) {
-            if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
-                return nok(code2);
+    function startTagInRow(p2, token) {
+        const tn = token.tagName;
+        if (tn === $$2.TH || tn === $$2.TD) {
+            p2.openElements.clearBackToTableRowContext();
+            p2._insertElement(token, NS.HTML);
+            p2.insertionMode = IN_CELL_MODE;
+            p2.activeFormattingElements.insertMarker();
+        } else if (tn === $$2.CAPTION || tn === $$2.COL || tn === $$2.COLGROUP || tn === $$2.TBODY || tn === $$2.TFOOT || tn === $$2.THEAD || tn === $$2.TR) {
+            if (p2.openElements.hasInTableScope($$2.TR)) {
+                p2.openElements.clearBackToTableRowContext();
+                p2.openElements.pop();
+                p2.insertionMode = IN_TABLE_BODY_MODE;
+                p2._processToken(token);
             }
-            return ok2(code2);
+        } else {
+            startTagInTable(p2, token);
         }
     }
 
-    function tokenizePath(effects, ok2) {
-        let sizeOpen = 0;
-        let sizeClose = 0;
-        return pathInside;
-
-        function pathInside(code2) {
-            if (code2 === 40) {
-                sizeOpen++;
-                effects.consume(code2);
-                return pathInside;
-            }
-            if (code2 === 41 && sizeClose < sizeOpen) {
-                return pathAtPunctuation(code2);
+    function endTagInRow(p2, token) {
+        const tn = token.tagName;
+        if (tn === $$2.TR) {
+            if (p2.openElements.hasInTableScope($$2.TR)) {
+                p2.openElements.clearBackToTableRowContext();
+                p2.openElements.pop();
+                p2.insertionMode = IN_TABLE_BODY_MODE;
             }
-            if (code2 === 33 || code2 === 34 || code2 === 38 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 60 || code2 === 63 || code2 === 93 || code2 === 95 || code2 === 126) {
-                return effects.check(trail, ok2, pathAtPunctuation)(code2);
+        } else if (tn === $$2.TABLE) {
+            if (p2.openElements.hasInTableScope($$2.TR)) {
+                p2.openElements.clearBackToTableRowContext();
+                p2.openElements.pop();
+                p2.insertionMode = IN_TABLE_BODY_MODE;
+                p2._processToken(token);
             }
-            if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
-                return ok2(code2);
+        } else if (tn === $$2.TBODY || tn === $$2.TFOOT || tn === $$2.THEAD) {
+            if (p2.openElements.hasInTableScope(tn) || p2.openElements.hasInTableScope($$2.TR)) {
+                p2.openElements.clearBackToTableRowContext();
+                p2.openElements.pop();
+                p2.insertionMode = IN_TABLE_BODY_MODE;
+                p2._processToken(token);
             }
-            effects.consume(code2);
-            return pathInside;
+        } else if (tn !== $$2.BODY && tn !== $$2.CAPTION && tn !== $$2.COL && tn !== $$2.COLGROUP || tn !== $$2.HTML && tn !== $$2.TD && tn !== $$2.TH) {
+            endTagInTable(p2, token);
         }
+    }
 
-        function pathAtPunctuation(code2) {
-            if (code2 === 41) {
-                sizeClose++;
+    function startTagInCell(p2, token) {
+        const tn = token.tagName;
+        if (tn === $$2.CAPTION || tn === $$2.COL || tn === $$2.COLGROUP || tn === $$2.TBODY || tn === $$2.TD || tn === $$2.TFOOT || tn === $$2.TH || tn === $$2.THEAD || tn === $$2.TR) {
+            if (p2.openElements.hasInTableScope($$2.TD) || p2.openElements.hasInTableScope($$2.TH)) {
+                p2._closeTableCell();
+                p2._processToken(token);
             }
-            effects.consume(code2);
-            return pathInside;
+        } else {
+            startTagInBody(p2, token);
         }
     }
 
-    function tokenizeTrail(effects, ok2, nok) {
-        return trail2;
+    function endTagInCell(p2, token) {
+        const tn = token.tagName;
+        if (tn === $$2.TD || tn === $$2.TH) {
+            if (p2.openElements.hasInTableScope(tn)) {
+                p2.openElements.generateImpliedEndTags();
+                p2.openElements.popUntilTagNamePopped(tn);
+                p2.activeFormattingElements.clearToLastMarker();
+                p2.insertionMode = IN_ROW_MODE;
+            }
+        } else if (tn === $$2.TABLE || tn === $$2.TBODY || tn === $$2.TFOOT || tn === $$2.THEAD || tn === $$2.TR) {
+            if (p2.openElements.hasInTableScope(tn)) {
+                p2._closeTableCell();
+                p2._processToken(token);
+            }
+        } else if (tn !== $$2.BODY && tn !== $$2.CAPTION && tn !== $$2.COL && tn !== $$2.COLGROUP && tn !== $$2.HTML) {
+            endTagInBody(p2, token);
+        }
+    }
 
-        function trail2(code2) {
-            if (code2 === 33 || code2 === 34 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 63 || code2 === 95 || code2 === 126) {
-                effects.consume(code2);
-                return trail2;
+    function startTagInSelect(p2, token) {
+        const tn = token.tagName;
+        if (tn === $$2.HTML) {
+            startTagInBody(p2, token);
+        } else if (tn === $$2.OPTION) {
+            if (p2.openElements.currentTagName === $$2.OPTION) {
+                p2.openElements.pop();
             }
-            if (code2 === 38) {
-                effects.consume(code2);
-                return trailCharRefStart;
+            p2._insertElement(token, NS.HTML);
+        } else if (tn === $$2.OPTGROUP) {
+            if (p2.openElements.currentTagName === $$2.OPTION) {
+                p2.openElements.pop();
             }
-            if (code2 === 93) {
-                effects.consume(code2);
-                return trailBracketAfter;
+            if (p2.openElements.currentTagName === $$2.OPTGROUP) {
+                p2.openElements.pop();
             }
-            if (code2 === 60 || code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
-                return ok2(code2);
+            p2._insertElement(token, NS.HTML);
+        } else if (tn === $$2.INPUT || tn === $$2.KEYGEN || tn === $$2.TEXTAREA || tn === $$2.SELECT) {
+            if (p2.openElements.hasInSelectScope($$2.SELECT)) {
+                p2.openElements.popUntilTagNamePopped($$2.SELECT);
+                p2._resetInsertionMode();
+                if (tn !== $$2.SELECT) {
+                    p2._processToken(token);
+                }
             }
-            return nok(code2);
+        } else if (tn === $$2.SCRIPT || tn === $$2.TEMPLATE) {
+            startTagInHead(p2, token);
         }
+    }
 
-        function trailBracketAfter(code2) {
-            if (code2 === null || code2 === 40 || code2 === 91 || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
-                return ok2(code2);
+    function endTagInSelect(p2, token) {
+        const tn = token.tagName;
+        if (tn === $$2.OPTGROUP) {
+            const prevOpenElement = p2.openElements.items[p2.openElements.stackTop - 1];
+            const prevOpenElementTn = prevOpenElement && p2.treeAdapter.getTagName(prevOpenElement);
+            if (p2.openElements.currentTagName === $$2.OPTION && prevOpenElementTn === $$2.OPTGROUP) {
+                p2.openElements.pop();
             }
-            return trail2(code2);
+            if (p2.openElements.currentTagName === $$2.OPTGROUP) {
+                p2.openElements.pop();
+            }
+        } else if (tn === $$2.OPTION) {
+            if (p2.openElements.currentTagName === $$2.OPTION) {
+                p2.openElements.pop();
+            }
+        } else if (tn === $$2.SELECT && p2.openElements.hasInSelectScope($$2.SELECT)) {
+            p2.openElements.popUntilTagNamePopped($$2.SELECT);
+            p2._resetInsertionMode();
+        } else if (tn === $$2.TEMPLATE) {
+            endTagInHead(p2, token);
         }
+    }
 
-        function trailCharRefStart(code2) {
-            return asciiAlpha(code2) ? trailCharRefInside(code2) : nok(code2);
+    function startTagInSelectInTable(p2, token) {
+        const tn = token.tagName;
+        if (tn === $$2.CAPTION || tn === $$2.TABLE || tn === $$2.TBODY || tn === $$2.TFOOT || tn === $$2.THEAD || tn === $$2.TR || tn === $$2.TD || tn === $$2.TH) {
+            p2.openElements.popUntilTagNamePopped($$2.SELECT);
+            p2._resetInsertionMode();
+            p2._processToken(token);
+        } else {
+            startTagInSelect(p2, token);
         }
+    }
 
-        function trailCharRefInside(code2) {
-            if (code2 === 59) {
-                effects.consume(code2);
-                return trail2;
-            }
-            if (asciiAlpha(code2)) {
-                effects.consume(code2);
-                return trailCharRefInside;
+    function endTagInSelectInTable(p2, token) {
+        const tn = token.tagName;
+        if (tn === $$2.CAPTION || tn === $$2.TABLE || tn === $$2.TBODY || tn === $$2.TFOOT || tn === $$2.THEAD || tn === $$2.TR || tn === $$2.TD || tn === $$2.TH) {
+            if (p2.openElements.hasInTableScope(tn)) {
+                p2.openElements.popUntilTagNamePopped($$2.SELECT);
+                p2._resetInsertionMode();
+                p2._processToken(token);
             }
-            return nok(code2);
+        } else {
+            endTagInSelect(p2, token);
         }
     }
 
-    function tokenizeEmailDomainDotTrail(effects, ok2, nok) {
-        return start2;
-
-        function start2(code2) {
-            effects.consume(code2);
-            return after;
+    function startTagInTemplate(p2, token) {
+        const tn = token.tagName;
+        if (tn === $$2.BASE || tn === $$2.BASEFONT || tn === $$2.BGSOUND || tn === $$2.LINK || tn === $$2.META || tn === $$2.NOFRAMES || tn === $$2.SCRIPT || tn === $$2.STYLE || tn === $$2.TEMPLATE || tn === $$2.TITLE) {
+            startTagInHead(p2, token);
+        } else {
+            const newInsertionMode = TEMPLATE_INSERTION_MODE_SWITCH_MAP[tn] || IN_BODY_MODE;
+            p2._popTmplInsertionMode();
+            p2._pushTmplInsertionMode(newInsertionMode);
+            p2.insertionMode = newInsertionMode;
+            p2._processToken(token);
         }
+    }
 
-        function after(code2) {
-            return asciiAlphanumeric(code2) ? nok(code2) : ok2(code2);
+    function endTagInTemplate(p2, token) {
+        if (token.tagName === $$2.TEMPLATE) {
+            endTagInHead(p2, token);
         }
     }
 
-    function previousWww(code2) {
-        return code2 === null || code2 === 40 || code2 === 42 || code2 === 95 || code2 === 91 || code2 === 93 || code2 === 126 || markdownLineEndingOrSpace(code2);
+    function eofInTemplate(p2, token) {
+        if (p2.openElements.tmplCount > 0) {
+            p2.openElements.popUntilTagNamePopped($$2.TEMPLATE);
+            p2.activeFormattingElements.clearToLastMarker();
+            p2._popTmplInsertionMode();
+            p2._resetInsertionMode();
+            p2._processToken(token);
+        } else {
+            p2.stopped = true;
+        }
     }
 
-    function previousProtocol(code2) {
-        return !asciiAlpha(code2);
+    function startTagAfterBody(p2, token) {
+        if (token.tagName === $$2.HTML) {
+            startTagInBody(p2, token);
+        } else {
+            tokenAfterBody(p2, token);
+        }
     }
 
-    function previousEmail(code2) {
-        return !(code2 === 47 || gfmAtext(code2));
+    function endTagAfterBody(p2, token) {
+        if (token.tagName === $$2.HTML) {
+            if (!p2.fragmentContext) {
+                p2.insertionMode = AFTER_AFTER_BODY_MODE;
+            }
+        } else {
+            tokenAfterBody(p2, token);
+        }
     }
 
-    function gfmAtext(code2) {
-        return code2 === 43 || code2 === 45 || code2 === 46 || code2 === 95 || asciiAlphanumeric(code2);
+    function tokenAfterBody(p2, token) {
+        p2.insertionMode = IN_BODY_MODE;
+        p2._processToken(token);
     }
 
-    function previousUnbalanced(events2) {
-        let index2 = events2.length;
-        let result = false;
-        while (index2--) {
-            const token = events2[index2][1];
-            if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
-                result = true;
-                break;
-            }
-            if (token._gfmAutolinkLiteralWalkedInto) {
-                result = false;
-                break;
-            }
-        }
-        if (events2.length > 0 && !result) {
-            events2[events2.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
+    function startTagInFrameset(p2, token) {
+        const tn = token.tagName;
+        if (tn === $$2.HTML) {
+            startTagInBody(p2, token);
+        } else if (tn === $$2.FRAMESET) {
+            p2._insertElement(token, NS.HTML);
+        } else if (tn === $$2.FRAME) {
+            p2._appendElement(token, NS.HTML);
+            token.ackSelfClosing = true;
+        } else if (tn === $$2.NOFRAMES) {
+            startTagInHead(p2, token);
         }
-        return result;
     }
-    const indent$1 = {
-        tokenize: tokenizeIndent,
-        partial: true
-    };
 
-    function gfmFootnote() {
-        return {
-            document: {
-                [91]: {
-                    tokenize: tokenizeDefinitionStart,
-                    continuation: {
-                        tokenize: tokenizeDefinitionContinuation
-                    },
-                    exit: gfmFootnoteDefinitionEnd
-                }
-            },
-            text: {
-                [91]: {
-                    tokenize: tokenizeGfmFootnoteCall
-                },
-                [93]: {
-                    add: "after",
-                    tokenize: tokenizePotentialGfmFootnoteCall,
-                    resolveTo: resolveToPotentialGfmFootnoteCall
-                }
+    function endTagInFrameset(p2, token) {
+        if (token.tagName === $$2.FRAMESET && !p2.openElements.isRootHtmlElementCurrent()) {
+            p2.openElements.pop();
+            if (!p2.fragmentContext && p2.openElements.currentTagName !== $$2.FRAMESET) {
+                p2.insertionMode = AFTER_FRAMESET_MODE;
             }
-        };
+        }
     }
 
-    function tokenizePotentialGfmFootnoteCall(effects, ok2, nok) {
-        const self2 = this;
-        let index2 = self2.events.length;
-        const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
-        let labelStart;
-        while (index2--) {
-            const token = self2.events[index2][1];
-            if (token.type === "labelImage") {
-                labelStart = token;
-                break;
-            }
-            if (token.type === "gfmFootnoteCall" || token.type === "labelLink" || token.type === "label" || token.type === "image" || token.type === "link") {
-                break;
-            }
+    function startTagAfterFrameset(p2, token) {
+        const tn = token.tagName;
+        if (tn === $$2.HTML) {
+            startTagInBody(p2, token);
+        } else if (tn === $$2.NOFRAMES) {
+            startTagInHead(p2, token);
         }
-        return start2;
+    }
 
-        function start2(code2) {
-            if (!labelStart || !labelStart._balanced) {
-                return nok(code2);
-            }
-            const id2 = normalizeIdentifier(
-                self2.sliceSerialize({
-                    start: labelStart.end,
-                    end: self2.now()
-                })
-            );
-            if (id2.codePointAt(0) !== 94 || !defined.includes(id2.slice(1))) {
-                return nok(code2);
-            }
-            effects.enter("gfmFootnoteCallLabelMarker");
-            effects.consume(code2);
-            effects.exit("gfmFootnoteCallLabelMarker");
-            return ok2(code2);
+    function endTagAfterFrameset(p2, token) {
+        if (token.tagName === $$2.HTML) {
+            p2.insertionMode = AFTER_AFTER_FRAMESET_MODE;
         }
     }
 
-    function resolveToPotentialGfmFootnoteCall(events2, context2) {
-        let index2 = events2.length;
-        while (index2--) {
-            if (events2[index2][1].type === "labelImage" && events2[index2][0] === "enter") {
-                events2[index2][1];
-                break;
-            }
+    function startTagAfterAfterBody(p2, token) {
+        if (token.tagName === $$2.HTML) {
+            startTagInBody(p2, token);
+        } else {
+            tokenAfterAfterBody(p2, token);
         }
-        events2[index2 + 1][1].type = "data";
-        events2[index2 + 3][1].type = "gfmFootnoteCallLabelMarker";
-        const call2 = {
-            type: "gfmFootnoteCall",
-            start: Object.assign({}, events2[index2 + 3][1].start),
-            end: Object.assign({}, events2[events2.length - 1][1].end)
-        };
-        const marker = {
-            type: "gfmFootnoteCallMarker",
-            start: Object.assign({}, events2[index2 + 3][1].end),
-            end: Object.assign({}, events2[index2 + 3][1].end)
-        };
-        marker.end.column++;
-        marker.end.offset++;
-        marker.end._bufferIndex++;
-        const string2 = {
-            type: "gfmFootnoteCallString",
-            start: Object.assign({}, marker.end),
-            end: Object.assign({}, events2[events2.length - 1][1].start)
-        };
-        const chunk = {
-            type: "chunkString",
-            contentType: "string",
-            start: Object.assign({}, string2.start),
-            end: Object.assign({}, string2.end)
-        };
-        const replacement = [
-            events2[index2 + 1],
-            events2[index2 + 2],
-            ["enter", call2, context2],
-            events2[index2 + 3],
-            events2[index2 + 4],
-            ["enter", marker, context2],
-            ["exit", marker, context2],
-            ["enter", string2, context2],
-            ["enter", chunk, context2],
-            ["exit", chunk, context2],
-            ["exit", string2, context2],
-            events2[events2.length - 2],
-            events2[events2.length - 1],
-            ["exit", call2, context2]
-        ];
-        events2.splice(index2, events2.length - index2 + 1, ...replacement);
-        return events2;
     }
 
-    function tokenizeGfmFootnoteCall(effects, ok2, nok) {
-        const self2 = this;
-        const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
-        let size2 = 0;
-        let data2;
-        return start2;
+    function tokenAfterAfterBody(p2, token) {
+        p2.insertionMode = IN_BODY_MODE;
+        p2._processToken(token);
+    }
 
-        function start2(code2) {
-            effects.enter("gfmFootnoteCall");
-            effects.enter("gfmFootnoteCallLabelMarker");
-            effects.consume(code2);
-            effects.exit("gfmFootnoteCallLabelMarker");
-            return callStart;
+    function startTagAfterAfterFrameset(p2, token) {
+        const tn = token.tagName;
+        if (tn === $$2.HTML) {
+            startTagInBody(p2, token);
+        } else if (tn === $$2.NOFRAMES) {
+            startTagInHead(p2, token);
         }
+    }
 
-        function callStart(code2) {
-            if (code2 !== 94)
-                return nok(code2);
-            effects.enter("gfmFootnoteCallMarker");
-            effects.consume(code2);
-            effects.exit("gfmFootnoteCallMarker");
-            effects.enter("gfmFootnoteCallString");
-            effects.enter("chunkString").contentType = "string";
-            return callData;
-        }
+    function nullCharacterInForeignContent(p2, token) {
+        token.chars = unicode.REPLACEMENT_CHARACTER;
+        p2._insertCharacters(token);
+    }
 
-        function callData(code2) {
-            if (size2 > 999 || code2 === 93 && !data2 || code2 === null || code2 === 91 || markdownLineEndingOrSpace(code2)) {
-                return nok(code2);
+    function characterInForeignContent(p2, token) {
+        p2._insertCharacters(token);
+        p2.framesetOk = false;
+    }
+
+    function startTagInForeignContent(p2, token) {
+        if (foreignContent.causesExit(token) && !p2.fragmentContext) {
+            while (p2.treeAdapter.getNamespaceURI(p2.openElements.current) !== NS.HTML && !p2._isIntegrationPoint(p2.openElements.current)) {
+                p2.openElements.pop();
             }
-            if (code2 === 93) {
-                effects.exit("chunkString");
-                const token = effects.exit("gfmFootnoteCallString");
-                if (!defined.includes(normalizeIdentifier(self2.sliceSerialize(token)))) {
-                    return nok(code2);
-                }
-                effects.enter("gfmFootnoteCallLabelMarker");
-                effects.consume(code2);
-                effects.exit("gfmFootnoteCallLabelMarker");
-                effects.exit("gfmFootnoteCall");
-                return ok2;
+            p2._processToken(token);
+        } else {
+            const current2 = p2._getAdjustedCurrentElement();
+            const currentNs = p2.treeAdapter.getNamespaceURI(current2);
+            if (currentNs === NS.MATHML) {
+                foreignContent.adjustTokenMathMLAttrs(token);
+            } else if (currentNs === NS.SVG) {
+                foreignContent.adjustTokenSVGTagName(token);
+                foreignContent.adjustTokenSVGAttrs(token);
             }
-            if (!markdownLineEndingOrSpace(code2)) {
-                data2 = true;
+            foreignContent.adjustTokenXMLAttrs(token);
+            if (token.selfClosing) {
+                p2._appendElement(token, currentNs);
+            } else {
+                p2._insertElement(token, currentNs);
             }
-            size2++;
-            effects.consume(code2);
-            return code2 === 92 ? callEscape : callData;
+            token.ackSelfClosing = true;
         }
+    }
 
-        function callEscape(code2) {
-            if (code2 === 91 || code2 === 92 || code2 === 93) {
-                effects.consume(code2);
-                size2++;
-                return callData;
+    function endTagInForeignContent(p2, token) {
+        for (let i2 = p2.openElements.stackTop; i2 > 0; i2--) {
+            const element2 = p2.openElements.items[i2];
+            if (p2.treeAdapter.getNamespaceURI(element2) === NS.HTML) {
+                p2._processToken(token);
+                break;
+            }
+            if (p2.treeAdapter.getTagName(element2).toLowerCase() === token.tagName) {
+                p2.openElements.popUntilElementPopped(element2);
+                break;
             }
-            return callData(code2);
         }
     }
+    const pointStart = point$1("start");
+    const pointEnd = point$1("end");
 
-    function tokenizeDefinitionStart(effects, ok2, nok) {
-        const self2 = this;
-        const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
-        let identifier;
-        let size2 = 0;
-        let data2;
-        return start2;
+    function point$1(type2) {
+        return point2;
 
-        function start2(code2) {
-            effects.enter("gfmFootnoteDefinition")._container = true;
-            effects.enter("gfmFootnoteDefinitionLabel");
-            effects.enter("gfmFootnoteDefinitionLabelMarker");
-            effects.consume(code2);
-            effects.exit("gfmFootnoteDefinitionLabelMarker");
-            return labelAtMarker;
+        function point2(node2) {
+            const point3 = node2 && node2.position && node2.position[type2] || {};
+            return {
+                line: point3.line || null,
+                column: point3.column || null,
+                offset: point3.offset > -1 ? point3.offset : null
+            };
         }
+    }
+    const convert = function(test2) {
+        if (test2 === void 0 || test2 === null) {
+            return ok;
+        }
+        if (typeof test2 === "string") {
+            return typeFactory(test2);
+        }
+        if (typeof test2 === "object") {
+            return Array.isArray(test2) ? anyFactory(test2) : propsFactory(test2);
+        }
+        if (typeof test2 === "function") {
+            return castFactory(test2);
+        }
+        throw new Error("Expected function, string, or object as test");
+    };
 
-        function labelAtMarker(code2) {
-            if (code2 === 94) {
-                effects.enter("gfmFootnoteDefinitionMarker");
-                effects.consume(code2);
-                effects.exit("gfmFootnoteDefinitionMarker");
-                effects.enter("gfmFootnoteDefinitionLabelString");
-                effects.enter("chunkString").contentType = "string";
-                return labelInside;
-            }
-            return nok(code2);
+    function anyFactory(tests) {
+        const checks2 = [];
+        let index2 = -1;
+        while (++index2 < tests.length) {
+            checks2[index2] = convert(tests[index2]);
         }
+        return castFactory(any);
 
-        function labelInside(code2) {
-            if (size2 > 999 || code2 === 93 && !data2 || code2 === null || code2 === 91 || markdownLineEndingOrSpace(code2)) {
-                return nok(code2);
-            }
-            if (code2 === 93) {
-                effects.exit("chunkString");
-                const token = effects.exit("gfmFootnoteDefinitionLabelString");
-                identifier = normalizeIdentifier(self2.sliceSerialize(token));
-                effects.enter("gfmFootnoteDefinitionLabelMarker");
-                effects.consume(code2);
-                effects.exit("gfmFootnoteDefinitionLabelMarker");
-                effects.exit("gfmFootnoteDefinitionLabel");
-                return labelAfter;
-            }
-            if (!markdownLineEndingOrSpace(code2)) {
-                data2 = true;
+        function any(...parameters) {
+            let index3 = -1;
+            while (++index3 < checks2.length) {
+                if (checks2[index3].call(this, ...parameters))
+                    return true;
             }
-            size2++;
-            effects.consume(code2);
-            return code2 === 92 ? labelEscape : labelInside;
+            return false;
         }
+    }
 
-        function labelEscape(code2) {
-            if (code2 === 91 || code2 === 92 || code2 === 93) {
-                effects.consume(code2);
-                size2++;
-                return labelInside;
+    function propsFactory(check) {
+        return castFactory(all2);
+
+        function all2(node2) {
+            let key;
+            for (key in check) {
+                if (node2[key] !== check[key])
+                    return false;
             }
-            return labelInside(code2);
+            return true;
         }
+    }
 
-        function labelAfter(code2) {
-            if (code2 === 58) {
-                effects.enter("definitionMarker");
-                effects.consume(code2);
-                effects.exit("definitionMarker");
-                if (!defined.includes(identifier)) {
-                    defined.push(identifier);
-                }
-                return factorySpace(
-                    effects,
-                    whitespaceAfter,
-                    "gfmFootnoteDefinitionWhitespace"
-                );
-            }
-            return nok(code2);
+    function typeFactory(check) {
+        return castFactory(type2);
+
+        function type2(node2) {
+            return node2 && node2.type === check;
         }
+    }
 
-        function whitespaceAfter(code2) {
-            return ok2(code2);
+    function castFactory(check) {
+        return assertion;
+
+        function assertion(node2, ...parameters) {
+            return Boolean(
+                node2 && typeof node2 === "object" && "type" in node2 && Boolean(check.call(this, node2, ...parameters))
+            );
         }
     }
 
-    function tokenizeDefinitionContinuation(effects, ok2, nok) {
-        return effects.check(blankLine, ok2, effects.attempt(indent$1, ok2, nok));
+    function ok() {
+        return true;
     }
 
-    function gfmFootnoteDefinitionEnd(effects) {
-        effects.exit("gfmFootnoteDefinition");
+    function color$1(d2) {
+        return d2;
     }
+    const CONTINUE = true;
+    const EXIT = false;
+    const SKIP = "skip";
+    const visitParents = function(tree, test2, visitor, reverse) {
+        if (typeof test2 === "function" && typeof visitor !== "function") {
+            reverse = visitor;
+            visitor = test2;
+            test2 = null;
+        }
+        const is2 = convert(test2);
+        const step2 = reverse ? -1 : 1;
+        factory2(tree, void 0, [])();
 
-    function tokenizeIndent(effects, ok2, nok) {
-        const self2 = this;
-        return factorySpace(
-            effects,
-            afterPrefix,
-            "gfmFootnoteDefinitionIndent",
-            4 + 1
-        );
+        function factory2(node2, index2, parents) {
+            const value = node2 && typeof node2 === "object" ? node2 : {};
+            if (typeof value.type === "string") {
+                const name2 = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
+                Object.defineProperty(visit2, "name", {
+                    value: "node (" + color$1(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
+                });
+            }
+            return visit2;
 
-        function afterPrefix(code2) {
-            const tail = self2.events[self2.events.length - 1];
-            return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok2(code2) : nok(code2);
+            function visit2() {
+                let result = [];
+                let subresult;
+                let offset2;
+                let grandparents;
+                if (!test2 || is2(node2, index2, parents[parents.length - 1] || null)) {
+                    result = toResult(visitor(node2, parents));
+                    if (result[0] === EXIT) {
+                        return result;
+                    }
+                }
+                if (node2.children && result[0] !== SKIP) {
+                    offset2 = (reverse ? node2.children.length : -1) + step2;
+                    grandparents = parents.concat(node2);
+                    while (offset2 > -1 && offset2 < node2.children.length) {
+                        subresult = factory2(node2.children[offset2], offset2, grandparents)();
+                        if (subresult[0] === EXIT) {
+                            return subresult;
+                        }
+                        offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step2;
+                    }
+                }
+                return result;
+            }
+        }
+    };
+
+    function toResult(value) {
+        if (Array.isArray(value)) {
+            return value;
+        }
+        if (typeof value === "number") {
+            return [CONTINUE, value];
         }
+        return [value];
     }
+    const visit = function(tree, test2, visitor, reverse) {
+        if (typeof test2 === "function" && typeof visitor !== "function") {
+            reverse = visitor;
+            visitor = test2;
+            test2 = null;
+        }
+        visitParents(tree, test2, overload, reverse);
 
-    function gfmStrikethrough(options) {
-        const options_ = options || {};
-        let single = options_.singleTilde;
-        const tokenizer2 = {
-            tokenize: tokenizeStrikethrough,
-            resolveAll: resolveAllStrikethrough
-        };
-        if (single === null || single === void 0) {
-            single = true;
+        function overload(node2, parents) {
+            const parent = parents[parents.length - 1];
+            return visitor(
+                node2,
+                parent ? parent.children.indexOf(node2) : null,
+                parent
+            );
         }
-        return {
-            text: {
-                [126]: tokenizer2
-            },
-            insideSpan: {
-                null: [tokenizer2]
-            },
-            attentionMarkers: {
-                null: [126]
+    };
+    const search = /[#.]/g;
+
+    function parseSelector(selector2, defaultTagName) {
+        const value = selector2 || "";
+        const props = {};
+        let start2 = 0;
+        let previous2;
+        let tagName;
+        while (start2 < value.length) {
+            search.lastIndex = start2;
+            const match2 = search.exec(value);
+            const subvalue = value.slice(start2, match2 ? match2.index : value.length);
+            if (subvalue) {
+                if (!previous2) {
+                    tagName = subvalue;
+                } else if (previous2 === "#") {
+                    props.id = subvalue;
+                } else if (Array.isArray(props.className)) {
+                    props.className.push(subvalue);
+                } else {
+                    props.className = [subvalue];
+                }
+                start2 += subvalue.length;
+            }
+            if (match2) {
+                previous2 = match2[0];
+                start2++;
             }
+        }
+        return {
+            type: "element",
+            tagName: tagName || defaultTagName || "div",
+            properties: props,
+            children: []
         };
+    }
+    const buttonTypes = /* @__PURE__ */ new Set(["menu", "submit", "reset", "button"]);
+    const own$2 = {}.hasOwnProperty;
 
-        function resolveAllStrikethrough(events2, context2) {
+    function core$1(schema, defaultTagName, caseSensitive) {
+        const adjust = caseSensitive && createAdjustMap(caseSensitive);
+        const h2 = function(selector2, properties, ...children2) {
             let index2 = -1;
-            while (++index2 < events2.length) {
-                if (events2[index2][0] === "enter" && events2[index2][1].type === "strikethroughSequenceTemporary" && events2[index2][1]._close) {
-                    let open = index2;
-                    while (open--) {
-                        if (events2[open][0] === "exit" && events2[open][1].type === "strikethroughSequenceTemporary" && events2[open][1]._open && events2[index2][1].end.offset - events2[index2][1].start.offset === events2[open][1].end.offset - events2[open][1].start.offset) {
-                            events2[index2][1].type = "strikethroughSequence";
-                            events2[open][1].type = "strikethroughSequence";
-                            const strikethrough2 = {
-                                type: "strikethrough",
-                                start: Object.assign({}, events2[open][1].start),
-                                end: Object.assign({}, events2[index2][1].end)
-                            };
-                            const text2 = {
-                                type: "strikethroughText",
-                                start: Object.assign({}, events2[open][1].end),
-                                end: Object.assign({}, events2[index2][1].start)
-                            };
-                            const nextEvents = [
-                                ["enter", strikethrough2, context2],
-                                ["enter", events2[open][1], context2],
-                                ["exit", events2[open][1], context2],
-                                ["enter", text2, context2]
-                            ];
-                            const insideSpan2 = context2.parser.constructs.insideSpan.null;
-                            if (insideSpan2) {
-                                splice(
-                                    nextEvents,
-                                    nextEvents.length,
-                                    0,
-                                    resolveAll(insideSpan2, events2.slice(open + 1, index2), context2)
-                                );
-                            }
-                            splice(nextEvents, nextEvents.length, 0, [
-                                ["exit", text2, context2],
-                                ["enter", events2[index2][1], context2],
-                                ["exit", events2[index2][1], context2],
-                                ["exit", strikethrough2, context2]
-                            ]);
-                            splice(events2, open - 1, index2 - open + 3, nextEvents);
-                            index2 = open + nextEvents.length - 2;
-                            break;
+            let node2;
+            if (selector2 === void 0 || selector2 === null) {
+                node2 = {
+                    type: "root",
+                    children: []
+                };
+                children2.unshift(properties);
+            } else {
+                node2 = parseSelector(selector2, defaultTagName);
+                node2.tagName = node2.tagName.toLowerCase();
+                if (adjust && own$2.call(adjust, node2.tagName)) {
+                    node2.tagName = adjust[node2.tagName];
+                }
+                if (isProperties(properties, node2.tagName)) {
+                    let key;
+                    for (key in properties) {
+                        if (own$2.call(properties, key)) {
+                            addProperty(schema, node2.properties, key, properties[key]);
                         }
                     }
+                } else {
+                    children2.unshift(properties);
                 }
             }
-            index2 = -1;
-            while (++index2 < events2.length) {
-                if (events2[index2][1].type === "strikethroughSequenceTemporary") {
-                    events2[index2][1].type = "data";
-                }
+            while (++index2 < children2.length) {
+                addChild(node2.children, children2[index2]);
             }
-            return events2;
-        }
-
-        function tokenizeStrikethrough(effects, ok2, nok) {
-            const previous2 = this.previous;
-            const events2 = this.events;
-            let size2 = 0;
-            return start2;
-
-            function start2(code2) {
-                if (previous2 === 126 && events2[events2.length - 1][1].type !== "characterEscape") {
-                    return nok(code2);
-                }
-                effects.enter("strikethroughSequenceTemporary");
-                return more(code2);
+            if (node2.type === "element" && node2.tagName === "template") {
+                node2.content = {
+                    type: "root",
+                    children: node2.children
+                };
+                node2.children = [];
             }
+            return node2;
+        };
+        return h2;
+    }
 
-            function more(code2) {
-                const before = classifyCharacter(previous2);
-                if (code2 === 126) {
-                    if (size2 > 1)
-                        return nok(code2);
-                    effects.consume(code2);
-                    size2++;
-                    return more;
-                }
-                if (size2 < 2 && !single)
-                    return nok(code2);
-                const token = effects.exit("strikethroughSequenceTemporary");
-                const after = classifyCharacter(code2);
-                token._open = !after || after === 2 && Boolean(before);
-                token._close = !before || before === 2 && Boolean(after);
-                return ok2(code2);
-            }
+    function isProperties(value, name2) {
+        if (value === null || value === void 0 || typeof value !== "object" || Array.isArray(value)) {
+            return false;
         }
-    }
-    class EditMap {
-        constructor() {
-            this.map = [];
+        if (name2 === "input" || !value.type || typeof value.type !== "string") {
+            return true;
         }
-        add(index2, remove2, add2) {
-            addImpl(this, index2, remove2, add2);
+        if ("children" in value && Array.isArray(value.children)) {
+            return false;
         }
-        consume(events2) {
-            this.map.sort(function(a2, b2) {
-                return a2[0] - b2[0];
-            });
-            if (this.map.length === 0) {
-                return;
-            }
-            let index2 = this.map.length;
-            const vecs = [];
-            while (index2 > 0) {
-                index2 -= 1;
-                vecs.push(
-                    events2.slice(this.map[index2][0] + this.map[index2][1]),
-                    this.map[index2][2]
-                );
-                events2.length = this.map[index2][0];
-            }
-            vecs.push([...events2]);
-            events2.length = 0;
-            let slice = vecs.pop();
-            while (slice) {
-                events2.push(...slice);
-                slice = vecs.pop();
-            }
-            this.map.length = 0;
+        if (name2 === "button") {
+            return buttonTypes.has(value.type.toLowerCase());
         }
+        return !("value" in value);
     }
 
-    function addImpl(editMap, at2, remove2, add2) {
-        let index2 = 0;
-        if (remove2 === 0 && add2.length === 0) {
+    function addProperty(schema, properties, key, value) {
+        const info = find$3(schema, key);
+        let index2 = -1;
+        let result;
+        if (value === void 0 || value === null)
             return;
-        }
-        while (index2 < editMap.map.length) {
-            if (editMap.map[index2][0] === at2) {
-                editMap.map[index2][1] += remove2;
-                editMap.map[index2][2].push(...add2);
+        if (typeof value === "number") {
+            if (Number.isNaN(value))
                 return;
+            result = value;
+        } else if (typeof value === "boolean") {
+            result = value;
+        } else if (typeof value === "string") {
+            if (info.spaceSeparated) {
+                result = parse$7(value);
+            } else if (info.commaSeparated) {
+                result = parse$8(value);
+            } else if (info.commaOrSpaceSeparated) {
+                result = parse$7(parse$8(value).join(" "));
+            } else {
+                result = parsePrimitive(info, info.property, value);
             }
-            index2 += 1;
+        } else if (Array.isArray(value)) {
+            result = value.concat();
+        } else {
+            result = info.property === "style" ? style(value) : String(value);
         }
-        editMap.map.push([at2, remove2, add2]);
+        if (Array.isArray(result)) {
+            const finalResult = [];
+            while (++index2 < result.length) {
+                finalResult[index2] = parsePrimitive(info, info.property, result[index2]);
+            }
+            result = finalResult;
+        }
+        if (info.property === "className" && Array.isArray(properties.className)) {
+            result = properties.className.concat(result);
+        }
+        properties[info.property] = result;
     }
 
-    function gfmTableAlign(events2, index2) {
-        let inDelimiterRow = false;
-        const align = [];
-        while (index2 < events2.length) {
-            const event2 = events2[index2];
-            if (inDelimiterRow) {
-                if (event2[0] === "enter") {
-                    if (event2[1].type === "tableContent") {
-                        align.push(
-                            events2[index2 + 1][1].type === "tableDelimiterMarker" ? "left" : "none"
-                        );
-                    }
-                } else if (event2[1].type === "tableContent") {
-                    if (events2[index2 - 1][1].type === "tableDelimiterMarker") {
-                        const alignIndex = align.length - 1;
-                        align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
-                    }
-                } else if (event2[1].type === "tableDelimiterRow") {
-                    break;
-                }
-            } else if (event2[0] === "enter" && event2[1].type === "tableDelimiterRow") {
-                inDelimiterRow = true;
+    function addChild(nodes, value) {
+        let index2 = -1;
+        if (value === void 0 || value === null)
+        ;
+        else if (typeof value === "string" || typeof value === "number") {
+            nodes.push({
+                type: "text",
+                value: String(value)
+            });
+        } else if (Array.isArray(value)) {
+            while (++index2 < value.length) {
+                addChild(nodes, value[index2]);
             }
-            index2 += 1;
+        } else if (typeof value === "object" && "type" in value) {
+            if (value.type === "root") {
+                addChild(nodes, value.children);
+            } else {
+                nodes.push(value);
+            }
+        } else {
+            throw new Error("Expected node, nodes, or string, got `" + value + "`");
         }
-        return align;
     }
 
-    function gfmTable() {
-        return {
-            flow: {
-                null: {
-                    tokenize: tokenizeTable,
-                    resolveAll: resolveTable
-                }
+    function parsePrimitive(info, name2, value) {
+        if (typeof value === "string") {
+            if (info.number && value && !Number.isNaN(Number(value))) {
+                return Number(value);
             }
-        };
+            if ((info.boolean || info.overloadedBoolean) && (value === "" || normalize$2(value) === normalize$2(name2))) {
+                return true;
+            }
+        }
+        return value;
     }
 
-    function tokenizeTable(effects, ok2, nok) {
-        const self2 = this;
-        let size2 = 0;
-        let sizeB = 0;
-        let seen;
-        return start2;
-
-        function start2(code2) {
-            let index2 = self2.events.length - 1;
-            while (index2 > -1) {
-                const type2 = self2.events[index2][1].type;
-                if (type2 === "lineEnding" || type2 === "linePrefix")
-                    index2--;
-                else
-                    break;
-            }
-            const tail = index2 > -1 ? self2.events[index2][1].type : null;
-            const next2 = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
-            if (next2 === bodyRowStart && self2.parser.lazy[self2.now().line]) {
-                return nok(code2);
+    function style(value) {
+        const result = [];
+        let key;
+        for (key in value) {
+            if (own$2.call(value, key)) {
+                result.push([key, value[key]].join(": "));
             }
-            return next2(code2);
         }
+        return result.join("; ");
+    }
 
-        function headRowBefore(code2) {
-            effects.enter("tableHead");
-            effects.enter("tableRow");
-            return headRowStart(code2);
+    function createAdjustMap(values) {
+        const result = {};
+        let index2 = -1;
+        while (++index2 < values.length) {
+            result[values[index2].toLowerCase()] = values[index2];
         }
+        return result;
+    }
+    const h$1 = core$1(html$3, "div");
+    const svgCaseSensitiveTagNames = [
+        "altGlyph",
+        "altGlyphDef",
+        "altGlyphItem",
+        "animateColor",
+        "animateMotion",
+        "animateTransform",
+        "clipPath",
+        "feBlend",
+        "feColorMatrix",
+        "feComponentTransfer",
+        "feComposite",
+        "feConvolveMatrix",
+        "feDiffuseLighting",
+        "feDisplacementMap",
+        "feDistantLight",
+        "feDropShadow",
+        "feFlood",
+        "feFuncA",
+        "feFuncB",
+        "feFuncG",
+        "feFuncR",
+        "feGaussianBlur",
+        "feImage",
+        "feMerge",
+        "feMergeNode",
+        "feMorphology",
+        "feOffset",
+        "fePointLight",
+        "feSpecularLighting",
+        "feSpotLight",
+        "feTile",
+        "feTurbulence",
+        "foreignObject",
+        "glyphRef",
+        "linearGradient",
+        "radialGradient",
+        "solidColor",
+        "textArea",
+        "textPath"
+    ];
+    const s$1 = core$1(svg, "g", svgCaseSensitiveTagNames);
 
-        function headRowStart(code2) {
-            if (code2 === 124) {
-                return headRowBreak(code2);
-            }
-            seen = true;
-            sizeB += 1;
-            return headRowBreak(code2);
+    function location(file) {
+        const value = String(file);
+        const indices2 = [];
+        const search2 = /\r?\n|\r/g;
+        while (search2.test(value)) {
+            indices2.push(search2.lastIndex);
         }
+        indices2.push(value.length + 1);
+        return {
+            toPoint,
+            toOffset
+        };
 
-        function headRowBreak(code2) {
-            if (code2 === null) {
-                return nok(code2);
-            }
-            if (markdownLineEnding(code2)) {
-                if (sizeB > 1) {
-                    sizeB = 0;
-                    self2.interrupt = true;
-                    effects.exit("tableRow");
-                    effects.enter("lineEnding");
-                    effects.consume(code2);
-                    effects.exit("lineEnding");
-                    return headDelimiterStart;
+        function toPoint(offset2) {
+            let index2 = -1;
+            if (typeof offset2 === "number" && offset2 > -1 && offset2 < indices2[indices2.length - 1]) {
+                while (++index2 < indices2.length) {
+                    if (indices2[index2] > offset2) {
+                        return {
+                            line: index2 + 1,
+                            column: offset2 - (index2 > 0 ? indices2[index2 - 1] : 0) + 1,
+                            offset: offset2
+                        };
+                    }
                 }
-                return nok(code2);
-            }
-            if (markdownSpace(code2)) {
-                return factorySpace(effects, headRowBreak, "whitespace")(code2);
-            }
-            sizeB += 1;
-            if (seen) {
-                seen = false;
-                size2 += 1;
-            }
-            if (code2 === 124) {
-                effects.enter("tableCellDivider");
-                effects.consume(code2);
-                effects.exit("tableCellDivider");
-                seen = true;
-                return headRowBreak;
             }
-            effects.enter("data");
-            return headRowData(code2);
+            return {
+                line: void 0,
+                column: void 0,
+                offset: void 0
+            };
         }
 
-        function headRowData(code2) {
-            if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
-                effects.exit("data");
-                return headRowBreak(code2);
+        function toOffset(point2) {
+            const line = point2 && point2.line;
+            const column = point2 && point2.column;
+            if (typeof line === "number" && typeof column === "number" && !Number.isNaN(line) && !Number.isNaN(column) && line - 1 in indices2) {
+                const offset2 = (indices2[line - 2] || 0) + column - 1 || 0;
+                if (offset2 > -1 && offset2 < indices2[indices2.length - 1]) {
+                    return offset2;
+                }
             }
-            effects.consume(code2);
-            return code2 === 92 ? headRowEscape : headRowData;
+            return -1;
         }
+    }
+    const webNamespaces = {
+        html: "http://www.w3.org/1999/xhtml",
+        mathml: "http://www.w3.org/1998/Math/MathML",
+        svg: "http://www.w3.org/2000/svg",
+        xlink: "http://www.w3.org/1999/xlink",
+        xml: "http://www.w3.org/XML/1998/namespace",
+        xmlns: "http://www.w3.org/2000/xmlns/"
+    };
+    const own$1 = {}.hasOwnProperty;
+    const proto = Object.prototype;
 
-        function headRowEscape(code2) {
-            if (code2 === 92 || code2 === 124) {
-                effects.consume(code2);
-                return headRowData;
-            }
-            return headRowData(code2);
+    function fromParse5(tree, options) {
+        const options_ = options || {};
+        let settings2;
+        let file;
+        if (isFile(options_)) {
+            file = options_;
+            settings2 = {};
+        } else {
+            file = options_.file || void 0;
+            settings2 = options_;
         }
+        return one$2({
+                schema: settings2.space === "svg" ? svg : html$3,
+                file,
+                verbose: settings2.verbose,
+                location: false
+            },
+            tree
+        );
+    }
 
-        function headDelimiterStart(code2) {
-            self2.interrupt = false;
-            if (self2.parser.lazy[self2.now().line]) {
-                return nok(code2);
+    function one$2(state, node2) {
+        let result;
+        switch (node2.nodeName) {
+            case "#comment": {
+                const reference2 = node2;
+                result = {
+                    type: "comment",
+                    value: reference2.data
+                };
+                patch$1(state, reference2, result);
+                return result;
             }
-            effects.enter("tableDelimiterRow");
-            seen = false;
-            if (markdownSpace(code2)) {
-                return factorySpace(
-                    effects,
-                    headDelimiterBefore,
-                    "linePrefix",
-                    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
-                )(code2);
+            case "#document":
+            case "#document-fragment": {
+                const reference2 = node2;
+                const quirksMode = "mode" in reference2 ? reference2.mode === "quirks" || reference2.mode === "limited-quirks" : false;
+                result = {
+                    type: "root",
+                    children: all$1(state, node2.childNodes),
+                    data: {
+                        quirksMode
+                    }
+                };
+                if (state.file && state.location) {
+                    const doc2 = String(state.file);
+                    const loc = location(doc2);
+                    const start2 = loc.toPoint(0);
+                    const end2 = loc.toPoint(doc2.length);
+                    result.position = {
+                        start: start2,
+                        end: end2
+                    };
+                }
+                return result;
             }
-            return headDelimiterBefore(code2);
-        }
-
-        function headDelimiterBefore(code2) {
-            if (code2 === 45 || code2 === 58) {
-                return headDelimiterValueBefore(code2);
+            case "#documentType": {
+                const reference2 = node2;
+                result = {
+                    type: "doctype"
+                };
+                patch$1(state, reference2, result);
+                return result;
             }
-            if (code2 === 124) {
-                seen = true;
-                effects.enter("tableCellDivider");
-                effects.consume(code2);
-                effects.exit("tableCellDivider");
-                return headDelimiterCellBefore;
+            case "#text": {
+                const reference2 = node2;
+                result = {
+                    type: "text",
+                    value: reference2.value
+                };
+                patch$1(state, reference2, result);
+                return result;
             }
-            return headDelimiterNok(code2);
-        }
-
-        function headDelimiterCellBefore(code2) {
-            if (markdownSpace(code2)) {
-                return factorySpace(effects, headDelimiterValueBefore, "whitespace")(code2);
+            default: {
+                const reference2 = node2;
+                result = element$2(state, reference2);
+                return result;
             }
-            return headDelimiterValueBefore(code2);
         }
+    }
 
-        function headDelimiterValueBefore(code2) {
-            if (code2 === 58) {
-                sizeB += 1;
-                seen = true;
-                effects.enter("tableDelimiterMarker");
-                effects.consume(code2);
-                effects.exit("tableDelimiterMarker");
-                return headDelimiterLeftAlignmentAfter;
-            }
-            if (code2 === 45) {
-                sizeB += 1;
-                return headDelimiterLeftAlignmentAfter(code2);
-            }
-            if (code2 === null || markdownLineEnding(code2)) {
-                return headDelimiterCellAfter(code2);
-            }
-            return headDelimiterNok(code2);
+    function all$1(state, nodes) {
+        let index2 = -1;
+        const result = [];
+        while (++index2 < nodes.length) {
+            result[index2] = one$2(state, nodes[index2]);
         }
+        return result;
+    }
 
-        function headDelimiterLeftAlignmentAfter(code2) {
-            if (code2 === 45) {
-                effects.enter("tableDelimiterFiller");
-                return headDelimiterFiller(code2);
+    function element$2(state, node2) {
+        const schema = state.schema;
+        state.schema = node2.namespaceURI === webNamespaces.svg ? svg : html$3;
+        let index2 = -1;
+        const props = {};
+        while (++index2 < node2.attrs.length) {
+            const attribute = node2.attrs[index2];
+            const name2 = (attribute.prefix ? attribute.prefix + ":" : "") + attribute.name;
+            if (!own$1.call(proto, name2)) {
+                props[name2] = attribute.value;
             }
-            return headDelimiterNok(code2);
         }
-
-        function headDelimiterFiller(code2) {
-            if (code2 === 45) {
-                effects.consume(code2);
-                return headDelimiterFiller;
-            }
-            if (code2 === 58) {
-                seen = true;
-                effects.exit("tableDelimiterFiller");
-                effects.enter("tableDelimiterMarker");
-                effects.consume(code2);
-                effects.exit("tableDelimiterMarker");
-                return headDelimiterRightAlignmentAfter;
+        const fn2 = state.schema.space === "svg" ? s$1 : h$1;
+        const result = fn2(node2.tagName, props, all$1(state, node2.childNodes));
+        patch$1(state, node2, result);
+        if (result.tagName === "template") {
+            const reference2 = node2;
+            const pos = reference2.sourceCodeLocation;
+            const startTag2 = pos && pos.startTag && position$1(pos.startTag);
+            const endTag2 = pos && pos.endTag && position$1(pos.endTag);
+            const content2 = one$2(state, reference2.content);
+            if (startTag2 && endTag2 && state.file) {
+                content2.position = {
+                    start: startTag2.end,
+                    end: endTag2.start
+                };
             }
-            effects.exit("tableDelimiterFiller");
-            return headDelimiterRightAlignmentAfter(code2);
+            result.content = content2;
         }
+        state.schema = schema;
+        return result;
+    }
 
-        function headDelimiterRightAlignmentAfter(code2) {
-            if (markdownSpace(code2)) {
-                return factorySpace(effects, headDelimiterCellAfter, "whitespace")(code2);
+    function patch$1(state, from, to2) {
+        if ("sourceCodeLocation" in from && from.sourceCodeLocation && state.file) {
+            const position2 = createLocation(state, to2, from.sourceCodeLocation);
+            if (position2) {
+                state.location = true;
+                to2.position = position2;
             }
-            return headDelimiterCellAfter(code2);
         }
+    }
 
-        function headDelimiterCellAfter(code2) {
-            if (code2 === 124) {
-                return headDelimiterBefore(code2);
+    function createLocation(state, node2, location2) {
+        const result = position$1(location2);
+        if (node2.type === "element") {
+            const tail = node2.children[node2.children.length - 1];
+            if (result && !location2.endTag && tail && tail.position && tail.position.end) {
+                result.end = Object.assign({}, tail.position.end);
             }
-            if (code2 === null || markdownLineEnding(code2)) {
-                if (!seen || size2 !== sizeB) {
-                    return headDelimiterNok(code2);
+            if (state.verbose) {
+                const props = {};
+                let key;
+                if (location2.attrs) {
+                    for (key in location2.attrs) {
+                        if (own$1.call(location2.attrs, key)) {
+                            props[find$3(state.schema, key).property] = position$1(
+                                location2.attrs[key]
+                            );
+                        }
+                    }
                 }
-                effects.exit("tableDelimiterRow");
-                effects.exit("tableHead");
-                return ok2(code2);
+                node2.data = {
+                    position: {
+                        opening: position$1(location2.startTag),
+                        closing: location2.endTag ? position$1(location2.endTag) : null,
+                        properties: props
+                    }
+                };
             }
-            return headDelimiterNok(code2);
         }
+        return result;
+    }
 
-        function headDelimiterNok(code2) {
-            return nok(code2);
-        }
+    function position$1(loc) {
+        const start2 = point({
+            line: loc.startLine,
+            column: loc.startCol,
+            offset: loc.startOffset
+        });
+        const end2 = point({
+            line: loc.endLine,
+            column: loc.endCol,
+            offset: loc.endOffset
+        });
+        return start2 || end2 ? {
+            start: start2,
+            end: end2
+        } : void 0;
+    }
 
-        function bodyRowStart(code2) {
-            effects.enter("tableRow");
-            return bodyRowBreak(code2);
-        }
+    function point(point2) {
+        return point2.line && point2.column ? point2 : void 0;
+    }
 
-        function bodyRowBreak(code2) {
-            if (code2 === 124) {
-                effects.enter("tableCellDivider");
-                effects.consume(code2);
-                effects.exit("tableCellDivider");
-                return bodyRowBreak;
-            }
-            if (code2 === null || markdownLineEnding(code2)) {
-                effects.exit("tableRow");
-                return ok2(code2);
-            }
-            if (markdownSpace(code2)) {
-                return factorySpace(effects, bodyRowBreak, "whitespace")(code2);
-            }
-            effects.enter("data");
-            return bodyRowData(code2);
+    function isFile(value) {
+        return "messages" in value;
+    }
+    const own = {}.hasOwnProperty;
+    const one$1 = zwitch("type", {
+        handlers: {
+            root: root$1,
+            element: element$1,
+            text,
+            comment: comment$1,
+            doctype
         }
+    });
 
-        function bodyRowData(code2) {
-            if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
-                effects.exit("data");
-                return bodyRowBreak(code2);
-            }
-            effects.consume(code2);
-            return code2 === 92 ? bodyRowEscape : bodyRowData;
-        }
+    function toParse5(tree, options) {
+        const space2 = options && typeof options === "object" ? options.space : options;
+        return one$1(tree, space2 === "svg" ? svg : html$3);
+    }
 
-        function bodyRowEscape(code2) {
-            if (code2 === 92 || code2 === 124) {
-                effects.consume(code2);
-                return bodyRowData;
-            }
-            return bodyRowData(code2);
-        }
+    function root$1(node2, schema) {
+        const result = {
+            nodeName: "#document",
+            mode: (node2.data || {}).quirksMode ? "quirks" : "no-quirks",
+            childNodes: []
+        };
+        result.childNodes = all(node2.children, result, schema);
+        patch(node2, result);
+        return result;
     }
 
-    function resolveTable(events2, context2) {
-        let index2 = -1;
-        let inFirstCellAwaitingPipe = true;
-        let rowKind = 0;
-        let lastCell = [0, 0, 0, 0];
-        let cell = [0, 0, 0, 0];
-        let afterHeadAwaitingFirstBodyRow = false;
-        let lastTableEnd = 0;
-        let currentTable;
-        let currentBody;
-        let currentCell;
-        const map2 = new EditMap();
-        while (++index2 < events2.length) {
-            const event2 = events2[index2];
-            const token = event2[1];
-            if (event2[0] === "enter") {
-                if (token.type === "tableHead") {
-                    afterHeadAwaitingFirstBodyRow = false;
-                    if (lastTableEnd !== 0) {
-                        flushTableEnd(map2, context2, lastTableEnd, currentTable, currentBody);
-                        currentBody = void 0;
-                        lastTableEnd = 0;
-                    }
-                    currentTable = {
-                        type: "table",
-                        start: Object.assign({}, token.start),
-                        end: Object.assign({}, token.end)
-                    };
-                    map2.add(index2, 0, [
-                        ["enter", currentTable, context2]
-                    ]);
-                } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
-                    inFirstCellAwaitingPipe = true;
-                    currentCell = void 0;
-                    lastCell = [0, 0, 0, 0];
-                    cell = [0, index2 + 1, 0, 0];
-                    if (afterHeadAwaitingFirstBodyRow) {
-                        afterHeadAwaitingFirstBodyRow = false;
-                        currentBody = {
-                            type: "tableBody",
-                            start: Object.assign({}, token.start),
-                            end: Object.assign({}, token.end)
-                        };
-                        map2.add(index2, 0, [
-                            ["enter", currentBody, context2]
-                        ]);
-                    }
-                    rowKind = token.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
-                } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
-                    inFirstCellAwaitingPipe = false;
-                    if (cell[2] === 0) {
-                        if (lastCell[1] !== 0) {
-                            cell[0] = cell[1];
-                            currentCell = flushCell(
-                                map2,
-                                context2,
-                                lastCell,
-                                rowKind,
-                                void 0,
-                                currentCell
-                            );
-                            lastCell = [0, 0, 0, 0];
-                        }
-                        cell[2] = index2;
-                    }
-                } else if (token.type === "tableCellDivider") {
-                    if (inFirstCellAwaitingPipe) {
-                        inFirstCellAwaitingPipe = false;
-                    } else {
-                        if (lastCell[1] !== 0) {
-                            cell[0] = cell[1];
-                            currentCell = flushCell(
-                                map2,
-                                context2,
-                                lastCell,
-                                rowKind,
-                                void 0,
-                                currentCell
-                            );
-                        }
-                        lastCell = cell;
-                        cell = [lastCell[1], index2, 0, 0];
-                    }
-                }
-            } else if (token.type === "tableHead") {
-                afterHeadAwaitingFirstBodyRow = true;
-                lastTableEnd = index2;
-            } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
-                lastTableEnd = index2;
-                if (lastCell[1] !== 0) {
-                    cell[0] = cell[1];
-                    currentCell = flushCell(
-                        map2,
-                        context2,
-                        lastCell,
-                        rowKind,
-                        index2,
-                        currentCell
+    function fragment$8(node2, schema) {
+        const result = {
+            nodeName: "#document-fragment",
+            childNodes: []
+        };
+        result.childNodes = all(node2.children, result, schema);
+        patch(node2, result);
+        return result;
+    }
+
+    function doctype(node2) {
+        const result = {
+            nodeName: "#documentType",
+            name: "html",
+            publicId: "",
+            systemId: "",
+            parentNode: void 0
+        };
+        patch(node2, result);
+        return result;
+    }
+
+    function text(node2) {
+        const result = {
+            nodeName: "#text",
+            value: node2.value,
+            parentNode: void 0
+        };
+        patch(node2, result);
+        return result;
+    }
+
+    function comment$1(node2) {
+        const result = {
+            nodeName: "#comment",
+            data: node2.value,
+            parentNode: void 0
+        };
+        patch(node2, result);
+        return result;
+    }
+
+    function element$1(node2, schema) {
+        const parentSchema = schema;
+        let currentSchema = parentSchema;
+        if (node2.type === "element" && node2.tagName.toLowerCase() === "svg" && parentSchema.space === "html") {
+            currentSchema = svg;
+        }
+        const attrs2 = [];
+        let prop;
+        if (node2.properties) {
+            for (prop in node2.properties) {
+                if (prop !== "children" && own.call(node2.properties, prop)) {
+                    const result2 = createProperty(
+                        currentSchema,
+                        prop,
+                        node2.properties[prop]
                     );
-                } else if (cell[1] !== 0) {
-                    currentCell = flushCell(map2, context2, cell, rowKind, index2, currentCell);
+                    if (result2) {
+                        attrs2.push(result2);
+                    }
                 }
-                rowKind = 0;
-            } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
-                cell[3] = index2;
             }
         }
-        if (lastTableEnd !== 0) {
-            flushTableEnd(map2, context2, lastTableEnd, currentTable, currentBody);
-        }
-        map2.consume(context2.events);
-        index2 = -1;
-        while (++index2 < context2.events.length) {
-            const event2 = context2.events[index2];
-            if (event2[0] === "enter" && event2[1].type === "table") {
-                event2[1]._align = gfmTableAlign(context2.events, index2);
-            }
+        const result = {
+            nodeName: node2.tagName,
+            tagName: node2.tagName,
+            attrs: attrs2,
+            namespaceURI: webNamespaces[currentSchema.space],
+            childNodes: [],
+            parentNode: void 0
+        };
+        result.childNodes = all(node2.children, result, currentSchema);
+        patch(node2, result);
+        if (node2.tagName === "template" && node2.content) {
+            result.content = fragment$8(node2.content, currentSchema);
         }
-        return events2;
+        return result;
     }
 
-    function flushCell(map2, context2, range2, rowKind, rowEnd, previousCell) {
-        const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
-        const valueName = "tableContent";
-        if (range2[0] !== 0) {
-            previousCell.end = Object.assign({}, getPoint(context2.events, range2[0]));
-            map2.add(range2[0], 0, [
-                ["exit", previousCell, context2]
-            ]);
+    function createProperty(schema, prop, value) {
+        const info = find$3(schema, prop);
+        if (value === void 0 || value === null || value === false || typeof value === "number" && Number.isNaN(value) || !value && info.boolean) {
+            return;
         }
-        const now2 = getPoint(context2.events, range2[1]);
-        previousCell = {
-            type: groupName,
-            start: Object.assign({}, now2),
-            end: Object.assign({}, now2)
+        if (Array.isArray(value)) {
+            value = info.commaSeparated ? stringify$3(value) : stringify$2(value);
+        }
+        const attribute = {
+            name: info.attribute,
+            value: value === true ? "" : String(value)
         };
-        map2.add(range2[1], 0, [
-            ["enter", previousCell, context2]
-        ]);
-        if (range2[2] !== 0) {
-            const relatedStart = getPoint(context2.events, range2[2]);
-            const relatedEnd = getPoint(context2.events, range2[3]);
-            const valueToken = {
-                type: valueName,
-                start: Object.assign({}, relatedStart),
-                end: Object.assign({}, relatedEnd)
-            };
-            map2.add(range2[2], 0, [
-                ["enter", valueToken, context2]
-            ]);
-            if (rowKind !== 2) {
-                const start2 = context2.events[range2[2]];
-                const end2 = context2.events[range2[3]];
-                start2[1].end = Object.assign({}, end2[1].end);
-                start2[1].type = "chunkText";
-                start2[1].contentType = "text";
-                if (range2[3] > range2[2] + 1) {
-                    const a2 = range2[2] + 1;
-                    const b2 = range2[3] - range2[2] - 1;
-                    map2.add(a2, b2, []);
-                }
+        if (info.space && info.space !== "html" && info.space !== "svg") {
+            const index2 = attribute.name.indexOf(":");
+            if (index2 < 0) {
+                attribute.prefix = "";
+            } else {
+                attribute.name = attribute.name.slice(index2 + 1);
+                attribute.prefix = info.attribute.slice(0, index2);
             }
-            map2.add(range2[3] + 1, 0, [
-                ["exit", valueToken, context2]
-            ]);
-        }
-        if (rowEnd !== void 0) {
-            previousCell.end = Object.assign({}, getPoint(context2.events, rowEnd));
-            map2.add(rowEnd, 0, [
-                ["exit", previousCell, context2]
-            ]);
-            previousCell = void 0;
+            attribute.namespace = webNamespaces[info.space];
         }
-        return previousCell;
+        return attribute;
     }
 
-    function flushTableEnd(map2, context2, index2, table2, tableBody) {
-        const exits = [];
-        const related = getPoint(context2.events, index2);
-        if (tableBody) {
-            tableBody.end = Object.assign({}, related);
-            exits.push(["exit", tableBody, context2]);
+    function all(children2, parentNode, schema) {
+        let index2 = -1;
+        const results = [];
+        if (children2) {
+            while (++index2 < children2.length) {
+                const child = one$1(children2[index2], schema);
+                child.parentNode = parentNode;
+                results.push(child);
+            }
         }
-        table2.end = Object.assign({}, related);
-        exits.push(["exit", table2, context2]);
-        map2.add(index2 + 1, 0, exits);
+        return results;
     }
 
-    function getPoint(events2, index2) {
-        const event2 = events2[index2];
-        const side = event2[0] === "enter" ? "start" : "end";
-        return event2[1][side];
+    function patch(from, to2) {
+        const position2 = from.position;
+        if (position2 && position2.start && position2.end) {
+            to2.sourceCodeLocation = {
+                startLine: position2.start.line,
+                startCol: position2.start.column,
+                startOffset: position2.start.offset,
+                endLine: position2.end.line,
+                endCol: position2.end.column,
+                endOffset: position2.end.offset
+            };
+        }
     }
-    const tasklistCheck = {
-        tokenize: tokenizeTasklistCheck
+    const htmlVoidElements = [
+        "area",
+        "base",
+        "basefont",
+        "bgsound",
+        "br",
+        "col",
+        "command",
+        "embed",
+        "frame",
+        "hr",
+        "image",
+        "img",
+        "input",
+        "isindex",
+        "keygen",
+        "link",
+        "menuitem",
+        "meta",
+        "nextid",
+        "param",
+        "source",
+        "track",
+        "wbr"
+    ];
+    const inTemplateMode = "IN_TEMPLATE_MODE";
+    const dataState = "DATA_STATE";
+    const characterToken = "CHARACTER_TOKEN";
+    const startTagToken = "START_TAG_TOKEN";
+    const endTagToken = "END_TAG_TOKEN";
+    const commentToken = "COMMENT_TOKEN";
+    const doctypeToken = "DOCTYPE_TOKEN";
+    const parseOptions = {
+        sourceCodeLocationInfo: true,
+        scriptingEnabled: false
     };
-
-    function gfmTaskListItem() {
-        return {
-            text: {
-                [91]: tasklistCheck
+    const raw = function(tree, file, options) {
+        let index2 = -1;
+        const parser2 = new parser$3(parseOptions);
+        const one2 = zwitch("type", {
+            handlers: {
+                root: root2,
+                element: element2,
+                text: text2,
+                comment: comment2,
+                doctype: doctype2,
+                raw: handleRaw
+            },
+            unknown
+        });
+        let stitches;
+        let tokenizer2;
+        let preprocessor2;
+        let posTracker;
+        let locationTracker;
+        if (isOptions(file)) {
+            options = file;
+            file = void 0;
+        }
+        if (options && options.passThrough) {
+            while (++index2 < options.passThrough.length) {
+                one2.handlers[options.passThrough[index2]] = stitch;
             }
-        };
-    }
+        }
+        const result = fromParse5(
+            documentMode(tree) ? document2() : fragment2(),
+            file
+        );
+        if (stitches) {
+            visit(result, "comment", (node2, index3, parent) => {
+                const stitch2 = node2;
+                if (stitch2.value.stitch && parent !== null && index3 !== null) {
+                    parent.children[index3] = stitch2.value.stitch;
+                    return index3;
+                }
+            });
+        }
+        if (tree.type !== "root" && result.type === "root" && result.children.length === 1) {
+            return result.children[0];
+        }
+        return result;
 
-    function tokenizeTasklistCheck(effects, ok2, nok) {
-        const self2 = this;
-        return open;
+        function fragment2() {
+            const context2 = {
+                nodeName: "template",
+                tagName: "template",
+                attrs: [],
+                namespaceURI: webNamespaces.html,
+                childNodes: []
+            };
+            const mock = {
+                nodeName: "documentmock",
+                tagName: "documentmock",
+                attrs: [],
+                namespaceURI: webNamespaces.html,
+                childNodes: []
+            };
+            const doc2 = {
+                nodeName: "#document-fragment",
+                childNodes: []
+            };
+            parser2._bootstrap(mock, context2);
+            parser2._pushTmplInsertionMode(inTemplateMode);
+            parser2._initTokenizerForFragmentParsing();
+            parser2._insertFakeRootElement();
+            parser2._resetInsertionMode();
+            parser2._findFormInFragmentContext();
+            tokenizer2 = parser2.tokenizer;
+            if (!tokenizer2)
+                throw new Error("Expected `tokenizer`");
+            preprocessor2 = tokenizer2.preprocessor;
+            locationTracker = tokenizer2.__mixins[0];
+            posTracker = locationTracker.posTracker;
+            one2(tree);
+            resetTokenizer();
+            parser2._adoptNodes(mock.childNodes[0], doc2);
+            return doc2;
+        }
 
-        function open(code2) {
-            if (self2.previous !== null || !self2._gfmTasklistFirstContentOfListItem) {
-                return nok(code2);
-            }
-            effects.enter("taskListCheck");
-            effects.enter("taskListCheckMarker");
-            effects.consume(code2);
-            effects.exit("taskListCheckMarker");
-            return inside2;
+        function document2() {
+            const doc2 = parser2.treeAdapter.createDocument();
+            parser2._bootstrap(doc2, void 0);
+            tokenizer2 = parser2.tokenizer;
+            if (!tokenizer2)
+                throw new Error("Expected `tokenizer`");
+            preprocessor2 = tokenizer2.preprocessor;
+            locationTracker = tokenizer2.__mixins[0];
+            posTracker = locationTracker.posTracker;
+            one2(tree);
+            resetTokenizer();
+            return doc2;
         }
 
-        function inside2(code2) {
-            if (markdownLineEndingOrSpace(code2)) {
-                effects.enter("taskListCheckValueUnchecked");
-                effects.consume(code2);
-                effects.exit("taskListCheckValueUnchecked");
-                return close;
+        function all2(nodes) {
+            let index3 = -1;
+            if (nodes) {
+                while (++index3 < nodes.length) {
+                    one2(nodes[index3]);
+                }
             }
-            if (code2 === 88 || code2 === 120) {
-                effects.enter("taskListCheckValueChecked");
-                effects.consume(code2);
-                effects.exit("taskListCheckValueChecked");
-                return close;
+        }
+
+        function root2(node2) {
+            all2(node2.children);
+        }
+
+        function element2(node2) {
+            resetTokenizer();
+            parser2._processInputToken(startTag(node2));
+            all2(node2.children);
+            if (!htmlVoidElements.includes(node2.tagName)) {
+                resetTokenizer();
+                parser2._processInputToken(endTag(node2));
             }
-            return nok(code2);
         }
 
-        function close(code2) {
-            if (code2 === 93) {
-                effects.enter("taskListCheckMarker");
-                effects.consume(code2);
-                effects.exit("taskListCheckMarker");
-                effects.exit("taskListCheck");
-                return after;
+        function text2(node2) {
+            resetTokenizer();
+            parser2._processInputToken({
+                type: characterToken,
+                chars: node2.value,
+                location: createParse5Location(node2)
+            });
+        }
+
+        function doctype2(node2) {
+            resetTokenizer();
+            parser2._processInputToken({
+                type: doctypeToken,
+                name: "html",
+                forceQuirks: false,
+                publicId: "",
+                systemId: "",
+                location: createParse5Location(node2)
+            });
+        }
+
+        function comment2(node2) {
+            resetTokenizer();
+            parser2._processInputToken({
+                type: commentToken,
+                data: node2.value,
+                location: createParse5Location(node2)
+            });
+        }
+
+        function handleRaw(node2) {
+            const start2 = pointStart(node2);
+            const line = start2.line || 1;
+            const column = start2.column || 1;
+            const offset2 = start2.offset || 0;
+            if (!preprocessor2)
+                throw new Error("Expected `preprocessor`");
+            if (!tokenizer2)
+                throw new Error("Expected `tokenizer`");
+            if (!posTracker)
+                throw new Error("Expected `posTracker`");
+            if (!locationTracker)
+                throw new Error("Expected `locationTracker`");
+            preprocessor2.html = void 0;
+            preprocessor2.pos = -1;
+            preprocessor2.lastGapPos = -1;
+            preprocessor2.lastCharPos = -1;
+            preprocessor2.gapStack = [];
+            preprocessor2.skipNextNewLine = false;
+            preprocessor2.lastChunkWritten = false;
+            preprocessor2.endOfChunkHit = false;
+            posTracker.isEol = false;
+            posTracker.lineStartPos = -column + 1;
+            posTracker.droppedBufferSize = offset2;
+            posTracker.offset = 0;
+            posTracker.col = 1;
+            posTracker.line = line;
+            locationTracker.currentAttrLocation = void 0;
+            locationTracker.ctLoc = createParse5Location(node2);
+            tokenizer2.write(node2.value);
+            parser2._runParsingLoop(null);
+            if (tokenizer2.state === "NAMED_CHARACTER_REFERENCE_STATE" || tokenizer2.state === "NUMERIC_CHARACTER_REFERENCE_END_STATE") {
+                preprocessor2.lastChunkWritten = true;
+                tokenizer2[tokenizer2.state](tokenizer2._consume());
             }
-            return nok(code2);
         }
 
-        function after(code2) {
-            if (markdownLineEnding(code2)) {
-                return ok2(code2);
+        function stitch(node2) {
+            stitches = true;
+            let clone2;
+            if ("children" in node2) {
+                clone2 = {
+                    ...node2,
+                    children: raw({
+                            type: "root",
+                            children: node2.children
+                        },
+                        file,
+                        options
+                    ).children
+                };
+            } else {
+                clone2 = {
+                    ...node2
+                };
             }
-            if (markdownSpace(code2)) {
-                return effects.check({
-                        tokenize: spaceThenNonSpace
-                    },
-                    ok2,
-                    nok
-                )(code2);
+            comment2({
+                type: "comment",
+                value: {
+                    stitch: clone2
+                }
+            });
+        }
+
+        function resetTokenizer() {
+            if (!tokenizer2)
+                throw new Error("Expected `tokenizer`");
+            if (!posTracker)
+                throw new Error("Expected `posTracker`");
+            const token = tokenizer2.currentCharacterToken;
+            if (token) {
+                token.location.endLine = posTracker.line;
+                token.location.endCol = posTracker.col + 1;
+                token.location.endOffset = posTracker.offset + 1;
+                parser2._processInputToken(token);
             }
-            return nok(code2);
+            tokenizer2.tokenQueue = [];
+            tokenizer2.state = dataState;
+            tokenizer2.returnState = "";
+            tokenizer2.charRefCode = -1;
+            tokenizer2.tempBuff = [];
+            tokenizer2.lastStartTagName = "";
+            tokenizer2.consumedAfterSnapshot = -1;
+            tokenizer2.active = false;
+            tokenizer2.currentCharacterToken = void 0;
+            tokenizer2.currentToken = void 0;
+            tokenizer2.currentAttr = void 0;
         }
+    };
+
+    function startTag(node2) {
+        const location2 = Object.assign(createParse5Location(node2));
+        location2.startTag = Object.assign({}, location2);
+        return {
+            type: startTagToken,
+            tagName: node2.tagName,
+            selfClosing: false,
+            attrs: attributes(node2),
+            location: location2
+        };
     }
 
-    function spaceThenNonSpace(effects, ok2, nok) {
-        return factorySpace(effects, after, "whitespace");
+    function attributes(node2) {
+        return toParse5({
+            tagName: node2.tagName,
+            type: "element",
+            properties: node2.properties,
+            children: []
+        }).attrs;
+    }
 
-        function after(code2) {
-            return code2 === null ? nok(code2) : ok2(code2);
-        }
+    function endTag(node2) {
+        const location2 = Object.assign(createParse5Location(node2));
+        location2.startTag = Object.assign({}, location2);
+        return {
+            type: endTagToken,
+            tagName: node2.tagName,
+            attrs: [],
+            location: location2
+        };
     }
 
-    function gfm(options) {
-        return combineExtensions([
-            gfmAutolinkLiteral(),
-            gfmFootnote(),
-            gfmStrikethrough(options),
-            gfmTable(),
-            gfmTaskListItem()
-        ]);
+    function unknown(node2) {
+        throw new Error("Cannot compile `" + node2.type + "` node");
     }
-    const emptyOptions = {};
 
-    function remarkGfm(options) {
-        const self2 = this;
-        const settings2 = options || emptyOptions;
-        const data2 = self2.data();
-        const micromarkExtensions = data2.micromarkExtensions || (data2.micromarkExtensions = []);
-        const fromMarkdownExtensions = data2.fromMarkdownExtensions || (data2.fromMarkdownExtensions = []);
-        const toMarkdownExtensions = data2.toMarkdownExtensions || (data2.toMarkdownExtensions = []);
-        micromarkExtensions.push(gfm(settings2));
-        fromMarkdownExtensions.push(gfmFromMarkdown());
-        toMarkdownExtensions.push(gfmToMarkdown(settings2));
+    function documentMode(node2) {
+        const head = node2.type === "root" ? node2.children[0] : node2;
+        return Boolean(
+            head && (head.type === "doctype" || head.type === "element" && head.tagName === "html")
+        );
+    }
+
+    function createParse5Location(node2) {
+        const start2 = pointStart(node2);
+        const end2 = pointEnd(node2);
+        return {
+            startLine: start2.line,
+            startCol: start2.column,
+            startOffset: start2.offset,
+            endLine: end2.line,
+            endCol: end2.column,
+            endOffset: end2.offset
+        };
+    }
+
+    function isOptions(value) {
+        return Boolean(value && !("message" in value && "messages" in value));
+    }
+
+    function rehypeRaw(options = {}) {
+        return (tree, file) => {
+            const result = raw(tree, file, options);
+            return result;
+        };
     }
     const _CustomMarkdown = styled__default.default.div`
     /*
      * Apply some base styles to the markdown content so it looks good by default
      * Inspired by https://tailwindcss.com/docs/typography-plugin
     */
     p {
@@ -72092,15 +72518,15 @@
         if (props.html_raw) {
             rehypePlugins.push(rehypeRaw);
         }
         return /* @__PURE__ */ React__default.default.createElement(CustomMarkdown, {
             $rawCss: css2,
             className: props.className,
             style: style2
-        }, /* @__PURE__ */ React__default.default.createElement(Markdown$1, {
+        }, /* @__PURE__ */ React__default.default.createElement(Markdown$2, {
             rehypePlugins,
             remarkPlugins: [remarkGfm]
         }, markdown));
     }
     const StyledModal = core$2.injectCss(Modal$1);
 
     function Modal(props) {
@@ -301513,15 +301939,15 @@
                         exports4.enabled = enabled;
                         exports4.humanize = __webpack_require__2(11375);
                         exports4.names = [];
                         exports4.skips = [];
                         exports4.formatters = {};
                         var prevTime;
 
-                        function selectColor(namespace2) {
+                        function selectColor2(namespace2) {
                             var hash2 = 0,
                                 i2;
                             for (i2 in namespace2) {
                                 hash2 = (hash2 << 5) - hash2 + namespace2.charCodeAt(i2);
                                 hash2 |= 0;
                             }
                             return exports4.colors[Math.abs(hash2) % exports4.colors.length];
@@ -301563,15 +301989,15 @@
                                 exports4.formatArgs.call(self2, args);
                                 var logFn = debug.log || exports4.log || console.log.bind(console);
                                 logFn.apply(self2, args);
                             }
                             debug.namespace = namespace2;
                             debug.enabled = exports4.enabled(namespace2);
                             debug.useColors = exports4.useColors();
-                            debug.color = selectColor(namespace2);
+                            debug.color = selectColor2(namespace2);
                             if ("function" === typeof exports4.init) {
                                 exports4.init(debug);
                             }
                             return debug;
                         }
 
                         function enable(namespaces2) {
@@ -320242,14 +320668,18 @@
         for (var index2 = 0;; index2++) {
             node2 = node2.previousSibling;
             if (!node2)
                 return index2;
         }
     }
 
+    function isBlockElement(node2) {
+        return node2.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node2.nodeName);
+    }
+
     function scanFor(node2, off, targetNode, targetOff, dir) {
         for (;;) {
             if (node2 == targetNode && off == targetOff)
                 return true;
             if (off == (dir < 0 ? 0 : maxOffset(node2))) {
                 if (node2.nodeName == "DIV")
                     return false;
@@ -320560,14 +320990,56 @@
             }
         }
     }
 
     function isScrolledToBottom(elt) {
         return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
     }
+
+    function textNodeBefore(startNode, startOffset) {
+        for (let node2 = startNode, offset2 = startOffset;;) {
+            if (node2.nodeType == 3 && offset2 > 0) {
+                return {
+                    node: node2,
+                    offset: offset2
+                };
+            } else if (node2.nodeType == 1 && offset2 > 0) {
+                if (node2.contentEditable == "false")
+                    return null;
+                node2 = node2.childNodes[offset2 - 1];
+                offset2 = maxOffset(node2);
+            } else if (node2.parentNode && !isBlockElement(node2)) {
+                offset2 = domIndex(node2);
+                node2 = node2.parentNode;
+            } else {
+                return null;
+            }
+        }
+    }
+
+    function textNodeAfter(startNode, startOffset) {
+        for (let node2 = startNode, offset2 = startOffset;;) {
+            if (node2.nodeType == 3 && offset2 < node2.nodeValue.length) {
+                return {
+                    node: node2,
+                    offset: offset2
+                };
+            } else if (node2.nodeType == 1 && offset2 < node2.childNodes.length) {
+                if (node2.contentEditable == "false")
+                    return null;
+                node2 = node2.childNodes[offset2];
+                offset2 = 0;
+            } else if (node2.parentNode && !isBlockElement(node2)) {
+                offset2 = domIndex(node2) + 1;
+                node2 = node2.parentNode;
+            } else {
+                return null;
+            }
+        }
+    }
     class DOMPos {
         constructor(node2, offset2, precise = true) {
             this.node = node2;
             this.offset = offset2;
             this.precise = precise;
         }
         static before(dom2, precise) {
@@ -322670,19 +323142,19 @@
         get length() {
             return this.view.state.doc.length;
         }
         constructor(view) {
             super();
             this.view = view;
             this.decorations = [];
-            this.dynamicDecorationMap = [false];
+            this.dynamicDecorationMap = [];
             this.domChanged = null;
             this.hasComposition = null;
             this.markedForComposition = /* @__PURE__ */ new Set();
-            this.compositionBarrier = Decoration.none;
+            this.lastCompositionAfterCursor = false;
             this.minWidth = 0;
             this.minWidthFrom = 0;
             this.minWidthTo = 0;
             this.impreciseAnchor = null;
             this.impreciseHead = null;
             this.forceSelection = false;
             this.lastUpdate = Date.now();
@@ -322882,15 +323354,15 @@
                     let rawSel = getSelection(this.view.root);
                     if (!rawSel)
                     ;
                     else if (main2.empty) {
                         if (browser.gecko) {
                             let nextTo = nextToUneditable(anchor.node, anchor.offset);
                             if (nextTo && nextTo != (1 | 2)) {
-                                let text2 = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);
+                                let text2 = (nextTo == 1 ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
                                 if (text2)
                                     anchor = new DOMPos(text2.node, text2.offset);
                             }
                         }
                         rawSel.collapse(anchor.node, anchor.offset);
                         if (main2.bidiLevel != null && rawSel.caretBidiLevel !== void 0)
                             rawSel.caretBidiLevel = main2.bidiLevel;
@@ -322916,15 +323388,15 @@
                 });
                 this.view.observer.setSelectionRange(anchor, head);
             }
             this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
             this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
         }
         suppressWidgetCursorChange(sel, cursor) {
-            return this.hasComposition && cursor.empty && !this.compositionBarrier.size && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor.head;
+            return this.hasComposition && cursor.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor.head;
         }
         enforceCursorAssoc() {
             if (this.hasComposition)
                 return;
             let {
                 view
             } = this, cursor = view.state.selection.main;
@@ -323144,15 +323616,15 @@
                 if (!next2)
                     break;
                 pos = next2.to + 1;
             }
             return Decoration.set(deco);
         }
         updateDeco() {
-            let i2 = 1;
+            let i2 = 0;
             let allDeco = this.view.state.facet(decorations).map((d2) => {
                 let dynamic = this.dynamicDecorationMap[i2++] = typeof d2 == "function";
                 return dynamic ? d2(this.view) : d2;
             });
             let dynamicOuter = false,
                 outerDeco = this.view.state.facet(outerDecorations).map((d2, i3) => {
                     let dynamic = typeof d2 == "function";
@@ -323161,49 +323633,22 @@
                     return dynamic ? d2(this.view) : d2;
                 });
             if (outerDeco.length) {
                 this.dynamicDecorationMap[i2++] = dynamicOuter;
                 allDeco.push(RangeSet.join(outerDeco));
             }
             this.decorations = [
-                this.compositionBarrier,
                 ...allDeco,
                 this.computeBlockGapDeco(),
                 this.view.viewState.lineGapDeco
             ];
             while (i2 < this.decorations.length)
                 this.dynamicDecorationMap[i2++] = false;
             return this.decorations;
         }
-        maybeCreateCompositionBarrier() {
-            let {
-                main: {
-                    head,
-                    empty: empty2
-                }
-            } = this.view.state.selection;
-            if (!empty2)
-                return false;
-            let found = null;
-            for (let set2 of this.decorations) {
-                set2.between(head, head, (from, to2, value) => {
-                    if (value.point)
-                        found = false;
-                    else if (value.endSide < 0 && from < head && to2 == head)
-                        found = true;
-                });
-                if (found === false)
-                    break;
-            }
-            this.compositionBarrier = found ? Decoration.set(compositionBarrierWidget.range(head)) : Decoration.none;
-            return !!found;
-        }
-        clearCompositionBarrier() {
-            this.compositionBarrier = Decoration.none;
-        }
         scrollIntoView(target) {
             if (target.isSnapshot) {
                 let ref2 = this.view.viewState.lineBlockAt(target.range.head);
                 this.view.scrollDOM.scrollTop = ref2.top - target.yMargin;
                 this.view.scrollDOM.scrollLeft = target.xMargin;
                 return;
             }
@@ -323239,18 +323684,14 @@
             let {
                 offsetWidth,
                 offsetHeight
             } = this.view.scrollDOM;
             scrollRectIntoView(this.view.scrollDOM, targetRect, range2.head < range2.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
         }
     }
-    const compositionBarrierWidget = /* @__PURE__ */ Decoration.widget({
-        side: -1,
-        widget: NullWidget.inline
-    });
 
     function betweenUneditable(pos) {
         return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
     }
     class BlockGapWidget extends WidgetType {
         constructor(height) {
             super();
@@ -323278,15 +323719,30 @@
         ignoreEvent() {
             return false;
         }
     }
 
     function findCompositionNode(view, headPos) {
         let sel = view.observer.selectionRange;
-        let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
+        if (!sel.focusNode)
+            return null;
+        let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
+        let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
+        let textNode = textBefore || textAfter;
+        if (textAfter && textBefore && textAfter.node != textBefore.node) {
+            let descAfter = ContentView.get(textAfter.node);
+            if (!descAfter || descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue) {
+                textNode = textAfter;
+            } else if (view.docView.lastCompositionAfterCursor) {
+                let descBefore = ContentView.get(textBefore.node);
+                if (!(!descBefore || descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue))
+                    textNode = textAfter;
+            }
+        }
+        view.docView.lastCompositionAfterCursor = textNode != textBefore;
         if (!textNode)
             return null;
         let from = headPos - textNode.offset;
         return {
             from,
             to: from + textNode.node.nodeValue.length,
             node: textNode.node
@@ -323333,46 +323789,14 @@
                     })
                 });
             else
                 return null;
         }
     }
 
-    function nearbyTextNode(startNode, startOffset, side) {
-        if (side <= 0)
-            for (let node2 = startNode, offset2 = startOffset;;) {
-                if (node2.nodeType == 3)
-                    return {
-                        node: node2,
-                        offset: offset2
-                    };
-                if (node2.nodeType == 1 && offset2 > 0) {
-                    node2 = node2.childNodes[offset2 - 1];
-                    offset2 = maxOffset(node2);
-                } else {
-                    break;
-                }
-            }
-        if (side >= 0)
-            for (let node2 = startNode, offset2 = startOffset;;) {
-                if (node2.nodeType == 3)
-                    return {
-                        node: node2,
-                        offset: offset2
-                    };
-                if (node2.nodeType == 1 && offset2 < node2.childNodes.length && side >= 0) {
-                    node2 = node2.childNodes[offset2];
-                    offset2 = 0;
-                } else {
-                    break;
-                }
-            }
-        return null;
-    }
-
     function nextToUneditable(node2, offset2) {
         if (node2.nodeType != 1)
             return 0;
         return (offset2 && node2.childNodes[offset2 - 1].contentEditable == "false" ? 1 : 0) | (offset2 < node2.childNodes.length && node2.childNodes[offset2].contentEditable == "false" ? 2 : 0);
     }
     let DecorationComparator$1 = class DecorationComparator {
         constructor() {
@@ -324620,18 +325044,14 @@
         updateForFocusChange(view);
     };
     observers.compositionstart = observers.compositionupdate = (view) => {
         if (view.inputState.compositionFirstChange == null)
             view.inputState.compositionFirstChange = true;
         if (view.inputState.composing < 0) {
             view.inputState.composing = 0;
-            if (view.docView.maybeCreateCompositionBarrier()) {
-                view.update([]);
-                view.docView.clearCompositionBarrier();
-            }
         }
     };
     observers.compositionend = (view) => {
         view.inputState.composing = -1;
         view.inputState.compositionEndedAt = Date.now();
         view.inputState.compositionPendingKey = true;
         view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
@@ -324665,14 +325085,17 @@
                     }
                 }, 100);
             }
         }
         if (browser.ios && event2.inputType == "deleteContentForward") {
             view.observer.flushSoon();
         }
+        if (browser.safari && event2.inputType == "insertText" && view.inputState.composing >= 0) {
+            setTimeout(() => observers.compositionend(view, event2), 20);
+        }
         return false;
     };
     const appliedFirefoxHack = /* @__PURE__ */ new Set();
 
     function firefoxCopyCutHack(doc2) {
         if (!appliedFirefoxHack.has(doc2)) {
             appliedFirefoxHack.add(doc2);
@@ -324988,15 +325411,15 @@
             let {
                 firstLine,
                 lastLine,
                 perLine,
                 perChar
             } = this.heightMetrics(oracle, offset2);
             if (oracle.lineWrapping) {
-                let guess = offset2 + Math.round(Math.max(0, Math.min(1, (height - top2) / this.height)) * this.length);
+                let guess = offset2 + (height < oracle.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (height - top2) / this.height)) * this.length));
                 let line = oracle.doc.lineAt(guess),
                     lineHeight = perLine + line.length * perChar;
                 let lineTop = Math.max(top2, height - lineHeight / 2);
                 return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
             } else {
                 let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / perLine)));
                 let {
@@ -325479,15 +325902,15 @@
             this.paddingTop = 0;
             this.paddingBottom = 0;
             this.contentDOMWidth = 0;
             this.contentDOMHeight = 0;
             this.editorHeight = 0;
             this.editorWidth = 0;
             this.scrollTop = 0;
-            this.scrolledToBottom = true;
+            this.scrolledToBottom = false;
             this.scaleX = 1;
             this.scaleY = 1;
             this.scrollAnchorPos = 0;
             this.scrollAnchorHeight = -1;
             this.scaler = IdScaler;
             this.scrollTarget = null;
             this.printing = false;
@@ -326404,18 +326827,14 @@
                 return false;
             if (node2 == parent)
                 return true;
             offset2 = domIndex(node2) + 1;
             node2 = node2.parentNode;
         }
     }
-
-    function isBlockElement(node2) {
-        return node2.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node2.nodeName);
-    }
     class DOMPoint {
         constructor(node2, offset2) {
             this.node = node2;
             this.offset = offset2;
             this.pos = -1;
         }
     }
@@ -326816,15 +327235,18 @@
             else
                 this.flush(false);
         }
         readSelectionRange() {
             let {
                 view
             } = this;
-            let range2 = browser.safari && view.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view) || getSelection(view.root);
+            let selection2 = getSelection(view.root);
+            if (!selection2)
+                return false;
+            let range2 = browser.safari && view.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view, selection2) || selection2;
             if (!range2 || this.selectionRange.eq(range2))
                 return false;
             let local = hasSelection(this.dom, range2);
             if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range2)) {
                 this.view.inputState.lastFocusTime = 0;
                 view.docView.updateSelection();
                 return false;
@@ -327085,40 +327507,47 @@
                 return curView;
             let parent = dom2.parentNode;
             dom2 = parent != cView.dom ? parent : dir > 0 ? dom2.nextSibling : dom2.previousSibling;
         }
         return null;
     }
 
-    function safariSelectionRangeHack(view) {
+    function buildSelectionRangeFromRange(view, range2) {
+        let anchorNode = range2.startContainer,
+            anchorOffset = range2.startOffset;
+        let focusNode = range2.endContainer,
+            focusOffset = range2.endOffset;
+        let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
+        if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
+            [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
+        return {
+            anchorNode,
+            anchorOffset,
+            focusNode,
+            focusOffset
+        };
+    }
+
+    function safariSelectionRangeHack(view, selection2) {
+        if (selection2.getComposedRanges) {
+            let range2 = selection2.getComposedRanges(view.root)[0];
+            if (range2)
+                return buildSelectionRangeFromRange(view, range2);
+        }
         let found = null;
 
         function read2(event2) {
             event2.preventDefault();
             event2.stopImmediatePropagation();
             found = event2.getTargetRanges()[0];
         }
         view.contentDOM.addEventListener("beforeinput", read2, true);
         view.dom.ownerDocument.execCommand("indent");
         view.contentDOM.removeEventListener("beforeinput", read2, true);
-        if (!found)
-            return null;
-        let anchorNode = found.startContainer,
-            anchorOffset = found.startOffset;
-        let focusNode = found.endContainer,
-            focusOffset = found.endOffset;
-        let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
-        if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
-            [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
-        return {
-            anchorNode,
-            anchorOffset,
-            focusNode,
-            focusOffset
-        };
+        return found ? buildSelectionRangeFromRange(view, found) : null;
     }
     class EditorView {
         get state() {
             return this.viewState.state;
         }
         get viewport() {
             return this.viewState.viewport;
@@ -336232,14 +336661,15 @@
                 /* @__PURE__ */
                 indentNodeProp.add({
                     Body: (context2) => {
                         var _a3;
                         return (_a3 = indentBody(context2, context2.node)) !== null && _a3 !== void 0 ? _a3 : context2.continue();
                     },
                     IfStatement: (cx) => /^\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
+                    "ForStatement WhileStatement": (cx) => /^\s*else:/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
                     TryStatement: (cx) => /^\s*(except |finally:|else:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
                     "TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": /* @__PURE__ */ delimitedIndent({
                         closing: ")"
                     }),
                     "DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": /* @__PURE__ */ delimitedIndent({
                         closing: "}"
                     }),
@@ -337583,27 +338013,84 @@
 
     :active {
         background-color: ${(props) => props.theme.colors.primaryDown};
     }
 `;
     const StyledChat = core$2.injectCss(Chat$1);
 
+    function parseUserData(user) {
+        return {
+            id: user == null ? void 0 : user.identity_id,
+            name: user.identity_name,
+            email: user == null ? void 0 : user.identity_email
+        };
+    }
+
+    function getAllUsersInChat(chat) {
+        const userMap = /* @__PURE__ */ new Map();
+        chat.forEach((message) => {
+            const {
+                email
+            } = message.user;
+            if (email && !userMap.has(email)) {
+                userMap.set(email, message.user);
+            }
+        });
+        return Array.from(userMap.values());
+    }
+    const anonymousUser = {
+        identity_name: "Anonymous"
+    };
+    async function sendNewMessage(payload, extras) {
+        try {
+            const res = await core$2.request(
+                "/api/chat/messages", {
+                    body: JSON.stringify(payload),
+                    method: HTTP_METHOD.POST
+                },
+                extras
+            );
+            await core$2.handleAuthErrors(res, true);
+            await validateResponse(res, "Failed to send message notification");
+        } catch (error2) {
+            console.error("Failed to send message notification:", error2);
+        }
+    }
+
     function Chat(props) {
+        var _a3;
         const [style2, css2] = core$2.useComponentStyles(props);
         const [value, setValue] = core$2.useVariable(props.value);
         const [showChat, setShowChat] = React__namespace.useState(false);
+        const user = core$2.useUser();
         const theme2 = useClTheme();
+        const extras = core$2.useRequestExtras();
+        const userData = (_a3 = user.data) != null ? _a3 : anonymousUser;
+        const onUpdate = (newValue) => {
+            if (newValue.length > value.length) {
+                const newMessage = newValue[newValue.length - 1];
+                const users = getAllUsersInChat(newValue);
+                const notificationPayload = {
+                    app_url: window.location.href,
+                    users,
+                    content: newMessage
+                };
+                sendNewMessage(notificationPayload, extras);
+            }
+            setValue(newValue);
+        };
         return /* @__PURE__ */ React__namespace.createElement(ChatWrapper, null, showChat && /* @__PURE__ */ React__namespace.createElement(
             StyledChat, {
                 $rawCss: css2,
                 className: props.className,
                 onClose: () => setShowChat(false),
-                onUpdate: setValue,
+                onUpdate,
                 style: style2,
-                value
+                value,
+                activeUser: parseUserData(userData)
             }
         ), !showChat && /* @__PURE__ */ React__namespace.createElement(ChatButton, {
             onClick: () => setShowChat(true)
         }, /* @__PURE__ */ React__namespace.createElement("svg", {
             fill: "none",
             height: "32",
             viewBox: "0 0 32 32",
@@ -338338,650 +338825,28 @@
         };
         AnonymousSubject2.prototype._subscribe = function(subscriber) {
             var _a3, _b;
             return (_b = (_a3 = this.source) === null || _a3 === void 0 ? void 0 : _a3.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
         };
         return AnonymousSubject2;
     }(Subject);
-    var PolishedError = /* @__PURE__ */ function(_Error) {
-        _inheritsLoose$2(PolishedError2, _Error);
-
-        function PolishedError2(code2) {
-            var _this;
-            {
-                _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + code2 + " for more information.") || this;
-            }
-            return _assertThisInitialized$3(_this);
-        }
-        return PolishedError2;
-    }( /* @__PURE__ */ _wrapNativeSuper$1(Error));
-
-    function colorToInt(color2) {
-        return Math.round(color2 * 255);
-    }
-
-    function convertToInt(red, green, blue) {
-        return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
-    }
-
-    function hslToRgb(hue, saturation, lightness, convert2) {
-        if (convert2 === void 0) {
-            convert2 = convertToInt;
-        }
-        if (saturation === 0) {
-            return convert2(lightness, lightness, lightness);
-        }
-        var huePrime = (hue % 360 + 360) % 360 / 60;
-        var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
-        var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
-        var red = 0;
-        var green = 0;
-        var blue = 0;
-        if (huePrime >= 0 && huePrime < 1) {
-            red = chroma;
-            green = secondComponent;
-        } else if (huePrime >= 1 && huePrime < 2) {
-            red = secondComponent;
-            green = chroma;
-        } else if (huePrime >= 2 && huePrime < 3) {
-            green = chroma;
-            blue = secondComponent;
-        } else if (huePrime >= 3 && huePrime < 4) {
-            green = secondComponent;
-            blue = chroma;
-        } else if (huePrime >= 4 && huePrime < 5) {
-            red = secondComponent;
-            blue = chroma;
-        } else if (huePrime >= 5 && huePrime < 6) {
-            red = chroma;
-            blue = secondComponent;
-        }
-        var lightnessModification = lightness - chroma / 2;
-        var finalRed = red + lightnessModification;
-        var finalGreen = green + lightnessModification;
-        var finalBlue = blue + lightnessModification;
-        return convert2(finalRed, finalGreen, finalBlue);
-    }
-    var namedColorMap = {
-        aliceblue: "f0f8ff",
-        antiquewhite: "faebd7",
-        aqua: "00ffff",
-        aquamarine: "7fffd4",
-        azure: "f0ffff",
-        beige: "f5f5dc",
-        bisque: "ffe4c4",
-        black: "000",
-        blanchedalmond: "ffebcd",
-        blue: "0000ff",
-        blueviolet: "8a2be2",
-        brown: "a52a2a",
-        burlywood: "deb887",
-        cadetblue: "5f9ea0",
-        chartreuse: "7fff00",
-        chocolate: "d2691e",
-        coral: "ff7f50",
-        cornflowerblue: "6495ed",
-        cornsilk: "fff8dc",
-        crimson: "dc143c",
-        cyan: "00ffff",
-        darkblue: "00008b",
-        darkcyan: "008b8b",
-        darkgoldenrod: "b8860b",
-        darkgray: "a9a9a9",
-        darkgreen: "006400",
-        darkgrey: "a9a9a9",
-        darkkhaki: "bdb76b",
-        darkmagenta: "8b008b",
-        darkolivegreen: "556b2f",
-        darkorange: "ff8c00",
-        darkorchid: "9932cc",
-        darkred: "8b0000",
-        darksalmon: "e9967a",
-        darkseagreen: "8fbc8f",
-        darkslateblue: "483d8b",
-        darkslategray: "2f4f4f",
-        darkslategrey: "2f4f4f",
-        darkturquoise: "00ced1",
-        darkviolet: "9400d3",
-        deeppink: "ff1493",
-        deepskyblue: "00bfff",
-        dimgray: "696969",
-        dimgrey: "696969",
-        dodgerblue: "1e90ff",
-        firebrick: "b22222",
-        floralwhite: "fffaf0",
-        forestgreen: "228b22",
-        fuchsia: "ff00ff",
-        gainsboro: "dcdcdc",
-        ghostwhite: "f8f8ff",
-        gold: "ffd700",
-        goldenrod: "daa520",
-        gray: "808080",
-        green: "008000",
-        greenyellow: "adff2f",
-        grey: "808080",
-        honeydew: "f0fff0",
-        hotpink: "ff69b4",
-        indianred: "cd5c5c",
-        indigo: "4b0082",
-        ivory: "fffff0",
-        khaki: "f0e68c",
-        lavender: "e6e6fa",
-        lavenderblush: "fff0f5",
-        lawngreen: "7cfc00",
-        lemonchiffon: "fffacd",
-        lightblue: "add8e6",
-        lightcoral: "f08080",
-        lightcyan: "e0ffff",
-        lightgoldenrodyellow: "fafad2",
-        lightgray: "d3d3d3",
-        lightgreen: "90ee90",
-        lightgrey: "d3d3d3",
-        lightpink: "ffb6c1",
-        lightsalmon: "ffa07a",
-        lightseagreen: "20b2aa",
-        lightskyblue: "87cefa",
-        lightslategray: "789",
-        lightslategrey: "789",
-        lightsteelblue: "b0c4de",
-        lightyellow: "ffffe0",
-        lime: "0f0",
-        limegreen: "32cd32",
-        linen: "faf0e6",
-        magenta: "f0f",
-        maroon: "800000",
-        mediumaquamarine: "66cdaa",
-        mediumblue: "0000cd",
-        mediumorchid: "ba55d3",
-        mediumpurple: "9370db",
-        mediumseagreen: "3cb371",
-        mediumslateblue: "7b68ee",
-        mediumspringgreen: "00fa9a",
-        mediumturquoise: "48d1cc",
-        mediumvioletred: "c71585",
-        midnightblue: "191970",
-        mintcream: "f5fffa",
-        mistyrose: "ffe4e1",
-        moccasin: "ffe4b5",
-        navajowhite: "ffdead",
-        navy: "000080",
-        oldlace: "fdf5e6",
-        olive: "808000",
-        olivedrab: "6b8e23",
-        orange: "ffa500",
-        orangered: "ff4500",
-        orchid: "da70d6",
-        palegoldenrod: "eee8aa",
-        palegreen: "98fb98",
-        paleturquoise: "afeeee",
-        palevioletred: "db7093",
-        papayawhip: "ffefd5",
-        peachpuff: "ffdab9",
-        peru: "cd853f",
-        pink: "ffc0cb",
-        plum: "dda0dd",
-        powderblue: "b0e0e6",
-        purple: "800080",
-        rebeccapurple: "639",
-        red: "f00",
-        rosybrown: "bc8f8f",
-        royalblue: "4169e1",
-        saddlebrown: "8b4513",
-        salmon: "fa8072",
-        sandybrown: "f4a460",
-        seagreen: "2e8b57",
-        seashell: "fff5ee",
-        sienna: "a0522d",
-        silver: "c0c0c0",
-        skyblue: "87ceeb",
-        slateblue: "6a5acd",
-        slategray: "708090",
-        slategrey: "708090",
-        snow: "fffafa",
-        springgreen: "00ff7f",
-        steelblue: "4682b4",
-        tan: "d2b48c",
-        teal: "008080",
-        thistle: "d8bfd8",
-        tomato: "ff6347",
-        turquoise: "40e0d0",
-        violet: "ee82ee",
-        wheat: "f5deb3",
-        white: "fff",
-        whitesmoke: "f5f5f5",
-        yellow: "ff0",
-        yellowgreen: "9acd32"
-    };
-
-    function nameToHex(color2) {
-        if (typeof color2 !== "string")
-            return color2;
-        var normalizedColorName = color2.toLowerCase();
-        return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color2;
-    }
-    var hexRegex = /^#[a-fA-F0-9]{6}$/;
-    var hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;
-    var reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
-    var reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;
-    var rgbRegex = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i;
-    var rgbaRegex = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
-    var hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
-    var hslaRegex = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
-
-    function parseToRgb(color2) {
-        if (typeof color2 !== "string") {
-            throw new PolishedError(3);
-        }
-        var normalizedColor = nameToHex(color2);
-        if (normalizedColor.match(hexRegex)) {
-            return {
-                red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
-                green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
-                blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
-            };
-        }
-        if (normalizedColor.match(hexRgbaRegex)) {
-            var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
-            return {
-                red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
-                green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
-                blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
-                alpha
-            };
-        }
-        if (normalizedColor.match(reducedHexRegex)) {
-            return {
-                red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
-                green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
-                blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
-            };
-        }
-        if (normalizedColor.match(reducedRgbaHexRegex)) {
-            var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));
-            return {
-                red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
-                green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
-                blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
-                alpha: _alpha
-            };
-        }
-        var rgbMatched = rgbRegex.exec(normalizedColor);
-        if (rgbMatched) {
-            return {
-                red: parseInt("" + rgbMatched[1], 10),
-                green: parseInt("" + rgbMatched[2], 10),
-                blue: parseInt("" + rgbMatched[3], 10)
-            };
-        }
-        var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));
-        if (rgbaMatched) {
-            return {
-                red: parseInt("" + rgbaMatched[1], 10),
-                green: parseInt("" + rgbaMatched[2], 10),
-                blue: parseInt("" + rgbaMatched[3], 10),
-                alpha: parseFloat("" + rgbaMatched[4]) > 1 ? parseFloat("" + rgbaMatched[4]) / 100 : parseFloat("" + rgbaMatched[4])
-            };
-        }
-        var hslMatched = hslRegex.exec(normalizedColor);
-        if (hslMatched) {
-            var hue = parseInt("" + hslMatched[1], 10);
-            var saturation = parseInt("" + hslMatched[2], 10) / 100;
-            var lightness = parseInt("" + hslMatched[3], 10) / 100;
-            var rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")";
-            var hslRgbMatched = rgbRegex.exec(rgbColorString);
-            if (!hslRgbMatched) {
-                throw new PolishedError(4, normalizedColor, rgbColorString);
-            }
-            return {
-                red: parseInt("" + hslRgbMatched[1], 10),
-                green: parseInt("" + hslRgbMatched[2], 10),
-                blue: parseInt("" + hslRgbMatched[3], 10)
-            };
-        }
-        var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));
-        if (hslaMatched) {
-            var _hue = parseInt("" + hslaMatched[1], 10);
-            var _saturation = parseInt("" + hslaMatched[2], 10) / 100;
-            var _lightness = parseInt("" + hslaMatched[3], 10) / 100;
-            var _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")";
-            var _hslRgbMatched = rgbRegex.exec(_rgbColorString);
-            if (!_hslRgbMatched) {
-                throw new PolishedError(4, normalizedColor, _rgbColorString);
-            }
-            return {
-                red: parseInt("" + _hslRgbMatched[1], 10),
-                green: parseInt("" + _hslRgbMatched[2], 10),
-                blue: parseInt("" + _hslRgbMatched[3], 10),
-                alpha: parseFloat("" + hslaMatched[4]) > 1 ? parseFloat("" + hslaMatched[4]) / 100 : parseFloat("" + hslaMatched[4])
-            };
-        }
-        throw new PolishedError(5);
-    }
-
-    function rgbToHsl(color2) {
-        var red = color2.red / 255;
-        var green = color2.green / 255;
-        var blue = color2.blue / 255;
-        var max2 = Math.max(red, green, blue);
-        var min2 = Math.min(red, green, blue);
-        var lightness = (max2 + min2) / 2;
-        if (max2 === min2) {
-            if (color2.alpha !== void 0) {
-                return {
-                    hue: 0,
-                    saturation: 0,
-                    lightness,
-                    alpha: color2.alpha
-                };
-            } else {
-                return {
-                    hue: 0,
-                    saturation: 0,
-                    lightness
-                };
-            }
-        }
-        var hue;
-        var delta = max2 - min2;
-        var saturation = lightness > 0.5 ? delta / (2 - max2 - min2) : delta / (max2 + min2);
-        switch (max2) {
-            case red:
-                hue = (green - blue) / delta + (green < blue ? 6 : 0);
-                break;
-            case green:
-                hue = (blue - red) / delta + 2;
-                break;
-            default:
-                hue = (red - green) / delta + 4;
-                break;
-        }
-        hue *= 60;
-        if (color2.alpha !== void 0) {
-            return {
-                hue,
-                saturation,
-                lightness,
-                alpha: color2.alpha
-            };
-        }
-        return {
-            hue,
-            saturation,
-            lightness
-        };
-    }
-
-    function parseToHsl(color2) {
-        return rgbToHsl(parseToRgb(color2));
-    }
-    var reduceHexValue = function reduceHexValue2(value) {
-        if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
-            return "#" + value[1] + value[3] + value[5];
-        }
-        return value;
-    };
-    var reduceHexValue$1 = reduceHexValue;
-
-    function numberToHex(value) {
-        var hex2 = value.toString(16);
-        return hex2.length === 1 ? "0" + hex2 : hex2;
-    }
-
-    function colorToHex(color2) {
-        return numberToHex(Math.round(color2 * 255));
-    }
-
-    function convertToHex(red, green, blue) {
-        return reduceHexValue$1("#" + colorToHex(red) + colorToHex(green) + colorToHex(blue));
-    }
-
-    function hslToHex(hue, saturation, lightness) {
-        return hslToRgb(hue, saturation, lightness, convertToHex);
-    }
-
-    function hsl(value, saturation, lightness) {
-        if (typeof value === "number" && typeof saturation === "number" && typeof lightness === "number") {
-            return hslToHex(value, saturation, lightness);
-        } else if (typeof value === "object" && saturation === void 0 && lightness === void 0) {
-            return hslToHex(value.hue, value.saturation, value.lightness);
-        }
-        throw new PolishedError(1);
-    }
-
-    function hsla$1(value, saturation, lightness, alpha) {
-        if (typeof value === "number" && typeof saturation === "number" && typeof lightness === "number" && typeof alpha === "number") {
-            return alpha >= 1 ? hslToHex(value, saturation, lightness) : "rgba(" + hslToRgb(value, saturation, lightness) + "," + alpha + ")";
-        } else if (typeof value === "object" && saturation === void 0 && lightness === void 0 && alpha === void 0) {
-            return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : "rgba(" + hslToRgb(value.hue, value.saturation, value.lightness) + "," + value.alpha + ")";
-        }
-        throw new PolishedError(2);
-    }
-
-    function rgb(value, green, blue) {
-        if (typeof value === "number" && typeof green === "number" && typeof blue === "number") {
-            return reduceHexValue$1("#" + numberToHex(value) + numberToHex(green) + numberToHex(blue));
-        } else if (typeof value === "object" && green === void 0 && blue === void 0) {
-            return reduceHexValue$1("#" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));
-        }
-        throw new PolishedError(6);
-    }
-
-    function rgba$1(firstValue, secondValue, thirdValue, fourthValue) {
-        if (typeof firstValue === "string" && typeof secondValue === "number") {
-            var rgbValue = parseToRgb(firstValue);
-            return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
-        } else if (typeof firstValue === "number" && typeof secondValue === "number" && typeof thirdValue === "number" && typeof fourthValue === "number") {
-            return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
-        } else if (typeof firstValue === "object" && secondValue === void 0 && thirdValue === void 0 && fourthValue === void 0) {
-            return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
-        }
-        throw new PolishedError(7);
-    }
-    var isRgb = function isRgb2(color2) {
-        return typeof color2.red === "number" && typeof color2.green === "number" && typeof color2.blue === "number" && (typeof color2.alpha !== "number" || typeof color2.alpha === "undefined");
-    };
-    var isRgba = function isRgba2(color2) {
-        return typeof color2.red === "number" && typeof color2.green === "number" && typeof color2.blue === "number" && typeof color2.alpha === "number";
-    };
-    var isHsl = function isHsl2(color2) {
-        return typeof color2.hue === "number" && typeof color2.saturation === "number" && typeof color2.lightness === "number" && (typeof color2.alpha !== "number" || typeof color2.alpha === "undefined");
-    };
-    var isHsla = function isHsla2(color2) {
-        return typeof color2.hue === "number" && typeof color2.saturation === "number" && typeof color2.lightness === "number" && typeof color2.alpha === "number";
-    };
-
-    function toColorString(color2) {
-        if (typeof color2 !== "object")
-            throw new PolishedError(8);
-        if (isRgba(color2))
-            return rgba$1(color2);
-        if (isRgb(color2))
-            return rgb(color2);
-        if (isHsla(color2))
-            return hsla$1(color2);
-        if (isHsl(color2))
-            return hsl(color2);
-        throw new PolishedError(8);
-    }
-
-    function curried(f2, length, acc) {
-        return function fn2() {
-            var combined = acc.concat(Array.prototype.slice.call(arguments));
-            return combined.length >= length ? f2.apply(this, combined) : curried(f2, length, combined);
-        };
-    }
-
-    function curry(f2) {
-        return curried(f2, f2.length, []);
-    }
-
-    function adjustHue(degree, color2) {
-        if (color2 === "transparent")
-            return color2;
-        var hslColor = parseToHsl(color2);
-        return toColorString(_extends$3({}, hslColor, {
-            hue: hslColor.hue + parseFloat(degree)
-        }));
-    }
-    curry(adjustHue);
-
-    function guard(lowerBoundary, upperBoundary, value) {
-        return Math.max(lowerBoundary, Math.min(upperBoundary, value));
-    }
-
-    function darken(amount, color2) {
-        if (color2 === "transparent")
-            return color2;
-        var hslColor = parseToHsl(color2);
-        return toColorString(_extends$3({}, hslColor, {
-            lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))
-        }));
-    }
-    curry(darken);
-
-    function desaturate(amount, color2) {
-        if (color2 === "transparent")
-            return color2;
-        var hslColor = parseToHsl(color2);
-        return toColorString(_extends$3({}, hslColor, {
-            saturation: guard(0, 1, hslColor.saturation - parseFloat(amount))
-        }));
-    }
-    curry(desaturate);
-
-    function lighten(amount, color2) {
-        if (color2 === "transparent")
-            return color2;
-        var hslColor = parseToHsl(color2);
-        return toColorString(_extends$3({}, hslColor, {
-            lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))
-        }));
-    }
-    curry(lighten);
-
-    function mix(weight, color2, otherColor) {
-        if (color2 === "transparent")
-            return otherColor;
-        if (otherColor === "transparent")
-            return color2;
-        if (weight === 0)
-            return otherColor;
-        var parsedColor1 = parseToRgb(color2);
-        var color1 = _extends$3({}, parsedColor1, {
-            alpha: typeof parsedColor1.alpha === "number" ? parsedColor1.alpha : 1
-        });
-        var parsedColor2 = parseToRgb(otherColor);
-        var color22 = _extends$3({}, parsedColor2, {
-            alpha: typeof parsedColor2.alpha === "number" ? parsedColor2.alpha : 1
-        });
-        var alphaDelta = color1.alpha - color22.alpha;
-        var x2 = parseFloat(weight) * 2 - 1;
-        var y2 = x2 * alphaDelta === -1 ? x2 : x2 + alphaDelta;
-        var z2 = 1 + x2 * alphaDelta;
-        var weight1 = (y2 / z2 + 1) / 2;
-        var weight2 = 1 - weight1;
-        var mixedColor = {
-            red: Math.floor(color1.red * weight1 + color22.red * weight2),
-            green: Math.floor(color1.green * weight1 + color22.green * weight2),
-            blue: Math.floor(color1.blue * weight1 + color22.blue * weight2),
-            alpha: color1.alpha * parseFloat(weight) + color22.alpha * (1 - parseFloat(weight))
-        };
-        return rgba$1(mixedColor);
-    }
-    var curriedMix = curry(mix);
-    var mix$1 = curriedMix;
-
-    function opacify(amount, color2) {
-        if (color2 === "transparent")
-            return color2;
-        var parsedColor = parseToRgb(color2);
-        var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
-        var colorWithAlpha = _extends$3({}, parsedColor, {
-            alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)
-        });
-        return rgba$1(colorWithAlpha);
-    }
-    curry(opacify);
-
-    function saturate(amount, color2) {
-        if (color2 === "transparent")
-            return color2;
-        var hslColor = parseToHsl(color2);
-        return toColorString(_extends$3({}, hslColor, {
-            saturation: guard(0, 1, hslColor.saturation + parseFloat(amount))
-        }));
-    }
-    curry(saturate);
-
-    function setHue(hue, color2) {
-        if (color2 === "transparent")
-            return color2;
-        return toColorString(_extends$3({}, parseToHsl(color2), {
-            hue: parseFloat(hue)
-        }));
-    }
-    curry(setHue);
-
-    function setLightness(lightness, color2) {
-        if (color2 === "transparent")
-            return color2;
-        return toColorString(_extends$3({}, parseToHsl(color2), {
-            lightness: parseFloat(lightness)
-        }));
-    }
-    curry(setLightness);
-
-    function setSaturation(saturation, color2) {
-        if (color2 === "transparent")
-            return color2;
-        return toColorString(_extends$3({}, parseToHsl(color2), {
-            saturation: parseFloat(saturation)
-        }));
-    }
-    curry(setSaturation);
-
-    function shade(percentage, color2) {
-        if (color2 === "transparent")
-            return color2;
-        return mix$1(parseFloat(percentage), "rgb(0, 0, 0)", color2);
-    }
-    curry(shade);
-
-    function tint(percentage, color2) {
-        if (color2 === "transparent")
-            return color2;
-        return mix$1(parseFloat(percentage), "rgb(255, 255, 255)", color2);
-    }
-    curry(tint);
-
-    function transparentize(amount, color2) {
-        if (color2 === "transparent")
-            return color2;
-        var parsedColor = parseToRgb(color2);
-        var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
-        var colorWithAlpha = _extends$3({}, parsedColor, {
-            alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)
-        });
-        return rgba$1(colorWithAlpha);
-    }
-    curry(transparentize);
     const NotificationWrapper$1 = styled__default.default.div`
     pointer-events: auto;
 
     display: flex;
     align-items: center;
     justify-content: space-between;
 
     width: 22rem;
     height: ${(props) => props.hasTitle ? "5.625rem" : "4.375rem"};
     padding: 1rem;
 
     color: ${(props) => getStatusColor(props.status, props.theme.colors)};
 
-    background-color: ${(props) => mix$1(0.1, getStatusColor(props.status, props.theme.colors), props.theme.colors.background)};
+    background-color: ${(props) => mix$1$1(0.1, getStatusColor(props.status, props.theme.colors), props.theme.colors.background)};
     border: 1px solid ${(props) => getStatusColor(props.status, props.theme.colors)};
     border-radius: 0.25rem;
     box-shadow: 0 2px 4px rgb(0 0 0 / 10%);
 `;
     const Message = styled__default.default.div`
     display: flex;
     flex-direction: column;
@@ -341393,14 +341258,636 @@
     }
 
     function getLegendData(defaultLegends, editorMode, additionalLegend) {
         var _a3;
         const modeData = (_a3 = defaultLegends === null || defaultLegends === void 0 ? void 0 : defaultLegends[editorMode]) !== null && _a3 !== void 0 ? _a3 : [];
         return [...modeData, ...(additionalLegend !== null && additionalLegend !== void 0 ? additionalLegend : []).filter(Boolean)];
     }
+    var PolishedError = /* @__PURE__ */ function(_Error) {
+        _inheritsLoose$2(PolishedError2, _Error);
+
+        function PolishedError2(code2) {
+            var _this;
+            {
+                _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + code2 + " for more information.") || this;
+            }
+            return _assertThisInitialized$4(_this);
+        }
+        return PolishedError2;
+    }( /* @__PURE__ */ _wrapNativeSuper$1(Error));
+
+    function colorToInt(color2) {
+        return Math.round(color2 * 255);
+    }
+
+    function convertToInt(red, green, blue) {
+        return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
+    }
+
+    function hslToRgb(hue, saturation, lightness, convert2) {
+        if (convert2 === void 0) {
+            convert2 = convertToInt;
+        }
+        if (saturation === 0) {
+            return convert2(lightness, lightness, lightness);
+        }
+        var huePrime = (hue % 360 + 360) % 360 / 60;
+        var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
+        var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
+        var red = 0;
+        var green = 0;
+        var blue = 0;
+        if (huePrime >= 0 && huePrime < 1) {
+            red = chroma;
+            green = secondComponent;
+        } else if (huePrime >= 1 && huePrime < 2) {
+            red = secondComponent;
+            green = chroma;
+        } else if (huePrime >= 2 && huePrime < 3) {
+            green = chroma;
+            blue = secondComponent;
+        } else if (huePrime >= 3 && huePrime < 4) {
+            green = secondComponent;
+            blue = chroma;
+        } else if (huePrime >= 4 && huePrime < 5) {
+            red = secondComponent;
+            blue = chroma;
+        } else if (huePrime >= 5 && huePrime < 6) {
+            red = chroma;
+            blue = secondComponent;
+        }
+        var lightnessModification = lightness - chroma / 2;
+        var finalRed = red + lightnessModification;
+        var finalGreen = green + lightnessModification;
+        var finalBlue = blue + lightnessModification;
+        return convert2(finalRed, finalGreen, finalBlue);
+    }
+    var namedColorMap = {
+        aliceblue: "f0f8ff",
+        antiquewhite: "faebd7",
+        aqua: "00ffff",
+        aquamarine: "7fffd4",
+        azure: "f0ffff",
+        beige: "f5f5dc",
+        bisque: "ffe4c4",
+        black: "000",
+        blanchedalmond: "ffebcd",
+        blue: "0000ff",
+        blueviolet: "8a2be2",
+        brown: "a52a2a",
+        burlywood: "deb887",
+        cadetblue: "5f9ea0",
+        chartreuse: "7fff00",
+        chocolate: "d2691e",
+        coral: "ff7f50",
+        cornflowerblue: "6495ed",
+        cornsilk: "fff8dc",
+        crimson: "dc143c",
+        cyan: "00ffff",
+        darkblue: "00008b",
+        darkcyan: "008b8b",
+        darkgoldenrod: "b8860b",
+        darkgray: "a9a9a9",
+        darkgreen: "006400",
+        darkgrey: "a9a9a9",
+        darkkhaki: "bdb76b",
+        darkmagenta: "8b008b",
+        darkolivegreen: "556b2f",
+        darkorange: "ff8c00",
+        darkorchid: "9932cc",
+        darkred: "8b0000",
+        darksalmon: "e9967a",
+        darkseagreen: "8fbc8f",
+        darkslateblue: "483d8b",
+        darkslategray: "2f4f4f",
+        darkslategrey: "2f4f4f",
+        darkturquoise: "00ced1",
+        darkviolet: "9400d3",
+        deeppink: "ff1493",
+        deepskyblue: "00bfff",
+        dimgray: "696969",
+        dimgrey: "696969",
+        dodgerblue: "1e90ff",
+        firebrick: "b22222",
+        floralwhite: "fffaf0",
+        forestgreen: "228b22",
+        fuchsia: "ff00ff",
+        gainsboro: "dcdcdc",
+        ghostwhite: "f8f8ff",
+        gold: "ffd700",
+        goldenrod: "daa520",
+        gray: "808080",
+        green: "008000",
+        greenyellow: "adff2f",
+        grey: "808080",
+        honeydew: "f0fff0",
+        hotpink: "ff69b4",
+        indianred: "cd5c5c",
+        indigo: "4b0082",
+        ivory: "fffff0",
+        khaki: "f0e68c",
+        lavender: "e6e6fa",
+        lavenderblush: "fff0f5",
+        lawngreen: "7cfc00",
+        lemonchiffon: "fffacd",
+        lightblue: "add8e6",
+        lightcoral: "f08080",
+        lightcyan: "e0ffff",
+        lightgoldenrodyellow: "fafad2",
+        lightgray: "d3d3d3",
+        lightgreen: "90ee90",
+        lightgrey: "d3d3d3",
+        lightpink: "ffb6c1",
+        lightsalmon: "ffa07a",
+        lightseagreen: "20b2aa",
+        lightskyblue: "87cefa",
+        lightslategray: "789",
+        lightslategrey: "789",
+        lightsteelblue: "b0c4de",
+        lightyellow: "ffffe0",
+        lime: "0f0",
+        limegreen: "32cd32",
+        linen: "faf0e6",
+        magenta: "f0f",
+        maroon: "800000",
+        mediumaquamarine: "66cdaa",
+        mediumblue: "0000cd",
+        mediumorchid: "ba55d3",
+        mediumpurple: "9370db",
+        mediumseagreen: "3cb371",
+        mediumslateblue: "7b68ee",
+        mediumspringgreen: "00fa9a",
+        mediumturquoise: "48d1cc",
+        mediumvioletred: "c71585",
+        midnightblue: "191970",
+        mintcream: "f5fffa",
+        mistyrose: "ffe4e1",
+        moccasin: "ffe4b5",
+        navajowhite: "ffdead",
+        navy: "000080",
+        oldlace: "fdf5e6",
+        olive: "808000",
+        olivedrab: "6b8e23",
+        orange: "ffa500",
+        orangered: "ff4500",
+        orchid: "da70d6",
+        palegoldenrod: "eee8aa",
+        palegreen: "98fb98",
+        paleturquoise: "afeeee",
+        palevioletred: "db7093",
+        papayawhip: "ffefd5",
+        peachpuff: "ffdab9",
+        peru: "cd853f",
+        pink: "ffc0cb",
+        plum: "dda0dd",
+        powderblue: "b0e0e6",
+        purple: "800080",
+        rebeccapurple: "639",
+        red: "f00",
+        rosybrown: "bc8f8f",
+        royalblue: "4169e1",
+        saddlebrown: "8b4513",
+        salmon: "fa8072",
+        sandybrown: "f4a460",
+        seagreen: "2e8b57",
+        seashell: "fff5ee",
+        sienna: "a0522d",
+        silver: "c0c0c0",
+        skyblue: "87ceeb",
+        slateblue: "6a5acd",
+        slategray: "708090",
+        slategrey: "708090",
+        snow: "fffafa",
+        springgreen: "00ff7f",
+        steelblue: "4682b4",
+        tan: "d2b48c",
+        teal: "008080",
+        thistle: "d8bfd8",
+        tomato: "ff6347",
+        turquoise: "40e0d0",
+        violet: "ee82ee",
+        wheat: "f5deb3",
+        white: "fff",
+        whitesmoke: "f5f5f5",
+        yellow: "ff0",
+        yellowgreen: "9acd32"
+    };
+
+    function nameToHex(color2) {
+        if (typeof color2 !== "string")
+            return color2;
+        var normalizedColorName = color2.toLowerCase();
+        return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color2;
+    }
+    var hexRegex = /^#[a-fA-F0-9]{6}$/;
+    var hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;
+    var reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
+    var reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;
+    var rgbRegex = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i;
+    var rgbaRegex = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
+    var hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
+    var hslaRegex = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
+
+    function parseToRgb(color2) {
+        if (typeof color2 !== "string") {
+            throw new PolishedError(3);
+        }
+        var normalizedColor = nameToHex(color2);
+        if (normalizedColor.match(hexRegex)) {
+            return {
+                red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
+                green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
+                blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
+            };
+        }
+        if (normalizedColor.match(hexRgbaRegex)) {
+            var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
+            return {
+                red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
+                green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
+                blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
+                alpha
+            };
+        }
+        if (normalizedColor.match(reducedHexRegex)) {
+            return {
+                red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
+                green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
+                blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
+            };
+        }
+        if (normalizedColor.match(reducedRgbaHexRegex)) {
+            var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));
+            return {
+                red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
+                green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
+                blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
+                alpha: _alpha
+            };
+        }
+        var rgbMatched = rgbRegex.exec(normalizedColor);
+        if (rgbMatched) {
+            return {
+                red: parseInt("" + rgbMatched[1], 10),
+                green: parseInt("" + rgbMatched[2], 10),
+                blue: parseInt("" + rgbMatched[3], 10)
+            };
+        }
+        var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));
+        if (rgbaMatched) {
+            return {
+                red: parseInt("" + rgbaMatched[1], 10),
+                green: parseInt("" + rgbaMatched[2], 10),
+                blue: parseInt("" + rgbaMatched[3], 10),
+                alpha: parseFloat("" + rgbaMatched[4]) > 1 ? parseFloat("" + rgbaMatched[4]) / 100 : parseFloat("" + rgbaMatched[4])
+            };
+        }
+        var hslMatched = hslRegex.exec(normalizedColor);
+        if (hslMatched) {
+            var hue = parseInt("" + hslMatched[1], 10);
+            var saturation = parseInt("" + hslMatched[2], 10) / 100;
+            var lightness = parseInt("" + hslMatched[3], 10) / 100;
+            var rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")";
+            var hslRgbMatched = rgbRegex.exec(rgbColorString);
+            if (!hslRgbMatched) {
+                throw new PolishedError(4, normalizedColor, rgbColorString);
+            }
+            return {
+                red: parseInt("" + hslRgbMatched[1], 10),
+                green: parseInt("" + hslRgbMatched[2], 10),
+                blue: parseInt("" + hslRgbMatched[3], 10)
+            };
+        }
+        var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));
+        if (hslaMatched) {
+            var _hue = parseInt("" + hslaMatched[1], 10);
+            var _saturation = parseInt("" + hslaMatched[2], 10) / 100;
+            var _lightness = parseInt("" + hslaMatched[3], 10) / 100;
+            var _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")";
+            var _hslRgbMatched = rgbRegex.exec(_rgbColorString);
+            if (!_hslRgbMatched) {
+                throw new PolishedError(4, normalizedColor, _rgbColorString);
+            }
+            return {
+                red: parseInt("" + _hslRgbMatched[1], 10),
+                green: parseInt("" + _hslRgbMatched[2], 10),
+                blue: parseInt("" + _hslRgbMatched[3], 10),
+                alpha: parseFloat("" + hslaMatched[4]) > 1 ? parseFloat("" + hslaMatched[4]) / 100 : parseFloat("" + hslaMatched[4])
+            };
+        }
+        throw new PolishedError(5);
+    }
+
+    function rgbToHsl(color2) {
+        var red = color2.red / 255;
+        var green = color2.green / 255;
+        var blue = color2.blue / 255;
+        var max2 = Math.max(red, green, blue);
+        var min2 = Math.min(red, green, blue);
+        var lightness = (max2 + min2) / 2;
+        if (max2 === min2) {
+            if (color2.alpha !== void 0) {
+                return {
+                    hue: 0,
+                    saturation: 0,
+                    lightness,
+                    alpha: color2.alpha
+                };
+            } else {
+                return {
+                    hue: 0,
+                    saturation: 0,
+                    lightness
+                };
+            }
+        }
+        var hue;
+        var delta = max2 - min2;
+        var saturation = lightness > 0.5 ? delta / (2 - max2 - min2) : delta / (max2 + min2);
+        switch (max2) {
+            case red:
+                hue = (green - blue) / delta + (green < blue ? 6 : 0);
+                break;
+            case green:
+                hue = (blue - red) / delta + 2;
+                break;
+            default:
+                hue = (red - green) / delta + 4;
+                break;
+        }
+        hue *= 60;
+        if (color2.alpha !== void 0) {
+            return {
+                hue,
+                saturation,
+                lightness,
+                alpha: color2.alpha
+            };
+        }
+        return {
+            hue,
+            saturation,
+            lightness
+        };
+    }
+
+    function parseToHsl(color2) {
+        return rgbToHsl(parseToRgb(color2));
+    }
+    var reduceHexValue = function reduceHexValue2(value) {
+        if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
+            return "#" + value[1] + value[3] + value[5];
+        }
+        return value;
+    };
+    var reduceHexValue$1 = reduceHexValue;
+
+    function numberToHex(value) {
+        var hex2 = value.toString(16);
+        return hex2.length === 1 ? "0" + hex2 : hex2;
+    }
+
+    function colorToHex(color2) {
+        return numberToHex(Math.round(color2 * 255));
+    }
+
+    function convertToHex(red, green, blue) {
+        return reduceHexValue$1("#" + colorToHex(red) + colorToHex(green) + colorToHex(blue));
+    }
+
+    function hslToHex(hue, saturation, lightness) {
+        return hslToRgb(hue, saturation, lightness, convertToHex);
+    }
+
+    function hsl(value, saturation, lightness) {
+        if (typeof value === "number" && typeof saturation === "number" && typeof lightness === "number") {
+            return hslToHex(value, saturation, lightness);
+        } else if (typeof value === "object" && saturation === void 0 && lightness === void 0) {
+            return hslToHex(value.hue, value.saturation, value.lightness);
+        }
+        throw new PolishedError(1);
+    }
+
+    function hsla$1(value, saturation, lightness, alpha) {
+        if (typeof value === "number" && typeof saturation === "number" && typeof lightness === "number" && typeof alpha === "number") {
+            return alpha >= 1 ? hslToHex(value, saturation, lightness) : "rgba(" + hslToRgb(value, saturation, lightness) + "," + alpha + ")";
+        } else if (typeof value === "object" && saturation === void 0 && lightness === void 0 && alpha === void 0) {
+            return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : "rgba(" + hslToRgb(value.hue, value.saturation, value.lightness) + "," + value.alpha + ")";
+        }
+        throw new PolishedError(2);
+    }
+
+    function rgb(value, green, blue) {
+        if (typeof value === "number" && typeof green === "number" && typeof blue === "number") {
+            return reduceHexValue$1("#" + numberToHex(value) + numberToHex(green) + numberToHex(blue));
+        } else if (typeof value === "object" && green === void 0 && blue === void 0) {
+            return reduceHexValue$1("#" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));
+        }
+        throw new PolishedError(6);
+    }
+
+    function rgba$1(firstValue, secondValue, thirdValue, fourthValue) {
+        if (typeof firstValue === "string" && typeof secondValue === "number") {
+            var rgbValue = parseToRgb(firstValue);
+            return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
+        } else if (typeof firstValue === "number" && typeof secondValue === "number" && typeof thirdValue === "number" && typeof fourthValue === "number") {
+            return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
+        } else if (typeof firstValue === "object" && secondValue === void 0 && thirdValue === void 0 && fourthValue === void 0) {
+            return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
+        }
+        throw new PolishedError(7);
+    }
+    var isRgb = function isRgb2(color2) {
+        return typeof color2.red === "number" && typeof color2.green === "number" && typeof color2.blue === "number" && (typeof color2.alpha !== "number" || typeof color2.alpha === "undefined");
+    };
+    var isRgba = function isRgba2(color2) {
+        return typeof color2.red === "number" && typeof color2.green === "number" && typeof color2.blue === "number" && typeof color2.alpha === "number";
+    };
+    var isHsl = function isHsl2(color2) {
+        return typeof color2.hue === "number" && typeof color2.saturation === "number" && typeof color2.lightness === "number" && (typeof color2.alpha !== "number" || typeof color2.alpha === "undefined");
+    };
+    var isHsla = function isHsla2(color2) {
+        return typeof color2.hue === "number" && typeof color2.saturation === "number" && typeof color2.lightness === "number" && typeof color2.alpha === "number";
+    };
+
+    function toColorString(color2) {
+        if (typeof color2 !== "object")
+            throw new PolishedError(8);
+        if (isRgba(color2))
+            return rgba$1(color2);
+        if (isRgb(color2))
+            return rgb(color2);
+        if (isHsla(color2))
+            return hsla$1(color2);
+        if (isHsl(color2))
+            return hsl(color2);
+        throw new PolishedError(8);
+    }
+
+    function curried(f2, length, acc) {
+        return function fn2() {
+            var combined = acc.concat(Array.prototype.slice.call(arguments));
+            return combined.length >= length ? f2.apply(this, combined) : curried(f2, length, combined);
+        };
+    }
+
+    function curry(f2) {
+        return curried(f2, f2.length, []);
+    }
+
+    function adjustHue(degree, color2) {
+        if (color2 === "transparent")
+            return color2;
+        var hslColor = parseToHsl(color2);
+        return toColorString(_extends$3({}, hslColor, {
+            hue: hslColor.hue + parseFloat(degree)
+        }));
+    }
+    curry(adjustHue);
+
+    function guard(lowerBoundary, upperBoundary, value) {
+        return Math.max(lowerBoundary, Math.min(upperBoundary, value));
+    }
+
+    function darken(amount, color2) {
+        if (color2 === "transparent")
+            return color2;
+        var hslColor = parseToHsl(color2);
+        return toColorString(_extends$3({}, hslColor, {
+            lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))
+        }));
+    }
+    curry(darken);
+
+    function desaturate(amount, color2) {
+        if (color2 === "transparent")
+            return color2;
+        var hslColor = parseToHsl(color2);
+        return toColorString(_extends$3({}, hslColor, {
+            saturation: guard(0, 1, hslColor.saturation - parseFloat(amount))
+        }));
+    }
+    curry(desaturate);
+
+    function lighten(amount, color2) {
+        if (color2 === "transparent")
+            return color2;
+        var hslColor = parseToHsl(color2);
+        return toColorString(_extends$3({}, hslColor, {
+            lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))
+        }));
+    }
+    curry(lighten);
+
+    function mix(weight, color2, otherColor) {
+        if (color2 === "transparent")
+            return otherColor;
+        if (otherColor === "transparent")
+            return color2;
+        if (weight === 0)
+            return otherColor;
+        var parsedColor1 = parseToRgb(color2);
+        var color1 = _extends$3({}, parsedColor1, {
+            alpha: typeof parsedColor1.alpha === "number" ? parsedColor1.alpha : 1
+        });
+        var parsedColor2 = parseToRgb(otherColor);
+        var color22 = _extends$3({}, parsedColor2, {
+            alpha: typeof parsedColor2.alpha === "number" ? parsedColor2.alpha : 1
+        });
+        var alphaDelta = color1.alpha - color22.alpha;
+        var x2 = parseFloat(weight) * 2 - 1;
+        var y2 = x2 * alphaDelta === -1 ? x2 : x2 + alphaDelta;
+        var z2 = 1 + x2 * alphaDelta;
+        var weight1 = (y2 / z2 + 1) / 2;
+        var weight2 = 1 - weight1;
+        var mixedColor = {
+            red: Math.floor(color1.red * weight1 + color22.red * weight2),
+            green: Math.floor(color1.green * weight1 + color22.green * weight2),
+            blue: Math.floor(color1.blue * weight1 + color22.blue * weight2),
+            alpha: color1.alpha * parseFloat(weight) + color22.alpha * (1 - parseFloat(weight))
+        };
+        return rgba$1(mixedColor);
+    }
+    var curriedMix = curry(mix);
+    var mix$1 = curriedMix;
+
+    function opacify(amount, color2) {
+        if (color2 === "transparent")
+            return color2;
+        var parsedColor = parseToRgb(color2);
+        var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
+        var colorWithAlpha = _extends$3({}, parsedColor, {
+            alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)
+        });
+        return rgba$1(colorWithAlpha);
+    }
+    curry(opacify);
+
+    function saturate(amount, color2) {
+        if (color2 === "transparent")
+            return color2;
+        var hslColor = parseToHsl(color2);
+        return toColorString(_extends$3({}, hslColor, {
+            saturation: guard(0, 1, hslColor.saturation + parseFloat(amount))
+        }));
+    }
+    curry(saturate);
+
+    function setHue(hue, color2) {
+        if (color2 === "transparent")
+            return color2;
+        return toColorString(_extends$3({}, parseToHsl(color2), {
+            hue: parseFloat(hue)
+        }));
+    }
+    curry(setHue);
+
+    function setLightness(lightness, color2) {
+        if (color2 === "transparent")
+            return color2;
+        return toColorString(_extends$3({}, parseToHsl(color2), {
+            lightness: parseFloat(lightness)
+        }));
+    }
+    curry(setLightness);
+
+    function setSaturation(saturation, color2) {
+        if (color2 === "transparent")
+            return color2;
+        return toColorString(_extends$3({}, parseToHsl(color2), {
+            saturation: parseFloat(saturation)
+        }));
+    }
+    curry(setSaturation);
+
+    function shade(percentage, color2) {
+        if (color2 === "transparent")
+            return color2;
+        return mix$1(parseFloat(percentage), "rgb(0, 0, 0)", color2);
+    }
+    curry(shade);
+
+    function tint(percentage, color2) {
+        if (color2 === "transparent")
+            return color2;
+        return mix$1(parseFloat(percentage), "rgb(255, 255, 255)", color2);
+    }
+    curry(tint);
+
+    function transparentize(amount, color2) {
+        if (color2 === "transparent")
+            return color2;
+        var parsedColor = parseToRgb(color2);
+        var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
+        var colorWithAlpha = _extends$3({}, parsedColor, {
+            alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)
+        });
+        return rgba$1(colorWithAlpha);
+    }
+    curry(transparentize);
     const PromptWrapper = styled__default.default.div`
     display: flex;
     flex-shrink: 1;
     gap: 0.25rem;
     align-items: center;
 
     min-width: 0;
@@ -421523,17 +422010,17 @@
                 const edge = this.edgeMap.get(edgeKey);
                 if (edge) {
                     edge.updateVisibility(zoomState, edgeAttributes.points !== void 0);
                     this.updateEdgeStyleByKey(edgeKey);
                 }
             });
         }
-        updateLayout() {
-            return __awaiter(this, arguments, void 0, function*(retry = false) {
-                var _a3;
+        updateLayout(retry = false) {
+            var _a3;
+            return __awaiter(this, void 0, void 0, function*() {
                 (_a3 = this.onCleanup) === null || _a3 === void 0 ? void 0 : _a3.call(this);
                 try {
                     const {
                         layout: layout2,
                         edgePoints: edgePoints2,
                         onStartDrag,
                         onEndDrag,
```

## Comparing `dara_components-1.8.0.dist-info/LICENSE` & `dara_components-1.8.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `dara_components-1.8.0.dist-info/METADATA` & `dara_components-1.8.1.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 Metadata-Version: 2.1
 Name: dara-components
-Version: 1.8.0
+Version: 1.8.1
 Summary: Components for the Dara Framework
 Home-page: https://dara.causalens.com/
 License: Apache-2.0
 Author: Patricia Jacob
 Author-email: patricia@causalens.com
 Requires-Python: >=3.8.0,<3.12.0
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
 Requires-Dist: bokeh (>=3.1.0,<3.2.0)
 Requires-Dist: cai-causal-graph (>=0.3.6)
-Requires-Dist: dara-core (==1.8.0)
+Requires-Dist: dara-core (==1.8.1)
 Requires-Dist: dill (>=0.3.0,<0.4.0)
 Requires-Dist: matplotlib (>=2.0.0)
 Requires-Dist: pandas (>=1.1.0,<3.0.0)
 Requires-Dist: plotly (>=5.14.0,<5.15.0)
 Requires-Dist: scipy
 Requires-Dist: seaborn (>=0.11.0)
 Project-URL: Repository, https://github.com/causalens/dara
 Description-Content-Type: text/markdown
 
 # Dara Components
 
-<img src="https://github.com/causalens/dara/blob/VERSION-1.8.0/img/dara_light.svg?raw=true">
+<img src="https://github.com/causalens/dara/blob/VERSION-1.8.1/img/dara_light.svg?raw=true">
 
 ![Master tests](https://github.com/causalens/dara/actions/workflows/tests.yml/badge.svg?branch=master)
 [![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](https://www.apache.org/licenses/LICENSE-2.0)
 [![PyPI](https://img.shields.io/pypi/v/dara-components.svg?color=dark-green)](https://pypi.org/project/dara-components/)
 [![PyPI - Python Version](https://img.shields.io/pypi/pyversions/dara-components.svg?color=dark-green)](https://pypi.org/project/dara-components/)
 [![NPM](https://img.shields.io/npm/v/@darajs/components.svg?color=dark-green)](https://www.npmjs.com/package/@darajs/components)
```

## Comparing `dara_components-1.8.0.dist-info/RECORD` & `dara_components-1.8.1.dist-info/RECORD`

 * *Files 3% similar despite different names*

```diff
@@ -57,27 +57,30 @@
 dara/components/plotting/matplotlib/__init__.py,sha256=XNvSBKg8ML2IhMm9fJ5-OOHAIX3sGs_q10MaaK2v0EI,681
 dara/components/plotting/matplotlib/matplotlib.py,sha256=VUeOJZ6bTVrsJezmGqUJdezi6Vp53voB9BBWAGfTtrQ,1851
 dara/components/plotting/palettes.py,sha256=dAFOLzDsb5Cq-ffhegLsElaJueGzCJ7Px6J7frMe_YY,8001
 dara/components/plotting/plotly/__init__.py,sha256=vbFmz0BhPw6LktZxtVc4iv5eXRlc-5OqhBKOleUVaBw,835
 dara/components/plotting/plotly/plotly.py,sha256=oZXrR7tWeZpFaa43rC_B0zx41nKXf4N3uhTRvmZWd3M,4361
 dara/components/plotting/plotly/themes.py,sha256=gz4LaxHUoSGxHuIYIi52DGto-TgxPJ4_RFpBwaXfEqw,4298
 dara/components/smart/__init__.py,sha256=BKddy9x0y4g6mKlPOZeSJMEpmdDZjDYMaqbfZOlfO3Q,1083
-dara/components/smart/chat/__init__.py,sha256=DUSpJvIVT4amDyhKPHQS8M8un82uLrct9QAtw-IIkI8,647
-dara/components/smart/chat/chat.py,sha256=a2tKdxsvVkfSiwlB2JIDJgV-MM7JQF0clbi5fEAS8CY,2964
+dara/components/smart/chat/__init__.py,sha256=1J6s1YYBuDYg7Vft5vhMzkGHp2vjqUWy3BZQB4Es6mM,796
+dara/components/smart/chat/chat.py,sha256=4Wz7M9tEDN9VkbFY9r8PmRdo16JFWG6EeWwAi-XQ7qw,3067
+dara/components/smart/chat/config.py,sha256=kXm_EkfE7mL-8sseZMGSqbXBTWwdIXozv37v-k-B8fg,590
+dara/components/smart/chat/endpoints.py,sha256=knILdBHrb2zEtL2r6-3OumSPZKdQ_FJLkj_BWrNCOLE,490
+dara/components/smart/chat/types.py,sha256=ic5KcIRowirxTHMtsBWCNwZPxF87jO0sxTYo8qDl9_w,1316
 dara/components/smart/code_editor/__init__.py,sha256=U568YcqDyS8lC2qzf_9TrB62er-UibnbT6IeAiDSaME,749
 dara/components/smart/code_editor/code_editor.py,sha256=T6OsGnbeUWtW4Zupr2MG-QSuAUEFumEMlsZMnxyw6jY,930
 dara/components/smart/code_editor/util.py,sha256=sAZphgDHXI2Q2crr3qJg0lnLzY9OzuOzW_1e0EX8Rjs,4476
 dara/components/smart/data_slicer/__init__.py,sha256=i-xM9LY7MzMOrg7wZ4vtbJ924EjAeqKWyyydmDfoMro,783
 dara/components/smart/data_slicer/data_slicer.py,sha256=Hl9nVRgg-2Z0O5uECxiioxT2RikIygDArQXF6XKMj8I,7490
 dara/components/smart/data_slicer/data_slicer_modal.py,sha256=t7NywA5DiFiUiUnuFQbTAAVm6PM7Qjd6LGzd9OWA0QE,4120
 dara/components/smart/data_slicer/extension/data_slicer_filter.py,sha256=2wdWn3gcrewrhUZ4tGNwAh1JURpcLmeDKIP7c5j9_sI,1616
 dara/components/smart/data_slicer/extension/filter_status_button.py,sha256=02CgqHEBgkZg1E9v9HGrnRYvEiMNhYpajyOwGuPNV1M,1345
 dara/components/smart/data_slicer/utils/core.py,sha256=6BrmG-iwQCuwUAKQ-y9zFKLeinnzhXIaUOB58UxCYbc,8656
 dara/components/smart/data_slicer/utils/data_preview.py,sha256=OAphjMrm3F76XmJ09X7sZSeOeKqGJFwN5ooo3qcyrG4,1722
 dara/components/smart/data_slicer/utils/plotting.py,sha256=JYzdQLXdAD0A8k2W-764xUr7zN0Ri5nf3OQ2Nb_iuiY,3313
 dara/components/smart/hierarchy.py,sha256=STkgyZiVB1c6KJtcKnn1r8lnjZAIrWkTCpZ_WCyCI1c,2877
-dara/components/umd/dara.components.umd.js,sha256=OwNRa-jh2icAqhbeQQk9RiJ6u8_1r6csjDGIDjiw3b4,16866614
+dara/components/umd/dara.components.umd.js,sha256=egys-9VGygtcD0SiKdaTV6LQhRhqjSuiRS-8HEB9JcI,16879670
 dara/components/umd/style.css,sha256=cvNU48TRRp73QxBrE9awB-zm3YURFnFlASafeLTNa_U,23576
-dara_components-1.8.0.dist-info/LICENSE,sha256=r9u1w2RvpLMV6YjuXHIKXRBKzia3fx_roPwboGcLqCc,10944
-dara_components-1.8.0.dist-info/METADATA,sha256=4nECfRKyzmy4RvX9QC0KOWdRjkucilHH-pef4tmu2oU,2710
-dara_components-1.8.0.dist-info/WHEEL,sha256=7Z8_27uaHI_UZAc4Uox4PpBhQ9Y5_modZXWMxtUi4NU,88
-dara_components-1.8.0.dist-info/RECORD,,
+dara_components-1.8.1.dist-info/LICENSE,sha256=r9u1w2RvpLMV6YjuXHIKXRBKzia3fx_roPwboGcLqCc,10944
+dara_components-1.8.1.dist-info/METADATA,sha256=A3ysaY_CxKyOEob-_tLrwaxcpJYJMVg-DVE46kmEyzk,2710
+dara_components-1.8.1.dist-info/WHEEL,sha256=7Z8_27uaHI_UZAc4Uox4PpBhQ9Y5_modZXWMxtUi4NU,88
+dara_components-1.8.1.dist-info/RECORD,,
```


# Comparing `tmp/cegalprizm_hub-1.2.2-py3-none-any.whl.zip` & `tmp/cegalprizm_hub-1.2.dev66355-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,36 +1,44 @@
-Zip file size: 53434 bytes, number of entries: 34
--rw-r--r--  2.0 unx      760 b- defN 24-Apr-17 05:29 cegalprizm/hub/__init__.py
--rw-r--r--  2.0 unx    16532 b- defN 24-Apr-17 05:29 cegalprizm/hub/agent.py
--rw-r--r--  2.0 unx    23141 b- defN 24-Apr-17 05:29 cegalprizm/hub/agent_pb2.py
--rw-r--r--  2.0 unx      159 b- defN 24-Apr-17 05:29 cegalprizm/hub/agent_pb2_grpc.py
--rw-r--r--  2.0 unx     3582 b- defN 24-Apr-17 05:29 cegalprizm/hub/base_ctx.py
--rw-r--r--  2.0 unx     2081 b- defN 24-Apr-17 05:29 cegalprizm/hub/capability.py
--rw-r--r--  2.0 unx    11428 b- defN 24-Apr-17 05:29 cegalprizm/hub/client.py
--rw-r--r--  2.0 unx     3064 b- defN 24-Apr-17 05:29 cegalprizm/hub/client_config.py
--rw-r--r--  2.0 unx     2676 b- defN 24-Apr-17 05:29 cegalprizm/hub/connection_parameters.py
--rw-r--r--  2.0 unx    20501 b- defN 24-Apr-17 05:29 cegalprizm/hub/connector.py
--rw-r--r--  2.0 unx     3131 b- defN 24-Apr-17 05:29 cegalprizm/hub/connector_filter.py
--rw-r--r--  2.0 unx    12103 b- defN 24-Apr-17 05:29 cegalprizm/hub/connector_request_service_pb2.py
--rw-r--r--  2.0 unx     6636 b- defN 24-Apr-17 05:29 cegalprizm/hub/connector_request_service_pb2_grpc.py
--rw-r--r--  2.0 unx    47744 b- defN 24-Apr-17 05:29 cegalprizm/hub/connector_task_service_pb2.py
--rw-r--r--  2.0 unx     2872 b- defN 24-Apr-17 05:29 cegalprizm/hub/connector_task_service_pb2_grpc.py
--rw-r--r--  2.0 unx     2626 b- defN 24-Apr-17 05:29 cegalprizm/hub/generic_client_interceptor.py
--rw-r--r--  2.0 unx    16763 b- defN 24-Apr-17 05:29 cegalprizm/hub/hub.py
--rw-r--r--  2.0 unx     4875 b- defN 24-Apr-17 05:29 cegalprizm/hub/hub_channel.py
--rw-r--r--  2.0 unx     1222 b- defN 24-Apr-17 05:29 cegalprizm/hub/impersonation_interceptor.py
--rw-r--r--  2.0 unx     1103 b- defN 24-Apr-17 05:29 cegalprizm/hub/keystone_auth_interceptor.py
--rw-r--r--  2.0 unx      575 b- defN 24-Apr-17 05:29 cegalprizm/hub/payload_auth.py
--rw-r--r--  2.0 unx    11496 b- defN 24-Apr-17 05:29 cegalprizm/hub/petrel.py
--rw-r--r--  2.0 unx    21065 b- defN 24-Apr-17 05:29 cegalprizm/hub/petrel_pb2.py
--rw-r--r--  2.0 unx      159 b- defN 24-Apr-17 05:29 cegalprizm/hub/petrel_pb2_grpc.py
--rw-r--r--  2.0 unx     4166 b- defN 24-Apr-17 05:29 cegalprizm/hub/server_config.py
--rw-r--r--  2.0 unx    51456 b- defN 24-Apr-17 05:29 cegalprizm/hub/server_service_pb2.py
--rw-r--r--  2.0 unx    11339 b- defN 24-Apr-17 05:29 cegalprizm/hub/server_service_pb2_grpc.py
--rw-r--r--  2.0 unx     3713 b- defN 24-Apr-17 05:29 cegalprizm/hub/task_registry.py
--rw-r--r--  2.0 unx     1047 b- defN 24-Apr-17 05:29 cegalprizm/hub/threadsafe.py
--rw-r--r--  2.0 unx     1212 b- defN 24-Apr-17 05:30 cegalprizm_hub-1.2.2.dist-info/LICENSE
--rw-r--r--  2.0 unx     3501 b- defN 24-Apr-17 05:30 cegalprizm_hub-1.2.2.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Apr-17 05:30 cegalprizm_hub-1.2.2.dist-info/WHEEL
--rw-r--r--  2.0 unx       11 b- defN 24-Apr-17 05:30 cegalprizm_hub-1.2.2.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     3052 b- defN 24-Apr-17 05:30 cegalprizm_hub-1.2.2.dist-info/RECORD
-34 files, 295883 bytes uncompressed, 48498 bytes compressed:  83.6%
+Zip file size: 56507 bytes, number of entries: 42
+-rw-r--r--  2.0 unx      820 b- defN 23-Jul-20 07:54 cegalprizm/hub/__init__.py
+-rw-r--r--  2.0 unx    16224 b- defN 23-Jul-20 07:54 cegalprizm/hub/agent.py
+-rw-r--r--  2.0 unx    23617 b- defN 23-Jul-20 07:54 cegalprizm/hub/agent_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-20 07:54 cegalprizm/hub/agent_pb2_grpc.py
+-rw-r--r--  2.0 unx     3605 b- defN 23-Jul-20 07:54 cegalprizm/hub/base_ctx.py
+-rw-r--r--  2.0 unx     2083 b- defN 23-Jul-20 07:54 cegalprizm/hub/capability.py
+-rw-r--r--  2.0 unx    11505 b- defN 23-Jul-20 07:54 cegalprizm/hub/client.py
+-rw-r--r--  2.0 unx     2369 b- defN 23-Jul-20 07:54 cegalprizm/hub/client_config.py
+-rw-r--r--  2.0 unx     2707 b- defN 23-Jul-20 07:54 cegalprizm/hub/connection_parameters.py
+-rw-r--r--  2.0 unx    12945 b- defN 23-Jul-20 07:54 cegalprizm/hub/connector.py
+-rw-r--r--  2.0 unx     3170 b- defN 23-Jul-20 07:54 cegalprizm/hub/connector_filter.py
+-rw-r--r--  2.0 unx    12103 b- defN 23-Jul-20 07:54 cegalprizm/hub/connector_request_service_pb2.py
+-rw-r--r--  2.0 unx     6636 b- defN 23-Jul-20 07:54 cegalprizm/hub/connector_request_service_pb2_grpc.py
+-rw-r--r--  2.0 unx    47744 b- defN 23-Jul-20 07:54 cegalprizm/hub/connector_task_service_pb2.py
+-rw-r--r--  2.0 unx     2872 b- defN 23-Jul-20 07:54 cegalprizm/hub/connector_task_service_pb2_grpc.py
+-rw-r--r--  2.0 unx     2626 b- defN 23-Jul-20 07:54 cegalprizm/hub/generic_client_interceptor.py
+-rw-r--r--  2.0 unx    16867 b- defN 23-Jul-20 07:54 cegalprizm/hub/hub.py
+-rw-r--r--  2.0 unx     4933 b- defN 23-Jul-20 07:54 cegalprizm/hub/hub_channel.py
+-rw-r--r--  2.0 unx      281 b- defN 23-Jul-20 07:54 cegalprizm/hub/in_memory_token_provider.py
+-rw-r--r--  2.0 unx     1102 b- defN 23-Jul-20 07:54 cegalprizm/hub/keystone_auth_interceptor.py
+-rw-r--r--  2.0 unx      575 b- defN 23-Jul-20 07:54 cegalprizm/hub/payload_auth.py
+-rw-r--r--  2.0 unx    11062 b- defN 23-Jul-20 07:54 cegalprizm/hub/petrel.py
+-rw-r--r--  2.0 unx    21065 b- defN 23-Jul-20 07:54 cegalprizm/hub/petrel_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-20 07:54 cegalprizm/hub/petrel_pb2_grpc.py
+-rw-r--r--  2.0 unx     4193 b- defN 23-Jul-20 07:54 cegalprizm/hub/server_config.py
+-rw-r--r--  2.0 unx    48233 b- defN 23-Jul-20 07:54 cegalprizm/hub/server_service_pb2.py
+-rw-r--r--  2.0 unx     9537 b- defN 23-Jul-20 07:54 cegalprizm/hub/server_service_pb2_grpc.py
+-rw-r--r--  2.0 unx     3716 b- defN 23-Jul-20 07:54 cegalprizm/hub/task_registry.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-20 07:54 example_client/__init__.py
+-rw-r--r--  2.0 unx     3387 b- defN 23-Jul-20 07:54 example_client/greeter_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-20 07:54 example_client/greeter_pb2_grpc.py
+-rw-r--r--  2.0 unx     4520 b- defN 23-Jul-20 07:54 example_client/main.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-20 07:54 example_connector/__init__.py
+-rw-r--r--  2.0 unx     3387 b- defN 23-Jul-20 07:54 example_connector/greeter_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-20 07:54 example_connector/greeter_pb2_grpc.py
+-rw-r--r--  2.0 unx     4997 b- defN 23-Jul-20 07:54 example_connector/main.py
+-rw-r--r--  2.0 unx      287 b- defN 23-Jul-20 07:54 example_upload/main.py
+-rw-r--r--  2.0 unx     1212 b- defN 23-Jul-20 07:54 cegalprizm_hub-1.2.dev66355.dist-info/LICENSE
+-rw-r--r--  2.0 unx     3515 b- defN 23-Jul-20 07:54 cegalprizm_hub-1.2.dev66355.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-20 07:54 cegalprizm_hub-1.2.dev66355.dist-info/WHEEL
+-rw-r--r--  2.0 unx       59 b- defN 23-Jul-20 07:54 cegalprizm_hub-1.2.dev66355.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     3759 b- defN 23-Jul-20 07:54 cegalprizm_hub-1.2.dev66355.dist-info/RECORD
+42 files, 298441 bytes uncompressed, 50439 bytes compressed:  83.1%
```

## zipnote {}

```diff
@@ -48,15 +48,15 @@
 
 Filename: cegalprizm/hub/hub.py
 Comment: 
 
 Filename: cegalprizm/hub/hub_channel.py
 Comment: 
 
-Filename: cegalprizm/hub/impersonation_interceptor.py
+Filename: cegalprizm/hub/in_memory_token_provider.py
 Comment: 
 
 Filename: cegalprizm/hub/keystone_auth_interceptor.py
 Comment: 
 
 Filename: cegalprizm/hub/payload_auth.py
 Comment: 
@@ -78,26 +78,50 @@
 
 Filename: cegalprizm/hub/server_service_pb2_grpc.py
 Comment: 
 
 Filename: cegalprizm/hub/task_registry.py
 Comment: 
 
-Filename: cegalprizm/hub/threadsafe.py
+Filename: example_client/__init__.py
 Comment: 
 
-Filename: cegalprizm_hub-1.2.2.dist-info/LICENSE
+Filename: example_client/greeter_pb2.py
 Comment: 
 
-Filename: cegalprizm_hub-1.2.2.dist-info/METADATA
+Filename: example_client/greeter_pb2_grpc.py
 Comment: 
 
-Filename: cegalprizm_hub-1.2.2.dist-info/WHEEL
+Filename: example_client/main.py
 Comment: 
 
-Filename: cegalprizm_hub-1.2.2.dist-info/top_level.txt
+Filename: example_connector/__init__.py
 Comment: 
 
-Filename: cegalprizm_hub-1.2.2.dist-info/RECORD
+Filename: example_connector/greeter_pb2.py
+Comment: 
+
+Filename: example_connector/greeter_pb2_grpc.py
+Comment: 
+
+Filename: example_connector/main.py
+Comment: 
+
+Filename: example_upload/main.py
+Comment: 
+
+Filename: cegalprizm_hub-1.2.dev66355.dist-info/LICENSE
+Comment: 
+
+Filename: cegalprizm_hub-1.2.dev66355.dist-info/METADATA
+Comment: 
+
+Filename: cegalprizm_hub-1.2.dev66355.dist-info/WHEEL
+Comment: 
+
+Filename: cegalprizm_hub-1.2.dev66355.dist-info/top_level.txt
+Comment: 
+
+Filename: cegalprizm_hub-1.2.dev66355.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## cegalprizm/hub/__init__.py

```diff
@@ -1,13 +1,13 @@
 # Copyright 2023 Cegal AS
 # All rights reserved.
 # Unauthorized copying of this file, via any medium is strictly prohibited.
 
-__version__ = '1.2.2'
-__git_hash__ = '4bea40df'
+__version__ = '1.2.0'
+__git_hash__ = '5b12b393'
 
 import logging
 
 logger = logging.getLogger(__name__)
 
 from .server_config import ServerConfig
 from .client_config import ClientConfig
@@ -19,7 +19,8 @@
 from .capability import HubCapability
 from .base_ctx import BaseContext
 from .petrel import PetrelContext
 from .agent import AgentContext
 from .connection_parameters import ConnectionParameters
 from .connector_filter import ConnectorFilter
 from .agent import AgentContext
+from .in_memory_token_provider import InMemoryTokenProvider
```

## cegalprizm/hub/agent.py

```diff
@@ -9,57 +9,55 @@
 from . import logger
 from .client import HubClient
 from .petrel import PetrelContext
 from .base_ctx import BaseContext
 from .connector_filter import ConnectorFilter
 from .agent_pb2 import LaunchApplicationRequest, LaunchApplicationResult
 from .agent_pb2 import ListFilesRequest, ListFilesResult
-from .agent_pb2 import DownloadFileRequest, DownloadFileResult
+from .agent_pb2 import DownloadFileRequest,DownloadFileResult
 from .agent_pb2 import UploadFileRequest, UploadFileResult
 
-
 class AgentContext(BaseContext):
     """A context or handle to a Cegal Hub Agent or Agents.
-    Connectors may be targeted by providing a ConnectorFilter"""
+    Connectors may be targted by providing a ConnectorFilter"""
 
     def __init__(self, hub_client: HubClient, wellknown_connector_id: str, connector_filter: ConnectorFilter = None):
         """Create an AgentContext from the specified parameters.
 
         Args:
             hub_client (HubClient): The HubClient which makes client requests to Cegal Hub Server.
             wellknown_connector_id (str): The wellknown string that represents the type of connector. i.e cegal.hub.petrel or cegal.hub.agent etc
             connector_filter (ConnectorFilter, optional): A Connector filter to target a specific instance or instances of a Connector. Defaults to None.
         """
         super().__init__(hub_client, wellknown_connector_id, connector_filter)
 
-    def new_petrel_instance(self, project_path: str = None, petrel_version: int = 2022, license_profile: str = None, read_only: bool = True,
-                            wait_for_connect: bool = True, connect_timeout_secs: int = 180):
+    def new_petrel_instance(self, project_path: str = None, petrel_version: int = 2022, license_profile: str = None, read_only: bool = True, wait_for_connect=True,connect_timeout_secs :int=180):
         """Launch a new instance of Petrel in the background.
 
         Args:
             project_path (str, optional): The path to a .pet file to ensure Petrel opens with a project already loaded. Defaults to None.
             petrel_version (int, optional): The version of Petrel i.e 2021 or 2022 etc. Defaults to 2022.
             license_profile (str, optional): The license profile name to use If not specified it will try to choose the last selected profile name. Defaults to None.
             read_only (bool, optional): Whether the Petrel project is opened in readonly mode. Defaults to True.
             wait_for_connect (bool, optional): If True this method will not return until Petrel has started up and connected to Cegal Hub Server. Defaults to True.
-            connect_timeout_secs (int, optional): The number of seconds the Agent will wait for before assuming that Petrel Connector - Hub Server connection failed.
+            connect_timeout_secs (int, optional): The number of seconds the Agent will wait for before assuming that Petrel Connector - Hub Server connection failed. 
             Only relevant if wait_for_connect is True. Defaults to 180.
 
         Raises:
             Exception: If there was an error whilst trying to launch Petrel.
 
         Returns:
             PetrelContext: A strong handle to the launched instance of Petrel.
-        """
+        """        
         cmdline_args = []
         override_default_args = False
-        ocean_env_var = "OCEAN" + str(petrel_version) + "HOME"
+        ocean_env_var = "OCEAN"+str(petrel_version)+"HOME"
 
-        # if need to specify a license profile then need to explicitly set cmdline args and that we are overriding the existing not augmenting
-        # same is true if a project path is specified and must also respect the read_only flag
+        #if need to specify a license profile then need to explicitly set cmdline args and that we are overriding the existing not augmenting
+        #same is true if a project path is specified and must also respect the read_only flag
         if license_profile is not None or project_path is not None:
             override_default_args = True
             if license_profile is not None:
                 cmdline_args.append("/licensePackage")
                 cmdline_args.append(license_profile)
             if read_only and project_path is not None:
                 cmdline_args.append("/readonly")
@@ -68,27 +66,26 @@
             cmdline_args.append("-exec")
             cmdline_args.append("Cegal.Hub.Main.Module, Cegal.Hub")
             cmdline_args.append("DoWork")
             if project_path is not None:
                 cmdline_args.append(project_path)
 
         try:
-            lar = self.launch_application("petrel", cmdline_args=cmdline_args, override_default_args=override_default_args, env_var_override=ocean_env_var,
-                                          is_hub_connector=True, wait_for_connect=wait_for_connect, connect_timeout_secs=connect_timeout_secs)
-            cf = ConnectorFilter(target_connector_id=lar.connector_id)
+            lar = self.launch_application("petrel",cmdline_args=cmdline_args, override_default_args=override_default_args, env_var_override=ocean_env_var, is_hub_connector=True, wait_for_connect=wait_for_connect, connect_timeout_secs=connect_timeout_secs)
+            cf = ConnectorFilter(target_connector_id = lar.connector_id)
             petrel = PetrelContext(self._hub_client, "cegalhub.petrel", cf)
             if wait_for_connect:
                 logger.info(f"Petrel version '{petrel_version}' successfully started!")
             else:
                 logger.info(f"Petrel version '{petrel_version}' has been launched but will take some time to connect!")
             return petrel
         except Exception:
             raise Exception("Error launching Petrel")
 
-    def list_files(self, path: str, suffix: str = "", timeout: int = 60, recursive: bool = False, skip_folder_starts_with: List[str] = [], skip_folder_contains=[]):
+    def list_files(self, path: str, suffix: str ="", timeout: int = 60, recursive: bool = False, skip_folder_starts_with: List[str]=[], skip_folder_contains=[]):
         """List the files seen by the Agent on the directory path provided.
 
         Args:
             path (str): The path directory to search on the Agent
             suffix (str, optional): An optional file suffix to filter search results. Defaults to "".
             timeout (int, optional): The maximum time in seconds to wait for the results of the search. Defaults to 60.
             recursive (bool, optional): Recursively search the directory specified in the path. Defaults to False.
@@ -96,15 +93,15 @@
             skip_folder_contains (list, optional): Skip folders that contain the given string. Defaults to [].
 
         Raises:
             Exception: If there was an error during the list files search.
 
         Returns:
             ListFilesResult: An object containing the files found during the list files search.
-        """
+        """        
         msg = ListFilesRequest()
         msg.root_path = path
         msg.suffix = suffix
         msg.timeout_secs = timeout
         msg.recursive = recursive
 
         for sfs in skip_folder_starts_with:
@@ -113,38 +110,38 @@
         for sfc in skip_folder_contains:
             msg.skip_folder_contains.append(sfc)
 
         payload = Any()
         payload.Pack(msg)
         logger.info("attempting to find files on an agent this may take a while...")
 
-        # reassemble a single find files message from the stream
+        #reassemble a single find files message from the stream
         single = ListFilesResult()
 
-        responses = self._hub_client.do_server_streaming("cegal.hub.agent", "cegal.hub.agent.list_files", payload, connector_filter=self.connector_filter, major_version=1, minor_version=0)
-        cid = ""
+        responses = self._hub_client.do_server_streaming("cegal.hub.agent", "cegal.hub.agent.list_files", payload, connector_filter=self.connector_filter, major_version=1,minor_version=0)
+        cid =""
         for ok, resp, connector_id in responses:
             if not ok:
                 logger.warning(f"error finding files: {resp} on connector_id {connector_id}")
                 raise Exception(f"error from Agent find files: {resp} on connector_id {connector_id}")
-            cid = connector_id
+            cid = connector_id 
             data = ListFilesResult()
             resp.Unpack(data)
             single.num_dirs_searched = data.num_dirs_searched
             single.num_dirs_skipped = data.num_dirs_skipped
             single.num_errors = data.num_errors
             single.num_results = data.num_results
             if data.paths is not None:
                 for p in data.paths:
                     single.paths.append(p)
         logger.info(f"finding files finished on connector_id {cid}")
         return single
 
-    def launch_application(self, profile_name: str, cmdline_args: Sequence = None, override_default_args: bool = False,
-                           env_var_override: str = None, is_hub_connector: bool = False, wait_for_connect: bool = False, connect_timeout_secs: int = 120):
+    def launch_application(self, profile_name:str, cmdline_args:Sequence=None, override_default_args:bool=False,
+     env_var_override:str=None, is_hub_connector: bool=False, wait_for_connect: bool=False, connect_timeout_secs :int=120):
         """Lauch an application profile with the given name from the Agent.
 
         Args:
             profile_name (str): The name of the application profile
             cmdline_args (Sequence, optional): Additional cmdline arguments to those in the application profile. Defaults to None.
             override_default_args (bool, optional): Override the default profile cmdline arguments with those specified in cmdline_args. Defaults to False.
             env_var_override (str, optional): Override the environment variable name in the profile (if one was specified). Defaults to None.
@@ -155,15 +152,15 @@
             name corresponds to a Connector. Defaults to 120.
 
         Raises:
             Exception: If there was a problem launching the application profile.
 
         Returns:
             LaunchApplicationResult: An object representing the result of launching an application profile
-        """
+        """     
         if profile_name is None:
             raise Exception("You must specify an application profile name")
 
         msg = LaunchApplicationRequest()
 
         msg.profile_name = profile_name
         if env_var_override is not None:
@@ -175,32 +172,31 @@
 
         if wait_for_connect:
             is_hub_connector = True
 
         msg.override_default_args = override_default_args
         msg.is_hub_connector = is_hub_connector
         msg.wait_for_connect = wait_for_connect
-        msg.connect_timeout_secs = connect_timeout_secs
+        msg.connect_timeout_secs = connect_timeout_secs  
         payload = Any()
         payload.Pack(msg)
         logger.info(f"attempting to launch {profile_name} on an agent this may take a while...")
-        ok, result, connector_id = self._hub_client.do_unary_request("cegal.hub.agent", "cegal.hub.agent.launch_application", payload,
-                                                                     connector_filter=self.connector_filter, major_version=1, minor_version=0)
+        ok, result, connector_id = self._hub_client.do_unary_request("cegal.hub.agent","cegal.hub.agent.launch_application", payload, connector_filter=self.connector_filter, major_version=1,minor_version=0)
         if (ok):
             response = LaunchApplicationResult()
             result.Unpack(response)
             logger.debug(response)
             return response
         else:
             logger.warning(f"failed to launch application profile {profile_name}: {result} on connector_id {connector_id}")
             raise Exception(f"failed to launch application profile {profile_name}: {result} on connector_id {connector_id}")
 
-    def upload_file(self, src_path: str, rel_dest_path: str = None, abs_dest_path: str = None, overwrite: bool = False):
+    def upload_file(self, src_path: str, rel_dest_path: str=None, abs_dest_path: str=None, overwrite: bool=False, open_file_on_complete: bool=False ):
         """upload a file to a Cegal Hub Agent if the Cegal Hub Agent permits file upload. A file can be uploaded by only specifying the src file and the file will be uploaded
-        to the default directory. The second alternative is to specify a relative destination path in addition to the src file path which will be the relative path from the
+        to the default directory. The second alternative is to specify a relative destination path in additionto the src file path which will be the relative path from the
         default Agent upload directory. The last alternative is to specify an absolute path for upload on the Agent (again the Agent must support this).
 
         Args:
             src_path (str): the src path of the file on the client
             rel_dest_path (str): the relative path to the default file upload shared path on the Agent (if permitted by the Agent)
             abs_dest_path (str): the absolute path to upload to on the Agent (if permitted by the Agent)
             overwrite (bool, optional): whether or not you to overwrite the file if already existing on the Agent (if permitted by the Agent). Defaults to False.
@@ -211,100 +207,96 @@
 
         Returns:
             UploadFileResult: the empty upload result message if successful
         """
         if src_path is None:
             raise Exception("src_path not specified!")
         if rel_dest_path is not None and abs_dest_path is not None:
-            raise Exception("cannot specify both a relative destination path and an absolute destination path")
+             raise Exception("cannot specify both a relative destination path and an absolute destination path")
         relative = True
         if abs_dest_path is not None:
             relative = False
             dest_path = abs_dest_path
         elif rel_dest_path is not None:
             dest_path = rel_dest_path
         else:
-            # construct the relative path from filename alone
+            #construct the relative path from filename alone
             dest_path = os.path.basename(src_path)
 
-        # check if the file exists
+        #check if the file exists
         path_exists = os.path.exists(src_path)
 
         if path_exists is False:
             raise Exception(f"file '{src_path}' does not exist ")
         else:
             # msg = UploadFileRequest()
             # msg.overwrite = overwrite
             # msg.open_on_complete = open_file_on_complete
             
-            ok, result, connector_id = self._hub_client.do_client_streaming("cegal.hub.agent", "cegal.hub.agent.upload_file",
-                                                                            _upload_message_from_file(src_path, dest_path, overwrite, relative),
-                                                                            connector_filter=self.connector_filter, major_version=1, minor_version=0)
+            ok, result, connector_id = self._hub_client.do_client_streaming("cegal.hub.agent","cegal.hub.agent.upload_file", _upload_message_from_file(src_path,dest_path,overwrite, relative, open_file_on_complete), connector_filter=self.connector_filter, major_version=1,minor_version=0)
             if (ok):
                 response = UploadFileResult()
                 result.Unpack(response)
                 logger.debug(response)
                 return response
             else:
                 logger.warning(f"failed to upload file {src_path}: to agent {result} on connector_id {connector_id}")
                 raise Exception(f"failed to upload file {src_path}: to agent {result} on connector_id {connector_id}")
 
-    def download_file(self, src_path: str, dest_path: str, overwrite: bool = False):
+    def download_file(self, src_path: str, dest_path: str, overwrite: bool=False ):
         """Download a file from a Cegal Hub Agent (if permitted by the Agent).
 
         Args:
             src_path (str): the src path of the file on the Agent
             dest_path (str): the destination path to save the file locally.
             overwrite (bool, optional): Whether or not to permit file overwrite if the file exists locally. Defaults to False.
 
         Raises:
             Exception: If there was an issue downloading the file.
-        """
+        """        
         if src_path is None or dest_path is None:
             raise Exception(f"both src_path and dest_path must be specified")
         path_exists = os.path.exists(dest_path)
         if path_exists is True and overwrite is False:
             raise Exception(f"the destination file '{dest_path}' already exists but overwrite is not specified")
         msg = DownloadFileRequest()
         msg.path = src_path
         payload = Any()
         payload.Pack(msg)
 
         try:
-            with open(dest_path, 'wb') as f:
-                responses = self._hub_client.do_server_streaming("cegal.hub.agent", "cegal.hub.agent.download_file", payload,
-                                                                 connector_filter=self.connector_filter, major_version=1, minor_version=0)
-                cid = ""
+            with open(dest_path, 'wb') as f: 
+            
+                responses = self._hub_client.do_server_streaming("cegal.hub.agent", "cegal.hub.agent.download_file", payload, connector_filter=self.connector_filter, major_version=1,minor_version=0)
+                cid =""
                 for ok, resp, connector_id in responses:
                     if not ok:
                         logger.warning(f"error downloading file: {resp} on connector_id {connector_id}")
                         raise Exception(f"error from Agent download file: {resp} on connector_id {connector_id}")
-                    cid = connector_id
+                    cid = connector_id 
                     data = DownloadFileResult()
                     resp.Unpack(data)
                     f.write(data.file_bytes)
                 logger.debug(f"download file finished on connector_id {cid}")
         except Exception as error:
             path_exists = os.path.exists(dest_path)
             os.remove(path=dest_path)
             raise Exception(error)
         return
 
-
-def _upload_message_from_file(filename, dest_path, overwrite, relative):
-    one_time = False
+def _upload_message_from_file(filename, dest_path, overwrite, relative, open_file_on_complete):
     with open(filename, "rb") as f:
         while True:
             msg = UploadFileRequest()
+            msg.open_on_complete = open_file_on_complete
             if relative:
                 msg.relative_path = dest_path
             else:
-                msg.absolute_path = dest_path
+                msg.absolute_path = dest_path    
             msg.overwrite = overwrite
             bytes = f.read(1024)
             msg.file_bytes = bytes
             payload = Any()
             payload.Pack(msg)
-            if not bytes and one_time:
+            if not bytes:
                 break
-            one_time = True
-            yield (payload)
+            yield(payload)
```

## cegalprizm/hub/agent_pb2.py

```diff
@@ -16,15 +16,15 @@
 
 DESCRIPTOR = _descriptor.FileDescriptor(
   name='cegalprizm/hub/agent.proto',
   package='hub',
   syntax='proto3',
   serialized_options=b'Z\007./agent',
   create_key=_descriptor._internal_create_key,
-  serialized_pb=b'\n\x1a\x63\x65galprizm/hub/agent.proto\x12\x03hub\"\x9d\x01\n\x10ListFilesRequest\x12\x11\n\troot_path\x18\x01 \x01(\t\x12\x11\n\trecursive\x18\x02 \x01(\x08\x12\x0e\n\x06suffix\x18\x03 \x01(\t\x12\x1f\n\x17skip_folder_starts_with\x18\x04 \x03(\t\x12\x1c\n\x14skip_folder_contains\x18\x05 \x03(\t\x12\x14\n\x0ctimeout_secs\x18\x06 \x01(\x05\"~\n\x0fListFilesResult\x12\r\n\x05paths\x18\x01 \x03(\t\x12\x19\n\x11num_dirs_searched\x18\x02 \x01(\x03\x12\x18\n\x10num_dirs_skipped\x18\x03 \x01(\x03\x12\x12\n\nnum_errors\x18\x04 \x01(\x03\x12\x13\n\x0bnum_results\x18\x05 \x01(\x03\"\xc9\x01\n\x18LaunchApplicationRequest\x12\x14\n\x0cprofile_name\x18\x01 \x01(\t\x12\x18\n\x10\x65nv_var_override\x18\x02 \x01(\t\x12\x0c\n\x04\x61rgs\x18\x03 \x03(\t\x12\x1d\n\x15override_default_args\x18\x04 \x01(\x08\x12\x18\n\x10is_hub_connector\x18\x05 \x01(\x08\x12\x18\n\x10wait_for_connect\x18\x06 \x01(\x08\x12\x1c\n\x14\x63onnect_timeout_secs\x18\x07 \x01(\x05\"C\n\x17LaunchApplicationResult\x12\x12\n\nprocess_id\x18\x01 \x01(\x05\x12\x14\n\x0c\x63onnector_id\x18\x02 \x01(\t\"E\n\x13\x44ownloadFileRequest\x12 \n\thash_type\x18\x01 \x01(\x0e\x32\r.hub.HashType\x12\x0c\n\x04path\x18\x02 \x01(\t\"6\n\x12\x44ownloadFileResult\x12\x12\n\nfile_bytes\x18\x01 \x01(\x0c\x12\x0c\n\x04hash\x18\x02 \x01(\t\"\x98\x01\n\x11UploadFileRequest\x12 \n\thash_type\x18\x01 \x01(\x0e\x32\r.hub.HashType\x12\x0c\n\x04hash\x18\x02 \x01(\t\x12\x15\n\rrelative_path\x18\x03 \x01(\t\x12\x15\n\rabsolute_path\x18\x04 \x01(\t\x12\x11\n\toverwrite\x18\x05 \x01(\x08\x12\x12\n\nfile_bytes\x18\x06 \x01(\x0c\"\x12\n\x10UploadFileResult*+\n\x08HashType\x12\n\n\x06NOHASH\x10\x00\x12\x07\n\x03MD5\x10\x01\x12\n\n\x06SHA256\x10\x02\x42\tZ\x07./agentb\x06proto3'
+  serialized_pb=b'\n\x1a\x63\x65galprizm/hub/agent.proto\x12\x03hub\"\x9d\x01\n\x10ListFilesRequest\x12\x11\n\troot_path\x18\x01 \x01(\t\x12\x11\n\trecursive\x18\x02 \x01(\x08\x12\x0e\n\x06suffix\x18\x03 \x01(\t\x12\x1f\n\x17skip_folder_starts_with\x18\x04 \x03(\t\x12\x1c\n\x14skip_folder_contains\x18\x05 \x03(\t\x12\x14\n\x0ctimeout_secs\x18\x06 \x01(\x05\"~\n\x0fListFilesResult\x12\r\n\x05paths\x18\x01 \x03(\t\x12\x19\n\x11num_dirs_searched\x18\x02 \x01(\x03\x12\x18\n\x10num_dirs_skipped\x18\x03 \x01(\x03\x12\x12\n\nnum_errors\x18\x04 \x01(\x03\x12\x13\n\x0bnum_results\x18\x05 \x01(\x03\"\xc9\x01\n\x18LaunchApplicationRequest\x12\x14\n\x0cprofile_name\x18\x01 \x01(\t\x12\x18\n\x10\x65nv_var_override\x18\x02 \x01(\t\x12\x0c\n\x04\x61rgs\x18\x03 \x03(\t\x12\x1d\n\x15override_default_args\x18\x04 \x01(\x08\x12\x18\n\x10is_hub_connector\x18\x05 \x01(\x08\x12\x18\n\x10wait_for_connect\x18\x06 \x01(\x08\x12\x1c\n\x14\x63onnect_timeout_secs\x18\x07 \x01(\x05\"C\n\x17LaunchApplicationResult\x12\x12\n\nprocess_id\x18\x01 \x01(\x05\x12\x14\n\x0c\x63onnector_id\x18\x02 \x01(\t\"E\n\x13\x44ownloadFileRequest\x12 \n\thash_type\x18\x01 \x01(\x0e\x32\r.hub.HashType\x12\x0c\n\x04path\x18\x02 \x01(\t\"6\n\x12\x44ownloadFileResult\x12\x12\n\nfile_bytes\x18\x01 \x01(\x0c\x12\x0c\n\x04hash\x18\x02 \x01(\t\"\xb2\x01\n\x11UploadFileRequest\x12 \n\thash_type\x18\x01 \x01(\x0e\x32\r.hub.HashType\x12\x0c\n\x04hash\x18\x02 \x01(\t\x12\x15\n\rrelative_path\x18\x03 \x01(\t\x12\x15\n\rabsolute_path\x18\x04 \x01(\t\x12\x11\n\toverwrite\x18\x05 \x01(\x08\x12\x12\n\nfile_bytes\x18\x06 \x01(\x0c\x12\x18\n\x10open_on_complete\x18\x07 \x01(\x08\"\x12\n\x10UploadFileResult*+\n\x08HashType\x12\n\n\x06NOHASH\x10\x00\x12\x07\n\x03MD5\x10\x01\x12\n\n\x06SHA256\x10\x02\x42\tZ\x07./agentb\x06proto3'
 )
 
 _HASHTYPE = _descriptor.EnumDescriptor(
   name='HashType',
   full_name='hub.HashType',
   filename=None,
   file=DESCRIPTOR,
@@ -44,16 +44,16 @@
       name='SHA256', index=2, number=2,
       serialized_options=None,
       type=None,
       create_key=_descriptor._internal_create_key),
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=898,
-  serialized_end=941,
+  serialized_start=924,
+  serialized_end=967,
 )
 _sym_db.RegisterEnumDescriptor(_HASHTYPE)
 
 HashType = enum_type_wrapper.EnumTypeWrapper(_HASHTYPE)
 NOHASH = 0
 MD5 = 1
 SHA256 = 2
@@ -424,28 +424,35 @@
     _descriptor.FieldDescriptor(
       name='file_bytes', full_name='hub.UploadFileRequest.file_bytes', index=5,
       number=6, type=12, cpp_type=9, label=1,
       has_default_value=False, default_value=b"",
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='open_on_complete', full_name='hub.UploadFileRequest.open_on_complete', index=6,
+      number=7, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
   ],
   extensions=[
   ],
   nested_types=[],
   enum_types=[
   ],
   serialized_options=None,
   is_extendable=False,
   syntax='proto3',
   extension_ranges=[],
   oneofs=[
   ],
   serialized_start=724,
-  serialized_end=876,
+  serialized_end=902,
 )
 
 
 _UPLOADFILERESULT = _descriptor.Descriptor(
   name='UploadFileResult',
   full_name='hub.UploadFileResult',
   filename=None,
@@ -461,16 +468,16 @@
   ],
   serialized_options=None,
   is_extendable=False,
   syntax='proto3',
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=878,
-  serialized_end=896,
+  serialized_start=904,
+  serialized_end=922,
 )
 
 _DOWNLOADFILEREQUEST.fields_by_name['hash_type'].enum_type = _HASHTYPE
 _UPLOADFILEREQUEST.fields_by_name['hash_type'].enum_type = _HASHTYPE
 DESCRIPTOR.message_types_by_name['ListFilesRequest'] = _LISTFILESREQUEST
 DESCRIPTOR.message_types_by_name['ListFilesResult'] = _LISTFILESRESULT
 DESCRIPTOR.message_types_by_name['LaunchApplicationRequest'] = _LAUNCHAPPLICATIONREQUEST
```

## cegalprizm/hub/base_ctx.py

```diff
@@ -15,15 +15,15 @@
     to communicate with a specific Connector type"""
 
     def __init__(self, hub_client: HubClient, wellknown_connector_id: str, connector_filter: ConnectorFilter = None):
         """Create a BaseContext from the specified parameters
 
         Args:
             hub_client (HubClient): The HubClient which makes client requests to Cegal Hub Server.
-            wellknown_connector_id (str): the wellknown string that represents the Connector type. i.e cegal.hub.agent or cegal.hub.petrel
+            wellknown_connector_id (str): the wellknown string that represents the Connector type. i.e cegal.hub.agentor cegal.hub.petrel
             connector_filter (ConnectorFilter, optional): the filter for targeting a specific instance or instances of a Connector type. Defaults to None.
         """
         self._hub_client = hub_client
         self._wellknown_connector_id = wellknown_connector_id
         if connector_filter is None:
             logger.debug("no ConnectorFilter specified")
             connector_filter = ConnectorFilter()
@@ -37,15 +37,15 @@
         """Get the available Cegal Hub Connectors
 
         Raises:
             Exception: If there was a problem obtaining the available Cegal Hub Connectors
 
         Returns:
             Connector[]: An enumeration of objects for available Connectors
-        """
+        """        
         stub = self._hub_client.server_request_stub
         msg = ConnectorQuery()
         msg.filter.connector_instance_id = self._connector_filter.target_connector_id
         msg.filter.wellknown_identifier = self._wellknown_connector_id
         if self._connector_filter._labels_dict:
             for k in self._connector_filter._labels_dict.keys():
                 msg.filter.labels[k] = self._connector_filter._labels_dict[k]
@@ -59,24 +59,24 @@
 
     @property
     def connector_filter(self):
         """Get the ConnectorFilter associated with the context.
 
         Returns:
             ConnectorFilter: The ConnectorFilter object.
-        """
+        """        
         return self._connector_filter
 
     @connector_filter.setter
     def connector_filter(self, connector_filter=None):
         """Set the ConnectorFilter on the context.
 
         Args:
             connector_filter ([type], optional): The ConnectorFilter object. Defaults to None.
-        """
+        """        
         if connector_filter is None:
             connector_filter = ConnectorFilter()
         self._connector_filter = connector_filter
 
     @property
     def connection_parameters(self):
         """Get a deep copy of the ConnectionParameters corresponding to the running Cegal Hub Server
```

## cegalprizm/hub/capability.py

```diff
@@ -1,16 +1,16 @@
 # Copyright 2023 Cegal AS
 # All rights reserved.
 # Unauthorized copying of this file, via any medium is strictly prohibited.
 #
 # This file contains the HubCapability class which is used to represent a Hub task that can be executed by
-# a HubConnector. The HubCapability class is a wrapper class Is a wrapper class that holds a task as a lambda,
+# a HubConnector. The HubCapability class is a wrapper class Is a wrapper class that holds a task as a lambda, 
 # as well as, information about the task. Information includes:
 # * version numbers
-# * description
+# * description 
 # * auth requirements
 
 from types import FunctionType
 from enum import Enum
 
 from .payload_auth import PayloadAuth
```

## cegalprizm/hub/client.py

```diff
@@ -25,34 +25,34 @@
     """
     def __init__(self, connection_parameters: ConnectionParameters = None, token_provider=None):
         """Create a HubClient utility object for making Cegal Hub Connector requests via a Cegal Hub Server.
 
         Args:
             connection_parameters (ConnectionParameters, optional): The configuration details to communicate with a running Cegal Hub Server. Defaults to None.
             token_provider (token_provider, optional): Most often an OidcClient object. Defaults to None.
-        """
+        """        
         super().__init__(connection_parameters, token_provider)
         self._connector_request_stub = ConnectorRequestServiceStub(self._channel)
         self._server_request_stub = ServerServiceStub(self._channel)
         self._connection_parameters = connection_parameters
 
     def do_unary_request(self, wellknown_connector_identifier, wellknown_payload_identifier, payload, connector_filter: ConnectorFilter = None, major_version: int = 0, minor_version: int = 0):
         """Make a unary GRPC client request against a wellknown Cegal Hub Connector type and wellknown payload identifier via a running Cegal Hub Server.
 
         Args:
-            wellknown_connector_identifier (str): The wellknown identifier of a Cegal Hub Connector type such as cegal.hub.agent or cegal.hub.petrel
+            wellknown_connector_identifier (str): The wellknown identifier of a Cegal Hub Connector type such as cegal.hub.agent or cegal.hub.petrel 
             wellknown_payload_identifier (str): The wellknown payload identifier (functionality supported by the Cegal Hub Connector) such as cegal.hub.agent.list_files
             payload (Any): A protobuf Any object
             major_version (int): The major version number for the payload
             minor_version (int): The minor version number for the payload
             connector_filter (ConnectorFilter, optional): A ConnectorFilter to help target a specific Connector instance(s). Defaults to None.
 
         Returns:
             tuple: A tuple containing a success / failure bool, the result Any payload and the connector instance identifier str that handled the request
-        """
+        """        
         if connector_filter is None:
             connector_filter = ConnectorFilter()
         request = ConnectorRequest(
             wellknown_connector_identifier=wellknown_connector_identifier,
             wellknown_payload_identifier=wellknown_payload_identifier,
             payload_major_version=major_version,
             payload_minor_version=minor_version,
@@ -72,35 +72,35 @@
             logger.debug(f"unary result: error: {result.error_message}, connector id: {result.connector_id}")
             return (False, result.error_message, result.connector_id)
 
     def do_server_streaming(self, wellknown_connector_identifier: str, wellknown_payload_identifier: str, payload, connector_filter: ConnectorFilter = None, major_version: int = 0, minor_version: int = 0):
         """Make a server streaming GRPC client request against a wellknown Cegal Hub Connector type and wellknown payload identifier via a running Cegal Hub Server.
 
         Args:
-            wellknown_connector_identifier (str): The wellknown identifier of a Cegal Hub Connector type such as cegal.hub.agent or cegal.hub.petrel
+            wellknown_connector_identifier (str): The wellknown identifier of a Cegal Hub Connector type such as cegal.hub.agent or cegal.hub.petrel 
             wellknown_payload_identifier (str): The wellknown payload identifier (functionality supported by the Cegal Hub Connector) such as cegal.hub.agent.list_files
             payload (Any): A protobuf Any object
             connector_filter (ConnectorFilter, optional): A ConnectorFilter to help target a specific Connector instance(s). Defaults to None.
             major_version (int): The major version number for the payload
             minor_version (int): The minor version number for the payload
 
         Yields:
             tuple: A tuple containing a success / failure bool, the result Any payload and the connector instance identifier str that handled the request
-        """
+        """        
         if connector_filter is None:
             connector_filter = ConnectorFilter()
         request = ConnectorRequest(
             wellknown_connector_identifier=wellknown_connector_identifier,
             wellknown_payload_identifier=wellknown_payload_identifier,
             target_connector_id=connector_filter.target_connector_id,
             payload=payload,
             payload_major_version=major_version,
             payload_minor_version=minor_version,
         )
-
+          
         if connector_filter.labels_dict:
             for k in connector_filter.labels_dict.keys():
                 request.labels[k] = connector_filter.labels_dict[k]
         logger.debug(f"server streaming request: wellknown connector identifier: {request.wellknown_connector_identifier}, wellknown payload identifier: {request.wellknown_payload_identifier}, target connector id: {request.target_connector_id}, labels: {request.labels}, payload major version: {request.payload_major_version},  payload minor version: {request.payload_minor_version}")
         responses = self.connector_request_stub.DoServerStreaming(request)
         for result in responses:
             if (result.ok):
@@ -110,27 +110,27 @@
                 logger.debug(f"server streaming result: error: {result.error_message}, connector id: {result.connector_id}")
                 yield (False, result.error_message, result.connector_id)
 
     def do_client_streaming(self, wellknown_connector_identifier: str, wellknown_payload_identifier: str, iterable_payloads: Iterable, connector_filter: ConnectorFilter = None, major_version: int = 0, minor_version: int = 0):
         """Make a client streaming GRPC client request against a wellknown Cegal Hub Connector type and wellknown payload identifier via a running Cegal Hub Server.
 
         Args:
-            wellknown_connector_identifier (str): The wellknown identifier of a Cegal Hub Connector type such as cegal.hub.agent or cegal.hub.petrel
+            wellknown_connector_identifier (str): The wellknown identifier of a Cegal Hub Connector type such as cegal.hub.agent or cegal.hub.petrel 
             wellknown_payload_identifier (str): The wellknown payload identifier (functionality supported by the Cegal Hub Connector) such as cegal.hub.agent.list_files
             iterable_payloads (Iterable): The client payloads to stream to the Cegal Hub Connector
             major_version (int): The major version number for the payload
             minor_version (int): The minor version number for the payload
             connector_filter (ConnectorFilter, optional): A ConnectorFilter to help target a specific Connector instance(s). Defaults to None.
 
         Returns:
             tuple: A tuple containing a success / failure bool, the result Any payload and the connector instance identifier str that handled the request
 
         Yields:
             [type]: [description]
-        """
+        """        
         if connector_filter is None:
             connector_filter = ConnectorFilter()
 
         def wrap_iterable_payloads(it_p):
             for payload in it_p:
                 request = ConnectorRequest(
                     wellknown_connector_identifier=wellknown_connector_identifier,
@@ -139,15 +139,15 @@
                     payload=payload,
                     payload_major_version=major_version,
                     payload_minor_version=minor_version,
                 )
                 if connector_filter.labels_dict:
                     for k in connector_filter.labels_dict.keys():
                         request.labels[k] = connector_filter.labels_dict[k]
-                logger.debug(f"client streaming request: wellknown connector identifier: {request.wellknown_connector_identifier}, wellknown payload identifier: {request.wellknown_payload_identifier}, target connector id: {request.target_connector_id}, labels: {request.labels}, payload major version: {request.payload_major_version},  payload minor version: {request.payload_minor_version}")
+                logger.debug(f"client streaming request: wellknown connector identifier: {request.wellknown_connector_identifier}, wellknown payload identifier: {request.wellknown_payload_identifier}, target connector id: {request.target_connector_id}, labels: {request.labels}, payload major version: {request.payload_major_version},  payload minor version: {request.payload_minor_version}")        
                 yield request
 
         result = self.connector_request_stub.DoConnectorInstanceClientStreaming(wrap_iterable_payloads(iterable_payloads))
 
         if (result.ok):
             logger.debug(f"client streaming result ok: connector id {result.connector_id}")
             return (True, result.payload, result.connector_id)
@@ -157,32 +157,32 @@
 
     @property
     def connector_request_stub(self):
         """The service stub for clients to communicate with Cegal Hub Connectors
 
         Returns:
             ConnectorRequestServiceStub: The service stub for clients to communicate with Cegal Hub Connectors
-        """
+        """        
         return self._connector_request_stub
 
     @property
     def server_request_stub(self):
         """The service stub for clients to communicate with a Cegal Hub Server
 
         Returns:
             ServerServiceStub: The service stub for clients to communicate with a Cegal Hub Server
-        """
+        """        
         return self._server_request_stub
 
     @property
     def connection_parameters(self):
         """The ConnectionParameters object associated with the running Cegal Hub Server.
 
         Returns:
             ConnectionParameters: The ConnectionParameters object associated with the running Cegal Hub Server.
-        """
+        """        
         return self._connection_parameters
 
     def close(self):
         """Close the underlying GRPC channel.
         """
         self._channel.close()
```

## cegalprizm/hub/client_config.py

```diff
@@ -1,93 +1,71 @@
 # Copyright 2023 Cegal AS
 # All rights reserved.
 # Unauthorized copying of this file, via any medium is strictly prohibited.
 
 import os
-
+from . import logger
 
 class ClientConfig():
     """Global configuration for the Python client communicating with a running Cegal Hub Server. This is used primarily with ConnectionParameters objects.
-    When a ConnectionParameters object is created but no values are provided, the ConnectionParameters object will rely on the ClientConfig and ServerConfig
+    When a ConnectionParameters object is created but no values are provided, the ConnectionParameters object will rely on the ClientConfig and ServerConfig 
     global configurations for defaults.
     """
 
     __use_auth: bool = None
+    __user_access_token: str = None
 
     @staticmethod
     def set_use_auth(use_auth: bool):
         """Update the ClientConfig to use auth or not.
 
         Args:
             use_auth (bool): True to indicate authentication should be used, False otherwise.
-        """
+        """        
         ClientConfig.__use_auth = use_auth
 
     @staticmethod
     def get_use_auth():
         """Get the configuration for whether or not to use authentication. This will look for an environment variable called CEGAL_HUB_USE_AUTH
         which it will expect to be set to True or False.
 
         Returns:
             [bool]: Whether or not to use authentication.
-        """
+        """  
         if ClientConfig.__use_auth is None:
             val = ClientConfig.__get_envvar("CEGAL_HUB_USE_AUTH")
             if val[0]:
                 return val[1].lower() == "true"
             else:
                 return False
         else:
             return ClientConfig.__use_auth
 
     @staticmethod
-    def is_user_impersonation_active() -> bool:
-        """Is a user impersonation token defined.
-
-        Returns:
-            [bool]: True if active, false otherwise
-        """
-        val = ClientConfig.__get_envvar("CEGAL_HUB_IMPERSONATION_TOKEN")
-        if val[0]:
-            return len(val[1]) > 0 and not val[1].isspace()
-        else:
-            return False
-
-    @staticmethod
-    def set_user_impersonation_token(token: str):
-        """Set the predefined impersonation token.
+    def set_user_access_token(token: str):
+        """Set the predefined user access token.
 
         Args:
-            token (str): The impersonation token to use. Set to None to clear the user impersonation token and restore the default behaviour
+            token (str): The access token to use. Set to None to clear the user access token and restore the default behaviour
         """
-        if token:
-            ClientConfig.__set_envvar("CEGAL_HUB_IMPERSONATION_TOKEN", token)
-        else:
-            ClientConfig.__set_envvar("CEGAL_HUB_IMPERSONATION_TOKEN", "")
+        ClientConfig.__user_access_token = token
 
     @staticmethod
-    def get_user_impersonation_token() -> str:
-        """Get a predefined user impersonation token if defined.
+    def get_user_access_token() -> str:
+        """Get a predefined user access token if defined.
 
         Returns:
-            [str]: The impersonation token, if None no user impersonation token is defined
+            [str]: The access token, if None no user access token is defined
         """
-        val = ClientConfig.__get_envvar("CEGAL_HUB_IMPERSONATION_TOKEN")
-        if val[0]:
-            return val[1]
-        else:
-            return None
+        return ClientConfig.__user_access_token
 
     @staticmethod
     def __get_envvar(key: str):
+        env = os.environ
         try:
-            return (True, os.environ[key])
+            return (True, env[key])
         except:
             return (False, "")
 
     @staticmethod
-    def __set_envvar(key: str, value: str):
-        os.environ[key] = value
-
-    @staticmethod
     def __repr__():
         return "use auth:" + repr(ClientConfig.get_use_auth())
```

## cegalprizm/hub/connection_parameters.py

```diff
@@ -37,36 +37,36 @@
 
     @property
     def host(self):
         """Get the host address of the Cegal Hub Server.
 
         Returns:
             str: The host address of the Cegal Hub Server.
-        """
+        """        
         return self._host
 
     @property
     def port(self):
         """Get the port that the Cegal Hub Server runs on.
 
         Returns:
             str: The port that the Cegal Hub Server runs on.
-        """
+        """        
         return self._port
 
     @property
     def use_tls(self):
         """Whether the Cegal Hub Server is running with TLS.
 
         Returns:
             bool: Whether the Cegal Hub Server is running with TLS.
-        """
+        """        
         return self._use_tls
 
     @property
     def use_auth(self):
         """Whether to use authentication when connecting with the Cegal Hub Server.
 
         Returns:
             bool: Whether to use authentication when connecting with the Cegal Hub Server.
-        """
-        return self._use_auth
+        """        
+        return self._use_auth
```

## cegalprizm/hub/connector.py

```diff
@@ -21,125 +21,31 @@
 import threading
 import socket
 import sys
 import time
 import queue
 import traceback
 
-from multiprocessing.pool import ThreadPool
-
-import grpc
-
 from . import logger
 from .capability import TaskType
 from .connection_parameters import ConnectionParameters
-from .connector_task_service_pb2 import CONNECTOR_UNARY, CONNECTOR_STREAMING, CONNECTOR_CLIENT_STREAMING, ConnectorTask, Connect, ConnectorResponse, ConnectorTaskResult, ConnectorTask
+from .connector_task_service_pb2 import CONNECTOR_UNARY, CONNECTOR_STREAMING, CONNECTOR_CLIENT_STREAMING
+from .connector_task_service_pb2 import Connect, ConnectorResponse, ConnectorTaskResult, ConnectorTask
 from .connector_task_service_pb2_grpc import ConnectorTaskServiceStub
 from .hub_channel import HubChannel
-from .server_service_pb2_grpc import ServerServiceStub
-from .server_service_pb2 import CancellationEventsRequest, CancellationEvent 
 from .task_registry import HubTaskRegistry
-from .threadsafe import ConcurrentDictionary, CooperativeCancellationToken
-
-class NotCancellable():
-    pass
 
 class TaskContext():
     def __init__(self, major_version = None, minor_version = None, cancellation_token = None, metadata = None):
         self.major_version = major_version
         self.minor_version = minor_version
         self.cancellation_token = cancellation_token
         self.metadata = metadata
 
-def _create_success_result(rpc_type, request_id, payload):
-    task_result = ConnectorTaskResult()
-    task_result.request_id = request_id
-    task_result.rpc_type = rpc_type
-    task_result.logical_request_completed = True
-    task_result.ok = True
-    task_result.payload.Pack(payload)
-    return task_result
-
-def _create_failure_result(rpc_type, request_id, error_message, is_complete: bool = True):
-    task_result = ConnectorTaskResult()
-    task_result.request_id = request_id
-    task_result.rpc_type = rpc_type
-    task_result.logical_request_completed = is_complete
-    task_result.ok = False
-    task_result.error_message = error_message
-    return task_result
-
-def _create_streaming_result(rpc_type, request_id, payload, is_complete):
-    task_result = ConnectorTaskResult()
-    task_result.request_id = request_id
-    task_result.rpc_type = rpc_type
-    task_result.logical_request_completed = is_complete
-    task_result.ok = True
-    if payload:
-        task_result.payload.Pack(payload)
-    return task_result
-
-
-def _get_hub_user_identity(metadata: Dict[str, str]) -> str:
-    if 'identity' in metadata.keys():
-        return metadata['identity']
-    else:   
-        return "anonymous"
-
-
-def handle_unary_task(task_registry, response_q, connectorTask, task_cancel_dict):
-    logger.info(f"Start Unary: Identity: '{_get_hub_user_identity(connectorTask.metadata)}' Request: {connectorTask.request_id} Task: {connectorTask.payload_identifier} ")
-    task = task_registry.get_unary_task(connectorTask.payload_identifier)
-    if task:
-        sig = inspect.signature(task)
-        if 'ctx' in sig.parameters:
-            cancellation_token = task_cancel_dict.set_if_not_present(connectorTask.request_id, CooperativeCancellationToken())
-            ctx = TaskContext(connectorTask.payload_major_version, connectorTask.payload_minor_version, cancellation_token, connectorTask.metadata)
-            result = task(ctx, connectorTask.payload)
-        else:
-            task_cancel_dict.set_if_not_present(connectorTask.request_id, NotCancellable())
-            result = task(connectorTask.payload)
-        logger.debug(f"Unary result: {result}")
-        if result[0]:
-            task_result = _create_success_result(connectorTask.rpc_type, connectorTask.request_id, result[1])
-        else:
-            task_result = _create_failure_result(connectorTask.rpc_type, connectorTask.request_id, result[2])
-    response_q.put(task_result)
-    task_cancel_dict.remove(connectorTask.request_id)
-    logger.info(f"Complete Unary: Identity: '{_get_hub_user_identity(connectorTask.metadata)}' Request: {connectorTask.request_id} Task: {connectorTask.payload_identifier} ")
-
-
-def handle_server_streaming(task_registry, connectorTask, response_q, task_cancel_dict):
-    logger.info(f"Start ServerStreaming: Identity: '{_get_hub_user_identity(connectorTask.metadata)}' Request: {connectorTask.request_id} Task: {connectorTask.payload_identifier} ")
-    task = task_registry.get_server_streaming_task(connectorTask.payload_identifier)
-    if task:
-        sig = inspect.signature(task)
-        if 'ctx' in sig.parameters:
-            cancellation_token = task_cancel_dict.set_if_not_present(connectorTask.request_id, CooperativeCancellationToken())
-            ctx = TaskContext(connectorTask.payload_major_version, connectorTask.payload_minor_version, cancellation_token, connectorTask.metadata)
-            result_it = task(ctx, connectorTask.payload)
-        else:
-            task_cancel_dict.set_if_not_present(connectorTask.request_id, NotCancellable())
-            result_it = task(connectorTask.payload)
-        for result in result_it:
-            logger.debug(f"Streaming result: {result}")
-            if result[0]:
-                task_result = _create_streaming_result(connectorTask.rpc_type, connectorTask.request_id, result[2], result[1])
-            else:
-                task_result = _create_failure_result(connectorTask.rpc_type, connectorTask.request_id, result[3], result[1])
-            response_q.put(task_result)
-        logger.debug(f"Stream complete")
-    else:
-        logger.warning(f"payload_identifier {connectorTask.payload_identifier} not recognised")
-        task_result = _create_failure_result(connectorTask.rpc_type, connectorTask.request_id, "Server streaming not supported")
-        response_q.put(task_result)
-    task_cancel_dict.remove(connectorTask.request_id)
-    logger.info(f"Finish ServerStreaming: Identity: '{_get_hub_user_identity(connectorTask.metadata)}' Request: {connectorTask.request_id} Task: {connectorTask.payload_identifier} ")
-
-class _HubConnectorSession():
+class HubConnector():
     """A generic HubConnector which can be extended by concrete implementations. This API is considered experimental.
 
     Args:
         HubChannel ([HubChannel]): A HubChannel object which defines the connection to a Cegal Hub Server
 
     """
 
@@ -148,81 +54,28 @@
                  description: str,
                  version: str,
                  build_version: str,
                  connection_parameters: ConnectionParameters = None,
                  token_provider=None,
                  join_token: str = "",
                  supports_public_requests: bool = False,
-                 additional_labels: Dict[str, str] = None,
-                 num_of_concurrent_tasks: int = 1):
+                 additional_labels: Dict[str, str] = None):
         self._response_q = queue.Queue()
         self._wellknown_identifier = wellknown_identifier
         self._friendly_name = friendly_name
         self._description = description
         self._version = version
         self._build_version = build_version
         self._connection_parameters = connection_parameters
         self._token_provider = token_provider
         self._join_token = join_token
         self._supports_public_requests = supports_public_requests
         self._additional_labels = additional_labels
-        self._num_of_concurrent_tasks = num_of_concurrent_tasks
         self._reconnect_id = ""
-        self._lock = threading.Lock()
-        self._cancellation_stream_iterator = None
-        self._do_connector_tasks_iterator = None
-
-
-    def start(self, task_registry: HubTaskRegistry):
-        logger.debug("Starting DoConnectorTask")
-        self._task_cancel_dict = ConcurrentDictionary()
-        connector_id_queue = queue.Queue()
-        self._stop = threading.Event()
-        self._connector_task_thread = threading.Thread(target=self._do_connector_tasks,args=(task_registry,connector_id_queue), daemon=True)
-        self._cancellation_subscription_thread = threading.Thread(target=self._subscribe_to_cancellations, args=(connector_id_queue,), daemon=True)
-        self._connector_task_thread.start()
-        self._cancellation_subscription_thread.start()
-        while self._connector_task_thread.is_alive():
-            time.sleep(0.1)
-        self.stop()
-
-
-    def stop(self):
-        with self._lock:
-            self._stop.set()
-            if self._cancellation_stream_iterator != None:
-                self._cancellation_stream_iterator.cancel()
-            if self._do_connector_tasks_iterator != None:
-                self._do_connector_tasks_iterator.cancel()
-
-
-    @property
-    def cancellation_stream_iterator(self):
-        with self._lock:
-            return self._cancellation_stream_iterator
-        
-
-    @cancellation_stream_iterator.setter
-    def cancellation_stream_iterator(self, value):
-        with self._lock:
-            self._cancellation_stream_iterator = value
-
-
-    @property
-    def do_connector_tasks_iterator(self):
-        with self._lock:
-            return self._do_connector_tasks_iterator
         
-
-    @do_connector_tasks_iterator.setter
-    def do_connector_tasks_iterator(self, value):
-        with self._lock:
-            self._do_connector_tasks_iterator = value
-
-
     def _create_initial_message(self, task_registry: HubTaskRegistry):
         try:
             hostname = os.environ["HOSTNAME"]
         except:
             hostname = socket.gethostname()
 
         connectorInfo = Connect()
@@ -254,15 +107,14 @@
                     connectorInfo.supported_payloads[task.wellknown_payload_identifier].auth.required_blueback_app_claims.append(claim)
 
         if self._additional_labels:
             for key in self._additional_labels.keys():
                 connectorInfo.labels[key] = self._additional_labels[key]
         return connectorInfo
 
-
     def _connector_tasks_iterator(self, task_registry) -> Iterable[ConnectorResponse]:
         info = self._create_initial_message(task_registry)
         initial_response = ConnectorResponse(connect=info)
         yield initial_response
 
         try:
             while True:
@@ -280,143 +132,114 @@
         logger.debug(f"Clearing response q")
         with self._response_q.mutex:
             self._response_q.queue.clear()
             self._response_q.all_tasks_done.notify_all()
             self._response_q.unfinished_tasks = 0
         logger.debug(f"Cleared response q")
 
+    def _create_success_result(self, rpc_type, request_id, payload):
+        task_result = ConnectorTaskResult()
+        task_result.request_id = request_id
+        task_result.rpc_type = rpc_type
+        task_result.logical_request_completed = True
+        task_result.ok = True
+        task_result.payload.Pack(payload)
+        return task_result
 
+    def _create_failure_result(self, rpc_type, request_id, error_message, is_complete: bool = True):
+        task_result = ConnectorTaskResult()
+        task_result.request_id = request_id
+        task_result.rpc_type = rpc_type
+        task_result.logical_request_completed = is_complete
+        task_result.ok = False
+        task_result.error_message = error_message
+        return task_result
+
+    def _create_streaming_result(self, rpc_type, request_id, payload, is_complete):
+        task_result = ConnectorTaskResult()
+        task_result.request_id = request_id
+        task_result.rpc_type = rpc_type
+        task_result.logical_request_completed = is_complete
+        task_result.ok = True
+        if payload:
+            task_result.payload.Pack(payload)
+        return task_result
 
-    def _do_connector_tasks(self, task_registry: HubTaskRegistry, connector_id_queue: queue.Queue):
-        try:
-            sem = threading.Semaphore(self._num_of_concurrent_tasks)
-            pool = ThreadPool(processes=self._num_of_concurrent_tasks)
-            logger.info(f"Registering connector with Cegal Hub")
-            hubChannel = HubChannel(self._connection_parameters, self._token_provider)
-            connector_task_stub = ConnectorTaskServiceStub(hubChannel._channel)
-            self._done = False
-            self.do_connector_tasks_iterator = connector_task_stub.DoConnectorTasks(self._connector_tasks_iterator(task_registry))
-
-            # This is a blocking call, can be cancelled by calling self.stop from another thread
-            for connectorTask in self.do_connector_tasks_iterator:
+    def _do_connector_tasks(self, task_registry: HubTaskRegistry):
+        while True:
+            try:
+                logger.info(f"Attempting to connect to Cegal Hub")
+                hubChannel = HubChannel(self._connection_parameters, self._token_provider)
+                connector_task_stub = ConnectorTaskServiceStub(hubChannel._channel)
+                self._done = False
+                response_iterator = connector_task_stub.DoConnectorTasks(self._connector_tasks_iterator(task_registry))
+                for connectorTask in response_iterator:
                     if connectorTask.acknowledge_connector_joined:
                         self._reconnect_id = connectorTask.connector_id
-                        connector_id_queue.put(connectorTask.connector_id)
                         logger.info(f"Successfully connected")
                         continue
                     
                     logger.debug(f"Task {connectorTask.payload_identifier} {connectorTask.request_id}")
 
                     if connectorTask.rpc_type == CONNECTOR_UNARY:
-                        sem.acquire()
-                        pool.apply_async(handle_unary_task, args=(task_registry, self._response_q, connectorTask, self._task_cancel_dict), callback=lambda x: sem.release())
+                        task = task_registry.get_unary_task(connectorTask.payload_identifier)
+                        if task:
+                            sig = inspect.signature(task)
+                            if 'ctx' in sig.parameters:
+                                ctx = TaskContext(connectorTask.payload_major_version, connectorTask.payload_minor_version, None, connectorTask.metadata)
+                                result = task(ctx, connectorTask.payload)
+                            else:
+                                result = task(connectorTask.payload)
+                            logger.debug(f"Unary result: {result}")
+                            if result[0]:
+                                task_result = self._create_success_result(connectorTask.rpc_type, connectorTask.request_id, result[1])
+                            else:
+                                task_result = self._create_failure_result(connectorTask.rpc_type, connectorTask.request_id, result[2])
+                        else:
+                            logger.warning(f"payload_identifier {connectorTask.payload_identifier} not recognised")
+                            task_result = self._create_failure_result(connectorTask.rpc_type, connectorTask.request_id, f"payload_identifier {connectorTask.payload_identifier} not recognised")
+                        self._response_q.put(task_result)
+
                     elif connectorTask.rpc_type == CONNECTOR_STREAMING:
-                        sem.acquire()
-                        pool.apply_async(handle_server_streaming, args=(task_registry, connectorTask, self._response_q, self._task_cancel_dict), callback=lambda x: sem.release())
+                        task = task_registry.get_server_streaming_task(connectorTask.payload_identifier)
+                        if task:
+                            sig = inspect.signature(task)
+                            if 'ctx' in sig.parameters:
+                                ctx = TaskContext(connectorTask.payload_major_version, connectorTask.payload_minor_version, None, connectorTask.metadata)
+                                result_it = task(ctx, connectorTask.payload)
+                            else:
+                                result_it = task(connectorTask.payload)
+                            for result in result_it:
+                                logger.debug(f"Streaming result: {result}")
+                                if result[0]:
+                                    task_result = self._create_streaming_result(connectorTask.rpc_type, connectorTask.request_id, result[2], result[1])
+                                else:
+                                    task_result = self._create_failure_result(connectorTask.rpc_type, connectorTask.request_id, result[3], result[1])
+                                self._response_q.put(task_result)
+                            logger.debug(f"Stream complete")
+                        else:
+                            logger.warning(f"payload_identifier {connectorTask.payload_identifier} not recognised")
+                            task_result = self._create_failure_result(connectorTask.rpc_type, connectorTask.request_id, "Server streaming not supported")
+                            self._response_q.put(task_result)
+
                     else:
                         logger.error(f"Unknown RpcType {connectorTask}")
                         task_result = self._create_failure_result(connectorTask.rpc_type, connectorTask.request_id, "Unknown rpc type")
                         self._response_q.put(task_result)
-        except Exception as error:
-            logger.error(f"_do_connector_tasks: {error}: {error.args}")
-            logger.error(f"_do_connector_tasks: {traceback.format_exc()}")
-            self._done = True
-        finally:
+
+            except Exception as error:
+                logger.error(f"_do_connector_tasks: {error}: {error.args}")
+                logger.error(f"_do_connector_tasks: {traceback.format_exc()}")
+                self._done = True
+
             logger.debug(f"Clearing response q")
             with self._response_q.mutex:
                 self._response_q.queue.clear()
                 self._response_q.all_tasks_done.notify_all()
                 self._response_q.unfinished_tasks = 0
             logger.debug(f"Cleared response q")
-            logger.debug(f"Completed with {len(self._task_cancel_dict)} unfinished tasks.")
             hubChannel.close()
-            pool.close()
-            self._stop.set()
-
-    def _subscribe_to_cancellations(self, connector_id_queue: queue.Queue):
-        # We need the connector id, it is set at the first message from do_connector_tasks endpoint
-        # lets wait until we get it. Cancel if stop is set.
-        connector_id = None
-        while connector_id == None:
-            try:
-                connector_id = connector_id_queue.get(block=True, timeout=2)
-            except queue.Empty:
-                if self._stop.is_set():
-                    return
-
-        try:
-            logger.info(f"Attempting to connect to Cegal Hub")
-            hubChannel = HubChannel(self._connection_parameters, self._token_provider)
-            server_service_stub = ServerServiceStub(hubChannel._channel)
-
-            cancellation_events_request = CancellationEventsRequest(connector_id=connector_id)
-            self.cancellation_stream_iterator = server_service_stub.GetCancellationEvents(cancellation_events_request)
-
-            # This is a blocking call, can be cancelled by calling self.stop from another thread
-            for connectorTask in self.cancellation_stream_iterator:
-                cancellation_token = self._task_cancel_dict.get(connectorTask.request_id)
-                if type(cancellation_token) == CooperativeCancellationToken:
-                    cancellation_token.cancel()
-                    logger.info(f"\033[92m Cancellation request for {connectorTask.request_id} acknowledged \033[00m")
-                elif type(cancellation_token) == NotCancellable:
-                    logger.info(f"\033[91m Cancellation request for {connectorTask.request_id} not supported \033[00m")
-                else:
-                    logger.info(f"\033[93m Cancellation request for {connectorTask.request_id} not found \033[00m")
-        except grpc._channel._MultiThreadedRendezvous as error:
-            if error.cancelled():
-                logger.info(f"_subscribe_to_cancellations: Cancelled")
-            else:
-                logger.error(f"_subscribe_to_cancellations: {error}: {error.args}")
-                logger.error(f"_subscribe_to_cancellations: {traceback.format_exc()}")
-        except Exception as error:
-            logger.error(f"_subscribe_to_cancellations: {error}: {error.args}")
-            logger.error(f"_subscribe_to_cancellations: {traceback.format_exc()}")
-        finally:
-            hubChannel.close()
-
-
-class HubConnector():
-    """A generic HubConnector which can be extended by concrete implementations. This API is considered experimental.
-
-    Args:
-        HubChannel ([HubChannel]): A HubChannel object which defines the connection to a Cegal Hub Server
-
-    """
-
-    def __init__(self, 
-                 wellknown_identifier: str,
-                 friendly_name: str,
-                 description: str,
-                 version: str,
-                 build_version: str,
-                 connection_parameters: ConnectionParameters = None,
-                 token_provider=None,
-                 join_token: str = "",
-                 supports_public_requests: bool = False,
-                 additional_labels: Dict[str, str] = None,
-                 num_of_concurrent_tasks: int = 1):
-        self._kw = { 
-                        "wellknown_identifier":wellknown_identifier,
-                        "friendly_name":friendly_name,
-                        "description":description,
-                        "version":version,
-                        "build_version":build_version,
-                        "connection_parameters":connection_parameters,
-                        "token_provider":token_provider,
-                        "join_token":join_token,
-                        "supports_public_requests":supports_public_requests,
-                        "additional_labels":additional_labels,
-                        "num_of_concurrent_tasks":num_of_concurrent_tasks
-                }
-
-
-    def start(self, task_registry: HubTaskRegistry, auto_reconnect=True):
-        while True:
-            self._session = _HubConnectorSession(**self._kw)
-            self._session.start(task_registry)
-            if not auto_reconnect:
-                break
             time.sleep(10)
 
-
-    def stop(self):
-        self._session.stop()
+    def start(self, task_registry: HubTaskRegistry):
+        logger.debug("Starting DoConnectorTask")
+        threading.Thread(target=self._do_connector_tasks(task_registry), daemon=True).start()
```

## cegalprizm/hub/connector_filter.py

```diff
@@ -1,19 +1,19 @@
 # Copyright 2023 Cegal AS
 # All rights reserved.
 # Unauthorized copying of this file, via any medium is strictly prohibited.
 #
-# This file contains the ConnectorFilter class which is used to target a particular instances of a Connector that is joined
+# This file contains the ConnectorFilter class which is used to target a particular instances of a Connector that is joined 
 # to Cegal Hub Server. It filters possible connectors based on either a target_connector_id or a labels_dict.
 
 
 class ConnectorFilter():
     """A filter to target a particular instance of a Connector that is joined to Cegal Hub Server.
     If a target_connector_id is provided this ensures that a connector with given id will be addressed.
-    Alternatively a dictionary of labels may be provided. This dictionary of strings are key - value pairs
+    Alternatively a dictionary of labels may be provided. This dictionary of strings are key - value pairs 
     for labels that a Connector has. Any specified labels must be satisfied by the Connector for that Connector to be targeted.
     A target_connector_id is always used in preference to any labels that are defined."""
 
     def __init__(self, target_connector_id: str = None, labels_dict=None):
         """Creates a ConnectionFilter from the given parameters
 
         Args:
@@ -24,48 +24,49 @@
             target_connector_id = ""
         self._target_connector_id = target_connector_id
         if labels_dict is None:
             labels_dict = {}
         self._labels_dict = labels_dict
 
     def __repr__(self):
-        return "target_connector_id: " + self._target_connector_id + ", labels:" + repr(self._labels_dict)
+        return "target_connector_id: " + self._target_connector_id + ", labels:" + repr(self._labels_dict) 
 
     @property
     def labels_dict(self):
         """The current labels dictionary key values
 
         Returns:
             [type]: The current key-values labels dictionary
-        """
+        """        
         return self._labels_dict
 
     @labels_dict.setter
     def labels(self, labels_dict=None):
         """Update with a new key-values dictionary for the labels
 
         Args:
             labels_dict ([type], optional): The new dictionary key-values for the labels. Defaults to None.
-        """
+        """        
         if labels_dict is None:
             labels_dict = {}
         self._labels_dict = labels_dict
 
     @property
     def target_connector_id(self):
         """Gets the target connector id that the ConnectorFilter will use to target a specific Connector instance
 
         Returns:
             [str]: The identifier representing the target connector for the ConnectorFilter
-        """
+        """        
         return self._target_connector_id
 
     @target_connector_id.setter
     def target_connector_id(self, target_connector_id=None):
         """Updates the ConnectorFilter to set the identifier of the Connector which will be used for targeting
 
         Args:
             target_connector_id ([str], optional): The identifier of the Connector used for targeting. Defaults to None.
-        """
+        """        
         if target_connector_id is None:
             target_connector_id = ""
         self._target_connector_id = target_connector_id
+
```

## cegalprizm/hub/hub.py

```diff
@@ -19,37 +19,36 @@
 from cegalprizm.hub import __version__
 
 
 class Hub:
     """Provides access to communicate with an instance of a running Cegal Hub Server. The Cegal Hub Server may be local or remote. A Hub instance
     provides helper methods to make Cegal Hub Server queries and access to Cegal Hub Petrel Connectors and Cegal Hub Agent Connectors via contexts."""
 
-    def __init__(self, connection_parameters: ConnectionParameters = None, custom_token_provider=None):
+    def __init__(self, connection_parameters: ConnectionParameters = None, custom_token_provider = None):
         """Creates a Hub with the specified ConnectionParameters with useful methods to obtain contexts
-        to a Cegal Hub Agent Connector or Cegal Hub Petrel Connector and make Cegal Hub Server queries.
+        to a Cegal Hub Agent Connector or Cegal Hub Petrel Connector and make Cegal Hub Server queries. 
 
         Args:
             connection_parameters (ConnectionParameters, optional): The connection parameters which address
             a Cegal Hub Server. Defaults to None.
             custom_token_provider (optional): A custom token provider to obtain access tokens on behalf of the user for communicating with Hub. Defaults to none.
         """
         if connection_parameters is None:
             logger.debug("connection parameters not provided, will create default")
             connection_parameters = ConnectionParameters()
-
+            
         self._hub_client = HubClient(connection_parameters, custom_token_provider)
 
     def __repr__(self):
-        return "hub connection params: " + repr(self._hub_client._connection_parameters)
+        return "hub connection params: " + repr(self._hub_client._connection_parameters)      
 
     def default_petrel_ctx(self):
-        """Get a default PetrelContext object.
-        If the user has several PetrelContext objects available it will arbitrarily select the first
+        """Get a default PetrelContext object. If the user has several PetrelContext objects available it will arbitrarily select the first
         instance. This PetrelContext will be a strong handle to a specific Petrel instance.
-
+        
         Raises:
             Exception: If no Petrel instances are connected to the Hub Server or are not available to the user.
 
         Returns:
             PetrelContext: A strong handle to a running instance of Petrel connected to Hub Server.
         """
         cf = ConnectorFilter()
@@ -70,30 +69,29 @@
         will be made using a round-robin schedule.
 
         Args:
             connector_filter (ConnectorFilter, optional): A means to target a particular connector instance(s). Defaults to None.
 
         Returns:
             PetrelContext: A handle to one or more Petrel instances.
-        """
+        """        
         if connector_filter is None:
             connector_filter = ConnectorFilter()
         return PetrelContext(self._hub_client, "cegal.hub.petrel", connector_filter)
 
     def default_agent_ctx(self):
-        """Get a default AgentContext object.
-        If the user has several AgentContext objects available it will arbitrarily select the first
+        """Get a default AgentContext object. If the user has several AgentContext objects available it will arbitrarily select the first
         instance. This AgentContext will be a strong handle to a specific Agent instance.
-
+        
         Raises:
             Exception: If no Agent instances are connected to Hub Server or are not available to the user.
 
         Returns:
             AgentContext: A strong handle to a running instance of an Agent connected to Hub Server.
-        """
+        """        
         cf = ConnectorFilter()
         ctx = AgentContext(self._hub_client, "cegal.hub.agent", cf)
         available = ctx.available
         logger.debug(f"there are {len(available)} connectors available")
         if len(available) > 0:
             logger.debug(f"selecting 1st available connector with id {available[0].connector_id}")
             ctx.connector_filter.target_connector_id = available[0].connector_id
@@ -108,44 +106,44 @@
         will be made using a round-robin schedule.
 
         Args:
             connector_filter (ConnectorFilter, optional): A means to target a particular connector instance(s). Defaults to None.
 
         Returns:
             AgentContext: A handle to one or more Agent instances.
-        """
+        """        
         if connector_filter is None:
             connector_filter = ConnectorFilter()
         return AgentContext(self._hub_client, "cegal.hub.agent", connector_filter)
 
     def verify_health(self):
         """Verify the health of a running Cegal Hub Server
 
         Returns:
             HealthQueryResult: An object containing non-sensitive open information about the Cegal Hub Server
-        """
+        """        
         msg = HealthQuery()
         result = self._hub_client.server_request_stub.VerifyHealth(msg)
         logger.info("Cegal Hub Server GRPC service is healthy")
         return result
 
     def query_server(self):
         """Query a running Cegal Hub Server for information on the Hub Server.
 
         Returns:
             ServerQueryResult: An object containing information about the running Cegal Hub Server.
-        """
+        """        
         msg = ServerQuery()
         result = self._hub_client.server_request_stub.QueryServer(msg)
         logger.debug(result)
         return result
 
     def print_query_server(self):
         """Print human-friendly information about a running Cegal Hub Server.
-        """
+        """        
         msg = ServerQuery()
         result = self._hub_client.server_request_stub.QueryServer(msg)
         logger.debug(result)
         dt = result.run_date.ToDatetime()
         print("Server started: " + str(dt))
         print("Server version: " + result.version)
         print("Server git hash: " + result.git_hash)
@@ -165,22 +163,22 @@
         Args:
             wellknown_identifier (str, optional): Limit the returned result to only Connectors of a given wellknown type. Defaults to "".
             wellknown_payload_identifier (str, optional): Limit the return result to only include Connectors that have the specified wellknown payload. Defaults to "".
             connector_filter (ConnectorFilter, optional): A ConnectorFilter object to target a specific Connector(s). Defaults to None.
 
         Returns:
             ConnectorQueryResult: An object containing information about the Cegal Hub Connectors available to the user.
-        """
+        """        
         if connector_filter is None:
             connector_filter = ConnectorFilter()
         msg = ConnectorQuery()
         msg.filter.connector_instance_id = connector_filter.target_connector_id
         msg.filter.wellknown_identifier = wellknown_identifier
         msg.filter.wellknown_payload_identifier = wellknown_payload_identifier
-        if connector_filter.labels_dict:
+        if connector_filter.labels_dict: 
             for k in connector_filter.labels_dict.keys():
                 msg.filter.labels[k] = connector_filter.labels_dict[k]
 
         result = self._hub_client._server_request_stub.QueryConnectors(msg)
         if (result.ok):
             logger.debug(result)
             return result.available_connectors
@@ -202,15 +200,15 @@
             show_labels (bool, optional): Include Connector labels in the output. Defaults to True.
             wellknown_identifier (str, optional): Target a specific instance of a running Cegal Hub Connector with the given connector identifier. Defaults to "".
             wellknown_payload_identifier (str, optional): Target specific Connectors based on the specified wellknown payload identifier. Defaults to "".
             connector_filter (ConnectorFilter, optional): A ConnectorFilter object to target a specific Connector(s). Defaults to None.
 
         Raises:
             Exception: If there is a problem querying the running Cegal Hub Server
-        """
+        """                               
         if connector_filter is None:
             connector_filter = ConnectorFilter()
         msg = ConnectorQuery()
         msg.filter.connector_instance_id = connector_filter.target_connector_id
         msg.filter.wellknown_identifier = wellknown_identifier
         msg.filter.wellknown_payload_identifier = wellknown_payload_identifier
         if connector_filter.labels_dict:
@@ -254,24 +252,25 @@
 
     def activate(self):
         """Activate a running Cegal Hub Server instance. The activation is only needed once on a running Cegal Hub Server instance. It is also only needed
         if the Cegal Hub is running in Server mode.
 
         Returns:
             ActivateServerResult: An object representing the result of the activation.
-        """
+        """        
         # use the hub logical client as server claim is in there for server activation (if the user is licensed to use it)
         # basic to desktop upgrade only needs hub_connector_api claim
-        oidc_options = OidcOptions(client_id="prizm",
-                                   provider_uri=ServerConfig.get_keystone_url(),
-                                   audiences=["hub_connector_api"],
-                                   extra_scopes=["offline_access", "hub_connector_api"])
+        oidc_options = oidc_options = OidcOptions(client_id="prizm",
+                                           provider_uri=ServerConfig.get_keystone_url(),
+                                           audiences=["hub_connector_api"],
+                                           extra_scopes=["offline_access", "hub_connector_api"])
         oidc_client = OidcClient(oidc_options,
-                                 page_handler=CegalProductTemplate(product="Cegal Prizm",
-                                                                   extra="<h3>You have successfully logged into Cegal Prizm</h3>"))
+        page_handler=CegalProductTemplate(
+        product="Cegal Prizm",
+        extra="<h3>You have successfully logged into Cegal Prizm</h3>"))
         url = self._hub_client.connection_parameters.host + ":" + str(self._hub_client.connection_parameters.port)
 
         if self._hub_client.connection_parameters.use_tls:
             chan = grpc.secure_channel(url, grpc.ssl_channel_credentials())
         else:
             chan = grpc.insecure_channel(url, options=(('grpc.enable_http_proxy', 0),))
         interceptor = auth_header_interceptor(token_provider=oidc_client)
@@ -287,15 +286,15 @@
         return result
 
     def is_version_compatible(self):
         """Checks the compatibility of the Cegal Hub Python client library with the running Cegal Hub Server.
 
         Returns:
             bool: True if compatible, False if incompatible or compatibilty cannot be determined.
-        """
+        """        
         msg = HealthQuery()
         try:
             result = self._hub_client.server_request_stub.VerifyHealth(msg)
         except Exception as error:
             logger.warning(f"cannot verify compatibility as Cegal Hub Server cannot be reached: {error}")
             return False
 
@@ -303,17 +302,17 @@
         server_version = version.parse(result.grpc_api_version)
         try:
             client_version.major
         except AttributeError:
             logger.info(f"cannot parse major version, you are probably running a development version")
             client_version = version.parse("1.0.0")
 
-        # compare the major version number for compatibility
+        #compare the major version number for compatibility
         compatible = client_version.major == server_version.major
         if compatible is False:
             logger.warning(f"the Hub Server major version '{server_version.major}' is not compatible with the Python client library major version '{client_version.major}'")
-        return compatible
+        return compatible    
 
     def close(self):
         """Close the underlying HubClient GRPC channel.
-        """
-        self._hub_client.close()
+        """        
+        self._hub_client.close()
```

## cegalprizm/hub/hub_channel.py

```diff
@@ -8,18 +8,18 @@
 import grpc
 
 from cegal.keystone_auth import OidcClient, OidcOptions
 from cegal.keystone_auth.responses import CegalProductTemplate
 
 from . import logger
 from .keystone_auth_interceptor import auth_header_interceptor
-from .impersonation_interceptor import impersonation_header_interceptor
 from .client_config import ClientConfig
 from .connection_parameters import ConnectionParameters
 from .server_config import ServerConfig
+from .in_memory_token_provider import InMemoryTokenProvider
 
 
 class HubChannel:
     """A Cegal Hub configured GRPC channel for use with a Cegal Hub Server.
     """
 
     def __init__(self, connection_parameters: ConnectionParameters = None, token_provider=None):
@@ -35,23 +35,28 @@
         host = connection_parameters.host
         port = connection_parameters.port
         url = host + ":" + str(port)
         logger.debug(f"HubChannel using url {url}")
         self._token_provider = token_provider
         if connection_parameters.use_auth:
             logger.debug(f"HubChannel use auth")
-            if token_provider is None and not ClientConfig.is_user_impersonation_active():
-                logger.debug(f"HubChannel requires auth and no explicit token provider specified, so will use the prizm clientid")
-                oidc_options = OidcOptions(client_id="prizm",
-                                           provider_uri=ServerConfig.get_keystone_url(),
-                                           audiences=["hub_connector_api"],
-                                           extra_scopes=["offline_access", "hub_connector_api"])
-                self._token_provider = OidcClient(oidc_options,
-                                                  page_handler=CegalProductTemplate(product="Cegal Prizm",
-                                                                                    extra="<h3>You have successfully logged into Cegal Prizm</h3>"))
+            if token_provider is None:
+                user_access_token = ClientConfig.get_user_access_token()
+                if user_access_token:
+                    logger.error(f"HubChannel requires auth and will use the provided access token")
+                    self._token_provider = InMemoryTokenProvider(user_access_token)
+                else:
+                    logger.error(f"HubChannel requires auth and no explicit token provider specified, so will use the prizm clientid")
+                    oidc_options = OidcOptions(client_id="prizm",
+                                               provider_uri=ServerConfig.get_keystone_url(),
+                                               audiences=["hub_connector_api"],
+                                               extra_scopes=["offline_access", "hub_connector_api"])
+                    self._token_provider = OidcClient(oidc_options,
+                                                      page_handler=CegalProductTemplate(product="Cegal Prizm",
+                                                                                        extra="<h3>You have successfully logged into Cegal Prizm</h3>"))
 
         chan = None
         channel_options = [
             ("grpc.max_receive_message_length", 524288000),
             ("grpc.max_send_message_length", 524288000)
         ]
 
@@ -63,48 +68,44 @@
             channel_options.append(('grpc.enable_http_proxy', 0))
             chan = grpc.insecure_channel(url, options=channel_options)
 
         if connection_parameters.use_auth and self._token_provider is not None:
             logger.debug("HubChannel using a token provider")
             interceptor = auth_header_interceptor(token_provider=self._token_provider)
             chan = grpc.intercept_channel(chan, interceptor)
-        elif ClientConfig.is_user_impersonation_active():
-            logger.debug("HubChannel will use user impersonation if available")
-            interceptor = impersonation_header_interceptor()
-            chan = grpc.intercept_channel(chan, interceptor)
         else:
             logger.debug("HubChannel NOT using auth")
 
         self._channel = chan
         self._connection_parameters = connection_parameters
 
     @property
     def connection_parameters(self):
         """The ConnectionParameters associated with a running Cegal Hub Server.
 
         Returns:
             ConnectionParameters: The ConnectionParameters associated with a running Cegal Hub Server.
-        """
+        """        
         return self._connection_parameters
 
     @property
     def channel(self):
         """The GRPC channel associated with a running Cegal Hub Server.
 
         Returns:
             Channel: The GRPC channel associated with a running Cegal Hub Server.
-        """
+        """        
         return self._channel
 
     @property
     def token_provider(self):
         """The token provider associated with authenticating against a Cegal Hub Server.
 
         Returns:
             token_provider: Usually an OidcClient.
-        """
+        """        
         return self._token_provider
 
     def close(self):
         """Close the underlying GRPC channel.
-        """
+        """        
         self._channel.close()
```

## cegalprizm/hub/keystone_auth_interceptor.py

 * *Ordering differences only*

```diff
@@ -28,8 +28,8 @@
             "Bearer " + token_provider.get_access_token(),
         ))
         client_call_details = _ClientCallDetails(
             client_call_details.method, client_call_details.timeout, metadata,
             client_call_details.credentials)
         return client_call_details, request_iterator, None
 
-    return create(intercept_call)
+    return create(intercept_call)
```

## cegalprizm/hub/petrel.py

```diff
@@ -38,21 +38,20 @@
             use_ref_project (bool, optional): If True use the secondary project loaded in Petrel(if available), otherwise use the primary project. Defaults to False.
 
         Raises:
             Exception: If there was a problem obtaining the Petrel project information
 
         Returns:
             ProjectInfoResult: An object containing the Petrel project information.
-        """
+        """        
         msg = ProjectInfoRequest()
         msg.use_ref_project = use_ref_project
         payload = Any()
         payload.Pack(msg)
-        ok, result, connector_id = self._hub_client.do_unary_request("cegal.hub.petrel", "cegal.hub.petrel.project_info", payload,
-                                                                     connector_filter=self.connector_filter, major_version=1, minor_version=0)
+        ok, result, connector_id = self._hub_client.do_unary_request("cegal.hub.petrel", "cegal.hub.petrel.project_info", payload, connector_filter=self.connector_filter, major_version=1,minor_version=0)
         if (ok):
             response = ProjectInfoResult()
             result.Unpack(response)
             logger.info(f"got project info:{response} on connector_id {connector_id}")
             return response
         else:
             logger.warning(f"failed to get Petrel project info: {result} on connector_id {connector_id}")
@@ -62,20 +61,19 @@
         """Kill the running instance of Petrel
 
         Raises:
             Exception: If there was a problem trying to kill Petrel
 
         Returns:
             PoisonPetrelResult: An object representing the result of attempting to kill Petrel
-        """
+        """        
         msg = PoisonPetrelRequest()
         payload = Any()
         payload.Pack(msg)
-        ok, result, connector_id = self._hub_client.do_unary_request("cegal.hub.petrel", "cegal.hub.petrel.poison_petrel", payload,
-                                                                     connector_filter=self.connector_filter, major_version=1, minor_version=0)
+        ok, result, connector_id = self._hub_client.do_unary_request("cegal.hub.petrel", "cegal.hub.petrel.poison_petrel", payload, connector_filter=self.connector_filter, major_version=1,minor_version=0)
         if (ok):
             response = PoisonPetrelResult()
             result.Unpack(response)
             logger.info(f"Petrel has been killed on connector_id {connector_id}")
             return response
         else:
             logger.warning(f"failed to kill Petrel: {result} on connector_id {connector_id}")
@@ -90,24 +88,23 @@
             use_ref_project (bool, optional): True if the project should be opened as a secondary project in Petrel. Defaults to False.
 
         Raises:
             Exception: If there was a problem loading the Petrel project
 
         Returns:
             LoadProjectResult: An object representing the result of loading a Petrel project
-        """
+        """        
         msg = LoadProjectRequest()
         msg.path = path
         msg.read_only = read_only
         msg.use_ref_project = use_ref_project
         payload = Any()
         payload.Pack(msg)
         logger.info("loading Petrel project, this could take a while...")
-        ok, result, connector_id = self._hub_client.do_unary_request("cegal.hub.petrel", "cegal.hub.petrel.project_load", payload,
-                                                                     connector_filter=self.connector_filter, major_version=1, minor_version=0)
+        ok, result, connector_id = self._hub_client.do_unary_request("cegal.hub.petrel", "cegal.hub.petrel.project_load", payload, connector_filter=self.connector_filter, major_version=1,minor_version=0)
         if (ok):
             response = LoadProjectResult()
             result.Unpack(response)
             logger.info(f"project successfully loaded: {response} on connector_id {connector_id}")
             return response
         else:
             logger.warning(f"failed to load  project: {result} on connector_id {connector_id}")
@@ -117,20 +114,19 @@
         """Create a new project in the running instance of Petrel.
 
         Raises:
             Exception: If there was a problem creating the new Petrel project.
 
         Returns:
             NewProjectResult: An object representing the result of creating a new Petrel project.
-        """
+        """        
         msg = NewProjectRequest()
         payload = Any()
         payload.Pack(msg)
-        ok, result, connector_id = self._hub_client.do_unary_request("cegal.hub.petrel", "cegal.hub.petrel.project_new", payload,
-                                                                     connector_filter=self.connector_filter, major_version=1, minor_version=0)
+        ok, result, connector_id = self._hub_client.do_unary_request("cegal.hub.petrel", "cegal.hub.petrel.project_new", payload, connector_filter=self.connector_filter, major_version=1,minor_version=0)
         if (ok):
             response = NewProjectResult()
             result.Unpack(response)
             logger.info(f"new project successfully created: {result} on connector_id {connector_id}")
             return response
         else:
             logger.warning(f"failed to create new project: {result} on connector_id {connector_id}")
@@ -145,22 +141,21 @@
             if this scenario is encountered. Defaults to False.
 
         Raises:
             Exception: If there was a problem saving the Petrel project.
 
         Returns:
             SaveProjectResult: An object representing the result of saving the Petrel project.
-        """
+        """        
         msg = SaveProjectRequest()
         msg.use_ref_project = use_ref_project
         msg.allow_project_version_upgrade = allow_project_version_upgrade
         payload = Any()
         payload.Pack(msg)
-        ok, result, connector_id = self._hub_client.do_unary_request("cegal.hub.petrel", "cegal.hub.petrel.project_save", payload,
-                                                                     connector_filter=self.connector_filter, major_version=1, minor_version=0)
+        ok, result, connector_id = self._hub_client.do_unary_request("cegal.hub.petrel", "cegal.hub.petrel.project_save", payload, connector_filter=self.connector_filter, major_version=1,minor_version=0)
         if (ok):
             response = SaveProjectResult()
             result.Unpack(response)
             logger.info(f"project successfully saved {result} on connector_id {connector_id}")
             return response
         else:
             logger.warning(f"failed to save project: {result} on connector_id {connector_id}")
@@ -174,22 +169,21 @@
             use_ref_project (bool, optional): If True perform save as on the secondary Petrel project, otherwise perform save as on the primary Petrel project. Defaults to False.
 
         Raises:
             Exception: It there was a problem performing the save as
 
         Returns:
             SaveAsProjectResult: An object representing the result of performing a save as.
-        """
+        """        
         msg = SaveAsProjectRequest()
         msg.path = path
         msg.use_ref_project = use_ref_project
         payload = Any()
         payload.Pack(msg)
-        ok, result, connector_id = self._hub_client.do_unary_request("cegal.hub.petrel", "cegal.hub.petrel.project_save_as", payload,
-                                                                     connector_filter=self.connector_filter, major_version=1, minor_version=0)
+        ok, result, connector_id = self._hub_client.do_unary_request("cegal.hub.petrel", "cegal.hub.petrel.project_save_as", payload, connector_filter=self.connector_filter, major_version=1,minor_version=0)
         if (ok):
             response = SaveAsProjectResult()
             result.Unpack(response)
             logger.info(f"project save as succesful on connector_id {connector_id}")
             return response
         else:
             logger.warning(f"failed to save as project: {result} on connector_id {connector_id}")
@@ -203,22 +197,21 @@
             close_both_projects (bool, optional): If True close both the primary and secondary Petrel projects. Defaults to False.
 
         Raises:
             Exception: If there was a problem closing the Petrel project.
 
         Returns:
             CloseProjectResult: An object representing the result of closing the Petrel project.
-        """
+        """        
         msg = CloseProjectRequest()
         msg.use_ref_project = use_ref_project
         msg.close_both_projects = close_both_projects
         payload = Any()
         payload.Pack(msg)
-        ok, result, connector_id = self._hub_client.do_unary_request("cegal.hub.petrel", "cegal.hub.petrel.project_close", payload,
-                                                                     connector_filter=self.connector_filter, major_version=1, minor_version=0)
+        ok, result, connector_id = self._hub_client.do_unary_request("cegal.hub.petrel", "cegal.hub.petrel.project_close", payload, connector_filter=self.connector_filter, major_version=1,minor_version=0)
         if (ok):
             response = CloseProjectResult()
             result.Unpack(response)
             logger.info(f"project(s) closed ok: {result} on connector_id {connector_id}")
             return response
         else:
             logger.warning(f"failed to close project(s): {result} on connector_id {connector_id}")
```

## cegalprizm/hub/server_config.py

```diff
@@ -3,39 +3,39 @@
 # Unauthorized copying of this file, via any medium is strictly prohibited.
 
 import os
 
 
 class ServerConfig():
     """The global Hub Server configuration for communicating with a Cegal Hub Server. This is used primarily with ConnectionParameters objects.
-    When a ConnectionParameters object is created but no values are provided, the ConnectionParameters object will rely on the ClientConfig and ServerConfig
+    When a ConnectionParameters object is created but no values are provided, the ConnectionParameters object will rely on the ClientConfig and ServerConfig 
     global configurations for defaults."""
 
     __host: str = None
     __port: int = None
     __use_tls: bool = None
     __keystone_url: str = None
 
     @staticmethod
     def set_host(host: str):
         """Update the host address of the Cegal Hub Server
 
         Args:
             host (str): The host address of the Cegal Hub Server
-        """
+        """        
         ServerConfig.__host = host
 
     @staticmethod
     def get_host():
         """Get the host address of a Cegal Hub Server. By default it will look for an environment variable
         called CEGAL_HUB_HOST
 
         Returns:
             [str]: The address of the Cegal Hub Server.
-        """
+        """        
         if ServerConfig.__host is None:
             val = ServerConfig.__get_envvar("CEGAL_HUB_HOST")
             if val[0]:
                 return val[1]
             else:
                 return "localhost"
         else:
@@ -43,25 +43,25 @@
 
     @staticmethod
     def set_port(port: int):
         """Update the port on which to talk to a Cegal Hub Server.
 
         Args:
             port (int): The port to talk to a Cegal Hub Server.
-        """
+        """        
         ServerConfig.__port = port
 
     @staticmethod
     def get_port():
         """Gets the port on which to talk to a Cegal Hub Server. By default it will look for an environment variable
         called CEGAL_HUB_PORT
 
         Returns:
             [int]: The port on which to talk to a Cegal Hub Server.
-        """
+        """        
         if ServerConfig.__port is None:
             val = ServerConfig.__get_envvar("CEGAL_HUB_PORT")
             if val[0]:
                 return int(val[1])
             else:
                 return 9595
         else:
@@ -69,25 +69,25 @@
 
     @staticmethod
     def set_use_tls(use_tls: bool):
         """Set whether or not to use Transport Level Security (TLS) when talking to a Cegal Hub Server
 
         Args:
             use_tls (bool): True if using TLS, False otherwise.
-        """
+        """        
         ServerConfig.__use_tls = use_tls
 
     @staticmethod
     def get_use_tls():
         """Get whether or not to use Transport level Security (TLS) when talking to a Cegal Hub Server. By default it will look for an environment variable
         called CEGAL_HUB_USE_TLS
 
         Returns:
             [bool]: True if using TLS, False otherwise.
-        """
+        """        
         if ServerConfig.__use_tls is None:
             val = ServerConfig.__get_envvar("CEGAL_HUB_USE_TLS")
             if val[0]:
                 return val[1].lower() == "true"
             else:
                 return False
         else:
@@ -103,24 +103,24 @@
 
     @staticmethod
     def set_keystone_url(url: str):
         """Update the URL for the Cegal Keystone Secure Token Server. Typically only used by Cegal development teams.
 
         Args:
             url (str): The URL to the Cegal Keystone Secure Token Server.
-        """
+        """        
         ServerConfig.__keystone_url = url
 
     @staticmethod
     def get_keystone_url():
         """Get the URL of the Cegal Keystone Secure Token Server.
 
         Returns:
             [str]: The URL of the Cegal Keystone Secure Token Server.
-        """
+        """        
         if ServerConfig.__keystone_url is None:
-            return os.environ.get("CEGAL_KEYSTONE_URL", "https://keystone.cegal-geo.com/identity")
+            return "https://keystone.cegal-geo.com/identity"
         return ServerConfig.__keystone_url
 
     @staticmethod
     def __repr__():
         return "host:" + ServerConfig.get_host() + ", port:" + repr(ServerConfig.get_port()) + ", use TLS:" + repr(ServerConfig.get_use_tls()) + ", Keystone URL:" + ServerConfig.get_keystone_url()
```

## cegalprizm/hub/server_service_pb2.py

```diff
@@ -18,15 +18,15 @@
 
 DESCRIPTOR = _descriptor.FileDescriptor(
   name='cegalprizm/hub/server_service.proto',
   package='hub',
   syntax='proto3',
   serialized_options=b'Z\t./grpcgen',
   create_key=_descriptor._internal_create_key,
-  serialized_pb=b'\n#cegalprizm/hub/server_service.proto\x12\x03hub\x1a+cegalprizm/hub/connector_task_service.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"1\n\x19\x43\x61ncellationEventsRequest\x12\x14\n\x0c\x63onnector_id\x18\x01 \x01(\t\"\'\n\x11\x43\x61ncellationEvent\x12\x12\n\nrequest_id\x18\x01 \x01(\t\"\r\n\x0bHealthQuery\"b\n\x11HealthQueryResult\x12\x18\n\x10grpc_api_version\x18\x01 \x01(\t\x12\x0f\n\x07version\x18\x02 \x01(\t\x12\x11\n\tactivated\x18\x03 \x01(\x08\x12\x0f\n\x07license\x18\x04 \x01(\t\"\r\n\x0bServerQuery\"\x17\n\x15\x41\x63tivateServerRequest\"9\n\x14\x41\x63tivateServerResult\x12\n\n\x02ok\x18\x01 \x01(\x08\x12\x15\n\rerror_message\x18\x02 \x01(\t\"\xa6\x03\n\x11ServerQueryResult\x12\n\n\x02ok\x18\x01 \x01(\x08\x12\x15\n\rerror_message\x18\x02 \x01(\t\x12,\n\x08run_date\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\x0f\n\x07version\x18\x04 \x01(\t\x12\x10\n\x08git_hash\x18\x05 \x01(\t\x12\x18\n\x10operating_system\x18\x06 \x01(\t\x12\x0f\n\x07license\x18\x07 \x01(\t\x12\x18\n\x10grpc_api_version\x18\x08 \x01(\t\x12\"\n\x1a\x61llow_connector_join_token\x18\t \x01(\x08\x12$\n\x1crequire_connector_join_token\x18\n \x01(\x08\x12\x1e\n\x16require_connector_auth\x18\x0b \x01(\x08\x12\x1b\n\x13require_client_auth\x18\x0c \x01(\x08\x12(\n num_connected_private_connectors\x18\r \x01(\x03\x12\'\n\x1fnum_connected_public_connectors\x18\x0e \x01(\x03\"\xdf\x01\n\x14\x43onnectorQueryFilter\x12\x1c\n\x14wellknown_identifier\x18\x01 \x01(\t\x12$\n\x1cwellknown_payload_identifier\x18\x02 \x01(\t\x12\x35\n\x06labels\x18\x03 \x03(\x0b\x32%.hub.ConnectorQueryFilter.LabelsEntry\x12\x1d\n\x15\x63onnector_instance_id\x18\x04 \x01(\t\x1a-\n\x0bLabelsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\t:\x02\x38\x01\";\n\x0e\x43onnectorQuery\x12)\n\x06\x66ilter\x18\x01 \x01(\x0b\x32\x19.hub.ConnectorQueryFilter\"\x8b\x01\n\x14\x43onnectorQueryResult\x12\n\n\x02ok\x18\x01 \x01(\x08\x12\x15\n\rerror_message\x18\x02 \x01(\t\x12,\n\x14\x61vailable_connectors\x18\x03 \x03(\x0b\x32\x0e.hub.Connector\x12\"\n\x1anum_unavailable_connectors\x18\x04 \x01(\x03\"\xb9\x04\n\tConnector\x12\x14\n\x0c\x63onnector_id\x18\x01 \x01(\t\x12\x1c\n\x14wellknown_identifier\x18\x02 \x01(\t\x12\x30\n\x0c\x63onnect_date\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\x15\n\rfriendly_name\x18\x04 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x05 \x01(\t\x12\x11\n\thost_name\x18\x06 \x01(\t\x12\x18\n\x10operating_system\x18\x07 \x01(\t\x12\x0f\n\x07version\x18\x08 \x01(\t\x12\x15\n\rbuild_version\x18\t \x01(\t\x12\"\n\x1a\x63urrent_logical_task_count\x18\n \x01(\x03\x12*\n\x06labels\x18\x0b \x03(\x0b\x32\x1a.hub.Connector.LabelsEntry\x12\x41\n\x12supported_payloads\x18\x0c \x03(\x0b\x32%.hub.Connector.SupportedPayloadsEntry\x12 \n\x18supports_public_requests\x18\r \x01(\x08\x12\x10\n\x08identity\x18\x0e \x01(\t\x1a-\n\x0bLabelsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\t:\x02\x38\x01\x1aO\n\x16SupportedPayloadsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12$\n\x05value\x18\x02 \x01(\x0b\x32\x15.hub.SupportedPayload:\x02\x38\x01\"\x12\n\x10HubEventsRequest\"B\n\x08HubEvent\x12.\n\x0f\x63onnector_event\x18\x01 \x01(\x0b\x32\x13.hub.ConnectorEventH\x00\x42\x06\n\x04type\"\xdb\x01\n\x0e\x43onnectorEvent\x12\x35\n\x14\x63onnector_event_type\x18\x01 \x01(\x0e\x32\x17.hub.ConnectorEventType\x12\x14\n\x0c\x63onnector_id\x18\x02 \x01(\t\x12\x1c\n\x14wellknown_identifier\x18\x03 \x01(\t\x12/\n\x06labels\x18\x04 \x03(\x0b\x32\x1f.hub.ConnectorEvent.LabelsEntry\x1a-\n\x0bLabelsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\t:\x02\x38\x01*D\n\x12\x43onnectorEventType\x12\x0b\n\x07\x43ONNECT\x10\x00\x12\x0e\n\nDISCONNECT\x10\x01\x12\x11\n\rUPDATE_LABELS\x10\x02\x32\xa5\x03\n\rServerService\x12:\n\x0cVerifyHealth\x12\x10.hub.HealthQuery\x1a\x16.hub.HealthQueryResult\"\x00\x12\x43\n\x0fQueryConnectors\x12\x13.hub.ConnectorQuery\x1a\x19.hub.ConnectorQueryResult\"\x00\x12\x39\n\x0bQueryServer\x12\x10.hub.ServerQuery\x1a\x16.hub.ServerQueryResult\"\x00\x12I\n\x0e\x41\x63tivateServer\x12\x1a.hub.ActivateServerRequest\x1a\x19.hub.ActivateServerResult\"\x00\x12\x38\n\x0cGetHubEvents\x12\x15.hub.HubEventsRequest\x1a\r.hub.HubEvent\"\x00\x30\x01\x12S\n\x15GetCancellationEvents\x12\x1e.hub.CancellationEventsRequest\x1a\x16.hub.CancellationEvent\"\x00\x30\x01\x42\x0bZ\t./grpcgenb\x06proto3'
+  serialized_pb=b'\n#cegalprizm/hub/server_service.proto\x12\x03hub\x1a+cegalprizm/hub/connector_task_service.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\r\n\x0bHealthQuery\"b\n\x11HealthQueryResult\x12\x18\n\x10grpc_api_version\x18\x01 \x01(\t\x12\x0f\n\x07version\x18\x02 \x01(\t\x12\x11\n\tactivated\x18\x03 \x01(\x08\x12\x0f\n\x07license\x18\x04 \x01(\t\"\r\n\x0bServerQuery\"\x17\n\x15\x41\x63tivateServerRequest\"9\n\x14\x41\x63tivateServerResult\x12\n\n\x02ok\x18\x01 \x01(\x08\x12\x15\n\rerror_message\x18\x02 \x01(\t\"\xa6\x03\n\x11ServerQueryResult\x12\n\n\x02ok\x18\x01 \x01(\x08\x12\x15\n\rerror_message\x18\x02 \x01(\t\x12,\n\x08run_date\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\x0f\n\x07version\x18\x04 \x01(\t\x12\x10\n\x08git_hash\x18\x05 \x01(\t\x12\x18\n\x10operating_system\x18\x06 \x01(\t\x12\x0f\n\x07license\x18\x07 \x01(\t\x12\x18\n\x10grpc_api_version\x18\x08 \x01(\t\x12\"\n\x1a\x61llow_connector_join_token\x18\t \x01(\x08\x12$\n\x1crequire_connector_join_token\x18\n \x01(\x08\x12\x1e\n\x16require_connector_auth\x18\x0b \x01(\x08\x12\x1b\n\x13require_client_auth\x18\x0c \x01(\x08\x12(\n num_connected_private_connectors\x18\r \x01(\x03\x12\'\n\x1fnum_connected_public_connectors\x18\x0e \x01(\x03\"\xdf\x01\n\x14\x43onnectorQueryFilter\x12\x1c\n\x14wellknown_identifier\x18\x01 \x01(\t\x12$\n\x1cwellknown_payload_identifier\x18\x02 \x01(\t\x12\x35\n\x06labels\x18\x03 \x03(\x0b\x32%.hub.ConnectorQueryFilter.LabelsEntry\x12\x1d\n\x15\x63onnector_instance_id\x18\x04 \x01(\t\x1a-\n\x0bLabelsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\t:\x02\x38\x01\";\n\x0e\x43onnectorQuery\x12)\n\x06\x66ilter\x18\x01 \x01(\x0b\x32\x19.hub.ConnectorQueryFilter\"\x8b\x01\n\x14\x43onnectorQueryResult\x12\n\n\x02ok\x18\x01 \x01(\x08\x12\x15\n\rerror_message\x18\x02 \x01(\t\x12,\n\x14\x61vailable_connectors\x18\x03 \x03(\x0b\x32\x0e.hub.Connector\x12\"\n\x1anum_unavailable_connectors\x18\x04 \x01(\x03\"\xb9\x04\n\tConnector\x12\x14\n\x0c\x63onnector_id\x18\x01 \x01(\t\x12\x1c\n\x14wellknown_identifier\x18\x02 \x01(\t\x12\x30\n\x0c\x63onnect_date\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\x15\n\rfriendly_name\x18\x04 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x05 \x01(\t\x12\x11\n\thost_name\x18\x06 \x01(\t\x12\x18\n\x10operating_system\x18\x07 \x01(\t\x12\x0f\n\x07version\x18\x08 \x01(\t\x12\x15\n\rbuild_version\x18\t \x01(\t\x12\"\n\x1a\x63urrent_logical_task_count\x18\n \x01(\x03\x12*\n\x06labels\x18\x0b \x03(\x0b\x32\x1a.hub.Connector.LabelsEntry\x12\x41\n\x12supported_payloads\x18\x0c \x03(\x0b\x32%.hub.Connector.SupportedPayloadsEntry\x12 \n\x18supports_public_requests\x18\r \x01(\x08\x12\x10\n\x08identity\x18\x0e \x01(\t\x1a-\n\x0bLabelsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\t:\x02\x38\x01\x1aO\n\x16SupportedPayloadsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12$\n\x05value\x18\x02 \x01(\x0b\x32\x15.hub.SupportedPayload:\x02\x38\x01\"\x12\n\x10HubEventsRequest\"B\n\x08HubEvent\x12.\n\x0f\x63onnector_event\x18\x01 \x01(\x0b\x32\x13.hub.ConnectorEventH\x00\x42\x06\n\x04type\"\xdb\x01\n\x0e\x43onnectorEvent\x12\x35\n\x14\x63onnector_event_type\x18\x01 \x01(\x0e\x32\x17.hub.ConnectorEventType\x12\x14\n\x0c\x63onnector_id\x18\x02 \x01(\t\x12\x1c\n\x14wellknown_identifier\x18\x03 \x01(\t\x12/\n\x06labels\x18\x04 \x03(\x0b\x32\x1f.hub.ConnectorEvent.LabelsEntry\x1a-\n\x0bLabelsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\t:\x02\x38\x01*D\n\x12\x43onnectorEventType\x12\x0b\n\x07\x43ONNECT\x10\x00\x12\x0e\n\nDISCONNECT\x10\x01\x12\x11\n\rUPDATE_LABELS\x10\x02\x32\xd0\x02\n\rServerService\x12:\n\x0cVerifyHealth\x12\x10.hub.HealthQuery\x1a\x16.hub.HealthQueryResult\"\x00\x12\x43\n\x0fQueryConnectors\x12\x13.hub.ConnectorQuery\x1a\x19.hub.ConnectorQueryResult\"\x00\x12\x39\n\x0bQueryServer\x12\x10.hub.ServerQuery\x1a\x16.hub.ServerQueryResult\"\x00\x12I\n\x0e\x41\x63tivateServer\x12\x1a.hub.ActivateServerRequest\x1a\x19.hub.ActivateServerResult\"\x00\x12\x38\n\x0cGetHubEvents\x12\x15.hub.HubEventsRequest\x1a\r.hub.HubEvent\"\x00\x30\x01\x42\x0bZ\t./grpcgenb\x06proto3'
   ,
   dependencies=[cegalprizm_dot_hub_dot_connector__task__service__pb2.DESCRIPTOR,google_dot_protobuf_dot_timestamp__pb2.DESCRIPTOR,])
 
 _CONNECTOREVENTTYPE = _descriptor.EnumDescriptor(
   name='ConnectorEventType',
   full_name='hub.ConnectorEventType',
   filename=None,
@@ -47,90 +47,26 @@
       name='UPDATE_LABELS', index=2, number=2,
       serialized_options=None,
       type=None,
       create_key=_descriptor._internal_create_key),
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=2164,
-  serialized_end=2232,
+  serialized_start=2072,
+  serialized_end=2140,
 )
 _sym_db.RegisterEnumDescriptor(_CONNECTOREVENTTYPE)
 
 ConnectorEventType = enum_type_wrapper.EnumTypeWrapper(_CONNECTOREVENTTYPE)
 CONNECT = 0
 DISCONNECT = 1
 UPDATE_LABELS = 2
 
 
 
-_CANCELLATIONEVENTSREQUEST = _descriptor.Descriptor(
-  name='CancellationEventsRequest',
-  full_name='hub.CancellationEventsRequest',
-  filename=None,
-  file=DESCRIPTOR,
-  containing_type=None,
-  create_key=_descriptor._internal_create_key,
-  fields=[
-    _descriptor.FieldDescriptor(
-      name='connector_id', full_name='hub.CancellationEventsRequest.connector_id', index=0,
-      number=1, type=9, cpp_type=9, label=1,
-      has_default_value=False, default_value=b"".decode('utf-8'),
-      message_type=None, enum_type=None, containing_type=None,
-      is_extension=False, extension_scope=None,
-      serialized_options=None, file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
-  ],
-  extensions=[
-  ],
-  nested_types=[],
-  enum_types=[
-  ],
-  serialized_options=None,
-  is_extendable=False,
-  syntax='proto3',
-  extension_ranges=[],
-  oneofs=[
-  ],
-  serialized_start=122,
-  serialized_end=171,
-)
-
-
-_CANCELLATIONEVENT = _descriptor.Descriptor(
-  name='CancellationEvent',
-  full_name='hub.CancellationEvent',
-  filename=None,
-  file=DESCRIPTOR,
-  containing_type=None,
-  create_key=_descriptor._internal_create_key,
-  fields=[
-    _descriptor.FieldDescriptor(
-      name='request_id', full_name='hub.CancellationEvent.request_id', index=0,
-      number=1, type=9, cpp_type=9, label=1,
-      has_default_value=False, default_value=b"".decode('utf-8'),
-      message_type=None, enum_type=None, containing_type=None,
-      is_extension=False, extension_scope=None,
-      serialized_options=None, file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
-  ],
-  extensions=[
-  ],
-  nested_types=[],
-  enum_types=[
-  ],
-  serialized_options=None,
-  is_extendable=False,
-  syntax='proto3',
-  extension_ranges=[],
-  oneofs=[
-  ],
-  serialized_start=173,
-  serialized_end=212,
-)
-
-
 _HEALTHQUERY = _descriptor.Descriptor(
   name='HealthQuery',
   full_name='hub.HealthQuery',
   filename=None,
   file=DESCRIPTOR,
   containing_type=None,
   create_key=_descriptor._internal_create_key,
@@ -143,16 +79,16 @@
   ],
   serialized_options=None,
   is_extendable=False,
   syntax='proto3',
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=214,
-  serialized_end=227,
+  serialized_start=122,
+  serialized_end=135,
 )
 
 
 _HEALTHQUERYRESULT = _descriptor.Descriptor(
   name='HealthQueryResult',
   full_name='hub.HealthQueryResult',
   filename=None,
@@ -196,16 +132,16 @@
   ],
   serialized_options=None,
   is_extendable=False,
   syntax='proto3',
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=229,
-  serialized_end=327,
+  serialized_start=137,
+  serialized_end=235,
 )
 
 
 _SERVERQUERY = _descriptor.Descriptor(
   name='ServerQuery',
   full_name='hub.ServerQuery',
   filename=None,
@@ -221,16 +157,16 @@
   ],
   serialized_options=None,
   is_extendable=False,
   syntax='proto3',
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=329,
-  serialized_end=342,
+  serialized_start=237,
+  serialized_end=250,
 )
 
 
 _ACTIVATESERVERREQUEST = _descriptor.Descriptor(
   name='ActivateServerRequest',
   full_name='hub.ActivateServerRequest',
   filename=None,
@@ -246,16 +182,16 @@
   ],
   serialized_options=None,
   is_extendable=False,
   syntax='proto3',
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=344,
-  serialized_end=367,
+  serialized_start=252,
+  serialized_end=275,
 )
 
 
 _ACTIVATESERVERRESULT = _descriptor.Descriptor(
   name='ActivateServerResult',
   full_name='hub.ActivateServerResult',
   filename=None,
@@ -285,16 +221,16 @@
   ],
   serialized_options=None,
   is_extendable=False,
   syntax='proto3',
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=369,
-  serialized_end=426,
+  serialized_start=277,
+  serialized_end=334,
 )
 
 
 _SERVERQUERYRESULT = _descriptor.Descriptor(
   name='ServerQueryResult',
   full_name='hub.ServerQueryResult',
   filename=None,
@@ -408,16 +344,16 @@
   ],
   serialized_options=None,
   is_extendable=False,
   syntax='proto3',
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=429,
-  serialized_end=851,
+  serialized_start=337,
+  serialized_end=759,
 )
 
 
 _CONNECTORQUERYFILTER_LABELSENTRY = _descriptor.Descriptor(
   name='LabelsEntry',
   full_name='hub.ConnectorQueryFilter.LabelsEntry',
   filename=None,
@@ -447,16 +383,16 @@
   ],
   serialized_options=b'8\001',
   is_extendable=False,
   syntax='proto3',
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1032,
-  serialized_end=1077,
+  serialized_start=940,
+  serialized_end=985,
 )
 
 _CONNECTORQUERYFILTER = _descriptor.Descriptor(
   name='ConnectorQueryFilter',
   full_name='hub.ConnectorQueryFilter',
   filename=None,
   file=DESCRIPTOR,
@@ -499,16 +435,16 @@
   ],
   serialized_options=None,
   is_extendable=False,
   syntax='proto3',
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=854,
-  serialized_end=1077,
+  serialized_start=762,
+  serialized_end=985,
 )
 
 
 _CONNECTORQUERY = _descriptor.Descriptor(
   name='ConnectorQuery',
   full_name='hub.ConnectorQuery',
   filename=None,
@@ -531,16 +467,16 @@
   ],
   serialized_options=None,
   is_extendable=False,
   syntax='proto3',
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1079,
-  serialized_end=1138,
+  serialized_start=987,
+  serialized_end=1046,
 )
 
 
 _CONNECTORQUERYRESULT = _descriptor.Descriptor(
   name='ConnectorQueryResult',
   full_name='hub.ConnectorQueryResult',
   filename=None,
@@ -584,16 +520,16 @@
   ],
   serialized_options=None,
   is_extendable=False,
   syntax='proto3',
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1141,
-  serialized_end=1280,
+  serialized_start=1049,
+  serialized_end=1188,
 )
 
 
 _CONNECTOR_LABELSENTRY = _descriptor.Descriptor(
   name='LabelsEntry',
   full_name='hub.Connector.LabelsEntry',
   filename=None,
@@ -623,16 +559,16 @@
   ],
   serialized_options=b'8\001',
   is_extendable=False,
   syntax='proto3',
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1032,
-  serialized_end=1077,
+  serialized_start=940,
+  serialized_end=985,
 )
 
 _CONNECTOR_SUPPORTEDPAYLOADSENTRY = _descriptor.Descriptor(
   name='SupportedPayloadsEntry',
   full_name='hub.Connector.SupportedPayloadsEntry',
   filename=None,
   file=DESCRIPTOR,
@@ -661,16 +597,16 @@
   ],
   serialized_options=b'8\001',
   is_extendable=False,
   syntax='proto3',
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1773,
-  serialized_end=1852,
+  serialized_start=1681,
+  serialized_end=1760,
 )
 
 _CONNECTOR = _descriptor.Descriptor(
   name='Connector',
   full_name='hub.Connector',
   filename=None,
   file=DESCRIPTOR,
@@ -783,16 +719,16 @@
   ],
   serialized_options=None,
   is_extendable=False,
   syntax='proto3',
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1283,
-  serialized_end=1852,
+  serialized_start=1191,
+  serialized_end=1760,
 )
 
 
 _HUBEVENTSREQUEST = _descriptor.Descriptor(
   name='HubEventsRequest',
   full_name='hub.HubEventsRequest',
   filename=None,
@@ -808,16 +744,16 @@
   ],
   serialized_options=None,
   is_extendable=False,
   syntax='proto3',
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1854,
-  serialized_end=1872,
+  serialized_start=1762,
+  serialized_end=1780,
 )
 
 
 _HUBEVENT = _descriptor.Descriptor(
   name='HubEvent',
   full_name='hub.HubEvent',
   filename=None,
@@ -845,16 +781,16 @@
   oneofs=[
     _descriptor.OneofDescriptor(
       name='type', full_name='hub.HubEvent.type',
       index=0, containing_type=None,
       create_key=_descriptor._internal_create_key,
     fields=[]),
   ],
-  serialized_start=1874,
-  serialized_end=1940,
+  serialized_start=1782,
+  serialized_end=1848,
 )
 
 
 _CONNECTOREVENT_LABELSENTRY = _descriptor.Descriptor(
   name='LabelsEntry',
   full_name='hub.ConnectorEvent.LabelsEntry',
   filename=None,
@@ -884,16 +820,16 @@
   ],
   serialized_options=b'8\001',
   is_extendable=False,
   syntax='proto3',
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1032,
-  serialized_end=1077,
+  serialized_start=940,
+  serialized_end=985,
 )
 
 _CONNECTOREVENT = _descriptor.Descriptor(
   name='ConnectorEvent',
   full_name='hub.ConnectorEvent',
   filename=None,
   file=DESCRIPTOR,
@@ -936,16 +872,16 @@
   ],
   serialized_options=None,
   is_extendable=False,
   syntax='proto3',
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1943,
-  serialized_end=2162,
+  serialized_start=1851,
+  serialized_end=2070,
 )
 
 _SERVERQUERYRESULT.fields_by_name['run_date'].message_type = google_dot_protobuf_dot_timestamp__pb2._TIMESTAMP
 _CONNECTORQUERYFILTER_LABELSENTRY.containing_type = _CONNECTORQUERYFILTER
 _CONNECTORQUERYFILTER.fields_by_name['labels'].message_type = _CONNECTORQUERYFILTER_LABELSENTRY
 _CONNECTORQUERY.fields_by_name['filter'].message_type = _CONNECTORQUERYFILTER
 _CONNECTORQUERYRESULT.fields_by_name['available_connectors'].message_type = _CONNECTOR
@@ -958,16 +894,14 @@
 _HUBEVENT.fields_by_name['connector_event'].message_type = _CONNECTOREVENT
 _HUBEVENT.oneofs_by_name['type'].fields.append(
   _HUBEVENT.fields_by_name['connector_event'])
 _HUBEVENT.fields_by_name['connector_event'].containing_oneof = _HUBEVENT.oneofs_by_name['type']
 _CONNECTOREVENT_LABELSENTRY.containing_type = _CONNECTOREVENT
 _CONNECTOREVENT.fields_by_name['connector_event_type'].enum_type = _CONNECTOREVENTTYPE
 _CONNECTOREVENT.fields_by_name['labels'].message_type = _CONNECTOREVENT_LABELSENTRY
-DESCRIPTOR.message_types_by_name['CancellationEventsRequest'] = _CANCELLATIONEVENTSREQUEST
-DESCRIPTOR.message_types_by_name['CancellationEvent'] = _CANCELLATIONEVENT
 DESCRIPTOR.message_types_by_name['HealthQuery'] = _HEALTHQUERY
 DESCRIPTOR.message_types_by_name['HealthQueryResult'] = _HEALTHQUERYRESULT
 DESCRIPTOR.message_types_by_name['ServerQuery'] = _SERVERQUERY
 DESCRIPTOR.message_types_by_name['ActivateServerRequest'] = _ACTIVATESERVERREQUEST
 DESCRIPTOR.message_types_by_name['ActivateServerResult'] = _ACTIVATESERVERRESULT
 DESCRIPTOR.message_types_by_name['ServerQueryResult'] = _SERVERQUERYRESULT
 DESCRIPTOR.message_types_by_name['ConnectorQueryFilter'] = _CONNECTORQUERYFILTER
@@ -976,28 +910,14 @@
 DESCRIPTOR.message_types_by_name['Connector'] = _CONNECTOR
 DESCRIPTOR.message_types_by_name['HubEventsRequest'] = _HUBEVENTSREQUEST
 DESCRIPTOR.message_types_by_name['HubEvent'] = _HUBEVENT
 DESCRIPTOR.message_types_by_name['ConnectorEvent'] = _CONNECTOREVENT
 DESCRIPTOR.enum_types_by_name['ConnectorEventType'] = _CONNECTOREVENTTYPE
 _sym_db.RegisterFileDescriptor(DESCRIPTOR)
 
-CancellationEventsRequest = _reflection.GeneratedProtocolMessageType('CancellationEventsRequest', (_message.Message,), {
-  'DESCRIPTOR' : _CANCELLATIONEVENTSREQUEST,
-  '__module__' : 'cegalprizm.hub.server_service_pb2'
-  # @@protoc_insertion_point(class_scope:hub.CancellationEventsRequest)
-  })
-_sym_db.RegisterMessage(CancellationEventsRequest)
-
-CancellationEvent = _reflection.GeneratedProtocolMessageType('CancellationEvent', (_message.Message,), {
-  'DESCRIPTOR' : _CANCELLATIONEVENT,
-  '__module__' : 'cegalprizm.hub.server_service_pb2'
-  # @@protoc_insertion_point(class_scope:hub.CancellationEvent)
-  })
-_sym_db.RegisterMessage(CancellationEvent)
-
 HealthQuery = _reflection.GeneratedProtocolMessageType('HealthQuery', (_message.Message,), {
   'DESCRIPTOR' : _HEALTHQUERY,
   '__module__' : 'cegalprizm.hub.server_service_pb2'
   # @@protoc_insertion_point(class_scope:hub.HealthQuery)
   })
 _sym_db.RegisterMessage(HealthQuery)
 
@@ -1127,16 +1047,16 @@
 _SERVERSERVICE = _descriptor.ServiceDescriptor(
   name='ServerService',
   full_name='hub.ServerService',
   file=DESCRIPTOR,
   index=0,
   serialized_options=None,
   create_key=_descriptor._internal_create_key,
-  serialized_start=2235,
-  serialized_end=2656,
+  serialized_start=2143,
+  serialized_end=2479,
   methods=[
   _descriptor.MethodDescriptor(
     name='VerifyHealth',
     full_name='hub.ServerService.VerifyHealth',
     index=0,
     containing_service=None,
     input_type=_HEALTHQUERY,
@@ -1180,23 +1100,13 @@
     index=4,
     containing_service=None,
     input_type=_HUBEVENTSREQUEST,
     output_type=_HUBEVENT,
     serialized_options=None,
     create_key=_descriptor._internal_create_key,
   ),
-  _descriptor.MethodDescriptor(
-    name='GetCancellationEvents',
-    full_name='hub.ServerService.GetCancellationEvents',
-    index=5,
-    containing_service=None,
-    input_type=_CANCELLATIONEVENTSREQUEST,
-    output_type=_CANCELLATIONEVENT,
-    serialized_options=None,
-    create_key=_descriptor._internal_create_key,
-  ),
 ])
 _sym_db.RegisterServiceDescriptor(_SERVERSERVICE)
 
 DESCRIPTOR.services_by_name['ServerService'] = _SERVERSERVICE
 
 # @@protoc_insertion_point(module_scope)
```

## cegalprizm/hub/server_service_pb2_grpc.py

```diff
@@ -35,19 +35,14 @@
                 response_deserializer=cegalprizm_dot_hub_dot_server__service__pb2.ActivateServerResult.FromString,
                 )
         self.GetHubEvents = channel.unary_stream(
                 '/hub.ServerService/GetHubEvents',
                 request_serializer=cegalprizm_dot_hub_dot_server__service__pb2.HubEventsRequest.SerializeToString,
                 response_deserializer=cegalprizm_dot_hub_dot_server__service__pb2.HubEvent.FromString,
                 )
-        self.GetCancellationEvents = channel.unary_stream(
-                '/hub.ServerService/GetCancellationEvents',
-                request_serializer=cegalprizm_dot_hub_dot_server__service__pb2.CancellationEventsRequest.SerializeToString,
-                response_deserializer=cegalprizm_dot_hub_dot_server__service__pb2.CancellationEvent.FromString,
-                )
 
 
 class ServerServiceServicer(object):
     """Missing associated documentation comment in .proto file."""
 
     def VerifyHealth(self, request, context):
         """Missing associated documentation comment in .proto file."""
@@ -75,20 +70,14 @@
 
     def GetHubEvents(self, request, context):
         """Missing associated documentation comment in .proto file."""
         context.set_code(grpc.StatusCode.UNIMPLEMENTED)
         context.set_details('Method not implemented!')
         raise NotImplementedError('Method not implemented!')
 
-    def GetCancellationEvents(self, request, context):
-        """Missing associated documentation comment in .proto file."""
-        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
-        context.set_details('Method not implemented!')
-        raise NotImplementedError('Method not implemented!')
-
 
 def add_ServerServiceServicer_to_server(servicer, server):
     rpc_method_handlers = {
             'VerifyHealth': grpc.unary_unary_rpc_method_handler(
                     servicer.VerifyHealth,
                     request_deserializer=cegalprizm_dot_hub_dot_server__service__pb2.HealthQuery.FromString,
                     response_serializer=cegalprizm_dot_hub_dot_server__service__pb2.HealthQueryResult.SerializeToString,
@@ -109,19 +98,14 @@
                     response_serializer=cegalprizm_dot_hub_dot_server__service__pb2.ActivateServerResult.SerializeToString,
             ),
             'GetHubEvents': grpc.unary_stream_rpc_method_handler(
                     servicer.GetHubEvents,
                     request_deserializer=cegalprizm_dot_hub_dot_server__service__pb2.HubEventsRequest.FromString,
                     response_serializer=cegalprizm_dot_hub_dot_server__service__pb2.HubEvent.SerializeToString,
             ),
-            'GetCancellationEvents': grpc.unary_stream_rpc_method_handler(
-                    servicer.GetCancellationEvents,
-                    request_deserializer=cegalprizm_dot_hub_dot_server__service__pb2.CancellationEventsRequest.FromString,
-                    response_serializer=cegalprizm_dot_hub_dot_server__service__pb2.CancellationEvent.SerializeToString,
-            ),
     }
     generic_handler = grpc.method_handlers_generic_handler(
             'hub.ServerService', rpc_method_handlers)
     server.add_generic_rpc_handlers((generic_handler,))
 
 
  # This class is part of an EXPERIMENTAL API.
@@ -208,24 +192,7 @@
             timeout=None,
             metadata=None):
         return grpc.experimental.unary_stream(request, target, '/hub.ServerService/GetHubEvents',
             cegalprizm_dot_hub_dot_server__service__pb2.HubEventsRequest.SerializeToString,
             cegalprizm_dot_hub_dot_server__service__pb2.HubEvent.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
-
-    @staticmethod
-    def GetCancellationEvents(request,
-            target,
-            options=(),
-            channel_credentials=None,
-            call_credentials=None,
-            insecure=False,
-            compression=None,
-            wait_for_ready=None,
-            timeout=None,
-            metadata=None):
-        return grpc.experimental.unary_stream(request, target, '/hub.ServerService/GetCancellationEvents',
-            cegalprizm_dot_hub_dot_server__service__pb2.CancellationEventsRequest.SerializeToString,
-            cegalprizm_dot_hub_dot_server__service__pb2.CancellationEvent.FromString,
-            options, channel_credentials,
-            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
```

## cegalprizm/hub/task_registry.py

```diff
@@ -1,14 +1,14 @@
 # Copyright 2023 Cegal AS
 # All rights reserved.
 # Unauthorized copying of this file, via any medium is strictly prohibited.
 #
 # This file contains the HubTaskRegistry class which is used to register tasks that Hub clients can execute by
-# by sending requests to the Hub Connector holding this task registry. The HubTaskRegistry holds registered hub tasks
-# that are identified by their wellknown_payload_identifier. The tasks are represented as HubCapabilities. The HubTaskRegistry
+# by sending requests to the Hub Connector holding this task registry. The HubTaskRegistry holds registered hub tasks 
+# that are identified by their wellknown_payload_identifier. The tasks are represented as HubCapabilities. The HubTaskRegistry 
 # methods enable caller to:
 # * Register tasks
 # * Retrieve tasks
 
 
 from types import FunctionType
 from typing import Dict, Iterator, Tuple
@@ -19,15 +19,15 @@
 
 
 class HubTaskRegistry:
 
     def __init__(self):
         self._supported_tasks: Dict[str, HubCapability] = {}
 
-    def register_unary_task(self,
+    def register_unary_task(self, 
                             wellknown_payload_identifier: str,
                             task: FunctionType,
                             friendly_name: str,
                             description: str,
                             payload_auth: PayloadAuth,
                             major_version: int = 0,
                             minor_version: int = 0) -> Tuple[bool, str]:
```

## Comparing `cegalprizm_hub-1.2.2.dist-info/LICENSE` & `cegalprizm_hub-1.2.dev66355.dist-info/LICENSE`

 * *Files 0% similar despite different names*

```diff
@@ -1 +1 @@
-Copyright (2024) Cegal, As. This library (the "Software") may not be used except in connection with the Licensees use of the Cegal Prizm Hub pursuant to an Agreement (defined below) between Licensee (defined below) and Cegal, AS. ("Cegal"). This Software shall be deemed part of the "Subscription Services" under the Agreement. Licensees use of the Software must comply at all times with any restrictions applicable to the Subscription Services, generally, and must be used in accordance with any applicable documentation. If you have not agreed to an Agreement or otherwise do not agree to these terms, you may not use the Software. This license terminates automatically upon the termination of the Agreement or Licensees breach of these terms. Agreement: the agreement between Cegal and Licensee governing the use of the Cegal Prizm Hub, which shall be, with respect to Cegal, and the Cegal Terms of Service located at https://cegal.com/about/terms-and-conditions , in each case unless Licensee has entered into a separate written agreement with Cegal governing the use of the applicable Cegal Services. Licensee: the user of the Software, or, if the Software is being used on behalf of a company, the company.
+Copyright (2023) Cegal, As. This library (the "Software") may not be used except in connection with the Licensees use of the Cegal Prizm Hub pursuant to an Agreement (defined below) between Licensee (defined below) and Cegal, AS. ("Cegal"). This Software shall be deemed part of the "Subscription Services" under the Agreement. Licensees use of the Software must comply at all times with any restrictions applicable to the Subscription Services, generally, and must be used in accordance with any applicable documentation. If you have not agreed to an Agreement or otherwise do not agree to these terms, you may not use the Software. This license terminates automatically upon the termination of the Agreement or Licensees breach of these terms. Agreement: the agreement between Cegal and Licensee governing the use of the Cegal Prizm Hub, which shall be, with respect to Cegal, and the Cegal Terms of Service located at https://cegal.com/about/terms-and-conditions , in each case unless Licensee has entered into a separate written agreement with Cegal governing the use of the applicable Cegal Services. Licensee: the user of the Software, or, if the Software is being used on behalf of a company, the company.
```

## Comparing `cegalprizm_hub-1.2.2.dist-info/METADATA` & `cegalprizm_hub-1.2.dev66355.dist-info/METADATA`

 * *Files 9% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 Metadata-Version: 2.1
 Name: cegalprizm-hub
-Version: 1.2.2
+Version: 1.2.dev66355
 Summary: A Python package to interact with a Cegal Hub Server and Cegal Hub Connectors
 Home-page: https://docs.prizm.cegal-geo.com/
 Author: Cegal Prizm Team
 Author-email: prizm@cegal.com
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: Other/Proprietary License
 Classifier: Operating System :: OS Independent
 Requires-Python: >=3.6
 Description-Content-Type: text/markdown
 License-File: LICENSE
-Requires-Dist: packaging >=21.0
-Requires-Dist: grpcio >=1.33.2
-Requires-Dist: protobuf <4,>=3
-Requires-Dist: cegal-keystoneauth <2,>=1.0.13
+Requires-Dist: packaging (>=21.0)
+Requires-Dist: grpcio (>=1.33.2)
+Requires-Dist: protobuf (<4,>=3)
+Requires-Dist: cegal-keystoneauth (<2,>=1.0.5)
 
 # Introduction
 
 A Python client library to use with a Cegal Hub Server and Cegal Hub Connector applications. Cegal Hub allows for exchange of data and messages across process boundaries on the local machine or across a network or internet. Out of the box the library allows for working with local or remote Cegal Hub Agents or Cegal Hub Connectors such as the Cegal Hub Petrel Connector and for queries against a running Cegal Hub Server which may also be local or remote. The library is designed to be consumed by other Python libraries with knowledge about specific Cegal Hub Connectors and functionality. Cegal Hub is secured using Cegal Keystone.
 
 # Usage
```


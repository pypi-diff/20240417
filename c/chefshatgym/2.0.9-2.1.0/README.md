# Comparing `tmp/chefshatgym-2.0.9-py3-none-any.whl.zip` & `tmp/chefshatgym-2.1.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,31 +1,33 @@
-Zip file size: 58186 bytes, number of entries: 29
+Zip file size: 66367 bytes, number of entries: 31
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Oct-22 21:52 ChefsHatGym/__init__.py
 -rw-rw-rw-  2.0 fat     6314 b- defN 24-Feb-19 17:02 ChefsHatGym/KEF/DataSetManager.py
 -rw-rw-rw-  2.0 fat     3943 b- defN 23-Oct-22 21:52 ChefsHatGym/KEF/ExperimentManager.py
 -rw-rw-rw-  2.0 fat     5439 b- defN 23-Oct-22 21:52 ChefsHatGym/KEF/LogManager.py
 -rw-rw-rw-  2.0 fat     2834 b- defN 23-Oct-22 21:52 ChefsHatGym/KEF/MetricsManager.py
 -rw-rw-rw-  2.0 fat    65452 b- defN 23-Oct-22 21:52 ChefsHatGym/KEF/PlotManager.py
 -rw-rw-rw-  2.0 fat    33311 b- defN 23-Oct-22 21:52 ChefsHatGym/KEF/RenderManager.py
 -rw-rw-rw-  2.0 fat    24979 b- defN 23-Oct-22 21:52 ChefsHatGym/KEF/StatisticsManager.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Oct-22 21:52 ChefsHatGym/KEF/__init__.py
 -rw-rw-rw-  2.0 fat      143 b- defN 23-Oct-22 21:52 ChefsHatGym/agents/__init__.py
 -rw-rw-rw-  2.0 fat     1638 b- defN 23-Oct-24 18:08 ChefsHatGym/agents/agent_random.py
--rw-rw-rw-  2.0 fat    11467 b- defN 23-Oct-24 18:08 ChefsHatGym/agents/chefs_hat_agent.py
--rw-rw-rw-  2.0 fat    48325 b- defN 24-Feb-19 17:27 ChefsHatGym/env/ChefsHatEnv.py
+-rw-rw-rw-  2.0 fat    12596 b- defN 24-Apr-17 11:37 ChefsHatGym/agents/chefs_hat_agent.py
+-rw-rw-rw-  2.0 fat    12622 b- defN 24-Apr-16 22:11 ChefsHatGym/agents/chefs_hat_agent_socket.py
+-rw-rw-rw-  2.0 fat    48325 b- defN 24-Apr-16 20:17 ChefsHatGym/env/ChefsHatEnv.py
 -rw-rw-rw-  2.0 fat      143 b- defN 23-Oct-22 21:52 ChefsHatGym/env/__init__.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Oct-22 21:52 ChefsHatGym/gameRooms/__init__.py
--rw-rw-rw-  2.0 fat    10840 b- defN 23-Oct-24 18:54 ChefsHatGym/gameRooms/chefs_hat_room_local.py
+-rw-rw-rw-  2.0 fat    10986 b- defN 24-Apr-17 11:39 ChefsHatGym/gameRooms/chefs_hat_room_local.py
 -rw-rw-rw-  2.0 fat    16986 b- defN 23-Oct-24 18:08 ChefsHatGym/gameRooms/chefs_hat_room_remote.py
+-rw-rw-rw-  2.0 fat    19649 b- defN 24-Apr-16 22:09 ChefsHatGym/gameRooms/chefs_hat_room_server.py
 -rw-rw-rw-  2.0 fat    12874 b- defN 23-Nov-04 19:10 ChefsHatGym/gameRooms/chefs_hat_tournament.py
 -rw-rw-rw-  2.0 fat      143 b- defN 23-Oct-22 21:52 ChefsHatGym/rewards/__init__.py
 -rw-rw-rw-  2.0 fat      419 b- defN 23-Oct-23 14:06 ChefsHatGym/rewards/only_winning.py
 -rw-rw-rw-  2.0 fat      488 b- defN 23-Oct-23 13:55 ChefsHatGym/rewards/performance_score.py
 -rw-rw-rw-  2.0 fat      261 b- defN 23-Oct-23 14:06 ChefsHatGym/rewards/reward.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Oct-22 21:52 ChefsHatGym/utils/__init__.py
 -rw-rw-rw-  2.0 fat      488 b- defN 23-Oct-23 13:55 ChefsHatGym/utils/utils.py
--rw-rw-rw-  2.0 fat     1089 b- defN 24-Feb-19 17:28 chefshatgym-2.0.9.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     9599 b- defN 24-Feb-19 17:28 chefshatgym-2.0.9.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 24-Feb-19 17:28 chefshatgym-2.0.9.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       12 b- defN 24-Feb-19 17:28 chefshatgym-2.0.9.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     2559 b- defN 24-Feb-19 17:28 chefshatgym-2.0.9.dist-info/RECORD
-29 files, 259838 bytes uncompressed, 54010 bytes compressed:  79.2%
+-rw-rw-rw-  2.0 fat     1089 b- defN 24-Apr-17 11:41 chefshatgym-2.1.0.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     9569 b- defN 24-Apr-17 11:41 chefshatgym-2.1.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-Apr-17 11:41 chefshatgym-2.1.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       12 b- defN 24-Apr-17 11:41 chefshatgym-2.1.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     2765 b- defN 24-Apr-17 11:41 chefshatgym-2.1.0.dist-info/RECORD
+31 files, 293560 bytes uncompressed, 61859 bytes compressed:  78.9%
```

## zipnote {}

```diff
@@ -30,14 +30,17 @@
 
 Filename: ChefsHatGym/agents/agent_random.py
 Comment: 
 
 Filename: ChefsHatGym/agents/chefs_hat_agent.py
 Comment: 
 
+Filename: ChefsHatGym/agents/chefs_hat_agent_socket.py
+Comment: 
+
 Filename: ChefsHatGym/env/ChefsHatEnv.py
 Comment: 
 
 Filename: ChefsHatGym/env/__init__.py
 Comment: 
 
 Filename: ChefsHatGym/gameRooms/__init__.py
@@ -45,14 +48,17 @@
 
 Filename: ChefsHatGym/gameRooms/chefs_hat_room_local.py
 Comment: 
 
 Filename: ChefsHatGym/gameRooms/chefs_hat_room_remote.py
 Comment: 
 
+Filename: ChefsHatGym/gameRooms/chefs_hat_room_server.py
+Comment: 
+
 Filename: ChefsHatGym/gameRooms/chefs_hat_tournament.py
 Comment: 
 
 Filename: ChefsHatGym/rewards/__init__.py
 Comment: 
 
 Filename: ChefsHatGym/rewards/only_winning.py
@@ -66,23 +72,23 @@
 
 Filename: ChefsHatGym/utils/__init__.py
 Comment: 
 
 Filename: ChefsHatGym/utils/utils.py
 Comment: 
 
-Filename: chefshatgym-2.0.9.dist-info/LICENSE
+Filename: chefshatgym-2.1.0.dist-info/LICENSE
 Comment: 
 
-Filename: chefshatgym-2.0.9.dist-info/METADATA
+Filename: chefshatgym-2.1.0.dist-info/METADATA
 Comment: 
 
-Filename: chefshatgym-2.0.9.dist-info/WHEEL
+Filename: chefshatgym-2.1.0.dist-info/WHEEL
 Comment: 
 
-Filename: chefshatgym-2.0.9.dist-info/top_level.txt
+Filename: chefshatgym-2.1.0.dist-info/top_level.txt
 Comment: 
 
-Filename: chefshatgym-2.0.9.dist-info/RECORD
+Filename: chefshatgym-2.1.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## ChefsHatGym/agents/chefs_hat_agent.py

```diff
@@ -1,55 +1,57 @@
 # -*- coding: utf-8 -*-
 from abc import ABCMeta, abstractmethod
 import logging
 import os
 
-import redis
 import json
 import numpy
 
-from ChefsHatGym.gameRooms.chefs_hat_room_remote import REQUEST_TYPE
+from ChefsHatGym.gameRooms.chefs_hat_room_server import REQUEST_TYPE, MESSAGE_TYPE
 import ChefsHatGym.utils.utils as utils
 
+import socket
+import json
+
 
-class ChefsHatAgent:
+class ChefsHatAgent_Server:
     """This is the Agent class interface. Every new Agent must inherit from this class and implement the methods below.
 
     The class is ready to be used in both local and remote rooms. When using a remote room, the agent must be initialized, and the .join() method must be called.
 
 
     """
 
     __metaclass__ = ABCMeta
 
     name = ""  #: Class attribute to store the name of the agent
     saveModelIn = ""  #: Class attribute path to a folder acessible by this agent to save/load from
 
     def __init__(
-        self,
-        agent_suffix,
-        name,
-        saveModelIn: str = "",        
+        self, agent_suffix, name, saveModelIn: str = "", verbose: bool = False
     ):
         """Constructor method. Initializes the agent name.
 
         :param agent_suffix: The name suffix of the agent name.
         :type agent_suffix: str
 
         :param name: The name of the Agent (must be a unique name).
         :type name: str
 
         :param saveModelIn: a folder acessible by this agent to save/load from
         :type saveModelIn: str
 
+        :param saveModelIn: If the agent will print or not the logs
+        :type saveModelIn: str
+
         """
         self.name = f"{agent_suffix}_{name}"
 
         self.saveModelIn = saveModelIn
-        self.verbose = False
+        self.verbose = verbose
         self.stop_actions = False
 
     def get_name(self):
         """Get the agent name.
 
         :return: The agent name
         :rtype: ndarray
@@ -60,17 +62,17 @@
     # Logging functions
     def startLogging(self, logDirectory):
         """Start the logging function
 
         Args:
             logDirectory (_type_): _description_
         """
-        if logDirectory =="":
+        if logDirectory == "":
             logDirectory = "temp/"
-            
+
         self.agent_log_directory = logDirectory
         self.updateLogDirectory()
         self.verbose = True
 
     def updateLogDirectory(
         self,
     ):
@@ -93,194 +95,212 @@
         """
         if self.verbose:
             self.logger.info(f"[Agent {self.name}]:  {message}")
 
     # Remote agent functions
     def joinGame(
         self,
-        room_id: str,
-        redis_url: str = "localhost",
-        redis_port: str = "6379",
-        verbose=False,
+        room_pass: str = "",
+        room_url: str = "localhost",
+        room_port: int = 10000,
+        connection_timeout: int = 10,
     ):
         """
         Allows an agent to enter a remote room, using a specific url and port to a redis server.
 
         Args:
-            room_id (str): _description_
+            room_pass (str): Password fo the room you wanna conntect to
             redis_url (str, optional): _description_. Defaults to "localhost".
             redis_port (str, optional): _description_. Defaults to "6379".
-            verbose (bool, optional): _description_. Defaults to False.
         """
 
-        self.room_id = room_id
-        self.redis_url = redis_url
-        self.redis_port = redis_port
-
-        # Connect to Redis
-        self._connect_to_redis()
-
-        # Register to the room
-        self._subscribe_in_room()
+        self.room_url = room_url
+        self.room_port = room_port
+        self.room_pass = room_pass
+        self.connection_timeout = connection_timeout
+
+        # Connect to the room server
+        try:
+            self._connect_to_room()
+
+            # Register the player to the room
+            self._join_room()
+        except Exception as e:
+            self.log(f"[ERROR!] {e}")
 
-        # Prepare to receive requests from the room
+        # Listen to requests from the server room
 
-        self.send_action_subscriber = self.redis_server.pubsub(
-            ignore_subscribe_messages=True
-        )
-        self.send_action_subscriber.subscribe(
-            **{f"{self.room_id}{self.name}Server": self._read_request}
-        )
+        self._receive_requests()
 
-        if verbose:
-            logDirectory = self.redis_server.get(self.room_id)
-            self.startLogging(logDirectory)
-
-        self._prepare_to_receive_request()
-
-    def _connect_to_redis(self):
-        """Connect to a redis server"""
+    def _connect_to_room(self):
+        """Connect to a room server"""
 
         self.log("---------------------------")
-        self.log("Connecting with Redis")
-        self.log(f"  - Connecting to Redis Server: {self.redis_url}:{self.redis_port}")
+        self.log("Connecting with Room server")
+        self.log(f"  - Room address: {self.room_url}:{self.room_port}")
 
-        self.redis_server = redis.Redis(
-            self.redis_url, self.redis_port, charset="utf_8", decode_responses=True
-        )
+        # Create a TCP/IP socket
+        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+        # Connect the socket to the port where the server is listening
+        server_address = (self.room_url, self.room_port)
+        self.socket.connect(server_address)
+        self.socket.settimeout(self.connection_timeout)
         self.log(f"--------------     -------------")
 
-    def _subscribe_in_room(self):
-        """Send a subscriber message to the room channel"""
+    def _join_room(self):
+        """Join room with this player"""
         self.log("---------------------------")
-        self.log("Connecting to the room")
+        self.log("Joining room...")
 
-        subscribeData = {}
-        subscribeData["playerName"] = self.name
-        self.redis_server.publish(f"{self.room_id}subscribe", json.dumps(subscribeData))
-        self.log(f"  - Registered to the room: {self.room_id}")
+        message = {}
+        message["playerName"] = self.name
+        message["password"] = self.room_pass
+        message = json.dumps(message)
+
+        self.socket.sendall(bytes(message, encoding="utf-8"))
+        while True:
+            room_message = self.socket.recv(1024)
+            if room_message:
+                break
+
+        room_message = json.loads(room_message.decode())
+
+        if room_message["type"] == MESSAGE_TYPE["ERROR"]:
+            self.log(f"[Error] {room_message['message']}")
+        else:
+            self.log(f"  - Registered to the room: {self.room_url}:{self.room_port}")
         self.log(f"---------------------------")
 
     @utils.threaded
-    def _prepare_to_receive_request(self):
+    def _receive_requests(self):
         """
-        threaded listener to the communication room.
+        threaded listener to the communication room.ddddd
 
         """
         self.log("---------------------------")
         self.log("Waiting requests from the room...")
 
-        while True:
-            self.send_action_subscriber.get_message()
-            if self.stop_actions:
-                break
+        while not self.stop_actions:
+            room_message = self.socket.recv(6144)
+
+            if room_message:
+                self._read_message(room_message)
 
-    def _read_request(self, message: str):
+    def _read_message(self, room_message: str):
         """Handler to parse a received message, and call the specific method.
 
         Args:
             message (str): _description_
         """
-        data = json.loads(message["data"])
-        type = data["type"]
 
-        self.log(f"-- Request received: {type}")
+        # print(f"Received message: {room_message}")
+        room_message = json.loads(room_message.decode())
+        type = room_message["type"]
+
+        # print(f"All request types: {REQUEST_TYPE[type]} ")
+
+        self.log(f"-- Request received: {REQUEST_TYPE[type]}")
         # If the received message is a request for an action, do the action and return it
         if type == REQUEST_TYPE["requestAction"]:
-            observations = data["observations"]
+            observations = room_message["observations"]
             action = self.get_action(observations)
 
             self.log(f"-- Sending action: {numpy.argmax(action)}")
 
             self._send_message_to_server(action.tolist())
 
         # If the received message is a request for updating the agent, update the agent
         elif type == REQUEST_TYPE["actionUpdate"]:
             self.log(f"-- Updating the agent after the action was performed!")
-            self.update_my_action(data)
+            self.update_my_action(room_message)
 
         # If the received message is a request for observing others, call the observe others function
         elif type == REQUEST_TYPE["updateOthers"]:
             self.log(f"-- Updating the agent based on other player turn!")
-            self.update_action_others(data)
+            self.update_action_others(room_message)
 
         # If the received message is an information that the match is over, update the agent
         elif type == REQUEST_TYPE["matchOver"]:
             self.log(f"-- Match over! Updating the agent.")
-            self.update_end_match(data)
+            self.update_end_match(room_message)
 
         # If the received message is an information that the match is over, update the agent
         elif type == REQUEST_TYPE["gameOver"]:
             self.log(f"-- Game over! Turning off the agent!")
             self.close()
 
         # If the received message is a request for special action
         elif type == REQUEST_TYPE["doSpecialAction"]:
-            special_action = data["special_action"]
-            action = self.do_special_action(data, action)
+            special_action = room_message["special_action"]
+            action = self.do_special_action(room_message, action)
 
             self.log(f"-- Doing Special action {special_action}: {action}")
 
             self._send_message_to_server(action)
+        elif type == REQUEST_TYPE["specialActionUpdate"]:
+
+            special_action = room_message["special_action"]
+            player = room_message["player"]
+
+            self.log(f"-- Player {player} did a special action: {special_action}")
+            self.observe_special_action(special_action, player)
 
         # If the received message is a exchange cards action
         elif type == REQUEST_TYPE["exchangeCards"]:
-            cards = data["cards"]
-            amount = data["amount"]
+            cards = room_message["cards"]
+            amount = room_message["amount"]
             cards = self.get_exhanged_cards(cards, amount)
 
             self.log(f"-- Exchanging {amount} cards: {cards}")
 
             self._send_message_to_server(cards)
-        
-         # If the received message is a update the begining of the match
+
+        # If the received message is a update the begining of the match
         elif type == REQUEST_TYPE["updateMatchStart"]:
 
-            cards = data["cards"]
-            players = data["players"]
-            starting_player = data["starting_player"]
-            cards = self.update_start_match(cards, players, starting_player)
+            cards = room_message["cards"]
+            players = room_message["players"]
+            starting_player = room_message["starting_player"]
 
-            self.log(f"-- Updating the start of the match")
+            self.log(f"-- Match started!")
 
-            self._send_message_to_server(cards)
+            self.update_start_match(cards, players, starting_player)
 
     def _send_message_to_server(self, agent_action):
         """Send a message to the communication channel.
 
         Args:
             agent_action (_type_): _description_
         """
 
-        sendAction = {}
-        sendAction["agent_action"] = agent_action
-        self.redis_server.publish(
-            f"{self.room_id}{self.name}Agent", json.dumps(sendAction)
-        )
+        message = {}
+        message["agent_action"] = agent_action
+
+        message = json.dumps(message)
+        self.socket.sendall(bytes(message, encoding="utf-8"))
 
     def close(self):
         """Close the receive message handler"""
         self.stop_actions = True
 
+    # Abstract methods that need to be implemented
 
-    #Abstract methods that need to be implemented
- 
     @abstractmethod
     def update_start_match(self, cards, players, starting_player):
         """This method updates the agent about the begining of the match. It contains the cards that the player has at hand.
 
         :param cards: Cards at hand at the begining of the match
         :type cards: list[float]
 
-        
+
         :param starting_player: the names of the starting players
-        :type starting_player: list[str]        
+        :type starting_player: list[str]
 
         :param starting_player: the index of the starting player
-        :type starting_player: list[float]        
+        :type starting_player: list[float]
 
         """
         pass
 
     @abstractmethod
     def get_exhanged_cards(self, cards, amount):
         """This method returns the selected cards when exchanging them at the begining of the match.
@@ -301,14 +321,23 @@
         :type envInfo: [type]
 
         :return: The decision to do or not the special action
         :rtype: ndarray
         """
         pass
 
+    @abstractmethod
+    def observe_special_action(self, action_type, player):
+        """This method updates the agent if an special action was done.
+
+        :param action_type: [description]
+        :type player: [type]
+
+        """
+        pass
 
     @abstractmethod
     def get_action(self, observations):
         """This method returns one action given the observation parameter.
 
         :
         :param envInfo: [description]
@@ -325,15 +354,15 @@
         :param info: [description]
         :type info: dict
 
 
         """
 
         pass
-    
+
     @abstractmethod
     def update_end_match(self, envInfo):
         """This method that is called by the end of each match. This is an oportunity to update the Agent with information gathered in the match.
 
         :param envInfo: [description]
         :type envInfo: [type]
         """
@@ -354,8 +383,7 @@
         """This method that is called after the Agent's action.
 
         :param envInfo: [description]
         :type envInfo: [type]
         """
 
         pass
-
```

## ChefsHatGym/env/ChefsHatEnv.py

```diff
@@ -992,15 +992,15 @@
                     self.board[boardPosition] = i
                     boardPosition = boardPosition + 1
 
         self.playersHand[player] = sorted(self.playersHand[player])
         return originalCardDiscarded
 
     def list_players_with_special_actions(self):
-        """list players that are allowed to do a specialk action
+        """list players that are allowed to do a special actions
 
         Returns:
             _type_: list()
         """
         players_special_action = []
         for i in range(len(self.playersHand)):
             if (
```

## ChefsHatGym/gameRooms/chefs_hat_room_local.py

```diff
@@ -261,14 +261,18 @@
                                 action = player_action[1]
                                 doSpecialAction = self.playersp[
                                     player
                                 ].do_special_action(info, action)
                                 if doSpecialAction:
                                     self.env.doSpecialAction(player, action)
                                     playerSpecialAction = player
+
+                                    for p in self.players:
+                                        p.observe_special_action(action, player)
+
                                     break
 
                         # Once the cards are handled again, the chef and sous-chef have to choose which cards to give
                         (
                             player_sourchef,
                             sc_cards,
                             player_chef,
```

## Comparing `chefshatgym-2.0.9.dist-info/LICENSE` & `chefshatgym-2.1.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `chefshatgym-2.0.9.dist-info/METADATA` & `chefshatgym-2.1.0.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: chefshatgym
-Version: 2.0.9
+Version: 2.1.0
 Summary: A python interface for training Reinforcement Learning agents to play the Chef's Hat Card Game.
 Home-page: https://github.com/pablovin/ChefsHatGYM
 Author: Pablo Barros
 Author-email: Pablo Barros <pablovin@gmail.com>
 License: MIT
 Classifier: Development Status :: 3 - Alpha
 Classifier: Intended Audience :: Developers
@@ -26,15 +26,14 @@
 Description-Content-Type: text/markdown
 License-File: LICENSE
 Requires-Dist: gym ==0.26.2
 Requires-Dist: matplotlib ==3.8.0
 Requires-Dist: numpy ==1.26.1
 Requires-Dist: pandas ==2.1.1
 Requires-Dist: python-dateutil ==2.8.2
-Requires-Dist: redis ==5.0.1
 Requires-Dist: opencv-python ==4.8.1.78
 
 
 ![Chef's Hat Card Game](gitImages/chefsHatLogo.png)
 
 ## ChefsHatGym V2
```

## Comparing `chefshatgym-2.0.9.dist-info/RECORD` & `chefshatgym-2.1.0.dist-info/RECORD`

 * *Files 10% similar despite different names*

```diff
@@ -5,25 +5,27 @@
 ChefsHatGym/KEF/MetricsManager.py,sha256=5KlC1chrmhZCNvmivMq4ZD_UhCxju3UK5X7VkLdY_BI,2834
 ChefsHatGym/KEF/PlotManager.py,sha256=sAT5ZXjzPCtyHy5kFQOwRN2oiXrIT4dxNmL5llJIBfU,65452
 ChefsHatGym/KEF/RenderManager.py,sha256=wvNLEWSOKVQeqscmth6OzgZp-G7oz0B56kZ82a7B0Ec,33311
 ChefsHatGym/KEF/StatisticsManager.py,sha256=yGHFh25Z8z-bTQKeqGoE512SNlYxrTwHANGlIFSORFc,24979
 ChefsHatGym/KEF/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 ChefsHatGym/agents/__init__.py,sha256=vKCxNh8cHhItBsozALqDD1MsjU2G_VWhLsu34Ftyhfs,143
 ChefsHatGym/agents/agent_random.py,sha256=_rLQkbnQDHB2t_uQSk9BlJx6ZmxsyPefCRuCj2Xm6Co,1638
-ChefsHatGym/agents/chefs_hat_agent.py,sha256=8IYrq8ZClGPmBBCeVq5jZV4yqgSRG8Lgf2PVDicRdNo,11467
-ChefsHatGym/env/ChefsHatEnv.py,sha256=0uE52DfOjqBtOLIc80bw-ctGlQcKDEU4c1sDuxdWyWI,48325
+ChefsHatGym/agents/chefs_hat_agent.py,sha256=McgkmnWyOXYfOmzmxx6aAoHfZ3lE-zclQpuWzB7YKlU,12596
+ChefsHatGym/agents/chefs_hat_agent_socket.py,sha256=bUmx-2TVIF8ETNqU2gRDUJ-QeYeiaVV93ws9v2u2SdE,12622
+ChefsHatGym/env/ChefsHatEnv.py,sha256=NaIn97bjoIJc2OenGPg7UkK3FMNllZTARQydNCihgnM,48325
 ChefsHatGym/env/__init__.py,sha256=vKCxNh8cHhItBsozALqDD1MsjU2G_VWhLsu34Ftyhfs,143
 ChefsHatGym/gameRooms/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-ChefsHatGym/gameRooms/chefs_hat_room_local.py,sha256=AHHGRpNRuieUxFjQ0J-nNnYTwRikwljlBI5aQ01yww8,10840
+ChefsHatGym/gameRooms/chefs_hat_room_local.py,sha256=NLAEvoVq8cNm15buq9GQTOghCTLb9WEInEybiuNe5M0,10986
 ChefsHatGym/gameRooms/chefs_hat_room_remote.py,sha256=riqBg8BJVjvZsidc37dGtH-FcFlXjvBAvr7wlcnOiTo,16986
+ChefsHatGym/gameRooms/chefs_hat_room_server.py,sha256=RCLRMw6BcLHvXwIk7vTXf9zhnh3NCsJWtXzs8pnrsUk,19649
 ChefsHatGym/gameRooms/chefs_hat_tournament.py,sha256=ZLF1S4QlS29bvDzk3a8LHK59zF0o3QnN5PbbY3Opwew,12874
 ChefsHatGym/rewards/__init__.py,sha256=vKCxNh8cHhItBsozALqDD1MsjU2G_VWhLsu34Ftyhfs,143
 ChefsHatGym/rewards/only_winning.py,sha256=4mdxRGt5-IsVJWZl9yAzScLLYcoyT0w3Y7euft1HTq4,419
 ChefsHatGym/rewards/performance_score.py,sha256=PaehIySmjlEllohRC7ip51cnFsrhZdG6SxSj7dcy-0o,488
 ChefsHatGym/rewards/reward.py,sha256=WW3VR7MuwrmTDSLfd5inDuOLDOEXSgi1rw7SdCftTP0,261
 ChefsHatGym/utils/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 ChefsHatGym/utils/utils.py,sha256=sDE0Vijgcgprz-SxUjmcCW7JsyMrsTGjNwUAcx939kY,488
-chefshatgym-2.0.9.dist-info/LICENSE,sha256=hCCVx5b2fVwXmX_xxzdEFQu2-QRUOumXbw5K0Z7LvI0,1089
-chefshatgym-2.0.9.dist-info/METADATA,sha256=zwia_yeKJY-MztXH5nL7Pbqc2K4-VrsnunhOb5mdQTU,9599
-chefshatgym-2.0.9.dist-info/WHEEL,sha256=yQN5g4mg4AybRjkgi-9yy4iQEFibGQmlz78Pik5Or-A,92
-chefshatgym-2.0.9.dist-info/top_level.txt,sha256=ekL7ntfrArepYZ6Sd1Omlh-xRAjzb7N5yp657GSMmJM,12
-chefshatgym-2.0.9.dist-info/RECORD,,
+chefshatgym-2.1.0.dist-info/LICENSE,sha256=hCCVx5b2fVwXmX_xxzdEFQu2-QRUOumXbw5K0Z7LvI0,1089
+chefshatgym-2.1.0.dist-info/METADATA,sha256=nkAiqbWdvTLlaLHpuQ4amMQXf_ubAAZ-OgKlp93LIJI,9569
+chefshatgym-2.1.0.dist-info/WHEEL,sha256=yQN5g4mg4AybRjkgi-9yy4iQEFibGQmlz78Pik5Or-A,92
+chefshatgym-2.1.0.dist-info/top_level.txt,sha256=ekL7ntfrArepYZ6Sd1Omlh-xRAjzb7N5yp657GSMmJM,12
+chefshatgym-2.1.0.dist-info/RECORD,,
```


# Comparing `tmp/armodel-1.1.0-py3-none-any.whl.zip` & `tmp/armodel-1.2.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,29 +1,29 @@
-Zip file size: 33261 bytes, number of entries: 27
--rw-rw-rw-  2.0 fat       54 b- defN 22-Apr-09 05:54 armodel/__init__.py
--rw-rw-rw-  2.0 fat        0 b- defN 22-Apr-09 05:54 armodel/cli/__init__.py
--rw-rw-rw-  2.0 fat     9932 b- defN 23-Jan-28 15:17 armodel/cli/arxml_dump_cli.py
--rw-rw-rw-  2.0 fat      402 b- defN 23-Jan-26 07:52 armodel/models/__init__.py
--rw-rw-rw-  2.0 fat      341 b- defN 23-Jan-29 14:38 armodel/models/ar_object.py
--rw-rw-rw-  2.0 fat    11921 b- defN 23-Jan-29 14:38 armodel/models/ar_package.py
--rw-rw-rw-  2.0 fat     3548 b- defN 23-Jan-29 14:38 armodel/models/ar_ref.py
--rw-rw-rw-  2.0 fat    11778 b- defN 23-Jan-28 15:17 armodel/models/bsw_module_template.py
--rw-rw-rw-  2.0 fat     6559 b- defN 23-Feb-02 23:10 armodel/models/common_structure.py
--rw-rw-rw-  2.0 fat      867 b- defN 22-Apr-09 05:54 armodel/models/data_dictionary.py
--rw-rw-rw-  2.0 fat     2096 b- defN 22-Apr-09 05:54 armodel/models/data_prototype.py
--rw-rw-rw-  2.0 fat     5802 b- defN 22-Apr-09 05:54 armodel/models/datatype.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Jan-29 14:38 armodel/models/ecuc_parameter_def_template.py
--rw-rw-rw-  2.0 fat     4480 b- defN 23-Jan-29 14:38 armodel/models/general_structure.py
--rw-rw-rw-  2.0 fat     3875 b- defN 23-Jan-30 02:15 armodel/models/implementation.py
--rw-rw-rw-  2.0 fat     2165 b- defN 22-Apr-09 05:54 armodel/models/m2_msr.py
--rw-rw-rw-  2.0 fat     6026 b- defN 22-Apr-09 05:54 armodel/models/port_interface.py
--rw-rw-rw-  2.0 fat     7215 b- defN 22-Apr-15 11:47 armodel/models/port_prototype.py
--rw-rw-rw-  2.0 fat    20503 b- defN 23-Jan-28 15:17 armodel/models/sw_component.py
--rw-rw-rw-  2.0 fat       37 b- defN 22-Apr-09 05:54 armodel/parser/__init__.py
--rw-rw-rw-  2.0 fat    55261 b- defN 23-Feb-04 11:29 armodel/parser/arxml_parser.py
--rw-rw-rw-  2.0 fat     1088 b- defN 23-Mar-12 02:10 armodel-1.1.0.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     4359 b- defN 23-Mar-12 02:10 armodel-1.1.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Mar-12 02:10 armodel-1.1.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       68 b- defN 23-Mar-12 02:10 armodel-1.1.0.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat        8 b- defN 23-Mar-12 02:10 armodel-1.1.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     2292 b- defN 23-Mar-12 02:10 armodel-1.1.0.dist-info/RECORD
-27 files, 160769 bytes uncompressed, 29541 bytes compressed:  81.6%
+Zip file size: 33606 bytes, number of entries: 27
+-rw-rw-rw-  2.0 fat       54 b- defN 24-Apr-15 14:31 armodel/__init__.py
+-rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-15 14:31 armodel/cli/__init__.py
+-rw-rw-rw-  2.0 fat     9932 b- defN 24-Apr-15 14:31 armodel/cli/arxml_dump_cli.py
+-rw-rw-rw-  2.0 fat      402 b- defN 24-Apr-15 14:31 armodel/models/__init__.py
+-rw-rw-rw-  2.0 fat      341 b- defN 24-Apr-15 14:31 armodel/models/ar_object.py
+-rw-rw-rw-  2.0 fat    13275 b- defN 24-Apr-16 13:39 armodel/models/ar_package.py
+-rw-rw-rw-  2.0 fat     3548 b- defN 24-Apr-15 14:31 armodel/models/ar_ref.py
+-rw-rw-rw-  2.0 fat    11778 b- defN 24-Apr-15 14:31 armodel/models/bsw_module_template.py
+-rw-rw-rw-  2.0 fat     6745 b- defN 24-Apr-16 10:59 armodel/models/common_structure.py
+-rw-rw-rw-  2.0 fat      867 b- defN 24-Apr-15 14:31 armodel/models/data_dictionary.py
+-rw-rw-rw-  2.0 fat     2096 b- defN 24-Apr-15 14:31 armodel/models/data_prototype.py
+-rw-rw-rw-  2.0 fat     5802 b- defN 24-Apr-15 14:31 armodel/models/datatype.py
+-rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-15 14:31 armodel/models/ecuc_parameter_def_template.py
+-rw-rw-rw-  2.0 fat     4480 b- defN 24-Apr-15 14:31 armodel/models/general_structure.py
+-rw-rw-rw-  2.0 fat     3850 b- defN 24-Apr-15 14:35 armodel/models/implementation.py
+-rw-rw-rw-  2.0 fat     2165 b- defN 24-Apr-15 14:31 armodel/models/m2_msr.py
+-rw-rw-rw-  2.0 fat     6026 b- defN 24-Apr-15 14:31 armodel/models/port_interface.py
+-rw-rw-rw-  2.0 fat     7215 b- defN 24-Apr-15 14:31 armodel/models/port_prototype.py
+-rw-rw-rw-  2.0 fat    20503 b- defN 24-Apr-15 14:31 armodel/models/sw_component.py
+-rw-rw-rw-  2.0 fat       37 b- defN 24-Apr-15 14:31 armodel/parser/__init__.py
+-rw-rw-rw-  2.0 fat    55951 b- defN 24-Apr-16 14:17 armodel/parser/arxml_parser.py
+-rw-rw-rw-  2.0 fat     1088 b- defN 24-Apr-16 14:19 armodel-1.2.0.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     4998 b- defN 24-Apr-16 14:19 armodel-1.2.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-Apr-16 14:19 armodel-1.2.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       68 b- defN 24-Apr-16 14:19 armodel-1.2.0.dist-info/entry_points.txt
+-rw-rw-rw-  2.0 fat        8 b- defN 24-Apr-16 14:19 armodel-1.2.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     2292 b- defN 24-Apr-16 14:19 armodel-1.2.0.dist-info/RECORD
+27 files, 163613 bytes uncompressed, 29886 bytes compressed:  81.7%
```

## zipnote {}

```diff
@@ -57,26 +57,26 @@
 
 Filename: armodel/parser/__init__.py
 Comment: 
 
 Filename: armodel/parser/arxml_parser.py
 Comment: 
 
-Filename: armodel-1.1.0.dist-info/LICENSE
+Filename: armodel-1.2.0.dist-info/LICENSE
 Comment: 
 
-Filename: armodel-1.1.0.dist-info/METADATA
+Filename: armodel-1.2.0.dist-info/METADATA
 Comment: 
 
-Filename: armodel-1.1.0.dist-info/WHEEL
+Filename: armodel-1.2.0.dist-info/WHEEL
 Comment: 
 
-Filename: armodel-1.1.0.dist-info/entry_points.txt
+Filename: armodel-1.2.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: armodel-1.1.0.dist-info/top_level.txt
+Filename: armodel-1.2.0.dist-info/top_level.txt
 Comment: 
 
-Filename: armodel-1.1.0.dist-info/RECORD
+Filename: armodel-1.2.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## armodel/models/ar_package.py

```diff
@@ -1,14 +1,14 @@
 from typing import List
 from .general_structure import Identifiable, ARObject, Referrable, CollectableElement, SwcBswMapping
 from .port_interface import SenderReceiverInterface, ClientServerInterface
-from .sw_component import SwComponentType, EcuAbstractionSwComponentType, AtomicSwComponentType, ApplicationSwComponentType, ServiceSwComponentType, CompositionSwComponentType
+from .sw_component import SwComponentType, EcuAbstractionSwComponentType, AtomicSwComponentType, ApplicationSwComponentType, ServiceSwComponentType, CompositionSwComponentType, SensorActuatorSwComponentType
 from .datatype import ImplementationDataType, ApplicationDataType, DataTypeMappingSet, DataTypeMap, SwBaseType, ApplicationPrimitiveDataType, ApplicationRecordDataType
 from .m2_msr import CompuMethod
-from .implementation import BswImplementation
+from .implementation import BswImplementation, SwcImplementation, Implementation
 from .bsw_module_template import BswModuleDescription, BswModuleEntry
 
 class ARPackage(Identifiable, CollectableElement):
     def __init__(self, parent: ARObject, short_name: str):
         Identifiable.__init__(self, parent, short_name)
         CollectableElement.__init__(self)
 
@@ -34,14 +34,20 @@
         return self.elements[short_name]
 
     def createServiceSwComponentType(self, short_name: str) -> ServiceSwComponentType:
         if (short_name not in self.elements):
             sw_component = ServiceSwComponentType(self, short_name)
             self.elements[short_name] = sw_component
         return self.elements[short_name]
+    
+    def createSensorActuatorSwComponentType(self, short_name: str) -> SensorActuatorSwComponentType:
+        if (short_name not in self.elements):
+            sw_component = SensorActuatorSwComponentType(self, short_name)
+            self.elements[short_name] = sw_component
+        return self.elements[short_name]
 
     def createCompositionSwComponentType(self, short_name: str) -> CompositionSwComponentType:
         if (short_name not in self.elements):
             sw_component = CompositionSwComponentType(self, short_name)
             self.elements[short_name] = sw_component
         return self.elements[short_name]
 
@@ -106,14 +112,20 @@
         return self.elements[short_name]
 
     def createBswImplementation(self, short_name: str) -> BswImplementation:
         if (short_name not in self.elements):
             sw_component = BswImplementation(self, short_name)
             self.elements[short_name] = sw_component
         return self.elements[short_name]
+    
+    def createSwcImplementation(self, short_name: str) -> SwcImplementation:
+        if (short_name not in self.elements):
+            sw_component = SwcImplementation(self, short_name)
+            self.elements[short_name] = sw_component
+        return self.elements[short_name]
 
     def createSwcBswMapping(self, short_name: str) -> SwcBswMapping:
         if (short_name not in self.elements):
             sw_component = SwcBswMapping(self, short_name)
             self.elements[short_name] = sw_component
         return self.elements[short_name]
 
@@ -124,14 +136,17 @@
         return list(filter(lambda a: isinstance(a, ImplementationDataType), self.elements.values()))
 
     def getSwBaseTypes(self) -> List[SwBaseType]:
         return list(filter(lambda a: isinstance(a, SwBaseType), self.elements.values()))
 
     def getSwComponentTypes(self) -> List[SwComponentType]:
         return list(filter(lambda a : isinstance(a, SwComponentType), self.elements.values()))
+    
+    def getSensorActuatorSwComponentType(self) -> List[SensorActuatorSwComponentType]:
+        return list(filter(lambda a : isinstance(a, SensorActuatorSwComponentType), self.elements.values()))
 
     def getAtomicSwComponentTypes(self) -> List[AtomicSwComponentType]:
         return list(filter(lambda a : isinstance(a, AtomicSwComponentType), self.elements.values()))
 
     def getCompositionSwComponentTypes(self) -> List[CompositionSwComponentType]:
         return list(filter(lambda a : isinstance(a, CompositionSwComponentType), self.elements.values()))
 
@@ -151,14 +166,20 @@
         return list(filter(lambda a: isinstance(a, BswModuleDescription), self.elements.values()))
 
     def getBswModuleEntries(self) -> List[BswModuleEntry]:
         return list(filter(lambda a: isinstance(a, BswModuleEntry), self.elements.values()))
 
     def getBswImplementations(self) -> List[BswImplementation]:
         return list(filter(lambda a: isinstance(a, BswImplementation), self.elements.values()))
+    
+    def getSwcImplementations(self) -> List[SwcImplementation]:
+        return list(filter(lambda a: isinstance(a, SwcImplementation), self.elements.values()))
+    
+    def getImplementations(self) -> List[Implementation]:
+        return list(filter(lambda a: isinstance(a, Implementation), self.elements.values()))
 
     def getSwcBswMappings(self) -> List[SwcBswMapping]:
         return list(filter(lambda a: isinstance(a, SwcBswMapping), self.elements.values()))
 
 class AUTOSAR (ARObject, CollectableElement):
     __instance = None
 
@@ -216,14 +237,16 @@
                     referred_type = self.find(data_type.sw_data_def_props.sw_pointer_target_props.sw_data_def_props.base_type_ref.value)
                     return self.getDataType(referred_type)
             return data_type
         else:
             raise ValueError("%s is not ImplementationDataType." % data_type)
             
     def addDataTypeMap(self, data_type_map: DataTypeMap):
+        if (data_type_map.application_data_type_ref is None) or (data_type_map.implementation_data_type_ref is None):
+            return
         self._appl_impl_type_maps[data_type_map.application_data_type_ref.value] = data_type_map.implementation_data_type_ref.value
         self._impl_appl_type_maps[data_type_map.implementation_data_type_ref.value] = data_type_map.application_data_type_ref.value
 
     def convertToImplementationDataType(self, appl_data_type: str) -> ImplementationDataType:
         if (appl_data_type not in self._appl_impl_type_maps.keys()):
             raise IndexError("Invalid application data type <%s>" % appl_data_type)
```

## armodel/models/common_structure.py

```diff
@@ -1,15 +1,18 @@
-import re
+#from __future__ import annotations
+
 from abc import ABCMeta
 from typing import List
 
 from .general_structure import ARObject, ARElement, Identifiable
 from .data_dictionary import SwDataDefProps
 from .ar_ref import RefType
 
+import re
+
 class ValueSpecification(ARObject, metaclass=ABCMeta):
     def __init__(self):
         if type(self) == ValueSpecification:
             raise NotImplementedError("ValueSpecification is an abstract class.")
         super().__init__()
 
         self.short_label = None
@@ -135,19 +138,25 @@
 
     @property
     def alignment(self) -> str:
         return self._alignment
 
     @alignment.setter
     def alignment(self, value:str):
-        if value  in ("UNKNOWN", "UNSPECIFIED", "BOOLEAN", "PTR"):
-            self._alignment = value
-        elif re.match(r'\d+', value):
+        match = False
+        if value in ("UNKNOWN", "UNSPECIFIED", "BOOLEAN", "PTR"):
             self._alignment = value
+            match = True
         else:
+            m = re.match(r'^\d+', value)
+            if m:
+                self._alignment = value
+                match = True
+                
+        if not match:
             raise ValueError("Invalid alignment <%s> of memory section <%s>" % (value, self.short_name))
         
 
 class ResourceConsumption(Identifiable):
     def __init__(self, parent: ARObject, short_name: str):
         super().__init__(parent, short_name)
```

## armodel/models/implementation.py

```diff
@@ -70,18 +70,19 @@
 class BswImplementation(Implementation):
     def __init__(self, parent: ARObject, short_name: str) -> None:
         super().__init__(parent, short_name)
 
         self.ar_release_version = ""
         self.revision_label_string = ""                 # 1
         self.behavior_ref = None                        # type: RefType
-        self.preconfigured_configuration_refs = []      # type: List[RefType]
-        self.recommended_configuration_refs = []        # type: List[RefType]
+        self.preconfigured_configuration_ref = None     # *
+        self.recommended_configuration_ref = None       # *
         self.vendor_api_infix = ""                      # 0..1
-        self.vendor_specific_module_def_refs = []     # List[RefType]
+        self.vendor_specific_module_def_ref = None      # *
 
-    def addVendorSpecificModuleDefRef(self, vendor_specific_module_def_ref: RefType):
-        self.vendor_specific_module_def_refs.append(vendor_specific_module_def_ref)
-
-    def getVendorSpecificModuleDefRefs(self) -> List[RefType]:
-        return self.vendor_specific_module_def_refs
+class SwcImplementation(Implementation):
+    def __init__(self, parent: ARObject, short_name: str) -> None:
+        super().__init__(parent, short_name)
 
+        self.behavior_ref = None                        # type: RefType
+        self.per_instance_memory_size = None
+        self.required_rte_vendor = ""
```

## armodel/parser/arxml_parser.py

```diff
@@ -121,24 +121,21 @@
     def readChildOptionalRefElement(self, element, key) -> RefType:
         child_element = element.find("./xmlns:%s" % key, self.nsmap)
         if (child_element != None):
             return self._readChildRefElementDestAndValue(child_element)
         return None
 
     def readChildRefElementList(self, element, key) -> List[RefType]:
-        list_element = element.find("./xmlns:%sS" % key, self.nsmap)
+        child_elements = element.findall("./xmlns:%s" % key, self.nsmap)
         results = []
-        if list_element != None:
-            child_elements = list_element.findall("./xmlns:%s" % key, self.nsmap)
-            for child_element in child_elements:
-                ref = RefType()
-                ref.dest = child_element.attrib['DEST']
-                ref.value = child_element.text
-                results.append(ref)
-
+        for child_element in child_elements:
+            ref = RefType()
+            ref.dest = child_element.attrib['DEST']
+            ref.value = child_element.text
+            results.append(ref)
         return results
 
     def readAutosarVariableInImplDatatype(self, element, accessed_variable_ref: AutosarVariableRef):
         child_element = element.find("./xmlns:ACCESSED-VARIABLE/xmlns:AUTOSAR-VARIABLE-IREF", self.nsmap)
         if (child_element != None):
             autosar_variable_in_impl_datatype = ArVariableInImplementationDataInstanceRef()
             autosar_variable_in_impl_datatype.port_prototype_ref = self.readChildOptionalRefElement(child_element, "PORT-PROTOTYPE-REF")
@@ -193,16 +190,18 @@
         for child_element in element.findall("./xmlns:REQUIRED-MODE-GROUPS/xmlns:MODE-DECLARATION-GROUP-PROTOTYPE", self.nsmap):
             short_name = self.readShortName(child_element)
             logging.debug("readRequiredModeGroup %s" % short_name)
             mode_group = parent.createProvidedModeGroup(short_name)
             mode_group.type_tref = self.readChildRefElement(parent.short_name, child_element, "TYPE-TREF")
 
     def readCanEnterExclusiveAreaRefs(self, element, entity: ExecutableEntity):
-        for ref in self.readChildRefElementList(element, "CAN-ENTER-EXCLUSIVE-AREA-REF"):
-            entity.addCanEnterExclusiveAreaRef(ref)
+        child_element = element.find("./xmlns:CAN-ENTER-EXCLUSIVE-AREA-REFS", self.nsmap)
+        if child_element != None:
+            for ref in self.readChildRefElementList(child_element, "CAN-ENTER-EXCLUSIVE-AREA-REF"):
+                entity.addCanEnterExclusiveAreaRef(ref)
 
     def readExecutableEntity(self, element, entity: ExecutableEntity):
         self.readCanEnterExclusiveAreaRefs(element, entity)
 
     def readBswModuleEntity(self, element, entity: BswModuleEntity):
         self.readExecutableEntity(element, entity)
         
@@ -262,39 +261,38 @@
             logging.debug("readBswInternalTriggerOccurredEvent %s" % short_name)
             event = parent.createBswInternalTriggerOccurredEvent(short_name)
             event.event_source_ref = self.readChildRefElement(parent.short_name, child_element, "EVENT-SOURCE-REF")
 
             self.readBswScheduleEvent(child_element, event)
 
     def readDataTypeMappingRefs(self, element, behavior: InternalBehavior):
-        for ref in self.readChildRefElementList(element, "DATA-TYPE-MAPPING-REF"):
-            behavior.addDataTypeMappingRef(ref)
+        child_element = element.find("./xmlns:DATA-TYPE-MAPPING-REFS", self.nsmap)
+        if child_element != None:
+            for ref in self.readChildRefElementList(child_element, "DATA-TYPE-MAPPING-REF"):
+                behavior.addDataTypeMappingRef(ref)
 
     def readInternalBehavior(self, element, behavior: InternalBehavior):
         for child_element in element.findall("./xmlns:EXCLUSIVE-AREAS/xmlns:EXCLUSIVE-AREA", self.nsmap):
             short_name = self.readShortName(child_element)
             behavior.createExclusiveArea(short_name)
 
         self.readDataTypeMappingRefs(element, behavior)
 
     def readSwInternalBehavior(self, element, parent: AtomicSwComponentType):
         for child_element in element.findall("./xmlns:INTERNAL-BEHAVIORS/xmlns:SWC-INTERNAL-BEHAVIOR", self.nsmap):
             short_name = self.readShortName(child_element)
             behavior = parent.createSwcInternalBehavior(short_name)
-            logging.debug("readSwInternalBehavior %s" % behavior.full_name)
+            logging.debug("readBswInternalBehavior %s" % behavior.full_name)
 
             # read the internal behavior
             self.readInternalBehavior(child_element, behavior)
 
             self.readRunnableEntities(child_element, behavior)
             self.readOperationInvokedEvents(child_element, behavior)
-            self.readInitEvents(child_element, behavior)
             self.readTimingEvents(child_element, behavior)
-            self.readDataReceivedEvent(child_element, behavior)
-            self.readSwcModeSwitchEvent(child_element, behavior)
             self.readInternalTriggerOccurredEvent(child_element, behavior)
             self.readExplicitInterRunnableVariables(child_element, behavior)
 
     def readBswInternalBehavior(self, element, parent: BswModuleDescription):
         for child_element in element.findall("./xmlns:INTERNAL-BEHAVIORS/xmlns:BSW-INTERNAL-BEHAVIOR", self.nsmap):
             short_name = self.readShortName(child_element)
             behavior = parent.createBswInternalBehavior(short_name)
@@ -370,36 +368,40 @@
             return
         short_name = self.readShortName(child_element)
         impl.resource_consumption = ResourceConsumption(impl, short_name)
         self.readMemorySections(child_element, impl.resource_consumption)
 
     def readImplementation(self, element, impl: Implementation):
         self.readCodeDescriptor(element, impl)
-        impl.programming_language = self.readChildElement(impl.short_name, element, "PROGRAMMING-LANGUAGE")
+        impl.programming_language = self.readChildOptionalElement(element, "PROGRAMMING-LANGUAGE")
         self.readResourceConsumption(element, impl)
-        impl.sw_version = self.readChildElement(impl.short_name, element, "SW-VERSION")
+        impl.sw_version = self.readChildOptionalElement(element, "SW-VERSION")
         impl.swc_bsw_mapping_ref = self.readChildOptionalRefElement(element, "SWC-BSW-MAPPING-REF")
         impl.vendor_id = self.readChildOptionalElementNumberValue(element, "VENDOR-ID")
-        if (impl.vendor_id == None):
-            self._raiseError("Vendor id of <%s> is required" % impl.short_name)
-
-    def readVendorSpecificModuleDefs(self, element, impl: BswImplementation):
-        for ref in self.readChildRefElementList(element, "VENDOR-SPECIFIC-MODULE-DEF-REF"):
-            impl.addVendorSpecificModuleDefRef(ref)
 
     def readBswImplementation(self, element, parent: ARPackage):
         for child_element in element.findall("./xmlns:ELEMENTS/xmlns:BSW-IMPLEMENTATION", self.nsmap):
             short_name = self.readShortName(child_element)
-            impl = parent.createBswImplementation(short_name)
-            logging.debug("readImplementation %s" % impl.short_name)
+            impl = parent.createBswImplementation(short_name)   
+            logging.debug("readBswImplementation %s" % impl.short_name)
 
             self.readImplementation(child_element, impl)
+
             impl.ar_release_version = self.readChildElement(parent.short_name, child_element, "AR-RELEASE-VERSION")
             impl.behavior_ref = self.readChildRefElement(parent.short_name, child_element, "BEHAVIOR-REF")
-            self.readVendorSpecificModuleDefs(child_element, impl)
+
+    def readSwcImplementation(self, element, parent: ARPackage):
+        for child_element in element.findall("./xmlns:ELEMENTS/xmlns:SWC-IMPLEMENTATION", self.nsmap):
+            short_name = self.readShortName(child_element)
+            impl = parent.createSwcImplementation(short_name)   
+            logging.debug("readSwcImplementation %s" % impl.short_name)
+
+            self.readImplementation(child_element, impl)
+
+            impl.behavior_ref = self.readChildRefElement(parent.short_name, child_element, "BEHAVIOR-REF")
 
     def readDataReceivePointByArguments(self, element, parent: RunnableEntity):
         self._readVariableAccesses(element, parent, "DATA-RECEIVE-POINT-BY-ARGUMENTS")
 
     def readDataReceivePointByValues(self, element, parent: RunnableEntity):
         self._readVariableAccesses(element, parent, "DATA-RECEIVE-POINT-BY-VALUES")
 
@@ -459,29 +461,29 @@
             point = parent.createInternalTriggeringPoint(short_name)
             point.sw_impl_policy = self.readChildOptionalElement(child_element, "SW-IMPL-POLICY")
 
     def readRunnableEntities(self, element, parent: SwcInternalBehavior):
         for child_element in element.findall("./xmlns:RUNNABLES/xmlns:RUNNABLE-ENTITY", self.nsmap):
             short_name = self.readShortName(child_element)
             runnable = parent.createRunnableEntity(short_name)
-            runnable.can_be_invoked_concurrently = self.readChildElement(short_name, child_element, "CAN-BE-INVOKED-CONCURRENTLY")
+            runnable.can_be_invoked_concurrently = self.readChildOptionalElement(child_element, "CAN-BE-INVOKED-CONCURRENTLY")
             runnable.symbol = self.readChildElement(short_name, child_element, "SYMBOL")
 
             self.readDataReceivePointByArguments(child_element, runnable)
             self.readDataReceivePointByValues(child_element, runnable)
             self.readDataReadAccesses(child_element, runnable)
             self.readDataSendPoints(child_element, runnable)
             self.readWrittenLocalVariables(child_element, runnable)
             self.readReadLocalVariables(child_element, runnable)
             self.readSynchronousServerCallPoint(child_element, runnable)
             self.readAsynchronousServerCallPoint(child_element, runnable)
             self.readInternalTriggeringPoint(child_element, runnable)
 
     def readRTEEvent(self, element, event: RTEEvent):
-        event.start_on_event_ref = self.readChildRefElement(event.short_name, element, "START-ON-EVENT-REF")
+        event.start_on_event_ref = self.readChildOptionalRefElement(element, "START-ON-EVENT-REF")
 
     def readOperationIRef(self, element, parent: OperationInvokedEvent):
         child_element = element.find("./xmlns:OPERATION-IREF", self.nsmap)
         if (child_element != None):
             parent.operation_iref = POperationInAtomicSwcInstanceRef()
             parent.operation_iref.context_p_port_ref = self.readChildRefElement(parent.short_name, child_element, "CONTEXT-P-PORT-REF")
             parent.operation_iref.target_provided_operation_ref = self.readChildRefElement(parent.short_name, child_element, "TARGET-PROVIDED-OPERATION-REF")
@@ -500,15 +502,15 @@
             self.readSwDataDefProps(child_element, prototype)
             prototype.type_tref = self.readChildRefElement(parent.short_name, child_element, "TYPE-TREF")
 
     def readInitEvents(self, element, parent: SwcInternalBehavior):
         for child_element in element.findall("./xmlns:EVENTS/xmlns:INIT-EVENT", self.nsmap):
             short_name = self.readShortName(child_element)
             event = parent.createInitEvent(short_name)
-            logging.debug("readInitEvents %s" % event.short_name)
+
             self.readRTEEvent(child_element, event)
 
     def readTimingEvents(self, element, parent: SwcInternalBehavior):
         for child_element in element.findall("./xmlns:EVENTS/xmlns:TIMING-EVENT", self.nsmap):
             short_name = self.readShortName(child_element)
             event = parent.createTimingEvent(short_name)
 
@@ -519,15 +521,15 @@
                 event.offset = (float)(offset)
             event.period = (float)(self.readChildElement(short_name, child_element, "PERIOD"))
 
     def readDataReceivedEvent(self, element, parent: SwcInternalBehavior):
         for child_element in element.findall("./xmlns:EVENTS/xmlns:DATA-RECEIVED-EVENT", self.nsmap):
             short_name = self.readShortName(child_element)
             event = parent.createDataReceivedEvent(short_name)
-            logging.debug("DataReceivedEvent %s" % event.short_name)
+
             self.readRTEEvent(child_element, event)
             self.readRVariableInAtomicSwcInstanceRef(child_element, event)
 
     def readSwcModeSwitchEvent(self, element, parent: SwcInternalBehavior):
         for child_element in element.findall("./xmlns:EVENTS/xmlns:SWC-MODE-SWITCH-EVENT", self.nsmap):
             short_name = self.readShortName(child_element)
             event = parent.createSwcModeSwitchEvent(short_name)
@@ -601,16 +603,18 @@
             self.readSwDataDefProps(child_element, data_type)
             if (data_type.category == ImplementationDataType.CATEGORY_ARRAY):
                 if (len(data_type.getImplementationDataTypeElements()) < 1):
                     self._raiseError("Array Sub-Element of <%s> do not defined." % data_type.short_name)
                 array_sub_element = data_type.getImplementationDataTypeElements()[0]
                 if (array_sub_element.category == ImplementationDataType.CATEGORY_TYPE_REFERENCE):
                     data_type.setArrayElementType(array_sub_element.sw_data_def_props.implementation_data_type_ref.value)
+                elif (array_sub_element.category == ImplementationDataType.CATEGORY_TYPE_VALUE):  # TODO: fix 
+                    continue
                 else:
-                    self._raiseError("The catetory <%s> of array sub-element does not support." % array_sub_element.category)
+                    self._raiseError("The category <%s> of array sub-element <%s> does not support." % (array_sub_element.category, data_type.short_name))
 
     def readSwDataTypes(self, element, parent: ARPackage):
         for child_element in element.findall("./xmlns:ELEMENTS/xmlns:SW-BASE-TYPE", self.nsmap):
             short_name = self.readShortName(child_element)
             data_type = parent.createSwBaseType(short_name)
 
     def readClientComSpec(self, element, parent: RPortPrototype):
@@ -621,15 +625,15 @@
                 parent.addRequiredComSpec(com_spec)
             except ValueError as err:
                 print(parent.short_name + ": " + str(err))
 
     def readReceiverComSpec(self, element, com_spec: ReceiverComSpec):
         #FIXME: readchildElement
         com_spec.data_element_ref = self.readChildOptionalRefElement(element, "DATA-ELEMENT-REF")
-        com_spec.handle_out_of_range = self.readChildElement("", element, "HANDLE-OUT-OF-RANGE")
+        com_spec.handle_out_of_range = self.readChildOptionalElement(element, "HANDLE-OUT-OF-RANGE")
         com_spec.uses_end_to_end_protection = self.readChildOptionalElementBooleanValue(element, "USES-END-TO-END-PROTECTION")
 
     def readNonqueuedReceiverComSpec(self, element, parent: RPortPrototype):
         for child_element in element.findall("./xmlns:REQUIRED-COM-SPECS/xmlns:NONQUEUED-RECEIVER-COM-SPEC", self.nsmap):
 
             com_spec = NonqueuedReceiverComSpec()
             self.readReceiverComSpec(child_element, com_spec)
@@ -654,15 +658,15 @@
 
             self.readClientComSpec(child_element, prototype)
             self.readNonqueuedReceiverComSpec(child_element, prototype)
 
     def readSenderComSpec(self, element, com_spec: SenderComSpec):
         # FIXME:
         com_spec.data_element_ref = self.readChildOptionalRefElement(element, "DATA-ELEMENT-REF")
-        com_spec.handle_out_of_range = self.readChildElement("", element, "HANDLE-OUT-OF-RANGE")
+        com_spec.handle_out_of_range = self.readChildOptionalElement(element, "HANDLE-OUT-OF-RANGE")
         com_spec.uses_end_to_end_protection = self.readChildOptionalElementBooleanValue(element, "USES-END-TO-END-PROTECTION")
 
     def readNonqueuedSenderComSpec(self, element, parent: PPortPrototype):
         for child_element in element.findall("./xmlns:PROVIDED-COM-SPECS/xmlns:NONQUEUED-SENDER-COM-SPEC", self.nsmap):
             com_spec = NonqueuedSenderComSpec()
             self.readSenderComSpec(child_element, com_spec)
             parent.addProvidedComSpec(com_spec)
@@ -691,23 +695,28 @@
                 short_name)
             self.readAtomicSwComponentType(child_element, sw_component)
 
     def readApplicationSwComponentTypes(self, element, parent: ARPackage):
         for child_element in element.findall("./xmlns:ELEMENTS/xmlns:APPLICATION-SW-COMPONENT-TYPE", self.nsmap):
             short_name = self.readShortName(child_element)
             sw_component = parent.createApplicationSwComponentType(short_name)
-            logging.debug("Read ApplicationSwComponentTypes <%s>" % sw_component.short_name)
             self.readAtomicSwComponentType(child_element, sw_component)
 
     def readComplexDeviceDriverSwComponentTypes(self, element, parent: ARPackage):
         for child_element in element.findall("./xmlns:ELEMENTS/xmlns:COMPLEX-DEVICE-DRIVER-SW-COMPONENT-TYPE", self.nsmap):
             short_name = self.readShortName(child_element)
             sw_component = parent.createApplicationSwComponentType(short_name)
             self.readAtomicSwComponentType(child_element, sw_component)
 
+    def readSensorActuatorSwComponentType(self, element, parent: ARPackage):
+        for child_element in element.findall("./xmlns:ELEMENTS/xmlns:SENSOR-ACTUATOR-SW-COMPONENT-TYPE", self.nsmap):
+            short_name = self.readShortName(child_element)
+            sw_component = parent.createSensorActuatorSwComponentType(short_name)
+            self.readAtomicSwComponentType(child_element, sw_component)
+
     def readServiceSwComponentTypes(self, element, parent: ARPackage):
         for child_element in element.findall("./xmlns:ELEMENTS/xmlns:SERVICE-SW-COMPONENT-TYPE", self.nsmap):
             short_name = self.readShortName(child_element)
             sw_component = parent.createServiceSwComponentType(short_name)
             self.readAtomicSwComponentType(child_element, sw_component)
 
     def readAssemblySwConnectorProviderIRef(self, element, parent: AssemblySwConnector):
@@ -786,16 +795,18 @@
             short_name = self.readShortName(child_element)
             prototype = ArgumentDataPrototype(property, short_name)
             prototype.type_tref = self.readChildOptionalRefElement(child_element, "TYPE-TREF")
             prototype.direction = self.readChildElement(short_name, child_element, "DIRECTION")
             parent.addArgumentDataPrototype(prototype)
 
     def readPossibleErrorRefs(self, element, parent: ClientServerOperation):
-        for ref in self.readChildRefElementList(element, "POSSIBLE-ERROR-REF"):
-            parent.addPossibleErrorRef(ref)
+        child_element = element.find("./xmlns:POSSIBLE-ERROR-REFS", self.nsmap)
+        if child_element != None:
+            for ref in self.readChildRefElementList(child_element, "POSSIBLE-ERROR-REF"):
+                parent.addPossibleErrorRef(ref)
 
     def readOperations(self, element, parent: ClientServerInterface):
         for child_element in element.findall("./xmlns:OPERATIONS/xmlns:CLIENT-SERVER-OPERATION", self.nsmap):
             short_name = self.readShortName(child_element)
             operation = parent.createOperation(short_name)
             self.readArgumentDataPrototypes(child_element, operation)
             self.readPossibleErrorRefs(child_element, operation)
@@ -835,15 +846,15 @@
             parent.compu_internal_to_phys.compu_content = CompuScales()
             self.readCompuScales(child_element, parent.compu_internal_to_phys.compu_content)
 
     def readCompuMethods(self, element, parent: ARPackage):
         for child_element in element.findall("./xmlns:ELEMENTS/xmlns:COMPU-METHOD", self.nsmap):
             short_name = self.readShortName(child_element)
             compu_method = parent.createCompuMethod(short_name)
-            compu_method.category = self.readChildElement(short_name, child_element, "CATEGORY")
+            compu_method.category = self.readChildOptionalElement(child_element, "CATEGORY")
             self.readCompuInternalToPhys(child_element, compu_method)
 
     def readSwcBswRunnableMappings(self, element, parent: SwcBswMapping):
         for child_element in element.findall("./xmlns:RUNNABLE-MAPPINGS/xmlns:SWC-BSW-RUNNABLE-MAPPING", self.nsmap):
             mapping = SwcBswRunnableMapping()
             mapping.bsw_entity_ref = self.readChildOptionalRefElement(child_element, "BSW-ENTITY-REF")
             mapping.swc_runnable_ref = self.readChildOptionalRefElement(child_element, "SWC-RUNNABLE-REF")
@@ -873,21 +884,22 @@
             self.readApplicationRecordDataTypes(child_element, ar_package)
             self.readImplementationDataTypes(child_element, ar_package)
             self.readSwDataTypes(child_element, ar_package)
             self.readCompuMethods(child_element, ar_package)
             self.readEcuAbstractionSwComponents(child_element, ar_package)
             self.readApplicationSwComponentTypes(child_element, ar_package)
             self.readComplexDeviceDriverSwComponentTypes(child_element, ar_package)
+            self.readSensorActuatorSwComponentType(child_element, ar_package)
             self.readServiceSwComponentTypes(child_element, ar_package)
             self.readCompositionSwComponentTypes(child_element, ar_package)
             self.readBswModuleDescription(child_element, ar_package)
             self.readBswModuleEntry(child_element, ar_package)
             self.readSwcBswMappings(child_element, ar_package)
             self.readBswImplementation(child_element, ar_package)
-
+            self.readSwcImplementation(child_element, ar_package)
 
     def load(self, filename, document: AUTOSAR):
         tree = ET.parse(filename)
         root = tree.getroot()
         if (self.getPureTagName(root.tag) != "AUTOSAR"):
             self._raiseError("Invalid ARXML file <%s>" % filename)
```

## Comparing `armodel-1.1.0.dist-info/LICENSE` & `armodel-1.2.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `armodel-1.1.0.dist-info/METADATA` & `armodel-1.2.0.dist-info/METADATA`

 * *Files 23% similar despite different names*

```diff
@@ -1,145 +1,154 @@
-Metadata-Version: 2.1
-Name: armodel
-Version: 1.1.0
-Summary: the python arxml parser
-Home-page: http://github.com/melodypapa/py-armodel
-Author: melodypapa
-Author-email: melodypapa@outlook.com
-License: MIT
-Keywords: AUTOSAR ARXML
-Platform: UNKNOWN
-Classifier: Development Status :: 1 - Planning
-Classifier: Environment :: Console
-Classifier: Programming Language :: Python :: 3
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Operating System :: OS Independent
-Requires-Python: >=3.5
-Description-Content-Type: text/markdown
-Provides-Extra: pytest
-Requires-Dist: pytest-cov ; extra == 'pytest'
-
-# 1. py-armodel
-
-## 1.1. Purpose
-
-To support AUTOSAR model with python 
-
-## 1.2. Reference Documents
-1. AUTOSAR_TPS_XMLSchemaProductionRules.pdf
-2. AUTOSAR_TPS_ARXMLSerializationRules.pdf
-
-|Version|Documentation|Travis CI|Coverage Status|Pypi|
-|--|--|--|--|--|
-|[![GitHub version](https://badge.fury.io/gh/melodypapa%2Fpy-armodel.svg)](https://badge.fury.io/gh/melodypapa%2Fpy-armodel)|[![Documentation Status](https://readthedocs.org/projects/py-armodel/badge/?version=latest)](https://py-armodel.readthedocs.io/en/latest)|[![](https://www.travis-ci.com/melodypapa/py-armodel.svg?branch=main)](https://www.travis-ci.com/melodypapa/py-armodel)|[![Coverage Status](https://coveralls.io/repos/github/melodypapa/py-armodel/badge.svg?branch=main)](https://coveralls.io/github/melodypapa/py-armodel?branch=main)|[![PyPI version](https://badge.fury.io/py/armodel.svg)](https://badge.fury.io/py/armodel)|
-
-## 1.3. How to create the distribution and upload to pypi
-1. Run `python setup.py bdist_wheel` to generate distribution
-2. Run `twine check dist/*` to check the validation of distribution
-3. Run `twine upload dist/*` to upload to pypi repository
-4. Check the website https://pypi.org/project/armodel/ to find out it works or not
-
-And more details can be found at https://packaging.python.org/  
-
-## 1.4. How to perform Unit test
-
-* Run `pip install pytest pytest-cov` to install pytest.
-* Run `pytest --cov=armodel --cov-report term-missing` to verify all the functionality.
-
-## 1.5. How to create a distribution and wheel
-
-* Run `python setup.py sdist bdist_wheel --universal`
-
-## 1.6. How to create the document
-
-1. Run `pip install sphinx` to install the necessary document
-
-## 1.7. Heritage 
-
-```
-- ARObject
-  - Referrable
-    - MultilanguageReferrable
-      - Identifiable
-        - PackageableElement
-          - ARElement
-            - AtpType
-              - AutosarDataType
-              - PortInterface
-                - DataInterface
-                  - NvDataInterface
-                  - ParameterInterface
-                  - SenderReceiverInterface
-            - BswModuleEntry
-          - Implementation
-            - BswImplementation
-        - AtpFeature
-          - AtpPrototype
-            - AtpPrototype
-              - DataPrototype
-                - AutosarDataPrototype
-                  - VariableDataPrototype
-                - ApplicationCompositeElementDataPrototype
-                  - ApplicationArrayElement
-                  - ApplicationRecordElement
-          - AtpStructureElement
-            - BswModuleDescription
-        - ExecutableEntity
-        - SwcBswMapping
-  - ValueSpecification
-    - ConstantReference
-```
-
-## 1.8. CLI usages
-
-### 1.8.1. arxml-dump
-
-**Dump all the arxml data to screen**
-
-`arxml-dump --arxml arg -h`
-
---arxml arg     The file name of arxml data
-
--h              show the help information
-
-### 1.8.2. Example for arxml-dump
-
-**Dump the arxml data from test1.arxml and test2.arxml**
-
-`arxml-dump --arxml test1.arxml --arxml test2.arxml`
-
-## 1.9. API
-
-### 1.9.1. Constructor
-
-```
-  ARXMLParser(options={"warning": True})
-```
-
-## 1.10. Change notes:
-
-**Version 0.1.1**
-
-Add the ARRAY category support for ImplementationDataType
-
-**Version 0.1.2**
-
-Add the AsynchronousServerCallPoint support for ARXML
-
-**Version 0.1.3**
-
-Fix the attribute intervalType of **Limit** is empty issue.
-
-**Version 1.0.0**
-
-1. Add the logging support
-2. Add the <warning> option to disable exception raised.
-3. Add the BswMD support
-
-**Version 1.1.0**
-
-1. Add the InitEvent support. (Issue #5)
-2. Add the DataReceiveEvent support. (Issue #5)
-3. Add the SwcModeSwitchEvent support. (Issue #5)
-4. Add the number format alignment supporting for MemorySection
-5. Add the more features supporting for BswImplementation
-
+Metadata-Version: 2.1
+Name: armodel
+Version: 1.2.0
+Summary: the python arxml parser
+Home-page: http://github.com/melodypapa/py-armodel
+Author: melodypapa
+Author-email: melodypapa@outlook.com
+License: MIT
+Keywords: AUTOSAR ARXML
+Platform: UNKNOWN
+Classifier: Development Status :: 1 - Planning
+Classifier: Environment :: Console
+Classifier: Programming Language :: Python :: 3
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Operating System :: OS Independent
+Requires-Python: >=3.5
+Description-Content-Type: text/markdown
+Provides-Extra: pytest
+Requires-Dist: pytest-cov ; extra == 'pytest'
+
+# 1. py-armodel
+
+## 1.1. Purpose
+
+To support AUTOSAR model with python 
+
+## 1.2. Reference Documents
+1. AUTOSAR_TPS_XMLSchemaProductionRules.pdf
+2. AUTOSAR_TPS_ARXMLSerializationRules.pdf
+
+|Version|Documentation|Travis CI|Coverage Status|Pypi|
+|--|--|--|--|--|
+|[![GitHub version](https://badge.fury.io/gh/melodypapa%2Fpy-armodel.svg)](https://badge.fury.io/gh/melodypapa%2Fpy-armodel)|[![Documentation Status](https://readthedocs.org/projects/py-armodel/badge/?version=latest)](https://py-armodel.readthedocs.io/en/latest)|[![](https://www.travis-ci.com/melodypapa/py-armodel.svg?branch=main)](https://www.travis-ci.com/melodypapa/py-armodel)|[![Coverage Status](https://coveralls.io/repos/github/melodypapa/py-armodel/badge.svg?branch=main)](https://coveralls.io/github/melodypapa/py-armodel?branch=main)|[![PyPI version](https://badge.fury.io/py/armodel.svg)](https://badge.fury.io/py/armodel)|
+
+## 1.3. How to create the distribution and upload to pypi
+1. Run `python setup.py bdist_wheel` to generate distribution
+2. Run `twine check dist/*` to check the validation of distribution
+3. Run `twine upload dist/*` to upload to pypi repository
+4. Check the website https://pypi.org/project/armodel/ to find out it works or not
+
+And more details can be found at https://packaging.python.org/  
+
+## 1.4. How to perform Unit test
+
+* Run `pip install pytest pytest-cov` to install pytest.
+* Run `pytest --cov=armodel --cov-report term-missing` to verify all the functionality.
+
+## 1.5. How to create a distribution and wheel
+
+* Run `python setup.py sdist bdist_wheel --universal`
+
+## 1.6. How to create the document
+
+1. Run `pip install sphinx` to install the necessary document
+
+## 1.7. Heritage 
+
+```
+- ARObject
+  - Referrable
+    - MultilanguageReferrable
+      - Identifiable
+        - PackageableElement
+          - ARElement
+            - AtpType
+              - AutosarDataType
+              - PortInterface
+                - DataInterface
+                  - NvDataInterface
+                  - ParameterInterface
+                  - SenderReceiverInterface
+            - BswModuleEntry
+          - Implementation
+            - BswImplementation
+        - AtpFeature
+          - AtpPrototype
+            - AtpPrototype
+              - DataPrototype
+                - AutosarDataPrototype
+                  - VariableDataPrototype
+                - ApplicationCompositeElementDataPrototype
+                  - ApplicationArrayElement
+                  - ApplicationRecordElement
+          - AtpStructureElement
+            - BswModuleDescription
+        - ExecutableEntity
+        - SwcBswMapping
+  - ValueSpecification
+    - ConstantReference
+```
+
+## 1.8. CLI usages
+
+### 1.8.1. arxml-dump
+
+**Dump all the arxml data to screen**
+
+`arxml-dump --arxml arg -h`
+
+--arxml arg     The file name of arxml data
+
+-h              show the help information
+
+### 1.8.2. Example for arxml-dump
+
+**Dump the arxml data from test1.arxml and test2.arxml**
+
+`arxml-dump --arxml test1.arxml --arxml test2.arxml`
+
+## 1.9. API
+
+### 1.9.1. Constructor
+
+```
+  ARXMLParser(options={"warning": True})
+```
+
+## 1.10. Change notes:
+
+**Version 0.1.1**
+
+Add the ARRAY category support for ImplementationDataType
+
+**Version 0.1.2**
+
+Add the AsynchronousServerCallPoint support for ARXML
+
+**Version 0.1.3**
+
+Fix the attribute intervalType of **Limit** is empty issue.
+
+**Version 1.0.0**
+
+1. Add the logging support
+2. Add the <warning> option to disable exception raised.
+3. Add the BswMD support
+
+**Version 1.1.0**
+
+1. Add the InitEvent support. (Issue #5)
+2. Add the DataReceiveEvent support. (Issue #5)
+3. Add the SwcModeSwitchEvent support. (Issue #5)
+
+**Version 1.2.0**
+
+1. Add the SwcImplementation support (Issue #9)
+2. Add the integer value for memory section alignment (Issue #9)
+3. Remove the required attributes for the Implementation according to the AUTOSAR standard 23R-11. (Issue #9)
+4. Change the START-ON-EVENT-REF to optional according to the AUTOSAR standard 23R-11. (Issue #9)
+5. Change the HANDLE-OUT-OF-RANGE to optional according to the AUTOSAR standard 23R-11. (Issue #9)
+6. Add the SensorActuatorSwComponentType support (Issue #9)
+7. Change the CATEGORY of COMPU-METHOD to optional.
+8. Change the CAN-BE-INVOKED-CONCURRENTLY to optional.
+
```

## Comparing `armodel-1.1.0.dist-info/RECORD` & `armodel-1.2.0.dist-info/RECORD`

 * *Files 10% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 armodel/__init__.py,sha256=K_KHb3O2T21uteIe0wac-tb3kI2xWHTnwV9ShaXesAU,54
 armodel/cli/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 armodel/cli/arxml_dump_cli.py,sha256=VBOTkrpj59kt2hM62iNVcDYGch_A2WL5_vFpbmC9ucI,9932
 armodel/models/__init__.py,sha256=ijDu-Ra2ZjEJNy88Y5ZsPqxAt05_reQsQti-_X4gD3o,402
 armodel/models/ar_object.py,sha256=gbo71ZPQ61-OhiPpHFbKtE2JA-8vOzXrd9T_0hh4GfA,341
-armodel/models/ar_package.py,sha256=Z_tcjcJ6lAqp4yDjFkaYFZAuVbXSxoe1cPNBPN4zt4o,11921
+armodel/models/ar_package.py,sha256=OPoNGaAhTBf30elxc1dvJMyU6CpMUmvs0SUwaYoEtVs,13275
 armodel/models/ar_ref.py,sha256=RZT6URQ91YgmRk1oUTC-0UPnwn61MgEzmII7UKwQXUM,3548
 armodel/models/bsw_module_template.py,sha256=k_CZWtTipKtVFjIx08uRqadSubVtBJ-NhUlocfoA0a0,11778
-armodel/models/common_structure.py,sha256=GJFTTwvAZgt9aLY63A3Vynp-tZt65-8Oy4k5YBMYfB8,6559
+armodel/models/common_structure.py,sha256=DSnuhhYdpDW-klOCZNg8zULuhFBdk7k601YQsPg5IT4,6745
 armodel/models/data_dictionary.py,sha256=xSQzXkLQyOJiLIsczlAzGBnrrvHFVv2_-OfVyN6_MSE,867
 armodel/models/data_prototype.py,sha256=pyIahyJh4KaikMfHikHiKzbGai1JnkrzDZpkVLvb6iU,2096
 armodel/models/datatype.py,sha256=BEc8y3mcQZEvwteFUtJyPYBIwnHJcs9fIyxLgnMK5rk,5802
 armodel/models/ecuc_parameter_def_template.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 armodel/models/general_structure.py,sha256=syJTAAo3DIBE6O0nB8Whm4OEnNyN4uVIAJZPA8t3ukY,4480
-armodel/models/implementation.py,sha256=iGm5aS1L2sA9eP0jeDFkkIURvr6zzHOCaTtL59G48Yg,3875
+armodel/models/implementation.py,sha256=jfatA90Ww51kMqnUsbx6q4JRRRIRFCQXVg88J44RNoA,3850
 armodel/models/m2_msr.py,sha256=Gk-h-4jSnOkWlfJJcI1-1YvSQvBqkUJZxlzikwgAsec,2165
 armodel/models/port_interface.py,sha256=UDCvj78k3sfG4IJX4FWQj6LUV2mWw6Nt0plMnLsQfZk,6026
 armodel/models/port_prototype.py,sha256=Pqp5euv_RDfTlsEqvBkpAreBFMJlovuU49cJsYD4d3Q,7215
 armodel/models/sw_component.py,sha256=LUmof9nZnN7krpIScS72R6YqTzzpkIFkIvHJoklYXgw,20503
 armodel/parser/__init__.py,sha256=whzCLvAstuSlm6scgcCId7AUxSX8z8PV8AIKSNWMkGo,37
-armodel/parser/arxml_parser.py,sha256=qjzZ9eeG6dGo5yt4Si007PVmaRlI6D8ulZthH5JjUFk,55261
-armodel-1.1.0.dist-info/LICENSE,sha256=rceTpGhsmmN1M0k1KO0HRS11iCjen-2y56ZEqgo43wo,1088
-armodel-1.1.0.dist-info/METADATA,sha256=zTaCxzE_4Cb1THE3btuz04QuzRNaJw6bjVMcAUhDqlU,4359
-armodel-1.1.0.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-armodel-1.1.0.dist-info/entry_points.txt,sha256=ofkww3HejFuRvGlQSANqFbTEcf0LUXX2FmXZovba9m0,68
-armodel-1.1.0.dist-info/top_level.txt,sha256=AEATYsqAuRpr0XGa_ThW7-o4WLlA5e3PEgD0QJhzmoA,8
-armodel-1.1.0.dist-info/RECORD,,
+armodel/parser/arxml_parser.py,sha256=NgIbfrXL2EoT5po1kvaxdpxnYOJCXk0TBlmgae-OfdQ,55951
+armodel-1.2.0.dist-info/LICENSE,sha256=rceTpGhsmmN1M0k1KO0HRS11iCjen-2y56ZEqgo43wo,1088
+armodel-1.2.0.dist-info/METADATA,sha256=MVqrzP9E8YfO9sA92XWqRNhwt-7CFPDyeg6-lX9ywUg,4998
+armodel-1.2.0.dist-info/WHEEL,sha256=yQN5g4mg4AybRjkgi-9yy4iQEFibGQmlz78Pik5Or-A,92
+armodel-1.2.0.dist-info/entry_points.txt,sha256=ofkww3HejFuRvGlQSANqFbTEcf0LUXX2FmXZovba9m0,68
+armodel-1.2.0.dist-info/top_level.txt,sha256=AEATYsqAuRpr0XGa_ThW7-o4WLlA5e3PEgD0QJhzmoA,8
+armodel-1.2.0.dist-info/RECORD,,
```


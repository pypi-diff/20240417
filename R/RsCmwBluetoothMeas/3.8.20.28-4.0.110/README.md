# Comparing `tmp/RsCmwBluetoothMeas-3.8.20.28.tar.gz` & `tmp/RsCmwBluetoothMeas-4.0.110.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist\RsCmwBluetoothMeas-3.8.20.28.tar", last modified: Sun May 16 18:18:46 2021, max compression
+gzip compressed data, was "dist\RsCmwBluetoothMeas-4.0.110.tar", last modified: Wed Apr 17 08:45:52 2024, max compression
```

## Comparing `RsCmwBluetoothMeas-3.8.20.28.tar` & `RsCmwBluetoothMeas-4.0.110.tar`

### file list

```diff
@@ -1,875 +1,1080 @@
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:46.094880 RsCmwBluetoothMeas-3.8.20.28/
--rw-rw-rw-   0        0        0     3943 2021-05-16 18:18:46.093881 RsCmwBluetoothMeas-3.8.20.28/PKG-INFO
--rw-rw-rw-   0        0        0     2732 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/README.md
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:42.799777 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:42.849645 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/CustomFiles/
--rw-rw-rw-   0        0        0        0 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/CustomFiles/__init__.py
--rw-rw-rw-   0        0        0     3304 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/CustomFiles/events.py
--rw-rw-rw-   0        0        0     4517 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/CustomFiles/reliability.py
--rw-rw-rw-   0        0        0    18659 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/CustomFiles/utilities.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:42.928434 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/
--rw-rw-rw-   0        0        0      981 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Call.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:42.939405 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Call_/
--rw-rw-rw-   0        0        0     1019 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Call_/DtMode.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:42.949378 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Call_/DtMode_/
--rw-rw-rw-   0        0        0     2576 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Call_/DtMode_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:42.963343 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Call_/DtMode_/LowEnergy_/
--rw-rw-rw-   0        0        0     1237 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Call_/DtMode_/LowEnergy_/Rdevices.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Call_/DtMode_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Call_/DtMode_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Call_/__init__.py
--rw-rw-rw-   0        0        0     1003 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Clean.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:42.974311 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Clean_/
--rw-rw-rw-   0        0        0     1049 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Clean_/Elogging.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Clean_/__init__.py
--rw-rw-rw-   0        0        0     9633 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.023181 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/
--rw-rw-rw-   0        0        0     7993 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/ComSettings.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.033154 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/ComSettings_/
--rw-rw-rw-   0        0        0     2096 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/ComSettings_/Ports.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/ComSettings_/__init__.py
--rw-rw-rw-   0        0        0     1020 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.043128 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/
--rw-rw-rw-   0        0        0     2252 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.082024 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/
--rw-rw-rw-   0        0        0     1546 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Eattenuation.py
--rw-rw-rw-   0        0        0      977 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Limit.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.092996 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Limit_/
--rw-rw-rw-   0        0        0     1013 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Limit_/Mper.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.102968 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Limit_/Mper_/
--rw-rw-rw-   0        0        0     5187 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Limit_/Mper_/LowEnergy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Limit_/Mper_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Limit_/__init__.py
--rw-rw-rw-   0        0        0     1265 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Per.py
--rw-rw-rw-   0        0        0     1047 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Rintegrity.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.112945 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Rintegrity_/
--rw-rw-rw-   0        0        0     4950 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Rintegrity_/LowEnergy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Rintegrity_/__init__.py
--rw-rw-rw-   0        0        0     3565 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Search.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.129897 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Search_/
--rw-rw-rw-   0        0        0      979 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Search_/Limit.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.141865 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Search_/Limit_/
--rw-rw-rw-   0        0        0     1015 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Search_/Limit_/Mper.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.152835 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Search_/Limit_/Mper_/
--rw-rw-rw-   0        0        0     5358 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Search_/Limit_/Mper_/LowEnergy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Search_/Limit_/Mper_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Search_/Limit_/__init__.py
--rw-rw-rw-   0        0        0     1049 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Search_/Rintegrity.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.161812 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Search_/Rintegrity_/
--rw-rw-rw-   0        0        0     5313 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Search_/Rintegrity_/LowEnergy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Search_/Rintegrity_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Search_/__init__.py
--rw-rw-rw-   0        0        0     1597 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/SmIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/__init__.py
--rw-rw-rw-   0        0        0    10735 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.225642 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/
--rw-rw-rw-   0        0        0     1503 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/AccAddress.py
--rw-rw-rw-   0        0        0     1027 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Cscheme.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.234617 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Cscheme_/
--rw-rw-rw-   0        0        0     1516 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Cscheme_/LowEnergy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Cscheme_/__init__.py
--rw-rw-rw-   0        0        0     1003 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Cte.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.244591 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Cte_/
--rw-rw-rw-   0        0        0     1221 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Cte_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.258554 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Cte_/LowEnergy_/
--rw-rw-rw-   0        0        0     3210 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Cte_/LowEnergy_/Le1M.py
--rw-rw-rw-   0        0        0     3210 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Cte_/LowEnergy_/Le2M.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Cte_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Cte_/__init__.py
--rw-rw-rw-   0        0        0     1503 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.277503 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/
--rw-rw-rw-   0        0        0     1029 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/Pattern.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.285482 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/Pattern_/
--rw-rw-rw-   0        0        0     6013 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/Pattern_/LowEnergy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/Pattern_/__init__.py
--rw-rw-rw-   0        0        0     1029 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/Plength.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.294457 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/Plength_/
--rw-rw-rw-   0        0        0     4725 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/Plength_/LowEnergy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/Plength_/__init__.py
--rw-rw-rw-   0        0        0     1025 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/RxQuality.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.303434 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/RxQuality_/
--rw-rw-rw-   0        0        0     1031 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/RxQuality_/Plength.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.312409 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/RxQuality_/Plength_/
--rw-rw-rw-   0        0        0     3971 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/RxQuality_/Plength_/LowEnergy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/RxQuality_/Plength_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/RxQuality_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/__init__.py
--rw-rw-rw-   0        0        0     1003 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Fec.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.321387 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Fec_/
--rw-rw-rw-   0        0        0     1904 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Fec_/LowEnergy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Fec_/__init__.py
--rw-rw-rw-   0        0        0     3086 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/LowEnergy.py
--rw-rw-rw-   0        0        0     3745 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Oslots.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.330362 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Oslots_/
--rw-rw-rw-   0        0        0     3895 2021-05-16 18:18:29.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Oslots_/LowEnergy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Oslots_/__init__.py
--rw-rw-rw-   0        0        0     3010 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Pattern.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.340335 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Pattern_/
--rw-rw-rw-   0        0        0     6275 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Pattern_/LowEnergy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Pattern_/__init__.py
--rw-rw-rw-   0        0        0     4895 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Plength.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.349311 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Plength_/
--rw-rw-rw-   0        0        0     6328 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Plength_/LowEnergy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Plength_/__init__.py
--rw-rw-rw-   0        0        0     3722 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Ptype.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.358287 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Ptype_/
--rw-rw-rw-   0        0        0     5313 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Ptype_/LowEnergy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Ptype_/__init__.py
--rw-rw-rw-   0        0        0     1336 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/SynWord.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/__init__.py
--rw-rw-rw-   0        0        0    12188 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.420123 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/
--rw-rw-rw-   0        0        0     1007 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Brate.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.429098 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Brate_/
--rw-rw-rw-   0        0        0     1672 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Brate_/FilterPy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Brate_/__init__.py
--rw-rw-rw-   0        0        0     1013 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Edrate.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.439072 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Edrate_/
--rw-rw-rw-   0        0        0     1804 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Edrate_/FilterPy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Edrate_/__init__.py
--rw-rw-rw-   0        0        0      989 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Frange.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.447050 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Frange_/
--rw-rw-rw-   0        0        0     2731 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Frange_/Brate.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Frange_/__init__.py
--rw-rw-rw-   0        0        0    12902 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.472981 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/
--rw-rw-rw-   0        0        0    16125 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Brate.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.480960 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Brate_/
--rw-rw-rw-   0        0        0     6155 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Brate_/Fdrift.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Brate_/__init__.py
--rw-rw-rw-   0        0        0     1005 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Cte.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.489935 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Cte_/
--rw-rw-rw-   0        0        0     1223 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Cte_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.502902 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Cte_/LowEnergy_/
--rw-rw-rw-   0        0        0     7379 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Cte_/LowEnergy_/Le1M.py
--rw-rw-rw-   0        0        0     7379 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Cte_/LowEnergy_/Le2M.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Cte_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Cte_/__init__.py
--rw-rw-rw-   0        0        0     6833 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Edrate.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.522848 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Edrate_/
--rw-rw-rw-   0        0        0     2896 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Edrate_/Dpsk.py
--rw-rw-rw-   0        0        0     2930 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Edrate_/Dqpsk.py
--rw-rw-rw-   0        0        0     4120 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Edrate_/Pencoding.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Edrate_/__init__.py
--rw-rw-rw-   0        0        0     3963 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.555761 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/LowEnergy_/
--rw-rw-rw-   0        0        0     4691 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/LowEnergy_/Daverage.py
--rw-rw-rw-   0        0        0     4691 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/LowEnergy_/Dmaximum.py
--rw-rw-rw-   0        0        0     4691 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/LowEnergy_/Dminimum.py
--rw-rw-rw-   0        0        0    14059 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/LowEnergy_/Le1M.py
--rw-rw-rw-   0        0        0    16838 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/LowEnergy_/Le2M.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.571718 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/LowEnergy_/Le2M_/
--rw-rw-rw-   0        0        0     4740 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/LowEnergy_/Le2M_/Daverage.py
--rw-rw-rw-   0        0        0     4740 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/LowEnergy_/Le2M_/Dmaximum.py
--rw-rw-rw-   0        0        0     4740 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/LowEnergy_/Le2M_/Dminimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/LowEnergy_/Le2M_/__init__.py
--rw-rw-rw-   0        0        0    20513 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/LowEnergy_/Lrange.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/__init__.py
--rw-rw-rw-   0        0        0     4243 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.584683 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/
--rw-rw-rw-   0        0        0     2306 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.603633 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/
--rw-rw-rw-   0        0        0     5016 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Results.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.637544 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Results_/
--rw-rw-rw-   0        0        0     2464 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Results_/Mscalar.py
--rw-rw-rw-   0        0        0     1993 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Results_/Pencoding.py
--rw-rw-rw-   0        0        0     2464 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Results_/Pscalar.py
--rw-rw-rw-   0        0        0     2427 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Results_/Sacp.py
--rw-rw-rw-   0        0        0     2456 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Results_/Sgacp.py
--rw-rw-rw-   0        0        0     2427 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Results_/SoBw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Results_/__init__.py
--rw-rw-rw-   0        0        0     5104 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scount.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.670455 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scount_/
--rw-rw-rw-   0        0        0     2560 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scount_/Mscalar.py
--rw-rw-rw-   0        0        0     1998 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scount_/Pencoding.py
--rw-rw-rw-   0        0        0     2570 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scount_/Pscalar.py
--rw-rw-rw-   0        0        0     2548 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scount_/Sacp.py
--rw-rw-rw-   0        0        0     2577 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scount_/Sgacp.py
--rw-rw-rw-   0        0        0     2548 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scount_/SoBw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scount_/__init__.py
--rw-rw-rw-   0        0        0     9711 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.741265 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/
--rw-rw-rw-   0        0        0     2209 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Btype.py
--rw-rw-rw-   0        0        0     2339 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Cscheme.py
--rw-rw-rw-   0        0        0     2433 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/EnvelopePower.py
--rw-rw-rw-   0        0        0     6100 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Extended.py
--rw-rw-rw-   0        0        0     2269 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/FilterPy.py
--rw-rw-rw-   0        0        0     2097 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Frequency.py
--rw-rw-rw-   0        0        0     2280 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/MoException.py
--rw-rw-rw-   0        0        0     2132 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Oslots.py
--rw-rw-rw-   0        0        0     2531 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Pattern.py
--rw-rw-rw-   0        0        0     2518 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Phy.py
--rw-rw-rw-   0        0        0     2060 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Plength.py
--rw-rw-rw-   0        0        0     2640 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Ptype.py
--rw-rw-rw-   0        0        0     2281 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Rtrigger.py
--rw-rw-rw-   0        0        0     1045 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/SingleCmw.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.749244 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/SingleCmw_/
--rw-rw-rw-   0        0        0     2995 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/SingleCmw_/Connector.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/SingleCmw_/__init__.py
--rw-rw-rw-   0        0        0     2246 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Slength.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/__init__.py
--rw-rw-rw-   0        0        0     2273 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/SingleCmw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/__init__.py
--rw-rw-rw-   0        0        0     1455 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.768195 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy_/
--rw-rw-rw-   0        0        0     1003 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy_/Le1M.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.777170 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy_/Le1M_/
--rw-rw-rw-   0        0        0     1922 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy_/Le1M_/FilterPy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy_/Le1M_/__init__.py
--rw-rw-rw-   0        0        0     1003 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy_/Le2M.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.786147 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy_/Le2M_/
--rw-rw-rw-   0        0        0     1918 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy_/Le2M_/FilterPy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy_/Le2M_/__init__.py
--rw-rw-rw-   0        0        0     1015 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy_/Lrange.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.795122 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy_/Lrange_/
--rw-rw-rw-   0        0        0     1930 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy_/Lrange_/FilterPy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy_/Lrange_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0     2694 2021-05-16 18:18:31.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Malgorithm.py
--rw-rw-rw-   0        0        0     1360 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Measurement.py
--rw-rw-rw-   0        0        0    42734 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Result.py
--rw-rw-rw-   0        0        0     1232 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.809084 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/
--rw-rw-rw-   0        0        0     1033 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/Brate.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.817063 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/Brate_/
--rw-rw-rw-   0        0        0     2014 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/Brate_/Measurement.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/Brate_/__init__.py
--rw-rw-rw-   0        0        0     1221 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.833020 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/LowEnergy_/
--rw-rw-rw-   0        0        0     1029 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/LowEnergy_/Le1M.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.841997 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/LowEnergy_/Le1M_/
--rw-rw-rw-   0        0        0     2980 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/LowEnergy_/Le1M_/Measurement.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/LowEnergy_/Le1M_/__init__.py
--rw-rw-rw-   0        0        0     1029 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/LowEnergy_/Le2M.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.850973 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/LowEnergy_/Le2M_/
--rw-rw-rw-   0        0        0     2976 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/LowEnergy_/Le2M_/Measurement.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/LowEnergy_/Le2M_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/__init__.py
--rw-rw-rw-   0        0        0    10685 2021-05-16 18:18:32.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Scount.py
--rw-rw-rw-   0        0        0      991 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sgacp.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.861943 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sgacp_/
--rw-rw-rw-   0        0        0     1039 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sgacp_/Edrate.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.871918 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sgacp_/Edrate_/
--rw-rw-rw-   0        0        0     2026 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sgacp_/Edrate_/Measurement.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sgacp_/Edrate_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sgacp_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/__init__.py
--rw-rw-rw-   0        0        0     8036 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RfSettings.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.896855 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RfSettings_/
--rw-rw-rw-   0        0        0     1003 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RfSettings_/Cte.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.905831 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RfSettings_/Cte_/
--rw-rw-rw-   0        0        0     3842 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RfSettings_/Cte_/LowEnergy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RfSettings_/Cte_/__init__.py
--rw-rw-rw-   0        0        0     3908 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RfSettings_/Dtx.py
--rw-rw-rw-   0        0        0     2837 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RfSettings_/Mchannel.py
--rw-rw-rw-   0        0        0     2458 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RfSettings_/Mmode.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.914807 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RfSettings_/Mmode_/
--rw-rw-rw-   0        0        0     2102 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RfSettings_/Mmode_/Nmode.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RfSettings_/Mmode_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RfSettings_/__init__.py
--rw-rw-rw-   0        0        0     8789 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RxQuality.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.942733 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RxQuality_/
--rw-rw-rw-   0        0        0     1501 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RxQuality_/Eattenuation.py
--rw-rw-rw-   0        0        0     2740 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RxQuality_/Per.py
--rw-rw-rw-   0        0        0     2767 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RxQuality_/Route.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.951710 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RxQuality_/Route_/
--rw-rw-rw-   0        0        0      969 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RxQuality_/Route_/Usage.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.961682 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RxQuality_/Route_/Usage_/
--rw-rw-rw-   0        0        0     2512 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RxQuality_/Route_/Usage_/All.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RxQuality_/Route_/Usage_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RxQuality_/Route_/__init__.py
--rw-rw-rw-   0        0        0     4035 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RxQuality_/Sensitivity.py
--rw-rw-rw-   0        0        0     1842 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RxQuality_/SpotCheck.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RxQuality_/__init__.py
--rw-rw-rw-   0        0        0      977 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/Trx.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.970660 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/Trx_/
--rw-rw-rw-   0        0        0     2139 2021-05-16 18:18:30.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/Trx_/Result.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/Trx_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/__init__.py
--rw-rw-rw-   0        0        0     1302 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Diagnostic.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.982626 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Diagnostic_/
--rw-rw-rw-   0        0        0     1923 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Diagnostic_/Bluetooth.py
--rw-rw-rw-   0        0        0     1269 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Diagnostic_/RfControl.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Diagnostic_/__init__.py
--rw-rw-rw-   0        0        0     1018 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:43.990608 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/
--rw-rw-rw-   0        0        0     1226 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.005570 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/
--rw-rw-rw-   0        0        0     6587 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Per.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.017537 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Per_/
--rw-rw-rw-   0        0        0     1457 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Per_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.037483 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Per_/LowEnergy_/
--rw-rw-rw-   0        0        0     3738 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Per_/LowEnergy_/Le1M.py
--rw-rw-rw-   0        0        0     3738 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Per_/LowEnergy_/Le2M.py
--rw-rw-rw-   0        0        0     3762 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Per_/LowEnergy_/Lrange.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Per_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0     1390 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Per_/State.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Per_/__init__.py
--rw-rw-rw-   0        0        0      974 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Search.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.046460 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Search_/
--rw-rw-rw-   0        0        0     6715 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Search_/Per.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.059425 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Search_/Per_/
--rw-rw-rw-   0        0        0     1459 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Search_/Per_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.079373 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Search_/Per_/LowEnergy_/
--rw-rw-rw-   0        0        0     4222 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Search_/Per_/LowEnergy_/Le1M.py
--rw-rw-rw-   0        0        0     4224 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Search_/Per_/LowEnergy_/Le2M.py
--rw-rw-rw-   0        0        0     4248 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Search_/Per_/LowEnergy_/Lrange.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Search_/Per_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0     1415 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Search_/Per_/State.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Search_/Per_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Search_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/__init__.py
--rw-rw-rw-   0        0        0     1048 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.088348 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/
--rw-rw-rw-   0        0        0     2682 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.128240 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/
--rw-rw-rw-   0        0        0     1033 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Aaddress.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.138214 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Aaddress_/
--rw-rw-rw-   0        0        0     1001 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Aaddress_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.147190 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Aaddress_/LowEnergy_/
--rw-rw-rw-   0        0        0     1346 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Aaddress_/LowEnergy_/Le1M.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Aaddress_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Aaddress_/__init__.py
--rw-rw-rw-   0        0        0     1021 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Coding.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.157164 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Coding_/
--rw-rw-rw-   0        0        0     1017 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Coding_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.165142 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Coding_/LowEnergy_/
--rw-rw-rw-   0        0        0     1344 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Coding_/LowEnergy_/Lrange.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Coding_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Coding_/__init__.py
--rw-rw-rw-   0        0        0     1003 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.174118 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/
--rw-rw-rw-   0        0        0     1221 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.186938 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/LowEnergy_/
--rw-rw-rw-   0        0        0     1212 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/LowEnergy_/Le1M.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.200900 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/LowEnergy_/Le1M_/
--rw-rw-rw-   0        0        0     1714 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/LowEnergy_/Le1M_/TypePy.py
--rw-rw-rw-   0        0        0     1427 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/LowEnergy_/Le1M_/Units.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/LowEnergy_/Le1M_/__init__.py
--rw-rw-rw-   0        0        0     1212 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/LowEnergy_/Le2M.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.213866 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/LowEnergy_/Le2M_/
--rw-rw-rw-   0        0        0     1714 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/LowEnergy_/Le2M_/TypePy.py
--rw-rw-rw-   0        0        0     1427 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/LowEnergy_/Le2M_/Units.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/LowEnergy_/Le2M_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/__init__.py
--rw-rw-rw-   0        0        0     1229 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/NoSlots.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.227828 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/NoSlots_/
--rw-rw-rw-   0        0        0     1304 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/NoSlots_/Brate.py
--rw-rw-rw-   0        0        0     1311 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/NoSlots_/Edrate.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/NoSlots_/__init__.py
--rw-rw-rw-   0        0        0     1253 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Pattern.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.240794 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Pattern_/
--rw-rw-rw-   0        0        0     1569 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Pattern_/Brate.py
--rw-rw-rw-   0        0        0     1457 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Pattern_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.260741 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Pattern_/LowEnergy_/
--rw-rw-rw-   0        0        0     1677 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Pattern_/LowEnergy_/Le1M.py
--rw-rw-rw-   0        0        0     1675 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Pattern_/LowEnergy_/Le2M.py
--rw-rw-rw-   0        0        0     1628 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Pattern_/LowEnergy_/Lrange.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Pattern_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Pattern_/__init__.py
--rw-rw-rw-   0        0        0     1027 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/PduType.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.270715 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/PduType_/
--rw-rw-rw-   0        0        0     1001 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/PduType_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.279690 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/PduType_/LowEnergy_/
--rw-rw-rw-   0        0        0     1670 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/PduType_/LowEnergy_/Le1M.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/PduType_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/PduType_/__init__.py
--rw-rw-rw-   0        0        0     1487 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Plength.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.297165 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Plength_/
--rw-rw-rw-   0        0        0     1316 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Plength_/Brate.py
--rw-rw-rw-   0        0        0     1324 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Plength_/Edrate.py
--rw-rw-rw-   0        0        0     1457 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Plength_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.316115 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Plength_/LowEnergy_/
--rw-rw-rw-   0        0        0     1454 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Plength_/LowEnergy_/Le1M.py
--rw-rw-rw-   0        0        0     1452 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Plength_/LowEnergy_/Le2M.py
--rw-rw-rw-   0        0        0     1464 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Plength_/LowEnergy_/Lrange.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Plength_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Plength_/__init__.py
--rw-rw-rw-   0        0        0     1471 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Ptype.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.334067 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Ptype_/
--rw-rw-rw-   0        0        0     1392 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Ptype_/Brate.py
--rw-rw-rw-   0        0        0     1478 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Ptype_/Edrate.py
--rw-rw-rw-   0        0        0     1457 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Ptype_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.352021 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Ptype_/LowEnergy_/
--rw-rw-rw-   0        0        0     1595 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Ptype_/LowEnergy_/Le1M.py
--rw-rw-rw-   0        0        0     1582 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Ptype_/LowEnergy_/Le2M.py
--rw-rw-rw-   0        0        0     1558 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Ptype_/LowEnergy_/Lrange.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Ptype_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Ptype_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/__init__.py
--rw-rw-rw-   0        0        0     8366 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.402394 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/
--rw-rw-rw-   0        0        0      987 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Frange.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.411370 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Frange_/
--rw-rw-rw-   0        0        0      999 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Frange_/Brate.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.419350 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Frange_/Brate_/
--rw-rw-rw-   0        0        0     6533 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Frange_/Brate_/Current.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Frange_/Brate_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Frange_/__init__.py
--rw-rw-rw-   0        0        0     1004 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.428325 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/
--rw-rw-rw-   0        0        0     2833 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.458245 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/
--rw-rw-rw-   0        0        0     2043 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.485174 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/
--rw-rw-rw-   0        0        0     5257 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Average.py
--rw-rw-rw-   0        0        0     6296 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.495147 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Current_/
--rw-rw-rw-   0        0        0     5857 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Current_/Extended.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Current_/__init__.py
--rw-rw-rw-   0        0        0     5257 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Maximum.py
--rw-rw-rw-   0        0        0     3654 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Minimum.py
--rw-rw-rw-   0        0        0     5256 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/StandardDev.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.504124 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/StandardDev_/
--rw-rw-rw-   0        0        0     4916 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/StandardDev_/Extended.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/StandardDev_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/__init__.py
--rw-rw-rw-   0        0        0     2264 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Pencoding.py
--rw-rw-rw-   0        0        0     1775 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/PowerVsTime.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.527061 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/PowerVsTime_/
--rw-rw-rw-   0        0        0     3992 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/PowerVsTime_/Average.py
--rw-rw-rw-   0        0        0     3992 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/PowerVsTime_/Current.py
--rw-rw-rw-   0        0        0     3992 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/PowerVsTime_/Maximum.py
--rw-rw-rw-   0        0        0     3992 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/PowerVsTime_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/PowerVsTime_/__init__.py
--rw-rw-rw-   0        0        0      963 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Sacp.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.535041 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Sacp_/
--rw-rw-rw-   0        0        0     3722 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Sacp_/Ptx.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Sacp_/__init__.py
--rw-rw-rw-   0        0        0      995 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/SoBw.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.544016 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/SoBw_/
--rw-rw-rw-   0        0        0     3212 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/SoBw_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/SoBw_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/__init__.py
--rw-rw-rw-   0        0        0     1953 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.571943 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/
--rw-rw-rw-   0        0        0     2728 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Brate.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.610838 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Brate_/
--rw-rw-rw-   0        0        0     7813 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Brate_/Average.py
--rw-rw-rw-   0        0        0     7813 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Brate_/Current.py
--rw-rw-rw-   0        0        0     7813 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Brate_/Maximum.py
--rw-rw-rw-   0        0        0     6663 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Brate_/Minimum.py
--rw-rw-rw-   0        0        0     5961 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Brate_/StandardDev.py
--rw-rw-rw-   0        0        0     7825 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Brate_/Xmaximum.py
--rw-rw-rw-   0        0        0     7825 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Brate_/Xminimum.py
--rw-rw-rw-   0        0        0     1449 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Brate_/YieldPy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Brate_/__init__.py
--rw-rw-rw-   0        0        0     1004 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.620812 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/
--rw-rw-rw-   0        0        0     1222 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.633777 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/
--rw-rw-rw-   0        0        0     2241 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le1M.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.665691 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le1M_/
--rw-rw-rw-   0        0        0     5576 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le1M_/Average.py
--rw-rw-rw-   0        0        0     5576 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le1M_/Current.py
--rw-rw-rw-   0        0        0     5576 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le1M_/Maximum.py
--rw-rw-rw-   0        0        0     5618 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le1M_/StandardDev.py
--rw-rw-rw-   0        0        0     5588 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le1M_/Xmaximum.py
--rw-rw-rw-   0        0        0     5588 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le1M_/Xminimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le1M_/__init__.py
--rw-rw-rw-   0        0        0     2241 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le2M.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.699602 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le2M_/
--rw-rw-rw-   0        0        0     5576 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le2M_/Average.py
--rw-rw-rw-   0        0        0     5576 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le2M_/Current.py
--rw-rw-rw-   0        0        0     5576 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le2M_/Maximum.py
--rw-rw-rw-   0        0        0     5618 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le2M_/StandardDev.py
--rw-rw-rw-   0        0        0     5588 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le2M_/Xmaximum.py
--rw-rw-rw-   0        0        0     5588 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le2M_/Xminimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le2M_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/__init__.py
--rw-rw-rw-   0        0        0     1761 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Edrate.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.723538 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Edrate_/
--rw-rw-rw-   0        0        0     6119 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Edrate_/Average.py
--rw-rw-rw-   0        0        0     6751 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Edrate_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.730518 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Edrate_/Current_/
--rw-rw-rw-   0        0        0     2989 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Edrate_/Current_/Extended.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Edrate_/Current_/__init__.py
--rw-rw-rw-   0        0        0     6119 2021-05-16 18:18:39.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Edrate_/Maximum.py
--rw-rw-rw-   0        0        0     6477 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Edrate_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Edrate_/__init__.py
--rw-rw-rw-   0        0        0     1456 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.750465 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/
--rw-rw-rw-   0        0        0     2717 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le1M.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.788365 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le1M_/
--rw-rw-rw-   0        0        0     8612 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le1M_/Average.py
--rw-rw-rw-   0        0        0     8612 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le1M_/Current.py
--rw-rw-rw-   0        0        0     8612 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le1M_/Maximum.py
--rw-rw-rw-   0        0        0     6866 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le1M_/Minimum.py
--rw-rw-rw-   0        0        0     6900 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le1M_/StandardDev.py
--rw-rw-rw-   0        0        0     8624 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le1M_/Xmaximum.py
--rw-rw-rw-   0        0        0     8624 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le1M_/Xminimum.py
--rw-rw-rw-   0        0        0     1565 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le1M_/YieldPy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le1M_/__init__.py
--rw-rw-rw-   0        0        0     2717 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le2M.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.828257 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le2M_/
--rw-rw-rw-   0        0        0     8606 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le2M_/Average.py
--rw-rw-rw-   0        0        0     8606 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le2M_/Current.py
--rw-rw-rw-   0        0        0     8606 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le2M_/Maximum.py
--rw-rw-rw-   0        0        0     6860 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le2M_/Minimum.py
--rw-rw-rw-   0        0        0     6894 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le2M_/StandardDev.py
--rw-rw-rw-   0        0        0     8618 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le2M_/Xmaximum.py
--rw-rw-rw-   0        0        0     8618 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le2M_/Xminimum.py
--rw-rw-rw-   0        0        0     1563 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le2M_/YieldPy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le2M_/__init__.py
--rw-rw-rw-   0        0        0     2727 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Lrange.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.868151 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Lrange_/
--rw-rw-rw-   0        0        0     7081 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Lrange_/Average.py
--rw-rw-rw-   0        0        0     7081 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Lrange_/Current.py
--rw-rw-rw-   0        0        0     7081 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Lrange_/Maximum.py
--rw-rw-rw-   0        0        0     5684 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Lrange_/Minimum.py
--rw-rw-rw-   0        0        0     4482 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Lrange_/StDev.py
--rw-rw-rw-   0        0        0     6119 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Lrange_/StandardDev.py
--rw-rw-rw-   0        0        0     7093 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Lrange_/Xmaximum.py
--rw-rw-rw-   0        0        0     7093 2021-05-16 18:18:40.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Lrange_/Xminimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Lrange_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0     1256 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.883112 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/
--rw-rw-rw-   0        0        0     2514 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/Classic.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.918019 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/Classic_/
--rw-rw-rw-   0        0        0     7259 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/Classic_/Average.py
--rw-rw-rw-   0        0        0     7259 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/Classic_/Current.py
--rw-rw-rw-   0        0        0     7259 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/Classic_/Maximum.py
--rw-rw-rw-   0        0        0     4641 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/Classic_/Minimum.py
--rw-rw-rw-   0        0        0     5504 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/Classic_/StandardDev.py
--rw-rw-rw-   0        0        0     7286 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/Classic_/Xmaximum.py
--rw-rw-rw-   0        0        0     7271 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/Classic_/Xminimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/Classic_/__init__.py
--rw-rw-rw-   0        0        0     1458 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.939960 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/
--rw-rw-rw-   0        0        0     2480 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le1M.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:44.977859 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le1M_/
--rw-rw-rw-   0        0        0     7225 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le1M_/Average.py
--rw-rw-rw-   0        0        0     7225 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le1M_/Current.py
--rw-rw-rw-   0        0        0     9369 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le1M_/Maximum.py
--rw-rw-rw-   0        0        0     7479 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le1M_/Minimum.py
--rw-rw-rw-   0        0        0     5196 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le1M_/StandardDev.py
--rw-rw-rw-   0        0        0     7252 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le1M_/Xmaximum.py
--rw-rw-rw-   0        0        0     7237 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le1M_/Xminimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le1M_/__init__.py
--rw-rw-rw-   0        0        0     2719 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le2M.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.017752 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le2M_/
--rw-rw-rw-   0        0        0     8273 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le2M_/Average.py
--rw-rw-rw-   0        0        0     8273 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le2M_/Current.py
--rw-rw-rw-   0        0        0     8273 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le2M_/Maximum.py
--rw-rw-rw-   0        0        0     6825 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le2M_/Minimum.py
--rw-rw-rw-   0        0        0     6682 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le2M_/StandardDev.py
--rw-rw-rw-   0        0        0     8285 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le2M_/Xmaximum.py
--rw-rw-rw-   0        0        0     8285 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le2M_/Xminimum.py
--rw-rw-rw-   0        0        0     1206 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le2M_/YieldPy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le2M_/__init__.py
--rw-rw-rw-   0        0        0     2729 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Lrange.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.062634 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Lrange_/
--rw-rw-rw-   0        0        0     6750 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Lrange_/Average.py
--rw-rw-rw-   0        0        0     6750 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Lrange_/Current.py
--rw-rw-rw-   0        0        0     6750 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Lrange_/Maximum.py
--rw-rw-rw-   0        0        0     5684 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Lrange_/Minimum.py
--rw-rw-rw-   0        0        0     4540 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Lrange_/StDev.py
--rw-rw-rw-   0        0        0     6097 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Lrange_/StandardDev.py
--rw-rw-rw-   0        0        0     6762 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Lrange_/Xmaximum.py
--rw-rw-rw-   0        0        0     6762 2021-05-16 18:18:38.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Lrange_/Xminimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Lrange_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/__init__.py
--rw-rw-rw-   0        0        0     1273 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.076595 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/
--rw-rw-rw-   0        0        0     1005 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/Edrate.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.084574 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/Edrate_/
--rw-rw-rw-   0        0        0     5701 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/Edrate_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.095544 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/Edrate_/Current_/
--rw-rw-rw-   0        0        0     2174 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/Edrate_/Current_/C.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/Edrate_/Current_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/Edrate_/__init__.py
--rw-rw-rw-   0        0        0     1015 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/Ssequence.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.105519 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/Ssequence_/
--rw-rw-rw-   0        0        0     1007 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/Ssequence_/Edrate.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.114494 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/Ssequence_/Edrate_/
--rw-rw-rw-   0        0        0     4387 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/Ssequence_/Edrate_/Current.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/Ssequence_/Edrate_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/Ssequence_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/__init__.py
--rw-rw-rw-   0        0        0     1749 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.137434 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/
--rw-rw-rw-   0        0        0     1720 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Brate.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.162366 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Brate_/
--rw-rw-rw-   0        0        0     7655 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Brate_/Average.py
--rw-rw-rw-   0        0        0     7655 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Brate_/Current.py
--rw-rw-rw-   0        0        0     7655 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Brate_/Maximum.py
--rw-rw-rw-   0        0        0     7727 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Brate_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Brate_/__init__.py
--rw-rw-rw-   0        0        0     1729 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Edrate.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.186303 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Edrate_/
--rw-rw-rw-   0        0        0     8939 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Edrate_/Average.py
--rw-rw-rw-   0        0        0     8939 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Edrate_/Current.py
--rw-rw-rw-   0        0        0     9011 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Edrate_/Maximum.py
--rw-rw-rw-   0        0        0     9011 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Edrate_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Edrate_/__init__.py
--rw-rw-rw-   0        0        0     1456 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.204256 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/
--rw-rw-rw-   0        0        0     1713 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le1M.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.228191 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le1M_/
--rw-rw-rw-   0        0        0     7104 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le1M_/Average.py
--rw-rw-rw-   0        0        0     7104 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le1M_/Current.py
--rw-rw-rw-   0        0        0     7104 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le1M_/Maximum.py
--rw-rw-rw-   0        0        0     7104 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le1M_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le1M_/__init__.py
--rw-rw-rw-   0        0        0     1713 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le2M.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.251129 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le2M_/
--rw-rw-rw-   0        0        0     7491 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le2M_/Average.py
--rw-rw-rw-   0        0        0     7491 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le2M_/Current.py
--rw-rw-rw-   0        0        0     7491 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le2M_/Maximum.py
--rw-rw-rw-   0        0        0     7491 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le2M_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le2M_/__init__.py
--rw-rw-rw-   0        0        0     1731 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Lrange.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.275066 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Lrange_/
--rw-rw-rw-   0        0        0     7509 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Lrange_/Average.py
--rw-rw-rw-   0        0        0     7509 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Lrange_/Current.py
--rw-rw-rw-   0        0        0     7509 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Lrange_/Maximum.py
--rw-rw-rw-   0        0        0     7509 2021-05-16 18:18:37.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Lrange_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Lrange_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0     1256 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.291023 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/
--rw-rw-rw-   0        0        0     1740 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/Classic.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.313963 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/Classic_/
--rw-rw-rw-   0        0        0     5763 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/Classic_/Average.py
--rw-rw-rw-   0        0        0     5763 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/Classic_/Current.py
--rw-rw-rw-   0        0        0     5763 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/Classic_/Maximum.py
--rw-rw-rw-   0        0        0     5763 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/Classic_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/Classic_/__init__.py
--rw-rw-rw-   0        0        0     1458 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.332911 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/
--rw-rw-rw-   0        0        0     1715 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le1M.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.356848 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le1M_/
--rw-rw-rw-   0        0        0     7576 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le1M_/Average.py
--rw-rw-rw-   0        0        0     7576 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le1M_/Current.py
--rw-rw-rw-   0        0        0     7576 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le1M_/Maximum.py
--rw-rw-rw-   0        0        0     7576 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le1M_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le1M_/__init__.py
--rw-rw-rw-   0        0        0     1715 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le2M.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.378789 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le2M_/
--rw-rw-rw-   0        0        0     7570 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le2M_/Average.py
--rw-rw-rw-   0        0        0     7570 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le2M_/Current.py
--rw-rw-rw-   0        0        0     7570 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le2M_/Maximum.py
--rw-rw-rw-   0        0        0     7570 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le2M_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le2M_/__init__.py
--rw-rw-rw-   0        0        0     1733 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Lrange.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.401728 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Lrange_/
--rw-rw-rw-   0        0        0     7588 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Lrange_/Average.py
--rw-rw-rw-   0        0        0     7588 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Lrange_/Current.py
--rw-rw-rw-   0        0        0     7588 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Lrange_/Maximum.py
--rw-rw-rw-   0        0        0     7588 2021-05-16 18:18:36.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Lrange_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Lrange_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/__init__.py
--rw-rw-rw-   0        0        0     1454 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.421675 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/
--rw-rw-rw-   0        0        0      967 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/Brate.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.429654 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/Brate_/
--rw-rw-rw-   0        0        0     6448 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/Brate_/Ptx.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/Brate_/__init__.py
--rw-rw-rw-   0        0        0     1455 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.448604 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/LowEnergy_/
--rw-rw-rw-   0        0        0     4016 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/LowEnergy_/Le1M.py
--rw-rw-rw-   0        0        0     4175 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/LowEnergy_/Le2M.py
--rw-rw-rw-   0        0        0     4199 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/LowEnergy_/Lrange.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0     1256 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/Nmode.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.462565 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/Nmode_/
--rw-rw-rw-   0        0        0     5224 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/Nmode_/Classic.py
--rw-rw-rw-   0        0        0     1457 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/Nmode_/LowEnergy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.480518 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/Nmode_/LowEnergy_/
--rw-rw-rw-   0        0        0     4482 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/Nmode_/LowEnergy_/Le1M.py
--rw-rw-rw-   0        0        0     4476 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/Nmode_/LowEnergy_/Le2M.py
--rw-rw-rw-   0        0        0     4500 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/Nmode_/LowEnergy_/Lrange.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/Nmode_/LowEnergy_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/Nmode_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/__init__.py
--rw-rw-rw-   0        0        0      989 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sgacp.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.490493 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sgacp_/
--rw-rw-rw-   0        0        0      973 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sgacp_/Edrate.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.498469 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sgacp_/Edrate_/
--rw-rw-rw-   0        0        0     6271 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sgacp_/Edrate_/Ptx.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sgacp_/Edrate_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sgacp_/__init__.py
--rw-rw-rw-   0        0        0      975 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/SoBw.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.520412 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/SoBw_/
--rw-rw-rw-   0        0        0      999 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/SoBw_/Brate.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.530384 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/SoBw_/Brate_/
--rw-rw-rw-   0        0        0     7454 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/SoBw_/Brate_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/SoBw_/Brate_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/SoBw_/__init__.py
--rw-rw-rw-   0        0        0     1935 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/State.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.539361 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/State_/
--rw-rw-rw-   0        0        0     2582 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/State_/All.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/State_/__init__.py
--rw-rw-rw-   0        0        0     3975 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.600198 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/
--rw-rw-rw-   0        0        0     1535 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/DevMagnitude.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.618152 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/DevMagnitude_/
--rw-rw-rw-   0        0        0     2455 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/DevMagnitude_/Average.py
--rw-rw-rw-   0        0        0     2455 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/DevMagnitude_/Current.py
--rw-rw-rw-   0        0        0     2455 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/DevMagnitude_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/DevMagnitude_/__init__.py
--rw-rw-rw-   0        0        0     1764 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Fdeviation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.642087 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Fdeviation_/
--rw-rw-rw-   0        0        0     2679 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Fdeviation_/Average.py
--rw-rw-rw-   0        0        0     2679 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Fdeviation_/Current.py
--rw-rw-rw-   0        0        0     2679 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Fdeviation_/Maximum.py
--rw-rw-rw-   0        0        0     2679 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Fdeviation_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Fdeviation_/__init__.py
--rw-rw-rw-   0        0        0     1005 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Frange.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.650066 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Frange_/
--rw-rw-rw-   0        0        0     2129 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Frange_/Average.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Frange_/__init__.py
--rw-rw-rw-   0        0        0     2522 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/IqAbs.py
--rw-rw-rw-   0        0        0     2561 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/IqDifference.py
--rw-rw-rw-   0        0        0     2532 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/IqError.py
--rw-rw-rw-   0        0        0     1274 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Pdeviation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.663032 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Pdeviation_/
--rw-rw-rw-   0        0        0     3455 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Pdeviation_/Maximum.py
--rw-rw-rw-   0        0        0     3455 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Pdeviation_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Pdeviation_/__init__.py
--rw-rw-rw-   0        0        0     1527 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Pdifference.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.679986 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Pdifference_/
--rw-rw-rw-   0        0        0     2591 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Pdifference_/Average.py
--rw-rw-rw-   0        0        0     2591 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Pdifference_/Current.py
--rw-rw-rw-   0        0        0     2591 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Pdifference_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Pdifference_/__init__.py
--rw-rw-rw-   0        0        0     1773 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/PowerVsTime.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.705917 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/PowerVsTime_/
--rw-rw-rw-   0        0        0     2463 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/PowerVsTime_/Average.py
--rw-rw-rw-   0        0        0     2463 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/PowerVsTime_/Current.py
--rw-rw-rw-   0        0        0     2463 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/PowerVsTime_/Maximum.py
--rw-rw-rw-   0        0        0     2463 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/PowerVsTime_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/PowerVsTime_/__init__.py
--rw-rw-rw-   0        0        0     1678 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sacp.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.726860 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sacp_/
--rw-rw-rw-   0        0        0     4667 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sacp_/Average.py
--rw-rw-rw-   0        0        0     4667 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sacp_/Current.py
--rw-rw-rw-   0        0        0     4667 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sacp_/Maximum.py
--rw-rw-rw-   0        0        0     4721 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sacp_/Ptx.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sacp_/__init__.py
--rw-rw-rw-   0        0        0     1687 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sgacp.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.750798 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sgacp_/
--rw-rw-rw-   0        0        0     3081 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sgacp_/Average.py
--rw-rw-rw-   0        0        0     3081 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sgacp_/Current.py
--rw-rw-rw-   0        0        0     3081 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sgacp_/Maximum.py
--rw-rw-rw-   0        0        0     3059 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sgacp_/Ptx.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sgacp_/__init__.py
--rw-rw-rw-   0        0        0     1471 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/SoBw.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.769746 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/SoBw_/
--rw-rw-rw-   0        0        0     2577 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/SoBw_/Average.py
--rw-rw-rw-   0        0        0     2577 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/SoBw_/Current.py
--rw-rw-rw-   0        0        0     2577 2021-05-16 18:18:34.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/SoBw_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/SoBw_/__init__.py
--rw-rw-rw-   0        0        0     1728 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Spower.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.790691 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Spower_/
--rw-rw-rw-   0        0        0     2019 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Spower_/Average.py
--rw-rw-rw-   0        0        0     2019 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Spower_/Current.py
--rw-rw-rw-   0        0        0     2019 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Spower_/Maximum.py
--rw-rw-rw-   0        0        0     2019 2021-05-16 18:18:35.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Spower_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Spower_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/__init__.py
--rw-rw-rw-   0        0        0     2788 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Route.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.802659 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Route_/
--rw-rw-rw-   0        0        0     1412 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Route_/RfSettings.py
--rw-rw-rw-   0        0        0     4672 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Route_/Scenario.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.812631 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Route_/Scenario_/
--rw-rw-rw-   0        0        0     1131 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Route_/Scenario_/MaProtocol.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Route_/Scenario_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Route_/__init__.py
--rw-rw-rw-   0        0        0     7175 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.838563 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/
--rw-rw-rw-   0        0        0     1029 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/Adetected.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.845544 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/Adetected_/
--rw-rw-rw-   0        0        0     1229 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/Adetected_/Aaddress.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/Adetected_/__init__.py
--rw-rw-rw-   0        0        0     1743 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/Per.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.855517 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/Per_/
--rw-rw-rw-   0        0        0     1207 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/Per_/RxPackets.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/Per_/__init__.py
--rw-rw-rw-   0        0        0     1252 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/Sensitivity.py
--rw-rw-rw-   0        0        0     1306 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/SpotCheck.py
--rw-rw-rw-   0        0        0     1931 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/State.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.864494 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/State_/
--rw-rw-rw-   0        0        0     2578 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/State_/All.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/State_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/__init__.py
--rw-rw-rw-   0        0        0     1003 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Sense.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.874467 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Sense_/
--rw-rw-rw-   0        0        0     3222 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Sense_/Elogging.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Sense_/__init__.py
--rw-rw-rw-   0        0        0     1023 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trigger.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.881448 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trigger_/
--rw-rw-rw-   0        0        0     4928 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trigger_/MultiEval.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.891422 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trigger_/MultiEval_/
--rw-rw-rw-   0        0        0     1035 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trigger_/MultiEval_/Catalog.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trigger_/MultiEval_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trigger_/__init__.py
--rw-rw-rw-   0        0        0     6926 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trx.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.917353 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trx_/
--rw-rw-rw-   0        0        0     1722 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trx_/Acp.py
--rw-rw-rw-   0        0        0     3461 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trx_/Modulation.py
--rw-rw-rw-   0        0        0     2403 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trx_/Power.py
--rw-rw-rw-   0        0        0     1258 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trx_/Spot.py
--rw-rw-rw-   0        0        0     1913 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trx_/State.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:45.929322 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trx_/State_/
--rw-rw-rw-   0        0        0     2560 2021-05-16 18:18:33.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trx_/State_/All.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trx_/State_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trx_/__init__.py
--rw-rw-rw-   0        0        0        0 2019-11-18 07:28:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/__init__.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:46.085904 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/
--rw-rw-rw-   0        0        0      541 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/ArgLinkedEventArgs.py
--rw-rw-rw-   0        0        0     4003 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/ArgSingle.py
--rw-rw-rw-   0        0        0     1061 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/ArgSingleList.py
--rw-rw-rw-   0        0        0     1000 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/ArgSingleSuppressed.py
--rw-rw-rw-   0        0        0     9026 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/ArgStringComposer.py
--rw-rw-rw-   0        0        0     5624 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/ArgStruct.py
--rw-rw-rw-   0        0        0     3354 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/ArgStructList.py
--rw-rw-rw-   0        0        0     2446 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/ArgStructStringParser.py
--rw-rw-rw-   0        0        0     5176 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/CommandsGroup.py
--rw-rw-rw-   0        0        0    20227 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/Conversions.py
--rw-rw-rw-   0        0        0     3618 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/ConverterFromScpiString.py
--rw-rw-rw-   0        0        0     4409 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/ConverterToScpiString.py
--rw-rw-rw-   0        0        0    10299 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/Core.py
--rw-rw-rw-   0        0        0    38340 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/Instrument.py
--rw-rw-rw-   0        0        0     3918 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/InstrumentErrors.py
--rw-rw-rw-   0        0        0     2081 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/InstrumentOptions.py
--rw-rw-rw-   0        0        0     5101 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/InstrumentSettings.py
--rw-rw-rw-   0        0        0     3380 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/InternalLinker.py
--rw-rw-rw-   0        0        0     4331 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/IoTransferEventArgs.py
--rw-rw-rw-   0        0        0     3841 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/RepeatedCapability.py
--rw-rw-rw-   0        0        0     4719 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/StreamReader.py
--rw-rw-rw-   0        0        0     4938 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/StreamWriter.py
--rw-rw-rw-   0        0        0     1040 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/StructBase.py
--rw-rw-rw-   0        0        0     2893 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/Types.py
--rw-rw-rw-   0        0        0     4530 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/Utilities.py
--rw-rw-rw-   0        0        0     4850 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/VisaPluginSocketIo.py
--rw-rw-rw-   0        0        0    44232 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/VisaSession.py
--rw-rw-rw-   0        0        0     6999 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/VisaSessionSim.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/__init__.py
--rw-rw-rw-   0        0        0    10621 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/RsCmwBluetoothMeas.py
--rw-rw-rw-   0        0        0      897 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/__init__.py
--rw-rw-rw-   0        0        0    10810 2021-05-16 18:18:24.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/enums.py
--rw-rw-rw-   0        0        0     1981 2021-05-16 18:18:24.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/repcap.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:18:42.827703 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas.egg-info/
--rw-rw-rw-   0        0        0     3943 2021-05-16 18:18:42.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0    52833 2021-05-16 18:18:42.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2021-05-16 18:18:42.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0        7 2021-05-16 18:18:42.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas.egg-info/requires.txt
--rw-rw-rw-   0        0        0       19 2021-05-16 18:18:42.000000 RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas.egg-info/top_level.txt
--rw-rw-rw-   0        0        0       42 2021-05-16 18:18:46.096873 RsCmwBluetoothMeas-3.8.20.28/setup.cfg
--rw-rw-rw-   0        0        0      885 2021-05-16 18:18:41.000000 RsCmwBluetoothMeas-3.8.20.28/setup.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.799423 RsCmwBluetoothMeas-4.0.110/
+-rw-rw-rw-   0        0        0     4471 2024-04-17 08:45:52.799423 RsCmwBluetoothMeas-4.0.110/PKG-INFO
+-rw-rw-rw-   0        0        0     2726 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/README.rst
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.614022 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.640756 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/CustomFiles/
+-rw-rw-rw-   0        0        0       90 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/CustomFiles/__init__.py
+-rw-rw-rw-   0        0        0     3725 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/CustomFiles/events.py
+-rw-rw-rw-   0        0        0     4916 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/CustomFiles/reliability.py
+-rw-rw-rw-   0        0        0    21879 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/CustomFiles/utilities.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.644141 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.646135 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Call/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.649127 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Call/DtMode/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.655113 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Call/DtMode/LowEnergy/
+-rw-rw-rw-   0        0        0      819 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Call/DtMode/LowEnergy/Rdevices.py
+-rw-rw-rw-   0        0        0     1990 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Call/DtMode/LowEnergy/__init__.py
+-rw-rw-rw-   0        0        0     1046 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Call/DtMode/__init__.py
+-rw-rw-rw-   0        0        0     1010 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Call/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.661096 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Clean/
+-rw-rw-rw-   0        0        0     1193 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Clean/Elogging.py
+-rw-rw-rw-   0        0        0     1031 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Clean/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.666602 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.666602 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/ComSettings/
+-rw-rw-rw-   0        0        0     1751 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/ComSettings/Ports.py
+-rw-rw-rw-   0        0        0     6569 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/ComSettings/__init__.py
+-rw-rw-rw-   0        0        0     3551 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Display.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.666602 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.676597 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/
+-rw-rw-rw-   0        0        0     1361 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Eattenuation.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.676597 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Limit/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.686591 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Limit/Mper/
+-rw-rw-rw-   0        0        0     3520 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Limit/Mper/LowEnergy.py
+-rw-rw-rw-   0        0        0     1042 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Limit/Mper/__init__.py
+-rw-rw-rw-   0        0        0     1005 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Limit/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.686591 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Per/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.696587 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Per/Packets/
+-rw-rw-rw-   0        0        0     3454 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Per/Packets/LowEnergy.py
+-rw-rw-rw-   0        0        0     1057 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Per/Packets/__init__.py
+-rw-rw-rw-   0        0        0     1908 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Per/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.696587 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Rintegrity/
+-rw-rw-rw-   0        0        0     3415 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Rintegrity/LowEnergy.py
+-rw-rw-rw-   0        0        0     1070 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Rintegrity/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.706581 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Search/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.706581 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Search/Limit/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.714088 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Search/Limit/Mper/
+-rw-rw-rw-   0        0        0     3649 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Search/Limit/Mper/LowEnergy.py
+-rw-rw-rw-   0        0        0     1044 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Search/Limit/Mper/__init__.py
+-rw-rw-rw-   0        0        0     1007 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Search/Limit/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.714088 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Search/Packets/
+-rw-rw-rw-   0        0        0     3508 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Search/Packets/LowEnergy.py
+-rw-rw-rw-   0        0        0     1057 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Search/Packets/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.724087 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Search/Rintegrity/
+-rw-rw-rw-   0        0        0     3544 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Search/Rintegrity/LowEnergy.py
+-rw-rw-rw-   0        0        0     1072 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Search/Rintegrity/__init__.py
+-rw-rw-rw-   0        0        0     3553 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Search/__init__.py
+-rw-rw-rw-   0        0        0     1370 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/SmIndex.py
+-rw-rw-rw-   0        0        0     2276 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/__init__.py
+-rw-rw-rw-   0        0        0     1047 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.734081 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdr/
+-rw-rw-rw-   0        0        0     8546 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdr/InputSignal.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.744076 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdr/Limit/
+-rw-rw-rw-   0        0        0     5080 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdr/Limit/P4H.py
+-rw-rw-rw-   0        0        0     5456 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdr/Limit/P8H.py
+-rw-rw-rw-   0        0        0     2163 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdr/Limit/Pencoding.py
+-rw-rw-rw-   0        0        0     6600 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdr/Limit/__init__.py
+-rw-rw-rw-   0        0        0    10488 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdr/Result.py
+-rw-rw-rw-   0        0        0     3756 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdr/Scount.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.754071 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdr/Sgacp/
+-rw-rw-rw-   0        0        0     1507 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdr/Sgacp/Measurement.py
+-rw-rw-rw-   0        0        0     1059 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdr/Sgacp/__init__.py
+-rw-rw-rw-   0        0        0     4774 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdr/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.754071 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.764065 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/InputSignal/
+-rw-rw-rw-   0        0        0     2424 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/InputSignal/Plength.py
+-rw-rw-rw-   0        0        0     3891 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/InputSignal/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.764065 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/Limit/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.774060 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/Limit/P4Hp/
+-rw-rw-rw-   0        0        0     2942 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/Limit/P4Hp/EvMagnitude.py
+-rw-rw-rw-   0        0        0     3447 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/Limit/P4Hp/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.781035 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/Limit/P8Hp/
+-rw-rw-rw-   0        0        0     2942 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/Limit/P8Hp/EvMagnitude.py
+-rw-rw-rw-   0        0        0     3823 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/Limit/P8Hp/__init__.py
+-rw-rw-rw-   0        0        0     2702 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/Limit/PowerVsTime.py
+-rw-rw-rw-   0        0        0     4066 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/Limit/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.782661 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/Result/
+-rw-rw-rw-   0        0        0     2871 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/Result/All.py
+-rw-rw-rw-   0        0        0     5047 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/Result/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.794612 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/Sacp/
+-rw-rw-rw-   0        0        0     1507 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/Sacp/Measurement.py
+-rw-rw-rw-   0        0        0     1054 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/Sacp/__init__.py
+-rw-rw-rw-   0        0        0     2929 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/Scount.py
+-rw-rw-rw-   0        0        0     4788 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.824240 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/
+-rw-rw-rw-   0        0        0     1304 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Aacc.py
+-rw-rw-rw-   0        0        0     1514 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/AccAddress.py
+-rw-rw-rw-   0        0        0     2386 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/BdAddress.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.832012 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cscheme/
+-rw-rw-rw-   0        0        0     1523 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cscheme/LowEnergy.py
+-rw-rw-rw-   0        0        0     1053 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cscheme/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.834005 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cte/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.841628 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cte/LowEnergy/
+-rw-rw-rw-   0        0        0     3217 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cte/LowEnergy/Le1M.py
+-rw-rw-rw-   0        0        0     3217 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cte/LowEnergy/Le2M.py
+-rw-rw-rw-   0        0        0     1245 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cte/LowEnergy/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.854335 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cte/Qhsl/
+-rw-rw-rw-   0        0        0     2336 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cte/Qhsl/P2Q.py
+-rw-rw-rw-   0        0        0     2336 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cte/Qhsl/P3Q.py
+-rw-rw-rw-   0        0        0     2336 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cte/Qhsl/P4Q.py
+-rw-rw-rw-   0        0        0     2336 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cte/Qhsl/P5Q.py
+-rw-rw-rw-   0        0        0     2336 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cte/Qhsl/P6Q.py
+-rw-rw-rw-   0        0        0     1841 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cte/Qhsl/__init__.py
+-rw-rw-rw-   0        0        0     1254 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cte/__init__.py
+-rw-rw-rw-   0        0        0     1304 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Dacc.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.861325 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/DtMode/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.866310 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/DtMode/Pattern/
+-rw-rw-rw-   0        0        0     3728 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/DtMode/Pattern/LowEnergy.py
+-rw-rw-rw-   0        0        0     1055 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/DtMode/Pattern/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.872295 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/DtMode/Plength/
+-rw-rw-rw-   0        0        0     3322 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/DtMode/Plength/LowEnergy.py
+-rw-rw-rw-   0        0        0     1055 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/DtMode/Plength/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.875287 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/DtMode/RxQuality/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.881188 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/DtMode/RxQuality/Plength/
+-rw-rw-rw-   0        0        0     3978 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/DtMode/RxQuality/Plength/LowEnergy.py
+-rw-rw-rw-   0        0        0     1057 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/DtMode/RxQuality/Plength/__init__.py
+-rw-rw-rw-   0        0        0     1049 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/DtMode/RxQuality/__init__.py
+-rw-rw-rw-   0        0        0     1536 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/DtMode/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.886175 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Fec/
+-rw-rw-rw-   0        0        0     1911 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Fec/LowEnergy.py
+-rw-rw-rw-   0        0        0     1033 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Fec/__init__.py
+-rw-rw-rw-   0        0        0     2254 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Lap.py
+-rw-rw-rw-   0        0        0     3097 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/LowEnergy.py
+-rw-rw-rw-   0        0        0     2266 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Nap.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.891160 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Oslots/
+-rw-rw-rw-   0        0        0     3902 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Oslots/LowEnergy.py
+-rw-rw-rw-   0        0        0     3773 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Oslots/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.895189 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Pattern/
+-rw-rw-rw-   0        0        0     6134 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Pattern/LowEnergy.py
+-rw-rw-rw-   0        0        0     3038 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Pattern/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.895189 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Plength/
+-rw-rw-rw-   0        0        0     6401 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Plength/LowEnergy.py
+-rw-rw-rw-   0        0        0     4850 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Plength/Qhsl.py
+-rw-rw-rw-   0        0        0     5147 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Plength/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.905184 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Ptype/
+-rw-rw-rw-   0        0        0     5320 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Ptype/LowEnergy.py
+-rw-rw-rw-   0        0        0     5514 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Ptype/Qhsl.py
+-rw-rw-rw-   0        0        0     3973 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Ptype/__init__.py
+-rw-rw-rw-   0        0        0     1421 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Qhsl.py
+-rw-rw-rw-   0        0        0     1347 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/SynWord.py
+-rw-rw-rw-   0        0        0     2246 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Uap.py
+-rw-rw-rw-   0        0        0     8367 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.924190 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.924190 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Brate/
+-rw-rw-rw-   0        0        0     1679 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Brate/FilterPy.py
+-rw-rw-rw-   0        0        0     1035 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Brate/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.934185 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Edrate/
+-rw-rw-rw-   0        0        0     1811 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Edrate/FilterPy.py
+-rw-rw-rw-   0        0        0     1040 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Edrate/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.934185 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Frange/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.944180 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Frange/Brate/
+-rw-rw-rw-   0        0        0     3536 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Frange/Brate/Measurement.py
+-rw-rw-rw-   0        0        0     1061 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Frange/Brate/__init__.py
+-rw-rw-rw-   0        0        0     1016 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Frange/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.954175 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.977197 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Brate/
+-rw-rw-rw-   0        0        0     2484 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Brate/Delta.py
+-rw-rw-rw-   0        0        0     2613 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Brate/Faccuracy.py
+-rw-rw-rw-   0        0        0     7675 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Brate/Fdrift.py
+-rw-rw-rw-   0        0        0     2354 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Brate/Mratio.py
+-rw-rw-rw-   0        0        0     4143 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Brate/PowerVsTime.py
+-rw-rw-rw-   0        0        0    11433 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Brate/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.980189 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Cte/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.981629 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Cte/LowEnergy/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.993070 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Cte/LowEnergy/Le1M/
+-rw-rw-rw-   0        0        0     2869 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Cte/LowEnergy/Le1M/Foffset.py
+-rw-rw-rw-   0        0        0     3490 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Cte/LowEnergy/Le1M/Pdeviation.py
+-rw-rw-rw-   0        0        0     4718 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Cte/LowEnergy/Le1M/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.000057 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Cte/LowEnergy/Le2M/
+-rw-rw-rw-   0        0        0     2869 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Cte/LowEnergy/Le2M/Foffset.py
+-rw-rw-rw-   0        0        0     3490 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Cte/LowEnergy/Le2M/Pdeviation.py
+-rw-rw-rw-   0        0        0     4718 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Cte/LowEnergy/Le2M/__init__.py
+-rw-rw-rw-   0        0        0     1247 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Cte/LowEnergy/__init__.py
+-rw-rw-rw-   0        0        0     1035 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Cte/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.010626 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Edrate/
+-rw-rw-rw-   0        0        0     3311 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Edrate/Dpsk.py
+-rw-rw-rw-   0        0        0     3352 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Edrate/Dqpsk.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.017486 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Edrate/Pencoding/
+-rw-rw-rw-   0        0        0     3347 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Edrate/Pencoding/Ssequence.py
+-rw-rw-rw-   0        0        0     3246 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Edrate/Pencoding/__init__.py
+-rw-rw-rw-   0        0        0     7785 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Edrate/__init__.py
+-rw-rw-rw-   0        0        0     3317 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Frange.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.022677 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.028150 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Daverage/
+-rw-rw-rw-   0        0        0     3314 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Daverage/Df2S.py
+-rw-rw-rw-   0        0        0     3919 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Daverage/__init__.py
+-rw-rw-rw-   0        0        0     2586 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Delta.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.032272 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Dmaximum/
+-rw-rw-rw-   0        0        0     3314 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Dmaximum/Df2S.py
+-rw-rw-rw-   0        0        0     3919 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Dmaximum/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.032272 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Dminimum/
+-rw-rw-rw-   0        0        0     3314 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Dminimum/Df2S.py
+-rw-rw-rw-   0        0        0     3919 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Dminimum/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.052571 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le1M/
+-rw-rw-rw-   0        0        0     2904 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le1M/Faccuracy.py
+-rw-rw-rw-   0        0        0     2862 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le1M/Foffset.py
+-rw-rw-rw-   0        0        0     2509 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le1M/Mratio.py
+-rw-rw-rw-   0        0        0     4538 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le1M/PowerVsTime.py
+-rw-rw-rw-   0        0        0     4307 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le1M/Sacp.py
+-rw-rw-rw-   0        0        0     5435 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le1M/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.072615 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le2M/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.078640 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le2M/Daverage/
+-rw-rw-rw-   0        0        0     3335 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le2M/Daverage/Df2S.py
+-rw-rw-rw-   0        0        0     3956 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le2M/Daverage/__init__.py
+-rw-rw-rw-   0        0        0     2623 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le2M/Delta.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.078640 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le2M/Dmaximum/
+-rw-rw-rw-   0        0        0     3335 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le2M/Dmaximum/Df2S.py
+-rw-rw-rw-   0        0        0     3956 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le2M/Dmaximum/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.088636 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le2M/Dminimum/
+-rw-rw-rw-   0        0        0     3335 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le2M/Dminimum/Df2S.py
+-rw-rw-rw-   0        0        0     3956 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le2M/Dminimum/__init__.py
+-rw-rw-rw-   0        0        0     2900 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le2M/Faccuracy.py
+-rw-rw-rw-   0        0        0     2858 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le2M/Foffset.py
+-rw-rw-rw-   0        0        0     2505 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le2M/Mratio.py
+-rw-rw-rw-   0        0        0     4534 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le2M/PowerVsTime.py
+-rw-rw-rw-   0        0        0     4303 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le2M/Sacp.py
+-rw-rw-rw-   0        0        0     6416 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Le2M/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.108625 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Lrange/
+-rw-rw-rw-   0        0        0     3348 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Lrange/Daverage.py
+-rw-rw-rw-   0        0        0     2645 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Lrange/Delta.py
+-rw-rw-rw-   0        0        0     3348 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Lrange/Dmaximum.py
+-rw-rw-rw-   0        0        0     3348 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Lrange/Dminimum.py
+-rw-rw-rw-   0        0        0     2912 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Lrange/Faccuracy.py
+-rw-rw-rw-   0        0        0     2870 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Lrange/Foffset.py
+-rw-rw-rw-   0        0        0     4546 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Lrange/PowerVsTime.py
+-rw-rw-rw-   0        0        0     4315 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Lrange/Sacp.py
+-rw-rw-rw-   0        0        0     6203 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Lrange/__init__.py
+-rw-rw-rw-   0        0        0     2466 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/__init__.py
+-rw-rw-rw-   0        0        0     2822 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/PowerVsTime.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.128614 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Qhsl/
+-rw-rw-rw-   0        0        0     2873 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Qhsl/P2Q.py
+-rw-rw-rw-   0        0        0     2873 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Qhsl/P3Q.py
+-rw-rw-rw-   0        0        0     2873 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Qhsl/P4Q.py
+-rw-rw-rw-   0        0        0     2873 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Qhsl/P5Q.py
+-rw-rw-rw-   0        0        0     2873 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Qhsl/P6Q.py
+-rw-rw-rw-   0        0        0     3093 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Qhsl/PowerVsTime.py
+-rw-rw-rw-   0        0        0     3006 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Qhsl/Sacp.py
+-rw-rw-rw-   0        0        0     5036 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Qhsl/__init__.py
+-rw-rw-rw-   0        0        0     4207 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Sacp.py
+-rw-rw-rw-   0        0        0     3945 2024-04-17 08:45:38.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/SoBw.py
+-rw-rw-rw-   0        0        0     6203 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.138608 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.148603 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/
+-rw-rw-rw-   0        0        0     1917 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Cidx.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.158598 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Results/
+-rw-rw-rw-   0        0        0     2496 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Results/Mscalar.py
+-rw-rw-rw-   0        0        0     2013 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Results/Pencoding.py
+-rw-rw-rw-   0        0        0     2496 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Results/Pscalar.py
+-rw-rw-rw-   0        0        0     2459 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Results/Sacp.py
+-rw-rw-rw-   0        0        0     2488 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Results/Sgacp.py
+-rw-rw-rw-   0        0        0     2459 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Results/SoBw.py
+-rw-rw-rw-   0        0        0     6121 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Results/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.184161 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Scount/
+-rw-rw-rw-   0        0        0     2580 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Scount/Mscalar.py
+-rw-rw-rw-   0        0        0     2018 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Scount/Pencoding.py
+-rw-rw-rw-   0        0        0     2590 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Scount/Pscalar.py
+-rw-rw-rw-   0        0        0     2568 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Scount/Sacp.py
+-rw-rw-rw-   0        0        0     2597 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Scount/Sgacp.py
+-rw-rw-rw-   0        0        0     2568 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Scount/SoBw.py
+-rw-rw-rw-   0        0        0     6271 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Scount/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.233930 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/
+-rw-rw-rw-   0        0        0     2277 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Btype.py
+-rw-rw-rw-   0        0        0     2359 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Cscheme.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.242905 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Cte/
+-rw-rw-rw-   0        0        0     2444 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Cte/TypePy.py
+-rw-rw-rw-   0        0        0     2167 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Cte/Units.py
+-rw-rw-rw-   0        0        0     1243 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Cte/__init__.py
+-rw-rw-rw-   0        0        0     2453 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/EnvelopePower.py
+-rw-rw-rw-   0        0        0     7694 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Extended.py
+-rw-rw-rw-   0        0        0     2289 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/FilterPy.py
+-rw-rw-rw-   0        0        0     2117 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Frequency.py
+-rw-rw-rw-   0        0        0     2300 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/MoException.py
+-rw-rw-rw-   0        0        0     2152 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Oslots.py
+-rw-rw-rw-   0        0        0     2551 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Pattern.py
+-rw-rw-rw-   0        0        0     2382 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Phy.py
+-rw-rw-rw-   0        0        0     2080 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Plength.py
+-rw-rw-rw-   0        0        0     2738 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Ptype.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.245200 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Qhsl/
+-rw-rw-rw-   0        0        0     2149 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Qhsl/Phy.py
+-rw-rw-rw-   0        0        0     6031 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Qhsl/__init__.py
+-rw-rw-rw-   0        0        0     2301 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Rtrigger.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.255195 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/SingleCmw/
+-rw-rw-rw-   0        0        0     2245 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/SingleCmw/Connector.py
+-rw-rw-rw-   0        0        0     1069 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/SingleCmw/__init__.py
+-rw-rw-rw-   0        0        0     2266 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Slength.py
+-rw-rw-rw-   0        0        0    10823 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/__init__.py
+-rw-rw-rw-   0        0        0     2572 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/__init__.py
+-rw-rw-rw-   0        0        0     1534 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/SingleCmw.py
+-rw-rw-rw-   0        0        0     6237 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.255195 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/LowEnergy/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.265189 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/LowEnergy/Le1M/
+-rw-rw-rw-   0        0        0     1929 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/LowEnergy/Le1M/FilterPy.py
+-rw-rw-rw-   0        0        0     1032 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/LowEnergy/Le1M/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.275184 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/LowEnergy/Le2M/
+-rw-rw-rw-   0        0        0     1925 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/LowEnergy/Le2M/FilterPy.py
+-rw-rw-rw-   0        0        0     1032 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/LowEnergy/Le2M/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.275184 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/LowEnergy/Lrange/
+-rw-rw-rw-   0        0        0     1937 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/LowEnergy/Lrange/FilterPy.py
+-rw-rw-rw-   0        0        0     1042 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/LowEnergy/Lrange/__init__.py
+-rw-rw-rw-   0        0        0     1479 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/LowEnergy/__init__.py
+-rw-rw-rw-   0        0        0     2701 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Malgorithm.py
+-rw-rw-rw-   0        0        0     1367 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Measurement.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.285179 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Qhsl/
+-rw-rw-rw-   0        0        0     1533 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Qhsl/FilterPy.py
+-rw-rw-rw-   0        0        0     1030 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Qhsl/__init__.py
+-rw-rw-rw-   0        0        0    42819 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Result.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.285179 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.295173 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/Brate/
+-rw-rw-rw-   0        0        0     2021 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/Brate/Measurement.py
+-rw-rw-rw-   0        0        0     1061 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/Brate/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.295173 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/LowEnergy/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.305168 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/LowEnergy/Le1M/
+-rw-rw-rw-   0        0        0     3081 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/LowEnergy/Le1M/Measurement.py
+-rw-rw-rw-   0        0        0     1058 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/LowEnergy/Le1M/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.315163 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/LowEnergy/Le2M/
+-rw-rw-rw-   0        0        0     3077 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/LowEnergy/Le2M/Measurement.py
+-rw-rw-rw-   0        0        0     1058 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/LowEnergy/Le2M/__init__.py
+-rw-rw-rw-   0        0        0     1245 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/LowEnergy/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.315163 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/Qhsl/
+-rw-rw-rw-   0        0        0     1561 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/Qhsl/Measurement.py
+-rw-rw-rw-   0        0        0     1056 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/Qhsl/__init__.py
+-rw-rw-rw-   0        0        0     1486 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/__init__.py
+-rw-rw-rw-   0        0        0    10828 2024-04-17 08:45:39.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Scount.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.315163 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sgacp/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.325158 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sgacp/Edrate/
+-rw-rw-rw-   0        0        0     2033 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sgacp/Edrate/Measurement.py
+-rw-rw-rw-   0        0        0     1066 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sgacp/Edrate/__init__.py
+-rw-rw-rw-   0        0        0     1019 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sgacp/__init__.py
+-rw-rw-rw-   0        0        0     2576 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Synchronise.py
+-rw-rw-rw-   0        0        0    10968 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.335153 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RfSettings/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.335153 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RfSettings/Cte/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.345147 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RfSettings/Cte/LowEnergy/
+-rw-rw-rw-   0        0        0     2744 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RfSettings/Cte/LowEnergy/Aoffset.py
+-rw-rw-rw-   0        0        0     2599 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RfSettings/Cte/LowEnergy/__init__.py
+-rw-rw-rw-   0        0        0     1033 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RfSettings/Cte/__init__.py
+-rw-rw-rw-   0        0        0     3915 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RfSettings/Dtx.py
+-rw-rw-rw-   0        0        0     2844 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RfSettings/Mchannel.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.345147 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RfSettings/Mmode/
+-rw-rw-rw-   0        0        0     2317 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RfSettings/Mmode/Nmode.py
+-rw-rw-rw-   0        0        0     2542 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RfSettings/Mmode/__init__.py
+-rw-rw-rw-   0        0        0     8517 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RfSettings/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.355142 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RxQuality/
+-rw-rw-rw-   0        0        0     1508 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RxQuality/Eattenuation.py
+-rw-rw-rw-   0        0        0     3633 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RxQuality/Per.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.365136 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RxQuality/Route/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.365136 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RxQuality/Route/Usage/
+-rw-rw-rw-   0        0        0     2549 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RxQuality/Route/Usage/All.py
+-rw-rw-rw-   0        0        0      997 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RxQuality/Route/Usage/__init__.py
+-rw-rw-rw-   0        0        0     3206 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RxQuality/Route/__init__.py
+-rw-rw-rw-   0        0        0     4042 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RxQuality/Sensitivity.py
+-rw-rw-rw-   0        0        0     1849 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RxQuality/SpotCheck.py
+-rw-rw-rw-   0        0        0     8820 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RxQuality/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.365136 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Trx/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.375132 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Trx/Result/
+-rw-rw-rw-   0        0        0     2871 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Trx/Result/All.py
+-rw-rw-rw-   0        0        0     1000 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Trx/Result/__init__.py
+-rw-rw-rw-   0        0        0     1007 2024-04-17 08:45:40.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Trx/__init__.py
+-rw-rw-rw-   0        0        0     7677 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.375132 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Diagnostic/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.390797 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Diagnostic/Bluetooth/
+-rw-rw-rw-   0        0        0     2446 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Diagnostic/Bluetooth/Synchronise.py
+-rw-rw-rw-   0        0        0     1077 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Diagnostic/Bluetooth/__init__.py
+-rw-rw-rw-   0        0        0     1276 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Diagnostic/RfControl.py
+-rw-rw-rw-   0        0        0     1324 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Diagnostic/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.394145 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.397136 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.400559 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Per/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.412254 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Per/LowEnergy/
+-rw-rw-rw-   0        0        0     3104 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Per/LowEnergy/Le1M.py
+-rw-rw-rw-   0        0        0     3104 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Per/LowEnergy/Le2M.py
+-rw-rw-rw-   0        0        0     3128 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Per/LowEnergy/Lrange.py
+-rw-rw-rw-   0        0        0     1481 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Per/LowEnergy/__init__.py
+-rw-rw-rw-   0        0        0     1774 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Per/State.py
+-rw-rw-rw-   0        0        0     2500 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Per/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.412254 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Search/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.412254 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Search/Per/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.429481 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Search/Per/LowEnergy/
+-rw-rw-rw-   0        0        0     3461 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Search/Per/LowEnergy/Le1M.py
+-rw-rw-rw-   0        0        0     3461 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Search/Per/LowEnergy/Le2M.py
+-rw-rw-rw-   0        0        0     3485 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Search/Per/LowEnergy/Lrange.py
+-rw-rw-rw-   0        0        0     1483 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Search/Per/LowEnergy/__init__.py
+-rw-rw-rw-   0        0        0     1802 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Search/Per/State.py
+-rw-rw-rw-   0        0        0     2565 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Search/Per/__init__.py
+-rw-rw-rw-   0        0        0     1001 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Search/__init__.py
+-rw-rw-rw-   0        0        0     1250 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/__init__.py
+-rw-rw-rw-   0        0        0     1045 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.431475 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.434467 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/InputSignal/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.442446 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/InputSignal/Adetected/
+-rw-rw-rw-   0        0        0     1155 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/InputSignal/Adetected/Plength.py
+-rw-rw-rw-   0        0        0     1267 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/InputSignal/Adetected/Ptype.py
+-rw-rw-rw-   0        0        0     1275 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/InputSignal/Adetected/__init__.py
+-rw-rw-rw-   0        0        0     1071 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/InputSignal/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.455242 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Modulation/
+-rw-rw-rw-   0        0        0     5501 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Modulation/Average.py
+-rw-rw-rw-   0        0        0     4590 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Modulation/Current.py
+-rw-rw-rw-   0        0        0     4324 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Modulation/Maximum.py
+-rw-rw-rw-   0        0        0     5529 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Modulation/StandardDev.py
+-rw-rw-rw-   0        0        0     1815 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Modulation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.459231 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Pencoding/
+-rw-rw-rw-   0        0        0     3353 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Pencoding/Current.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.462251 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Pencoding/Ssequence/
+-rw-rw-rw-   0        0        0     3447 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Pencoding/Ssequence/Current.py
+-rw-rw-rw-   0        0        0     1047 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Pencoding/Ssequence/__init__.py
+-rw-rw-rw-   0        0        0     1305 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Pencoding/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.472246 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/PowerVsTime/
+-rw-rw-rw-   0        0        0     4181 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/PowerVsTime/Average.py
+-rw-rw-rw-   0        0        0     4181 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/PowerVsTime/Current.py
+-rw-rw-rw-   0        0        0     4181 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/PowerVsTime/Maximum.py
+-rw-rw-rw-   0        0        0     4181 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/PowerVsTime/Minimum.py
+-rw-rw-rw-   0        0        0     1788 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/PowerVsTime/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.472246 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Sgacp/
+-rw-rw-rw-   0        0        0     3287 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Sgacp/Current.py
+-rw-rw-rw-   0        0        0     1025 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Sgacp/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.482241 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/State/
+-rw-rw-rw-   0        0        0     1722 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/State/All.py
+-rw-rw-rw-   0        0        0     2320 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/State/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.492236 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.502230 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/DevMagnitude/
+-rw-rw-rw-   0        0        0     1754 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/DevMagnitude/Average.py
+-rw-rw-rw-   0        0        0     1754 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/DevMagnitude/Current.py
+-rw-rw-rw-   0        0        0     1754 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/DevMagnitude/Maximum.py
+-rw-rw-rw-   0        0        0     1550 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/DevMagnitude/__init__.py
+-rw-rw-rw-   0        0        0     1999 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/IqAbs.py
+-rw-rw-rw-   0        0        0     2038 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/IqDifference.py
+-rw-rw-rw-   0        0        0     2009 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/IqError.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.512224 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/Pdifference/
+-rw-rw-rw-   0        0        0     1772 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/Pdifference/Average.py
+-rw-rw-rw-   0        0        0     1772 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/Pdifference/Current.py
+-rw-rw-rw-   0        0        0     1772 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/Pdifference/Maximum.py
+-rw-rw-rw-   0        0        0     1545 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/Pdifference/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.522220 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/PowerVsTime/
+-rw-rw-rw-   0        0        0     1738 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/PowerVsTime/Average.py
+-rw-rw-rw-   0        0        0     1738 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/PowerVsTime/Current.py
+-rw-rw-rw-   0        0        0     1738 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/PowerVsTime/Maximum.py
+-rw-rw-rw-   0        0        0     1738 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/PowerVsTime/Minimum.py
+-rw-rw-rw-   0        0        0     1789 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/PowerVsTime/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.532216 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/Sgacp/
+-rw-rw-rw-   0        0        0     1726 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/Sgacp/Average.py
+-rw-rw-rw-   0        0        0     1726 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/Sgacp/Current.py
+-rw-rw-rw-   0        0        0     1726 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/Sgacp/Maximum.py
+-rw-rw-rw-   0        0        0     1694 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/Sgacp/Ptx.py
+-rw-rw-rw-   0        0        0     1727 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/Sgacp/__init__.py
+-rw-rw-rw-   0        0        0     2602 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/__init__.py
+-rw-rw-rw-   0        0        0     4850 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.532216 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.542209 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/InputSignal/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.542209 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/InputSignal/Adetected/
+-rw-rw-rw-   0        0        0     1273 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/InputSignal/Adetected/Pcoding.py
+-rw-rw-rw-   0        0        0     1158 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/InputSignal/Adetected/Plength.py
+-rw-rw-rw-   0        0        0     1291 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/InputSignal/Adetected/__init__.py
+-rw-rw-rw-   0        0        0     1071 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/InputSignal/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.562198 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Modulation/
+-rw-rw-rw-   0        0        0     6134 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Modulation/Average.py
+-rw-rw-rw-   0        0        0     6551 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Modulation/Current.py
+-rw-rw-rw-   0        0        0     4822 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Modulation/Maximum.py
+-rw-rw-rw-   0        0        0     6182 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Modulation/StandardDev.py
+-rw-rw-rw-   0        0        0     1815 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Modulation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.572193 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/PowerVsTime/
+-rw-rw-rw-   0        0        0     3139 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/PowerVsTime/Average.py
+-rw-rw-rw-   0        0        0     3139 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/PowerVsTime/Current.py
+-rw-rw-rw-   0        0        0     3139 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/PowerVsTime/Maximum.py
+-rw-rw-rw-   0        0        0     3139 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/PowerVsTime/Minimum.py
+-rw-rw-rw-   0        0        0     1788 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/PowerVsTime/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.572193 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Sacp/
+-rw-rw-rw-   0        0        0     3287 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Sacp/Current.py
+-rw-rw-rw-   0        0        0     1020 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Sacp/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.582188 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/State/
+-rw-rw-rw-   0        0        0     2448 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/State/All.py
+-rw-rw-rw-   0        0        0     2326 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/State/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.592182 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.597264 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/EvMagnitude/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.608517 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/EvMagnitude/Absolute/
+-rw-rw-rw-   0        0        0     1810 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/EvMagnitude/Absolute/Average.py
+-rw-rw-rw-   0        0        0     1810 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/EvMagnitude/Absolute/Current.py
+-rw-rw-rw-   0        0        0     1810 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/EvMagnitude/Absolute/Maximum.py
+-rw-rw-rw-   0        0        0     1532 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/EvMagnitude/Absolute/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.621543 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/EvMagnitude/Offset/
+-rw-rw-rw-   0        0        0     1798 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/EvMagnitude/Offset/Average.py
+-rw-rw-rw-   0        0        0     1798 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/EvMagnitude/Offset/Current.py
+-rw-rw-rw-   0        0        0     1798 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/EvMagnitude/Offset/Maximum.py
+-rw-rw-rw-   0        0        0     1522 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/EvMagnitude/Offset/__init__.py
+-rw-rw-rw-   0        0        0     1302 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/EvMagnitude/__init__.py
+-rw-rw-rw-   0        0        0     2005 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/IqAbs.py
+-rw-rw-rw-   0        0        0     2032 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/IqOffset.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.634597 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/PowerVsTime/
+-rw-rw-rw-   0        0        0     1744 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/PowerVsTime/Average.py
+-rw-rw-rw-   0        0        0     1744 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/PowerVsTime/Current.py
+-rw-rw-rw-   0        0        0     1744 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/PowerVsTime/Maximum.py
+-rw-rw-rw-   0        0        0     1744 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/PowerVsTime/Minimum.py
+-rw-rw-rw-   0        0        0     1789 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/PowerVsTime/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.646403 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/Sacp/
+-rw-rw-rw-   0        0        0     1724 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/Sacp/Average.py
+-rw-rw-rw-   0        0        0     1724 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/Sacp/Current.py
+-rw-rw-rw-   0        0        0     1724 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/Sacp/Maximum.py
+-rw-rw-rw-   0        0        0     1692 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/Sacp/Ptx.py
+-rw-rw-rw-   0        0        0     1722 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/Sacp/__init__.py
+-rw-rw-rw-   0        0        0     2034 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/__init__.py
+-rw-rw-rw-   0        0        0     4605 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.649395 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.651388 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.654380 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Aaddress/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.658372 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Aaddress/LowEnergy/
+-rw-rw-rw-   0        0        0     1353 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Aaddress/LowEnergy/Le1M.py
+-rw-rw-rw-   0        0        0     1025 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Aaddress/LowEnergy/__init__.py
+-rw-rw-rw-   0        0        0     1058 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Aaddress/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.660364 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Coding/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.665351 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Coding/LowEnergy/
+-rw-rw-rw-   0        0        0     1351 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Coding/LowEnergy/Lrange.py
+-rw-rw-rw-   0        0        0     1041 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Coding/LowEnergy/__init__.py
+-rw-rw-rw-   0        0        0     1048 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Coding/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.665965 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.665965 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/LowEnergy/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.675962 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/LowEnergy/Le1M/
+-rw-rw-rw-   0        0        0     1721 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/LowEnergy/Le1M/TypePy.py
+-rw-rw-rw-   0        0        0     1434 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/LowEnergy/Le1M/Units.py
+-rw-rw-rw-   0        0        0     1246 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/LowEnergy/Le1M/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.685956 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/LowEnergy/Le2M/
+-rw-rw-rw-   0        0        0     1721 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/LowEnergy/Le2M/TypePy.py
+-rw-rw-rw-   0        0        0     1434 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/LowEnergy/Le2M/Units.py
+-rw-rw-rw-   0        0        0     1246 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/LowEnergy/Le2M/__init__.py
+-rw-rw-rw-   0        0        0     1245 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/LowEnergy/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.685956 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.695950 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P2Q/
+-rw-rw-rw-   0        0        0     1296 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P2Q/TypePy.py
+-rw-rw-rw-   0        0        0     1180 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P2Q/Units.py
+-rw-rw-rw-   0        0        0     1241 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P2Q/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.695950 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P3Q/
+-rw-rw-rw-   0        0        0     1296 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P3Q/TypePy.py
+-rw-rw-rw-   0        0        0     1180 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P3Q/Units.py
+-rw-rw-rw-   0        0        0     1241 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P3Q/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.705945 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P4Q/
+-rw-rw-rw-   0        0        0     1296 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P4Q/TypePy.py
+-rw-rw-rw-   0        0        0     1180 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P4Q/Units.py
+-rw-rw-rw-   0        0        0     1241 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P4Q/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.715939 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P5Q/
+-rw-rw-rw-   0        0        0     1296 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P5Q/TypePy.py
+-rw-rw-rw-   0        0        0     1180 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P5Q/Units.py
+-rw-rw-rw-   0        0        0     1241 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P5Q/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.725934 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P6Q/
+-rw-rw-rw-   0        0        0     1296 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P6Q/TypePy.py
+-rw-rw-rw-   0        0        0     1180 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P6Q/Units.py
+-rw-rw-rw-   0        0        0     1241 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P6Q/__init__.py
+-rw-rw-rw-   0        0        0     1841 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/__init__.py
+-rw-rw-rw-   0        0        0     1254 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.732440 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/NoSlots/
+-rw-rw-rw-   0        0        0     1311 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/NoSlots/Brate.py
+-rw-rw-rw-   0        0        0     1318 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/NoSlots/Edrate.py
+-rw-rw-rw-   0        0        0     1257 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/NoSlots/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.732440 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Pattern/
+-rw-rw-rw-   0        0        0     1576 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Pattern/Brate.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.742439 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Pattern/LowEnergy/
+-rw-rw-rw-   0        0        0     1684 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Pattern/LowEnergy/Le1M.py
+-rw-rw-rw-   0        0        0     1682 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Pattern/LowEnergy/Le2M.py
+-rw-rw-rw-   0        0        0     1635 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Pattern/LowEnergy/Lrange.py
+-rw-rw-rw-   0        0        0     1481 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Pattern/LowEnergy/__init__.py
+-rw-rw-rw-   0        0        0     1281 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Pattern/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.742439 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/PduType/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.752434 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/PduType/LowEnergy/
+-rw-rw-rw-   0        0        0     1677 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/PduType/LowEnergy/Le1M.py
+-rw-rw-rw-   0        0        0     1025 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/PduType/LowEnergy/__init__.py
+-rw-rw-rw-   0        0        0     1053 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/PduType/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.762429 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/
+-rw-rw-rw-   0        0        0     1323 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/Brate.py
+-rw-rw-rw-   0        0        0     1331 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/Edrate.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.772423 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/LowEnergy/
+-rw-rw-rw-   0        0        0     1461 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/LowEnergy/Le1M.py
+-rw-rw-rw-   0        0        0     1459 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/LowEnergy/Le2M.py
+-rw-rw-rw-   0        0        0     1471 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/LowEnergy/Lrange.py
+-rw-rw-rw-   0        0        0     1481 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/LowEnergy/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.782417 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/Qhsl/
+-rw-rw-rw-   0        0        0     1163 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/Qhsl/P2Q.py
+-rw-rw-rw-   0        0        0     1163 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/Qhsl/P3Q.py
+-rw-rw-rw-   0        0        0     1163 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/Qhsl/P4Q.py
+-rw-rw-rw-   0        0        0     1163 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/Qhsl/P5Q.py
+-rw-rw-rw-   0        0        0     1163 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/Qhsl/P6Q.py
+-rw-rw-rw-   0        0        0     1840 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/Qhsl/__init__.py
+-rw-rw-rw-   0        0        0     1738 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.792412 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Ptype/
+-rw-rw-rw-   0        0        0     1399 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Ptype/Brate.py
+-rw-rw-rw-   0        0        0     1485 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Ptype/Edrate.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.806820 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Ptype/LowEnergy/
+-rw-rw-rw-   0        0        0     1602 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Ptype/LowEnergy/Le1M.py
+-rw-rw-rw-   0        0        0     1589 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Ptype/LowEnergy/Le2M.py
+-rw-rw-rw-   0        0        0     1565 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Ptype/LowEnergy/Lrange.py
+-rw-rw-rw-   0        0        0     1481 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Ptype/LowEnergy/__init__.py
+-rw-rw-rw-   0        0        0     1507 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Ptype/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.814148 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Qhsl/
+-rw-rw-rw-   0        0        0     1279 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Qhsl/Phy.py
+-rw-rw-rw-   0        0        0      990 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Qhsl/__init__.py
+-rw-rw-rw-   0        0        0     2926 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/__init__.py
+-rw-rw-rw-   0        0        0     1070 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.817139 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.820147 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Frange/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.820147 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Frange/Brate/
+-rw-rw-rw-   0        0        0     6614 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Frange/Brate/Current.py
+-rw-rw-rw-   0        0        0     1027 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Frange/Brate/__init__.py
+-rw-rw-rw-   0        0        0     1014 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Frange/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.828712 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.832274 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.832274 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.844469 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Average/
+-rw-rw-rw-   0        0        0     6056 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Average/Extended.py
+-rw-rw-rw-   0        0        0     5931 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Average/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.849455 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Current/
+-rw-rw-rw-   0        0        0     6776 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Current/Extended.py
+-rw-rw-rw-   0        0        0     6354 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Current/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.855438 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Maximum/
+-rw-rw-rw-   0        0        0     5941 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Maximum/Extended.py
+-rw-rw-rw-   0        0        0     5931 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Maximum/__init__.py
+-rw-rw-rw-   0        0        0     3666 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Minimum.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.862283 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/StandardDev/
+-rw-rw-rw-   0        0        0     5894 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/StandardDev/Extended.py
+-rw-rw-rw-   0        0        0     5559 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/StandardDev/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.867268 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Xmaximum/
+-rw-rw-rw-   0        0        0     4395 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Xmaximum/Extended.py
+-rw-rw-rw-   0        0        0     4298 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Xmaximum/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.872255 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Xminimum/
+-rw-rw-rw-   0        0        0     4395 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Xminimum/Extended.py
+-rw-rw-rw-   0        0        0     4298 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Xminimum/__init__.py
+-rw-rw-rw-   0        0        0     2567 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/__init__.py
+-rw-rw-rw-   0        0        0     2276 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Pencoding.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.879274 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/PowerVsTime/
+-rw-rw-rw-   0        0        0     4003 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/PowerVsTime/Average.py
+-rw-rw-rw-   0        0        0     4003 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/PowerVsTime/Current.py
+-rw-rw-rw-   0        0        0     4003 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/PowerVsTime/Maximum.py
+-rw-rw-rw-   0        0        0     4003 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/PowerVsTime/Minimum.py
+-rw-rw-rw-   0        0        0     1791 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/PowerVsTime/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.889269 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Sacp/
+-rw-rw-rw-   0        0        0     3734 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Sacp/Ptx.py
+-rw-rw-rw-   0        0        0      992 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Sacp/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.889269 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/SoBw/
+-rw-rw-rw-   0        0        0     3224 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/SoBw/Maximum.py
+-rw-rw-rw-   0        0        0     1024 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/SoBw/__init__.py
+-rw-rw-rw-   0        0        0     2883 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/__init__.py
+-rw-rw-rw-   0        0        0     1031 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.889269 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.919253 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Brate/
+-rw-rw-rw-   0        0        0     8212 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Brate/Average.py
+-rw-rw-rw-   0        0        0     8212 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Brate/Current.py
+-rw-rw-rw-   0        0        0     8212 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Brate/Maximum.py
+-rw-rw-rw-   0        0        0     7010 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Brate/Minimum.py
+-rw-rw-rw-   0        0        0     6248 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Brate/StandardDev.py
+-rw-rw-rw-   0        0        0     8224 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Brate/Xmaximum.py
+-rw-rw-rw-   0        0        0     8224 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Brate/Xminimum.py
+-rw-rw-rw-   0        0        0     1456 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Brate/YieldPy.py
+-rw-rw-rw-   0        0        0     2784 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Brate/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.919253 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.919253 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.949237 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le1M/
+-rw-rw-rw-   0        0        0     5669 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le1M/Average.py
+-rw-rw-rw-   0        0        0     5669 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le1M/Current.py
+-rw-rw-rw-   0        0        0     5669 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le1M/Maximum.py
+-rw-rw-rw-   0        0        0     5711 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le1M/StandardDev.py
+-rw-rw-rw-   0        0        0     5681 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le1M/Xmaximum.py
+-rw-rw-rw-   0        0        0     5681 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le1M/Xminimum.py
+-rw-rw-rw-   0        0        0     2295 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le1M/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.969226 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le2M/
+-rw-rw-rw-   0        0        0     5669 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le2M/Average.py
+-rw-rw-rw-   0        0        0     5669 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le2M/Current.py
+-rw-rw-rw-   0        0        0     5669 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le2M/Maximum.py
+-rw-rw-rw-   0        0        0     5711 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le2M/StandardDev.py
+-rw-rw-rw-   0        0        0     5681 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le2M/Xmaximum.py
+-rw-rw-rw-   0        0        0     5681 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le2M/Xminimum.py
+-rw-rw-rw-   0        0        0     2295 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le2M/__init__.py
+-rw-rw-rw-   0        0        0     1246 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/__init__.py
+-rw-rw-rw-   0        0        0     1034 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.979221 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Edrate/
+-rw-rw-rw-   0        0        0     6280 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Edrate/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.989217 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Edrate/Current/
+-rw-rw-rw-   0        0        0     2996 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Edrate/Current/Extended.py
+-rw-rw-rw-   0        0        0     6933 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Edrate/Current/__init__.py
+-rw-rw-rw-   0        0        0     6280 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Edrate/Maximum.py
+-rw-rw-rw-   0        0        0     6638 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Edrate/StandardDev.py
+-rw-rw-rw-   0        0        0     1797 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Edrate/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:51.989217 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.013280 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le1M/
+-rw-rw-rw-   0        0        0     9233 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le1M/Average.py
+-rw-rw-rw-   0        0        0     9233 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le1M/Current.py
+-rw-rw-rw-   0        0        0     9233 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le1M/Maximum.py
+-rw-rw-rw-   0        0        0     7395 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le1M/Minimum.py
+-rw-rw-rw-   0        0        0     7325 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le1M/StandardDev.py
+-rw-rw-rw-   0        0        0     9245 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le1M/Xmaximum.py
+-rw-rw-rw-   0        0        0     9245 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le1M/Xminimum.py
+-rw-rw-rw-   0        0        0     1572 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le1M/YieldPy.py
+-rw-rw-rw-   0        0        0     2781 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le1M/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.039188 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le2M/
+-rw-rw-rw-   0        0        0     9227 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le2M/Average.py
+-rw-rw-rw-   0        0        0     9227 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le2M/Current.py
+-rw-rw-rw-   0        0        0     9227 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le2M/Maximum.py
+-rw-rw-rw-   0        0        0     7389 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le2M/Minimum.py
+-rw-rw-rw-   0        0        0     7319 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le2M/StandardDev.py
+-rw-rw-rw-   0        0        0     9239 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le2M/Xmaximum.py
+-rw-rw-rw-   0        0        0     9239 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le2M/Xminimum.py
+-rw-rw-rw-   0        0        0     1570 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le2M/YieldPy.py
+-rw-rw-rw-   0        0        0     2781 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le2M/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.065502 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Lrange/
+-rw-rw-rw-   0        0        0     7298 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Lrange/Average.py
+-rw-rw-rw-   0        0        0     7298 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Lrange/Current.py
+-rw-rw-rw-   0        0        0     7298 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Lrange/Maximum.py
+-rw-rw-rw-   0        0        0     5829 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Lrange/Minimum.py
+-rw-rw-rw-   0        0        0     4629 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Lrange/StDev.py
+-rw-rw-rw-   0        0        0     6284 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Lrange/StandardDev.py
+-rw-rw-rw-   0        0        0     7310 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Lrange/Xmaximum.py
+-rw-rw-rw-   0        0        0     7310 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Lrange/Xminimum.py
+-rw-rw-rw-   0        0        0     2775 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Lrange/__init__.py
+-rw-rw-rw-   0        0        0     1480 2024-04-17 08:45:44.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.067497 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.089493 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/Classic/
+-rw-rw-rw-   0        0        0     7128 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/Classic/Average.py
+-rw-rw-rw-   0        0        0     7128 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/Classic/Current.py
+-rw-rw-rw-   0        0        0     7128 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/Classic/Maximum.py
+-rw-rw-rw-   0        0        0     4788 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/Classic/Minimum.py
+-rw-rw-rw-   0        0        0     5253 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/Classic/StandardDev.py
+-rw-rw-rw-   0        0        0     7155 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/Classic/Xmaximum.py
+-rw-rw-rw-   0        0        0     7140 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/Classic/Xminimum.py
+-rw-rw-rw-   0        0        0     2552 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/Classic/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.089493 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.109482 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le1M/
+-rw-rw-rw-   0        0        0     7506 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le1M/Average.py
+-rw-rw-rw-   0        0        0     7506 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le1M/Current.py
+-rw-rw-rw-   0        0        0     9643 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le1M/Maximum.py
+-rw-rw-rw-   0        0        0     7653 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le1M/Minimum.py
+-rw-rw-rw-   0        0        0     5317 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le1M/StandardDev.py
+-rw-rw-rw-   0        0        0     7533 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le1M/Xmaximum.py
+-rw-rw-rw-   0        0        0     7518 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le1M/Xminimum.py
+-rw-rw-rw-   0        0        0     2539 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le1M/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.129472 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le2M/
+-rw-rw-rw-   0        0        0     8594 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le2M/Average.py
+-rw-rw-rw-   0        0        0     8594 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le2M/Current.py
+-rw-rw-rw-   0        0        0     8594 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le2M/Maximum.py
+-rw-rw-rw-   0        0        0     7046 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le2M/Minimum.py
+-rw-rw-rw-   0        0        0     6883 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le2M/StandardDev.py
+-rw-rw-rw-   0        0        0     8606 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le2M/Xmaximum.py
+-rw-rw-rw-   0        0        0     8606 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le2M/Xminimum.py
+-rw-rw-rw-   0        0        0     1213 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le2M/YieldPy.py
+-rw-rw-rw-   0        0        0     2783 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le2M/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.149462 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Lrange/
+-rw-rw-rw-   0        0        0     6991 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Lrange/Average.py
+-rw-rw-rw-   0        0        0     6991 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Lrange/Current.py
+-rw-rw-rw-   0        0        0     6991 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Lrange/Maximum.py
+-rw-rw-rw-   0        0        0     5845 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Lrange/Minimum.py
+-rw-rw-rw-   0        0        0     4687 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Lrange/StDev.py
+-rw-rw-rw-   0        0        0     6278 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Lrange/StandardDev.py
+-rw-rw-rw-   0        0        0     7003 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Lrange/Xmaximum.py
+-rw-rw-rw-   0        0        0     7003 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Lrange/Xminimum.py
+-rw-rw-rw-   0        0        0     2777 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Lrange/__init__.py
+-rw-rw-rw-   0        0        0     1482 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/__init__.py
+-rw-rw-rw-   0        0        0     1288 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.149462 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.169451 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P2Q/
+-rw-rw-rw-   0        0        0     4859 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P2Q/Average.py
+-rw-rw-rw-   0        0        0     4859 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P2Q/Current.py
+-rw-rw-rw-   0        0        0     4859 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P2Q/Maximum.py
+-rw-rw-rw-   0        0        0     4901 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P2Q/StandardDev.py
+-rw-rw-rw-   0        0        0     1784 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P2Q/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.179446 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P3Q/
+-rw-rw-rw-   0        0        0     4859 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P3Q/Average.py
+-rw-rw-rw-   0        0        0     4859 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P3Q/Current.py
+-rw-rw-rw-   0        0        0     4859 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P3Q/Maximum.py
+-rw-rw-rw-   0        0        0     4901 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P3Q/StandardDev.py
+-rw-rw-rw-   0        0        0     1784 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P3Q/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.199436 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P4Q/
+-rw-rw-rw-   0        0        0     4859 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P4Q/Average.py
+-rw-rw-rw-   0        0        0     4859 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P4Q/Current.py
+-rw-rw-rw-   0        0        0     4859 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P4Q/Maximum.py
+-rw-rw-rw-   0        0        0     4901 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P4Q/StandardDev.py
+-rw-rw-rw-   0        0        0     1784 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P4Q/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.209430 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P5Q/
+-rw-rw-rw-   0        0        0     4859 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P5Q/Average.py
+-rw-rw-rw-   0        0        0     4859 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P5Q/Current.py
+-rw-rw-rw-   0        0        0     4859 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P5Q/Maximum.py
+-rw-rw-rw-   0        0        0     4901 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P5Q/StandardDev.py
+-rw-rw-rw-   0        0        0     1784 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P5Q/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.219424 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P6Q/
+-rw-rw-rw-   0        0        0     4859 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P6Q/Average.py
+-rw-rw-rw-   0        0        0     4859 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P6Q/Current.py
+-rw-rw-rw-   0        0        0     4859 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P6Q/Maximum.py
+-rw-rw-rw-   0        0        0     4901 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P6Q/StandardDev.py
+-rw-rw-rw-   0        0        0     1784 2024-04-17 08:45:43.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/P6Q/__init__.py
+-rw-rw-rw-   0        0        0     1839 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Qhsl/__init__.py
+-rw-rw-rw-   0        0        0     2192 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.229421 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Pencoding/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.235407 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Pencoding/Edrate/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.239376 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Pencoding/Edrate/Current/
+-rw-rw-rw-   0        0        0     2181 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Pencoding/Edrate/Current/C.py
+-rw-rw-rw-   0        0        0     5789 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Pencoding/Edrate/Current/__init__.py
+-rw-rw-rw-   0        0        0     1032 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Pencoding/Edrate/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.245784 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Pencoding/Ssequence/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.250771 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Pencoding/Ssequence/Edrate/
+-rw-rw-rw-   0        0        0     4454 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Pencoding/Ssequence/Edrate/Current.py
+-rw-rw-rw-   0        0        0     1034 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Pencoding/Ssequence/Edrate/__init__.py
+-rw-rw-rw-   0        0        0     1039 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Pencoding/Ssequence/__init__.py
+-rw-rw-rw-   0        0        0     1297 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Pencoding/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.253764 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.262163 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Brate/
+-rw-rw-rw-   0        0        0     7788 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Brate/Average.py
+-rw-rw-rw-   0        0        0     7788 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Brate/Current.py
+-rw-rw-rw-   0        0        0     7788 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Brate/Maximum.py
+-rw-rw-rw-   0        0        0     7840 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Brate/Minimum.py
+-rw-rw-rw-   0        0        0     1760 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Brate/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.283137 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Edrate/
+-rw-rw-rw-   0        0        0     9112 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Edrate/Average.py
+-rw-rw-rw-   0        0        0     9112 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Edrate/Current.py
+-rw-rw-rw-   0        0        0     9164 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Edrate/Maximum.py
+-rw-rw-rw-   0        0        0     9164 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Edrate/Minimum.py
+-rw-rw-rw-   0        0        0     1765 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Edrate/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.286129 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.298974 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le1M/
+-rw-rw-rw-   0        0        0     7280 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le1M/Average.py
+-rw-rw-rw-   0        0        0     7280 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le1M/Current.py
+-rw-rw-rw-   0        0        0     7280 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le1M/Maximum.py
+-rw-rw-rw-   0        0        0     7280 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le1M/Minimum.py
+-rw-rw-rw-   0        0        0     1757 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le1M/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.311939 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le2M/
+-rw-rw-rw-   0        0        0     7652 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le2M/Average.py
+-rw-rw-rw-   0        0        0     7652 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le2M/Current.py
+-rw-rw-rw-   0        0        0     7652 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le2M/Maximum.py
+-rw-rw-rw-   0        0        0     7652 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le2M/Minimum.py
+-rw-rw-rw-   0        0        0     1757 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le2M/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.322967 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Lrange/
+-rw-rw-rw-   0        0        0     7670 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Lrange/Average.py
+-rw-rw-rw-   0        0        0     7670 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Lrange/Current.py
+-rw-rw-rw-   0        0        0     7670 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Lrange/Maximum.py
+-rw-rw-rw-   0        0        0     7670 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Lrange/Minimum.py
+-rw-rw-rw-   0        0        0     1767 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Lrange/__init__.py
+-rw-rw-rw-   0        0        0     1480 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.322967 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.339470 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/Classic/
+-rw-rw-rw-   0        0        0     5808 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/Classic/Average.py
+-rw-rw-rw-   0        0        0     5808 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/Classic/Current.py
+-rw-rw-rw-   0        0        0     5808 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/Classic/Maximum.py
+-rw-rw-rw-   0        0        0     5808 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/Classic/Minimum.py
+-rw-rw-rw-   0        0        0     1772 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/Classic/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.339470 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.349470 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le1M/
+-rw-rw-rw-   0        0        0     7740 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le1M/Average.py
+-rw-rw-rw-   0        0        0     7740 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le1M/Current.py
+-rw-rw-rw-   0        0        0     7740 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le1M/Maximum.py
+-rw-rw-rw-   0        0        0     7740 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le1M/Minimum.py
+-rw-rw-rw-   0        0        0     1759 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le1M/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.369458 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le2M/
+-rw-rw-rw-   0        0        0     7734 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le2M/Average.py
+-rw-rw-rw-   0        0        0     7734 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le2M/Current.py
+-rw-rw-rw-   0        0        0     7734 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le2M/Maximum.py
+-rw-rw-rw-   0        0        0     7734 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le2M/Minimum.py
+-rw-rw-rw-   0        0        0     1759 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le2M/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.379452 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Lrange/
+-rw-rw-rw-   0        0        0     7752 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Lrange/Average.py
+-rw-rw-rw-   0        0        0     7752 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Lrange/Current.py
+-rw-rw-rw-   0        0        0     7752 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Lrange/Maximum.py
+-rw-rw-rw-   0        0        0     7752 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Lrange/Minimum.py
+-rw-rw-rw-   0        0        0     1769 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Lrange/__init__.py
+-rw-rw-rw-   0        0        0     1482 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/__init__.py
+-rw-rw-rw-   0        0        0     1288 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.379452 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.399443 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P2Q/
+-rw-rw-rw-   0        0        0     5045 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P2Q/Average.py
+-rw-rw-rw-   0        0        0     5045 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P2Q/Current.py
+-rw-rw-rw-   0        0        0     5045 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P2Q/Maximum.py
+-rw-rw-rw-   0        0        0     5045 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P2Q/Minimum.py
+-rw-rw-rw-   0        0        0     1752 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P2Q/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.409436 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P3Q/
+-rw-rw-rw-   0        0        0     5045 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P3Q/Average.py
+-rw-rw-rw-   0        0        0     5045 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P3Q/Current.py
+-rw-rw-rw-   0        0        0     5045 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P3Q/Maximum.py
+-rw-rw-rw-   0        0        0     5045 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P3Q/Minimum.py
+-rw-rw-rw-   0        0        0     1752 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P3Q/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.419432 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P4Q/
+-rw-rw-rw-   0        0        0     5045 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P4Q/Average.py
+-rw-rw-rw-   0        0        0     5045 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P4Q/Current.py
+-rw-rw-rw-   0        0        0     5045 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P4Q/Maximum.py
+-rw-rw-rw-   0        0        0     5045 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P4Q/Minimum.py
+-rw-rw-rw-   0        0        0     1752 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P4Q/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.429426 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P5Q/
+-rw-rw-rw-   0        0        0     5045 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P5Q/Average.py
+-rw-rw-rw-   0        0        0     5045 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P5Q/Current.py
+-rw-rw-rw-   0        0        0     5045 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P5Q/Maximum.py
+-rw-rw-rw-   0        0        0     5045 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P5Q/Minimum.py
+-rw-rw-rw-   0        0        0     1752 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P5Q/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.451953 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P6Q/
+-rw-rw-rw-   0        0        0     5045 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P6Q/Average.py
+-rw-rw-rw-   0        0        0     5045 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P6Q/Current.py
+-rw-rw-rw-   0        0        0     5045 2024-04-17 08:45:42.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P6Q/Maximum.py
+-rw-rw-rw-   0        0        0     5045 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P6Q/Minimum.py
+-rw-rw-rw-   0        0        0     1752 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P6Q/__init__.py
+-rw-rw-rw-   0        0        0     1839 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/__init__.py
+-rw-rw-rw-   0        0        0     1985 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.454946 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.458964 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Brate/
+-rw-rw-rw-   0        0        0     6525 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Brate/Ptx.py
+-rw-rw-rw-   0        0        0      995 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Brate/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.472742 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/LowEnergy/
+-rw-rw-rw-   0        0        0     4039 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/LowEnergy/Le1M.py
+-rw-rw-rw-   0        0        0     4198 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/LowEnergy/Le2M.py
+-rw-rw-rw-   0        0        0     4222 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/LowEnergy/Lrange.py
+-rw-rw-rw-   0        0        0     1479 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/LowEnergy/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.472742 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Nmode/
+-rw-rw-rw-   0        0        0     5301 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Nmode/Classic.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.478993 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Nmode/LowEnergy/
+-rw-rw-rw-   0        0        0     4505 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Nmode/LowEnergy/Le1M.py
+-rw-rw-rw-   0        0        0     4499 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Nmode/LowEnergy/Le2M.py
+-rw-rw-rw-   0        0        0     4523 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Nmode/LowEnergy/Lrange.py
+-rw-rw-rw-   0        0        0     1481 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Nmode/LowEnergy/__init__.py
+-rw-rw-rw-   0        0        0     1288 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Nmode/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.502029 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Qhsl/
+-rw-rw-rw-   0        0        0     3073 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Qhsl/P2Q.py
+-rw-rw-rw-   0        0        0     3073 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Qhsl/P3Q.py
+-rw-rw-rw-   0        0        0     3073 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Qhsl/P4Q.py
+-rw-rw-rw-   0        0        0     3073 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Qhsl/P5Q.py
+-rw-rw-rw-   0        0        0     3073 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Qhsl/P6Q.py
+-rw-rw-rw-   0        0        0     1839 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Qhsl/__init__.py
+-rw-rw-rw-   0        0        0     1713 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.504023 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sgacp/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.509009 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sgacp/Edrate/
+-rw-rw-rw-   0        0        0     6432 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sgacp/Edrate/Ptx.py
+-rw-rw-rw-   0        0        0     1000 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sgacp/Edrate/__init__.py
+-rw-rw-rw-   0        0        0     1017 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sgacp/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.511003 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/SoBw/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.514777 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/SoBw/Brate/
+-rw-rw-rw-   0        0        0     7785 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/SoBw/Brate/Maximum.py
+-rw-rw-rw-   0        0        0     1027 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/SoBw/Brate/__init__.py
+-rw-rw-rw-   0        0        0     1004 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/SoBw/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.519764 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/State/
+-rw-rw-rw-   0        0        0     3420 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/State/All.py
+-rw-rw-rw-   0        0        0     2796 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/State/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.529774 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.539281 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/DevMagnitude/
+-rw-rw-rw-   0        0        0     2370 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/DevMagnitude/Average.py
+-rw-rw-rw-   0        0        0     2370 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/DevMagnitude/Current.py
+-rw-rw-rw-   0        0        0     2370 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/DevMagnitude/Maximum.py
+-rw-rw-rw-   0        0        0     1550 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/DevMagnitude/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.549280 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Fdeviation/
+-rw-rw-rw-   0        0        0     2586 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Fdeviation/Average.py
+-rw-rw-rw-   0        0        0     2586 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Fdeviation/Current.py
+-rw-rw-rw-   0        0        0     2586 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Fdeviation/Maximum.py
+-rw-rw-rw-   0        0        0     2586 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Fdeviation/Minimum.py
+-rw-rw-rw-   0        0        0     1784 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Fdeviation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.559274 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Frange/
+-rw-rw-rw-   0        0        0     2136 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Frange/Average.py
+-rw-rw-rw-   0        0        0     1032 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Frange/__init__.py
+-rw-rw-rw-   0        0        0     2760 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/IqAbs.py
+-rw-rw-rw-   0        0        0     2799 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/IqDifference.py
+-rw-rw-rw-   0        0        0     2770 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/IqError.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.559274 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Pdeviation/
+-rw-rw-rw-   0        0        0     3560 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Pdeviation/Maximum.py
+-rw-rw-rw-   0        0        0     3560 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Pdeviation/Minimum.py
+-rw-rw-rw-   0        0        0     1296 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Pdeviation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.569270 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Pdifference/
+-rw-rw-rw-   0        0        0     2598 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Pdifference/Average.py
+-rw-rw-rw-   0        0        0     2598 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Pdifference/Current.py
+-rw-rw-rw-   0        0        0     2598 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Pdifference/Maximum.py
+-rw-rw-rw-   0        0        0     1545 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Pdifference/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.589259 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/PowerVsTime/
+-rw-rw-rw-   0        0        0     2486 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/PowerVsTime/Average.py
+-rw-rw-rw-   0        0        0     2486 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/PowerVsTime/Current.py
+-rw-rw-rw-   0        0        0     2486 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/PowerVsTime/Maximum.py
+-rw-rw-rw-   0        0        0     2486 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/PowerVsTime/Minimum.py
+-rw-rw-rw-   0        0        0     1789 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/PowerVsTime/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.599253 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Sacp/
+-rw-rw-rw-   0        0        0     4670 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Sacp/Average.py
+-rw-rw-rw-   0        0        0     4670 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Sacp/Current.py
+-rw-rw-rw-   0        0        0     4670 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Sacp/Maximum.py
+-rw-rw-rw-   0        0        0     4718 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Sacp/Ptx.py
+-rw-rw-rw-   0        0        0     1722 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Sacp/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.609247 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Sgacp/
+-rw-rw-rw-   0        0        0     3088 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Sgacp/Average.py
+-rw-rw-rw-   0        0        0     3088 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Sgacp/Current.py
+-rw-rw-rw-   0        0        0     3088 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Sgacp/Maximum.py
+-rw-rw-rw-   0        0        0     3066 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Sgacp/Ptx.py
+-rw-rw-rw-   0        0        0     1727 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Sgacp/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.619242 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/SoBw/
+-rw-rw-rw-   0        0        0     2584 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/SoBw/Average.py
+-rw-rw-rw-   0        0        0     2584 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/SoBw/Current.py
+-rw-rw-rw-   0        0        0     2584 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/SoBw/Maximum.py
+-rw-rw-rw-   0        0        0     1510 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/SoBw/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.639233 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Spower/
+-rw-rw-rw-   0        0        0     2026 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Spower/Average.py
+-rw-rw-rw-   0        0        0     2026 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Spower/Current.py
+-rw-rw-rw-   0        0        0     2026 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Spower/Maximum.py
+-rw-rw-rw-   0        0        0     2026 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Spower/Minimum.py
+-rw-rw-rw-   0        0        0     1764 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Spower/__init__.py
+-rw-rw-rw-   0        0        0     4051 2024-04-17 08:45:45.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/__init__.py
+-rw-rw-rw-   0        0        0     6862 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.646038 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Route/
+-rw-rw-rw-   0        0        0     1419 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Route/RfSettings.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.654015 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Route/Scenario/
+-rw-rw-rw-   0        0        0     1267 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Route/Scenario/MaProtocol.py
+-rw-rw-rw-   0        0        0     2625 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Route/Scenario/Salone.py
+-rw-rw-rw-   0        0        0     3218 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Route/Scenario/__init__.py
+-rw-rw-rw-   0        0        0     2889 2024-04-17 08:45:41.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Route/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.662804 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.662804 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/Adetected/
+-rw-rw-rw-   0        0        0     1236 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/Adetected/Aaddress.py
+-rw-rw-rw-   0        0        0     1053 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/Adetected/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.672800 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/Per/
+-rw-rw-rw-   0        0        0     1214 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/Per/RxPackets.py
+-rw-rw-rw-   0        0        0     1776 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/Per/__init__.py
+-rw-rw-rw-   0        0        0     1259 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/Sensitivity.py
+-rw-rw-rw-   0        0        0     1313 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/SpotCheck.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.672800 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/State/
+-rw-rw-rw-   0        0        0     3413 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/State/All.py
+-rw-rw-rw-   0        0        0     2789 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/State/__init__.py
+-rw-rw-rw-   0        0        0     5679 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.679069 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Sense/
+-rw-rw-rw-   0        0        0     2799 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Sense/Elogging.py
+-rw-rw-rw-   0        0        0     1031 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Sense/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.679069 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trigger/
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.689063 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trigger/Hdr/
+-rw-rw-rw-   0        0        0      830 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trigger/Hdr/Catalog.py
+-rw-rw-rw-   0        0        0     3516 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trigger/Hdr/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.698208 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trigger/Hdrp/
+-rw-rw-rw-   0        0        0      833 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trigger/Hdrp/Catalog.py
+-rw-rw-rw-   0        0        0     3539 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trigger/Hdrp/__init__.py
+-rw-rw-rw-   0        0        0     3040 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trigger/MultiEval.py
+-rw-rw-rw-   0        0        0     1482 2024-04-17 08:45:37.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trigger/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.710176 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trx/
+-rw-rw-rw-   0        0        0     1768 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trx/Acp.py
+-rw-rw-rw-   0        0        0     3722 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trx/Modulation.py
+-rw-rw-rw-   0        0        0     2514 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trx/Power.py
+-rw-rw-rw-   0        0        0     1265 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trx/Spot.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.714953 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trx/State/
+-rw-rw-rw-   0        0        0     3395 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trx/State/All.py
+-rw-rw-rw-   0        0        0     2771 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trx/State/__init__.py
+-rw-rw-rw-   0        0        0     5496 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trx/__init__.py
+-rw-rw-rw-   0        0        0        0 2019-11-18 07:28:01.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:52.799423 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/
+-rw-rw-rw-   0        0        0      586 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ArgLinkedEventArgs.py
+-rw-rw-rw-   0        0        0     4165 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ArgSingle.py
+-rw-rw-rw-   0        0        0     1116 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ArgSingleList.py
+-rw-rw-rw-   0        0        0     1145 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ArgSingleSuppressed.py
+-rw-rw-rw-   0        0        0     9097 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ArgStringComposer.py
+-rw-rw-rw-   0        0        0     5751 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ArgStruct.py
+-rw-rw-rw-   0        0        0     3439 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ArgStructList.py
+-rw-rw-rw-   0        0        0     2546 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ArgStructStringParser.py
+-rw-rw-rw-   0        0        0     5238 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/CommandsGroup.py
+-rw-rw-rw-   0        0        0    25419 2024-04-03 11:15:31.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/Conversions.py
+-rw-rw-rw-   0        0        0     3775 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ConverterFromScpiString.py
+-rw-rw-rw-   0        0        0     4768 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ConverterToScpiString.py
+-rw-rw-rw-   0        0        0    14213 2024-04-03 11:15:31.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/Core.py
+-rw-rw-rw-   0        0        0     1386 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/GlobalData.py
+-rw-rw-rw-   0        0        0    60862 2024-04-03 11:15:31.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/Instrument.py
+-rw-rw-rw-   0        0        0     4785 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/InstrumentErrors.py
+-rw-rw-rw-   0        0        0     2225 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/InstrumentOptions.py
+-rw-rw-rw-   0        0        0    16156 2024-04-03 11:15:31.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/InstrumentSettings.py
+-rw-rw-rw-   0        0        0     3518 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/InternalLinker.py
+-rw-rw-rw-   0        0        0     4390 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/IoTransferEventArgs.py
+-rw-rw-rw-   0        0        0      387 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/Properties.py
+-rw-rw-rw-   0        0        0     4289 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/RepeatedCapability.py
+-rw-rw-rw-   0        0        0     4745 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ScpiEnums.py
+-rw-rw-rw-   0        0        0    35525 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ScpiLogger.py
+-rw-rw-rw-   0        0        0     5098 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/StreamReader.py
+-rw-rw-rw-   0        0        0     5856 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/StreamWriter.py
+-rw-rw-rw-   0        0        0     1114 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/StructBase.py
+-rw-rw-rw-   0        0        0     3608 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/Types.py
+-rw-rw-rw-   0        0        0     5498 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/Utilities.py
+-rw-rw-rw-   0        0        0     5716 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/VisaPluginSocketIo.py
+-rw-rw-rw-   0        0        0    51976 2024-04-03 11:15:31.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/VisaSession.py
+-rw-rw-rw-   0        0        0     7512 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/VisaSessionSim.py
+-rw-rw-rw-   0        0        0       29 2024-02-28 16:27:53.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/__init__.py
+-rw-rw-rw-   0        0        0    15412 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/RsCmwBluetoothMeas.py
+-rw-rw-rw-   0        0        0      978 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/__init__.py
+-rw-rw-rw-   0        0        0    12416 2024-04-17 08:45:36.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/enums.py
+-rw-rw-rw-   0        0        0     2023 2024-04-17 08:45:32.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/repcap.py
+drwxrwxrwx   0        0        0        0 2024-04-17 08:45:50.630784 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas.egg-info/
+-rw-rw-rw-   0        0        0     4471 2024-04-17 08:45:49.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0    60516 2024-04-17 08:45:50.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2024-04-17 08:45:49.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0       15 2024-04-17 08:45:49.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas.egg-info/requires.txt
+-rw-rw-rw-   0        0        0       19 2024-04-17 08:45:49.000000 RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas.egg-info/top_level.txt
+-rw-rw-rw-   0        0        0       42 2024-04-17 08:45:52.799423 RsCmwBluetoothMeas-4.0.110/setup.cfg
+-rw-rw-rw-   0        0        0     1498 2024-04-17 08:45:46.000000 RsCmwBluetoothMeas-4.0.110/setup.py
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/CustomFiles/events.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/CustomFiles/events.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,79 +1,89 @@
-from typing import Callable
-
-from ..Internal import Core
-
-
-class Events:
-	"""Common Events class.
-	Event-related methods common for all types of drivers."""
-	def __init__(self, core: Core):
-		self._core = core
-
-	@property
-	def io_events_include_data(self) -> bool:
-		"""Returns the current state of the io_events_include_data See the setter for more details."""
-		return self._core.io.io_events_include_data
-
-	@io_events_include_data.setter
-	def io_events_include_data(self, value: bool) -> None:
-		"""If True, the on_write and on_read events include also the sent/received data.
-		Default value is False, to avoid handling potentially big data."""
-		self._core.io.io_events_include_data = value
-
-	@property
-	def before_write_handler(self) -> Callable:
-		"""Returns the handler of before_write events. \n
-		:return: current before_write_handler"""
-		return self._core.io.before_write_handler
-
-	@before_write_handler.setter
-	def before_write_handler(self, handler: Callable) -> None:
-		"""Sets handler for before_write events.
-		The before_write event is invoked before each write operation (only once, not for every chunk)
-		Event prototype: handler(io: Instrument, cmd: str)
-		:param handler: new handler"""
-		self._core.io.before_write_handler = handler
-
-	@property
-	def on_write_handler(self) -> Callable:
-		"""Returns the handler of on_write events. \n
-		:return: current on_write_handler"""
-		return self._core.io.on_write_handler
-
-	@on_write_handler.setter
-	def on_write_handler(self, handler: Callable) -> None:
-		"""Sets handler for on_write events.
-		The on_write event is invoked every time the driver performs a write operation to the instrument (for each write chunk)
-		Event arguments type: IoTransferEventArgs
-		By default, the event_args do not contain the actual data sent. If you wish to receive them, set the driver.Events.io_events_include_data to True \n
-		:param handler: new handler for all write operations"""
-		self._core.io.on_write_handler = handler
-
-	@property
-	def on_read_handler(self) -> Callable:
-		"""Returns the handler of on_read events. \n
-		:return: current on_read_handler"""
-		return self._core.io.on_read_handler
-
-	@on_read_handler.setter
-	def on_read_handler(self, handler: Callable) -> None:
-		"""Sets handler for on_read events.
-		The on_read event is invoked every time the driver performs a read operation to the instrument.
-		Event arguments type: IoTransferEventArgs
-		By default, the event_args do not contain the actual data sent. If you wish to receive them, set the driver.Events.io_events_include_data to True \n
-		:param handler: new handler for all read operations"""
-		self._core.io.on_read_handler = handler
-
-	@property
-	def before_query_handler(self) -> Callable:
-		"""Returns the handler of before_query events. \n
-		:return: current before_query_handler"""
-		return self._core.io.before_query_handler
-
-	@before_query_handler.setter
-	def before_query_handler(self, handler: Callable) -> None:
-		"""Sets handler for before_query events.
-		The before_query event is invoked before each query operation (only once, not for every chunk)
-		Event prototype: handler(io: Instrument, query: str)
-		:param handler: new handler"""
-		self._core.io.before_query_handler = handler
+"""Event-related methods and properties. Here you can set all the event handlers."""
+
+from typing import Callable
+
+from ..Internal import Core
+
+
+class Events:
+	"""Common Events class.
+	Event-related methods and properties. Here you can set all the event handlers."""
+	def __init__(self, core: Core):
+		self._core = core
+
+	@property
+	def io_events_include_data(self) -> bool:
+		"""Returns the current state of the io_events_include_data See the setter for more details."""
+		return self._core.io.io_events_include_data
+
+	@io_events_include_data.setter
+	def io_events_include_data(self, value: bool) -> None:
+		"""If True, the on_write and on_read events include also the transferred data.
+		Default value is False, to avoid handling potentially big data."""
+		self._core.io.io_events_include_data = value
+
+	@property
+	def before_write_handler(self) -> Callable:
+		"""Returns the handler of before_write events. \n
+		:return: current ``before_write_handler``"""
+		return self._core.io.before_write_handler
+
+	@before_write_handler.setter
+	def before_write_handler(self, handler: Callable) -> None:
+		"""Sets handler for before_write events.
+		The before_write event is invoked before each write operation (only once, not for every chunk)
+		Event prototype: handler(io: Instrument, cmd: str)
+		:param handler: new handler"""
+		self._core.io.before_write_handler = handler
+
+	@property
+	def on_write_handler(self) -> Callable:
+		"""Returns the handler of on_write events. \n
+		:return: current ``on_write_handler``"""
+		return self._core.io.on_write_handler
+
+	@on_write_handler.setter
+	def on_write_handler(self, handler: Callable) -> None:
+		"""Sets handler for on_write events.
+		The on_write event is invoked every time the driver performs a write operation to the instrument (for each write chunk)
+		Event arguments type: IoTransferEventArgs
+		By default, the event_args do not contain the actual data sent. If you wish to receive them, set the driver.Events.io_events_include_data to True \n
+		:param handler: new handler for all write operations"""
+		self._core.io.on_write_handler = handler
+
+	@property
+	def on_read_handler(self) -> Callable:
+		"""Returns the handler of on_read events. \n
+		:return: current ``on_read_handler``"""
+		return self._core.io.on_read_handler
+
+	@on_read_handler.setter
+	def on_read_handler(self, handler: Callable) -> None:
+		"""Sets handler for on_read events.
+		The on_read event is invoked every time the driver performs a read operation to the instrument.
+		Event arguments type: IoTransferEventArgs
+		By default, the event_args do not contain the actual data sent. If you wish to receive them, set the driver.Events.io_events_include_data to True \n
+		:param handler: new handler for all read operations"""
+		self._core.io.on_read_handler = handler
+
+	@property
+	def before_query_handler(self) -> Callable:
+		"""Returns the handler of before_query events. \n
+		:return: current ``before_query_handler``"""
+		return self._core.io.before_query_handler
+
+	@before_query_handler.setter
+	def before_query_handler(self, handler: Callable) -> None:
+		"""Sets handler for before_query events.
+		The before_query event is invoked before each query operation (only once, not for every chunk)
+		Event prototype: handler(io: Instrument, query: str)
+		:param handler: new handler"""
+		self._core.io.before_query_handler = handler
+
+	def sync_from(self, source: 'Events') -> None:
+		"""Synchronises these Events with the source."""
+		self.before_query_handler = source.before_query_handler
+		self.before_write_handler = source.before_write_handler
+		self.io_events_include_data = source.io_events_include_data
+		self.on_read_handler = source.on_read_handler
+		self.on_write_handler = source.on_write_handler
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/CustomFiles/reliability.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/CustomFiles/reliability.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,7 +1,10 @@
+"""Class for R&S Mobile Radio Test instruments that use reliability indicators."""
+
+
 import time
 from typing import Callable
 
 from ..Internal import ArgLinkedEventArgs
 from ..Internal import Core
 
 codes_table = {
@@ -60,25 +63,25 @@
 		self.context = context
 
 
 class Reliability:
 	"""Reliability class that handles all the necessary tasks related to reliability indicator."""
 
 	def __init__(self, core: Core):
-		self._core = core
-		self._last_value = 0
-		self._last_context = ''
+		self._core: Core = core
+		self._last_value: int = 0
+		self._last_context: str = ''
 		self._last_timestamp = None
 		self._exception_on_error = False
 		# noinspection PyTypeChecker
 		self._on_update_handler: Callable = None
 		self._core.set_link_handler('Reliability', self._permanent_on_update_handler)
 
 	@property
-	def last_value(self):
+	def last_value(self) -> int:
 		"""Returns the last updated Reliability code."""
 		return self._last_value
 
 	@property
 	def last_context(self) -> str:
 		"""Returns the last updated Context of the reliability code - usually the SCPI query on which the instrument responded with the Reliability code."""
 		return self._last_context
@@ -94,36 +97,39 @@
 		if self._last_value in codes_table:
 			return codes_table[self._last_value]
 		else:
 			return f'Undefined reliability code {self._last_value}.'
 
 	@property
 	def exception_on_error(self) -> bool:
-		"""see the exception_on_error.setter."""
+		"""If True, (default is False) the object throws an exception if the updated reliability is not 0 (non-OK)."""
 		return self._exception_on_error
 
 	@exception_on_error.setter
 	def exception_on_error(self, value) -> None:
 		"""If True, (default is False) the object throws an exception if the updated reliability is not 0 (non-OK)."""
 		self._exception_on_error = value
 
 	def on_update_handler(self, handler: Callable) -> None:
 		"""Register the handler for on_update event.
 		This handler is invoked with each update of the reliability indicator.
 		Handler API: handler(event_args: ReliabilityEventArgs)"""
 		self._on_update_handler = handler
 
-	def _permanent_on_update_handler(self, event_args: ArgLinkedEventArgs):
+	def _permanent_on_update_handler(self, event_args: ArgLinkedEventArgs) -> None:
 		"""Permanent on_update handler. Takes care of updating all the 'last_xxx' values and calling a user-defined updated_handler."""
 		self._last_value = int(str(event_args.value))
 		self._last_context = event_args.context
 		self._last_timestamp = event_args.timestamp
-
 		if self._on_update_handler:
 			# Call the additional handler if registered
 			rel_events_args = ReliabilityEventArgs(self._last_timestamp, self._last_value, self.last_message, self._last_context)
 			self._on_update_handler(rel_events_args)
-
 		if self._exception_on_error and self._last_value != 0:
 			raise Exception(
 				f'Reliability indicator error. Time: {time.strftime("%H:%M:%S", time.localtime(self._last_timestamp))}, '
 				f'Context: {self._last_context}, Value {self._last_value}: {self.last_message}')
+
+	def sync_from(self, source: 'Reliability') -> None:
+		"""Synchronises this Reliability with the source."""
+		self.exception_on_error = source.exception_on_error
+		self.on_update_handler(source._on_update_handler)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Call.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Call/DtMode/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Call:
-	"""Call commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class DtModeCls:
+	"""DtMode commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("call", core, parent)
+		self._cmd_group = CommandsGroup("dtMode", core, parent)
 
 	@property
-	def dtMode(self):
-		"""dtMode commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_dtMode'):
-			from .Call_.DtMode import DtMode
-			self._dtMode = DtMode(self._core, self._base)
-		return self._dtMode
+	def lowEnergy(self):
+		"""lowEnergy commands group. 1 Sub-classes, 2 commands."""
+		if not hasattr(self, '_lowEnergy'):
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
+		return self._lowEnergy
 
-	def clone(self) -> 'Call':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'DtModeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Call(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = DtModeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Call_/DtMode.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Call/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DtMode:
-	"""DtMode commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class CallCls:
+	"""Call commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dtMode", core, parent)
+		self._cmd_group = CommandsGroup("call", core, parent)
 
 	@property
-	def lowEnergy(self):
-		"""lowEnergy commands group. 1 Sub-classes, 2 commands."""
-		if not hasattr(self, '_lowEnergy'):
-			from .DtMode_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
-		return self._lowEnergy
+	def dtMode(self):
+		"""dtMode commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_dtMode'):
+			from .DtMode import DtModeCls
+			self._dtMode = DtModeCls(self._core, self._cmd_group)
+		return self._dtMode
 
-	def clone(self) -> 'DtMode':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CallCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = DtMode(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CallCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Call_/DtMode_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trigger/MultiEval.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,56 +1,50 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
+from ...Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 3 total commands, 1 Sub-groups, 2 group commands"""
+class MultiEvalCls:
+	"""MultiEval commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("multiEval", core, parent)
 
-	@property
-	def rdevices(self):
-		"""rdevices commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_rdevices'):
-			from .LowEnergy_.Rdevices import Rdevices
-			self._rdevices = Rdevices(self._core, self._base)
-		return self._rdevices
-
-	# noinspection PyTypeChecker
-	def get_rresult(self) -> enums.Result:
-		"""SCPI: CALL:BLUetooth:MEASurement<Instance>:DTMode:LENergy:RRESult \n
-		Snippet: value: enums.Result = driver.call.dtMode.lowEnergy.get_rresult() \n
-		Returns the result of reset DUT command. Refer tomethod RsCmwBluetoothMeas.Call.DtMode.LowEnergy.reset. \n
-			:return: result: FAIL | PASS
+	def get_threshold(self) -> float or bool:
+		"""SCPI: TRIGger:BLUetooth:MEASurement<Instance>:MEValuation:THReshold \n
+		Snippet: value: float or bool = driver.trigger.multiEval.get_threshold() \n
+		Defines the trigger threshold for the power trigger. \n
+			:return: power: (float or boolean) numeric Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
 		"""
-		response = self._core.io.query_str('CALL:BLUetooth:MEASurement<Instance>:DTMode:LENergy:RRESult?')
-		return Conversions.str_to_scalar_enum(response, enums.Result)
+		response = self._core.io.query_str('TRIGger:BLUetooth:MEASurement<Instance>:MEValuation:THReshold?')
+		return Conversions.str_to_float_or_bool(response)
 
-	def reset(self) -> None:
-		"""SCPI: CALL:BLUetooth:MEASurement<Instance>:DTMode:LENergy:RESet \n
-		Snippet: driver.call.dtMode.lowEnergy.reset() \n
-		Sends the HCI reset command to the EUT via USB. Check the execution via method RsCmwBluetoothMeas.Call.DtMode.LowEnergy.
-		rresult. \n
+	def set_threshold(self, power: float or bool) -> None:
+		"""SCPI: TRIGger:BLUetooth:MEASurement<Instance>:MEValuation:THReshold \n
+		Snippet: driver.trigger.multiEval.set_threshold(power = 1.0) \n
+		Defines the trigger threshold for the power trigger. \n
+			:param power: (float or boolean) numeric Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
 		"""
-		self._core.io.write(f'CALL:BLUetooth:MEASurement<Instance>:DTMode:LENergy:RESet')
+		param = Conversions.decimal_or_bool_value_to_str(power)
+		self._core.io.write(f'TRIGger:BLUetooth:MEASurement<Instance>:MEValuation:THReshold {param}')
 
-	def reset_with_opc(self) -> None:
-		"""SCPI: CALL:BLUetooth:MEASurement<Instance>:DTMode:LENergy:RESet \n
-		Snippet: driver.call.dtMode.lowEnergy.reset_with_opc() \n
-		Sends the HCI reset command to the EUT via USB. Check the execution via method RsCmwBluetoothMeas.Call.DtMode.LowEnergy.
-		rresult. \n
-		Same as reset, but waits for the operation to complete before continuing further. Use the RsCmwBluetoothMeas.utilities.opc_timeout_set() to set the timeout value. \n
+	def get_timeout(self) -> float or bool:
+		"""SCPI: TRIGger:BLUetooth:MEASurement<Instance>:MEValuation:TOUT \n
+		Snippet: value: float or bool = driver.trigger.multiEval.get_timeout() \n
+		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
+		indicates a trigger timeout in manual operation mode. \n
+			:return: trigger_timeout: (float or boolean) numeric | ON | OFF Range: 0.01 s to 167772.15 s Additional parameters: OFF | ON (disables timeout | enables timeout using the previous/default values) .
 		"""
-		self._core.io.write_with_opc(f'CALL:BLUetooth:MEASurement<Instance>:DTMode:LENergy:RESet')
+		response = self._core.io.query_str('TRIGger:BLUetooth:MEASurement<Instance>:MEValuation:TOUT?')
+		return Conversions.str_to_float_or_bool(response)
 
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
-		Also copies all the existing default Repeated Capabilities setting,
-		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
-		return new_group
+	def set_timeout(self, trigger_timeout: float or bool) -> None:
+		"""SCPI: TRIGger:BLUetooth:MEASurement<Instance>:MEValuation:TOUT \n
+		Snippet: driver.trigger.multiEval.set_timeout(trigger_timeout = 1.0) \n
+		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
+		indicates a trigger timeout in manual operation mode. \n
+			:param trigger_timeout: (float or boolean) numeric | ON | OFF Range: 0.01 s to 167772.15 s Additional parameters: OFF | ON (disables timeout | enables timeout using the previous/default values) .
+		"""
+		param = Conversions.decimal_or_bool_value_to_str(trigger_timeout)
+		self._core.io.write(f'TRIGger:BLUetooth:MEASurement<Instance>:MEValuation:TOUT {param}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Call_/DtMode_/LowEnergy_/Rdevices.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Brate/FilterPy.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,26 +1,32 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Rdevices:
-	"""Rdevices commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class FilterPyCls:
+	"""FilterPy commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rdevices", core, parent)
+		self._cmd_group = CommandsGroup("filterPy", core, parent)
 
-	def set(self) -> None:
-		"""SCPI: CALL:BLUetooth:MEASurement<Instance>:DTMode:LENergy:RDEVices \n
-		Snippet: driver.call.dtMode.lowEnergy.rdevices.set() \n
-		Discovers the DUTs connected to USB ports via a USB-to-RS232 adapter. \n
+	# noinspection PyTypeChecker
+	def get_bandwidth(self) -> enums.FilterWidth:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:BRATe:FILTer:BWIDth \n
+		Snippet: value: enums.FilterWidth = driver.configure.multiEval.brate.filterPy.get_bandwidth() \n
+		Selects the filter bandwidth for BR measurements. \n
+			:return: filter_bandwidth: NARRow | WIDE NARRow: Narrow-band filter WIDE: Wide-band filter
 		"""
-		self._core.io.write(f'CALL:BLUetooth:MEASurement<Instance>:DTMode:LENergy:RDEVices')
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:BRATe:FILTer:BWIDth?')
+		return Conversions.str_to_scalar_enum(response, enums.FilterWidth)
 
-	def set_with_opc(self) -> None:
-		"""SCPI: CALL:BLUetooth:MEASurement<Instance>:DTMode:LENergy:RDEVices \n
-		Snippet: driver.call.dtMode.lowEnergy.rdevices.set_with_opc() \n
-		Discovers the DUTs connected to USB ports via a USB-to-RS232 adapter. \n
-		Same as set, but waits for the operation to complete before continuing further. Use the RsCmwBluetoothMeas.utilities.opc_timeout_set() to set the timeout value. \n
+	def set_bandwidth(self, filter_bandwidth: enums.FilterWidth) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:BRATe:FILTer:BWIDth \n
+		Snippet: driver.configure.multiEval.brate.filterPy.set_bandwidth(filter_bandwidth = enums.FilterWidth.NARRow) \n
+		Selects the filter bandwidth for BR measurements. \n
+			:param filter_bandwidth: NARRow | WIDE NARRow: Narrow-band filter WIDE: Wide-band filter
 		"""
-		self._core.io.write_with_opc(f'CALL:BLUetooth:MEASurement<Instance>:DTMode:LENergy:RDEVices')
+		param = Conversions.enum_scalar_to_str(filter_bandwidth, enums.FilterWidth)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:BRATe:FILTer:BWIDth {param}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Clean.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P3Q/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,27 +1,35 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Clean:
-	"""Clean commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class P3QCls:
+	"""P3Q commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("clean", core, parent)
+		self._cmd_group = CommandsGroup("p3Q", core, parent)
 
 	@property
-	def elogging(self):
-		"""elogging commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_elogging'):
-			from .Clean_.Elogging import Elogging
-			self._elogging = Elogging(self._core, self._base)
-		return self._elogging
+	def units(self):
+		"""units commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_units'):
+			from .Units import UnitsCls
+			self._units = UnitsCls(self._core, self._cmd_group)
+		return self._units
 
-	def clone(self) -> 'Clean':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def typePy(self):
+		"""typePy commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_typePy'):
+			from .TypePy import TypePyCls
+			self._typePy = TypePyCls(self._core, self._cmd_group)
+		return self._typePy
+
+	def clone(self) -> 'P3QCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Clean(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = P3QCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Clean_/Elogging.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Route/Scenario/MaProtocol.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Elogging:
-	"""Elogging commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MaProtocolCls:
+	"""MaProtocol commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("elogging", core, parent)
+		self._cmd_group = CommandsGroup("maProtocol", core, parent)
 
 	def set(self) -> None:
-		"""SCPI: CLEan:BLUetooth:MEASurement<Instance>:ELOGging \n
-		Snippet: driver.clean.elogging.set() \n
-		Clears the event log. \n
+		"""SCPI: ROUTe:BLUetooth:MEASurement<Instance>:SCENario:MAPRotocol \n
+		Snippet: driver.route.scenario.maProtocol.set() \n
+		No command help available \n
 		"""
-		self._core.io.write(f'CLEan:BLUetooth:MEASurement<Instance>:ELOGging')
+		self._core.io.write(f'ROUTe:BLUetooth:MEASurement<Instance>:SCENario:MAPRotocol')
 
-	def set_with_opc(self) -> None:
-		"""SCPI: CLEan:BLUetooth:MEASurement<Instance>:ELOGging \n
-		Snippet: driver.clean.elogging.set_with_opc() \n
-		Clears the event log. \n
+	def set_with_opc(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: ROUTe:BLUetooth:MEASurement<Instance>:SCENario:MAPRotocol \n
+		Snippet: driver.route.scenario.maProtocol.set_with_opc() \n
+		No command help available \n
 		Same as set, but waits for the operation to complete before continuing further. Use the RsCmwBluetoothMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'CLEan:BLUetooth:MEASurement<Instance>:ELOGging')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'ROUTe:BLUetooth:MEASurement<Instance>:SCENario:MAPRotocol', opc_timeout_ms)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/ComSettings.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RfSettings/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,142 +1,157 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ComSettings:
-	"""ComSettings commands group definition. 7 total commands, 1 Sub-groups, 6 group commands"""
+class RfSettingsCls:
+	"""RfSettings commands group definition. 16 total commands, 4 Subgroups, 5 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("comSettings", core, parent)
+		self._cmd_group = CommandsGroup("rfSettings", core, parent)
 
 	@property
-	def ports(self):
-		"""ports commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_ports'):
-			from .ComSettings_.Ports import Ports
-			self._ports = Ports(self._core, self._base)
-		return self._ports
-
-	def get_com_port(self) -> int:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:COMPort \n
-		Snippet: value: int = driver.configure.comSettings.get_com_port() \n
-		Specifies the virtual COM port of the R&S CMW100 control computer to be used for USB connection with USB to RS232 adapter. \n
-			:return: no: integer The number of a virtual COM port
-		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:COMPort?')
-		return Conversions.str_to_int(response)
+	def dtx(self):
+		"""dtx commands group. 0 Sub-classes, 4 commands."""
+		if not hasattr(self, '_dtx'):
+			from .Dtx import DtxCls
+			self._dtx = DtxCls(self._core, self._cmd_group)
+		return self._dtx
 
-	def set_com_port(self, no: int) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:COMPort \n
-		Snippet: driver.configure.comSettings.set_com_port(no = 1) \n
-		Specifies the virtual COM port of the R&S CMW100 control computer to be used for USB connection with USB to RS232 adapter. \n
-			:param no: integer The number of a virtual COM port
-		"""
-		param = Conversions.decimal_value_to_str(no)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:COMPort {param}')
-
-	# noinspection PyTypeChecker
-	def get_baud_rate(self) -> enums.BaudRate:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:BAUDrate \n
-		Snippet: value: enums.BaudRate = driver.configure.comSettings.get_baud_rate() \n
-		Specifies the transmission parameters of serial connection. \n
-			:return: baud_rate: B110 | B300 | B600 | B12K | B24K | B48K | B96K | B14K | B19K | B28K | B38K | B57K | B115k | B234k | B460k | B500k | B576k | B921k | B1M | B1M5 | B2M | B3M | B3M5 | B4M Data transmission rate in symbol: 110, 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200, 230400, 460800, 500000, 576000, 921600, 1000000, 1152000, 2000000, 3000000, 3500000, 4000000
-		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:BAUDrate?')
-		return Conversions.str_to_scalar_enum(response, enums.BaudRate)
-
-	def set_baud_rate(self, baud_rate: enums.BaudRate) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:BAUDrate \n
-		Snippet: driver.configure.comSettings.set_baud_rate(baud_rate = enums.BaudRate.B110) \n
-		Specifies the transmission parameters of serial connection. \n
-			:param baud_rate: B110 | B300 | B600 | B12K | B24K | B48K | B96K | B14K | B19K | B28K | B38K | B57K | B115k | B234k | B460k | B500k | B576k | B921k | B1M | B1M5 | B2M | B3M | B3M5 | B4M Data transmission rate in symbol: 110, 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200, 230400, 460800, 500000, 576000, 921600, 1000000, 1152000, 2000000, 3000000, 3500000, 4000000
-		"""
-		param = Conversions.enum_scalar_to_str(baud_rate, enums.BaudRate)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:BAUDrate {param}')
-
-	# noinspection PyTypeChecker
-	def get_stop_bits(self) -> enums.StopBits:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:STOPbits \n
-		Snippet: value: enums.StopBits = driver.configure.comSettings.get_stop_bits() \n
-		Specifies the transmission parameters of serial connection. \n
-			:return: stop_bits: S1 | S2 Number of bits used for stop indication
-		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:STOPbits?')
-		return Conversions.str_to_scalar_enum(response, enums.StopBits)
-
-	def set_stop_bits(self, stop_bits: enums.StopBits) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:STOPbits \n
-		Snippet: driver.configure.comSettings.set_stop_bits(stop_bits = enums.StopBits.S1) \n
-		Specifies the transmission parameters of serial connection. \n
-			:param stop_bits: S1 | S2 Number of bits used for stop indication
-		"""
-		param = Conversions.enum_scalar_to_str(stop_bits, enums.StopBits)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:STOPbits {param}')
-
-	# noinspection PyTypeChecker
-	def get_parity(self) -> enums.Parity:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:PARity \n
-		Snippet: value: enums.Parity = driver.configure.comSettings.get_parity() \n
-		Specifies the transmission parameters of serial connection. \n
-			:return: parity: NONE | ODD | EVEN Number of parity bits
-		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:PARity?')
-		return Conversions.str_to_scalar_enum(response, enums.Parity)
-
-	def set_parity(self, parity: enums.Parity) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:PARity \n
-		Snippet: driver.configure.comSettings.set_parity(parity = enums.Parity.EVEN) \n
-		Specifies the transmission parameters of serial connection. \n
-			:param parity: NONE | ODD | EVEN Number of parity bits
-		"""
-		param = Conversions.enum_scalar_to_str(parity, enums.Parity)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:PARity {param}')
-
-	# noinspection PyTypeChecker
-	def get_protocol(self) -> enums.Protocol:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:PROTocol \n
-		Snippet: value: enums.Protocol = driver.configure.comSettings.get_protocol() \n
-		Specifies the transmission parameters of serial connection. \n
-			:return: protocol: XONXoff | CTSRts | NONE Transmit flow control X-ON/X-OFF, RFR/CTS, or none
-		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:PROTocol?')
-		return Conversions.str_to_scalar_enum(response, enums.Protocol)
-
-	def set_protocol(self, protocol: enums.Protocol) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:PROTocol \n
-		Snippet: driver.configure.comSettings.set_protocol(protocol = enums.Protocol.CTSRts) \n
-		Specifies the transmission parameters of serial connection. \n
-			:param protocol: XONXoff | CTSRts | NONE Transmit flow control X-ON/X-OFF, RFR/CTS, or none
-		"""
-		param = Conversions.enum_scalar_to_str(protocol, enums.Protocol)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:PROTocol {param}')
-
-	# noinspection PyTypeChecker
-	def get_dbits(self) -> enums.DataBits:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:DBITs \n
-		Snippet: value: enums.DataBits = driver.configure.comSettings.get_dbits() \n
-		No command help available \n
-			:return: data_bits: No help available
-		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:DBITs?')
-		return Conversions.str_to_scalar_enum(response, enums.DataBits)
+	@property
+	def cte(self):
+		"""cte commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_cte'):
+			from .Cte import CteCls
+			self._cte = CteCls(self._core, self._cmd_group)
+		return self._cte
 
-	def set_dbits(self, data_bits: enums.DataBits) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:DBITs \n
-		Snippet: driver.configure.comSettings.set_dbits(data_bits = enums.DataBits.D7) \n
+	@property
+	def mmode(self):
+		"""mmode commands group. 1 Sub-classes, 1 commands."""
+		if not hasattr(self, '_mmode'):
+			from .Mmode import MmodeCls
+			self._mmode = MmodeCls(self._core, self._cmd_group)
+		return self._mmode
+
+	@property
+	def mchannel(self):
+		"""mchannel commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_mchannel'):
+			from .Mchannel import MchannelCls
+			self._mchannel = MchannelCls(self._core, self._cmd_group)
+		return self._mchannel
+
+	def get_eattenuation(self) -> float:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:EATTenuation \n
+		Snippet: value: float = driver.configure.rfSettings.get_eattenuation() \n
+		Defines an external attenuation (or gain, if the value is negative) , to be applied to the input connector.
+		For the combined signal path scenario, use CONFigure:BLUetooth:SIGN<i>:RFSettings:EATTenuation:INPut. \n
+			:return: external_att: numeric Range: -50 dB to 90 dB
+		"""
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:EATTenuation?')
+		return Conversions.str_to_float(response)
+
+	def set_eattenuation(self, external_att: float) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:EATTenuation \n
+		Snippet: driver.configure.rfSettings.set_eattenuation(external_att = 1.0) \n
+		Defines an external attenuation (or gain, if the value is negative) , to be applied to the input connector.
+		For the combined signal path scenario, use CONFigure:BLUetooth:SIGN<i>:RFSettings:EATTenuation:INPut. \n
+			:param external_att: numeric Range: -50 dB to 90 dB
+		"""
+		param = Conversions.decimal_value_to_str(external_att)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:EATTenuation {param}')
+
+	def get_umargin(self) -> float:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:UMARgin \n
+		Snippet: value: float = driver.configure.rfSettings.get_umargin() \n
+		Sets the margin that the R&S CMW adds to the expected nominal power to determine the reference level. The reference level
+		minus the external input attenuation must be within the power range of the selected input connector; refer to the data
+		sheet. For the combined signal path scenario, use CONFigure:BLUetooth:SIGN<i>:RFSettings:UMARgin. \n
+			:return: user_margin: numeric Range: 0 dB to (55 dB + external attenuation - expected nominal power)
+		"""
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:UMARgin?')
+		return Conversions.str_to_float(response)
+
+	def set_umargin(self, user_margin: float) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:UMARgin \n
+		Snippet: driver.configure.rfSettings.set_umargin(user_margin = 1.0) \n
+		Sets the margin that the R&S CMW adds to the expected nominal power to determine the reference level. The reference level
+		minus the external input attenuation must be within the power range of the selected input connector; refer to the data
+		sheet. For the combined signal path scenario, use CONFigure:BLUetooth:SIGN<i>:RFSettings:UMARgin. \n
+			:param user_margin: numeric Range: 0 dB to (55 dB + external attenuation - expected nominal power)
+		"""
+		param = Conversions.decimal_value_to_str(user_margin)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:UMARgin {param}')
+
+	def get_envelope_power(self) -> float:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:ENPower \n
+		Snippet: value: float = driver.configure.rfSettings.get_envelope_power() \n
+		Sets the expected nominal power of the measured RF signal. For the combined signal path scenario,
+		use CONFigure:BLUetooth:SIGN<i>:RFSettings:ENPower. \n
+			:return: exp_nominal_power: numeric The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet.
+		"""
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:ENPower?')
+		return Conversions.str_to_float(response)
+
+	def set_envelope_power(self, exp_nominal_power: float) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:ENPower \n
+		Snippet: driver.configure.rfSettings.set_envelope_power(exp_nominal_power = 1.0) \n
+		Sets the expected nominal power of the measured RF signal. For the combined signal path scenario,
+		use CONFigure:BLUetooth:SIGN<i>:RFSettings:ENPower. \n
+			:param exp_nominal_power: numeric The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet.
+		"""
+		param = Conversions.decimal_value_to_str(exp_nominal_power)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:ENPower {param}')
+
+	def get_frequency(self) -> float:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:FREQuency \n
+		Snippet: value: float = driver.configure.rfSettings.get_frequency() \n
+		Selects the center frequency of the RF analyzer.
+			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
+			- CONFigure:BLUetooth:SIGN<i>:RFSettings:CHANnel:LOOPback
+			- CONFigure:BLUetooth:SIGN<i>:RFSettings:CHANnel:TXTest
+			- CONFigure:BLUetooth:SIGN<i>:RFSettings:FREQuency:LOOPback?
+			- CONFigure:BLUetooth:SIGN<i>:RFSettings:FREQuency:TXTest?
+			- CONFigure:BLUetooth:SIGN<i>:RFSettings:HOPPing
+			- method RsCmwBluetoothMeas.Configure.RfSettings.Mmode.value
+			- method RsCmwBluetoothMeas.Configure.RfSettings.Mchannel.classic \n
+			:return: analyzer_freq: numeric Range: 100 MHz to 6 GHz, Unit: Hz
+		"""
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:FREQuency?')
+		return Conversions.str_to_float(response)
+
+	def set_frequency(self, analyzer_freq: float) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:FREQuency \n
+		Snippet: driver.configure.rfSettings.set_frequency(analyzer_freq = 1.0) \n
+		Selects the center frequency of the RF analyzer.
+			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
+			- CONFigure:BLUetooth:SIGN<i>:RFSettings:CHANnel:LOOPback
+			- CONFigure:BLUetooth:SIGN<i>:RFSettings:CHANnel:TXTest
+			- CONFigure:BLUetooth:SIGN<i>:RFSettings:FREQuency:LOOPback?
+			- CONFigure:BLUetooth:SIGN<i>:RFSettings:FREQuency:TXTest?
+			- CONFigure:BLUetooth:SIGN<i>:RFSettings:HOPPing
+			- method RsCmwBluetoothMeas.Configure.RfSettings.Mmode.value
+			- method RsCmwBluetoothMeas.Configure.RfSettings.Mchannel.classic \n
+			:param analyzer_freq: numeric Range: 100 MHz to 6 GHz, Unit: Hz
+		"""
+		param = Conversions.decimal_value_to_str(analyzer_freq)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:FREQuency {param}')
+
+	def get_rlevel(self) -> int:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:RLEVel \n
+		Snippet: value: int = driver.configure.rfSettings.get_rlevel() \n
 		No command help available \n
-			:param data_bits: No help available
+			:return: reference_level: No help available
 		"""
-		param = Conversions.enum_scalar_to_str(data_bits, enums.DataBits)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:DBITs {param}')
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:RLEVel?')
+		return Conversions.str_to_int(response)
 
-	def clone(self) -> 'ComSettings':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RfSettingsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ComSettings(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RfSettingsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/ComSettings_/Ports.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/IqAbs.py`

 * *Files 21% similar despite different names*

```diff
@@ -4,40 +4,48 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.Types import DataType
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ports:
-	"""Ports commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class IqAbsCls:
+	"""IqAbs commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ports", core, parent)
+		self._cmd_group = CommandsGroup("iqAbs", core, parent)
 
 	# noinspection PyTypeChecker
-	class CatalogStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- No_Devices: int: decimal Number of all COM ports, where a connected DUT has been recognized
-			- Item_Number: List[int]: decimal The number of a list item
-			- Discovered_Port: List[str]: string Number of the virtual COM port, to which the used USB port has been mapped"""
+	class ResultData(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: decimal 'Reliability indicator'
+			- Iphase: List[float]: float N in-phase amplitudes (IPhase) and N quadrature-phase (QPhase) amplitudes, where N is equal to the number of processed 50-symbol blocks; see 'Trace points for IQ constellation diagrams (EDR) '. Range: -2 to 2
+			- Qphase: List[float]: No parameter help available"""
 		__meta_args_list = [
-			ArgStruct.scalar_int('No_Devices'),
-			ArgStruct('Item_Number', DataType.IntegerList, None, False, True, 1),
-			ArgStruct('Discovered_Port', DataType.StringList, None, False, True, 1)]
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct('Iphase', DataType.FloatList, None, False, True, 1),
+			ArgStruct('Qphase', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.No_Devices: int = None
-			self.Item_Number: List[int] = None
-			self.Discovered_Port: List[str] = None
-
-	def get_catalog(self) -> CatalogStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:PORTs:CATalog \n
-		Snippet: value: CatalogStruct = driver.configure.comSettings.ports.get_catalog() \n
-		Queries the COM ports of the R&S CMW100 control computer used by a DUT. The command is relevant for the USB connection
-		with USB-to-serial converter ('HW Interface' = USB to RS232 adapter) . Results are returned for each used USB port:
-		<NoDevices>, {1, <DiscoveredPort>}1, ..., {<NoDevices>, <DiscoveredPort>}<NoDevices> \n
-			:return: structure: for return value, see the help for CatalogStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:COMSettings:PORTs:CATalog?', self.__class__.CatalogStruct())
+			self.Reliability: int = None
+			self.Iphase: List[float] = None
+			self.Qphase: List[float] = None
+
+	def read(self) -> ResultData:
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:IQABs \n
+		Snippet: value: ResultData = driver.multiEval.trace.iqAbs.read() \n
+		Returns the values of the traces in the I/Q constellation diagrams. The mnemonics IQABs, IQDiff, and IQERr denote the
+		absolute, differential and I/Q constellation error results. The I/Q traces are available for EDR packets (method
+		RsCmwBluetoothMeas.Configure.InputSignal.btype EDR) . \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:IQABs?', self.__class__.ResultData())
+
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:IQABs \n
+		Snippet: value: ResultData = driver.multiEval.trace.iqAbs.fetch() \n
+		Returns the values of the traces in the I/Q constellation diagrams. The mnemonics IQABs, IQDiff, and IQERr denote the
+		absolute, differential and I/Q constellation error results. The I/Q traces are available for EDR packets (method
+		RsCmwBluetoothMeas.Configure.InputSignal.btype EDR) . \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:IQABs?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,27 +1,35 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DtMode:
-	"""DtMode commands group definition. 17 total commands, 1 Sub-groups, 0 group commands"""
+class RxQualityCls:
+	"""RxQuality commands group definition. 26 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dtMode", core, parent)
+		self._cmd_group = CommandsGroup("rxQuality", core, parent)
 
 	@property
-	def rxQuality(self):
-		"""rxQuality commands group. 6 Sub-classes, 0 commands."""
-		if not hasattr(self, '_rxQuality'):
-			from .DtMode_.RxQuality import RxQuality
-			self._rxQuality = RxQuality(self._core, self._base)
-		return self._rxQuality
+	def search(self):
+		"""search commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_search'):
+			from .Search import SearchCls
+			self._search = SearchCls(self._core, self._cmd_group)
+		return self._search
 
-	def clone(self) -> 'DtMode':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def per(self):
+		"""per commands group. 2 Sub-classes, 3 commands."""
+		if not hasattr(self, '_per'):
+			from .Per import PerCls
+			self._per = PerCls(self._core, self._cmd_group)
+		return self._per
+
+	def clone(self) -> 'RxQualityCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = DtMode(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RxQualityCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,67 +1,67 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RxQuality:
-	"""RxQuality commands group definition. 17 total commands, 6 Sub-groups, 0 group commands"""
+class RxQualityCls:
+	"""RxQuality commands group definition. 23 total commands, 6 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rxQuality", core, parent)
+		self._cmd_group = CommandsGroup("rxQuality", core, parent)
 
 	@property
 	def smIndex(self):
 		"""smIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_smIndex'):
-			from .RxQuality_.SmIndex import SmIndex
-			self._smIndex = SmIndex(self._core, self._base)
+			from .SmIndex import SmIndexCls
+			self._smIndex = SmIndexCls(self._core, self._cmd_group)
 		return self._smIndex
 
 	@property
 	def eattenuation(self):
 		"""eattenuation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_eattenuation'):
-			from .RxQuality_.Eattenuation import Eattenuation
-			self._eattenuation = Eattenuation(self._core, self._base)
+			from .Eattenuation import EattenuationCls
+			self._eattenuation = EattenuationCls(self._core, self._cmd_group)
 		return self._eattenuation
 
 	@property
 	def search(self):
-		"""search commands group. 2 Sub-classes, 2 commands."""
+		"""search commands group. 3 Sub-classes, 2 commands."""
 		if not hasattr(self, '_search'):
-			from .RxQuality_.Search import Search
-			self._search = Search(self._core, self._base)
+			from .Search import SearchCls
+			self._search = SearchCls(self._core, self._cmd_group)
 		return self._search
 
 	@property
 	def rintegrity(self):
 		"""rintegrity commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_rintegrity'):
-			from .RxQuality_.Rintegrity import Rintegrity
-			self._rintegrity = Rintegrity(self._core, self._base)
+			from .Rintegrity import RintegrityCls
+			self._rintegrity = RintegrityCls(self._core, self._cmd_group)
 		return self._rintegrity
 
 	@property
 	def per(self):
-		"""per commands group. 0 Sub-classes, 1 commands."""
+		"""per commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_per'):
-			from .RxQuality_.Per import Per
-			self._per = Per(self._core, self._base)
+			from .Per import PerCls
+			self._per = PerCls(self._core, self._cmd_group)
 		return self._per
 
 	@property
 	def limit(self):
 		"""limit commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_limit'):
-			from .RxQuality_.Limit import Limit
-			self._limit = Limit(self._core, self._base)
+			from .Limit import LimitCls
+			self._limit = LimitCls(self._core, self._cmd_group)
 		return self._limit
 
-	def clone(self) -> 'RxQuality':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RxQualityCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = RxQuality(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RxQualityCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Eattenuation.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RxQuality/Eattenuation.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,30 +1,30 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Eattenuation:
-	"""Eattenuation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class EattenuationCls:
+	"""Eattenuation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("eattenuation", core, parent)
+		self._cmd_group = CommandsGroup("eattenuation", core, parent)
 
 	def get_output(self) -> float:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:EATTenuation:OUTPut \n
-		Snippet: value: float = driver.configure.dtMode.rxQuality.eattenuation.get_output() \n
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:EATTenuation:OUTPut \n
+		Snippet: value: float = driver.configure.rxQuality.eattenuation.get_output() \n
 		Defines an external attenuation (or gain, if the value is negative) , to be applied to the output connector. \n
 			:return: atten: numeric Range: -50 dB to 90 dB
 		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:EATTenuation:OUTPut?')
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:EATTenuation:OUTPut?')
 		return Conversions.str_to_float(response)
 
 	def set_output(self, atten: float) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:EATTenuation:OUTPut \n
-		Snippet: driver.configure.dtMode.rxQuality.eattenuation.set_output(atten = 1.0) \n
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:EATTenuation:OUTPut \n
+		Snippet: driver.configure.rxQuality.eattenuation.set_output(atten = 1.0) \n
 		Defines an external attenuation (or gain, if the value is negative) , to be applied to the output connector. \n
 			:param atten: numeric Range: -50 dB to 90 dB
 		"""
 		param = Conversions.decimal_value_to_str(atten)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:EATTenuation:OUTPut {param}')
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:EATTenuation:OUTPut {param}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Limit.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Trx/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Limit:
-	"""Limit commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class TrxCls:
+	"""Trx commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("limit", core, parent)
+		self._cmd_group = CommandsGroup("trx", core, parent)
 
 	@property
-	def mper(self):
-		"""mper commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_mper'):
-			from .Limit_.Mper import Mper
-			self._mper = Mper(self._core, self._base)
-		return self._mper
+	def result(self):
+		"""result commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_result'):
+			from .Result import ResultCls
+			self._result = ResultCls(self._core, self._cmd_group)
+		return self._result
 
-	def clone(self) -> 'Limit':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'TrxCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Limit(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TrxCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Limit_/Mper.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Limit/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Mper:
-	"""Mper commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class LimitCls:
+	"""Limit commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("mper", core, parent)
+		self._cmd_group = CommandsGroup("limit", core, parent)
 
 	@property
-	def lowEnergy(self):
-		"""lowEnergy commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_lowEnergy'):
-			from .Mper_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
-		return self._lowEnergy
+	def mper(self):
+		"""mper commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_mper'):
+			from .Mper import MperCls
+			self._mper = MperCls(self._core, self._cmd_group)
+		return self._mper
 
-	def clone(self) -> 'Mper':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LimitCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Mper(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LimitCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Per.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Dacc.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,30 +1,31 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.Utilities import trim_str_response
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Per:
-	"""Per commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DaccCls:
+	"""Dacc commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("per", core, parent)
+		self._cmd_group = CommandsGroup("dacc", core, parent)
 
-	def get_level(self) -> float:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LEVel \n
-		Snippet: value: float = driver.configure.dtMode.rxQuality.per.get_level() \n
-		Sets the Tx level of ARB generator. \n
-			:return: level: numeric
+	def get_qhsl(self) -> str:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DACC:QHSL \n
+		Snippet: value: str = driver.configure.inputSignal.dacc.get_qhsl() \n
+		No command help available \n
+			:return: access_address: No help available
 		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LEVel?')
-		return Conversions.str_to_float(response)
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DACC:QHSL?')
+		return trim_str_response(response)
 
-	def set_level(self, level: float) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LEVel \n
-		Snippet: driver.configure.dtMode.rxQuality.per.set_level(level = 1.0) \n
-		Sets the Tx level of ARB generator. \n
-			:param level: numeric
+	def set_qhsl(self, access_address: str) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DACC:QHSL \n
+		Snippet: driver.configure.inputSignal.dacc.set_qhsl(access_address = rawAbc) \n
+		No command help available \n
+			:param access_address: No help available
 		"""
-		param = Conversions.decimal_value_to_str(level)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LEVel {param}')
+		param = Conversions.value_to_str(access_address)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DACC:QHSL {param}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Rintegrity.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Edrate/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Rintegrity:
-	"""Rintegrity commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class EdrateCls:
+	"""Edrate commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rintegrity", core, parent)
+		self._cmd_group = CommandsGroup("edrate", core, parent)
 
 	@property
-	def lowEnergy(self):
-		"""lowEnergy commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_lowEnergy'):
-			from .Rintegrity_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
-		return self._lowEnergy
+	def filterPy(self):
+		"""filterPy commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_filterPy'):
+			from .FilterPy import FilterPyCls
+			self._filterPy = FilterPyCls(self._core, self._cmd_group)
+		return self._filterPy
 
-	def clone(self) -> 'Rintegrity':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EdrateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Rintegrity(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EdrateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Search.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RxQuality/Per.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,72 +1,70 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Search:
-	"""Search commands group definition. 8 total commands, 2 Sub-groups, 2 group commands"""
+class PerCls:
+	"""Per commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("search", core, parent)
+		self._cmd_group = CommandsGroup("per", core, parent)
 
-	@property
-	def rintegrity(self):
-		"""rintegrity commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_rintegrity'):
-			from .Search_.Rintegrity import Rintegrity
-			self._rintegrity = Rintegrity(self._core, self._base)
-		return self._rintegrity
-
-	@property
-	def limit(self):
-		"""limit commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_limit'):
-			from .Search_.Limit import Limit
-			self._limit = Limit(self._core, self._base)
-		return self._limit
-
-	def get_start_level(self) -> float or bool:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:STARtlevel \n
-		Snippet: value: float or bool = driver.configure.dtMode.rxQuality.search.get_start_level() \n
-		Specifies the initial Tx power for the LE search iteration of PER search measurements with ARB generator. \n
-			:return: start_level: numeric Range: -100 dBm to 0 dBm
+	def get_level(self) -> float:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:PER:LEVel \n
+		Snippet: value: float = driver.configure.rxQuality.per.get_level() \n
+		Sets the Tx level of R&S CMW for PER measurements. The allowed value range can be calculated as follows: Range (Level) =
+		Range (Output Power) - External Attenuation Range (Output Power) = -130 dBm to 0 dBm (RFx COM) or -120 dBm to 8 dBm (RFx
+		OUT) ; please also notice the ranges quoted in the data sheet. \n
+			:return: level: numeric Range: see above
 		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:STARtlevel?')
-		return Conversions.str_to_float_or_bool(response)
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:PER:LEVel?')
+		return Conversions.str_to_float(response)
+
+	def set_level(self, level: float) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:PER:LEVel \n
+		Snippet: driver.configure.rxQuality.per.set_level(level = 1.0) \n
+		Sets the Tx level of R&S CMW for PER measurements. The allowed value range can be calculated as follows: Range (Level) =
+		Range (Output Power) - External Attenuation Range (Output Power) = -130 dBm to 0 dBm (RFx COM) or -120 dBm to 8 dBm (RFx
+		OUT) ; please also notice the ranges quoted in the data sheet. \n
+			:param level: numeric Range: see above
+		"""
+		param = Conversions.decimal_value_to_str(level)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:PER:LEVel {param}')
+
+	def get_tx_packets(self) -> int:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:PER:TXPackets \n
+		Snippet: value: int = driver.configure.rxQuality.per.get_tx_packets() \n
+		Sets number of packets for PER measurements. \n
+			:return: packets_to_send: numeric Range: 1 to 100E+3
+		"""
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:PER:TXPackets?')
+		return Conversions.str_to_int(response)
+
+	def set_tx_packets(self, packets_to_send: int) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:PER:TXPackets \n
+		Snippet: driver.configure.rxQuality.per.set_tx_packets(packets_to_send = 1) \n
+		Sets number of packets for PER measurements. \n
+			:param packets_to_send: numeric Range: 1 to 100E+3
+		"""
+		param = Conversions.decimal_value_to_str(packets_to_send)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:PER:TXPackets {param}')
 
-	def set_start_level(self, start_level: float or bool) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:STARtlevel \n
-		Snippet: driver.configure.dtMode.rxQuality.search.set_start_level(start_level = 1.0) \n
-		Specifies the initial Tx power for the LE search iteration of PER search measurements with ARB generator. \n
-			:param start_level: numeric Range: -100 dBm to 0 dBm
-		"""
-		param = Conversions.decimal_or_bool_value_to_str(start_level)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:STARtlevel {param}')
-
-	def get_step(self) -> float or bool:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:STEP \n
-		Snippet: value: float or bool = driver.configure.dtMode.rxQuality.search.get_step() \n
-		Specifies the power step for the LE search iteration of PER search measurements with ARB generator. \n
-			:return: level_step: numeric Range: 0.01 dB to 5 dB
+	def get_limit(self) -> float or bool:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:PER:LIMit \n
+		Snippet: value: float or bool = driver.configure.rxQuality.per.get_limit() \n
+		No command help available \n
+			:return: limit: (float or boolean) No help available
 		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:STEP?')
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:PER:LIMit?')
 		return Conversions.str_to_float_or_bool(response)
 
-	def set_step(self, level_step: float or bool) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:STEP \n
-		Snippet: driver.configure.dtMode.rxQuality.search.set_step(level_step = 1.0) \n
-		Specifies the power step for the LE search iteration of PER search measurements with ARB generator. \n
-			:param level_step: numeric Range: 0.01 dB to 5 dB
-		"""
-		param = Conversions.decimal_or_bool_value_to_str(level_step)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:STEP {param}')
-
-	def clone(self) -> 'Search':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
-		Also copies all the existing default Repeated Capabilities setting,
-		which you can change independently without affecting the original group"""
-		new_group = Search(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
-		return new_group
+	def set_limit(self, limit: float or bool) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:PER:LIMit \n
+		Snippet: driver.configure.rxQuality.per.set_limit(limit = 1.0) \n
+		No command help available \n
+			:param limit: (float or boolean) No help available
+		"""
+		param = Conversions.decimal_or_bool_value_to_str(limit)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:PER:LIMit {param}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Search_/Limit.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Qhsl/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Limit:
-	"""Limit commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class QhslCls:
+	"""Qhsl commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("limit", core, parent)
+		self._cmd_group = CommandsGroup("qhsl", core, parent)
 
 	@property
-	def mper(self):
-		"""mper commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_mper'):
-			from .Limit_.Mper import Mper
-			self._mper = Mper(self._core, self._base)
-		return self._mper
+	def phy(self):
+		"""phy commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_phy'):
+			from .Phy import PhyCls
+			self._phy = PhyCls(self._core, self._cmd_group)
+		return self._phy
 
-	def clone(self) -> 'Limit':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'QhslCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Limit(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = QhslCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/Search_/Limit_/Mper.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Search/Limit/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Mper:
-	"""Mper commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class LimitCls:
+	"""Limit commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("mper", core, parent)
+		self._cmd_group = CommandsGroup("limit", core, parent)
 
 	@property
-	def lowEnergy(self):
-		"""lowEnergy commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_lowEnergy'):
-			from .Mper_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
-		return self._lowEnergy
+	def mper(self):
+		"""mper commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_mper'):
+			from .Mper import MperCls
+			self._mper = MperCls(self._core, self._cmd_group)
+		return self._mper
 
-	def clone(self) -> 'Mper':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LimitCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Mper(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LimitCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/DtMode_/RxQuality_/SmIndex.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/SmIndex.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,30 +1,30 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SmIndex:
-	"""SmIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SmIndexCls:
+	"""SmIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("smIndex", core, parent)
+		self._cmd_group = CommandsGroup("smIndex", core, parent)
 
 	def get_low_energy(self) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SMINdex:LENergy \n
 		Snippet: value: bool = driver.configure.dtMode.rxQuality.smIndex.get_low_energy() \n
-		Selects the standard or stable modulation index used by a dirty transmitter. \n
-			:return: mod_index_type: OFF | ON OFF: standard modulation index is used ON: stable modulation index is used
+		No command help available \n
+			:return: mod_index_type: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SMINdex:LENergy?')
 		return Conversions.str_to_bool(response)
 
 	def set_low_energy(self, mod_index_type: bool) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SMINdex:LENergy \n
 		Snippet: driver.configure.dtMode.rxQuality.smIndex.set_low_energy(mod_index_type = False) \n
-		Selects the standard or stable modulation index used by a dirty transmitter. \n
-			:param mod_index_type: OFF | ON OFF: standard modulation index is used ON: stable modulation index is used
+		No command help available \n
+			:param mod_index_type: No help available
 		"""
 		param = Conversions.bool_to_str(mod_index_type)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SMINdex:LENergy {param}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,240 +1,225 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ...Internal.Utilities import trim_str_response
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class InputSignal:
-	"""InputSignal commands group definition. 45 total commands, 11 Sub-groups, 7 group commands"""
+class MultiEvalCls:
+	"""MultiEval commands group definition. 154 total commands, 14 Subgroups, 4 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("inputSignal", core, parent)
+		self._cmd_group = CommandsGroup("multiEval", core, parent)
 
 	@property
-	def dtMode(self):
-		"""dtMode commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_dtMode'):
-			from .InputSignal_.DtMode import DtMode
-			self._dtMode = DtMode(self._core, self._base)
-		return self._dtMode
-
-	@property
-	def cte(self):
-		"""cte commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_cte'):
-			from .InputSignal_.Cte import Cte
-			self._cte = Cte(self._core, self._base)
-		return self._cte
-
-	@property
-	def oslots(self):
-		"""oslots commands group. 1 Sub-classes, 2 commands."""
-		if not hasattr(self, '_oslots'):
-			from .InputSignal_.Oslots import Oslots
-			self._oslots = Oslots(self._core, self._base)
-		return self._oslots
-
-	@property
-	def plength(self):
-		"""plength commands group. 1 Sub-classes, 2 commands."""
-		if not hasattr(self, '_plength'):
-			from .InputSignal_.Plength import Plength
-			self._plength = Plength(self._core, self._base)
-		return self._plength
-
-	@property
-	def ptype(self):
-		"""ptype commands group. 1 Sub-classes, 2 commands."""
-		if not hasattr(self, '_ptype'):
-			from .InputSignal_.Ptype import Ptype
-			self._ptype = Ptype(self._core, self._base)
-		return self._ptype
+	def qhsl(self):
+		"""qhsl commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_qhsl'):
+			from .Qhsl import QhslCls
+			self._qhsl = QhslCls(self._core, self._cmd_group)
+		return self._qhsl
+
+	@property
+	def sacp(self):
+		"""sacp commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_sacp'):
+			from .Sacp import SacpCls
+			self._sacp = SacpCls(self._core, self._cmd_group)
+		return self._sacp
+
+	@property
+	def limit(self):
+		"""limit commands group. 9 Sub-classes, 1 commands."""
+		if not hasattr(self, '_limit'):
+			from .Limit import LimitCls
+			self._limit = LimitCls(self._core, self._cmd_group)
+		return self._limit
+
+	@property
+	def measurement(self):
+		"""measurement commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_measurement'):
+			from .Measurement import MeasurementCls
+			self._measurement = MeasurementCls(self._core, self._cmd_group)
+		return self._measurement
+
+	@property
+	def listPy(self):
+		"""listPy commands group. 2 Sub-classes, 5 commands."""
+		if not hasattr(self, '_listPy'):
+			from .ListPy import ListPyCls
+			self._listPy = ListPyCls(self._core, self._cmd_group)
+		return self._listPy
+
+	@property
+	def malgorithm(self):
+		"""malgorithm commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_malgorithm'):
+			from .Malgorithm import MalgorithmCls
+			self._malgorithm = MalgorithmCls(self._core, self._cmd_group)
+		return self._malgorithm
 
 	@property
 	def lowEnergy(self):
-		"""lowEnergy commands group. 0 Sub-classes, 2 commands."""
+		"""lowEnergy commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_lowEnergy'):
-			from .InputSignal_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
 		return self._lowEnergy
 
 	@property
-	def accAddress(self):
-		"""accAddress commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_accAddress'):
-			from .InputSignal_.AccAddress import AccAddress
-			self._accAddress = AccAddress(self._core, self._base)
-		return self._accAddress
-
-	@property
-	def synWord(self):
-		"""synWord commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_synWord'):
-			from .InputSignal_.SynWord import SynWord
-			self._synWord = SynWord(self._core, self._base)
-		return self._synWord
-
-	@property
-	def pattern(self):
-		"""pattern commands group. 1 Sub-classes, 1 commands."""
-		if not hasattr(self, '_pattern'):
-			from .InputSignal_.Pattern import Pattern
-			self._pattern = Pattern(self._core, self._base)
-		return self._pattern
-
-	@property
-	def cscheme(self):
-		"""cscheme commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_cscheme'):
-			from .InputSignal_.Cscheme import Cscheme
-			self._cscheme = Cscheme(self._core, self._base)
-		return self._cscheme
-
-	@property
-	def fec(self):
-		"""fec commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_fec'):
-			from .InputSignal_.Fec import Fec
-			self._fec = Fec(self._core, self._base)
-		return self._fec
+	def edrate(self):
+		"""edrate commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_edrate'):
+			from .Edrate import EdrateCls
+			self._edrate = EdrateCls(self._core, self._cmd_group)
+		return self._edrate
+
+	@property
+	def brate(self):
+		"""brate commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_brate'):
+			from .Brate import BrateCls
+			self._brate = BrateCls(self._core, self._cmd_group)
+		return self._brate
+
+	@property
+	def scount(self):
+		"""scount commands group. 0 Sub-classes, 7 commands."""
+		if not hasattr(self, '_scount'):
+			from .Scount import ScountCls
+			self._scount = ScountCls(self._core, self._cmd_group)
+		return self._scount
+
+	@property
+	def result(self):
+		"""result commands group. 0 Sub-classes, 17 commands."""
+		if not hasattr(self, '_result'):
+			from .Result import ResultCls
+			self._result = ResultCls(self._core, self._cmd_group)
+		return self._result
+
+	@property
+	def frange(self):
+		"""frange commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_frange'):
+			from .Frange import FrangeCls
+			self._frange = FrangeCls(self._core, self._cmd_group)
+		return self._frange
+
+	@property
+	def sgacp(self):
+		"""sgacp commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_sgacp'):
+			from .Sgacp import SgacpCls
+			self._sgacp = SgacpCls(self._core, self._cmd_group)
+		return self._sgacp
+
+	@property
+	def synchronise(self):
+		"""synchronise commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_synchronise'):
+			from .Synchronise import SynchroniseCls
+			self._synchronise = SynchroniseCls(self._core, self._cmd_group)
+		return self._synchronise
+
+	def get_timeout(self) -> float:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:TOUT \n
+		Snippet: value: float = driver.configure.multiEval.get_timeout() \n
+		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
+			:return: timeout: numeric Unit: s
+		"""
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:TOUT?')
+		return Conversions.str_to_float(response)
+
+	def set_timeout(self, timeout: float) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:TOUT \n
+		Snippet: driver.configure.multiEval.set_timeout(timeout = 1.0) \n
+		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
+			:param timeout: numeric Unit: s
+		"""
+		param = Conversions.decimal_value_to_str(timeout)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:TOUT {param}')
+
+	def get_mo_exception(self) -> bool:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:MOEXception \n
+		Snippet: value: bool = driver.configure.multiEval.get_mo_exception() \n
+		Specifies whether measurement results that are identified as faulty or inaccurate are rejected. \n
+			:return: meas_on_exception: OFF | ON ON: Results are never rejected. OFF: Faulty results are rejected.
+		"""
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:MOEXception?')
+		return Conversions.str_to_bool(response)
 
-	# noinspection PyTypeChecker
-	def get_dmode(self) -> enums.AutoManualMode:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DMODe \n
-		Snippet: value: enums.AutoManualMode = driver.configure.inputSignal.get_dmode() \n
-		Selects an algorithm which the R&S CMW uses to detect the measured burst. \n
-			:return: detection_mode: MANual | AUTO
-		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DMODe?')
-		return Conversions.str_to_scalar_enum(response, enums.AutoManualMode)
-
-	def set_dmode(self, detection_mode: enums.AutoManualMode) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DMODe \n
-		Snippet: driver.configure.inputSignal.set_dmode(detection_mode = enums.AutoManualMode.AUTO) \n
-		Selects an algorithm which the R&S CMW uses to detect the measured burst. \n
-			:param detection_mode: MANual | AUTO
+	def set_mo_exception(self, meas_on_exception: bool) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:MOEXception \n
+		Snippet: driver.configure.multiEval.set_mo_exception(meas_on_exception = False) \n
+		Specifies whether measurement results that are identified as faulty or inaccurate are rejected. \n
+			:param meas_on_exception: OFF | ON ON: Results are never rejected. OFF: Faulty results are rejected.
 		"""
-		param = Conversions.enum_scalar_to_str(detection_mode, enums.AutoManualMode)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DMODe {param}')
+		param = Conversions.bool_to_str(meas_on_exception)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:MOEXception {param}')
 
 	# noinspection PyTypeChecker
-	def get_btype(self) -> enums.BurstType:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:BTYPe \n
-		Snippet: value: enums.BurstType = driver.configure.inputSignal.get_btype() \n
-		Specifies the measured burst / packet type.
-		For the combined signal path scenario, use CONFigure:BLUetooth:SIGN<i>:CONNection:BTYPe. \n
-			:return: burst_type: BR | EDR | LE BR: 'Basic Rate' EDR: 'Enhanced Data Rate' LE: 'Low Energy'
-		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:BTYPe?')
-		return Conversions.str_to_scalar_enum(response, enums.BurstType)
-
-	def set_btype(self, burst_type: enums.BurstType) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:BTYPe \n
-		Snippet: driver.configure.inputSignal.set_btype(burst_type = enums.BurstType.BR) \n
-		Specifies the measured burst / packet type.
-		For the combined signal path scenario, use CONFigure:BLUetooth:SIGN<i>:CONNection:BTYPe. \n
-			:param burst_type: BR | EDR | LE BR: 'Basic Rate' EDR: 'Enhanced Data Rate' LE: 'Low Energy'
-		"""
-		param = Conversions.enum_scalar_to_str(burst_type, enums.BurstType)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:BTYPe {param}')
-
-	def get_nap(self) -> str:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:NAP \n
-		Snippet: value: str = driver.configure.inputSignal.get_nap() \n
-		Specifies the non-specific address part of the EUT's Bluetooth device address. \n
-			:return: bd_address_nap: hex Four-digit hex number Range: #H0 to #HFFFF
-		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:NAP?')
-		return trim_str_response(response)
-
-	def set_nap(self, bd_address_nap: str) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:NAP \n
-		Snippet: driver.configure.inputSignal.set_nap(bd_address_nap = r1) \n
-		Specifies the non-specific address part of the EUT's Bluetooth device address. \n
-			:param bd_address_nap: hex Four-digit hex number Range: #H0 to #HFFFF
-		"""
-		param = Conversions.value_to_str(bd_address_nap)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:NAP {param}')
-
-	def get_uap(self) -> str:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:UAP \n
-		Snippet: value: str = driver.configure.inputSignal.get_uap() \n
-		Specifies the upper address part of the DUT's Bluetooth device address. \n
-			:return: bd_address_uap: hex Two-digit hex number Range: #H0 to #HFF
-		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:UAP?')
-		return trim_str_response(response)
-
-	def set_uap(self, bd_address_uap: str) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:UAP \n
-		Snippet: driver.configure.inputSignal.set_uap(bd_address_uap = r1) \n
-		Specifies the upper address part of the DUT's Bluetooth device address. \n
-			:param bd_address_uap: hex Two-digit hex number Range: #H0 to #HFF
-		"""
-		param = Conversions.value_to_str(bd_address_uap)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:UAP {param}')
-
-	def get_lap(self) -> str:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:LAP \n
-		Snippet: value: str = driver.configure.inputSignal.get_lap() \n
-		Specifies the lower address part of the DUT's Bluetooth device address. \n
-			:return: bd_address_lap: hex Six-digit hex number Range: #H0 to #HFFFFFF
-		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:LAP?')
-		return trim_str_response(response)
-
-	def set_lap(self, bd_address_lap: str) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:LAP \n
-		Snippet: driver.configure.inputSignal.set_lap(bd_address_lap = r1) \n
-		Specifies the lower address part of the DUT's Bluetooth device address. \n
-			:param bd_address_lap: hex Six-digit hex number Range: #H0 to #HFFFFFF
-		"""
-		param = Conversions.value_to_str(bd_address_lap)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:LAP {param}')
-
-	def get_bd_address(self) -> str:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:BDADdress \n
-		Snippet: value: str = driver.configure.inputSignal.get_bd_address() \n
-		Specifies the Bluetooth device address that the R&S CMW expects the EUT to use to generate its access code. \n
-			:return: bd_address: hex 12-digit hex number Range: #H0 to #HFFFFFFFFFFFF
-		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:BDADdress?')
-		return trim_str_response(response)
-
-	def set_bd_address(self, bd_address: str) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:BDADdress \n
-		Snippet: driver.configure.inputSignal.set_bd_address(bd_address = r1) \n
-		Specifies the Bluetooth device address that the R&S CMW expects the EUT to use to generate its access code. \n
-			:param bd_address: hex 12-digit hex number Range: #H0 to #HFFFFFFFFFFFF
-		"""
-		param = Conversions.value_to_str(bd_address)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:BDADdress {param}')
-
-	def get_asynchronize(self) -> bool:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:ASYNchronize \n
-		Snippet: value: bool = driver.configure.inputSignal.get_asynchronize() \n
-		Disables / enables automatic synchronization to the captured signal for an unspecified Bluetooth device address. \n
-			:return: auto_synch: OFF | ON
+	def get_scondition(self) -> enums.StopCondition:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCONdition \n
+		Snippet: value: enums.StopCondition = driver.configure.multiEval.get_scondition() \n
+		Qualifies whether the measurement is stopped after a failed limit check or continued. SLFail means that the measurement
+		is stopped and reaches the RDY state when one of the results exceeds the limits. \n
+			:return: stop_condition: NONE | SLFail NONE: Continue measurement irrespective of the limit check. SLFail: Stop measurement on limit failure.
+		"""
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCONdition?')
+		return Conversions.str_to_scalar_enum(response, enums.StopCondition)
+
+	def set_scondition(self, stop_condition: enums.StopCondition) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCONdition \n
+		Snippet: driver.configure.multiEval.set_scondition(stop_condition = enums.StopCondition.NONE) \n
+		Qualifies whether the measurement is stopped after a failed limit check or continued. SLFail means that the measurement
+		is stopped and reaches the RDY state when one of the results exceeds the limits. \n
+			:param stop_condition: NONE | SLFail NONE: Continue measurement irrespective of the limit check. SLFail: Stop measurement on limit failure.
 		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:ASYNchronize?')
-		return Conversions.str_to_bool(response)
+		param = Conversions.enum_scalar_to_str(stop_condition, enums.StopCondition)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCONdition {param}')
 
-	def set_asynchronize(self, auto_synch: bool) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:ASYNchronize \n
-		Snippet: driver.configure.inputSignal.set_asynchronize(auto_synch = False) \n
-		Disables / enables automatic synchronization to the captured signal for an unspecified Bluetooth device address. \n
-			:param auto_synch: OFF | ON
+	# noinspection PyTypeChecker
+	def get_repetition(self) -> enums.Repeat:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:REPetition \n
+		Snippet: value: enums.Repeat = driver.configure.multiEval.get_repetition() \n
+		Specifies the repetition mode of the measurement. The repetition mode specifies whether the measurement is stopped after
+		a single shot or repeated continuously. Use CONFigure:..:MEAS<i>:...:SCOunt to determine the number of measurement
+		intervals per single shot. \n
+			:return: repetition: SINGleshot | CONTinuous SINGleshot: Single-shot measurement CONTinuous: Continuous measurement
+		"""
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:REPetition?')
+		return Conversions.str_to_scalar_enum(response, enums.Repeat)
+
+	def set_repetition(self, repetition: enums.Repeat) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:REPetition \n
+		Snippet: driver.configure.multiEval.set_repetition(repetition = enums.Repeat.CONTinuous) \n
+		Specifies the repetition mode of the measurement. The repetition mode specifies whether the measurement is stopped after
+		a single shot or repeated continuously. Use CONFigure:..:MEAS<i>:...:SCOunt to determine the number of measurement
+		intervals per single shot. \n
+			:param repetition: SINGleshot | CONTinuous SINGleshot: Single-shot measurement CONTinuous: Continuous measurement
 		"""
-		param = Conversions.bool_to_str(auto_synch)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:ASYNchronize {param}')
+		param = Conversions.enum_scalar_to_str(repetition, enums.Repeat)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:REPetition {param}')
 
-	def clone(self) -> 'InputSignal':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MultiEvalCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = InputSignal(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MultiEvalCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/AccAddress.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/AccAddress.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,31 +1,31 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 from ....Internal.Utilities import trim_str_response
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class AccAddress:
-	"""AccAddress commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AccAddressCls:
+	"""AccAddress commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("accAddress", core, parent)
+		self._cmd_group = CommandsGroup("accAddress", core, parent)
 
 	def get_low_energy(self) -> str:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:ACCaddress:LENergy \n
 		Snippet: value: str = driver.configure.inputSignal.accAddress.get_low_energy() \n
 		Specifies the access address of advertiser for standalone LE measurements. \n
 			:return: access_address: hex Range: #H0 to #HFFFFFFFF
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:ACCaddress:LENergy?')
 		return trim_str_response(response)
 
 	def set_low_energy(self, access_address: str) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:ACCaddress:LENergy \n
-		Snippet: driver.configure.inputSignal.accAddress.set_low_energy(access_address = r1) \n
+		Snippet: driver.configure.inputSignal.accAddress.set_low_energy(access_address = rawAbc) \n
 		Specifies the access address of advertiser for standalone LE measurements. \n
 			:param access_address: hex Range: #H0 to #HFFFFFFFF
 		"""
 		param = Conversions.value_to_str(access_address)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:ACCaddress:LENergy {param}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Cscheme.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Rintegrity/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cscheme:
-	"""Cscheme commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class RintegrityCls:
+	"""Rintegrity commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cscheme", core, parent)
+		self._cmd_group = CommandsGroup("rintegrity", core, parent)
 
 	@property
 	def lowEnergy(self):
-		"""lowEnergy commands group. 0 Sub-classes, 1 commands."""
+		"""lowEnergy commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_lowEnergy'):
-			from .Cscheme_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
 		return self._lowEnergy
 
-	def clone(self) -> 'Cscheme':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RintegrityCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cscheme(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RintegrityCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Cscheme_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cscheme/LowEnergy.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class LowEnergyCls:
+	"""LowEnergy commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("lowEnergy", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_lrange(self) -> enums.CodingScheme:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:CSCHeme:LENergy:LRANge \n
 		Snippet: value: enums.CodingScheme = driver.configure.inputSignal.cscheme.lowEnergy.get_lrange() \n
 		No command help available \n
 			:return: coding_scheme: No help available
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Cte.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,27 +1,35 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cte:
-	"""Cte commands group definition. 4 total commands, 1 Sub-groups, 0 group commands"""
+class NmodeCls:
+	"""Nmode commands group definition. 48 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cte", core, parent)
+		self._cmd_group = CommandsGroup("nmode", core, parent)
+
+	@property
+	def classic(self):
+		"""classic commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_classic'):
+			from .Classic import ClassicCls
+			self._classic = ClassicCls(self._core, self._cmd_group)
+		return self._classic
 
 	@property
 	def lowEnergy(self):
-		"""lowEnergy commands group. 2 Sub-classes, 0 commands."""
+		"""lowEnergy commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_lowEnergy'):
-			from .Cte_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
 		return self._lowEnergy
 
-	def clone(self) -> 'Cte':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'NmodeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cte(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = NmodeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Cte_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Limit/Mper/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class MperCls:
+	"""Mper commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("mper", core, parent)
 
 	@property
-	def le1M(self):
-		"""le1M commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_le1M'):
-			from .LowEnergy_.Le1M import Le1M
-			self._le1M = Le1M(self._core, self._base)
-		return self._le1M
+	def lowEnergy(self):
+		"""lowEnergy commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_lowEnergy'):
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
+		return self._lowEnergy
 
-	@property
-	def le2M(self):
-		"""le2M commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_le2M'):
-			from .LowEnergy_.Le2M import Le2M
-			self._le2M = Le2M(self._core, self._base)
-		return self._le2M
-
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MperCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MperCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Cte_/LowEnergy_/Le1M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cte/LowEnergy/Le1M.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal import Conversions
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le1M:
-	"""Le1M commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class Le1MCls:
+	"""Le1M commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le1M", core, parent)
+		self._cmd_group = CommandsGroup("le1M", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_type_py(self) -> enums.CtePacketType:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:CTE:LENergy:LE1M:TYPE \n
 		Snippet: value: enums.CtePacketType = driver.configure.inputSignal.cte.lowEnergy.le1M.get_type_py() \n
 		Specifies the CTE slot type for LE with CTE. Commands for uncoded LE 1M PHY (..:LE1M..) and LE 2M PHY (..:LE2M..
 		) are available. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Cte_/LowEnergy_/Le2M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cte/LowEnergy/Le2M.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal import Conversions
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le2M:
-	"""Le2M commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class Le2MCls:
+	"""Le2M commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le2M", core, parent)
+		self._cmd_group = CommandsGroup("le2M", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_type_py(self) -> enums.CtePacketType:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:CTE:LENergy:LE2M:TYPE \n
 		Snippet: value: enums.CtePacketType = driver.configure.inputSignal.cte.lowEnergy.le2M.get_type_py() \n
 		Specifies the CTE slot type for LE with CTE. Commands for uncoded LE 1M PHY (..:LE1M..) and LE 2M PHY (..:LE2M..
 		) are available. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/DtMode/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DtMode:
-	"""DtMode commands group definition. 9 total commands, 3 Sub-groups, 0 group commands"""
+class DtModeCls:
+	"""DtMode commands group definition. 9 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dtMode", core, parent)
+		self._cmd_group = CommandsGroup("dtMode", core, parent)
 
 	@property
 	def rxQuality(self):
 		"""rxQuality commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_rxQuality'):
-			from .DtMode_.RxQuality import RxQuality
-			self._rxQuality = RxQuality(self._core, self._base)
+			from .RxQuality import RxQualityCls
+			self._rxQuality = RxQualityCls(self._core, self._cmd_group)
 		return self._rxQuality
 
 	@property
 	def plength(self):
 		"""plength commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_plength'):
-			from .DtMode_.Plength import Plength
-			self._plength = Plength(self._core, self._base)
+			from .Plength import PlengthCls
+			self._plength = PlengthCls(self._core, self._cmd_group)
 		return self._plength
 
 	@property
 	def pattern(self):
 		"""pattern commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_pattern'):
-			from .DtMode_.Pattern import Pattern
-			self._pattern = Pattern(self._core, self._base)
+			from .Pattern import PatternCls
+			self._pattern = PatternCls(self._core, self._cmd_group)
 		return self._pattern
 
-	def clone(self) -> 'DtMode':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'DtModeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = DtMode(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = DtModeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/Pattern.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/LowEnergy/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,27 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pattern:
-	"""Pattern commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class LowEnergyCls:
+	"""LowEnergy commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pattern", core, parent)
+		self._cmd_group = CommandsGroup("lowEnergy", core, parent)
 
 	@property
-	def lowEnergy(self):
-		"""lowEnergy commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_lowEnergy'):
-			from .Pattern_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
-		return self._lowEnergy
+	def le2M(self):
+		"""le2M commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_le2M'):
+			from .Le2M import Le2MCls
+			self._le2M = Le2MCls(self._core, self._cmd_group)
+		return self._le2M
 
-	def clone(self) -> 'Pattern':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def le1M(self):
+		"""le1M commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_le1M'):
+			from .Le1M import Le1MCls
+			self._le1M = Le1MCls(self._core, self._cmd_group)
+		return self._le1M
+
+	def clone(self) -> 'LowEnergyCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pattern(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LowEnergyCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/Plength.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Search/Rintegrity/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Plength:
-	"""Plength commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class RintegrityCls:
+	"""Rintegrity commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("plength", core, parent)
+		self._cmd_group = CommandsGroup("rintegrity", core, parent)
 
 	@property
 	def lowEnergy(self):
 		"""lowEnergy commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_lowEnergy'):
-			from .Plength_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
 		return self._lowEnergy
 
-	def clone(self) -> 'Plength':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RintegrityCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Plength(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RintegrityCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/Plength_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Plength/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,72 +1,86 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal import Conversions
+from typing import List
+
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class PlengthCls:
+	"""Plength commands group definition. 10 total commands, 2 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
-
-	def get_le_1_m(self) -> int:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DTMode:PLENgth:LENergy:LE1M \n
-		Snippet: value: int = driver.configure.inputSignal.dtMode.plength.lowEnergy.get_le_1_m() \n
-		Specifies the number of bytes (octets) in the payload data of the measured LE test packets. Commands for uncoded LE 1M
-		PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
-			:return: payload_length: numeric Payload lengths of LE packets Range: 0 Byte(s) to 255 Byte(s)
-		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DTMode:PLENgth:LENergy:LE1M?')
-		return Conversions.str_to_int(response)
-
-	def set_le_1_m(self, payload_length: int) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DTMode:PLENgth:LENergy:LE1M \n
-		Snippet: driver.configure.inputSignal.dtMode.plength.lowEnergy.set_le_1_m(payload_length = 1) \n
-		Specifies the number of bytes (octets) in the payload data of the measured LE test packets. Commands for uncoded LE 1M
-		PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
-			:param payload_length: numeric Payload lengths of LE packets Range: 0 Byte(s) to 255 Byte(s)
-		"""
-		param = Conversions.decimal_value_to_str(payload_length)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DTMode:PLENgth:LENergy:LE1M {param}')
-
-	def get_le_2_m(self) -> int:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DTMode:PLENgth:LENergy:LE2M \n
-		Snippet: value: int = driver.configure.inputSignal.dtMode.plength.lowEnergy.get_le_2_m() \n
-		Specifies the number of bytes (octets) in the payload data of the measured LE test packets. Commands for uncoded LE 1M
-		PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
-			:return: payload_length: numeric Payload lengths of LE packets Range: 0 Byte(s) to 255 Byte(s)
-		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DTMode:PLENgth:LENergy:LE2M?')
-		return Conversions.str_to_int(response)
-
-	def set_le_2_m(self, payload_length: int) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DTMode:PLENgth:LENergy:LE2M \n
-		Snippet: driver.configure.inputSignal.dtMode.plength.lowEnergy.set_le_2_m(payload_length = 1) \n
-		Specifies the number of bytes (octets) in the payload data of the measured LE test packets. Commands for uncoded LE 1M
-		PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
-			:param payload_length: numeric Payload lengths of LE packets Range: 0 Byte(s) to 255 Byte(s)
-		"""
-		param = Conversions.decimal_value_to_str(payload_length)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DTMode:PLENgth:LENergy:LE2M {param}')
+		self._cmd_group = CommandsGroup("plength", core, parent)
 
-	def get_lrange(self) -> int:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DTMode:PLENgth:LENergy:LRANge \n
-		Snippet: value: int = driver.configure.inputSignal.dtMode.plength.lowEnergy.get_lrange() \n
-		Specifies the number of bytes (octets) in the payload data of the measured LE test packets. Commands for uncoded LE 1M
-		PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
-			:return: payload_length: numeric Payload lengths of LE packets Range: 0 Byte(s) to 255 Byte(s)
-		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DTMode:PLENgth:LENergy:LRANge?')
-		return Conversions.str_to_int(response)
-
-	def set_lrange(self, payload_length: int) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DTMode:PLENgth:LENergy:LRANge \n
-		Snippet: driver.configure.inputSignal.dtMode.plength.lowEnergy.set_lrange(payload_length = 1) \n
-		Specifies the number of bytes (octets) in the payload data of the measured LE test packets. Commands for uncoded LE 1M
-		PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
-			:param payload_length: numeric Payload lengths of LE packets Range: 0 Byte(s) to 255 Byte(s)
-		"""
-		param = Conversions.decimal_value_to_str(payload_length)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DTMode:PLENgth:LENergy:LRANge {param}')
+	@property
+	def qhsl(self):
+		"""qhsl commands group. 0 Sub-classes, 5 commands."""
+		if not hasattr(self, '_qhsl'):
+			from .Qhsl import QhslCls
+			self._qhsl = QhslCls(self._core, self._cmd_group)
+		return self._qhsl
+
+	@property
+	def lowEnergy(self):
+		"""lowEnergy commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_lowEnergy'):
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
+		return self._lowEnergy
+
+	def get_brate(self) -> List[int]:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PLENgth:BRATe \n
+		Snippet: value: List[int] = driver.configure.inputSignal.plength.get_brate() \n
+		Specifies the number of bytes (octets) in the payload data of the measured BR signal. The range of values depends on the
+		packet type (method RsCmwBluetoothMeas.Configure.InputSignal.Ptype.brate) . The command requires 3 comma-separated
+		parameters, one for each BR packet type (order: DH1, DH3, DH5) . For the combined signal path scenario,
+		use CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:BRATe. \n
+			:return: payload_length: numeric 3 payload lengths for BR packets Range: 0 to 27 (DH1) , 0 to 183 (DH3) , 0 to 339 (DH5)
+		"""
+		response = self._core.io.query_bin_or_ascii_int_list('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PLENgth:BRATe?')
+		return response
+
+	def set_brate(self, payload_length: List[int]) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PLENgth:BRATe \n
+		Snippet: driver.configure.inputSignal.plength.set_brate(payload_length = [1, 2, 3]) \n
+		Specifies the number of bytes (octets) in the payload data of the measured BR signal. The range of values depends on the
+		packet type (method RsCmwBluetoothMeas.Configure.InputSignal.Ptype.brate) . The command requires 3 comma-separated
+		parameters, one for each BR packet type (order: DH1, DH3, DH5) . For the combined signal path scenario,
+		use CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:BRATe. \n
+			:param payload_length: numeric 3 payload lengths for BR packets Range: 0 to 27 (DH1) , 0 to 183 (DH3) , 0 to 339 (DH5)
+		"""
+		param = Conversions.list_to_csv_str(payload_length)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PLENgth:BRATe {param}')
+
+	def get_edrate(self) -> List[int]:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PLENgth:EDRate \n
+		Snippet: value: List[int] = driver.configure.inputSignal.plength.get_edrate() \n
+		Specifies the number of bytes (octets) in the payload data of the measured EDR signal. The range of values depends on the
+		packet type (method RsCmwBluetoothMeas.Configure.InputSignal.Ptype.edrate) . The command requires 6 comma-separated
+		parameters, one for each EDR packet type (order: 2-DH1, 2-DH3, 2-DH5, 3-DH1, 3-DH3, 3-DH5) . For the combined signal path
+		scenario, use CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:EDRate. \n
+			:return: payload_length: numeric 6 payload lengths for EDR packets Range: 0 to 54 (2-DH1) , 0 to 367 (2-DH3) , 0 to 679 (2-DH5) , 0 to 83 (3-DH1) , 0 to 552 (3-DH3) , 0 to 1021 (3-DH5)
+		"""
+		response = self._core.io.query_bin_or_ascii_int_list('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PLENgth:EDRate?')
+		return response
+
+	def set_edrate(self, payload_length: List[int]) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PLENgth:EDRate \n
+		Snippet: driver.configure.inputSignal.plength.set_edrate(payload_length = [1, 2, 3]) \n
+		Specifies the number of bytes (octets) in the payload data of the measured EDR signal. The range of values depends on the
+		packet type (method RsCmwBluetoothMeas.Configure.InputSignal.Ptype.edrate) . The command requires 6 comma-separated
+		parameters, one for each EDR packet type (order: 2-DH1, 2-DH3, 2-DH5, 3-DH1, 3-DH3, 3-DH5) . For the combined signal path
+		scenario, use CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:EDRate. \n
+			:param payload_length: numeric 6 payload lengths for EDR packets Range: 0 to 54 (2-DH1) , 0 to 367 (2-DH3) , 0 to 679 (2-DH5) , 0 to 83 (3-DH1) , 0 to 552 (3-DH3) , 0 to 1021 (3-DH5)
+		"""
+		param = Conversions.list_to_csv_str(payload_length)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PLENgth:EDRate {param}')
+
+	def clone(self) -> 'PlengthCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = PlengthCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/RxQuality.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Fec/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RxQuality:
-	"""RxQuality commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class FecCls:
+	"""Fec commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rxQuality", core, parent)
+		self._cmd_group = CommandsGroup("fec", core, parent)
 
 	@property
-	def plength(self):
-		"""plength commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_plength'):
-			from .RxQuality_.Plength import Plength
-			self._plength = Plength(self._core, self._base)
-		return self._plength
+	def lowEnergy(self):
+		"""lowEnergy commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_lowEnergy'):
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
+		return self._lowEnergy
 
-	def clone(self) -> 'RxQuality':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'FecCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = RxQuality(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = FecCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/RxQuality_/Plength.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Sacp/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Plength:
-	"""Plength commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class SacpCls:
+	"""Sacp commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("plength", core, parent)
+		self._cmd_group = CommandsGroup("sacp", core, parent)
 
 	@property
-	def lowEnergy(self):
-		"""lowEnergy commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_lowEnergy'):
-			from .Plength_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
-		return self._lowEnergy
+	def ptx(self):
+		"""ptx commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_ptx'):
+			from .Ptx import PtxCls
+			self._ptx = PtxCls(self._core, self._cmd_group)
+		return self._ptx
 
-	def clone(self) -> 'Plength':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SacpCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Plength(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SacpCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/DtMode_/RxQuality_/Plength_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/DtMode/RxQuality/Plength/LowEnergy.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class LowEnergyCls:
+	"""LowEnergy commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("lowEnergy", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_le_1_m(self) -> enums.PayloadLength:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:DTMode:RXQuality:PLENgth:LENergy:LE1M \n
 		Snippet: value: enums.PayloadLength = driver.configure.inputSignal.dtMode.rxQuality.plength.lowEnergy.get_le_1_m() \n
 		No command help available \n
 			:return: payload_length: No help available
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Fec.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cscheme/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Fec:
-	"""Fec commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class CschemeCls:
+	"""Cscheme commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("fec", core, parent)
+		self._cmd_group = CommandsGroup("cscheme", core, parent)
 
 	@property
 	def lowEnergy(self):
 		"""lowEnergy commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_lowEnergy'):
-			from .Fec_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
 		return self._lowEnergy
 
-	def clone(self) -> 'Fec':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CschemeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Fec(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CschemeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Fec_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Fec/LowEnergy.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class LowEnergyCls:
+	"""LowEnergy commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("lowEnergy", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_lrange(self) -> enums.CodingScheme:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:FEC:LENergy:LRANge \n
 		Snippet: value: enums.CodingScheme = driver.configure.inputSignal.fec.lowEnergy.get_lrange() \n
 		Defines S coding for LE coded PHY according to the core specification version 5.0 for Bluetooth wireless technology. For
 		the combined signal path scenario, use CONFigure:BLUetooth:SIGN<i>:CONNection:FEC:LENergy:LRANge \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/LowEnergy.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,34 +2,34 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 from ....Internal.Utilities import trim_str_response
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class LowEnergyCls:
+	"""LowEnergy commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("lowEnergy", core, parent)
 
 	def get_syn_word(self) -> str:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:LENergy:SYNWord \n
 		Snippet: value: str = driver.configure.inputSignal.lowEnergy.get_syn_word() \n
 		Specifies the synchronization word used during direct test mode. For the combined signal path scenario,
 		use CONFigure:BLUetooth:SIGN<i>:CONNection:SYNWord:LENergy \n
 			:return: synch_word: hex Range: #H0 to #HFFFFFFFF
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:LENergy:SYNWord?')
 		return trim_str_response(response)
 
 	def set_syn_word(self, synch_word: str) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:LENergy:SYNWord \n
-		Snippet: driver.configure.inputSignal.lowEnergy.set_syn_word(synch_word = r1) \n
+		Snippet: driver.configure.inputSignal.lowEnergy.set_syn_word(synch_word = rawAbc) \n
 		Specifies the synchronization word used during direct test mode. For the combined signal path scenario,
 		use CONFigure:BLUetooth:SIGN<i>:CONNection:SYNWord:LENergy \n
 			:param synch_word: hex Range: #H0 to #HFFFFFFFF
 		"""
 		param = Conversions.value_to_str(synch_word)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:LENergy:SYNWord {param}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Oslots.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Oslots/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Oslots:
-	"""Oslots commands group definition. 5 total commands, 1 Sub-groups, 2 group commands"""
+class OslotsCls:
+	"""Oslots commands group definition. 5 total commands, 1 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("oslots", core, parent)
+		self._cmd_group = CommandsGroup("oslots", core, parent)
 
 	@property
 	def lowEnergy(self):
 		"""lowEnergy commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_lowEnergy'):
-			from .Oslots_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
 		return self._lowEnergy
 
 	def get_edrate(self) -> List[int]:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:OSLots:EDRate \n
 		Snippet: value: List[int] = driver.configure.inputSignal.oslots.get_edrate() \n
 		Specifies the number of unused slots between any two occupied slots or slot sequences. \n
 			:return: no_of_off_slots: numeric Number of off slots for the different packet types: 3 values for BR packets (DH1, DH3, DH5) 6 values for EDR packets (2-DH1, 2-DH3, 2-DH5, 3-DH1, 3-DH3, 3-DH5) Range: 1 to 9
@@ -53,14 +53,14 @@
 		Snippet: driver.configure.inputSignal.oslots.set_brate(no_of_off_slots = [1, 2, 3]) \n
 		Specifies the number of unused slots between any two occupied slots or slot sequences. \n
 			:param no_of_off_slots: numeric Number of off slots for the different packet types: 3 values for BR packets (DH1, DH3, DH5) 6 values for EDR packets (2-DH1, 2-DH3, 2-DH5, 3-DH1, 3-DH3, 3-DH5) Range: 1 to 9
 		"""
 		param = Conversions.list_to_csv_str(no_of_off_slots)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:OSLots:BRATe {param}')
 
-	def clone(self) -> 'Oslots':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'OslotsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Oslots(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = OslotsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Oslots_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Oslots/LowEnergy.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class LowEnergyCls:
+	"""LowEnergy commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("lowEnergy", core, parent)
 
 	def get_le_1_m(self) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:OSLots:LENergy[:LE1M] \n
 		Snippet: value: int = driver.configure.inputSignal.oslots.lowEnergy.get_le_1_m() \n
 		Specifies the number of unused slots between any two occupied slots or slot sequences. Commands for LE 1M PHY (...:LE1M...
 		) and LE 2M PHY (...:LE2M...) are available. \n
 			:return: no_of_off_slots: numeric Range: 1 to 9, Unit: Multiplies of 625 µs
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Pattern.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Pattern/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pattern:
-	"""Pattern commands group definition. 4 total commands, 1 Sub-groups, 1 group commands"""
+class PatternCls:
+	"""Pattern commands group definition. 4 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pattern", core, parent)
+		self._cmd_group = CommandsGroup("pattern", core, parent)
 
 	@property
 	def lowEnergy(self):
 		"""lowEnergy commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_lowEnergy'):
-			from .Pattern_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
 		return self._lowEnergy
 
 	# noinspection PyTypeChecker
 	def get_value(self) -> enums.DetectedPatternType:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PATTern \n
 		Snippet: value: enums.DetectedPatternType = driver.configure.inputSignal.pattern.get_value() \n
 		Specifies the data pattern type that the EUT transmits as user payload data on its BR packets. The setting is not valid
@@ -43,14 +43,14 @@
 			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PATTern:BRATe
 			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PATTern:EDRate \n
 			:param pattern_type: P44 | P11 | OTHer | ALTernating P11: 10101010 P44: 11110000 OTHer: any pattern except P11, P44 ALTernating: the periodical change of the pattern P11 and P44
 		"""
 		param = Conversions.enum_scalar_to_str(pattern_type, enums.DetectedPatternType)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PATTern {param}')
 
-	def clone(self) -> 'Pattern':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PatternCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pattern(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PatternCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Pattern_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Pattern/LowEnergy.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,44 +1,44 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class LowEnergyCls:
+	"""LowEnergy commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("lowEnergy", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_le_1_m(self) -> enums.LePatternType:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PATTern:LENergy[:LE1M] \n
 		Snippet: value: enums.LePatternType = driver.configure.inputSignal.pattern.lowEnergy.get_le_1_m() \n
 		Specifies the data pattern type that the EUT transmits as user payload data in its LE packets. Commands for LE 1M PHY (...
 		:LE1M...) and LE 2M PHY (...:LE2M...) are available.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PATTern
+			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PATTern:LENergy[:LE1M]
 			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PATTern:LENergy:LE2M \n
-			:return: pattern_type: P44 | P11 | OTHer P11: '10101010' in transmission order (LSB first) P44: '11110000' in transmission order (LSB first) OTHer: any pattern except P11, P44 (see 'Low Energy Measurements in Direct Test Mode')
+			:return: pattern_type: P44 | P11 | OTHer P11: '10101010' in transmission order (LSB first) P44: '11110000' in transmission order (LSB first) OTHer: any pattern except P11, P44
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PATTern:LENergy:LE1M?')
 		return Conversions.str_to_scalar_enum(response, enums.LePatternType)
 
 	def set_le_1_m(self, pattern_type: enums.LePatternType) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PATTern:LENergy[:LE1M] \n
 		Snippet: driver.configure.inputSignal.pattern.lowEnergy.set_le_1_m(pattern_type = enums.LePatternType.OTHer) \n
 		Specifies the data pattern type that the EUT transmits as user payload data in its LE packets. Commands for LE 1M PHY (...
 		:LE1M...) and LE 2M PHY (...:LE2M...) are available.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PATTern
+			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PATTern:LENergy[:LE1M]
 			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PATTern:LENergy:LE2M \n
-			:param pattern_type: P44 | P11 | OTHer P11: '10101010' in transmission order (LSB first) P44: '11110000' in transmission order (LSB first) OTHer: any pattern except P11, P44 (see 'Low Energy Measurements in Direct Test Mode')
+			:param pattern_type: P44 | P11 | OTHer P11: '10101010' in transmission order (LSB first) P44: '11110000' in transmission order (LSB first) OTHer: any pattern except P11, P44
 		"""
 		param = Conversions.enum_scalar_to_str(pattern_type, enums.LePatternType)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PATTern:LENergy:LE1M {param}')
 
 	# noinspection PyTypeChecker
 	def get_lrange(self) -> enums.TransmitPatternType:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PATTern:LENergy:LRANge \n
@@ -63,26 +63,26 @@
 	# noinspection PyTypeChecker
 	def get_le_2_m(self) -> enums.LePatternType:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PATTern:LENergy:LE2M \n
 		Snippet: value: enums.LePatternType = driver.configure.inputSignal.pattern.lowEnergy.get_le_2_m() \n
 		Specifies the data pattern type that the EUT transmits as user payload data in its LE packets. Commands for LE 1M PHY (...
 		:LE1M...) and LE 2M PHY (...:LE2M...) are available.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PATTern
+			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PATTern:LENergy[:LE1M]
 			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PATTern:LENergy:LE2M \n
-			:return: pattern_type: P44 | P11 | OTHer P11: '10101010' in transmission order (LSB first) P44: '11110000' in transmission order (LSB first) OTHer: any pattern except P11, P44 (see 'Low Energy Measurements in Direct Test Mode')
+			:return: pattern_type: P44 | P11 | OTHer P11: '10101010' in transmission order (LSB first) P44: '11110000' in transmission order (LSB first) OTHer: any pattern except P11, P44
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PATTern:LENergy:LE2M?')
 		return Conversions.str_to_scalar_enum(response, enums.LePatternType)
 
 	def set_le_2_m(self, pattern_type: enums.LePatternType) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PATTern:LENergy:LE2M \n
 		Snippet: driver.configure.inputSignal.pattern.lowEnergy.set_le_2_m(pattern_type = enums.LePatternType.OTHer) \n
 		Specifies the data pattern type that the EUT transmits as user payload data in its LE packets. Commands for LE 1M PHY (...
 		:LE1M...) and LE 2M PHY (...:LE2M...) are available.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PATTern
+			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PATTern:LENergy[:LE1M]
 			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PATTern:LENergy:LE2M \n
-			:param pattern_type: P44 | P11 | OTHer P11: '10101010' in transmission order (LSB first) P44: '11110000' in transmission order (LSB first) OTHer: any pattern except P11, P44 (see 'Low Energy Measurements in Direct Test Mode')
+			:param pattern_type: P44 | P11 | OTHer P11: '10101010' in transmission order (LSB first) P44: '11110000' in transmission order (LSB first) OTHer: any pattern except P11, P44
 		"""
 		param = Conversions.enum_scalar_to_str(pattern_type, enums.LePatternType)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PATTern:LENergy:LE2M {param}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Plength_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Plength/LowEnergy.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,96 +1,96 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class LowEnergyCls:
+	"""LowEnergy commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("lowEnergy", core, parent)
 
 	def get_le_1_m(self) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PLENgth:LENergy[:LE1M] \n
 		Snippet: value: int = driver.configure.inputSignal.plength.lowEnergy.get_le_1_m() \n
-		Specifies the number of bytes (octets) in the payload data of the measured LE test packets. Commands for uncoded LE 1M
-		PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available.
+		Specifies the number of bytes (octets) in the payload data of the measured LE packets. Commands for uncoded LE 1M PHY (..
+		:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth
+			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:LENergy[:LE1M]
 			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:LENergy:LE2M
 			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:LENergy:LRANge \n
 			:return: payload_length: numeric Payload lengths for LE packets Range: 0 Byte(s) to 255 Byte(s) , Unit: byte
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PLENgth:LENergy:LE1M?')
 		return Conversions.str_to_int(response)
 
 	def set_le_1_m(self, payload_length: int) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PLENgth:LENergy[:LE1M] \n
 		Snippet: driver.configure.inputSignal.plength.lowEnergy.set_le_1_m(payload_length = 1) \n
-		Specifies the number of bytes (octets) in the payload data of the measured LE test packets. Commands for uncoded LE 1M
-		PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available.
+		Specifies the number of bytes (octets) in the payload data of the measured LE packets. Commands for uncoded LE 1M PHY (..
+		:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth
+			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:LENergy[:LE1M]
 			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:LENergy:LE2M
 			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:LENergy:LRANge \n
 			:param payload_length: numeric Payload lengths for LE packets Range: 0 Byte(s) to 255 Byte(s) , Unit: byte
 		"""
 		param = Conversions.decimal_value_to_str(payload_length)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PLENgth:LENergy:LE1M {param}')
 
 	def get_lrange(self) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PLENgth:LENergy:LRANge \n
 		Snippet: value: int = driver.configure.inputSignal.plength.lowEnergy.get_lrange() \n
-		Specifies the number of bytes (octets) in the payload data of the measured LE test packets. Commands for uncoded LE 1M
-		PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available.
+		Specifies the number of bytes (octets) in the payload data of the measured LE packets. Commands for uncoded LE 1M PHY (..
+		:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth
+			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:LENergy[:LE1M]
 			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:LENergy:LE2M
 			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:LENergy:LRANge \n
 			:return: payload_length: numeric Payload lengths for LE packets Range: 0 Byte(s) to 255 Byte(s) , Unit: byte
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PLENgth:LENergy:LRANge?')
 		return Conversions.str_to_int(response)
 
 	def set_lrange(self, payload_length: int) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PLENgth:LENergy:LRANge \n
 		Snippet: driver.configure.inputSignal.plength.lowEnergy.set_lrange(payload_length = 1) \n
-		Specifies the number of bytes (octets) in the payload data of the measured LE test packets. Commands for uncoded LE 1M
-		PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available.
+		Specifies the number of bytes (octets) in the payload data of the measured LE packets. Commands for uncoded LE 1M PHY (..
+		:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth
+			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:LENergy[:LE1M]
 			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:LENergy:LE2M
 			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:LENergy:LRANge \n
 			:param payload_length: numeric Payload lengths for LE packets Range: 0 Byte(s) to 255 Byte(s) , Unit: byte
 		"""
 		param = Conversions.decimal_value_to_str(payload_length)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PLENgth:LENergy:LRANge {param}')
 
 	def get_le_2_m(self) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PLENgth:LENergy:LE2M \n
 		Snippet: value: int = driver.configure.inputSignal.plength.lowEnergy.get_le_2_m() \n
-		Specifies the number of bytes (octets) in the payload data of the measured LE test packets. Commands for uncoded LE 1M
-		PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available.
+		Specifies the number of bytes (octets) in the payload data of the measured LE packets. Commands for uncoded LE 1M PHY (..
+		:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth
+			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:LENergy[:LE1M]
 			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:LENergy:LE2M
 			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:LENergy:LRANge \n
 			:return: payload_length: numeric Payload lengths for LE packets Range: 0 Byte(s) to 255 Byte(s) , Unit: byte
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PLENgth:LENergy:LE2M?')
 		return Conversions.str_to_int(response)
 
 	def set_le_2_m(self, payload_length: int) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PLENgth:LENergy:LE2M \n
 		Snippet: driver.configure.inputSignal.plength.lowEnergy.set_le_2_m(payload_length = 1) \n
-		Specifies the number of bytes (octets) in the payload data of the measured LE test packets. Commands for uncoded LE 1M
-		PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available.
+		Specifies the number of bytes (octets) in the payload data of the measured LE packets. Commands for uncoded LE 1M PHY (..
+		:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth
+			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:LENergy[:LE1M]
 			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:LENergy:LE2M
 			- CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PLENgth:LENergy:LRANge \n
 			:param payload_length: numeric Payload lengths for LE packets Range: 0 Byte(s) to 255 Byte(s) , Unit: byte
 		"""
 		param = Conversions.decimal_value_to_str(payload_length)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PLENgth:LENergy:LE2M {param}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Ptype.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Ptype/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,27 +1,35 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ptype:
-	"""Ptype commands group definition. 5 total commands, 1 Sub-groups, 2 group commands"""
+class PtypeCls:
+	"""Ptype commands group definition. 10 total commands, 2 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ptype", core, parent)
+		self._cmd_group = CommandsGroup("ptype", core, parent)
+
+	@property
+	def qhsl(self):
+		"""qhsl commands group. 0 Sub-classes, 5 commands."""
+		if not hasattr(self, '_qhsl'):
+			from .Qhsl import QhslCls
+			self._qhsl = QhslCls(self._core, self._cmd_group)
+		return self._qhsl
 
 	@property
 	def lowEnergy(self):
 		"""lowEnergy commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_lowEnergy'):
-			from .Ptype_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
 		return self._lowEnergy
 
 	# noinspection PyTypeChecker
 	def get_edrate(self) -> enums.EdrPacketType:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PTYPe:EDRate \n
 		Snippet: value: enums.EdrPacketType = driver.configure.inputSignal.ptype.get_edrate() \n
 		Specifies the EDR packet type of the measured signal. For the combined signal path scenario,
@@ -58,14 +66,14 @@
 		Specifies the BR packet type of the measured signal. For the combined signal path scenario,
 		use CONFigure:BLUetooth:SIGN<i>:CONNection:PACKets:PTYPe:BRATe. \n
 			:param packet_type: DH1 | DH3 | DH5
 		"""
 		param = Conversions.enum_scalar_to_str(packet_type, enums.BrPacketType)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PTYPe:BRATe {param}')
 
-	def clone(self) -> 'Ptype':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PtypeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Ptype(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PtypeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/Ptype_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Ptype/LowEnergy.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class LowEnergyCls:
+	"""LowEnergy commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("lowEnergy", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_le_1_m(self) -> enums.LePacketType:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:PTYPe:LENergy[:LE1M] \n
 		Snippet: value: enums.LePacketType = driver.configure.inputSignal.ptype.lowEnergy.get_le_1_m() \n
 		Specifies the packet type of the measured signal for LE uncoded PHY (LE 1M and LE 2M) . Data channel packet cannot be
 		selected. It is only automatically selected in combined signal path with LE connection tests. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/InputSignal_/SynWord.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/SynWord.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,31 +1,31 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 from ....Internal.Utilities import trim_str_response
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SynWord:
-	"""SynWord commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SynWordCls:
+	"""SynWord commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("synWord", core, parent)
+		self._cmd_group = CommandsGroup("synWord", core, parent)
 
 	def get_low_energy(self) -> str:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:SYNWord:LENergy \n
 		Snippet: value: str = driver.configure.inputSignal.synWord.get_low_energy() \n
 		No command help available \n
 			:return: synch_word: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:SYNWord:LENergy?')
 		return trim_str_response(response)
 
 	def set_low_energy(self, synch_word: str) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:SYNWord:LENergy \n
-		Snippet: driver.configure.inputSignal.synWord.set_low_energy(synch_word = r1) \n
+		Snippet: driver.configure.inputSignal.synWord.set_low_energy(synch_word = rawAbc) \n
 		No command help available \n
 			:param synch_word: No help available
 		"""
 		param = Conversions.value_to_str(synch_word)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:SYNWord:LENergy {param}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Brate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RfSettings/Cte/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Brate:
-	"""Brate commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class CteCls:
+	"""Cte commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("brate", core, parent)
+		self._cmd_group = CommandsGroup("cte", core, parent)
 
 	@property
-	def filterPy(self):
-		"""filterPy commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_filterPy'):
-			from .Brate_.FilterPy import FilterPy
-			self._filterPy = FilterPy(self._core, self._base)
-		return self._filterPy
+	def lowEnergy(self):
+		"""lowEnergy commands group. 1 Sub-classes, 2 commands."""
+		if not hasattr(self, '_lowEnergy'):
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
+		return self._lowEnergy
 
-	def clone(self) -> 'Brate':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CteCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Brate(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CteCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Brate_/FilterPy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/LowEnergy/Lrange/FilterPy.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,32 +1,34 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from ..... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class FilterPy:
-	"""FilterPy commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class FilterPyCls:
+	"""FilterPy commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("filterPy", core, parent)
+		self._cmd_group = CommandsGroup("filterPy", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_bandwidth(self) -> enums.FilterWidth:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:BRATe:FILTer:BWIDth \n
-		Snippet: value: enums.FilterWidth = driver.configure.multiEval.brate.filterPy.get_bandwidth() \n
-		Selects the filter bandwidth for BR measurements. \n
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LENergy:LRANge:FILTer:BWIDth \n
+		Snippet: value: enums.FilterWidth = driver.configure.multiEval.lowEnergy.lrange.filterPy.get_bandwidth() \n
+		Selects the filter bandwidth. Commands for uncoded LE 1M PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..
+		:LRANge..) are available. \n
 			:return: filter_bandwidth: NARRow | WIDE NARRow: Narrow-band filter WIDE: Wide-band filter
 		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:BRATe:FILTer:BWIDth?')
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LENergy:LRANge:FILTer:BWIDth?')
 		return Conversions.str_to_scalar_enum(response, enums.FilterWidth)
 
 	def set_bandwidth(self, filter_bandwidth: enums.FilterWidth) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:BRATe:FILTer:BWIDth \n
-		Snippet: driver.configure.multiEval.brate.filterPy.set_bandwidth(filter_bandwidth = enums.FilterWidth.NARRow) \n
-		Selects the filter bandwidth for BR measurements. \n
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LENergy:LRANge:FILTer:BWIDth \n
+		Snippet: driver.configure.multiEval.lowEnergy.lrange.filterPy.set_bandwidth(filter_bandwidth = enums.FilterWidth.NARRow) \n
+		Selects the filter bandwidth. Commands for uncoded LE 1M PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..
+		:LRANge..) are available. \n
 			:param filter_bandwidth: NARRow | WIDE NARRow: Narrow-band filter WIDE: Wide-band filter
 		"""
 		param = Conversions.enum_scalar_to_str(filter_bandwidth, enums.FilterWidth)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:BRATe:FILTer:BWIDth {param}')
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LENergy:LRANge:FILTer:BWIDth {param}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Edrate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/LowEnergy/Le1M/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Edrate:
-	"""Edrate commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class Le1MCls:
+	"""Le1M commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("edrate", core, parent)
+		self._cmd_group = CommandsGroup("le1M", core, parent)
 
 	@property
 	def filterPy(self):
 		"""filterPy commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_filterPy'):
-			from .Edrate_.FilterPy import FilterPy
-			self._filterPy = FilterPy(self._core, self._base)
+			from .FilterPy import FilterPyCls
+			self._filterPy = FilterPyCls(self._core, self._cmd_group)
 		return self._filterPy
 
-	def clone(self) -> 'Edrate':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'Le1MCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Edrate(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = Le1MCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Edrate_/FilterPy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Edrate/FilterPy.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class FilterPy:
-	"""FilterPy commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class FilterPyCls:
+	"""FilterPy commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("filterPy", core, parent)
+		self._cmd_group = CommandsGroup("filterPy", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_bandwidth(self) -> enums.FilterWidth:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:EDRate:FILTer:BWIDth \n
 		Snippet: value: enums.FilterWidth = driver.configure.multiEval.edrate.filterPy.get_bandwidth() \n
 		Selects the filter bandwidth for EDR measurements. The filter is applied only to the GFSK portion of the bursts. \n
 			:return: filter_bandwidth: NARRow | WIDE NARRow: Narrow-band filter WIDE: Wide-band filter
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Frange.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Brate/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Frange:
-	"""Frange commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class BrateCls:
+	"""Brate commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("frange", core, parent)
+		self._cmd_group = CommandsGroup("brate", core, parent)
 
 	@property
-	def brate(self):
-		"""brate commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_brate'):
-			from .Frange_.Brate import Brate
-			self._brate = Brate(self._core, self._base)
-		return self._brate
+	def ptx(self):
+		"""ptx commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_ptx'):
+			from .Ptx import PtxCls
+			self._ptx = PtxCls(self._core, self._cmd_group)
+		return self._ptx
 
-	def clone(self) -> 'Frange':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'BrateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Frange(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = BrateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Frange_/Brate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Frange/Brate/Measurement.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,48 +1,53 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ......Internal.ArgSingleList import ArgSingleList
+from ......Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Brate:
-	"""Brate commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MeasurementCls:
+	"""Measurement commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("brate", core, parent)
+		self._cmd_group = CommandsGroup("measurement", core, parent)
+
+	def set(self, left_channel: int, right_channel: int, threshold: float) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:FRANge:BRATe:MEASurement \n
+		Snippet: driver.configure.multiEval.frange.brate.measurement.set(left_channel = 1, right_channel = 1, threshold = 1.0) \n
+		Specifies the number of 1 MHz channels to be measured below and above the current measured channel. The threshold is the
+		level that needs to be crossed to search the frequencies fL and fH. \n
+			:param left_channel: numeric Left adjacent channel relative to the EUT center TX channel Range: 1 to 5
+			:param right_channel: numeric Right adjacent channel relative to the EUT center TX channel Range: 1 to 5
+			:param threshold: numeric Threshold for the spectral power density drop to search the frequencies fL and fH Specification defines - 80 dBm/Hz for equivalent isotropically radiated power or - 30 dBm if measured in a 100 kHz bandwidth. Range: -80 dBm to 40 dBm
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('left_channel', left_channel, DataType.Integer), ArgSingle('right_channel', right_channel, DataType.Integer), ArgSingle('threshold', threshold, DataType.Float))
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:FRANge:BRATe:MEASurement {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class MeasurementStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
+		"""Response structure. Fields: \n
 			- Left_Channel: int: numeric Left adjacent channel relative to the EUT center TX channel Range: 1 to 5
 			- Right_Channel: int: numeric Right adjacent channel relative to the EUT center TX channel Range: 1 to 5
 			- Threshold: float: numeric Threshold for the spectral power density drop to search the frequencies fL and fH Specification defines - 80 dBm/Hz for equivalent isotropically radiated power or - 30 dBm if measured in a 100 kHz bandwidth. Range: -80 dBm to 40 dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Left_Channel'),
 			ArgStruct.scalar_int('Right_Channel'),
 			ArgStruct.scalar_float('Threshold')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Left_Channel: int = None
 			self.Right_Channel: int = None
 			self.Threshold: float = None
 
-	def get_measurement(self) -> MeasurementStruct:
+	def get(self) -> MeasurementStruct:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:FRANge:BRATe:MEASurement \n
-		Snippet: value: MeasurementStruct = driver.configure.multiEval.frange.brate.get_measurement() \n
+		Snippet: value: MeasurementStruct = driver.configure.multiEval.frange.brate.measurement.get() \n
 		Specifies the number of 1 MHz channels to be measured below and above the current measured channel. The threshold is the
 		level that needs to be crossed to search the frequencies fL and fH. \n
-			:return: structure: for return value, see the help for MeasurementStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:FRANge:BRATe:MEASurement?', self.__class__.MeasurementStruct())
-
-	def set_measurement(self, value: MeasurementStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:FRANge:BRATe:MEASurement \n
-		Snippet: driver.configure.multiEval.frange.brate.set_measurement(value = MeasurementStruct()) \n
-		Specifies the number of 1 MHz channels to be measured below and above the current measured channel. The threshold is the
-		level that needs to be crossed to search the frequencies fL and fH. \n
-			:param value: see the help for MeasurementStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:FRANge:BRATe:MEASurement', value)
+			:return: structure: for return value, see the help for MeasurementStruct structure arguments."""
+		return self._core.io.query_struct(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:FRANge:BRATe:MEASurement?', self.__class__.MeasurementStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Brate/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,258 +1,220 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.Types import DataType
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Limit:
-	"""Limit commands group definition. 61 total commands, 4 Sub-groups, 5 group commands"""
+class BrateCls:
+	"""Brate commands group definition. 9 total commands, 5 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("limit", core, parent)
+		self._cmd_group = CommandsGroup("brate", core, parent)
 
 	@property
-	def lowEnergy(self):
-		"""lowEnergy commands group. 6 Sub-classes, 1 commands."""
-		if not hasattr(self, '_lowEnergy'):
-			from .Limit_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
-		return self._lowEnergy
+	def powerVsTime(self):
+		"""powerVsTime commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_powerVsTime'):
+			from .PowerVsTime import PowerVsTimeCls
+			self._powerVsTime = PowerVsTimeCls(self._core, self._cmd_group)
+		return self._powerVsTime
 
 	@property
-	def cte(self):
-		"""cte commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_cte'):
-			from .Limit_.Cte import Cte
-			self._cte = Cte(self._core, self._base)
-		return self._cte
+	def mratio(self):
+		"""mratio commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_mratio'):
+			from .Mratio import MratioCls
+			self._mratio = MratioCls(self._core, self._cmd_group)
+		return self._mratio
 
 	@property
-	def edrate(self):
-		"""edrate commands group. 3 Sub-classes, 2 commands."""
-		if not hasattr(self, '_edrate'):
-			from .Limit_.Edrate import Edrate
-			self._edrate = Edrate(self._core, self._base)
-		return self._edrate
+	def delta(self):
+		"""delta commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_delta'):
+			from .Delta import DeltaCls
+			self._delta = DeltaCls(self._core, self._cmd_group)
+		return self._delta
 
 	@property
-	def brate(self):
-		"""brate commands group. 1 Sub-classes, 7 commands."""
-		if not hasattr(self, '_brate'):
-			from .Limit_.Brate import Brate
-			self._brate = Brate(self._core, self._base)
-		return self._brate
+	def fdrift(self):
+		"""fdrift commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_fdrift'):
+			from .Fdrift import FdriftCls
+			self._fdrift = FdriftCls(self._core, self._cmd_group)
+		return self._fdrift
 
-	# noinspection PyTypeChecker
-	class FrangeStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Flx_Lower: float: numeric Lower limit for the lowest frequency fL relative to center frequency Range: -5 MHz to 0 MHz, Unit: Hz
-			- Fhx_Upper: float: numeric Upper limit for the highest frequency fH relative to center frequency Range: 0 MHz to 5 MHz, Unit: Hz
-			- Flx_Lower_Enable: bool: OFF | ON Disable or enable limit check for the lowest frequency fL
-			- Fhx_Upper_Enable: bool: OFF | ON Disable or enable limit check for the highest frequency fH"""
-		__meta_args_list = [
-			ArgStruct.scalar_float('Flx_Lower'),
-			ArgStruct.scalar_float('Fhx_Upper'),
-			ArgStruct.scalar_bool('Flx_Lower_Enable'),
-			ArgStruct.scalar_bool('Fhx_Upper_Enable')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Flx_Lower: float = None
-			self.Fhx_Upper: float = None
-			self.Flx_Lower_Enable: bool = None
-			self.Fhx_Upper_Enable: bool = None
-
-	def get_frange(self) -> FrangeStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:FRANge \n
-		Snippet: value: FrangeStruct = driver.configure.multiEval.limit.get_frange() \n
-		Defines the limit for the frequency range measurement. \n
-			:return: structure: for return value, see the help for FrangeStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:FRANge?', self.__class__.FrangeStruct())
-
-	def set_frange(self, value: FrangeStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:FRANge \n
-		Snippet: driver.configure.multiEval.limit.set_frange(value = FrangeStruct()) \n
-		Defines the limit for the frequency range measurement. \n
-			:param value: see the help for FrangeStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:FRANge', value)
-
-	# noinspection PyTypeChecker
-	class SacpStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Ptx_Limit: float: numeric Power limit for 1 MHz channels fTX± 2 MHz Range: -80 dBm to -10 dBm
-			- Exc_Ptx_Limit: float: numeric Power limit for 1 MHz channels fTX±3 MHz, fTX±4 MHz, ... Range: -80 dBm to -10 dBm
-			- No_Of_Ex_Limit: int: numeric Maximum number of tolerable exceptions, i.e. 1 MHz channels fTX±3 MHz, fTX±4 MHz, ... whose power is above ExcPTxLimit, but below PTxLimit Range: 0 to 16
-			- Ptx_Enable: bool: OFF | ON Disables | enables the PTxLimit limit for 1 MHz channels fTX± 2 MHz
-			- No_Of_Exc_Enable: bool: OFF | ON Disables | enables the ExcPTxLimit limit for 1 MHz channels fTX±3 MHz, fTX±4 MHz, ... with NoOfExLimit tolerable exceptions (per statistic cycle) ."""
-		__meta_args_list = [
-			ArgStruct.scalar_float('Ptx_Limit'),
-			ArgStruct.scalar_float('Exc_Ptx_Limit'),
-			ArgStruct.scalar_int('No_Of_Ex_Limit'),
-			ArgStruct.scalar_bool('Ptx_Enable'),
-			ArgStruct.scalar_bool('No_Of_Exc_Enable')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Ptx_Limit: float = None
-			self.Exc_Ptx_Limit: float = None
-			self.No_Of_Ex_Limit: int = None
-			self.Ptx_Enable: bool = None
-			self.No_Of_Exc_Enable: bool = None
-
-	def get_sacp(self) -> SacpStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:SACP \n
-		Snippet: value: SacpStruct = driver.configure.multiEval.limit.get_sacp() \n
-		These commands define and enable the 'Spectrum ACP' limits for BR (...:LIMit:SACP) , LE 1M PHY ( ...:LE1M...) , LE 2M PHY
-		(...:LE2M...) , and LE coded PHY (...:LRANge...) , respectively. \n
-			:return: structure: for return value, see the help for SacpStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:SACP?', self.__class__.SacpStruct())
-
-	def set_sacp(self, value: SacpStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:SACP \n
-		Snippet: driver.configure.multiEval.limit.set_sacp(value = SacpStruct()) \n
-		These commands define and enable the 'Spectrum ACP' limits for BR (...:LIMit:SACP) , LE 1M PHY ( ...:LE1M...) , LE 2M PHY
-		(...:LE2M...) , and LE coded PHY (...:LRANge...) , respectively. \n
-			:param value: see the help for SacpStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:SACP', value)
+	@property
+	def faccuracy(self):
+		"""faccuracy commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_faccuracy'):
+			from .Faccuracy import FaccuracyCls
+			self._faccuracy = FaccuracyCls(self._core, self._cmd_group)
+		return self._faccuracy
 
 	# noinspection PyTypeChecker
-	class SoBwStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Limit_Threshold: float: numeric Threshold value for 'high' vs 'low' peak emission bursts Range: -80 dBm to 40 dBm
-			- Eq_High_Peak_Upper: float: numeric 20 dB bandwidth limit for 'high' peak emission bursts (≥LimitThreshold) Range: 1E-3 MHz to 4 MHz
-			- Low_Peak_Upper: float: numeric 20 dB bandwidth limit for 'low' peak emission bursts ( LimitThreshold) Range: 1E-3 MHz to 4 MHz
-			- Eq_High_Peak_Enable: bool: OFF | ON Disable or enable the 20 dB bandwidth limit for 'high' peak emission bursts
-			- Low_Peak_Enable: bool: OFF | ON Disable or enable the 20 dB bandwidth limit for 'low' peak emission bursts"""
+	class DaverageStruct(StructBase):  # From WriteStructDefinition CmdPropertyTemplate.xml
+		"""Structure for setting input parameters. Fields: \n
+			- Freq_Dev_F_1_Lower: float: numeric Range: 0 Hz to 500 kHz
+			- Freq_Dev_F_1_Upper: float: numeric Range: 0 Hz to 500 kHz
+			- Freq_Dev_F_2_Lower: float: numeric Range: 0 Hz to 500 kHz
+			- Freq_Dev_F_2_Upper: float: numeric Range: 0 Hz to 500 kHz
+			- Freq_Dev_F_1_Enable: List[bool]: OFF | ON Disable or enable limits for current, average, maximum, and minimum results (4 values) .
+			- Freq_Dev_F_2_Enable: List[bool]: OFF | ON Disable or enable limits for current, average, maximum, and minimum results (4 values) ."""
 		__meta_args_list = [
-			ArgStruct.scalar_float('Limit_Threshold'),
-			ArgStruct.scalar_float('Eq_High_Peak_Upper'),
-			ArgStruct.scalar_float('Low_Peak_Upper'),
-			ArgStruct.scalar_bool('Eq_High_Peak_Enable'),
-			ArgStruct.scalar_bool('Low_Peak_Enable')]
+			ArgStruct.scalar_float('Freq_Dev_F_1_Lower'),
+			ArgStruct.scalar_float('Freq_Dev_F_1_Upper'),
+			ArgStruct.scalar_float('Freq_Dev_F_2_Lower'),
+			ArgStruct.scalar_float('Freq_Dev_F_2_Upper'),
+			ArgStruct('Freq_Dev_F_1_Enable', DataType.BooleanList, None, False, False, 4),
+			ArgStruct('Freq_Dev_F_2_Enable', DataType.BooleanList, None, False, False, 4)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Limit_Threshold: float = None
-			self.Eq_High_Peak_Upper: float = None
-			self.Low_Peak_Upper: float = None
-			self.Eq_High_Peak_Enable: bool = None
-			self.Low_Peak_Enable: bool = None
-
-	def get_so_bw(self) -> SoBwStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:SOBW \n
-		Snippet: value: SoBwStruct = driver.configure.multiEval.limit.get_so_bw() \n
-		Defines and enables the limits for the 20 dB bandwidth measurement (BR only) . \n
-			:return: structure: for return value, see the help for SoBwStruct structure arguments.
+			self.Freq_Dev_F_1_Lower: float = None
+			self.Freq_Dev_F_1_Upper: float = None
+			self.Freq_Dev_F_2_Lower: float = None
+			self.Freq_Dev_F_2_Upper: float = None
+			self.Freq_Dev_F_1_Enable: List[bool] = None
+			self.Freq_Dev_F_2_Enable: List[bool] = None
+
+	def get_daverage(self) -> DaverageStruct:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:DAVerage \n
+		Snippet: value: DaverageStruct = driver.configure.multiEval.limit.brate.get_daverage() \n
+		Defines the lower and upper frequency deviation limits for BR bursts. The mnemonics DAVerage, DMAXimum, DMINimum
+		distinguish average, maximum, and minimum frequency deviations. \n
+			:return: structure: for return value, see the help for DaverageStruct structure arguments.
+		"""
+		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:DAVerage?', self.__class__.DaverageStruct())
+
+	def set_daverage(self, value: DaverageStruct) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:DAVerage \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.limit.brate.DaverageStruct() \n
+		structure.Freq_Dev_F_1_Lower: float = 1.0 \n
+		structure.Freq_Dev_F_1_Upper: float = 1.0 \n
+		structure.Freq_Dev_F_2_Lower: float = 1.0 \n
+		structure.Freq_Dev_F_2_Upper: float = 1.0 \n
+		structure.Freq_Dev_F_1_Enable: List[bool] = [True, False, True] \n
+		structure.Freq_Dev_F_2_Enable: List[bool] = [True, False, True] \n
+		driver.configure.multiEval.limit.brate.set_daverage(value = structure) \n
+		Defines the lower and upper frequency deviation limits for BR bursts. The mnemonics DAVerage, DMAXimum, DMINimum
+		distinguish average, maximum, and minimum frequency deviations. \n
+			:param value: see the help for DaverageStruct structure arguments.
 		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:SOBW?', self.__class__.SoBwStruct())
-
-	def set_so_bw(self, value: SoBwStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:SOBW \n
-		Snippet: driver.configure.multiEval.limit.set_so_bw(value = SoBwStruct()) \n
-		Defines and enables the limits for the 20 dB bandwidth measurement (BR only) . \n
-			:param value: see the help for SoBwStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:SOBW', value)
+		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:DAVerage', value)
 
 	# noinspection PyTypeChecker
-	class SgacpStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Ptx_Limit: float: numeric Range: -80 dBm to -10 dBm
-			- Exc_Ptx_Limit: float: numeric Range: -80 dBm to -10 dBm
-			- No_Of_Ex_Limit: int: numeric Range: 0 to 16
-			- Ptxm_26_N_1_Rel_Lim: float: numeric Range: -80 dB to 0 dB
-			- Ptxm_26_P_1_Rel_Lim: float: numeric Range: -80 dB to 0 dB
-			- Ptx_Enable: bool: OFF | ON
-			- No_Of_Exc_Enable: bool: OFF | ON
-			- Ptxm_26_N_1_Rel_Enable: bool: OFF | ON
-			- Ptxm_26_P_1_Rel_Enable: bool: OFF | ON"""
+	class DminimumStruct(StructBase):  # From WriteStructDefinition CmdPropertyTemplate.xml
+		"""Structure for setting input parameters. Fields: \n
+			- Freq_Dev_F_1_Lower: float: numeric Range: 0 Hz to 500 kHz
+			- Freq_Dev_F_1_Upper: float: numeric Range: 0 Hz to 500 kHz
+			- Freq_Dev_F_2_Lower: float: numeric Range: 0 Hz to 500 kHz
+			- Freq_Dev_F_2_Upper: float: numeric Range: 0 Hz to 500 kHz
+			- Freq_Dev_F_1_Enable: List[bool]: OFF | ON Disable or enable limits for current, average, maximum, and minimum results (4 values) .
+			- Freq_Dev_F_2_Enable: List[bool]: OFF | ON Disable or enable limits for current, average, maximum, and minimum results (4 values) ."""
 		__meta_args_list = [
-			ArgStruct.scalar_float('Ptx_Limit'),
-			ArgStruct.scalar_float('Exc_Ptx_Limit'),
-			ArgStruct.scalar_int('No_Of_Ex_Limit'),
-			ArgStruct.scalar_float('Ptxm_26_N_1_Rel_Lim'),
-			ArgStruct.scalar_float('Ptxm_26_P_1_Rel_Lim'),
-			ArgStruct.scalar_bool('Ptx_Enable'),
-			ArgStruct.scalar_bool('No_Of_Exc_Enable'),
-			ArgStruct.scalar_bool('Ptxm_26_N_1_Rel_Enable'),
-			ArgStruct.scalar_bool('Ptxm_26_P_1_Rel_Enable')]
+			ArgStruct.scalar_float('Freq_Dev_F_1_Lower'),
+			ArgStruct.scalar_float('Freq_Dev_F_1_Upper'),
+			ArgStruct.scalar_float('Freq_Dev_F_2_Lower'),
+			ArgStruct.scalar_float('Freq_Dev_F_2_Upper'),
+			ArgStruct('Freq_Dev_F_1_Enable', DataType.BooleanList, None, False, False, 4),
+			ArgStruct('Freq_Dev_F_2_Enable', DataType.BooleanList, None, False, False, 4)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Ptx_Limit: float = None
-			self.Exc_Ptx_Limit: float = None
-			self.No_Of_Ex_Limit: int = None
-			self.Ptxm_26_N_1_Rel_Lim: float = None
-			self.Ptxm_26_P_1_Rel_Lim: float = None
-			self.Ptx_Enable: bool = None
-			self.No_Of_Exc_Enable: bool = None
-			self.Ptxm_26_N_1_Rel_Enable: bool = None
-			self.Ptxm_26_P_1_Rel_Enable: bool = None
-
-	def get_sgacp(self) -> SgacpStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:SGACp \n
-		Snippet: value: SgacpStruct = driver.configure.multiEval.limit.get_sgacp() \n
-		Defines and enables the upper limits for the 'Spectrum Gated ACP' measurement for EDR packets: 'PTx', 'Exceptions PTx',
-		'No. of Exceptions', PTx–26 dB–1 (rel) , PTx–26 dB +1 (rel) , and limit check enabling. \n
-			:return: structure: for return value, see the help for SgacpStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:SGACp?', self.__class__.SgacpStruct())
-
-	def set_sgacp(self, value: SgacpStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:SGACp \n
-		Snippet: driver.configure.multiEval.limit.set_sgacp(value = SgacpStruct()) \n
-		Defines and enables the upper limits for the 'Spectrum Gated ACP' measurement for EDR packets: 'PTx', 'Exceptions PTx',
-		'No. of Exceptions', PTx–26 dB–1 (rel) , PTx–26 dB +1 (rel) , and limit check enabling. \n
-			:param value: see the help for SgacpStruct structure arguments.
+			self.Freq_Dev_F_1_Lower: float = None
+			self.Freq_Dev_F_1_Upper: float = None
+			self.Freq_Dev_F_2_Lower: float = None
+			self.Freq_Dev_F_2_Upper: float = None
+			self.Freq_Dev_F_1_Enable: List[bool] = None
+			self.Freq_Dev_F_2_Enable: List[bool] = None
+
+	def get_dminimum(self) -> DminimumStruct:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:DMINimum \n
+		Snippet: value: DminimumStruct = driver.configure.multiEval.limit.brate.get_dminimum() \n
+		Defines the lower and upper frequency deviation limits for BR bursts. The mnemonics DAVerage, DMAXimum, DMINimum
+		distinguish average, maximum, and minimum frequency deviations. \n
+			:return: structure: for return value, see the help for DminimumStruct structure arguments.
+		"""
+		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:DMINimum?', self.__class__.DminimumStruct())
+
+	def set_dminimum(self, value: DminimumStruct) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:DMINimum \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.limit.brate.DminimumStruct() \n
+		structure.Freq_Dev_F_1_Lower: float = 1.0 \n
+		structure.Freq_Dev_F_1_Upper: float = 1.0 \n
+		structure.Freq_Dev_F_2_Lower: float = 1.0 \n
+		structure.Freq_Dev_F_2_Upper: float = 1.0 \n
+		structure.Freq_Dev_F_1_Enable: List[bool] = [True, False, True] \n
+		structure.Freq_Dev_F_2_Enable: List[bool] = [True, False, True] \n
+		driver.configure.multiEval.limit.brate.set_dminimum(value = structure) \n
+		Defines the lower and upper frequency deviation limits for BR bursts. The mnemonics DAVerage, DMAXimum, DMINimum
+		distinguish average, maximum, and minimum frequency deviations. \n
+			:param value: see the help for DminimumStruct structure arguments.
 		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:SGACp', value)
+		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:DMINimum', value)
 
 	# noinspection PyTypeChecker
-	class PowerVsTimeStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Pack_Time_Lower: float: numeric Range: -15 µs to 15 µs
-			- Pack_Time_Upper: float: numeric Range: -15 µs to 15 µs
-			- Pack_Time_Enable: List[bool]: OFF | ON"""
+	class DmaximumStruct(StructBase):  # From WriteStructDefinition CmdPropertyTemplate.xml
+		"""Structure for setting input parameters. Fields: \n
+			- Freq_Dev_F_1_Lower: float: numeric Range: 0 Hz to 500 kHz
+			- Freq_Dev_F_1_Upper: float: numeric Range: 0 Hz to 500 kHz
+			- Freq_Dev_F_2_Lower: float: numeric Range: 0 Hz to 500 kHz
+			- Freq_Dev_F_2_Upper: float: numeric Range: 0 Hz to 500 kHz
+			- Freq_Dev_F_1_Enable: List[bool]: OFF | ON Disable or enable limits for current, average, maximum, and minimum results (4 values) .
+			- Freq_Dev_F_2_Enable: List[bool]: OFF | ON Disable or enable limits for current, average, maximum, and minimum results (4 values) ."""
 		__meta_args_list = [
-			ArgStruct.scalar_float('Pack_Time_Lower'),
-			ArgStruct.scalar_float('Pack_Time_Upper'),
-			ArgStruct('Pack_Time_Enable', DataType.BooleanList, None, False, False, 4)]
+			ArgStruct.scalar_float('Freq_Dev_F_1_Lower'),
+			ArgStruct.scalar_float('Freq_Dev_F_1_Upper'),
+			ArgStruct.scalar_float('Freq_Dev_F_2_Lower'),
+			ArgStruct.scalar_float('Freq_Dev_F_2_Upper'),
+			ArgStruct('Freq_Dev_F_1_Enable', DataType.BooleanList, None, False, False, 4),
+			ArgStruct('Freq_Dev_F_2_Enable', DataType.BooleanList, None, False, False, 4)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Pack_Time_Lower: float = None
-			self.Pack_Time_Upper: float = None
-			self.Pack_Time_Enable: List[bool] = None
-
-	def get_power_vs_time(self) -> PowerVsTimeStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:PVTime \n
-		Snippet: value: PowerVsTimeStruct = driver.configure.multiEval.limit.get_power_vs_time() \n
-		Sets and enables/disables a lower and upper timing error limit for PVT measurements. \n
-			:return: structure: for return value, see the help for PowerVsTimeStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:PVTime?', self.__class__.PowerVsTimeStruct())
-
-	def set_power_vs_time(self, value: PowerVsTimeStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:PVTime \n
-		Snippet: driver.configure.multiEval.limit.set_power_vs_time(value = PowerVsTimeStruct()) \n
-		Sets and enables/disables a lower and upper timing error limit for PVT measurements. \n
-			:param value: see the help for PowerVsTimeStruct structure arguments.
+			self.Freq_Dev_F_1_Lower: float = None
+			self.Freq_Dev_F_1_Upper: float = None
+			self.Freq_Dev_F_2_Lower: float = None
+			self.Freq_Dev_F_2_Upper: float = None
+			self.Freq_Dev_F_1_Enable: List[bool] = None
+			self.Freq_Dev_F_2_Enable: List[bool] = None
+
+	def get_dmaximum(self) -> DmaximumStruct:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:DMAXimum \n
+		Snippet: value: DmaximumStruct = driver.configure.multiEval.limit.brate.get_dmaximum() \n
+		Defines the lower and upper frequency deviation limits for BR bursts. The mnemonics DAVerage, DMAXimum, DMINimum
+		distinguish average, maximum, and minimum frequency deviations. \n
+			:return: structure: for return value, see the help for DmaximumStruct structure arguments.
+		"""
+		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:DMAXimum?', self.__class__.DmaximumStruct())
+
+	def set_dmaximum(self, value: DmaximumStruct) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:DMAXimum \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.limit.brate.DmaximumStruct() \n
+		structure.Freq_Dev_F_1_Lower: float = 1.0 \n
+		structure.Freq_Dev_F_1_Upper: float = 1.0 \n
+		structure.Freq_Dev_F_2_Lower: float = 1.0 \n
+		structure.Freq_Dev_F_2_Upper: float = 1.0 \n
+		structure.Freq_Dev_F_1_Enable: List[bool] = [True, False, True] \n
+		structure.Freq_Dev_F_2_Enable: List[bool] = [True, False, True] \n
+		driver.configure.multiEval.limit.brate.set_dmaximum(value = structure) \n
+		Defines the lower and upper frequency deviation limits for BR bursts. The mnemonics DAVerage, DMAXimum, DMINimum
+		distinguish average, maximum, and minimum frequency deviations. \n
+			:param value: see the help for DmaximumStruct structure arguments.
 		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:PVTime', value)
+		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:DMAXimum', value)
 
-	def clone(self) -> 'Limit':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'BrateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Limit(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = BrateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Brate_/Fdrift.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Brate/Fdrift.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,27 +1,72 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
+from ......Internal.ArgSingleList import ArgSingleList
+from ......Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Fdrift:
-	"""Fdrift commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class FdriftCls:
+	"""Fdrift commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("fdrift", core, parent)
+		self._cmd_group = CommandsGroup("fdrift", core, parent)
+
+	def set(self, frequency_drift: float, max_drift_rate: float, freq_drift_enable: List[bool], max_drift_rate_enb: List[bool]) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:FDRift \n
+		Snippet: driver.configure.multiEval.limit.brate.fdrift.set(frequency_drift = 1.0, max_drift_rate = 1.0, freq_drift_enable = [True, False, True], max_drift_rate_enb = [True, False, True]) \n
+		Defines the frequency drift limit for DH1 packets and the maximum drift rate limit for all BR packets. Since V2.1.
+		20, this command is superseded by the command method RsCmwBluetoothMeas.Configure.MultiEval.Limit.Brate.Fdrift.apackets
+		that allows to set different limits for different packet types. \n
+			:param frequency_drift: numeric Range: 0 Hz to 250 kHz
+			:param max_drift_rate: numeric Range: 0 Hz to 250 kHz
+			:param freq_drift_enable: OFF | ON Disable or enable limit check for current, average, and maximum results (3 values) .
+			:param max_drift_rate_enb: OFF | ON Disable or enable limit check for current, average, and maximum results (3 values) .
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('frequency_drift', frequency_drift, DataType.Float), ArgSingle('max_drift_rate', max_drift_rate, DataType.Float), ArgSingle('freq_drift_enable', freq_drift_enable, DataType.BooleanList, None, False, False, 3), ArgSingle('max_drift_rate_enb', max_drift_rate_enb, DataType.BooleanList, None, False, False, 3))
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:FDRift {param}'.rstrip())
+
+	# noinspection PyTypeChecker
+	class FdriftStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Frequency_Drift: float: numeric Range: 0 Hz to 250 kHz
+			- Max_Drift_Rate: float: numeric Range: 0 Hz to 250 kHz
+			- Freq_Drift_Enable: List[bool]: OFF | ON Disable or enable limit check for current, average, and maximum results (3 values) .
+			- Max_Drift_Rate_Enb: List[bool]: OFF | ON Disable or enable limit check for current, average, and maximum results (3 values) ."""
+		__meta_args_list = [
+			ArgStruct.scalar_float('Frequency_Drift'),
+			ArgStruct.scalar_float('Max_Drift_Rate'),
+			ArgStruct('Freq_Drift_Enable', DataType.BooleanList, None, False, False, 3),
+			ArgStruct('Max_Drift_Rate_Enb', DataType.BooleanList, None, False, False, 3)]
+
+		def __init__(self):
+			StructBase.__init__(self, self)
+			self.Frequency_Drift: float = None
+			self.Max_Drift_Rate: float = None
+			self.Freq_Drift_Enable: List[bool] = None
+			self.Max_Drift_Rate_Enb: List[bool] = None
+
+	def get(self) -> FdriftStruct:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:FDRift \n
+		Snippet: value: FdriftStruct = driver.configure.multiEval.limit.brate.fdrift.get() \n
+		Defines the frequency drift limit for DH1 packets and the maximum drift rate limit for all BR packets. Since V2.1.
+		20, this command is superseded by the command method RsCmwBluetoothMeas.Configure.MultiEval.Limit.Brate.Fdrift.apackets
+		that allows to set different limits for different packet types. \n
+			:return: structure: for return value, see the help for FdriftStruct structure arguments."""
+		return self._core.io.query_struct(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:FDRift?', self.__class__.FdriftStruct())
 
 	# noinspection PyTypeChecker
-	class ApacketsStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
+	class ApacketsStruct(StructBase):  # From WriteStructDefinition CmdPropertyTemplate.xml
+		"""Structure for setting input parameters. Fields: \n
 			- Freq_Drift_Dh_1: float: numeric Range: 0 Hz to 250 kHz
 			- Freq_Drift_Dh_3: float: numeric Range: 0 Hz to 250 kHz
 			- Freq_Drift_Dh_5: float: numeric Range: 0 Hz to 250 kHz
 			- Max_Drift_Rate: float: numeric Range: 0 Hz to 250 kHz
 			- Freq_Drift_Dh_1_Enb: List[bool]: OFF | ON Disable or enable limit check for current, average, and maximum results (3 values) .
 			- Freq_Drift_Dh_3_Enb: List[bool]: OFF | ON Disable or enable limit check for current, average, and maximum results (3 values) .
 			- Freq_Drift_Dh_5_Enb: List[bool]: OFF | ON Disable or enable limit check for current, average, and maximum results (3 values) .
@@ -54,53 +99,23 @@
 		different frequency drift limit can be specified. \n
 			:return: structure: for return value, see the help for ApacketsStruct structure arguments.
 		"""
 		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:FDRift:APACkets?', self.__class__.ApacketsStruct())
 
 	def set_apackets(self, value: ApacketsStruct) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:FDRift:APACkets \n
-		Snippet: driver.configure.multiEval.limit.brate.fdrift.set_apackets(value = ApacketsStruct()) \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.limit.brate.fdrift.ApacketsStruct() \n
+		structure.Freq_Drift_Dh_1: float = 1.0 \n
+		structure.Freq_Drift_Dh_3: float = 1.0 \n
+		structure.Freq_Drift_Dh_5: float = 1.0 \n
+		structure.Max_Drift_Rate: float = 1.0 \n
+		structure.Freq_Drift_Dh_1_Enb: List[bool] = [True, False, True] \n
+		structure.Freq_Drift_Dh_3_Enb: List[bool] = [True, False, True] \n
+		structure.Freq_Drift_Dh_5_Enb: List[bool] = [True, False, True] \n
+		structure.Max_Drift_Rate_Enb: List[bool] = [True, False, True] \n
+		driver.configure.multiEval.limit.brate.fdrift.set_apackets(value = structure) \n
 		Defines the limits for the frequency drift and the maximum drift rate for BR. For each packet type (DH1, DH3, DH5) a
 		different frequency drift limit can be specified. \n
 			:param value: see the help for ApacketsStruct structure arguments.
 		"""
 		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:FDRift:APACkets', value)
-
-	# noinspection PyTypeChecker
-	class ValueStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Frequency_Drift: float: numeric Range: 0 Hz to 250 kHz
-			- Max_Drift_Rate: float: numeric Range: 0 Hz to 250 kHz
-			- Freq_Drift_Enable: List[bool]: OFF | ON Disable or enable limit check for current, average, and maximum results (3 values) .
-			- Max_Drift_Rate_Enb: List[bool]: OFF | ON Disable or enable limit check for current, average, and maximum results (3 values) ."""
-		__meta_args_list = [
-			ArgStruct.scalar_float('Frequency_Drift'),
-			ArgStruct.scalar_float('Max_Drift_Rate'),
-			ArgStruct('Freq_Drift_Enable', DataType.BooleanList, None, False, False, 3),
-			ArgStruct('Max_Drift_Rate_Enb', DataType.BooleanList, None, False, False, 3)]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Frequency_Drift: float = None
-			self.Max_Drift_Rate: float = None
-			self.Freq_Drift_Enable: List[bool] = None
-			self.Max_Drift_Rate_Enb: List[bool] = None
-
-	def get_value(self) -> ValueStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:FDRift \n
-		Snippet: value: ValueStruct = driver.configure.multiEval.limit.brate.fdrift.get_value() \n
-		Defines the frequency drift limit for DH1 packets and the maximum drift rate limit for all BR packets. Since V2.1.
-		20, this command is superseded by the command method RsCmwBluetoothMeas.Configure.MultiEval.Limit.Brate.Fdrift.apackets
-		that allows to set different limits for different packet types. \n
-			:return: structure: for return value, see the help for ValueStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:FDRift?', self.__class__.ValueStruct())
-
-	def set_value(self, value: ValueStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:FDRift \n
-		Snippet: driver.configure.multiEval.limit.brate.fdrift.set_value(value = ValueStruct()) \n
-		Defines the frequency drift limit for DH1 packets and the maximum drift rate limit for all BR packets. Since V2.1.
-		20, this command is superseded by the command method RsCmwBluetoothMeas.Configure.MultiEval.Limit.Brate.Fdrift.apackets
-		that allows to set different limits for different packet types. \n
-			:param value: see the help for ValueStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:BRATe:FDRift', value)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Cte.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,27 +1,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cte:
-	"""Cte commands group definition. 6 total commands, 1 Sub-groups, 0 group commands"""
+class NmodeCls:
+	"""Nmode commands group definition. 88 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cte", core, parent)
+		self._cmd_group = CommandsGroup("nmode", core, parent)
+
+	@property
+	def classic(self):
+		"""classic commands group. 7 Sub-classes, 0 commands."""
+		if not hasattr(self, '_classic'):
+			from .Classic import ClassicCls
+			self._classic = ClassicCls(self._core, self._cmd_group)
+		return self._classic
 
 	@property
 	def lowEnergy(self):
-		"""lowEnergy commands group. 2 Sub-classes, 0 commands."""
+		"""lowEnergy commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_lowEnergy'):
-			from .Cte_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
 		return self._lowEnergy
 
-	def clone(self) -> 'Cte':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'NmodeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cte(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = NmodeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Cte_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,35 +1,35 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 6 total commands, 2 Sub-groups, 0 group commands"""
+class LowEnergyCls:
+	"""LowEnergy commands group definition. 36 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("lowEnergy", core, parent)
 
 	@property
 	def le1M(self):
-		"""le1M commands group. 0 Sub-classes, 3 commands."""
+		"""le1M commands group. 6 Sub-classes, 0 commands."""
 		if not hasattr(self, '_le1M'):
-			from .LowEnergy_.Le1M import Le1M
-			self._le1M = Le1M(self._core, self._base)
+			from .Le1M import Le1MCls
+			self._le1M = Le1MCls(self._core, self._cmd_group)
 		return self._le1M
 
 	@property
 	def le2M(self):
-		"""le2M commands group. 0 Sub-classes, 3 commands."""
+		"""le2M commands group. 6 Sub-classes, 0 commands."""
 		if not hasattr(self, '_le2M'):
-			from .LowEnergy_.Le2M import Le2M
-			self._le2M = Le2M(self._core, self._base)
+			from .Le2M import Le2MCls
+			self._le2M = Le2MCls(self._core, self._cmd_group)
 		return self._le2M
 
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LowEnergyCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LowEnergyCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Cte_/LowEnergy_/Le1M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Edrate/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,130 +1,150 @@
 from typing import List
 
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.Types import DataType
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le1M:
-	"""Le1M commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class EdrateCls:
+	"""Edrate commands group definition. 6 total commands, 3 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le1M", core, parent)
+		self._cmd_group = CommandsGroup("edrate", core, parent)
 
-	# noinspection PyTypeChecker
-	class PdeviationStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Ref_Dev: float: numeric Upper CTE power limit for reference antenna. Range: 0.01 to 1
-			- Tx_Dev: float: numeric Upper limit for power deviation in a slot. Range: 0.01 to 1
-			- Ref_Dev_Enable: bool: OFF | ON Enables/disables the CTE power limit check for reference antenna.
-			- Tx_Dev_Enable: bool: OFF | ON Enables/disables the limit check for power deviation in a slot."""
-		__meta_args_list = [
-			ArgStruct.scalar_float('Ref_Dev'),
-			ArgStruct.scalar_float('Tx_Dev'),
-			ArgStruct.scalar_bool('Ref_Dev_Enable'),
-			ArgStruct.scalar_bool('Tx_Dev_Enable')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Ref_Dev: float = None
-			self.Tx_Dev: float = None
-			self.Ref_Dev_Enable: bool = None
-			self.Tx_Dev_Enable: bool = None
-
-	def get_pdeviation(self) -> PdeviationStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE1M:PDEViation \n
-		Snippet: value: PdeviationStruct = driver.configure.multiEval.limit.cte.lowEnergy.le1M.get_pdeviation() \n
-		Defines the upper CTE power limits and enables/disables the limit check. Commands for uncoded LE 1M PHY (..:LE1M..) and
-		LE 2M PHY (..:LE2M..) are available. \n
-			:return: structure: for return value, see the help for PdeviationStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE1M:PDEViation?', self.__class__.PdeviationStruct())
-
-	def set_pdeviation(self, value: PdeviationStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE1M:PDEViation \n
-		Snippet: driver.configure.multiEval.limit.cte.lowEnergy.le1M.set_pdeviation(value = PdeviationStruct()) \n
-		Defines the upper CTE power limits and enables/disables the limit check. Commands for uncoded LE 1M PHY (..:LE1M..) and
-		LE 2M PHY (..:LE2M..) are available. \n
-			:param value: see the help for PdeviationStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE1M:PDEViation', value)
+	@property
+	def pencoding(self):
+		"""pencoding commands group. 1 Sub-classes, 1 commands."""
+		if not hasattr(self, '_pencoding'):
+			from .Pencoding import PencodingCls
+			self._pencoding = PencodingCls(self._core, self._cmd_group)
+		return self._pencoding
+
+	@property
+	def dpsk(self):
+		"""dpsk commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dpsk'):
+			from .Dpsk import DpskCls
+			self._dpsk = DpskCls(self._core, self._cmd_group)
+		return self._dpsk
+
+	@property
+	def dqpsk(self):
+		"""dqpsk commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dqpsk'):
+			from .Dqpsk import DqpskCls
+			self._dqpsk = DqpskCls(self._core, self._cmd_group)
+		return self._dqpsk
 
 	# noinspection PyTypeChecker
-	class FdriftStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Frequency_Drift: float: numeric Range: 0 Hz to 500 kHz
-			- Max_Drift_Rate: float: numeric Range: 0 Hz to 500 kHz
-			- Initl_Freq_Drift: float: numeric Range: 0 Hz to 500 kHz
-			- Freq_Drift_Enable: List[bool]: OFF | ON Disable or enable limit checking for current, average, and maximum results (3 values) .
-			- Max_Drift_Rate_Enb: List[bool]: OFF | ON Disable or enable limit checking for current, average, and maximum results (3 values) .
-			- Init_Freq_Drift_En: List[bool]: OFF | ON Disable or enable limit checking for current, average, and maximum results (3 values) ."""
+	class PowerVsTimeStruct(StructBase):  # From WriteStructDefinition CmdPropertyTemplate.xml
+		"""Structure for setting input parameters. Fields: \n
+			- Dpsk_Minus_Gfsk_Low: float: numeric Range: -99.99 dB to 99.99 dB
+			- Dpsk_Minus_Gfsk_Upp: float: numeric Range: -99.99 dB to 99.99 dB
+			- Guard_Period_Low: float: numeric Range: -9.99 µs to 9.99 µs
+			- Guard_Period_Upp: float: numeric Range: -9.99 µs to 9.99 µs
+			- Dpsk_Minus_Gfsk_Enable: List[bool]: OFF | ON Disables or enables the limit check for the DPSK minus GFSK power, 4 values, corresponding to the current, average, maximum and minimum results.
+			- Guard_Period_Enable: List[bool]: OFF | ON Disables or enables the limit check for the guard period, 4 values, corresponding to the current, average, maximum and minimum results."""
 		__meta_args_list = [
-			ArgStruct.scalar_float('Frequency_Drift'),
-			ArgStruct.scalar_float('Max_Drift_Rate'),
-			ArgStruct.scalar_float('Initl_Freq_Drift'),
-			ArgStruct('Freq_Drift_Enable', DataType.BooleanList, None, False, False, 3),
-			ArgStruct('Max_Drift_Rate_Enb', DataType.BooleanList, None, False, False, 3),
-			ArgStruct('Init_Freq_Drift_En', DataType.BooleanList, None, False, False, 3)]
+			ArgStruct.scalar_float('Dpsk_Minus_Gfsk_Low'),
+			ArgStruct.scalar_float('Dpsk_Minus_Gfsk_Upp'),
+			ArgStruct.scalar_float('Guard_Period_Low'),
+			ArgStruct.scalar_float('Guard_Period_Upp'),
+			ArgStruct('Dpsk_Minus_Gfsk_Enable', DataType.BooleanList, None, False, False, 4),
+			ArgStruct('Guard_Period_Enable', DataType.BooleanList, None, False, False, 4)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Frequency_Drift: float = None
-			self.Max_Drift_Rate: float = None
-			self.Initl_Freq_Drift: float = None
-			self.Freq_Drift_Enable: List[bool] = None
-			self.Max_Drift_Rate_Enb: List[bool] = None
-			self.Init_Freq_Drift_En: List[bool] = None
-
-	def get_fdrift(self) -> FdriftStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE1M:FDRift \n
-		Snippet: value: FdriftStruct = driver.configure.multiEval.limit.cte.lowEnergy.le1M.get_fdrift() \n
-		Sets and enables limits for frequency drift, maximum drift rate and initial frequency drift for the CTE portion. Commands
-		for uncoded LE 1M PHY (..:LE1M..) and LE 2M PHY (..:LE2M..) are available. \n
-			:return: structure: for return value, see the help for FdriftStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE1M:FDRift?', self.__class__.FdriftStruct())
-
-	def set_fdrift(self, value: FdriftStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE1M:FDRift \n
-		Snippet: driver.configure.multiEval.limit.cte.lowEnergy.le1M.set_fdrift(value = FdriftStruct()) \n
-		Sets and enables limits for frequency drift, maximum drift rate and initial frequency drift for the CTE portion. Commands
-		for uncoded LE 1M PHY (..:LE1M..) and LE 2M PHY (..:LE2M..) are available. \n
-			:param value: see the help for FdriftStruct structure arguments.
+			self.Dpsk_Minus_Gfsk_Low: float = None
+			self.Dpsk_Minus_Gfsk_Upp: float = None
+			self.Guard_Period_Low: float = None
+			self.Guard_Period_Upp: float = None
+			self.Dpsk_Minus_Gfsk_Enable: List[bool] = None
+			self.Guard_Period_Enable: List[bool] = None
+
+	def get_power_vs_time(self) -> PowerVsTimeStruct:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:PVTime \n
+		Snippet: value: PowerVsTimeStruct = driver.configure.multiEval.limit.edrate.get_power_vs_time() \n
+		Defines the power limits for EDR: lower and upper limits for DPSK minus GFSK power and for guard period, limit check
+		enabling. \n
+			:return: structure: for return value, see the help for PowerVsTimeStruct structure arguments.
+		"""
+		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:PVTime?', self.__class__.PowerVsTimeStruct())
+
+	def set_power_vs_time(self, value: PowerVsTimeStruct) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:PVTime \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.limit.edrate.PowerVsTimeStruct() \n
+		structure.Dpsk_Minus_Gfsk_Low: float = 1.0 \n
+		structure.Dpsk_Minus_Gfsk_Upp: float = 1.0 \n
+		structure.Guard_Period_Low: float = 1.0 \n
+		structure.Guard_Period_Upp: float = 1.0 \n
+		structure.Dpsk_Minus_Gfsk_Enable: List[bool] = [True, False, True] \n
+		structure.Guard_Period_Enable: List[bool] = [True, False, True] \n
+		driver.configure.multiEval.limit.edrate.set_power_vs_time(value = structure) \n
+		Defines the power limits for EDR: lower and upper limits for DPSK minus GFSK power and for guard period, limit check
+		enabling. \n
+			:param value: see the help for PowerVsTimeStruct structure arguments.
 		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE1M:FDRift', value)
+		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:PVTime', value)
 
 	# noinspection PyTypeChecker
-	class FoffsetStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Freq_Offset: float: numeric Range: 0 Hz to 500 kHz
-			- Freq_Offset_Enable: List[bool]: OFF | ON Disable or enable limit checking for current, average, and maximum results (3 values)"""
+	class FstabilityStruct(StructBase):  # From WriteStructDefinition CmdPropertyTemplate.xml
+		"""Structure for setting input parameters. Fields: \n
+			- Wi: float: numeric Limit for the initial center frequency error Range: 0 Hz to 250 kHz
+			- Wiplus_W_0_Max: float: numeric Limit for the overall uncompensated frequency error Range: 0 Hz to 250 kHz
+			- W_0_Max: float: numeric Limit for the maximum compensated frequency error in the DPSK portion of the packet Range: 0 Hz to 250 kHz
+			- Wi_Enabled: List[bool]: OFF | ON Enable limits for current, average, and maximum results (3 values) .
+			- Wi_W_0_Max_Enabled: List[bool]: OFF | ON Enable limits for current, average, and maximum results (3 values) .
+			- W_0_Max_Enabled: List[bool]: OFF | ON Enable limits for current, average, and maximum results (3 values) ."""
 		__meta_args_list = [
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct('Freq_Offset_Enable', DataType.BooleanList, None, False, False, 3)]
+			ArgStruct.scalar_float('Wi'),
+			ArgStruct.scalar_float('Wiplus_W_0_Max'),
+			ArgStruct.scalar_float('W_0_Max'),
+			ArgStruct('Wi_Enabled', DataType.BooleanList, None, False, False, 3),
+			ArgStruct('Wi_W_0_Max_Enabled', DataType.BooleanList, None, False, False, 3),
+			ArgStruct('W_0_Max_Enabled', DataType.BooleanList, None, False, False, 3)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Freq_Offset: float = None
-			self.Freq_Offset_Enable: List[bool] = None
-
-	def get_foffset(self) -> FoffsetStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE1M:FOFFset \n
-		Snippet: value: FoffsetStruct = driver.configure.multiEval.limit.cte.lowEnergy.le1M.get_foffset() \n
-		Sets/gets the frequency offset limit for the CTE portion. Commands for uncoded LE 1M PHY (..:LE1M..) and LE 2M PHY (..
-		:LE2M..) are available. \n
-			:return: structure: for return value, see the help for FoffsetStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE1M:FOFFset?', self.__class__.FoffsetStruct())
-
-	def set_foffset(self, value: FoffsetStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE1M:FOFFset \n
-		Snippet: driver.configure.multiEval.limit.cte.lowEnergy.le1M.set_foffset(value = FoffsetStruct()) \n
-		Sets/gets the frequency offset limit for the CTE portion. Commands for uncoded LE 1M PHY (..:LE1M..) and LE 2M PHY (..
-		:LE2M..) are available. \n
-			:param value: see the help for FoffsetStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE1M:FOFFset', value)
+			self.Wi: float = None
+			self.Wiplus_W_0_Max: float = None
+			self.W_0_Max: float = None
+			self.Wi_Enabled: List[bool] = None
+			self.Wi_W_0_Max_Enabled: List[bool] = None
+			self.W_0_Max_Enabled: List[bool] = None
+
+	def get_fstability(self) -> FstabilityStruct:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:FSTability \n
+		Snippet: value: FstabilityStruct = driver.configure.multiEval.limit.edrate.get_fstability() \n
+		Defines and activates upper limits for the frequency stability. \n
+			:return: structure: for return value, see the help for FstabilityStruct structure arguments.
+		"""
+		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:FSTability?', self.__class__.FstabilityStruct())
+
+	def set_fstability(self, value: FstabilityStruct) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:FSTability \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.limit.edrate.FstabilityStruct() \n
+		structure.Wi: float = 1.0 \n
+		structure.Wiplus_W_0_Max: float = 1.0 \n
+		structure.W_0_Max: float = 1.0 \n
+		structure.Wi_Enabled: List[bool] = [True, False, True] \n
+		structure.Wi_W_0_Max_Enabled: List[bool] = [True, False, True] \n
+		structure.W_0_Max_Enabled: List[bool] = [True, False, True] \n
+		driver.configure.multiEval.limit.edrate.set_fstability(value = structure) \n
+		Defines and activates upper limits for the frequency stability. \n
+			:param value: see the help for FstabilityStruct structure arguments.
+		"""
+		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:FSTability', value)
+
+	def clone(self) -> 'EdrateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = EdrateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Cte_/LowEnergy_/Le2M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Cte/LowEnergy/Le1M/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,65 +1,43 @@
 from typing import List
 
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.Types import DataType
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.Types import DataType
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le2M:
-	"""Le2M commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class Le1MCls:
+	"""Le1M commands group definition. 3 total commands, 2 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le2M", core, parent)
+		self._cmd_group = CommandsGroup("le1M", core, parent)
 
-	# noinspection PyTypeChecker
-	class PdeviationStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Ref_Dev: float: numeric Upper CTE power limit for reference antenna. Range: 0.01 to 1
-			- Tx_Dev: float: numeric Upper limit for power deviation in a slot. Range: 0.01 to 1
-			- Ref_Dev_Enable: bool: OFF | ON Enables/disables the CTE power limit check for reference antenna.
-			- Tx_Dev_Enable: bool: OFF | ON Enables/disables the limit check for power deviation in a slot."""
-		__meta_args_list = [
-			ArgStruct.scalar_float('Ref_Dev'),
-			ArgStruct.scalar_float('Tx_Dev'),
-			ArgStruct.scalar_bool('Ref_Dev_Enable'),
-			ArgStruct.scalar_bool('Tx_Dev_Enable')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Ref_Dev: float = None
-			self.Tx_Dev: float = None
-			self.Ref_Dev_Enable: bool = None
-			self.Tx_Dev_Enable: bool = None
-
-	def get_pdeviation(self) -> PdeviationStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE2M:PDEViation \n
-		Snippet: value: PdeviationStruct = driver.configure.multiEval.limit.cte.lowEnergy.le2M.get_pdeviation() \n
-		Defines the upper CTE power limits and enables/disables the limit check. Commands for uncoded LE 1M PHY (..:LE1M..) and
-		LE 2M PHY (..:LE2M..) are available. \n
-			:return: structure: for return value, see the help for PdeviationStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE2M:PDEViation?', self.__class__.PdeviationStruct())
-
-	def set_pdeviation(self, value: PdeviationStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE2M:PDEViation \n
-		Snippet: driver.configure.multiEval.limit.cte.lowEnergy.le2M.set_pdeviation(value = PdeviationStruct()) \n
-		Defines the upper CTE power limits and enables/disables the limit check. Commands for uncoded LE 1M PHY (..:LE1M..) and
-		LE 2M PHY (..:LE2M..) are available. \n
-			:param value: see the help for PdeviationStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE2M:PDEViation', value)
+	@property
+	def pdeviation(self):
+		"""pdeviation commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_pdeviation'):
+			from .Pdeviation import PdeviationCls
+			self._pdeviation = PdeviationCls(self._core, self._cmd_group)
+		return self._pdeviation
+
+	@property
+	def foffset(self):
+		"""foffset commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_foffset'):
+			from .Foffset import FoffsetCls
+			self._foffset = FoffsetCls(self._core, self._cmd_group)
+		return self._foffset
 
 	# noinspection PyTypeChecker
-	class FdriftStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
+	class FdriftStruct(StructBase):  # From WriteStructDefinition CmdPropertyTemplate.xml
+		"""Structure for setting input parameters. Fields: \n
 			- Frequency_Drift: float: numeric Range: 0 Hz to 500 kHz
 			- Max_Drift_Rate: float: numeric Range: 0 Hz to 500 kHz
 			- Initl_Freq_Drift: float: numeric Range: 0 Hz to 500 kHz
 			- Freq_Drift_Enable: List[bool]: OFF | ON Disable or enable limit checking for current, average, and maximum results (3 values) .
 			- Max_Drift_Rate_Enb: List[bool]: OFF | ON Disable or enable limit checking for current, average, and maximum results (3 values) .
 			- Init_Freq_Drift_En: List[bool]: OFF | ON Disable or enable limit checking for current, average, and maximum results (3 values) ."""
 		__meta_args_list = [
@@ -76,55 +54,39 @@
 			self.Max_Drift_Rate: float = None
 			self.Initl_Freq_Drift: float = None
 			self.Freq_Drift_Enable: List[bool] = None
 			self.Max_Drift_Rate_Enb: List[bool] = None
 			self.Init_Freq_Drift_En: List[bool] = None
 
 	def get_fdrift(self) -> FdriftStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE2M:FDRift \n
-		Snippet: value: FdriftStruct = driver.configure.multiEval.limit.cte.lowEnergy.le2M.get_fdrift() \n
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE1M:FDRift \n
+		Snippet: value: FdriftStruct = driver.configure.multiEval.limit.cte.lowEnergy.le1M.get_fdrift() \n
 		Sets and enables limits for frequency drift, maximum drift rate and initial frequency drift for the CTE portion. Commands
 		for uncoded LE 1M PHY (..:LE1M..) and LE 2M PHY (..:LE2M..) are available. \n
 			:return: structure: for return value, see the help for FdriftStruct structure arguments.
 		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE2M:FDRift?', self.__class__.FdriftStruct())
+		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE1M:FDRift?', self.__class__.FdriftStruct())
 
 	def set_fdrift(self, value: FdriftStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE2M:FDRift \n
-		Snippet: driver.configure.multiEval.limit.cte.lowEnergy.le2M.set_fdrift(value = FdriftStruct()) \n
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE1M:FDRift \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.limit.cte.lowEnergy.le1M.FdriftStruct() \n
+		structure.Frequency_Drift: float = 1.0 \n
+		structure.Max_Drift_Rate: float = 1.0 \n
+		structure.Initl_Freq_Drift: float = 1.0 \n
+		structure.Freq_Drift_Enable: List[bool] = [True, False, True] \n
+		structure.Max_Drift_Rate_Enb: List[bool] = [True, False, True] \n
+		structure.Init_Freq_Drift_En: List[bool] = [True, False, True] \n
+		driver.configure.multiEval.limit.cte.lowEnergy.le1M.set_fdrift(value = structure) \n
 		Sets and enables limits for frequency drift, maximum drift rate and initial frequency drift for the CTE portion. Commands
 		for uncoded LE 1M PHY (..:LE1M..) and LE 2M PHY (..:LE2M..) are available. \n
 			:param value: see the help for FdriftStruct structure arguments.
 		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE2M:FDRift', value)
+		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE1M:FDRift', value)
 
-	# noinspection PyTypeChecker
-	class FoffsetStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Freq_Offset: float: numeric Range: 0 Hz to 500 kHz
-			- Freq_Offset_Enable: List[bool]: OFF | ON Disable or enable limit checking for current, average, and maximum results (3 values)"""
-		__meta_args_list = [
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct('Freq_Offset_Enable', DataType.BooleanList, None, False, False, 3)]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Freq_Offset: float = None
-			self.Freq_Offset_Enable: List[bool] = None
-
-	def get_foffset(self) -> FoffsetStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE2M:FOFFset \n
-		Snippet: value: FoffsetStruct = driver.configure.multiEval.limit.cte.lowEnergy.le2M.get_foffset() \n
-		Sets/gets the frequency offset limit for the CTE portion. Commands for uncoded LE 1M PHY (..:LE1M..) and LE 2M PHY (..
-		:LE2M..) are available. \n
-			:return: structure: for return value, see the help for FoffsetStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE2M:FOFFset?', self.__class__.FoffsetStruct())
-
-	def set_foffset(self, value: FoffsetStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE2M:FOFFset \n
-		Snippet: driver.configure.multiEval.limit.cte.lowEnergy.le2M.set_foffset(value = FoffsetStruct()) \n
-		Sets/gets the frequency offset limit for the CTE portion. Commands for uncoded LE 1M PHY (..:LE1M..) and LE 2M PHY (..
-		:LE2M..) are available. \n
-			:param value: see the help for FoffsetStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE2M:FOFFset', value)
+	def clone(self) -> 'Le1MCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = Le1MCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Edrate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/Lrange/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,134 +1,140 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.Types import DataType
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Edrate:
-	"""Edrate commands group definition. 6 total commands, 3 Sub-groups, 2 group commands"""
+class LrangeCls:
+	"""Lrange commands group definition. 9 total commands, 8 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("edrate", core, parent)
+		self._cmd_group = CommandsGroup("lrange", core, parent)
 
 	@property
-	def pencoding(self):
-		"""pencoding commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_pencoding'):
-			from .Edrate_.Pencoding import Pencoding
-			self._pencoding = Pencoding(self._core, self._base)
-		return self._pencoding
-
-	@property
-	def dpsk(self):
-		"""dpsk commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_dpsk'):
-			from .Edrate_.Dpsk import Dpsk
-			self._dpsk = Dpsk(self._core, self._base)
-		return self._dpsk
-
-	@property
-	def dqpsk(self):
-		"""dqpsk commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_dqpsk'):
-			from .Edrate_.Dqpsk import Dqpsk
-			self._dqpsk = Dqpsk(self._core, self._base)
-		return self._dqpsk
+	def sacp(self):
+		"""sacp commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_sacp'):
+			from .Sacp import SacpCls
+			self._sacp = SacpCls(self._core, self._cmd_group)
+		return self._sacp
 
-	# noinspection PyTypeChecker
-	class PowerVsTimeStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Dpsk_Minus_Gfsk_Low: float: numeric Range: -99.99 dB to 99.99 dB
-			- Dpsk_Minus_Gfsk_Upp: float: numeric Range: -99.99 dB to 99.99 dB
-			- Guard_Period_Low: float: numeric Range: -9.99 µs to 9.99 µs
-			- Guard_Period_Upp: float: numeric Range: -9.99 µs to 9.99 µs
-			- Dpsk_Minus_Gfsk_Enable: List[bool]: OFF | ON Disables or enables the limit check for the DPSK minus GFSK power, 4 values, corresponding to the current, average, maximum and minimum results.
-			- Guard_Period_Enable: List[bool]: OFF | ON Disables or enables the limit check for the guard period, 4 values, corresponding to the current, average, maximum and minimum results."""
-		__meta_args_list = [
-			ArgStruct.scalar_float('Dpsk_Minus_Gfsk_Low'),
-			ArgStruct.scalar_float('Dpsk_Minus_Gfsk_Upp'),
-			ArgStruct.scalar_float('Guard_Period_Low'),
-			ArgStruct.scalar_float('Guard_Period_Upp'),
-			ArgStruct('Dpsk_Minus_Gfsk_Enable', DataType.BooleanList, None, False, False, 4),
-			ArgStruct('Guard_Period_Enable', DataType.BooleanList, None, False, False, 4)]
+	@property
+	def powerVsTime(self):
+		"""powerVsTime commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_powerVsTime'):
+			from .PowerVsTime import PowerVsTimeCls
+			self._powerVsTime = PowerVsTimeCls(self._core, self._cmd_group)
+		return self._powerVsTime
 
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Dpsk_Minus_Gfsk_Low: float = None
-			self.Dpsk_Minus_Gfsk_Upp: float = None
-			self.Guard_Period_Low: float = None
-			self.Guard_Period_Upp: float = None
-			self.Dpsk_Minus_Gfsk_Enable: List[bool] = None
-			self.Guard_Period_Enable: List[bool] = None
-
-	def get_power_vs_time(self) -> PowerVsTimeStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:PVTime \n
-		Snippet: value: PowerVsTimeStruct = driver.configure.multiEval.limit.edrate.get_power_vs_time() \n
-		Defines the power limits for EDR: lower and upper limits for DPSK minus GFSK power and for guard period, limit check
-		enabling. \n
-			:return: structure: for return value, see the help for PowerVsTimeStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:PVTime?', self.__class__.PowerVsTimeStruct())
+	@property
+	def faccuracy(self):
+		"""faccuracy commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_faccuracy'):
+			from .Faccuracy import FaccuracyCls
+			self._faccuracy = FaccuracyCls(self._core, self._cmd_group)
+		return self._faccuracy
 
-	def set_power_vs_time(self, value: PowerVsTimeStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:PVTime \n
-		Snippet: driver.configure.multiEval.limit.edrate.set_power_vs_time(value = PowerVsTimeStruct()) \n
-		Defines the power limits for EDR: lower and upper limits for DPSK minus GFSK power and for guard period, limit check
-		enabling. \n
-			:param value: see the help for PowerVsTimeStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:PVTime', value)
+	@property
+	def foffset(self):
+		"""foffset commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_foffset'):
+			from .Foffset import FoffsetCls
+			self._foffset = FoffsetCls(self._core, self._cmd_group)
+		return self._foffset
+
+	@property
+	def delta(self):
+		"""delta commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_delta'):
+			from .Delta import DeltaCls
+			self._delta = DeltaCls(self._core, self._cmd_group)
+		return self._delta
+
+	@property
+	def daverage(self):
+		"""daverage commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_daverage'):
+			from .Daverage import DaverageCls
+			self._daverage = DaverageCls(self._core, self._cmd_group)
+		return self._daverage
+
+	@property
+	def dminimum(self):
+		"""dminimum commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dminimum'):
+			from .Dminimum import DminimumCls
+			self._dminimum = DminimumCls(self._core, self._cmd_group)
+		return self._dminimum
+
+	@property
+	def dmaximum(self):
+		"""dmaximum commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dmaximum'):
+			from .Dmaximum import DmaximumCls
+			self._dmaximum = DmaximumCls(self._core, self._cmd_group)
+		return self._dmaximum
 
 	# noinspection PyTypeChecker
-	class FstabilityStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Wi: float: numeric Limit for the initial center frequency error Range: 0 Hz to 250 kHz
-			- Wiplus_W_0_Max: float: numeric Limit for the overall uncompensated frequency error Range: 0 Hz to 250 kHz
-			- W_0_Max: float: numeric Limit for the maximum compensated frequency error in the DPSK portion of the packet Range: 0 Hz to 250 kHz
-			- Wi_Enabled: List[bool]: OFF | ON Enable limits for current, average, and maximum results (3 values)
-			- Wi_W_0_Max_Enabled: List[bool]: OFF | ON Enable limits for current, average, and maximum results (3 values)
-			- W_0_Max_Enabled: List[bool]: OFF | ON Enable limits for current, average, and maximum results (3 values)"""
+	class FdriftStruct(StructBase):  # From WriteStructDefinition CmdPropertyTemplate.xml
+		"""Structure for setting input parameters. Fields: \n
+			- Frequency_Drift: float: numeric Range: 0 Hz to 250 kHz
+			- Max_Drift_Rate: float: numeric Range: 0 Hz to 250 kHz
+			- Initl_Freq_Drift: float: numeric Range: 0 Hz to 250 kHz
+			- Freq_Drift_Enable: List[bool]: OFF | ON Disable or enable limit checking for current, average, and maximum results (3 values) .
+			- Max_Drift_Rate_Enb: List[bool]: OFF | ON Disable or enable limit checking for current, average, and maximum results (3 values) .
+			- Init_Freq_Drift_En: List[bool]: OFF | ON Disable or enable limit checking for current, average, and maximum results (3 values) ."""
 		__meta_args_list = [
-			ArgStruct.scalar_float('Wi'),
-			ArgStruct.scalar_float('Wiplus_W_0_Max'),
-			ArgStruct.scalar_float('W_0_Max'),
-			ArgStruct('Wi_Enabled', DataType.BooleanList, None, False, False, 3),
-			ArgStruct('Wi_W_0_Max_Enabled', DataType.BooleanList, None, False, False, 3),
-			ArgStruct('W_0_Max_Enabled', DataType.BooleanList, None, False, False, 3)]
+			ArgStruct.scalar_float('Frequency_Drift'),
+			ArgStruct.scalar_float('Max_Drift_Rate'),
+			ArgStruct.scalar_float('Initl_Freq_Drift'),
+			ArgStruct('Freq_Drift_Enable', DataType.BooleanList, None, False, False, 3),
+			ArgStruct('Max_Drift_Rate_Enb', DataType.BooleanList, None, False, False, 3),
+			ArgStruct('Init_Freq_Drift_En', DataType.BooleanList, None, False, False, 3)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Wi: float = None
-			self.Wiplus_W_0_Max: float = None
-			self.W_0_Max: float = None
-			self.Wi_Enabled: List[bool] = None
-			self.Wi_W_0_Max_Enabled: List[bool] = None
-			self.W_0_Max_Enabled: List[bool] = None
-
-	def get_fstability(self) -> FstabilityStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:FSTability \n
-		Snippet: value: FstabilityStruct = driver.configure.multiEval.limit.edrate.get_fstability() \n
-		Defines and activates upper limits for the frequency stability. \n
-			:return: structure: for return value, see the help for FstabilityStruct structure arguments.
+			self.Frequency_Drift: float = None
+			self.Max_Drift_Rate: float = None
+			self.Initl_Freq_Drift: float = None
+			self.Freq_Drift_Enable: List[bool] = None
+			self.Max_Drift_Rate_Enb: List[bool] = None
+			self.Init_Freq_Drift_En: List[bool] = None
+
+	def get_fdrift(self) -> FdriftStruct:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:LENergy:LRANge:FDRift \n
+		Snippet: value: FdriftStruct = driver.configure.multiEval.limit.lowEnergy.lrange.get_fdrift() \n
+		Sets and enables limits for frequency drift, maximum drift rate and initial frequency drift. Commands for uncoded LE 1M
+		PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
+			:return: structure: for return value, see the help for FdriftStruct structure arguments.
 		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:FSTability?', self.__class__.FstabilityStruct())
+		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:LENergy:LRANge:FDRift?', self.__class__.FdriftStruct())
 
-	def set_fstability(self, value: FstabilityStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:FSTability \n
-		Snippet: driver.configure.multiEval.limit.edrate.set_fstability(value = FstabilityStruct()) \n
-		Defines and activates upper limits for the frequency stability. \n
-			:param value: see the help for FstabilityStruct structure arguments.
+	def set_fdrift(self, value: FdriftStruct) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:LENergy:LRANge:FDRift \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.limit.lowEnergy.lrange.FdriftStruct() \n
+		structure.Frequency_Drift: float = 1.0 \n
+		structure.Max_Drift_Rate: float = 1.0 \n
+		structure.Initl_Freq_Drift: float = 1.0 \n
+		structure.Freq_Drift_Enable: List[bool] = [True, False, True] \n
+		structure.Max_Drift_Rate_Enb: List[bool] = [True, False, True] \n
+		structure.Init_Freq_Drift_En: List[bool] = [True, False, True] \n
+		driver.configure.multiEval.limit.lowEnergy.lrange.set_fdrift(value = structure) \n
+		Sets and enables limits for frequency drift, maximum drift rate and initial frequency drift. Commands for uncoded LE 1M
+		PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
+			:param value: see the help for FdriftStruct structure arguments.
 		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:FSTability', value)
+		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:LENergy:LRANge:FDRift', value)
 
-	def clone(self) -> 'Edrate':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LrangeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Edrate(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LrangeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Edrate_/Dpsk.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Edrate/Dpsk.py`

 * *Files 14% similar despite different names*

```diff
@@ -4,24 +4,24 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dpsk:
-	"""Dpsk commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DpskCls:
+	"""Dpsk commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dpsk", core, parent)
+		self._cmd_group = CommandsGroup("dpsk", core, parent)
 
 	# noinspection PyTypeChecker
-	class DevmStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
+	class DevmStruct(StructBase):  # From WriteStructDefinition CmdPropertyTemplate.xml
+		"""Structure for setting input parameters. Fields: \n
 			- Rms: float: numeric Limit for RMS DEVM (8DPSK) Range: 0 to 1
 			- Peak: float: numeric Limit for peak DEVM (8DPSK) Range: 0 to 1
 			- P_99: float: numeric Limit for 99% DEVM (8DPSK) Range: 0 to 1
 			- Rms_Enabled: List[bool]: OFF | ON Disable or enable limit check for current, average, and maximum results (3 values)
 			- Peak_Enabled: List[bool]: OFF | ON Disable or enable limit check for current, average, and maximum results (3 values)
 			- P_99_Enabled: bool: OFF | ON Disable or enable limit check for current result (1 value)"""
 		__meta_args_list = [
@@ -47,12 +47,20 @@
 		Defines and activates upper limits for the differential error vector magnitude for 8DPSK modulated packets (3-DHx) . \n
 			:return: structure: for return value, see the help for DevmStruct structure arguments.
 		"""
 		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:DPSK:DEVM?', self.__class__.DevmStruct())
 
 	def set_devm(self, value: DevmStruct) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:DPSK:DEVM \n
-		Snippet: driver.configure.multiEval.limit.edrate.dpsk.set_devm(value = DevmStruct()) \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.limit.edrate.dpsk.DevmStruct() \n
+		structure.Rms: float = 1.0 \n
+		structure.Peak: float = 1.0 \n
+		structure.P_99: float = 1.0 \n
+		structure.Rms_Enabled: List[bool] = [True, False, True] \n
+		structure.Peak_Enabled: List[bool] = [True, False, True] \n
+		structure.P_99_Enabled: bool = False \n
+		driver.configure.multiEval.limit.edrate.dpsk.set_devm(value = structure) \n
 		Defines and activates upper limits for the differential error vector magnitude for 8DPSK modulated packets (3-DHx) . \n
 			:param value: see the help for DevmStruct structure arguments.
 		"""
 		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:DPSK:DEVM', value)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Edrate_/Dqpsk.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Qhsl/P2Q.py`

 * *Files 15% similar despite different names*

```diff
@@ -4,30 +4,30 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dqpsk:
-	"""Dqpsk commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class P2QCls:
+	"""P2Q commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dqpsk", core, parent)
+		self._cmd_group = CommandsGroup("p2Q", core, parent)
 
 	# noinspection PyTypeChecker
-	class DevmStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Rms: float: numeric Limit for RMS DEVM (π/4 DQPSK) Range: 0 to 1
-			- Peak: float: numeric Limit for peak DEVM (π/4 DQPSK) Range: 0 to 1
-			- P_99: float: numeric Limit for 99% DEVM (π/4 DQPSK) Range: 0 to 1
-			- Rms_Enabled: List[bool]: OFF | ON Disable or enable limit check for current, average, and maximum results (3 values)
-			- Peak_Enabled: List[bool]: OFF | ON Disable or enable limit check for current, average, and maximum results (3 values)
-			- P_99_Enabled: bool: OFF | ON Disable or enable limit check for current result (1 value)"""
+	class DevmStruct(StructBase):  # From WriteStructDefinition CmdPropertyTemplate.xml
+		"""Structure for setting input parameters. Fields: \n
+			- Rms: float: No parameter help available
+			- Peak: float: No parameter help available
+			- P_99: float: No parameter help available
+			- Rms_Enabled: List[bool]: No parameter help available
+			- Peak_Enabled: List[bool]: No parameter help available
+			- P_99_Enabled: bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_float('Rms'),
 			ArgStruct.scalar_float('Peak'),
 			ArgStruct.scalar_float('P_99'),
 			ArgStruct('Rms_Enabled', DataType.BooleanList, None, False, False, 3),
 			ArgStruct('Peak_Enabled', DataType.BooleanList, None, False, False, 3),
 			ArgStruct.scalar_bool('P_99_Enabled')]
@@ -38,21 +38,29 @@
 			self.Peak: float = None
 			self.P_99: float = None
 			self.Rms_Enabled: List[bool] = None
 			self.Peak_Enabled: List[bool] = None
 			self.P_99_Enabled: bool = None
 
 	def get_devm(self) -> DevmStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:DQPSk:DEVM \n
-		Snippet: value: DevmStruct = driver.configure.multiEval.limit.edrate.dqpsk.get_devm() \n
-		Defines and activates upper limits for the differential error vector magnitude for π/4 DQPSK modulated packets (2-DHx) . \n
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:QHSL:P2Q:DEVM \n
+		Snippet: value: DevmStruct = driver.configure.multiEval.limit.qhsl.p2Q.get_devm() \n
+		No command help available \n
 			:return: structure: for return value, see the help for DevmStruct structure arguments.
 		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:DQPSk:DEVM?', self.__class__.DevmStruct())
+		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:QHSL:P2Q:DEVM?', self.__class__.DevmStruct())
 
 	def set_devm(self, value: DevmStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:DQPSk:DEVM \n
-		Snippet: driver.configure.multiEval.limit.edrate.dqpsk.set_devm(value = DevmStruct()) \n
-		Defines and activates upper limits for the differential error vector magnitude for π/4 DQPSK modulated packets (2-DHx) . \n
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:QHSL:P2Q:DEVM \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.limit.qhsl.p2Q.DevmStruct() \n
+		structure.Rms: float = 1.0 \n
+		structure.Peak: float = 1.0 \n
+		structure.P_99: float = 1.0 \n
+		structure.Rms_Enabled: List[bool] = [True, False, True] \n
+		structure.Peak_Enabled: List[bool] = [True, False, True] \n
+		structure.P_99_Enabled: bool = False \n
+		driver.configure.multiEval.limit.qhsl.p2Q.set_devm(value = structure) \n
+		No command help available \n
 			:param value: see the help for DevmStruct structure arguments.
 		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:DQPSk:DEVM', value)
+		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:QHSL:P2Q:DEVM', value)
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/Edrate_/Pencoding.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/LowEnergy/Lrange.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,79 +1,74 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pencoding:
-	"""Pencoding commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class LrangeCls:
+	"""Lrange commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pencoding", core, parent)
+		self._cmd_group = CommandsGroup("lrange", core, parent)
 
 	# noinspection PyTypeChecker
-	class SsequenceStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Sync_Bit_Errors: int: numeric Upper limit for sync bit errors. Range: 0 to 1000
-			- Trailer_Bit_Errs: int: numeric Upper limit for trailer bit errors. Range: 0 to 1000
-			- Sync_Bit_Enable: bool: OFF | ON Disable or enable the limit check.
-			- Trailer_Bit_Enable: bool: OFF | ON Disable or enable the limit check."""
+	class ResultData(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: decimal 'Reliability indicator'
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm
+			- No_Of_Exceptions: int: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99"""
 		__meta_args_list = [
-			ArgStruct.scalar_int('Sync_Bit_Errors'),
-			ArgStruct.scalar_int('Trailer_Bit_Errs'),
-			ArgStruct.scalar_bool('Sync_Bit_Enable'),
-			ArgStruct.scalar_bool('Trailer_Bit_Enable')]
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_int('No_Of_Exceptions')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Sync_Bit_Errors: int = None
-			self.Trailer_Bit_Errs: int = None
-			self.Sync_Bit_Enable: bool = None
-			self.Trailer_Bit_Enable: bool = None
-
-	def get_ssequence(self) -> SsequenceStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:PENCoding:SSEQuence \n
-		Snippet: value: SsequenceStruct = driver.configure.multiEval.limit.edrate.pencoding.get_ssequence() \n
-		Defines the limit for the differential phase encoding measurement in combined signal path. \n
-			:return: structure: for return value, see the help for SsequenceStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:PENCoding:SSEQuence?', self.__class__.SsequenceStruct())
-
-	def set_ssequence(self, value: SsequenceStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:PENCoding:SSEQuence \n
-		Snippet: driver.configure.multiEval.limit.edrate.pencoding.set_ssequence(value = SsequenceStruct()) \n
-		Defines the limit for the differential phase encoding measurement in combined signal path. \n
-			:param value: see the help for SsequenceStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:PENCoding:SSEQuence', value)
+			self.Reliability: int = None
+			self.Nominal_Power: float = None
+			self.No_Of_Exceptions: int = None
+
+	def read(self) -> ResultData:
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LRANge \n
+		Snippet: value: ResultData = driver.multiEval.sacp.lowEnergy.lrange.read() \n
+		Returns the 'Spectrum ACP' results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . See 'View Spectrum ACP'.
+		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
+		one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LRANge?', self.__class__.ResultData())
+
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LRANge \n
+		Snippet: value: ResultData = driver.multiEval.sacp.lowEnergy.lrange.fetch() \n
+		Returns the 'Spectrum ACP' results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . See 'View Spectrum ACP'.
+		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
+		one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LRANge?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
-	class ValueStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Phase_Encoding: float: numeric Lower limit as percentage of received fault free packets. Range: 0 to 1
-			- Phase_Encod_Enable: bool: OFF | ON Disable or enable limit check for the phase encoding."""
+	class CalculateStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: decimal 'Reliability indicator'
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm
+			- No_Of_Exceptions: float or bool: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99"""
 		__meta_args_list = [
-			ArgStruct.scalar_float('Phase_Encoding'),
-			ArgStruct.scalar_bool('Phase_Encod_Enable')]
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('No_Of_Exceptions')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Phase_Encoding: float = None
-			self.Phase_Encod_Enable: bool = None
-
-	def get_value(self) -> ValueStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:PENCoding \n
-		Snippet: value: ValueStruct = driver.configure.multiEval.limit.edrate.pencoding.get_value() \n
-		Defines the limit for the phase encoding measurement. \n
-			:return: structure: for return value, see the help for ValueStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:PENCoding?', self.__class__.ValueStruct())
-
-	def set_value(self, value: ValueStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:PENCoding \n
-		Snippet: driver.configure.multiEval.limit.edrate.pencoding.set_value(value = ValueStruct()) \n
-		Defines the limit for the phase encoding measurement. \n
-			:param value: see the help for ValueStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:EDRate:PENCoding', value)
+			self.Reliability: int = None
+			self.Nominal_Power: float or bool = None
+			self.No_Of_Exceptions: float or bool = None
+
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LRANge \n
+		Snippet: value: CalculateStruct = driver.multiEval.sacp.lowEnergy.lrange.calculate() \n
+		Returns the 'Spectrum ACP' results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . See 'View Spectrum ACP'.
+		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
+		one value for each result listed below. \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LRANge?', self.__class__.CalculateStruct())
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Limit_/LowEnergy_/Daverage.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Cte/LowEnergy/Le2M/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,86 +1,92 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.Types import DataType
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.Types import DataType
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Daverage:
-	"""Daverage commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class Le2MCls:
+	"""Le2M commands group definition. 3 total commands, 2 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("daverage", core, parent)
+		self._cmd_group = CommandsGroup("le2M", core, parent)
 
-	# noinspection PyTypeChecker
-	class Df2SStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Freq_Dev_F_2_Lower: float: numeric Range: 0 Hz to 500 kHz
-			- Freq_Dev_F_2_Upper: float: numeric Range: 0 Hz to 500 kHz
-			- Freq_Dev_F_2_Enable: List[bool]: OFF | ON Disable or enable limits for current, average, maximum, and minimum results (4 values)"""
-		__meta_args_list = [
-			ArgStruct.scalar_float('Freq_Dev_F_2_Lower'),
-			ArgStruct.scalar_float('Freq_Dev_F_2_Upper'),
-			ArgStruct('Freq_Dev_F_2_Enable', DataType.BooleanList, None, False, False, 4)]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Freq_Dev_F_2_Lower: float = None
-			self.Freq_Dev_F_2_Upper: float = None
-			self.Freq_Dev_F_2_Enable: List[bool] = None
-
-	def get_df_2_s(self) -> Df2SStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:LENergy:DAVerage:DF2S \n
-		Snippet: value: Df2SStruct = driver.configure.multiEval.limit.lowEnergy.daverage.get_df_2_s() \n
-		Defines the lower and upper Δf2 frequency deviation limits for uncoded LE 1M PHY. The mnemonics DAVerage, DMINimum,
-		DMAXimum distinguish average, minimum and maximum frequency deviations. \n
-			:return: structure: for return value, see the help for Df2SStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:LENergy:DAVerage:DF2S?', self.__class__.Df2SStruct())
-
-	def set_df_2_s(self, value: Df2SStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:LENergy:DAVerage:DF2S \n
-		Snippet: driver.configure.multiEval.limit.lowEnergy.daverage.set_df_2_s(value = Df2SStruct()) \n
-		Defines the lower and upper Δf2 frequency deviation limits for uncoded LE 1M PHY. The mnemonics DAVerage, DMINimum,
-		DMAXimum distinguish average, minimum and maximum frequency deviations. \n
-			:param value: see the help for Df2SStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:LENergy:DAVerage:DF2S', value)
+	@property
+	def pdeviation(self):
+		"""pdeviation commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_pdeviation'):
+			from .Pdeviation import PdeviationCls
+			self._pdeviation = PdeviationCls(self._core, self._cmd_group)
+		return self._pdeviation
+
+	@property
+	def foffset(self):
+		"""foffset commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_foffset'):
+			from .Foffset import FoffsetCls
+			self._foffset = FoffsetCls(self._core, self._cmd_group)
+		return self._foffset
 
 	# noinspection PyTypeChecker
-	class ValueStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Freq_Dev_F_1_Lower: float: numeric Range: 0 Hz to 500 kHz
-			- Freq_Dev_F_1_Upper: float: numeric Range: 0 Hz to 500 kHz
-			- Freq_Dev_F_1_Enable: List[bool]: OFF | ON Disable or enable limits for current, average, maximum, and minimum results (4 values)"""
+	class FdriftStruct(StructBase):  # From WriteStructDefinition CmdPropertyTemplate.xml
+		"""Structure for setting input parameters. Fields: \n
+			- Frequency_Drift: float: numeric Range: 0 Hz to 500 kHz
+			- Max_Drift_Rate: float: numeric Range: 0 Hz to 500 kHz
+			- Initl_Freq_Drift: float: numeric Range: 0 Hz to 500 kHz
+			- Freq_Drift_Enable: List[bool]: OFF | ON Disable or enable limit checking for current, average, and maximum results (3 values) .
+			- Max_Drift_Rate_Enb: List[bool]: OFF | ON Disable or enable limit checking for current, average, and maximum results (3 values) .
+			- Init_Freq_Drift_En: List[bool]: OFF | ON Disable or enable limit checking for current, average, and maximum results (3 values) ."""
 		__meta_args_list = [
-			ArgStruct.scalar_float('Freq_Dev_F_1_Lower'),
-			ArgStruct.scalar_float('Freq_Dev_F_1_Upper'),
-			ArgStruct('Freq_Dev_F_1_Enable', DataType.BooleanList, None, False, False, 4)]
+			ArgStruct.scalar_float('Frequency_Drift'),
+			ArgStruct.scalar_float('Max_Drift_Rate'),
+			ArgStruct.scalar_float('Initl_Freq_Drift'),
+			ArgStruct('Freq_Drift_Enable', DataType.BooleanList, None, False, False, 3),
+			ArgStruct('Max_Drift_Rate_Enb', DataType.BooleanList, None, False, False, 3),
+			ArgStruct('Init_Freq_Drift_En', DataType.BooleanList, None, False, False, 3)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Freq_Dev_F_1_Lower: float = None
-			self.Freq_Dev_F_1_Upper: float = None
-			self.Freq_Dev_F_1_Enable: List[bool] = None
-
-	def get_value(self) -> ValueStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:LENergy:DAVerage \n
-		Snippet: value: ValueStruct = driver.configure.multiEval.limit.lowEnergy.daverage.get_value() \n
-		Defines the lower and upper Δf1 frequency deviation limits for LE 1M PHY. The mnemonics DAVerage, DMINimum, DMAXimum
-		distinguish average, minimum and maximum frequency deviations. \n
-			:return: structure: for return value, see the help for ValueStruct structure arguments.
+			self.Frequency_Drift: float = None
+			self.Max_Drift_Rate: float = None
+			self.Initl_Freq_Drift: float = None
+			self.Freq_Drift_Enable: List[bool] = None
+			self.Max_Drift_Rate_Enb: List[bool] = None
+			self.Init_Freq_Drift_En: List[bool] = None
+
+	def get_fdrift(self) -> FdriftStruct:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE2M:FDRift \n
+		Snippet: value: FdriftStruct = driver.configure.multiEval.limit.cte.lowEnergy.le2M.get_fdrift() \n
+		Sets and enables limits for frequency drift, maximum drift rate and initial frequency drift for the CTE portion. Commands
+		for uncoded LE 1M PHY (..:LE1M..) and LE 2M PHY (..:LE2M..) are available. \n
+			:return: structure: for return value, see the help for FdriftStruct structure arguments.
 		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:LENergy:DAVerage?', self.__class__.ValueStruct())
+		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE2M:FDRift?', self.__class__.FdriftStruct())
 
-	def set_value(self, value: ValueStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:LENergy:DAVerage \n
-		Snippet: driver.configure.multiEval.limit.lowEnergy.daverage.set_value(value = ValueStruct()) \n
-		Defines the lower and upper Δf1 frequency deviation limits for LE 1M PHY. The mnemonics DAVerage, DMINimum, DMAXimum
-		distinguish average, minimum and maximum frequency deviations. \n
-			:param value: see the help for ValueStruct structure arguments.
+	def set_fdrift(self, value: FdriftStruct) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE2M:FDRift \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.limit.cte.lowEnergy.le2M.FdriftStruct() \n
+		structure.Frequency_Drift: float = 1.0 \n
+		structure.Max_Drift_Rate: float = 1.0 \n
+		structure.Initl_Freq_Drift: float = 1.0 \n
+		structure.Freq_Drift_Enable: List[bool] = [True, False, True] \n
+		structure.Max_Drift_Rate_Enb: List[bool] = [True, False, True] \n
+		structure.Init_Freq_Drift_En: List[bool] = [True, False, True] \n
+		driver.configure.multiEval.limit.cte.lowEnergy.le2M.set_fdrift(value = structure) \n
+		Sets and enables limits for frequency drift, maximum drift rate and initial frequency drift for the CTE portion. Commands
+		for uncoded LE 1M PHY (..:LE1M..) and LE 2M PHY (..:LE2M..) are available. \n
+			:param value: see the help for FdriftStruct structure arguments.
 		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:LENergy:DAVerage', value)
+		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:CTE:LENergy:LE2M:FDRift', value)
+
+	def clone(self) -> 'Le2MCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = Le2MCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/Qhsl/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,92 +1,130 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
+from typing import List
+
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ListPy:
-	"""ListPy commands group definition. 34 total commands, 2 Sub-groups, 3 group commands"""
+class QhslCls:
+	"""Qhsl commands group definition. 8 total commands, 7 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("listPy", core, parent)
+		self._cmd_group = CommandsGroup("qhsl", core, parent)
 
 	@property
-	def segment(self):
-		"""segment commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_segment'):
-			from .ListPy_.Segment import Segment
-			self._segment = Segment(self._core, self._base)
-		return self._segment
-
-	@property
-	def singleCmw(self):
-		"""singleCmw commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_singleCmw'):
-			from .ListPy_.SingleCmw import SingleCmw
-			self._singleCmw = SingleCmw(self._core, self._base)
-		return self._singleCmw
-
-	def get_count(self) -> int:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:COUNt \n
-		Snippet: value: int = driver.configure.multiEval.listPy.get_count() \n
-		Defines the number of segments in the entire measurement interval. \n
-			:return: segments: numeric Range: 1 to 48
-		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:COUNt?')
-		return Conversions.str_to_int(response)
+	def powerVsTime(self):
+		"""powerVsTime commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_powerVsTime'):
+			from .PowerVsTime import PowerVsTimeCls
+			self._powerVsTime = PowerVsTimeCls(self._core, self._cmd_group)
+		return self._powerVsTime
 
-	def set_count(self, segments: int) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:COUNt \n
-		Snippet: driver.configure.multiEval.listPy.set_count(segments = 1) \n
-		Defines the number of segments in the entire measurement interval. \n
-			:param segments: numeric Range: 1 to 48
-		"""
-		param = Conversions.decimal_value_to_str(segments)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:COUNt {param}')
+	@property
+	def p2Q(self):
+		"""p2Q commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_p2Q'):
+			from .P2Q import P2QCls
+			self._p2Q = P2QCls(self._core, self._cmd_group)
+		return self._p2Q
+
+	@property
+	def p3Q(self):
+		"""p3Q commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_p3Q'):
+			from .P3Q import P3QCls
+			self._p3Q = P3QCls(self._core, self._cmd_group)
+		return self._p3Q
+
+	@property
+	def p4Q(self):
+		"""p4Q commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_p4Q'):
+			from .P4Q import P4QCls
+			self._p4Q = P4QCls(self._core, self._cmd_group)
+		return self._p4Q
+
+	@property
+	def p5Q(self):
+		"""p5Q commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_p5Q'):
+			from .P5Q import P5QCls
+			self._p5Q = P5QCls(self._core, self._cmd_group)
+		return self._p5Q
+
+	@property
+	def p6Q(self):
+		"""p6Q commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_p6Q'):
+			from .P6Q import P6QCls
+			self._p6Q = P6QCls(self._core, self._cmd_group)
+		return self._p6Q
+
+	@property
+	def sacp(self):
+		"""sacp commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_sacp'):
+			from .Sacp import SacpCls
+			self._sacp = SacpCls(self._core, self._cmd_group)
+		return self._sacp
 
 	# noinspection PyTypeChecker
-	def get_malgorithm(self) -> enums.PatternIndependent:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:MALGorithm \n
-		Snippet: value: enums.PatternIndependent = driver.configure.multiEval.listPy.get_malgorithm() \n
+	class FstabilityStruct(StructBase):  # From WriteStructDefinition CmdPropertyTemplate.xml
+		"""Structure for setting input parameters. Fields: \n
+			- Wi: float: No parameter help available
+			- Wiplus_W_0_Max: float: No parameter help available
+			- W_0_Max: float: No parameter help available
+			- Wi_Enabled: List[bool]: No parameter help available
+			- Wi_W_0_Max_Enabled: List[bool]: No parameter help available
+			- W_0_Max_Enabled: List[bool]: No parameter help available"""
+		__meta_args_list = [
+			ArgStruct.scalar_float('Wi'),
+			ArgStruct.scalar_float('Wiplus_W_0_Max'),
+			ArgStruct.scalar_float('W_0_Max'),
+			ArgStruct('Wi_Enabled', DataType.BooleanList, None, False, False, 3),
+			ArgStruct('Wi_W_0_Max_Enabled', DataType.BooleanList, None, False, False, 3),
+			ArgStruct('W_0_Max_Enabled', DataType.BooleanList, None, False, False, 3)]
+
+		def __init__(self):
+			StructBase.__init__(self, self)
+			self.Wi: float = None
+			self.Wiplus_W_0_Max: float = None
+			self.W_0_Max: float = None
+			self.Wi_Enabled: List[bool] = None
+			self.Wi_W_0_Max_Enabled: List[bool] = None
+			self.W_0_Max_Enabled: List[bool] = None
+
+	def get_fstability(self) -> FstabilityStruct:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:QHSL:FSTability \n
+		Snippet: value: FstabilityStruct = driver.configure.multiEval.limit.qhsl.get_fstability() \n
 		No command help available \n
-			:return: pattern_independent: No help available
+			:return: structure: for return value, see the help for FstabilityStruct structure arguments.
 		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:MALGorithm?')
-		return Conversions.str_to_scalar_enum(response, enums.PatternIndependent)
+		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:QHSL:FSTability?', self.__class__.FstabilityStruct())
 
-	def set_malgorithm(self, pattern_independent: enums.PatternIndependent) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:MALGorithm \n
-		Snippet: driver.configure.multiEval.listPy.set_malgorithm(pattern_independent = enums.PatternIndependent.PINDependent) \n
+	def set_fstability(self, value: FstabilityStruct) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:QHSL:FSTability \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.limit.qhsl.FstabilityStruct() \n
+		structure.Wi: float = 1.0 \n
+		structure.Wiplus_W_0_Max: float = 1.0 \n
+		structure.W_0_Max: float = 1.0 \n
+		structure.Wi_Enabled: List[bool] = [True, False, True] \n
+		structure.Wi_W_0_Max_Enabled: List[bool] = [True, False, True] \n
+		structure.W_0_Max_Enabled: List[bool] = [True, False, True] \n
+		driver.configure.multiEval.limit.qhsl.set_fstability(value = structure) \n
 		No command help available \n
-			:param pattern_independent: No help available
-		"""
-		param = Conversions.enum_scalar_to_str(pattern_independent, enums.PatternIndependent)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:MALGorithm {param}')
-
-	def get_value(self) -> bool:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST \n
-		Snippet: value: bool = driver.configure.multiEval.listPy.get_value() \n
-		Enables or disables the list mode. \n
-			:return: enable: OFF | ON OFF: disable list mode ON: enable list mode
-		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST?')
-		return Conversions.str_to_bool(response)
-
-	def set_value(self, enable: bool) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST \n
-		Snippet: driver.configure.multiEval.listPy.set_value(enable = False) \n
-		Enables or disables the list mode. \n
-			:param enable: OFF | ON OFF: disable list mode ON: enable list mode
+			:param value: see the help for FstabilityStruct structure arguments.
 		"""
-		param = Conversions.bool_to_str(enable)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST {param}')
+		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIMit:QHSL:FSTability', value)
 
-	def clone(self) -> 'ListPy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'QhslCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ListPy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = QhslCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,58 +1,74 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.RepeatedCapability import RepeatedCapability
 from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Segment:
-	"""Segment commands group definition. 30 total commands, 3 Sub-groups, 0 group commands
+class SegmentCls:
+	"""Segment commands group definition. 20 total commands, 5 Subgroups, 0 group commands
 	Repeated Capability: Segment, default value after init: Segment.S1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("segment", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_segment_get', 'repcap_segment_set', repcap.Segment.S1)
+		self._cmd_group = CommandsGroup("segment", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_segment_get', 'repcap_segment_set', repcap.Segment.S1)
 
-	def repcap_segment_set(self, enum_value: repcap.Segment) -> None:
+	def repcap_segment_set(self, segment: repcap.Segment) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Segment.Default
 		Default value after init: Segment.S1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(segment)
 
 	def repcap_segment_get(self) -> repcap.Segment:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
-	def setup(self):
-		"""setup commands group. 15 Sub-classes, 1 commands."""
-		if not hasattr(self, '_setup'):
-			from .Segment_.Setup import Setup
-			self._setup = Setup(self._core, self._base)
-		return self._setup
+	def pencoding(self):
+		"""pencoding commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_pencoding'):
+			from .Pencoding import PencodingCls
+			self._pencoding = PencodingCls(self._core, self._cmd_group)
+		return self._pencoding
 
 	@property
-	def scount(self):
-		"""scount commands group. 6 Sub-classes, 1 commands."""
-		if not hasattr(self, '_scount'):
-			from .Segment_.Scount import Scount
-			self._scount = Scount(self._core, self._base)
-		return self._scount
+	def sacp(self):
+		"""sacp commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_sacp'):
+			from .Sacp import SacpCls
+			self._sacp = SacpCls(self._core, self._cmd_group)
+		return self._sacp
 
 	@property
-	def results(self):
-		"""results commands group. 6 Sub-classes, 1 commands."""
-		if not hasattr(self, '_results'):
-			from .Segment_.Results import Results
-			self._results = Results(self._core, self._base)
-		return self._results
+	def soBw(self):
+		"""soBw commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_soBw'):
+			from .SoBw import SoBwCls
+			self._soBw = SoBwCls(self._core, self._cmd_group)
+		return self._soBw
 
-	def clone(self) -> 'Segment':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def modulation(self):
+		"""modulation commands group. 7 Sub-classes, 0 commands."""
+		if not hasattr(self, '_modulation'):
+			from .Modulation import ModulationCls
+			self._modulation = ModulationCls(self._core, self._cmd_group)
+		return self._modulation
+
+	@property
+	def powerVsTime(self):
+		"""powerVsTime commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_powerVsTime'):
+			from .PowerVsTime import PowerVsTimeCls
+			self._powerVsTime = PowerVsTimeCls(self._core, self._cmd_group)
+		return self._powerVsTime
+
+	def clone(self) -> 'SegmentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Segment(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SegmentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Results.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Nmode/LowEnergy/Le2M.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,111 +1,74 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Results:
-	"""Results commands group definition. 7 total commands, 6 Sub-groups, 1 group commands"""
+class Le2MCls:
+	"""Le2M commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("results", core, parent)
+		self._cmd_group = CommandsGroup("le2M", core, parent)
 
-	@property
-	def mscalar(self):
-		"""mscalar commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_mscalar'):
-			from .Results_.Mscalar import Mscalar
-			self._mscalar = Mscalar(self._core, self._base)
-		return self._mscalar
-
-	@property
-	def pencoding(self):
-		"""pencoding commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_pencoding'):
-			from .Results_.Pencoding import Pencoding
-			self._pencoding = Pencoding(self._core, self._base)
-		return self._pencoding
-
-	@property
-	def pscalar(self):
-		"""pscalar commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_pscalar'):
-			from .Results_.Pscalar import Pscalar
-			self._pscalar = Pscalar(self._core, self._base)
-		return self._pscalar
-
-	@property
-	def soBw(self):
-		"""soBw commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_soBw'):
-			from .Results_.SoBw import SoBw
-			self._soBw = SoBw(self._core, self._base)
-		return self._soBw
-
-	@property
-	def sacp(self):
-		"""sacp commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_sacp'):
-			from .Results_.Sacp import Sacp
-			self._sacp = Sacp(self._core, self._base)
-		return self._sacp
-
-	@property
-	def sgacp(self):
-		"""sgacp commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_sgacp'):
-			from .Results_.Sgacp import Sgacp
-			self._sgacp = Sgacp(self._core, self._base)
-		return self._sgacp
+	# noinspection PyTypeChecker
+	class ResultData(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: decimal 'Reliability indicator'
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to +30.0 dBm , Unit: dBm
+			- No_Of_Exceptions: int: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99"""
+		__meta_args_list = [
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_int('No_Of_Exceptions')]
+
+		def __init__(self):
+			StructBase.__init__(self, self)
+			self.Reliability: int = None
+			self.Nominal_Power: float = None
+			self.No_Of_Exceptions: int = None
+
+	def read(self) -> ResultData:
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LE2M \n
+		Snippet: value: ResultData = driver.multiEval.sacp.nmode.lowEnergy.le2M.read() \n
+		Returns the 'Spectrum ACP' results for LE normal mode, see 'View Spectrum ACP'. Commands for uncoded LE 1M PHY (..:LE1M..
+		) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by
+		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LE2M?', self.__class__.ResultData())
+
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LE2M \n
+		Snippet: value: ResultData = driver.multiEval.sacp.nmode.lowEnergy.le2M.fetch() \n
+		Returns the 'Spectrum ACP' results for LE normal mode, see 'View Spectrum ACP'. Commands for uncoded LE 1M PHY (..:LE1M..
+		) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by
+		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LE2M?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
-	class ResultsStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Enable_Mod_Scalar: bool: OFF | ON Enable/disable statistical modulation results
-			- Enable_Pow_Scalar: bool: OFF | ON Enable/disable statistical power results
-			- Enable_Spec_Obw: bool: OFF | ON Enable/disable the spectrum 20 dB bandwidth results (BR)
-			- Enable_Spec_Acp: bool: OFF | ON Enable/disable the spectrum ACP results (BR, LE)
-			- Enable_Spec_Gat_Acp: bool: OFF | ON Enable/disable the spectrum gated ACP results (EDR)"""
+	class CalculateStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: decimal 'Reliability indicator'
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128.0 dBm to +30.0 dBm , Unit: dBm
+			- No_Of_Exceptions: float or bool: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99"""
 		__meta_args_list = [
-			ArgStruct.scalar_bool('Enable_Mod_Scalar'),
-			ArgStruct.scalar_bool('Enable_Pow_Scalar'),
-			ArgStruct.scalar_bool('Enable_Spec_Obw'),
-			ArgStruct.scalar_bool('Enable_Spec_Acp'),
-			ArgStruct.scalar_bool('Enable_Spec_Gat_Acp')]
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('No_Of_Exceptions')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Enable_Mod_Scalar: bool = None
-			self.Enable_Pow_Scalar: bool = None
-			self.Enable_Spec_Obw: bool = None
-			self.Enable_Spec_Acp: bool = None
-			self.Enable_Spec_Gat_Acp: bool = None
-
-	def set(self, structure: ResultsStruct, segment=repcap.Segment.Default) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RESults \n
-		Snippet: driver.configure.multiEval.listPy.segment.results.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default) \n
-		Enables or disables the evaluation of the particular measurement type in the segment. \n
-			:param structure: for set value, see the help for ResultsStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		self._core.io.write_struct(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RESults', structure)
-
-	def get(self, segment=repcap.Segment.Default) -> ResultsStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RESults \n
-		Snippet: value: ResultsStruct = driver.configure.multiEval.listPy.segment.results.get(segment = repcap.Segment.Default) \n
-		Enables or disables the evaluation of the particular measurement type in the segment. \n
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
-			:return: structure: for return value, see the help for ResultsStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RESults?', self.__class__.ResultsStruct())
-
-	def clone(self) -> 'Results':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
-		Also copies all the existing default Repeated Capabilities setting,
-		which you can change independently without affecting the original group"""
-		new_group = Results(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
-		return new_group
+			self.Reliability: int = None
+			self.Nominal_Power: float or bool = None
+			self.No_Of_Exceptions: float or bool = None
+
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LE2M \n
+		Snippet: value: CalculateStruct = driver.multiEval.sacp.nmode.lowEnergy.le2M.calculate() \n
+		Returns the 'Spectrum ACP' results for LE normal mode, see 'View Spectrum ACP'. Commands for uncoded LE 1M PHY (..:LE1M..
+		) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by
+		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LE2M?', self.__class__.CalculateStruct())
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Results_/Mscalar.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Results/Mscalar.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Mscalar:
-	"""Mscalar commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MscalarCls:
+	"""Mscalar commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("mscalar", core, parent)
+		self._cmd_group = CommandsGroup("mscalar", core, parent)
 
 	def set(self, enable_mod_scalar: bool, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RESults:MSCalar \n
 		Snippet: driver.configure.multiEval.listPy.segment.results.mscalar.set(enable_mod_scalar = False, segment = repcap.Segment.Default) \n
 		Enables or disables the evaluation of results for the segment<no> in list mode. The last mnemonic denotes the measurement
 		type: statistical modulation results, statistical power results, spectrum ACP (BR, LE) , spectrum gated ACP (EDR) ,
-		occupied bandwidth (BR) . \n
+		spectrum 20 dB bandwidth (BR) . \n
 			:param enable_mod_scalar: No help available
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.bool_to_str(enable_mod_scalar)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RESults:MSCalar {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RESults:MSCalar \n
 		Snippet: value: bool = driver.configure.multiEval.listPy.segment.results.mscalar.get(segment = repcap.Segment.Default) \n
 		Enables or disables the evaluation of results for the segment<no> in list mode. The last mnemonic denotes the measurement
 		type: statistical modulation results, statistical power results, spectrum ACP (BR, LE) , spectrum gated ACP (EDR) ,
-		occupied bandwidth (BR) . \n
+		spectrum 20 dB bandwidth (BR) . \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: enable_mod_scalar: No help available"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RESults:MSCalar?')
 		return Conversions.str_to_bool(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Results_/Pencoding.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Results/Pencoding.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,33 +1,34 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pencoding:
-	"""Pencoding commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PencodingCls:
+	"""Pencoding commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pencoding", core, parent)
+		self._cmd_group = CommandsGroup("pencoding", core, parent)
 
 	def set(self, enable_phase_enc: bool, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RESults:PENCoding \n
 		Snippet: driver.configure.multiEval.listPy.segment.results.pencoding.set(enable_phase_enc = False, segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param enable_phase_enc: No help available
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.bool_to_str(enable_phase_enc)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RESults:PENCoding {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RESults:PENCoding \n
 		Snippet: value: bool = driver.configure.multiEval.listPy.segment.results.pencoding.get(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: enable_phase_enc: No help available"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RESults:PENCoding?')
 		return Conversions.str_to_bool(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Results_/Pscalar.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Results/Pscalar.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pscalar:
-	"""Pscalar commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PscalarCls:
+	"""Pscalar commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pscalar", core, parent)
+		self._cmd_group = CommandsGroup("pscalar", core, parent)
 
 	def set(self, enable_pow_scalar: bool, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RESults:PSCalar \n
 		Snippet: driver.configure.multiEval.listPy.segment.results.pscalar.set(enable_pow_scalar = False, segment = repcap.Segment.Default) \n
 		Enables or disables the evaluation of results for the segment<no> in list mode. The last mnemonic denotes the measurement
 		type: statistical modulation results, statistical power results, spectrum ACP (BR, LE) , spectrum gated ACP (EDR) ,
-		occupied bandwidth (BR) . \n
+		spectrum 20 dB bandwidth (BR) . \n
 			:param enable_pow_scalar: No help available
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.bool_to_str(enable_pow_scalar)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RESults:PSCalar {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RESults:PSCalar \n
 		Snippet: value: bool = driver.configure.multiEval.listPy.segment.results.pscalar.get(segment = repcap.Segment.Default) \n
 		Enables or disables the evaluation of results for the segment<no> in list mode. The last mnemonic denotes the measurement
 		type: statistical modulation results, statistical power results, spectrum ACP (BR, LE) , spectrum gated ACP (EDR) ,
-		occupied bandwidth (BR) . \n
+		spectrum 20 dB bandwidth (BR) . \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: enable_pow_scalar: No help available"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RESults:PSCalar?')
 		return Conversions.str_to_bool(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Results_/Sacp.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Results/Sgacp.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sacp:
-	"""Sacp commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SgacpCls:
+	"""Sgacp commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sacp", core, parent)
+		self._cmd_group = CommandsGroup("sgacp", core, parent)
 
-	def set(self, enable_spec_acp: bool, segment=repcap.Segment.Default) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RESults:SACP \n
-		Snippet: driver.configure.multiEval.listPy.segment.results.sacp.set(enable_spec_acp = False, segment = repcap.Segment.Default) \n
+	def set(self, enable_spec_gat_acp: bool, segment=repcap.Segment.Default) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RESults:SGACp \n
+		Snippet: driver.configure.multiEval.listPy.segment.results.sgacp.set(enable_spec_gat_acp = False, segment = repcap.Segment.Default) \n
 		Enables or disables the evaluation of results for the segment<no> in list mode. The last mnemonic denotes the measurement
 		type: statistical modulation results, statistical power results, spectrum ACP (BR, LE) , spectrum gated ACP (EDR) ,
-		occupied bandwidth (BR) . \n
-			:param enable_spec_acp: No help available
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
-		param = Conversions.bool_to_str(enable_spec_acp)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RESults:SACP {param}')
+		spectrum 20 dB bandwidth (BR) . \n
+			:param enable_spec_gat_acp: No help available
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
+		param = Conversions.bool_to_str(enable_spec_gat_acp)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RESults:SGACp {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> bool:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RESults:SACP \n
-		Snippet: value: bool = driver.configure.multiEval.listPy.segment.results.sacp.get(segment = repcap.Segment.Default) \n
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RESults:SGACp \n
+		Snippet: value: bool = driver.configure.multiEval.listPy.segment.results.sgacp.get(segment = repcap.Segment.Default) \n
 		Enables or disables the evaluation of results for the segment<no> in list mode. The last mnemonic denotes the measurement
 		type: statistical modulation results, statistical power results, spectrum ACP (BR, LE) , spectrum gated ACP (EDR) ,
-		occupied bandwidth (BR) . \n
+		spectrum 20 dB bandwidth (BR) . \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
-			:return: enable_spec_acp: No help available"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RESults:SACP?')
+			:return: enable_spec_gat_acp: No help available"""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RESults:SGACp?')
 		return Conversions.str_to_bool(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Results_/Sgacp.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Results/SoBw.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sgacp:
-	"""Sgacp commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SoBwCls:
+	"""SoBw commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sgacp", core, parent)
+		self._cmd_group = CommandsGroup("soBw", core, parent)
 
-	def set(self, enable_spec_gat_acp: bool, segment=repcap.Segment.Default) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RESults:SGACp \n
-		Snippet: driver.configure.multiEval.listPy.segment.results.sgacp.set(enable_spec_gat_acp = False, segment = repcap.Segment.Default) \n
+	def set(self, enable_spec_obw: bool, segment=repcap.Segment.Default) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RESults:SOBW \n
+		Snippet: driver.configure.multiEval.listPy.segment.results.soBw.set(enable_spec_obw = False, segment = repcap.Segment.Default) \n
 		Enables or disables the evaluation of results for the segment<no> in list mode. The last mnemonic denotes the measurement
 		type: statistical modulation results, statistical power results, spectrum ACP (BR, LE) , spectrum gated ACP (EDR) ,
-		occupied bandwidth (BR) . \n
-			:param enable_spec_gat_acp: No help available
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
-		param = Conversions.bool_to_str(enable_spec_gat_acp)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RESults:SGACp {param}')
+		spectrum 20 dB bandwidth (BR) . \n
+			:param enable_spec_obw: No help available
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
+		param = Conversions.bool_to_str(enable_spec_obw)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RESults:SOBW {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> bool:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RESults:SGACp \n
-		Snippet: value: bool = driver.configure.multiEval.listPy.segment.results.sgacp.get(segment = repcap.Segment.Default) \n
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RESults:SOBW \n
+		Snippet: value: bool = driver.configure.multiEval.listPy.segment.results.soBw.get(segment = repcap.Segment.Default) \n
 		Enables or disables the evaluation of results for the segment<no> in list mode. The last mnemonic denotes the measurement
 		type: statistical modulation results, statistical power results, spectrum ACP (BR, LE) , spectrum gated ACP (EDR) ,
-		occupied bandwidth (BR) . \n
+		spectrum 20 dB bandwidth (BR) . \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
-			:return: enable_spec_gat_acp: No help available"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RESults:SGACp?')
+			:return: enable_spec_obw: No help available"""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RESults:SOBW?')
 		return Conversions.str_to_bool(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Results_/SoBw.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Results/Sacp.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SoBw:
-	"""SoBw commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SacpCls:
+	"""Sacp commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("soBw", core, parent)
+		self._cmd_group = CommandsGroup("sacp", core, parent)
 
-	def set(self, enable_spec_obw: bool, segment=repcap.Segment.Default) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RESults:SOBW \n
-		Snippet: driver.configure.multiEval.listPy.segment.results.soBw.set(enable_spec_obw = False, segment = repcap.Segment.Default) \n
+	def set(self, enable_spec_acp: bool, segment=repcap.Segment.Default) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RESults:SACP \n
+		Snippet: driver.configure.multiEval.listPy.segment.results.sacp.set(enable_spec_acp = False, segment = repcap.Segment.Default) \n
 		Enables or disables the evaluation of results for the segment<no> in list mode. The last mnemonic denotes the measurement
 		type: statistical modulation results, statistical power results, spectrum ACP (BR, LE) , spectrum gated ACP (EDR) ,
-		occupied bandwidth (BR) . \n
-			:param enable_spec_obw: No help available
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
-		param = Conversions.bool_to_str(enable_spec_obw)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RESults:SOBW {param}')
+		spectrum 20 dB bandwidth (BR) . \n
+			:param enable_spec_acp: No help available
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
+		param = Conversions.bool_to_str(enable_spec_acp)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RESults:SACP {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> bool:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RESults:SOBW \n
-		Snippet: value: bool = driver.configure.multiEval.listPy.segment.results.soBw.get(segment = repcap.Segment.Default) \n
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RESults:SACP \n
+		Snippet: value: bool = driver.configure.multiEval.listPy.segment.results.sacp.get(segment = repcap.Segment.Default) \n
 		Enables or disables the evaluation of results for the segment<no> in list mode. The last mnemonic denotes the measurement
 		type: statistical modulation results, statistical power results, spectrum ACP (BR, LE) , spectrum gated ACP (EDR) ,
-		occupied bandwidth (BR) . \n
+		spectrum 20 dB bandwidth (BR) . \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
-			:return: enable_spec_obw: No help available"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RESults:SOBW?')
+			:return: enable_spec_acp: No help available"""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RESults:SACP?')
 		return Conversions.str_to_bool(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scount.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Scount/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,78 +1,96 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scount:
-	"""Scount commands group definition. 7 total commands, 6 Sub-groups, 1 group commands"""
+class ScountCls:
+	"""Scount commands group definition. 7 total commands, 6 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scount", core, parent)
+		self._cmd_group = CommandsGroup("scount", core, parent)
 
 	@property
 	def mscalar(self):
 		"""mscalar commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_mscalar'):
-			from .Scount_.Mscalar import Mscalar
-			self._mscalar = Mscalar(self._core, self._base)
+			from .Mscalar import MscalarCls
+			self._mscalar = MscalarCls(self._core, self._cmd_group)
 		return self._mscalar
 
 	@property
 	def pencoding(self):
 		"""pencoding commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_pencoding'):
-			from .Scount_.Pencoding import Pencoding
-			self._pencoding = Pencoding(self._core, self._base)
+			from .Pencoding import PencodingCls
+			self._pencoding = PencodingCls(self._core, self._cmd_group)
 		return self._pencoding
 
 	@property
 	def pscalar(self):
 		"""pscalar commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_pscalar'):
-			from .Scount_.Pscalar import Pscalar
-			self._pscalar = Pscalar(self._core, self._base)
+			from .Pscalar import PscalarCls
+			self._pscalar = PscalarCls(self._core, self._cmd_group)
 		return self._pscalar
 
 	@property
 	def soBw(self):
 		"""soBw commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_soBw'):
-			from .Scount_.SoBw import SoBw
-			self._soBw = SoBw(self._core, self._base)
+			from .SoBw import SoBwCls
+			self._soBw = SoBwCls(self._core, self._cmd_group)
 		return self._soBw
 
 	@property
 	def sacp(self):
 		"""sacp commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_sacp'):
-			from .Scount_.Sacp import Sacp
-			self._sacp = Sacp(self._core, self._base)
+			from .Sacp import SacpCls
+			self._sacp = SacpCls(self._core, self._cmd_group)
 		return self._sacp
 
 	@property
 	def sgacp(self):
 		"""sgacp commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_sgacp'):
-			from .Scount_.Sgacp import Sgacp
-			self._sgacp = Sgacp(self._core, self._base)
+			from .Sgacp import SgacpCls
+			self._sgacp = SgacpCls(self._core, self._cmd_group)
 		return self._sgacp
 
+	def set(self, mod_stat_count: int, power_stat_count: int, spec_obw_stat_cnt: int, spec_acp_stat_cnt: int, spec_gat_acp_stat_cnt: int, segment=repcap.Segment.Default) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCOunt \n
+		Snippet: driver.configure.multiEval.listPy.segment.scount.set(mod_stat_count = 1, power_stat_count = 1, spec_obw_stat_cnt = 1, spec_acp_stat_cnt = 1, spec_gat_acp_stat_cnt = 1, segment = repcap.Segment.Default) \n
+		Defines the statistic count for the particular measurement type in the segment. \n
+			:param mod_stat_count: numeric Statistic count for statistical modulation measurement Range: 1 to 1000
+			:param power_stat_count: numeric Statistic count for statistical power measurement Range: 1 to 1000
+			:param spec_obw_stat_cnt: numeric Statistic count for spectrum 20 dB bandwidth measurement (BR) Range: 1 to 1000
+			:param spec_acp_stat_cnt: numeric Statistic count for spectrum ACP (BR, LE) Range: 1 to 1000
+			:param spec_gat_acp_stat_cnt: numeric Statistic count for spectrum gated ACP measurement (EDR) Range: 1 to 1000
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('mod_stat_count', mod_stat_count, DataType.Integer), ArgSingle('power_stat_count', power_stat_count, DataType.Integer), ArgSingle('spec_obw_stat_cnt', spec_obw_stat_cnt, DataType.Integer), ArgSingle('spec_acp_stat_cnt', spec_acp_stat_cnt, DataType.Integer), ArgSingle('spec_gat_acp_stat_cnt', spec_gat_acp_stat_cnt, DataType.Integer))
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCOunt {param}'.rstrip())
+
 	# noinspection PyTypeChecker
 	class ScountStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Mod_Stat_Count: int: numeric Statistic count for the statistical modulation measurement Range: 1 to 1000
-			- Power_Stat_Count: int: numeric Statistic count for the statistical power measurement Range: 1 to 1000
-			- Spec_Obw_Stat_Cnt: int: numeric Statistic count for the spectrum 20 dB bandwidth measurement (BR) Range: 1 to 1000
-			- Spec_Acp_Stat_Cnt: int: numeric Statistic count for the spectrum ACP measurement (BR, LE) Range: 1 to 1000
-			- Spec_Gat_Acp_Stat_Cnt: int: numeric Statistic count for the spectrum gated ACP measurement (EDR) Range: 1 to 1000"""
+		"""Response structure. Fields: \n
+			- Mod_Stat_Count: int: numeric Statistic count for statistical modulation measurement Range: 1 to 1000
+			- Power_Stat_Count: int: numeric Statistic count for statistical power measurement Range: 1 to 1000
+			- Spec_Obw_Stat_Cnt: int: numeric Statistic count for spectrum 20 dB bandwidth measurement (BR) Range: 1 to 1000
+			- Spec_Acp_Stat_Cnt: int: numeric Statistic count for spectrum ACP (BR, LE) Range: 1 to 1000
+			- Spec_Gat_Acp_Stat_Cnt: int: numeric Statistic count for spectrum gated ACP measurement (EDR) Range: 1 to 1000"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Mod_Stat_Count'),
 			ArgStruct.scalar_int('Power_Stat_Count'),
 			ArgStruct.scalar_int('Spec_Obw_Stat_Cnt'),
 			ArgStruct.scalar_int('Spec_Acp_Stat_Cnt'),
 			ArgStruct.scalar_int('Spec_Gat_Acp_Stat_Cnt')]
 
@@ -80,32 +98,23 @@
 			StructBase.__init__(self, self)
 			self.Mod_Stat_Count: int = None
 			self.Power_Stat_Count: int = None
 			self.Spec_Obw_Stat_Cnt: int = None
 			self.Spec_Acp_Stat_Cnt: int = None
 			self.Spec_Gat_Acp_Stat_Cnt: int = None
 
-	def set(self, structure: ScountStruct, segment=repcap.Segment.Default) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCOunt \n
-		Snippet: driver.configure.multiEval.listPy.segment.scount.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default) \n
-		Defines the statistic count for the particular measurement type in the segment. \n
-			:param structure: for set value, see the help for ScountStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		self._core.io.write_struct(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCOunt', structure)
-
 	def get(self, segment=repcap.Segment.Default) -> ScountStruct:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCOunt \n
 		Snippet: value: ScountStruct = driver.configure.multiEval.listPy.segment.scount.get(segment = repcap.Segment.Default) \n
 		Defines the statistic count for the particular measurement type in the segment. \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for ScountStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCOunt?', self.__class__.ScountStruct())
 
-	def clone(self) -> 'Scount':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ScountCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scount(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ScountCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scount_/Mscalar.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Scount/Mscalar.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Mscalar:
-	"""Mscalar commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MscalarCls:
+	"""Mscalar commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("mscalar", core, parent)
+		self._cmd_group = CommandsGroup("mscalar", core, parent)
 
 	def set(self, mod_stat_count: int, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCOunt:MSCalar \n
 		Snippet: driver.configure.multiEval.listPy.segment.scount.mscalar.set(mod_stat_count = 1, segment = repcap.Segment.Default) \n
 		Defines the statistic count in the segment. The last mnemonic denotes the measurement type: statistical modulation
 		measurement, statistical power measurement, spectrum ACP measurement (BR, LE) , spectrum gated ACP measurement (EDR) ,
 		spectrum 20 dB bandwidth (occupied bandwidth) measurement (BR) . \n
 			:param mod_stat_count: numeric Statistic count Range: 1 to 1000
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.decimal_value_to_str(mod_stat_count)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCOunt:MSCalar {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCOunt:MSCalar \n
 		Snippet: value: int = driver.configure.multiEval.listPy.segment.scount.mscalar.get(segment = repcap.Segment.Default) \n
 		Defines the statistic count in the segment. The last mnemonic denotes the measurement type: statistical modulation
 		measurement, statistical power measurement, spectrum ACP measurement (BR, LE) , spectrum gated ACP measurement (EDR) ,
 		spectrum 20 dB bandwidth (occupied bandwidth) measurement (BR) . \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: mod_stat_count: numeric Statistic count Range: 1 to 1000"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCOunt:MSCalar?')
 		return Conversions.str_to_int(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scount_/Pencoding.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Scount/Pencoding.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,33 +1,34 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pencoding:
-	"""Pencoding commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PencodingCls:
+	"""Pencoding commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pencoding", core, parent)
+		self._cmd_group = CommandsGroup("pencoding", core, parent)
 
 	def set(self, phase_enc_stat_cnt: int, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCOunt:PENCoding \n
 		Snippet: driver.configure.multiEval.listPy.segment.scount.pencoding.set(phase_enc_stat_cnt = 1, segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param phase_enc_stat_cnt: No help available
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.decimal_value_to_str(phase_enc_stat_cnt)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCOunt:PENCoding {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCOunt:PENCoding \n
 		Snippet: value: int = driver.configure.multiEval.listPy.segment.scount.pencoding.get(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: phase_enc_stat_cnt: No help available"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCOunt:PENCoding?')
 		return Conversions.str_to_int(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scount_/Pscalar.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Scount/Pscalar.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pscalar:
-	"""Pscalar commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PscalarCls:
+	"""Pscalar commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pscalar", core, parent)
+		self._cmd_group = CommandsGroup("pscalar", core, parent)
 
 	def set(self, power_stat_count: int, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCOunt:PSCalar \n
 		Snippet: driver.configure.multiEval.listPy.segment.scount.pscalar.set(power_stat_count = 1, segment = repcap.Segment.Default) \n
 		Defines the statistic count in the segment. The last mnemonic denotes the measurement type: statistical modulation
 		measurement, statistical power measurement, spectrum ACP measurement (BR, LE) , spectrum gated ACP measurement (EDR) ,
 		spectrum 20 dB bandwidth (occupied bandwidth) measurement (BR) . \n
 			:param power_stat_count: numeric Statistic count Range: 1 to 1000
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.decimal_value_to_str(power_stat_count)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCOunt:PSCalar {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCOunt:PSCalar \n
 		Snippet: value: int = driver.configure.multiEval.listPy.segment.scount.pscalar.get(segment = repcap.Segment.Default) \n
 		Defines the statistic count in the segment. The last mnemonic denotes the measurement type: statistical modulation
 		measurement, statistical power measurement, spectrum ACP measurement (BR, LE) , spectrum gated ACP measurement (EDR) ,
 		spectrum 20 dB bandwidth (occupied bandwidth) measurement (BR) . \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: power_stat_count: numeric Statistic count Range: 1 to 1000"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCOunt:PSCalar?')
 		return Conversions.str_to_int(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scount_/Sacp.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Scount/Sacp.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sacp:
-	"""Sacp commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SacpCls:
+	"""Sacp commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sacp", core, parent)
+		self._cmd_group = CommandsGroup("sacp", core, parent)
 
 	def set(self, spec_acp_stat_cnt: int, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCOunt:SACP \n
 		Snippet: driver.configure.multiEval.listPy.segment.scount.sacp.set(spec_acp_stat_cnt = 1, segment = repcap.Segment.Default) \n
 		Defines the statistic count in the segment. The last mnemonic denotes the measurement type: statistical modulation
 		measurement, statistical power measurement, spectrum ACP measurement (BR, LE) , spectrum gated ACP measurement (EDR) ,
 		spectrum 20 dB bandwidth (occupied bandwidth) measurement (BR) . \n
 			:param spec_acp_stat_cnt: numeric Statistic count Range: 1 to 1000
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.decimal_value_to_str(spec_acp_stat_cnt)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCOunt:SACP {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCOunt:SACP \n
 		Snippet: value: int = driver.configure.multiEval.listPy.segment.scount.sacp.get(segment = repcap.Segment.Default) \n
 		Defines the statistic count in the segment. The last mnemonic denotes the measurement type: statistical modulation
 		measurement, statistical power measurement, spectrum ACP measurement (BR, LE) , spectrum gated ACP measurement (EDR) ,
 		spectrum 20 dB bandwidth (occupied bandwidth) measurement (BR) . \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: spec_acp_stat_cnt: numeric Statistic count Range: 1 to 1000"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCOunt:SACP?')
 		return Conversions.str_to_int(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scount_/Sgacp.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Scount/Sgacp.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sgacp:
-	"""Sgacp commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SgacpCls:
+	"""Sgacp commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sgacp", core, parent)
+		self._cmd_group = CommandsGroup("sgacp", core, parent)
 
 	def set(self, spec_gat_acp_stat_cnt: int, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCOunt:SGACp \n
 		Snippet: driver.configure.multiEval.listPy.segment.scount.sgacp.set(spec_gat_acp_stat_cnt = 1, segment = repcap.Segment.Default) \n
 		Defines the statistic count in the segment. The last mnemonic denotes the measurement type: statistical modulation
 		measurement, statistical power measurement, spectrum ACP measurement (BR, LE) , spectrum gated ACP measurement (EDR) ,
 		spectrum 20 dB bandwidth (occupied bandwidth) measurement (BR) . \n
 			:param spec_gat_acp_stat_cnt: numeric Statistic count Range: 1 to 1000
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.decimal_value_to_str(spec_gat_acp_stat_cnt)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCOunt:SGACp {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCOunt:SGACp \n
 		Snippet: value: int = driver.configure.multiEval.listPy.segment.scount.sgacp.get(segment = repcap.Segment.Default) \n
 		Defines the statistic count in the segment. The last mnemonic denotes the measurement type: statistical modulation
 		measurement, statistical power measurement, spectrum ACP measurement (BR, LE) , spectrum gated ACP measurement (EDR) ,
 		spectrum 20 dB bandwidth (occupied bandwidth) measurement (BR) . \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: spec_gat_acp_stat_cnt: numeric Statistic count Range: 1 to 1000"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCOunt:SGACp?')
 		return Conversions.str_to_int(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scount_/SoBw.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Scount/SoBw.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SoBw:
-	"""SoBw commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SoBwCls:
+	"""SoBw commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("soBw", core, parent)
+		self._cmd_group = CommandsGroup("soBw", core, parent)
 
 	def set(self, spec_obw_stat_cnt: int, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCOunt:SOBW \n
 		Snippet: driver.configure.multiEval.listPy.segment.scount.soBw.set(spec_obw_stat_cnt = 1, segment = repcap.Segment.Default) \n
 		Defines the statistic count in the segment. The last mnemonic denotes the measurement type: statistical modulation
 		measurement, statistical power measurement, spectrum ACP measurement (BR, LE) , spectrum gated ACP measurement (EDR) ,
 		spectrum 20 dB bandwidth (occupied bandwidth) measurement (BR) . \n
 			:param spec_obw_stat_cnt: numeric Statistic count Range: 1 to 1000
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.decimal_value_to_str(spec_obw_stat_cnt)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCOunt:SOBW {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCOunt:SOBW \n
 		Snippet: value: int = driver.configure.multiEval.listPy.segment.scount.soBw.get(segment = repcap.Segment.Default) \n
 		Defines the statistic count in the segment. The last mnemonic denotes the measurement type: statistical modulation
 		measurement, statistical power measurement, spectrum ACP measurement (BR, LE) , spectrum gated ACP measurement (EDR) ,
 		spectrum 20 dB bandwidth (occupied bandwidth) measurement (BR) . \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: spec_obw_stat_cnt: numeric Statistic count Range: 1 to 1000"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCOunt:SOBW?')
 		return Conversions.str_to_int(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,153 +1,169 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import enums
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import enums
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Setup:
-	"""Setup commands group definition. 16 total commands, 15 Sub-groups, 1 group commands"""
+class SetupCls:
+	"""Setup commands group definition. 20 total commands, 17 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("setup", core, parent)
+		self._cmd_group = CommandsGroup("setup", core, parent)
+
+	@property
+	def cte(self):
+		"""cte commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_cte'):
+			from .Cte import CteCls
+			self._cte = CteCls(self._core, self._cmd_group)
+		return self._cte
 
 	@property
 	def btype(self):
 		"""btype commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_btype'):
-			from .Setup_.Btype import Btype
-			self._btype = Btype(self._core, self._base)
+			from .Btype import BtypeCls
+			self._btype = BtypeCls(self._core, self._cmd_group)
 		return self._btype
 
 	@property
 	def ptype(self):
 		"""ptype commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_ptype'):
-			from .Setup_.Ptype import Ptype
-			self._ptype = Ptype(self._core, self._base)
+			from .Ptype import PtypeCls
+			self._ptype = PtypeCls(self._core, self._cmd_group)
 		return self._ptype
 
 	@property
 	def pattern(self):
 		"""pattern commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_pattern'):
-			from .Setup_.Pattern import Pattern
-			self._pattern = Pattern(self._core, self._base)
+			from .Pattern import PatternCls
+			self._pattern = PatternCls(self._core, self._cmd_group)
 		return self._pattern
 
 	@property
 	def plength(self):
 		"""plength commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_plength'):
-			from .Setup_.Plength import Plength
-			self._plength = Plength(self._core, self._base)
+			from .Plength import PlengthCls
+			self._plength = PlengthCls(self._core, self._cmd_group)
 		return self._plength
 
 	@property
 	def oslots(self):
 		"""oslots commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_oslots'):
-			from .Setup_.Oslots import Oslots
-			self._oslots = Oslots(self._core, self._base)
+			from .Oslots import OslotsCls
+			self._oslots = OslotsCls(self._core, self._cmd_group)
 		return self._oslots
 
 	@property
 	def slength(self):
 		"""slength commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_slength'):
-			from .Setup_.Slength import Slength
-			self._slength = Slength(self._core, self._base)
+			from .Slength import SlengthCls
+			self._slength = SlengthCls(self._core, self._cmd_group)
 		return self._slength
 
 	@property
 	def moException(self):
 		"""moException commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_moException'):
-			from .Setup_.MoException import MoException
-			self._moException = MoException(self._core, self._base)
+			from .MoException import MoExceptionCls
+			self._moException = MoExceptionCls(self._core, self._cmd_group)
 		return self._moException
 
 	@property
 	def envelopePower(self):
 		"""envelopePower commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_envelopePower'):
-			from .Setup_.EnvelopePower import EnvelopePower
-			self._envelopePower = EnvelopePower(self._core, self._base)
+			from .EnvelopePower import EnvelopePowerCls
+			self._envelopePower = EnvelopePowerCls(self._core, self._cmd_group)
 		return self._envelopePower
 
 	@property
 	def frequency(self):
 		"""frequency commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_frequency'):
-			from .Setup_.Frequency import Frequency
-			self._frequency = Frequency(self._core, self._base)
+			from .Frequency import FrequencyCls
+			self._frequency = FrequencyCls(self._core, self._cmd_group)
 		return self._frequency
 
 	@property
 	def filterPy(self):
 		"""filterPy commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_filterPy'):
-			from .Setup_.FilterPy import FilterPy
-			self._filterPy = FilterPy(self._core, self._base)
+			from .FilterPy import FilterPyCls
+			self._filterPy = FilterPyCls(self._core, self._cmd_group)
 		return self._filterPy
 
 	@property
 	def rtrigger(self):
 		"""rtrigger commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rtrigger'):
-			from .Setup_.Rtrigger import Rtrigger
-			self._rtrigger = Rtrigger(self._core, self._base)
+			from .Rtrigger import RtriggerCls
+			self._rtrigger = RtriggerCls(self._core, self._cmd_group)
 		return self._rtrigger
 
 	@property
 	def singleCmw(self):
 		"""singleCmw commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_singleCmw'):
-			from .Setup_.SingleCmw import SingleCmw
-			self._singleCmw = SingleCmw(self._core, self._base)
+			from .SingleCmw import SingleCmwCls
+			self._singleCmw = SingleCmwCls(self._core, self._cmd_group)
 		return self._singleCmw
 
 	@property
 	def phy(self):
 		"""phy commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_phy'):
-			from .Setup_.Phy import Phy
-			self._phy = Phy(self._core, self._base)
+			from .Phy import PhyCls
+			self._phy = PhyCls(self._core, self._cmd_group)
 		return self._phy
 
 	@property
 	def cscheme(self):
 		"""cscheme commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_cscheme'):
-			from .Setup_.Cscheme import Cscheme
-			self._cscheme = Cscheme(self._core, self._base)
+			from .Cscheme import CschemeCls
+			self._cscheme = CschemeCls(self._core, self._cmd_group)
 		return self._cscheme
 
 	@property
 	def extended(self):
 		"""extended commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_extended'):
-			from .Setup_.Extended import Extended
-			self._extended = Extended(self._core, self._base)
+			from .Extended import ExtendedCls
+			self._extended = ExtendedCls(self._core, self._cmd_group)
 		return self._extended
 
+	@property
+	def qhsl(self):
+		"""qhsl commands group. 1 Sub-classes, 1 commands."""
+		if not hasattr(self, '_qhsl'):
+			from .Qhsl import QhslCls
+			self._qhsl = QhslCls(self._core, self._cmd_group)
+		return self._qhsl
+
 	# noinspection PyTypeChecker
 	class SetupStruct(StructBase):
 		"""Structure for setting input parameters. Contains optional setting parameters. Fields: \n
-			- Burst_Type: enums.BurstType: BR | EDR | LE Burst type expected in the segment
-			- Packet_Type: enums.SegmentPacketType: DH1 | DH3 | DH5 | E21P | E23P | E25P | E31P | E33P | E35P | RFPHytest | ADVertiser Packet type expected in the segment DH1, DH3, DH5: BR packet E21P, E23P, E25P, E31P, E33P, E35P: 2-DH1, 2-DH3, 2-DH5, 3-DH1, 3-DH3, 3-DH5 EDR packet RFPHytest: LE test packet ADVertiser: LE advertiser
-			- Pattern_Type: enums.MevPatternType: ALL1 | P11 | OTHer | ALTernating | P44 Payload pattern type expected in the segment ALL1: 11111111 P11: 10101010 OTHer: any pattern except P11, P44 and ALL1 ALTernating: the periodical change of the pattern P11, P44 P44: 11110000
+			- Burst_Type: enums.BurstType: BR | EDR | LE BR: 'Basic Rate' EDR: 'Enhanced Data Rate' LE: 'Low Energy'
+			- Packet_Type: enums.SegmentPacketType: DH1 | DH3 | DH5 | E21P | E23P | E25P | E31P | E33P | E35P | RFPHytest | ADVertiser | RFCTe Packet type expected in the segment DH1, DH3, DH5: BR packet E21P, E23P, E25P, E31P, E33P, E35P: 2-DH1, 2-DH3, 2-DH5, 3-DH1, 3-DH3, 3-DH5 EDR packet RFPHytest: LE test packet ADVertiser: LE advertiser RFCTe: LE with CTE test packet
+			- Pattern_Type: enums.MevPatternType: ALL1 | P11 | OTHer | ALTernating | P44 Payload pattern type expected in the segment: ALL1: 11111111 P11: 10101010 OTHer: any pattern except P11, P44 and ALL1 ALTernating: the periodical change of the pattern P11, P44 P44: 11110000
 			- Payload_Length: int: numeric Payload length expected in the segment Range: 0 Byte(s) to 1021 Byte(s)
-			- No_Of_Off_Slots: int: numeric Number of unused slots between any two occupied slots or slot sequences expected in the segment Range: 1 to 9
+			- No_Of_Off_Slots: int: numeric Number of unused slots between any two occupied slots or slot sequences expected in the segment. Range: 1 to 9
 			- Segment_Length: int: numeric Number of measured bursts in the segment. The sum of the length of all active segments must not exceed 6700 timeslots (1 timeslot = 625 μs duration) . Range: 1 to 1000
-			- Meas_On_Exception: bool: OFF | ON Specifies whether the segment results that the R&S CMW identifies as faulty or inaccurate are rejected. ON: include the erroneous bursts OFF: exclude the erroneous bursts
+			- Meas_On_Exception: bool: No parameter help available
 			- Level: float: numeric Expected nominal power in the segment. The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet. Unit: dBm
 			- Frequency: float: numeric Center frequency for the segment Range: 100 MHz to 6 GHz, Unit: Hz
 			- Meas_Filter: enums.FilterWidth: NARRow | WIDE Filter bandwidth for the segment NARRow: narrow-band filter WIDE: wide-band filter
 			- Retrigger: bool: Optional setting parameter. OFF | ON Specifies whether a trigger event is required for the segment or not. The setting is ignored for the first segment of a measurement. OFF: measure the segment without retrigger ON: trigger event required"""
 		__meta_args_list = [
 			ArgStruct.scalar_enum('Burst_Type', enums.BurstType),
 			ArgStruct.scalar_enum('Packet_Type', enums.SegmentPacketType),
@@ -155,15 +171,15 @@
 			ArgStruct.scalar_int('Payload_Length'),
 			ArgStruct.scalar_int('No_Of_Off_Slots'),
 			ArgStruct.scalar_int('Segment_Length'),
 			ArgStruct.scalar_bool('Meas_On_Exception'),
 			ArgStruct.scalar_float('Level'),
 			ArgStruct.scalar_float('Frequency'),
 			ArgStruct.scalar_enum('Meas_Filter', enums.FilterWidth),
-			ArgStruct.scalar_bool('Retrigger')]
+			ArgStruct.scalar_bool_optional('Retrigger')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Burst_Type: enums.BurstType = None
 			self.Packet_Type: enums.SegmentPacketType = None
 			self.Pattern_Type: enums.MevPatternType = None
 			self.Payload_Length: int = None
@@ -173,32 +189,46 @@
 			self.Level: float = None
 			self.Frequency: float = None
 			self.Meas_Filter: enums.FilterWidth = None
 			self.Retrigger: bool = None
 
 	def set(self, structure: SetupStruct, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup] \n
-		Snippet: driver.configure.multiEval.listPy.segment.setup.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default) \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.listPy.segment.setup.SetupStruct() \n
+		structure.Burst_Type: enums.BurstType = enums.BurstType.BR \n
+		structure.Packet_Type: enums.SegmentPacketType = enums.SegmentPacketType.ADVertiser \n
+		structure.Pattern_Type: enums.MevPatternType = enums.MevPatternType.ALL1 \n
+		structure.Payload_Length: int = 1 \n
+		structure.No_Of_Off_Slots: int = 1 \n
+		structure.Segment_Length: int = 1 \n
+		structure.Meas_On_Exception: bool = False \n
+		structure.Level: float = 1.0 \n
+		structure.Frequency: float = 1.0 \n
+		structure.Meas_Filter: enums.FilterWidth = enums.FilterWidth.NARRow \n
+		structure.Retrigger: bool = False \n
+		driver.configure.multiEval.listPy.segment.setup.set(structure, segment = repcap.Segment.Default) \n
 		Defines the segment length, the signal properties and the analyzer settings for a selected segment. In general, this
 		command must be sent for all segments to be measured. \n
 			:param structure: for set value, see the help for SetupStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write_struct(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup', structure)
 
 	def get(self, segment=repcap.Segment.Default) -> SetupStruct:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup] \n
 		Snippet: value: SetupStruct = driver.configure.multiEval.listPy.segment.setup.get(segment = repcap.Segment.Default) \n
 		Defines the segment length, the signal properties and the analyzer settings for a selected segment. In general, this
 		command must be sent for all segments to be measured. \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for SetupStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup?', self.__class__.SetupStruct())
 
-	def clone(self) -> 'Setup':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SetupCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Setup(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SetupCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Btype.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Btype.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,34 +2,35 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import enums
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Btype:
-	"""Btype commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class BtypeCls:
+	"""Btype commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("btype", core, parent)
+		self._cmd_group = CommandsGroup("btype", core, parent)
 
 	def set(self, burst_type: enums.BurstType, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:BTYPe \n
 		Snippet: driver.configure.multiEval.listPy.segment.setup.btype.set(burst_type = enums.BurstType.BR, segment = repcap.Segment.Default) \n
 		Specifies the burst type of the signal expected in the segment. \n
-			:param burst_type: BR | EDR | LE Burst type expected in the segment.
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param burst_type: BR | EDR | LE BR: 'Basic Rate' EDR: 'Enhanced Data Rate' LE: 'Low Energy'
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.enum_scalar_to_str(burst_type, enums.BurstType)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:BTYPe {param}')
 
 	# noinspection PyTypeChecker
 	def get(self, segment=repcap.Segment.Default) -> enums.BurstType:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:BTYPe \n
 		Snippet: value: enums.BurstType = driver.configure.multiEval.listPy.segment.setup.btype.get(segment = repcap.Segment.Default) \n
 		Specifies the burst type of the signal expected in the segment. \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
-			:return: burst_type: BR | EDR | LE Burst type expected in the segment."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+			:return: burst_type: BR | EDR | LE BR: 'Basic Rate' EDR: 'Enhanced Data Rate' LE: 'Low Energy'"""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:BTYPe?')
 		return Conversions.str_to_scalar_enum(response, enums.BurstType)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Cscheme.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Cscheme.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,36 +2,37 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import enums
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cscheme:
-	"""Cscheme commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CschemeCls:
+	"""Cscheme commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cscheme", core, parent)
+		self._cmd_group = CommandsGroup("cscheme", core, parent)
 
 	def set(self, le_lr_coding: enums.CodingScheme, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:CSCHeme \n
 		Snippet: driver.configure.multiEval.listPy.segment.setup.cscheme.set(le_lr_coding = enums.CodingScheme.S2, segment = repcap.Segment.Default) \n
 		Defines coding scheme S for LE coded PHY according to the core specification version 5.0 for Bluetooth wireless
 		technology. \n
 			:param le_lr_coding: S8 | S2 Coding S = 8 or S = 2
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.enum_scalar_to_str(le_lr_coding, enums.CodingScheme)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:CSCHeme {param}')
 
 	# noinspection PyTypeChecker
 	def get(self, segment=repcap.Segment.Default) -> enums.CodingScheme:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:CSCHeme \n
 		Snippet: value: enums.CodingScheme = driver.configure.multiEval.listPy.segment.setup.cscheme.get(segment = repcap.Segment.Default) \n
 		Defines coding scheme S for LE coded PHY according to the core specification version 5.0 for Bluetooth wireless
 		technology. \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: le_lr_coding: S8 | S2 Coding S = 8 or S = 2"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:CSCHeme?')
 		return Conversions.str_to_scalar_enum(response, enums.CodingScheme)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/EnvelopePower.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/EnvelopePower.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,35 +1,36 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EnvelopePower:
-	"""EnvelopePower commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class EnvelopePowerCls:
+	"""EnvelopePower commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("envelopePower", core, parent)
+		self._cmd_group = CommandsGroup("envelopePower", core, parent)
 
 	def set(self, level: float, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:ENPower \n
 		Snippet: driver.configure.multiEval.listPy.segment.setup.envelopePower.set(level = 1.0, segment = repcap.Segment.Default) \n
 		Specifies the expected nominal power in the segment. The range of the expected nominal power can be calculated as
 		follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin \n
 			:param level: numeric The input power range is stated in the data sheet. Unit: dBm
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.decimal_value_to_str(level)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:ENPower {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> float:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:ENPower \n
 		Snippet: value: float = driver.configure.multiEval.listPy.segment.setup.envelopePower.get(segment = repcap.Segment.Default) \n
 		Specifies the expected nominal power in the segment. The range of the expected nominal power can be calculated as
 		follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: level: numeric The input power range is stated in the data sheet. Unit: dBm"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:ENPower?')
 		return Conversions.str_to_float(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Extended.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Extended.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,80 +3,104 @@
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 from ....... import enums
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extended:
-	"""Extended commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ExtendedCls:
+	"""Extended commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extended", core, parent)
+		self._cmd_group = CommandsGroup("extended", core, parent)
 
 	# noinspection PyTypeChecker
 	class ExtendedStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Burst_Type: enums.BurstType: BR | EDR | LE Burst type expected in the segment
-			- Phy: enums.LePhysicalType: LE1M | LE2M | LELR Relevant only for LE. Set dummy value for other burst types. LE1M: LE 1 Msymbol/s PHY LE2M: LE 2 Msymbol/s PHY LELR: Long range (LE coded PHY)
+		"""Structure for setting input parameters. Contains optional setting parameters. Fields: \n
+			- Burst_Type: enums.BurstType: BR | EDR | LE BR: 'Basic Rate' EDR: 'Enhanced Data Rate' LE: 'Low Energy'
+			- Phy: enums.LePhysicalTypeB: LE1M | LE2M | LELR LE1M: LE 1 Msymbol/s uncoded PHY LE2M: LE 2 Msymbol/s uncoded PHY LELR: LE 1 Msymbol/s long range (LE coded PHY)
 			- Coding: enums.CodingScheme: S8 | S2 Coding S = 8 or S = 2 relevant only for LELR PHY Set dummy value for other physical layers.
-			- Packet_Type: enums.SegmentPacketType: DH1 | DH3 | DH5 | E21P | E23P | E25P | E31P | E33P | E35P | RFPHytest | ADVertiser Packet type expected in the segment DH1, DH3, DH5: BR packet E21P, E23P, E25P, E31P, E33P, E35P: 2-DH1, 2-DH3, 2-DH5, 3-DH1, 3-DH3, 3-DH5 EDR packet RFPHytest: LE test packet ADVertiser: LE advertiser
+			- Packet_Type: enums.SegmentPacketType: DH1 | DH3 | DH5 | E21P | E23P | E25P | E31P | E33P | E35P | RFPHytest | ADVertiser | RFCTe Packet type expected in the segment DH1, DH3, DH5: BR packet E21P, E23P, E25P, E31P, E33P, E35P: 2-DH1, 2-DH3, 2-DH5, 3-DH1, 3-DH3, 3-DH5 EDR packet RFPHytest: LE test packet ADVertiser: LE advertiser RFCTe: LE with CTE test packet
 			- Pattern_Type: enums.MevPatternType: ALL1 | P11 | OTHer | ALTernating | P44 Payload pattern type expected in the segment ALL1: 11111111 P11: 10101010 OTHer: any pattern except P11, P44 and ALL1 ALTernating: the periodical change of the pattern P11, P44 P44: 11110000
 			- Payload_Length: int: numeric Payload length expected in the segment Range: 0 Byte(s) to 1021 Byte(s)
-			- No_Of_Off_Slots: int: numeric Number of unused slots between any two occupied slots or slot sequences expected in the segment Range: 1 to 9
+			- No_Of_Off_Slots: int: numeric Number of unused slots between any two occupied slots or slot sequences expected in the segment. Range: 1 to 9
 			- Segment_Length: int: numeric Number of measured bursts in the segment. The sum of the length of all active segments must not exceed 6700 timeslots (1 timeslot = 625 μs duration) . Range: 1 to 1000
 			- Meas_On_Exception: bool: No parameter help available
 			- Level: float: numeric Expected nominal power in the segment. The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet.
 			- Frequency: float: numeric Center frequency for the segment Range: 100 MHz to 6 GHz
 			- Meas_Filter: enums.FilterWidth: NARRow | WIDE Filter bandwidth for the segment NARRow: narrow-band filter WIDE: wide-band filter
-			- Retrigger: bool: OFF | ON Specifies whether a trigger event is required for the segment or not. The setting is ignored for the first segment of a measurement. OFF: measure the segment without retrigger ON: trigger event required"""
+			- Retrigger: bool: OFF | ON Specifies whether a trigger event is required for the segment or not. The setting is ignored for the first segment of a measurement. OFF: measure the segment without retrigger ON: trigger event required
+			- Cte_Units: int: Optional setting parameter. numeric No. of CTE units for LE with CTE, one unit corresponds to 8 μs. Range: 2 Byte(s) to 30 Byte(s)
+			- Cte_Type: enums.CteType: Optional setting parameter. AOA | AOD1 | AOD2 CTE slot type for LE with CTE AOA: CTE type angle of arrival, 2 μs slot AOD1: CTE type angle of departure, 1 μs slot AOD2: CTE type angle of departure, 2 μs slot"""
 		__meta_args_list = [
 			ArgStruct.scalar_enum('Burst_Type', enums.BurstType),
-			ArgStruct.scalar_enum('Phy', enums.LePhysicalType),
+			ArgStruct.scalar_enum('Phy', enums.LePhysicalTypeB),
 			ArgStruct.scalar_enum('Coding', enums.CodingScheme),
 			ArgStruct.scalar_enum('Packet_Type', enums.SegmentPacketType),
 			ArgStruct.scalar_enum('Pattern_Type', enums.MevPatternType),
 			ArgStruct.scalar_int('Payload_Length'),
 			ArgStruct.scalar_int('No_Of_Off_Slots'),
 			ArgStruct.scalar_int('Segment_Length'),
 			ArgStruct.scalar_bool('Meas_On_Exception'),
 			ArgStruct.scalar_float('Level'),
 			ArgStruct.scalar_float('Frequency'),
 			ArgStruct.scalar_enum('Meas_Filter', enums.FilterWidth),
-			ArgStruct.scalar_bool('Retrigger')]
+			ArgStruct.scalar_bool('Retrigger'),
+			ArgStruct.scalar_int_optional('Cte_Units'),
+			ArgStruct.scalar_enum_optional('Cte_Type', enums.CteType)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Burst_Type: enums.BurstType = None
-			self.Phy: enums.LePhysicalType = None
+			self.Phy: enums.LePhysicalTypeB = None
 			self.Coding: enums.CodingScheme = None
 			self.Packet_Type: enums.SegmentPacketType = None
 			self.Pattern_Type: enums.MevPatternType = None
 			self.Payload_Length: int = None
 			self.No_Of_Off_Slots: int = None
 			self.Segment_Length: int = None
 			self.Meas_On_Exception: bool = None
 			self.Level: float = None
 			self.Frequency: float = None
 			self.Meas_Filter: enums.FilterWidth = None
 			self.Retrigger: bool = None
+			self.Cte_Units: int = None
+			self.Cte_Type: enums.CteType = None
 
 	def set(self, structure: ExtendedStruct, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:EXTended \n
-		Snippet: driver.configure.multiEval.listPy.segment.setup.extended.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default) \n
-		Defines the segment length, the signal properties including Bluetooth version 5 and the analyzer settings for a selected
-		segment. In general, this command must be sent for all segments to be measured. \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.listPy.segment.setup.extended.ExtendedStruct() \n
+		structure.Burst_Type: enums.BurstType = enums.BurstType.BR \n
+		structure.Phy: enums.LePhysicalTypeB = enums.LePhysicalTypeB.LE1M \n
+		structure.Coding: enums.CodingScheme = enums.CodingScheme.S2 \n
+		structure.Packet_Type: enums.SegmentPacketType = enums.SegmentPacketType.ADVertiser \n
+		structure.Pattern_Type: enums.MevPatternType = enums.MevPatternType.ALL1 \n
+		structure.Payload_Length: int = 1 \n
+		structure.No_Of_Off_Slots: int = 1 \n
+		structure.Segment_Length: int = 1 \n
+		structure.Meas_On_Exception: bool = False \n
+		structure.Level: float = 1.0 \n
+		structure.Frequency: float = 1.0 \n
+		structure.Meas_Filter: enums.FilterWidth = enums.FilterWidth.NARRow \n
+		structure.Retrigger: bool = False \n
+		structure.Cte_Units: int = 1 \n
+		structure.Cte_Type: enums.CteType = enums.CteType.AOA \n
+		driver.configure.multiEval.listPy.segment.setup.extended.set(structure, segment = repcap.Segment.Default) \n
+		Defines the segment length, the signal properties including Bluetooth version 5.0 and higher, and the analyzer settings
+		for a selected segment. In general, this command must be sent for all segments to be measured. \n
 			:param structure: for set value, see the help for ExtendedStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write_struct(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:EXTended', structure)
 
 	def get(self, segment=repcap.Segment.Default) -> ExtendedStruct:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:EXTended \n
 		Snippet: value: ExtendedStruct = driver.configure.multiEval.listPy.segment.setup.extended.get(segment = repcap.Segment.Default) \n
-		Defines the segment length, the signal properties including Bluetooth version 5 and the analyzer settings for a selected
-		segment. In general, this command must be sent for all segments to be measured. \n
+		Defines the segment length, the signal properties including Bluetooth version 5.0 and higher, and the analyzer settings
+		for a selected segment. In general, this command must be sent for all segments to be measured. \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for ExtendedStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:EXTended?', self.__class__.ExtendedStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/FilterPy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/FilterPy.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,34 +2,35 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import enums
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class FilterPy:
-	"""FilterPy commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class FilterPyCls:
+	"""FilterPy commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("filterPy", core, parent)
+		self._cmd_group = CommandsGroup("filterPy", core, parent)
 
 	def set(self, meas_filter: enums.FilterWidth, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:FILTer \n
 		Snippet: driver.configure.multiEval.listPy.segment.setup.filterPy.set(meas_filter = enums.FilterWidth.NARRow, segment = repcap.Segment.Default) \n
 		Specifies the measurement filter bandwidth for the segment. \n
 			:param meas_filter: NARRow | WIDE NARRow: narrow-band filter WIDE: wide-band filter
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.enum_scalar_to_str(meas_filter, enums.FilterWidth)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:FILTer {param}')
 
 	# noinspection PyTypeChecker
 	def get(self, segment=repcap.Segment.Default) -> enums.FilterWidth:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:FILTer \n
 		Snippet: value: enums.FilterWidth = driver.configure.multiEval.listPy.segment.setup.filterPy.get(segment = repcap.Segment.Default) \n
 		Specifies the measurement filter bandwidth for the segment. \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: meas_filter: NARRow | WIDE NARRow: narrow-band filter WIDE: wide-band filter"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:FILTer?')
 		return Conversions.str_to_scalar_enum(response, enums.FilterWidth)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Frequency.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Frequency.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,33 +1,34 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Frequency:
-	"""Frequency commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class FrequencyCls:
+	"""Frequency commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("frequency", core, parent)
+		self._cmd_group = CommandsGroup("frequency", core, parent)
 
 	def set(self, frequency: float, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:FREQuency \n
 		Snippet: driver.configure.multiEval.listPy.segment.setup.frequency.set(frequency = 1.0, segment = repcap.Segment.Default) \n
 		Specifies the center frequency of the signal expected in the segment. \n
 			:param frequency: numeric Range: 100 MHz to 6 GHz, Unit: Hz
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.decimal_value_to_str(frequency)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:FREQuency {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> float:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:FREQuency \n
 		Snippet: value: float = driver.configure.multiEval.listPy.segment.setup.frequency.get(segment = repcap.Segment.Default) \n
 		Specifies the center frequency of the signal expected in the segment. \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: frequency: numeric Range: 100 MHz to 6 GHz, Unit: Hz"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:FREQuency?')
 		return Conversions.str_to_float(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/MoException.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/MoException.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,33 +1,34 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class MoException:
-	"""MoException commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MoExceptionCls:
+	"""MoException commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("moException", core, parent)
+		self._cmd_group = CommandsGroup("moException", core, parent)
 
 	def set(self, meas_on_exception: bool, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:MOEXception \n
 		Snippet: driver.configure.multiEval.listPy.segment.setup.moException.set(meas_on_exception = False, segment = repcap.Segment.Default) \n
 		Specifies whether the segment results that the R&S CMW identifies as faulty or inaccurate are rejected. \n
 			:param meas_on_exception: OFF | ON ON: include the erroneous bursts OFF: exclude the erroneous bursts
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.bool_to_str(meas_on_exception)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:MOEXception {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:MOEXception \n
 		Snippet: value: bool = driver.configure.multiEval.listPy.segment.setup.moException.get(segment = repcap.Segment.Default) \n
 		Specifies whether the segment results that the R&S CMW identifies as faulty or inaccurate are rejected. \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: meas_on_exception: OFF | ON ON: include the erroneous bursts OFF: exclude the erroneous bursts"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:MOEXception?')
 		return Conversions.str_to_bool(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Oslots.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Oslots.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,33 +1,34 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Oslots:
-	"""Oslots commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class OslotsCls:
+	"""Oslots commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("oslots", core, parent)
+		self._cmd_group = CommandsGroup("oslots", core, parent)
 
 	def set(self, no_of_off_slots: int, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:OSLots \n
 		Snippet: driver.configure.multiEval.listPy.segment.setup.oslots.set(no_of_off_slots = 1, segment = repcap.Segment.Default) \n
 		Specifies the number of unused slots between any two occupied slots or slot sequences expected in the segment. \n
 			:param no_of_off_slots: numeric Range: 1 to 9
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.decimal_value_to_str(no_of_off_slots)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:OSLots {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:OSLots \n
 		Snippet: value: int = driver.configure.multiEval.listPy.segment.setup.oslots.get(segment = repcap.Segment.Default) \n
 		Specifies the number of unused slots between any two occupied slots or slot sequences expected in the segment. \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: no_of_off_slots: numeric Range: 1 to 9"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:OSLots?')
 		return Conversions.str_to_int(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Pattern.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Pattern.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,34 +2,35 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import enums
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pattern:
-	"""Pattern commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PatternCls:
+	"""Pattern commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pattern", core, parent)
+		self._cmd_group = CommandsGroup("pattern", core, parent)
 
 	def set(self, pattern_type: enums.MevPatternType, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:PATTern \n
 		Snippet: driver.configure.multiEval.listPy.segment.setup.pattern.set(pattern_type = enums.MevPatternType.ALL1, segment = repcap.Segment.Default) \n
 		Specifies the payload pattern type expected in the segment. \n
 			:param pattern_type: ALL1 | P11 | OTHer | ALTernating | P44 ALL1: 11111111 P11: 10101010 OTHer: any pattern except P11, P44, ALL1 ALTernating: the periodical change of the pattern P11 and P44 P44: 11110000
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.enum_scalar_to_str(pattern_type, enums.MevPatternType)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:PATTern {param}')
 
 	# noinspection PyTypeChecker
 	def get(self, segment=repcap.Segment.Default) -> enums.MevPatternType:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:PATTern \n
 		Snippet: value: enums.MevPatternType = driver.configure.multiEval.listPy.segment.setup.pattern.get(segment = repcap.Segment.Default) \n
 		Specifies the payload pattern type expected in the segment. \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: pattern_type: ALL1 | P11 | OTHer | ALTernating | P44 ALL1: 11111111 P11: 10101010 OTHer: any pattern except P11, P44, ALL1 ALTernating: the periodical change of the pattern P11 and P44 P44: 11110000"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:PATTern?')
 		return Conversions.str_to_scalar_enum(response, enums.MevPatternType)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Phy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Phy.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,36 +2,35 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import enums
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Phy:
-	"""Phy commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PhyCls:
+	"""Phy commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("phy", core, parent)
+		self._cmd_group = CommandsGroup("phy", core, parent)
 
-	def set(self, le_phy_type: enums.LePhysicalType, segment=repcap.Segment.Default) -> None:
+	def set(self, le_phy_type: enums.LePhysicalTypeB, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:PHY \n
-		Snippet: driver.configure.multiEval.listPy.segment.setup.phy.set(le_phy_type = enums.LePhysicalType.LE1M, segment = repcap.Segment.Default) \n
-		Defines physical layer ( PHY) for segment according to the core specification version 5.0 for Bluetooth wireless
-		technology. \n
+		Snippet: driver.configure.multiEval.listPy.segment.setup.phy.set(le_phy_type = enums.LePhysicalTypeB.LE1M, segment = repcap.Segment.Default) \n
+		Defines the physical layer (PHY) for segment. \n
 			:param le_phy_type: LE1M | LE2M | LELR LE1M: LE 1 Msymbol/s uncoded PHY LE2M: LE 2 Msymbol/s uncoded PHY LELR: LE 1 Msymbol/s long range (LE coded PHY)
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
-		param = Conversions.enum_scalar_to_str(le_phy_type, enums.LePhysicalType)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
+		param = Conversions.enum_scalar_to_str(le_phy_type, enums.LePhysicalTypeB)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:PHY {param}')
 
 	# noinspection PyTypeChecker
-	def get(self, segment=repcap.Segment.Default) -> enums.LePhysicalType:
+	def get(self, segment=repcap.Segment.Default) -> enums.LePhysicalTypeB:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:PHY \n
-		Snippet: value: enums.LePhysicalType = driver.configure.multiEval.listPy.segment.setup.phy.get(segment = repcap.Segment.Default) \n
-		Defines physical layer ( PHY) for segment according to the core specification version 5.0 for Bluetooth wireless
-		technology. \n
+		Snippet: value: enums.LePhysicalTypeB = driver.configure.multiEval.listPy.segment.setup.phy.get(segment = repcap.Segment.Default) \n
+		Defines the physical layer (PHY) for segment. \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: le_phy_type: LE1M | LE2M | LELR LE1M: LE 1 Msymbol/s uncoded PHY LE2M: LE 2 Msymbol/s uncoded PHY LELR: LE 1 Msymbol/s long range (LE coded PHY)"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:PHY?')
-		return Conversions.str_to_scalar_enum(response, enums.LePhysicalType)
+		return Conversions.str_to_scalar_enum(response, enums.LePhysicalTypeB)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Plength.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Plength.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,33 +1,34 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Plength:
-	"""Plength commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PlengthCls:
+	"""Plength commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("plength", core, parent)
+		self._cmd_group = CommandsGroup("plength", core, parent)
 
 	def set(self, payload_length: int, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:PLENgth \n
 		Snippet: driver.configure.multiEval.listPy.segment.setup.plength.set(payload_length = 1, segment = repcap.Segment.Default) \n
 		Specifies the payload length expected in the segment. \n
 			:param payload_length: numeric Range: 0 Byte(s) to 1021 Byte(s)
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.decimal_value_to_str(payload_length)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:PLENgth {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:PLENgth \n
 		Snippet: value: int = driver.configure.multiEval.listPy.segment.setup.plength.get(segment = repcap.Segment.Default) \n
 		Specifies the payload length expected in the segment. \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: payload_length: numeric Range: 0 Byte(s) to 1021 Byte(s)"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:PLENgth?')
 		return Conversions.str_to_int(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Ptype.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Ptype.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,34 +2,35 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import enums
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ptype:
-	"""Ptype commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PtypeCls:
+	"""Ptype commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ptype", core, parent)
+		self._cmd_group = CommandsGroup("ptype", core, parent)
 
 	def set(self, packet_type: enums.SegmentPacketType, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:PTYPe \n
 		Snippet: driver.configure.multiEval.listPy.segment.setup.ptype.set(packet_type = enums.SegmentPacketType.ADVertiser, segment = repcap.Segment.Default) \n
 		Specifies the packet type expected in the segment. \n
-			:param packet_type: DH1 | DH3 | DH5 | E21P | E23P | E25P | E31P | E33P | E35P | RFPHytest | ADVertiser DH1, DH3, DH5: BR packet E21P, E23P, E25P, E31P, E33P, E35P: 2-DH1, 2-DH3, 2-DH5, 3-DH1, 3-DH3, 3-DH5 EDR packet RFPHytest: LE test packet ADVertiser: LE advertiser
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param packet_type: DH1 | DH3 | DH5 | E21P | E23P | E25P | E31P | E33P | E35P | RFPHytest | ADVertiser | RFCTe DH1, DH3, DH5: BR packet E21P, E23P, E25P, E31P, E33P, E35P: 2-DH1, 2-DH3, 2-DH5, 3-DH1, 3-DH3, 3-DH5 EDR packet RFPHytest: LE test packet ADVertiser: LE advertiser RFCTe: LE with CTE test packet
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.enum_scalar_to_str(packet_type, enums.SegmentPacketType)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:PTYPe {param}')
 
 	# noinspection PyTypeChecker
 	def get(self, segment=repcap.Segment.Default) -> enums.SegmentPacketType:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:PTYPe \n
 		Snippet: value: enums.SegmentPacketType = driver.configure.multiEval.listPy.segment.setup.ptype.get(segment = repcap.Segment.Default) \n
 		Specifies the packet type expected in the segment. \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
-			:return: packet_type: DH1 | DH3 | DH5 | E21P | E23P | E25P | E31P | E33P | E35P | RFPHytest | ADVertiser DH1, DH3, DH5: BR packet E21P, E23P, E25P, E31P, E33P, E35P: 2-DH1, 2-DH3, 2-DH5, 3-DH1, 3-DH3, 3-DH5 EDR packet RFPHytest: LE test packet ADVertiser: LE advertiser"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+			:return: packet_type: DH1 | DH3 | DH5 | E21P | E23P | E25P | E31P | E33P | E35P | RFPHytest | ADVertiser | RFCTe DH1, DH3, DH5: BR packet E21P, E23P, E25P, E31P, E33P, E35P: 2-DH1, 2-DH3, 2-DH5, 3-DH1, 3-DH3, 3-DH5 EDR packet RFPHytest: LE test packet ADVertiser: LE advertiser RFCTe: LE with CTE test packet"""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:PTYPe?')
 		return Conversions.str_to_scalar_enum(response, enums.SegmentPacketType)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Rtrigger.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Rtrigger.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,35 +1,36 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Rtrigger:
-	"""Rtrigger commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RtriggerCls:
+	"""Rtrigger commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rtrigger", core, parent)
+		self._cmd_group = CommandsGroup("rtrigger", core, parent)
 
 	def set(self, retrigger: bool, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:RTRigger \n
 		Snippet: driver.configure.multiEval.listPy.segment.setup.rtrigger.set(retrigger = False, segment = repcap.Segment.Default) \n
 		Specifies whether a trigger event is required for the segment or not. The setting is ignored for the first segment of a
 		measurement. \n
 			:param retrigger: OFF | ON OFF: measure the segment without retrigger ON: trigger event required
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.bool_to_str(retrigger)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:RTRigger {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:RTRigger \n
 		Snippet: value: bool = driver.configure.multiEval.listPy.segment.setup.rtrigger.get(segment = repcap.Segment.Default) \n
 		Specifies whether a trigger event is required for the segment or not. The setting is ignored for the first segment of a
 		measurement. \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: retrigger: OFF | ON OFF: measure the segment without retrigger ON: trigger event required"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:RTRigger?')
 		return Conversions.str_to_bool(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/SingleCmw.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/SingleCmw/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SingleCmw:
-	"""SingleCmw commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class SingleCmwCls:
+	"""SingleCmw commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("singleCmw", core, parent)
+		self._cmd_group = CommandsGroup("singleCmw", core, parent)
 
 	@property
 	def connector(self):
 		"""connector commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_connector'):
-			from .SingleCmw_.Connector import Connector
-			self._connector = Connector(self._core, self._base)
+			from .Connector import ConnectorCls
+			self._connector = ConnectorCls(self._core, self._cmd_group)
 		return self._connector
 
-	def clone(self) -> 'SingleCmw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SingleCmwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = SingleCmw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SingleCmwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/SingleCmw_/Connector.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/SingleCmw/Connector.py`

 * *Files 15% similar despite different names*

```diff
@@ -2,40 +2,35 @@
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal import Conversions
 from ........ import enums
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Connector:
-	"""Connector commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ConnectorCls:
+	"""Connector commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("connector", core, parent)
+		self._cmd_group = CommandsGroup("connector", core, parent)
 
 	def set(self, cmws_connector: enums.CmwSingleConnector, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:CMWS:CONNector \n
 		Snippet: driver.configure.multiEval.listPy.segment.setup.singleCmw.connector.set(cmws_connector = enums.CmwSingleConnector.R11, segment = repcap.Segment.Default) \n
-		Selects the RF input connector for segment <no> for Bluetooth list mode measurements with the R&S CMWS. This setting is
-		only relevant for connector mode LIST, see method RsCmwBluetoothMeas.Configure.MultiEval.ListPy.SingleCmw.cmode.
-		All segments of a list mode measurement must use connectors of the same bench. For possible connector values, see 'Values
-		for RF Path Selection'. \n
-			:param cmws_connector: Selects the input connector of the R&S CMWS
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+		No command help available \n
+			:param cmws_connector: No help available
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.enum_scalar_to_str(cmws_connector, enums.CmwSingleConnector)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:CMWS:CONNector {param}')
 
 	# noinspection PyTypeChecker
 	def get(self, segment=repcap.Segment.Default) -> enums.CmwSingleConnector:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:CMWS:CONNector \n
 		Snippet: value: enums.CmwSingleConnector = driver.configure.multiEval.listPy.segment.setup.singleCmw.connector.get(segment = repcap.Segment.Default) \n
-		Selects the RF input connector for segment <no> for Bluetooth list mode measurements with the R&S CMWS. This setting is
-		only relevant for connector mode LIST, see method RsCmwBluetoothMeas.Configure.MultiEval.ListPy.SingleCmw.cmode.
-		All segments of a list mode measurement must use connectors of the same bench. For possible connector values, see 'Values
-		for RF Path Selection'. \n
+		No command help available \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
-			:return: cmws_connector: Selects the input connector of the R&S CMWS"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+			:return: cmws_connector: No help available"""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:CMWS:CONNector?')
 		return Conversions.str_to_scalar_enum(response, enums.CmwSingleConnector)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup_/Slength.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Slength.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,33 +1,34 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Slength:
-	"""Slength commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SlengthCls:
+	"""Slength commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("slength", core, parent)
+		self._cmd_group = CommandsGroup("slength", core, parent)
 
 	def set(self, segment_length: int, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:SLENgth \n
 		Snippet: driver.configure.multiEval.listPy.segment.setup.slength.set(segment_length = 1, segment = repcap.Segment.Default) \n
 		Defines the number of measured bursts in the segment \n
 			:param segment_length: numeric The sum of the length of all active segments must not exceed 6700 timeslots (1 timeslot = 625 μs duration) . Range: 1 to 1000
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.decimal_value_to_str(segment_length)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:SLENgth {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>[:SETup]:SLENgth \n
 		Snippet: value: int = driver.configure.multiEval.listPy.segment.setup.slength.get(segment = repcap.Segment.Default) \n
 		Defines the number of measured bursts in the segment \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: segment_length: numeric The sum of the length of all active segments must not exceed 6700 timeslots (1 timeslot = 625 μs duration) . Range: 1 to 1000"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup:SLENgth?')
 		return Conversions.str_to_int(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Pencoding/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,43 +1,35 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 3 total commands, 3 Sub-groups, 0 group commands"""
+class PencodingCls:
+	"""Pencoding commands group definition. 7 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("pencoding", core, parent)
 
 	@property
-	def lrange(self):
-		"""lrange commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_lrange'):
-			from .LowEnergy_.Lrange import Lrange
-			self._lrange = Lrange(self._core, self._base)
-		return self._lrange
+	def ssequence(self):
+		"""ssequence commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_ssequence'):
+			from .Ssequence import SsequenceCls
+			self._ssequence = SsequenceCls(self._core, self._cmd_group)
+		return self._ssequence
 
 	@property
-	def le2M(self):
-		"""le2M commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_le2M'):
-			from .LowEnergy_.Le2M import Le2M
-			self._le2M = Le2M(self._core, self._base)
-		return self._le2M
+	def edrate(self):
+		"""edrate commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_edrate'):
+			from .Edrate import EdrateCls
+			self._edrate = EdrateCls(self._core, self._cmd_group)
+		return self._edrate
 
-	@property
-	def le1M(self):
-		"""le1M commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_le1M'):
-			from .LowEnergy_.Le1M import Le1M
-			self._le1M = Le1M(self._core, self._base)
-		return self._le1M
-
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PencodingCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PencodingCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy_/Le1M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/LowEnergy/Le2M/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le1M:
-	"""Le1M commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class Le2MCls:
+	"""Le2M commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le1M", core, parent)
+		self._cmd_group = CommandsGroup("le2M", core, parent)
 
 	@property
 	def filterPy(self):
 		"""filterPy commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_filterPy'):
-			from .Le1M_.FilterPy import FilterPy
-			self._filterPy = FilterPy(self._core, self._base)
+			from .FilterPy import FilterPyCls
+			self._filterPy = FilterPyCls(self._core, self._cmd_group)
 		return self._filterPy
 
-	def clone(self) -> 'Le1M':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'Le2MCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Le1M(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = Le2MCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy_/Le1M_/FilterPy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/LowEnergy/Le1M/FilterPy.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal import Conversions
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class FilterPy:
-	"""FilterPy commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class FilterPyCls:
+	"""FilterPy commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("filterPy", core, parent)
+		self._cmd_group = CommandsGroup("filterPy", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_bandwidth(self) -> enums.FilterWidth:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LENergy[:LE1M]:FILTer:BWIDth \n
 		Snippet: value: enums.FilterWidth = driver.configure.multiEval.lowEnergy.le1M.filterPy.get_bandwidth() \n
 		Selects the filter bandwidth. Commands for uncoded LE 1M PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..
 		:LRANge..) are available. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy_/Le2M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Trx/Result/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le2M:
-	"""Le2M commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class ResultCls:
+	"""Result commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le2M", core, parent)
+		self._cmd_group = CommandsGroup("result", core, parent)
 
 	@property
-	def filterPy(self):
-		"""filterPy commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_filterPy'):
-			from .Le2M_.FilterPy import FilterPy
-			self._filterPy = FilterPy(self._core, self._base)
-		return self._filterPy
+	def all(self):
+		"""all commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_all'):
+			from .All import AllCls
+			self._all = AllCls(self._core, self._cmd_group)
+		return self._all
 
-	def clone(self) -> 'Le2M':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ResultCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Le2M(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ResultCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy_/Le2M_/FilterPy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/LowEnergy/Le2M/FilterPy.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal import Conversions
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class FilterPy:
-	"""FilterPy commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class FilterPyCls:
+	"""FilterPy commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("filterPy", core, parent)
+		self._cmd_group = CommandsGroup("filterPy", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_bandwidth(self) -> enums.FilterWidth:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LENergy:LE2M:FILTer:BWIDth \n
 		Snippet: value: enums.FilterWidth = driver.configure.multiEval.lowEnergy.le2M.filterPy.get_bandwidth() \n
 		Selects the filter bandwidth. Commands for uncoded LE 1M PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..
 		:LRANge..) are available. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy_/Lrange.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/LowEnergy/Lrange/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Lrange:
-	"""Lrange commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class LrangeCls:
+	"""Lrange commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lrange", core, parent)
+		self._cmd_group = CommandsGroup("lrange", core, parent)
 
 	@property
 	def filterPy(self):
 		"""filterPy commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_filterPy'):
-			from .Lrange_.FilterPy import FilterPy
-			self._filterPy = FilterPy(self._core, self._base)
+			from .FilterPy import FilterPyCls
+			self._filterPy = FilterPyCls(self._core, self._cmd_group)
 		return self._filterPy
 
-	def clone(self) -> 'Lrange':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LrangeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Lrange(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LrangeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/LowEnergy_/Lrange_/FilterPy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cte/Qhsl/P4Q.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,34 +1,50 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal import Conversions
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class FilterPy:
-	"""FilterPy commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class P4QCls:
+	"""P4Q commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("filterPy", core, parent)
+		self._cmd_group = CommandsGroup("p4Q", core, parent)
 
 	# noinspection PyTypeChecker
-	def get_bandwidth(self) -> enums.FilterWidth:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LENergy:LRANge:FILTer:BWIDth \n
-		Snippet: value: enums.FilterWidth = driver.configure.multiEval.lowEnergy.lrange.filterPy.get_bandwidth() \n
-		Selects the filter bandwidth. Commands for uncoded LE 1M PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..
-		:LRANge..) are available. \n
-			:return: filter_bandwidth: NARRow | WIDE NARRow: Narrow-band filter WIDE: Wide-band filter
+	def get_type_py(self) -> enums.CtePacketType:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:CTE:QHSL:P4Q:TYPE \n
+		Snippet: value: enums.CtePacketType = driver.configure.inputSignal.cte.qhsl.p4Q.get_type_py() \n
+		No command help available \n
+			:return: cte_type: No help available
 		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LENergy:LRANge:FILTer:BWIDth?')
-		return Conversions.str_to_scalar_enum(response, enums.FilterWidth)
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:CTE:QHSL:P4Q:TYPE?')
+		return Conversions.str_to_scalar_enum(response, enums.CtePacketType)
 
-	def set_bandwidth(self, filter_bandwidth: enums.FilterWidth) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LENergy:LRANge:FILTer:BWIDth \n
-		Snippet: driver.configure.multiEval.lowEnergy.lrange.filterPy.set_bandwidth(filter_bandwidth = enums.FilterWidth.NARRow) \n
-		Selects the filter bandwidth. Commands for uncoded LE 1M PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..
-		:LRANge..) are available. \n
-			:param filter_bandwidth: NARRow | WIDE NARRow: Narrow-band filter WIDE: Wide-band filter
+	def set_type_py(self, cte_type: enums.CtePacketType) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:CTE:QHSL:P4Q:TYPE \n
+		Snippet: driver.configure.inputSignal.cte.qhsl.p4Q.set_type_py(cte_type = enums.CtePacketType.AOA1us) \n
+		No command help available \n
+			:param cte_type: No help available
 		"""
-		param = Conversions.enum_scalar_to_str(filter_bandwidth, enums.FilterWidth)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:LENergy:LRANge:FILTer:BWIDth {param}')
+		param = Conversions.enum_scalar_to_str(cte_type, enums.CtePacketType)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:CTE:QHSL:P4Q:TYPE {param}')
+
+	def get_units(self) -> int:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:CTE:QHSL:P4Q:UNITs \n
+		Snippet: value: int = driver.configure.inputSignal.cte.qhsl.p4Q.get_units() \n
+		No command help available \n
+			:return: cte_units: No help available
+		"""
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:CTE:QHSL:P4Q:UNITs?')
+		return Conversions.str_to_int(response)
+
+	def set_units(self, cte_units: int) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:CTE:QHSL:P4Q:UNITs \n
+		Snippet: driver.configure.inputSignal.cte.qhsl.p4Q.set_units(cte_units = 1) \n
+		No command help available \n
+			:param cte_units: No help available
+		"""
+		param = Conversions.decimal_value_to_str(cte_units)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:ISIGnal:CTE:QHSL:P4Q:UNITs {param}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Malgorithm.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Malgorithm.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Malgorithm:
-	"""Malgorithm commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MalgorithmCls:
+	"""Malgorithm commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("malgorithm", core, parent)
+		self._cmd_group = CommandsGroup("malgorithm", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_low_energy(self) -> enums.PatternIndependent:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:MALGorithm:LENergy \n
 		Snippet: value: enums.PatternIndependent = driver.configure.multiEval.malgorithm.get_low_energy() \n
 		No command help available \n
 			:return: pattern_independent: No help available
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Measurement.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Measurement.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Measurement:
-	"""Measurement commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MeasurementCls:
+	"""Measurement commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("measurement", core, parent)
+		self._cmd_group = CommandsGroup("measurement", core, parent)
 
 	def get_me_count(self) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:MEASurement:MECount \n
 		Snippet: value: int = driver.configure.multiEval.measurement.get_me_count() \n
 		No command help available \n
 			:return: max_error_count: No help available
 		"""
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Result.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Result.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,20 +2,20 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Result:
-	"""Result commands group definition. 17 total commands, 0 Sub-groups, 17 group commands"""
+class ResultCls:
+	"""Result commands group definition. 17 total commands, 0 Subgroups, 17 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("result", core, parent)
+		self._cmd_group = CommandsGroup("result", core, parent)
 
 	def get_spower(self) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:SPOWer \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_spower() \n
 		No command help available \n
 			:return: enable: No help available
 		"""
@@ -30,195 +30,195 @@
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:SPOWer {param}')
 
 	def get_pencoding(self) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:PENCoding \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_pencoding() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:return: enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:return: enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:PENCoding?')
 		return Conversions.str_to_bool(response)
 
 	def set_pencoding(self, enable: bool) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:PENCoding \n
 		Snippet: driver.configure.multiEval.result.set_pencoding(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:param enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:param enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:PENCoding {param}')
 
 	def get_frange(self) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:FRANge \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_frange() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:return: enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:return: enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:FRANge?')
 		return Conversions.str_to_bool(response)
 
 	def set_frange(self, enable: bool) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:FRANge \n
 		Snippet: driver.configure.multiEval.result.set_frange(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:param enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:param enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:FRANge {param}')
 
 	def get_sgacp(self) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:SGACp \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_sgacp() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:return: enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:return: enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:SGACp?')
 		return Conversions.str_to_bool(response)
 
 	def set_sgacp(self, enable: bool) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:SGACp \n
 		Snippet: driver.configure.multiEval.result.set_sgacp(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:param enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:param enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:SGACp {param}')
 
 	def get_so_bw(self) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:SOBW \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_so_bw() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:return: enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:return: enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:SOBW?')
 		return Conversions.str_to_bool(response)
 
 	def set_so_bw(self, enable: bool) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:SOBW \n
 		Snippet: driver.configure.multiEval.result.set_so_bw(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:param enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:param enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:SOBW {param}')
 
 	def get_sacp(self) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:SACP \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_sacp() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:return: enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:return: enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:SACP?')
 		return Conversions.str_to_bool(response)
 
 	def set_sacp(self, enable: bool) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:SACP \n
 		Snippet: driver.configure.multiEval.result.set_sacp(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:param enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:param enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:SACP {param}')
 
 	# noinspection PyTypeChecker
-	class AllStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Devm: bool: OFF | ON Differential error vector magnitude (only for EDR) ON: Evaluate results and show the view OFF: Do not evaluate results, hide the view (if applicable)
+	class AllStruct(StructBase):  # From WriteStructDefinition CmdPropertyTemplate.xml
+		"""Structure for setting input parameters. Contains optional set arguments. Fields: \n
+			- Devm: bool: OFF | ON Differential error vector magnitude (only for EDR) ON: Evaluate results. OFF: Do not evaluate results.
 			- Phase_Diff: bool: OFF | ON Phase difference (only for EDR)
 			- Mod_Scalars: bool: OFF | ON Statistical modulation results
 			- Iq_Absolute: bool: OFF | ON IQ constellation absolute (only for EDR)
 			- Iq_Differential: bool: OFF | ON IQ constellation differential (only for EDR)
 			- Iq_Error: bool: OFF | ON IQ constellation error (only for EDR)
 			- Freq_Dev: bool: OFF | ON Frequency deviation (only for BR and LE)
-			- Power_Vs_Time: bool: OFF | ON Power vs. time
+			- Power_Vs_Time: bool: OFF | ON Power vs time
 			- Power_Scalars: bool: OFF | ON Statistical power results
 			- Spectrum_Obw: bool: OFF | ON Spectrum 20 dB bandwidth (only for BR)
 			- Spectrum_Acp: bool: OFF | ON Spectrum ACP (only for BR and LE)
 			- Spectrum_Gat_Acp: bool: OFF | ON Spectrum gated ACP (only for EDR)
-			- Spec_Freq_Range: bool: OFF | ON Spectrum frequency range (only for BR)
-			- Phase_Encoding: bool: OFF | ON Statistical differential phase encoding results (only for EDR in combined signal path)
-			- Power_Vs_Slot: bool: OFF | ON Power versus slot (only for LE with CE)"""
+			- Spec_Freq_Range: bool: Optional setting parameter. OFF | ON Spectrum frequency range (only for BR)
+			- Phase_Encoding: bool: Optional setting parameter. OFF | ON Statistical differential phase encoding results (only for EDR in combined signal path)
+			- Power_Vs_Slot: bool: Optional setting parameter. OFF | ON Power versus slot (only for LE with CTE)"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Devm'),
 			ArgStruct.scalar_bool('Phase_Diff'),
 			ArgStruct.scalar_bool('Mod_Scalars'),
 			ArgStruct.scalar_bool('Iq_Absolute'),
 			ArgStruct.scalar_bool('Iq_Differential'),
 			ArgStruct.scalar_bool('Iq_Error'),
 			ArgStruct.scalar_bool('Freq_Dev'),
 			ArgStruct.scalar_bool('Power_Vs_Time'),
 			ArgStruct.scalar_bool('Power_Scalars'),
 			ArgStruct.scalar_bool('Spectrum_Obw'),
 			ArgStruct.scalar_bool('Spectrum_Acp'),
 			ArgStruct.scalar_bool('Spectrum_Gat_Acp'),
-			ArgStruct.scalar_bool('Spec_Freq_Range'),
-			ArgStruct.scalar_bool('Phase_Encoding'),
-			ArgStruct.scalar_bool('Power_Vs_Slot')]
+			ArgStruct.scalar_bool_optional('Spec_Freq_Range'),
+			ArgStruct.scalar_bool_optional('Phase_Encoding'),
+			ArgStruct.scalar_bool_optional('Power_Vs_Slot')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Devm: bool = None
 			self.Phase_Diff: bool = None
 			self.Mod_Scalars: bool = None
 			self.Iq_Absolute: bool = None
@@ -233,323 +233,340 @@
 			self.Spec_Freq_Range: bool = None
 			self.Phase_Encoding: bool = None
 			self.Power_Vs_Slot: bool = None
 
 	def get_all(self) -> AllStruct:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult[:ALL] \n
 		Snippet: value: AllStruct = driver.configure.multiEval.result.get_all() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-		This command combines all other CONFigure:BLUetooth:MEAS<i>:MEValuation:RESult... commands. Tip: Use READ...? queries to
-		retrieve results for disabled views. \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement. This command combines all other
+		CONFigure:BLUetooth:MEAS<i>:MEValuation:RESult... commands. Tip: Use READ...? queries to retrieve results for disabled
+		views. \n
 			:return: structure: for return value, see the help for AllStruct structure arguments.
 		"""
 		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:ALL?', self.__class__.AllStruct())
 
 	def set_all(self, value: AllStruct) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult[:ALL] \n
-		Snippet: driver.configure.multiEval.result.set_all(value = AllStruct()) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-		This command combines all other CONFigure:BLUetooth:MEAS<i>:MEValuation:RESult... commands. Tip: Use READ...? queries to
-		retrieve results for disabled views. \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.result.AllStruct() \n
+		structure.Devm: bool = False \n
+		structure.Phase_Diff: bool = False \n
+		structure.Mod_Scalars: bool = False \n
+		structure.Iq_Absolute: bool = False \n
+		structure.Iq_Differential: bool = False \n
+		structure.Iq_Error: bool = False \n
+		structure.Freq_Dev: bool = False \n
+		structure.Power_Vs_Time: bool = False \n
+		structure.Power_Scalars: bool = False \n
+		structure.Spectrum_Obw: bool = False \n
+		structure.Spectrum_Acp: bool = False \n
+		structure.Spectrum_Gat_Acp: bool = False \n
+		structure.Spec_Freq_Range: bool = False \n
+		structure.Phase_Encoding: bool = False \n
+		structure.Power_Vs_Slot: bool = False \n
+		driver.configure.multiEval.result.set_all(value = structure) \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement. This command combines all other
+		CONFigure:BLUetooth:MEAS<i>:MEValuation:RESult... commands. Tip: Use READ...? queries to retrieve results for disabled
+		views. \n
 			:param value: see the help for AllStruct structure arguments.
 		"""
 		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:ALL', value)
 
 	def get_pscalar(self) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:PSCalar \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_pscalar() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:return: enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:return: enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:PSCalar?')
 		return Conversions.str_to_bool(response)
 
 	def set_pscalar(self, enable: bool) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:PSCalar \n
 		Snippet: driver.configure.multiEval.result.set_pscalar(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:param enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:param enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:PSCalar {param}')
 
 	def get_iq_absolute(self) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:IQABsolute \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_iq_absolute() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:return: enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:return: enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:IQABsolute?')
 		return Conversions.str_to_bool(response)
 
 	def set_iq_absolute(self, enable: bool) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:IQABsolute \n
 		Snippet: driver.configure.multiEval.result.set_iq_absolute(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:param enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:param enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:IQABsolute {param}')
 
 	def get_iq_error(self) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:IQERror \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_iq_error() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:return: enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:return: enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:IQERror?')
 		return Conversions.str_to_bool(response)
 
 	def set_iq_error(self, enable: bool) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:IQERror \n
 		Snippet: driver.configure.multiEval.result.set_iq_error(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:param enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:param enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:IQERror {param}')
 
 	def get_iq_difference(self) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:IQDiff \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_iq_difference() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:return: enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:return: enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:IQDiff?')
 		return Conversions.str_to_bool(response)
 
 	def set_iq_difference(self, enable: bool) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:IQDiff \n
 		Snippet: driver.configure.multiEval.result.set_iq_difference(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:param enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:param enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:IQDiff {param}')
 
 	def get_power_vs_time(self) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:PVTime \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_power_vs_time() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:return: enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:return: enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:PVTime?')
 		return Conversions.str_to_bool(response)
 
 	def set_power_vs_time(self, enable: bool) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:PVTime \n
 		Snippet: driver.configure.multiEval.result.set_power_vs_time(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:param enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:param enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:PVTime {param}')
 
 	def get_dev_magnitude(self) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:DEVMagnitude \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_dev_magnitude() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:return: enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:return: enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:DEVMagnitude?')
 		return Conversions.str_to_bool(response)
 
 	def set_dev_magnitude(self, enable: bool) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:DEVMagnitude \n
 		Snippet: driver.configure.multiEval.result.set_dev_magnitude(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:param enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:param enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:DEVMagnitude {param}')
 
 	def get_pdifference(self) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:PDIFference \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_pdifference() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:return: enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:return: enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:PDIFference?')
 		return Conversions.str_to_bool(response)
 
 	def set_pdifference(self, enable: bool) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:PDIFference \n
 		Snippet: driver.configure.multiEval.result.set_pdifference(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:param enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:param enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:PDIFference {param}')
 
 	def get_mscalar(self) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:MSCalar \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_mscalar() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:return: enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:return: enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:MSCalar?')
 		return Conversions.str_to_bool(response)
 
 	def set_mscalar(self, enable: bool) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:MSCalar \n
 		Snippet: driver.configure.multiEval.result.set_mscalar(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:param enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:param enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:MSCalar {param}')
 
 	def get_fdeviation(self) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:FDEViation \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_fdeviation() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:return: enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:return: enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:FDEViation?')
 		return Conversions.str_to_bool(response)
 
 	def set_fdeviation(self, enable: bool) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:FDEViation \n
 		Snippet: driver.configure.multiEval.result.set_fdeviation(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:param enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:param enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:FDEViation {param}')
 
 	def get_pv_slot(self) -> bool:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:PVSLot \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_pv_slot() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:return: enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:return: enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:PVSLot?')
 		return Conversions.str_to_bool(response)
 
 	def set_pv_slot(self, enable: bool) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:PVSLot \n
 		Snippet: driver.configure.multiEval.result.set_pv_slot(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement. The last
-		mnemonic denotes the view type: statistical modulation results , statistical power results, statistical differential
-		phase encoding results (EDR in CSP) , power vs. time results, power vs. slot results (LE with CTE) , DEVM (EDR) , phase
-		difference (EDR) , IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) ,
-		frequency deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) ,
-		spectrum gated ACP (EDR) . Use CONFigure:BLUetooth:MEAS<i>:MEValuation to enable/disable all result types. Tip: Use READ..
-		.? queries to retrieve results for disabled views. \n
-			:param enable: OFF | ON ON: Evaluate results and show view OFF: Do not evaluate results, hide view
+		Enables or disables the evaluation of results in the multi-evaluation measurement. The last mnemonic denotes the
+		measurement type: Statistical modulation results , statistical power results, statistical differential phase encoding
+		results (EDR in CSP) , power vs time results, power vs slot results (LE with CTE) , DEVM (EDR) , phase difference (EDR) ,
+		IQ constellation absolute (EDR) , IQ constellation differential (EDR) , IQ constellation error (EDR) , frequency
+		deviation (BR, LE) , frequency range results (BR) , spectrum 20 dB bandwidth (BR) , spectrum ACP (BR, LE) , spectrum
+		gated ACP (EDR) . Use method RsCmwBluetoothMeas.Configure.MultiEval.Result.all to enable/disable all result types. Tip:
+		Use READ...? queries to retrieve results for disabled measurements. \n
+			:param enable: OFF | ON ON: Evaluate results. OFF: Do not evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:RESult:PVSLot {param}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Ptype/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,35 +1,43 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sacp:
-	"""Sacp commands group definition. 3 total commands, 2 Sub-groups, 0 group commands"""
+class PtypeCls:
+	"""Ptype commands group definition. 5 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sacp", core, parent)
+		self._cmd_group = CommandsGroup("ptype", core, parent)
 
 	@property
 	def lowEnergy(self):
-		"""lowEnergy commands group. 2 Sub-classes, 0 commands."""
+		"""lowEnergy commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_lowEnergy'):
-			from .Sacp_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
 		return self._lowEnergy
 
 	@property
+	def edrate(self):
+		"""edrate commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_edrate'):
+			from .Edrate import EdrateCls
+			self._edrate = EdrateCls(self._core, self._cmd_group)
+		return self._edrate
+
+	@property
 	def brate(self):
-		"""brate commands group. 1 Sub-classes, 0 commands."""
+		"""brate commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_brate'):
-			from .Sacp_.Brate import Brate
-			self._brate = Brate(self._core, self._base)
+			from .Brate import BrateCls
+			self._brate = BrateCls(self._core, self._cmd_group)
 		return self._brate
 
-	def clone(self) -> 'Sacp':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PtypeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Sacp(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PtypeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/Brate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/InputSignal/Adetected/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,27 +1,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Brate:
-	"""Brate commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class AdetectedCls:
+	"""Adetected commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("brate", core, parent)
+		self._cmd_group = CommandsGroup("adetected", core, parent)
 
 	@property
-	def measurement(self):
-		"""measurement commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_measurement'):
-			from .Brate_.Measurement import Measurement
-			self._measurement = Measurement(self._core, self._base)
-		return self._measurement
+	def plength(self):
+		"""plength commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_plength'):
+			from .Plength import PlengthCls
+			self._plength = PlengthCls(self._core, self._cmd_group)
+		return self._plength
 
-	def clone(self) -> 'Brate':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def ptype(self):
+		"""ptype commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_ptype'):
+			from .Ptype import PtypeCls
+			self._ptype = PtypeCls(self._core, self._cmd_group)
+		return self._ptype
+
+	def clone(self) -> 'AdetectedCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Brate(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AdetectedCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/Brate_/Measurement.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/Brate/Measurement.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal import Conversions
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Measurement:
-	"""Measurement commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MeasurementCls:
+	"""Measurement commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("measurement", core, parent)
+		self._cmd_group = CommandsGroup("measurement", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_mode(self) -> enums.BrEdrChannelsRange:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SACP:BRATe:MEASurement:MODE \n
 		Snippet: value: enums.BrEdrChannelsRange = driver.configure.multiEval.sacp.brate.measurement.get_mode() \n
 		Selects the measured ACP channel range for BR or EDR packets. The ACP can be measured over the expected transmit channel
 		+/- 10 channels (21 channels in total) or over the entire Bluetooth regulatory range (79 channels) . \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/LowEnergy/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class LowEnergyCls:
+	"""LowEnergy commands group definition. 4 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
-
-	@property
-	def le2M(self):
-		"""le2M commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_le2M'):
-			from .LowEnergy_.Le2M import Le2M
-			self._le2M = Le2M(self._core, self._base)
-		return self._le2M
+		self._cmd_group = CommandsGroup("lowEnergy", core, parent)
 
 	@property
 	def le1M(self):
-		"""le1M commands group. 1 Sub-classes, 0 commands."""
+		"""le1M commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_le1M'):
-			from .LowEnergy_.Le1M import Le1M
-			self._le1M = Le1M(self._core, self._base)
+			from .Le1M import Le1MCls
+			self._le1M = Le1MCls(self._core, self._cmd_group)
 		return self._le1M
 
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def le2M(self):
+		"""le2M commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_le2M'):
+			from .Le2M import Le2MCls
+			self._le2M = Le2MCls(self._core, self._cmd_group)
+		return self._le2M
+
+	def clone(self) -> 'LowEnergyCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LowEnergyCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/LowEnergy_/Le1M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdrp/Sacp/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le1M:
-	"""Le1M commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class SacpCls:
+	"""Sacp commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le1M", core, parent)
+		self._cmd_group = CommandsGroup("sacp", core, parent)
 
 	@property
 	def measurement(self):
 		"""measurement commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_measurement'):
-			from .Le1M_.Measurement import Measurement
-			self._measurement = Measurement(self._core, self._base)
+			from .Measurement import MeasurementCls
+			self._measurement = MeasurementCls(self._core, self._cmd_group)
 		return self._measurement
 
-	def clone(self) -> 'Le1M':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SacpCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Le1M(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SacpCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/LowEnergy_/Le1M_/Measurement.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/LowEnergy/Le2M/Measurement.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,38 +1,38 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Measurement:
-	"""Measurement commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MeasurementCls:
+	"""Measurement commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("measurement", core, parent)
+		self._cmd_group = CommandsGroup("measurement", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_mode(self) -> enums.LeChannelsRange:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy[:LE1M]:MEASurement:MODE \n
-		Snippet: value: enums.LeChannelsRange = driver.configure.multiEval.sacp.lowEnergy.le1M.measurement.get_mode() \n
-		Specifies the channel range for ACP measurements. Can be selected to cover either the full LE frequency band (forty 2 MHz
-		channels) or only the adjacency of the current LE channel (ten 2 MHz channels) . The commands for LE 1M PHY (...:LE1M...)
-		and LE 2M PHY (...:LE2M...) are available. Note: Although LE channels are 2 MHz wide, the channel width in ACP
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE2M:MEASurement:MODE \n
+		Snippet: value: enums.LeChannelsRange = driver.configure.multiEval.sacp.lowEnergy.le2M.measurement.get_mode() \n
+		Specifies the channel range for ACP measurements. It can be selected to cover either the full LE frequency band (forty 2
+		MHz channels) or only the adjacency of the current LE channel (ten 2 MHz channels) . The commands for LE 1M PHY (...:LE1M.
+		..) and LE 2M PHY (...:LE2M...) are available. Note: Although LE channels are 2 MHz wide, the channel width in ACP
 		measurements is always 1 MHz ('half-channel') . \n
-			:return: meas_mode: CH40 | CH10 CH10: Covers the current and its 10 adjacent 2 MHz LE channels (5 to the left, 5 to the right) . The R&S CMW measures the 1 MHz channels centered at fTX – 10 MHz, ..., fTX + 10 MHz. CH40: Covers all 40 LE channels. The R&S CMW measures the 81 half-channels centered at 2401 MHz, 2402 MHz, ..., 2481 MHz.
+			:return: meas_mode: CH40 | CH10 CH10: 'ACP +/- 5 Channels' - covers the current and its 10 adjacent 2 MHz LE channels (5 to the left, 5 to the right) . The R&S CMW measures the 1 MHz channels centered at fTX – 10 MHz, ..., fTX + 10 MHz. CH40: 'LE All Channels' - covers all 40 LE channels. The R&S CMW measures the 81 half-channels centered at 2401 MHz, 2402 MHz, ..., 2481 MHz.
 		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE1M:MEASurement:MODE?')
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE2M:MEASurement:MODE?')
 		return Conversions.str_to_scalar_enum(response, enums.LeChannelsRange)
 
 	def set_mode(self, meas_mode: enums.LeChannelsRange) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy[:LE1M]:MEASurement:MODE \n
-		Snippet: driver.configure.multiEval.sacp.lowEnergy.le1M.measurement.set_mode(meas_mode = enums.LeChannelsRange.CH10) \n
-		Specifies the channel range for ACP measurements. Can be selected to cover either the full LE frequency band (forty 2 MHz
-		channels) or only the adjacency of the current LE channel (ten 2 MHz channels) . The commands for LE 1M PHY (...:LE1M...)
-		and LE 2M PHY (...:LE2M...) are available. Note: Although LE channels are 2 MHz wide, the channel width in ACP
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE2M:MEASurement:MODE \n
+		Snippet: driver.configure.multiEval.sacp.lowEnergy.le2M.measurement.set_mode(meas_mode = enums.LeChannelsRange.CH10) \n
+		Specifies the channel range for ACP measurements. It can be selected to cover either the full LE frequency band (forty 2
+		MHz channels) or only the adjacency of the current LE channel (ten 2 MHz channels) . The commands for LE 1M PHY (...:LE1M.
+		..) and LE 2M PHY (...:LE2M...) are available. Note: Although LE channels are 2 MHz wide, the channel width in ACP
 		measurements is always 1 MHz ('half-channel') . \n
-			:param meas_mode: CH40 | CH10 CH10: Covers the current and its 10 adjacent 2 MHz LE channels (5 to the left, 5 to the right) . The R&S CMW measures the 1 MHz channels centered at fTX – 10 MHz, ..., fTX + 10 MHz. CH40: Covers all 40 LE channels. The R&S CMW measures the 81 half-channels centered at 2401 MHz, 2402 MHz, ..., 2481 MHz.
+			:param meas_mode: CH40 | CH10 CH10: 'ACP +/- 5 Channels' - covers the current and its 10 adjacent 2 MHz LE channels (5 to the left, 5 to the right) . The R&S CMW measures the 1 MHz channels centered at fTX – 10 MHz, ..., fTX + 10 MHz. CH40: 'LE All Channels' - covers all 40 LE channels. The R&S CMW measures the 81 half-channels centered at 2401 MHz, 2402 MHz, ..., 2481 MHz.
 		"""
 		param = Conversions.enum_scalar_to_str(meas_mode, enums.LeChannelsRange)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE1M:MEASurement:MODE {param}')
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE2M:MEASurement:MODE {param}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/LowEnergy_/Le2M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sgacp/Edrate/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le2M:
-	"""Le2M commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class EdrateCls:
+	"""Edrate commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le2M", core, parent)
+		self._cmd_group = CommandsGroup("edrate", core, parent)
 
 	@property
 	def measurement(self):
 		"""measurement commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_measurement'):
-			from .Le2M_.Measurement import Measurement
-			self._measurement = Measurement(self._core, self._base)
+			from .Measurement import MeasurementCls
+			self._measurement = MeasurementCls(self._core, self._cmd_group)
 		return self._measurement
 
-	def clone(self) -> 'Le2M':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EdrateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Le2M(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EdrateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sacp_/LowEnergy_/Le2M_/Measurement.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/LowEnergy/Le1M/Measurement.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,38 +1,38 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Measurement:
-	"""Measurement commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MeasurementCls:
+	"""Measurement commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("measurement", core, parent)
+		self._cmd_group = CommandsGroup("measurement", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_mode(self) -> enums.LeChannelsRange:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE2M:MEASurement:MODE \n
-		Snippet: value: enums.LeChannelsRange = driver.configure.multiEval.sacp.lowEnergy.le2M.measurement.get_mode() \n
-		Specifies the channel range for ACP measurements. Can be selected to cover either the full LE frequency band (forty 2 MHz
-		channels) or only the adjacency of the current LE channel (ten 2 MHz channels) . The commands for LE 1M PHY (...:LE1M...)
-		and LE 2M PHY (...:LE2M...) are available. Note: Although LE channels are 2 MHz wide, the channel width in ACP
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy[:LE1M]:MEASurement:MODE \n
+		Snippet: value: enums.LeChannelsRange = driver.configure.multiEval.sacp.lowEnergy.le1M.measurement.get_mode() \n
+		Specifies the channel range for ACP measurements. It can be selected to cover either the full LE frequency band (forty 2
+		MHz channels) or only the adjacency of the current LE channel (ten 2 MHz channels) . The commands for LE 1M PHY (...:LE1M.
+		..) and LE 2M PHY (...:LE2M...) are available. Note: Although LE channels are 2 MHz wide, the channel width in ACP
 		measurements is always 1 MHz ('half-channel') . \n
-			:return: meas_mode: CH40 | CH10 CH10: Covers the current and its 10 adjacent 2 MHz LE channels (5 to the left, 5 to the right) . The R&S CMW measures the 1 MHz channels centered at fTX – 10 MHz, ..., fTX + 10 MHz. CH40: Covers all 40 LE channels. The R&S CMW measures the 81 half-channels centered at 2401 MHz, 2402 MHz, ..., 2481 MHz.
+			:return: meas_mode: CH40 | CH10 CH10: 'ACP +/- 5 Channels' - covers the current and its 10 adjacent 2 MHz LE channels (5 to the left, 5 to the right) . The R&S CMW measures the 1 MHz channels centered at fTX – 10 MHz, ..., fTX + 10 MHz. CH40: 'LE All Channels' - covers all 40 LE channels. The R&S CMW measures the 81 half-channels centered at 2401 MHz, 2402 MHz, ..., 2481 MHz.
 		"""
-		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE2M:MEASurement:MODE?')
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE1M:MEASurement:MODE?')
 		return Conversions.str_to_scalar_enum(response, enums.LeChannelsRange)
 
 	def set_mode(self, meas_mode: enums.LeChannelsRange) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE2M:MEASurement:MODE \n
-		Snippet: driver.configure.multiEval.sacp.lowEnergy.le2M.measurement.set_mode(meas_mode = enums.LeChannelsRange.CH10) \n
-		Specifies the channel range for ACP measurements. Can be selected to cover either the full LE frequency band (forty 2 MHz
-		channels) or only the adjacency of the current LE channel (ten 2 MHz channels) . The commands for LE 1M PHY (...:LE1M...)
-		and LE 2M PHY (...:LE2M...) are available. Note: Although LE channels are 2 MHz wide, the channel width in ACP
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy[:LE1M]:MEASurement:MODE \n
+		Snippet: driver.configure.multiEval.sacp.lowEnergy.le1M.measurement.set_mode(meas_mode = enums.LeChannelsRange.CH10) \n
+		Specifies the channel range for ACP measurements. It can be selected to cover either the full LE frequency band (forty 2
+		MHz channels) or only the adjacency of the current LE channel (ten 2 MHz channels) . The commands for LE 1M PHY (...:LE1M.
+		..) and LE 2M PHY (...:LE2M...) are available. Note: Although LE channels are 2 MHz wide, the channel width in ACP
 		measurements is always 1 MHz ('half-channel') . \n
-			:param meas_mode: CH40 | CH10 CH10: Covers the current and its 10 adjacent 2 MHz LE channels (5 to the left, 5 to the right) . The R&S CMW measures the 1 MHz channels centered at fTX – 10 MHz, ..., fTX + 10 MHz. CH40: Covers all 40 LE channels. The R&S CMW measures the 81 half-channels centered at 2401 MHz, 2402 MHz, ..., 2481 MHz.
+			:param meas_mode: CH40 | CH10 CH10: 'ACP +/- 5 Channels' - covers the current and its 10 adjacent 2 MHz LE channels (5 to the left, 5 to the right) . The R&S CMW measures the 1 MHz channels centered at fTX – 10 MHz, ..., fTX + 10 MHz. CH40: 'LE All Channels' - covers all 40 LE channels. The R&S CMW measures the 81 half-channels centered at 2401 MHz, 2402 MHz, ..., 2481 MHz.
 		"""
 		param = Conversions.enum_scalar_to_str(meas_mode, enums.LeChannelsRange)
-		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE2M:MEASurement:MODE {param}')
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE1M:MEASurement:MODE {param}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Scount.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Scount.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scount:
-	"""Scount commands group definition. 7 total commands, 0 Sub-groups, 7 group commands"""
+class ScountCls:
+	"""Scount commands group definition. 7 total commands, 0 Subgroups, 7 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scount", core, parent)
+		self._cmd_group = CommandsGroup("scount", core, parent)
 
 	def get_pencoding(self) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCOunt:PENCoding \n
 		Snippet: value: int = driver.configure.multiEval.scount.get_pencoding() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
-		single shot. The last mnemonic denotes the measurement type: statistical modulation, statistical power and spectrum 20 dB
-		bandwidth (occupied bandwidth) measurement. \n
+		single shot. The last mnemonic denotes the measurement type: statistical modulation, phase encoding, statistical power,
+		and spectrum 20 dB bandwidth (occupied bandwidth) measurement. \n
 			:return: statistic_count: numeric Number of measurement intervals Range: 1 to 1000
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCOunt:PENCoding?')
 		return Conversions.str_to_int(response)
 
 	def set_pencoding(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCOunt:PENCoding \n
 		Snippet: driver.configure.multiEval.scount.set_pencoding(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
-		single shot. The last mnemonic denotes the measurement type: statistical modulation, statistical power and spectrum 20 dB
-		bandwidth (occupied bandwidth) measurement. \n
+		single shot. The last mnemonic denotes the measurement type: statistical modulation, phase encoding, statistical power,
+		and spectrum 20 dB bandwidth (occupied bandwidth) measurement. \n
 			:param statistic_count: numeric Number of measurement intervals Range: 1 to 1000
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCOunt:PENCoding {param}')
 
 	def get_frange(self) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCOunt:FRANge \n
@@ -77,27 +77,27 @@
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCOunt:SGACp {param}')
 
 	def get_so_bw(self) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCOunt:SOBW \n
 		Snippet: value: int = driver.configure.multiEval.scount.get_so_bw() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
-		single shot. The last mnemonic denotes the measurement type: statistical modulation, statistical power and spectrum 20 dB
-		bandwidth (occupied bandwidth) measurement. \n
+		single shot. The last mnemonic denotes the measurement type: statistical modulation, phase encoding, statistical power,
+		and spectrum 20 dB bandwidth (occupied bandwidth) measurement. \n
 			:return: statistic_count: numeric Number of measurement intervals Range: 1 to 1000
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCOunt:SOBW?')
 		return Conversions.str_to_int(response)
 
 	def set_so_bw(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCOunt:SOBW \n
 		Snippet: driver.configure.multiEval.scount.set_so_bw(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
-		single shot. The last mnemonic denotes the measurement type: statistical modulation, statistical power and spectrum 20 dB
-		bandwidth (occupied bandwidth) measurement. \n
+		single shot. The last mnemonic denotes the measurement type: statistical modulation, phase encoding, statistical power,
+		and spectrum 20 dB bandwidth (occupied bandwidth) measurement. \n
 			:param statistic_count: numeric Number of measurement intervals Range: 1 to 1000
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCOunt:SOBW {param}')
 
 	def get_sacp(self) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCOunt:SACP \n
@@ -121,46 +121,46 @@
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCOunt:SACP {param}')
 
 	def get_power_vs_time(self) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCOunt:PVTime \n
 		Snippet: value: int = driver.configure.multiEval.scount.get_power_vs_time() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
-		single shot. The last mnemonic denotes the measurement type: statistical modulation, statistical power and spectrum 20 dB
-		bandwidth (occupied bandwidth) measurement. \n
+		single shot. The last mnemonic denotes the measurement type: statistical modulation, phase encoding, statistical power,
+		and spectrum 20 dB bandwidth (occupied bandwidth) measurement. \n
 			:return: statistic_count: numeric Number of measurement intervals Range: 1 to 1000
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCOunt:PVTime?')
 		return Conversions.str_to_int(response)
 
 	def set_power_vs_time(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCOunt:PVTime \n
 		Snippet: driver.configure.multiEval.scount.set_power_vs_time(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
-		single shot. The last mnemonic denotes the measurement type: statistical modulation, statistical power and spectrum 20 dB
-		bandwidth (occupied bandwidth) measurement. \n
+		single shot. The last mnemonic denotes the measurement type: statistical modulation, phase encoding, statistical power,
+		and spectrum 20 dB bandwidth (occupied bandwidth) measurement. \n
 			:param statistic_count: numeric Number of measurement intervals Range: 1 to 1000
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCOunt:PVTime {param}')
 
 	def get_modulation(self) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCOunt:MODulation \n
 		Snippet: value: int = driver.configure.multiEval.scount.get_modulation() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
-		single shot. The last mnemonic denotes the measurement type: statistical modulation, statistical power and spectrum 20 dB
-		bandwidth (occupied bandwidth) measurement. \n
+		single shot. The last mnemonic denotes the measurement type: statistical modulation, phase encoding, statistical power,
+		and spectrum 20 dB bandwidth (occupied bandwidth) measurement. \n
 			:return: statistic_count: numeric Number of measurement intervals Range: 1 to 1000
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCOunt:MODulation?')
 		return Conversions.str_to_int(response)
 
 	def set_modulation(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCOunt:MODulation \n
 		Snippet: driver.configure.multiEval.scount.set_modulation(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
-		single shot. The last mnemonic denotes the measurement type: statistical modulation, statistical power and spectrum 20 dB
-		bandwidth (occupied bandwidth) measurement. \n
+		single shot. The last mnemonic denotes the measurement type: statistical modulation, phase encoding, statistical power,
+		and spectrum 20 dB bandwidth (occupied bandwidth) measurement. \n
 			:param statistic_count: numeric Number of measurement intervals Range: 1 to 1000
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SCOunt:MODulation {param}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sgacp.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Pencoding/Ssequence/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sgacp:
-	"""Sgacp commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class SsequenceCls:
+	"""Ssequence commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sgacp", core, parent)
+		self._cmd_group = CommandsGroup("ssequence", core, parent)
 
 	@property
 	def edrate(self):
 		"""edrate commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_edrate'):
-			from .Sgacp_.Edrate import Edrate
-			self._edrate = Edrate(self._core, self._base)
+			from .Edrate import EdrateCls
+			self._edrate = EdrateCls(self._core, self._cmd_group)
 		return self._edrate
 
-	def clone(self) -> 'Sgacp':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SsequenceCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Sgacp(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SsequenceCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sgacp_/Edrate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Frange/Brate/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Edrate:
-	"""Edrate commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class BrateCls:
+	"""Brate commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("edrate", core, parent)
+		self._cmd_group = CommandsGroup("brate", core, parent)
 
 	@property
 	def measurement(self):
 		"""measurement commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_measurement'):
-			from .Edrate_.Measurement import Measurement
-			self._measurement = Measurement(self._core, self._base)
+			from .Measurement import MeasurementCls
+			self._measurement = MeasurementCls(self._core, self._cmd_group)
 		return self._measurement
 
-	def clone(self) -> 'Edrate':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'BrateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Edrate(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = BrateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/MultiEval_/Sgacp_/Edrate_/Measurement.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sgacp/Edrate/Measurement.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal import Conversions
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Measurement:
-	"""Measurement commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MeasurementCls:
+	"""Measurement commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("measurement", core, parent)
+		self._cmd_group = CommandsGroup("measurement", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_mode(self) -> enums.BrEdrChannelsRange:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:MEValuation:SGACp:EDRate:MEASurement:MODE \n
 		Snippet: value: enums.BrEdrChannelsRange = driver.configure.multiEval.sgacp.edrate.measurement.get_mode() \n
 		Selects the measured ACP channel range for BR or EDR packets. The ACP can be measured over the expected transmit channel
 		+/- 10 channels (21 channels in total) or over the entire Bluetooth regulatory range (79 channels) . \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RfSettings_/Cte.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/DtMode/RxQuality/Plength/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cte:
-	"""Cte commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class PlengthCls:
+	"""Plength commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cte", core, parent)
+		self._cmd_group = CommandsGroup("plength", core, parent)
 
 	@property
 	def lowEnergy(self):
 		"""lowEnergy commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_lowEnergy'):
-			from .Cte_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
 		return self._lowEnergy
 
-	def clone(self) -> 'Cte':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PlengthCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cte(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PlengthCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RfSettings_/Dtx.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RfSettings/Dtx.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dtx:
-	"""Dtx commands group definition. 4 total commands, 0 Sub-groups, 4 group commands"""
+class DtxCls:
+	"""Dtx commands group definition. 4 total commands, 0 Subgroups, 4 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dtx", core, parent)
+		self._cmd_group = CommandsGroup("dtx", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_st_error(self) -> enums.LeSymolTimeError:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:DTX:STERror \n
 		Snippet: value: enums.LeSymolTimeError = driver.configure.rfSettings.dtx.get_st_error() \n
 		No command help available \n
 			:return: sym_tim_err: No help available
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RfSettings_/Mchannel.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RfSettings/Mchannel.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Mchannel:
-	"""Mchannel commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MchannelCls:
+	"""Mchannel commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("mchannel", core, parent)
+		self._cmd_group = CommandsGroup("mchannel", core, parent)
 
 	def get_classic(self) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:MCHannel[:CLASsic] \n
 		Snippet: value: int = driver.configure.rfSettings.mchannel.get_classic() \n
 		Specifies the channel to be measured in CSP single channel mode for classic, see method RsCmwBluetoothMeas.Configure.
 		RfSettings.Mmode.value \n
 			:return: measured_channel: numeric Range: 0 to 78
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RfSettings_/Mmode.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RfSettings/Mmode/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,48 +1,48 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Mmode:
-	"""Mmode commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class MmodeCls:
+	"""Mmode commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("mmode", core, parent)
+		self._cmd_group = CommandsGroup("mmode", core, parent)
 
 	@property
 	def nmode(self):
 		"""nmode commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_nmode'):
-			from .Mmode_.Nmode import Nmode
-			self._nmode = Nmode(self._core, self._base)
+			from .Nmode import NmodeCls
+			self._nmode = NmodeCls(self._core, self._cmd_group)
 		return self._nmode
 
 	# noinspection PyTypeChecker
 	def get_value(self) -> enums.MeasureScope:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:MMODe \n
 		Snippet: value: enums.MeasureScope = driver.configure.rfSettings.mmode.get_value() \n
 		Sets measure mode for BR/EDR test mode in combined signal path scenario during hopping enabled. \n
-			:return: measure_mode: ALL | SINGle ALL: multi-evaluation TX measurements on all channels SINGle: multi-evaluation TX measurements on specified channel, see CONFigure:BLUetooth:MEASi:RFSettings
+			:return: measure_mode: ALL | SINGle ALL: multi-evaluation TX measurements on all channels SINGle: multi-evaluation TX measurements on specified channel, see method RsCmwBluetoothMeas.Configure.RfSettings.Mchannel.classic
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:MMODe?')
 		return Conversions.str_to_scalar_enum(response, enums.MeasureScope)
 
 	def set_value(self, measure_mode: enums.MeasureScope) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:MMODe \n
 		Snippet: driver.configure.rfSettings.mmode.set_value(measure_mode = enums.MeasureScope.ALL) \n
 		Sets measure mode for BR/EDR test mode in combined signal path scenario during hopping enabled. \n
-			:param measure_mode: ALL | SINGle ALL: multi-evaluation TX measurements on all channels SINGle: multi-evaluation TX measurements on specified channel, see CONFigure:BLUetooth:MEASi:RFSettings
+			:param measure_mode: ALL | SINGle ALL: multi-evaluation TX measurements on all channels SINGle: multi-evaluation TX measurements on specified channel, see method RsCmwBluetoothMeas.Configure.RfSettings.Mchannel.classic
 		"""
 		param = Conversions.enum_scalar_to_str(measure_mode, enums.MeasureScope)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:MMODe {param}')
 
-	def clone(self) -> 'Mmode':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MmodeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Mmode(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MmodeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RfSettings_/Mmode_/Nmode.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RfSettings/Mmode/Nmode.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,38 +1,40 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Nmode:
-	"""Nmode commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class NmodeCls:
+	"""Nmode commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nmode", core, parent)
+		self._cmd_group = CommandsGroup("nmode", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_low_energy(self) -> enums.MeasureScope:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:MMODe:NMODe:LENergy \n
 		Snippet: value: enums.MeasureScope = driver.configure.rfSettings.mmode.nmode.get_low_energy() \n
 		Specifies measurement mode for LE connection tests in combined signal path scenario.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- All 37 data channels can only be measured if signaling application uses all channel hopping mode.
-			- Single channel mode enables Tx measurements at the specified RF channel \n
+			- All 37 data channels can only be measured if signaling application uses all-channel hopping mode.
+			- Single channel mode enables Tx measurements at the specified RF channel
+		For the combined signal path scenario, use CONFigure:BLUetooth:SIGN<i>:RFSettings:NMODe:HMODe:LENergy \n
 			:return: measure_mode: ALL | SINGle
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:MMODe:NMODe:LENergy?')
 		return Conversions.str_to_scalar_enum(response, enums.MeasureScope)
 
 	def set_low_energy(self, measure_mode: enums.MeasureScope) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:MMODe:NMODe:LENergy \n
 		Snippet: driver.configure.rfSettings.mmode.nmode.set_low_energy(measure_mode = enums.MeasureScope.ALL) \n
 		Specifies measurement mode for LE connection tests in combined signal path scenario.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- All 37 data channels can only be measured if signaling application uses all channel hopping mode.
-			- Single channel mode enables Tx measurements at the specified RF channel \n
+			- All 37 data channels can only be measured if signaling application uses all-channel hopping mode.
+			- Single channel mode enables Tx measurements at the specified RF channel
+		For the combined signal path scenario, use CONFigure:BLUetooth:SIGN<i>:RFSettings:NMODe:HMODe:LENergy \n
 			:param measure_mode: ALL | SINGle
 		"""
 		param = Conversions.enum_scalar_to_str(measure_mode, enums.MeasureScope)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:RFSettings:MMODe:NMODe:LENergy {param}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RxQuality.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RxQuality/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,60 +1,60 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ...Internal.Utilities import trim_str_response
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.Utilities import trim_str_response
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RxQuality:
-	"""RxQuality commands group definition. 16 total commands, 5 Sub-groups, 7 group commands"""
+class RxQualityCls:
+	"""RxQuality commands group definition. 17 total commands, 5 Subgroups, 7 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rxQuality", core, parent)
+		self._cmd_group = CommandsGroup("rxQuality", core, parent)
 
 	@property
 	def sensitivity(self):
 		"""sensitivity commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_sensitivity'):
-			from .RxQuality_.Sensitivity import Sensitivity
-			self._sensitivity = Sensitivity(self._core, self._base)
+			from .Sensitivity import SensitivityCls
+			self._sensitivity = SensitivityCls(self._core, self._cmd_group)
 		return self._sensitivity
 
 	@property
 	def spotCheck(self):
 		"""spotCheck commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_spotCheck'):
-			from .RxQuality_.SpotCheck import SpotCheck
-			self._spotCheck = SpotCheck(self._core, self._base)
+			from .SpotCheck import SpotCheckCls
+			self._spotCheck = SpotCheckCls(self._core, self._cmd_group)
 		return self._spotCheck
 
 	@property
 	def per(self):
-		"""per commands group. 0 Sub-classes, 2 commands."""
+		"""per commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_per'):
-			from .RxQuality_.Per import Per
-			self._per = Per(self._core, self._base)
+			from .Per import PerCls
+			self._per = PerCls(self._core, self._cmd_group)
 		return self._per
 
 	@property
 	def route(self):
 		"""route commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_route'):
-			from .RxQuality_.Route import Route
-			self._route = Route(self._core, self._base)
+			from .Route import RouteCls
+			self._route = RouteCls(self._core, self._cmd_group)
 		return self._route
 
 	@property
 	def eattenuation(self):
 		"""eattenuation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_eattenuation'):
-			from .RxQuality_.Eattenuation import Eattenuation
-			self._eattenuation = Eattenuation(self._core, self._base)
+			from .Eattenuation import EattenuationCls
+			self._eattenuation = EattenuationCls(self._core, self._cmd_group)
 		return self._eattenuation
 
 	def get_doffset(self) -> int:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:DOFFset \n
 		Snippet: value: int = driver.configure.rxQuality.get_doffset() \n
 		No command help available \n
 			:return: delay_offset: No help available
@@ -78,15 +78,15 @@
 			:return: scanner_address: hex 12-digit hexadecimal number Range: #H0 to #HFFFFFFFFFFFF
 		"""
 		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:SADDress?')
 		return trim_str_response(response)
 
 	def set_saddress(self, scanner_address: str) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:SADDress \n
-		Snippet: driver.configure.rxQuality.set_saddress(scanner_address = r1) \n
+		Snippet: driver.configure.rxQuality.set_saddress(scanner_address = rawAbc) \n
 		Sets the scanner's device address of R&S CMW. \n
 			:param scanner_address: hex 12-digit hexadecimal number Range: #H0 to #HFFFFFFFFFFFF
 		"""
 		param = Conversions.value_to_str(scanner_address)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:SADDress {param}')
 
 	# noinspection PyTypeChecker
@@ -177,14 +177,14 @@
 		Snippet: driver.configure.rxQuality.set_aindex(adv_chan_index = 1) \n
 		Specifies the advertiser channel index to be measured. See also Figure 'RF channel index'. \n
 			:param adv_chan_index: numeric Range: 37 to 39
 		"""
 		param = Conversions.decimal_value_to_str(adv_chan_index)
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:AINDex {param}')
 
-	def clone(self) -> 'RxQuality':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RxQualityCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = RxQuality(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RxQualityCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RxQuality_/Route.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Route/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,63 +1,66 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
-from .... import enums
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
+from ...Internal.StructBase import StructBase
+from ...Internal.ArgStruct import ArgStruct
+from ... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Route:
-	"""Route commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class RouteCls:
+	"""Route commands group definition. 6 total commands, 2 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("route", core, parent)
+		self._cmd_group = CommandsGroup("route", core, parent)
 
 	@property
-	def usage(self):
-		"""usage commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_usage'):
-			from .Route_.Usage import Usage
-			self._usage = Usage(self._core, self._base)
-		return self._usage
+	def scenario(self):
+		"""scenario commands group. 2 Sub-classes, 2 commands."""
+		if not hasattr(self, '_scenario'):
+			from .Scenario import ScenarioCls
+			self._scenario = ScenarioCls(self._core, self._cmd_group)
+		return self._scenario
+
+	@property
+	def rfSettings(self):
+		"""rfSettings commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_rfSettings'):
+			from .RfSettings import RfSettingsCls
+			self._rfSettings = RfSettingsCls(self._core, self._cmd_group)
+		return self._rfSettings
 
 	# noinspection PyTypeChecker
-	class ValueStruct(StructBase):
+	class ValueStruct(StructBase):  # From ReadStructDefinition CmdPropertyTemplate.xml
 		"""Structure for reading output parameters. Fields: \n
-			- Tx_Connector: enums.TxConnector: RF connector for the output path
-			- Rf_Converter: enums.TxConverter: TX module for the output path"""
+			- Scenario: enums.TestScenario: SALone | CSPath SALone: standalone (non-signaling) CSPath: combined signal path
+			- Master: str: string Controlling application for scenario CSPath Not relevant for stand-alone scenario
+			- Rf_Connector: enums.RfConnector: RF connector for the input path
+			- Rf_Converter: enums.RxConverter: RX module for the input path"""
 		__meta_args_list = [
-			ArgStruct.scalar_enum('Tx_Connector', enums.TxConnector),
-			ArgStruct.scalar_enum('Rf_Converter', enums.TxConverter)]
+			ArgStruct.scalar_enum('Scenario', enums.TestScenario),
+			ArgStruct.scalar_str('Master'),
+			ArgStruct.scalar_enum('Rf_Connector', enums.RfConnector),
+			ArgStruct.scalar_enum('Rf_Converter', enums.RxConverter)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Tx_Connector: enums.TxConnector = None
-			self.Rf_Converter: enums.TxConverter = None
+			self.Scenario: enums.TestScenario = None
+			self.Master: str = None
+			self.Rf_Connector: enums.RfConnector = None
+			self.Rf_Converter: enums.RxConverter = None
 
-	# noinspection PyTypeChecker
 	def get_value(self) -> ValueStruct:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:ROUTe \n
-		Snippet: value: ValueStruct = driver.configure.rxQuality.route.get_value() \n
-		Selects the RF output path for the RF signal generated using ARB files. For possible TX module values, see 'Values for RF
-		Path Selection'. \n
+		"""SCPI: ROUTe:BLUetooth:MEASurement<Instance> \n
+		Snippet: value: ValueStruct = driver.route.get_value() \n
+		Returns the configured routing settings. For possible connector and converter values, see 'Values for RF path selection'. \n
 			:return: structure: for return value, see the help for ValueStruct structure arguments.
 		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:ROUTe?', self.__class__.ValueStruct())
-
-	def set_value(self, value: ValueStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:ROUTe \n
-		Snippet: driver.configure.rxQuality.route.set_value(value = ValueStruct()) \n
-		Selects the RF output path for the RF signal generated using ARB files. For possible TX module values, see 'Values for RF
-		Path Selection'. \n
-			:param value: see the help for ValueStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:ROUTe', value)
+		return self._core.io.query_struct('ROUTe:BLUetooth:MEASurement<Instance>?', self.__class__.ValueStruct())
 
-	def clone(self) -> 'Route':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RouteCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Route(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RouteCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RxQuality_/Route_/Usage.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RxQuality/Route/Usage/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Usage:
-	"""Usage commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class UsageCls:
+	"""Usage commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("usage", core, parent)
+		self._cmd_group = CommandsGroup("usage", core, parent)
 
 	@property
 	def all(self):
 		"""all commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_all'):
-			from .Usage_.All import All
-			self._all = All(self._core, self._base)
+			from .All import AllCls
+			self._all = AllCls(self._core, self._cmd_group)
 		return self._all
 
-	def clone(self) -> 'Usage':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'UsageCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Usage(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = UsageCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RxQuality_/Route_/Usage_/All.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RxQuality/Route/Usage/All.py`

 * *Files 3% similar despite different names*

```diff
@@ -6,35 +6,35 @@
 from ......Internal.Types import DataType
 from ......Internal.ArgSingleList import ArgSingleList
 from ......Internal.ArgSingle import ArgSingle
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class All:
-	"""All commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AllCls:
+	"""All commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("all", core, parent)
+		self._cmd_group = CommandsGroup("all", core, parent)
 
 	def set(self, tx_connector_bench: enums.TxConnectorBench, usage: List[bool]) -> None:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:ROUTe:USAGe:ALL \n
 		Snippet: driver.configure.rxQuality.route.usage.all.set(tx_connector_bench = enums.TxConnectorBench.R118, usage = [True, False, True]) \n
 		Activates or deactivates the individual RF connectors of a connector bench. The setting is relevant for non-signaling Rx
-		measurements. For possible bench values, see 'Values for RF Path Selection'. \n
+		measurements. For possible bench values, see 'Values for RF path selection'. \n
 			:param tx_connector_bench: Selects a bench with 4 or 8 connectors.
 			:param usage: OFF | ON Comma-separated list of 4 or 8 values, one for each connector of the bench.
 		"""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('tx_connector_bench', tx_connector_bench, DataType.Enum), ArgSingle.as_open_list('usage', usage, DataType.BooleanList))
+		param = ArgSingleList().compose_cmd_string(ArgSingle('tx_connector_bench', tx_connector_bench, DataType.Enum, enums.TxConnectorBench), ArgSingle.as_open_list('usage', usage, DataType.BooleanList, None))
 		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:ROUTe:USAGe:ALL {param}'.rstrip())
 
 	def get(self, tx_connector_bench: enums.TxConnectorBench) -> List[bool]:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:ROUTe:USAGe:ALL \n
 		Snippet: value: List[bool] = driver.configure.rxQuality.route.usage.all.get(tx_connector_bench = enums.TxConnectorBench.R118) \n
 		Activates or deactivates the individual RF connectors of a connector bench. The setting is relevant for non-signaling Rx
-		measurements. For possible bench values, see 'Values for RF Path Selection'. \n
+		measurements. For possible bench values, see 'Values for RF path selection'. \n
 			:param tx_connector_bench: Selects a bench with 4 or 8 connectors.
 			:return: usage: OFF | ON Comma-separated list of 4 or 8 values, one for each connector of the bench."""
 		param = Conversions.enum_scalar_to_str(tx_connector_bench, enums.TxConnectorBench)
 		response = self._core.io.query_str(f'CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:ROUTe:USAGe:ALL? {param}')
 		return Conversions.str_to_bool_list(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RxQuality_/Sensitivity.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RxQuality/Sensitivity.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sensitivity:
-	"""Sensitivity commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class SensitivityCls:
+	"""Sensitivity commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sensitivity", core, parent)
+		self._cmd_group = CommandsGroup("sensitivity", core, parent)
 
 	def get_start_level(self) -> float:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:SENSitivity:STARtlevel \n
 		Snippet: value: float = driver.configure.rxQuality.sensitivity.get_start_level() \n
 		Sets Tx start level of R&S CMW for sensitivity search measurement. The allowed value range can be calculated as follows:
 		Range (Start Level) = Range (Output Power) - External Attenuation Range (Output Power) = -130 dBm to 0 dBm (RFx COM) or
 		-120 dBm to 8 dBm (RFx OUT) ; please also notice the ranges quoted in the data sheet. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/RxQuality_/SpotCheck.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RxQuality/SpotCheck.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SpotCheck:
-	"""SpotCheck commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SpotCheckCls:
+	"""SpotCheck commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("spotCheck", core, parent)
+		self._cmd_group = CommandsGroup("spotCheck", core, parent)
 
 	def get_level(self) -> float:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:SPOTcheck:LEVel \n
 		Snippet: value: float = driver.configure.rxQuality.spotCheck.get_level() \n
 		Sets the Tx level of R&S CMW for spot check. The allowed value range can be calculated as follows: Range (Level) = Range
 		(Output Power) - External Attenuation Range (Output Power) = -130 dBm to 0 dBm (RFx COM) or -120 dBm to 8 dBm (RFx OUT) ;
 		please also notice the ranges quoted in the data sheet. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/Trx.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/SoBw/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Trx:
-	"""Trx commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class SoBwCls:
+	"""SoBw commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("trx", core, parent)
+		self._cmd_group = CommandsGroup("soBw", core, parent)
 
 	@property
-	def result(self):
-		"""result commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_result'):
-			from .Trx_.Result import Result
-			self._result = Result(self._core, self._base)
-		return self._result
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
 
-	def clone(self) -> 'Trx':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SoBwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Trx(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SoBwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Configure_/Trx_/Result.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Trx/Result/All.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,24 +1,39 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Types import DataType
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
+from .....Internal.ArgSingleList import ArgSingleList
+from .....Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Result:
-	"""Result commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AllCls:
+	"""All commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("result", core, parent)
+		self._cmd_group = CommandsGroup("all", core, parent)
+
+	def set(self, spot_check: bool, power: bool, modulation: bool, spectrum_acp: bool) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:TRX:RESult[:ALL] \n
+		Snippet: driver.configure.trx.result.all.set(spot_check = False, power = False, modulation = False, spectrum_acp = False) \n
+		Enables or disables the evaluation of results. \n
+			:param spot_check: OFF | ON Spot check ON: Evaluate results OFF: Do not evaluate results
+			:param power: OFF | ON Statistical power results
+			:param modulation: OFF | ON Statistical modulation results
+			:param spectrum_acp: OFF | ON Spectrum ACP results Only ACP+/-5 channel mode supported (21 half-channels)
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('spot_check', spot_check, DataType.Boolean), ArgSingle('power', power, DataType.Boolean), ArgSingle('modulation', modulation, DataType.Boolean), ArgSingle('spectrum_acp', spectrum_acp, DataType.Boolean))
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:TRX:RESult:ALL {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class AllStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
+		"""Response structure. Fields: \n
 			- Spot_Check: bool: OFF | ON Spot check ON: Evaluate results OFF: Do not evaluate results
 			- Power: bool: OFF | ON Statistical power results
 			- Modulation: bool: OFF | ON Statistical modulation results
 			- Spectrum_Acp: bool: OFF | ON Spectrum ACP results Only ACP+/-5 channel mode supported (21 half-channels)"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Spot_Check'),
 			ArgStruct.scalar_bool('Power'),
@@ -28,22 +43,13 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Spot_Check: bool = None
 			self.Power: bool = None
 			self.Modulation: bool = None
 			self.Spectrum_Acp: bool = None
 
-	def get_all(self) -> AllStruct:
+	def get(self) -> AllStruct:
 		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:TRX:RESult[:ALL] \n
-		Snippet: value: AllStruct = driver.configure.trx.result.get_all() \n
+		Snippet: value: AllStruct = driver.configure.trx.result.all.get() \n
 		Enables or disables the evaluation of results. \n
-			:return: structure: for return value, see the help for AllStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:BLUetooth:MEASurement<Instance>:TRX:RESult:ALL?', self.__class__.AllStruct())
-
-	def set_all(self, value: AllStruct) -> None:
-		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:TRX:RESult[:ALL] \n
-		Snippet: driver.configure.trx.result.set_all(value = AllStruct()) \n
-		Enables or disables the evaluation of results. \n
-			:param value: see the help for AllStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:BLUetooth:MEASurement<Instance>:TRX:RESult:ALL', value)
+			:return: structure: for return value, see the help for AllStruct structure arguments."""
+		return self._core.io.query_struct(f'CONFigure:BLUetooth:MEASurement<Instance>:TRX:RESult:ALL?', self.__class__.AllStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Diagnostic.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Diagnostic/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Diagnostic:
-	"""Diagnostic commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class DiagnosticCls:
+	"""Diagnostic commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("diagnostic", core, parent)
+		self._cmd_group = CommandsGroup("diagnostic", core, parent)
 
 	@property
 	def rfControl(self):
 		"""rfControl commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rfControl'):
-			from .Diagnostic_.RfControl import RfControl
-			self._rfControl = RfControl(self._core, self._base)
+			from .RfControl import RfControlCls
+			self._rfControl = RfControlCls(self._core, self._cmd_group)
 		return self._rfControl
 
 	@property
 	def bluetooth(self):
-		"""bluetooth commands group. 0 Sub-classes, 1 commands."""
+		"""bluetooth commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_bluetooth'):
-			from .Diagnostic_.Bluetooth import Bluetooth
-			self._bluetooth = Bluetooth(self._core, self._base)
+			from .Bluetooth import BluetoothCls
+			self._bluetooth = BluetoothCls(self._core, self._cmd_group)
 		return self._bluetooth
 
-	def clone(self) -> 'Diagnostic':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'DiagnosticCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Diagnostic(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = DiagnosticCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Diagnostic_/Bluetooth.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Qhsl/P6Q.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,46 +1,68 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal.StructBase import StructBase
-from ...Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Bluetooth:
-	"""Bluetooth commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class P6QCls:
+	"""P6Q commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("bluetooth", core, parent)
+		self._cmd_group = CommandsGroup("p6Q", core, parent)
 
 	# noinspection PyTypeChecker
-	class SynchroniseStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Min_No_Valid_Bursts: int: No parameter help available
-			- Syn_Check_Filter: int: No parameter help available
-			- Max_Invalid_Burst: int: No parameter help available"""
+	class CalculateStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: No parameter help available
+			- Nominal_Power: float or bool: No parameter help available
+			- No_Of_Exceptions: float or bool: No parameter help available"""
 		__meta_args_list = [
-			ArgStruct.scalar_int('Min_No_Valid_Bursts'),
-			ArgStruct.scalar_int('Syn_Check_Filter'),
-			ArgStruct.scalar_int('Max_Invalid_Burst')]
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('No_Of_Exceptions')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Min_No_Valid_Bursts: int = None
-			self.Syn_Check_Filter: int = None
-			self.Max_Invalid_Burst: int = None
-
-	def get_synchronise(self) -> SynchroniseStruct:
-		"""SCPI: DIAGnostic:BLUetooth:SYNChronise \n
-		Snippet: value: SynchroniseStruct = driver.diagnostic.bluetooth.get_synchronise() \n
+			self.Reliability: int = None
+			self.Nominal_Power: float or bool = None
+			self.No_Of_Exceptions: float or bool = None
+
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:QHSL:P6Q \n
+		Snippet: value: CalculateStruct = driver.multiEval.sacp.qhsl.p6Q.calculate() \n
 		No command help available \n
-			:return: structure: for return value, see the help for SynchroniseStruct structure arguments.
-		"""
-		return self._core.io.query_struct('DIAGnostic:BLUetooth:SYNChronise?', self.__class__.SynchroniseStruct())
-
-	def set_synchronise(self, value: SynchroniseStruct) -> None:
-		"""SCPI: DIAGnostic:BLUetooth:SYNChronise \n
-		Snippet: driver.diagnostic.bluetooth.set_synchronise(value = SynchroniseStruct()) \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:QHSL:P6Q?', self.__class__.CalculateStruct())
+
+	# noinspection PyTypeChecker
+	class ResultData(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: No parameter help available
+			- Nominal_Power: float: No parameter help available
+			- No_Of_Exceptions: int: No parameter help available"""
+		__meta_args_list = [
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_int('No_Of_Exceptions')]
+
+		def __init__(self):
+			StructBase.__init__(self, self)
+			self.Reliability: int = None
+			self.Nominal_Power: float = None
+			self.No_Of_Exceptions: int = None
+
+	def read(self) -> ResultData:
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:QHSL:P6Q \n
+		Snippet: value: ResultData = driver.multiEval.sacp.qhsl.p6Q.read() \n
+		No command help available \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:QHSL:P6Q?', self.__class__.ResultData())
+
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:QHSL:P6Q \n
+		Snippet: value: ResultData = driver.multiEval.sacp.qhsl.p6Q.fetch() \n
 		No command help available \n
-			:param value: see the help for SynchroniseStruct structure arguments.
-		"""
-		self._core.io.write_struct('DIAGnostic:BLUetooth:SYNChronise', value)
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:QHSL:P6Q?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Diagnostic_/RfControl.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Diagnostic/RfControl.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RfControl:
-	"""RfControl commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RfControlCls:
+	"""RfControl commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rfControl", core, parent)
+		self._cmd_group = CommandsGroup("rfControl", core, parent)
 
 	def get_tx_enable(self) -> bool:
 		"""SCPI: DIAGnostic:BLUetooth:MEASurement<Instance>:RFControl:TXENable \n
 		Snippet: value: bool = driver.diagnostic.rfControl.get_tx_enable() \n
 		No command help available \n
 			:return: set_ctrl_bit: No help available
 		"""
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/LowEnergy/Le2M/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,27 +1,35 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DtMode:
-	"""DtMode commands group definition. 26 total commands, 1 Sub-groups, 0 group commands"""
+class Le2MCls:
+	"""Le2M commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dtMode", core, parent)
+		self._cmd_group = CommandsGroup("le2M", core, parent)
 
 	@property
-	def rxQuality(self):
-		"""rxQuality commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_rxQuality'):
-			from .DtMode_.RxQuality import RxQuality
-			self._rxQuality = RxQuality(self._core, self._base)
-		return self._rxQuality
+	def typePy(self):
+		"""typePy commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_typePy'):
+			from .TypePy import TypePyCls
+			self._typePy = TypePyCls(self._core, self._cmd_group)
+		return self._typePy
 
-	def clone(self) -> 'DtMode':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def units(self):
+		"""units commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_units'):
+			from .Units import UnitsCls
+			self._units = UnitsCls(self._core, self._cmd_group)
+		return self._units
+
+	def clone(self) -> 'Le2MCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = DtMode(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = Le2MCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/DtMode/RxQuality/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RxQuality:
-	"""RxQuality commands group definition. 26 total commands, 2 Sub-groups, 0 group commands"""
+class RxQualityCls:
+	"""RxQuality commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rxQuality", core, parent)
+		self._cmd_group = CommandsGroup("rxQuality", core, parent)
 
 	@property
-	def search(self):
-		"""search commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_search'):
-			from .RxQuality_.Search import Search
-			self._search = Search(self._core, self._base)
-		return self._search
+	def plength(self):
+		"""plength commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_plength'):
+			from .Plength import PlengthCls
+			self._plength = PlengthCls(self._core, self._cmd_group)
+		return self._plength
 
-	@property
-	def per(self):
-		"""per commands group. 2 Sub-classes, 3 commands."""
-		if not hasattr(self, '_per'):
-			from .RxQuality_.Per import Per
-			self._per = Per(self._core, self._base)
-		return self._per
-
-	def clone(self) -> 'RxQuality':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RxQualityCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = RxQuality(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RxQualityCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Per.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,104 +1,144 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Per:
-	"""Per commands group definition. 13 total commands, 2 Sub-groups, 3 group commands"""
+class MultiEvalCls:
+	"""MultiEval commands group definition. 608 total commands, 10 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("per", core, parent)
+		self._cmd_group = CommandsGroup("multiEval", core, parent)
 
 	@property
-	def state(self):
-		"""state commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_state'):
-			from .Per_.State import State
-			self._state = State(self._core, self._base)
-		return self._state
+	def sacp(self):
+		"""sacp commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_sacp'):
+			from .Sacp import SacpCls
+			self._sacp = SacpCls(self._core, self._cmd_group)
+		return self._sacp
 
 	@property
-	def lowEnergy(self):
-		"""lowEnergy commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_lowEnergy'):
-			from .Per_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
-		return self._lowEnergy
-
-	def initiate(self) -> None:
-		"""SCPI: INITiate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER \n
-		Snippet: driver.dtMode.rxQuality.per.initiate() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'INITiate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER')
+	def powerVsTime(self):
+		"""powerVsTime commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_powerVsTime'):
+			from .PowerVsTime import PowerVsTimeCls
+			self._powerVsTime = PowerVsTimeCls(self._core, self._cmd_group)
+		return self._powerVsTime
 
-	def initiate_with_opc(self) -> None:
-		"""SCPI: INITiate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER \n
-		Snippet: driver.dtMode.rxQuality.per.initiate_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		Same as initiate, but waits for the operation to complete before continuing further. Use the RsCmwBluetoothMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'INITiate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER')
+	@property
+	def modulation(self):
+		"""modulation commands group. 6 Sub-classes, 0 commands."""
+		if not hasattr(self, '_modulation'):
+			from .Modulation import ModulationCls
+			self._modulation = ModulationCls(self._core, self._cmd_group)
+		return self._modulation
+
+	@property
+	def listPy(self):
+		"""listPy commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_listPy'):
+			from .ListPy import ListPyCls
+			self._listPy = ListPyCls(self._core, self._cmd_group)
+		return self._listPy
+
+	@property
+	def trace(self):
+		"""trace commands group. 13 Sub-classes, 0 commands."""
+		if not hasattr(self, '_trace'):
+			from .Trace import TraceCls
+			self._trace = TraceCls(self._core, self._cmd_group)
+		return self._trace
+
+	@property
+	def frange(self):
+		"""frange commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_frange'):
+			from .Frange import FrangeCls
+			self._frange = FrangeCls(self._core, self._cmd_group)
+		return self._frange
+
+	@property
+	def sgacp(self):
+		"""sgacp commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_sgacp'):
+			from .Sgacp import SgacpCls
+			self._sgacp = SgacpCls(self._core, self._cmd_group)
+		return self._sgacp
+
+	@property
+	def soBw(self):
+		"""soBw commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_soBw'):
+			from .SoBw import SoBwCls
+			self._soBw = SoBwCls(self._core, self._cmd_group)
+		return self._soBw
+
+	@property
+	def pencoding(self):
+		"""pencoding commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_pencoding'):
+			from .Pencoding import PencodingCls
+			self._pencoding = PencodingCls(self._core, self._cmd_group)
+		return self._pencoding
+
+	@property
+	def state(self):
+		"""state commands group. 1 Sub-classes, 1 commands."""
+		if not hasattr(self, '_state'):
+			from .State import StateCls
+			self._state = StateCls(self._core, self._cmd_group)
+		return self._state
 
 	def stop(self) -> None:
-		"""SCPI: STOP:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER \n
-		Snippet: driver.dtMode.rxQuality.per.stop() \n
+		"""SCPI: STOP:BLUetooth:MEASurement<Instance>:MEValuation \n
+		Snippet: driver.multiEval.stop() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
 		"""
-		self._core.io.write(f'STOP:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER')
+		self._core.io.write(f'STOP:BLUetooth:MEASurement<Instance>:MEValuation')
 
-	def stop_with_opc(self) -> None:
-		"""SCPI: STOP:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER \n
-		Snippet: driver.dtMode.rxQuality.per.stop_with_opc() \n
+	def stop_with_opc(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: STOP:BLUetooth:MEASurement<Instance>:MEValuation \n
+		Snippet: driver.multiEval.stop_with_opc() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
 		Same as stop, but waits for the operation to complete before continuing further. Use the RsCmwBluetoothMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'STOP:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'STOP:BLUetooth:MEASurement<Instance>:MEValuation', opc_timeout_ms)
 
-	def abort(self) -> None:
-		"""SCPI: ABORt:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER \n
-		Snippet: driver.dtMode.rxQuality.per.abort() \n
+	def abort(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: ABORt:BLUetooth:MEASurement<Instance>:MEValuation \n
+		Snippet: driver.multiEval.abort() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'ABORt:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'ABORt:BLUetooth:MEASurement<Instance>:MEValuation', opc_timeout_ms)
 
-	def abort_with_opc(self) -> None:
-		"""SCPI: ABORt:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER \n
-		Snippet: driver.dtMode.rxQuality.per.abort_with_opc() \n
+	def initiate(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: INITiate:BLUetooth:MEASurement<Instance>:MEValuation \n
+		Snippet: driver.multiEval.initiate() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		Same as abort, but waits for the operation to complete before continuing further. Use the RsCmwBluetoothMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'ABORt:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'INITiate:BLUetooth:MEASurement<Instance>:MEValuation', opc_timeout_ms)
 
-	def clone(self) -> 'Per':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MultiEvalCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Per(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MultiEvalCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Per_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Nmode/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,43 +1,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 9 total commands, 3 Sub-groups, 0 group commands"""
+class NmodeCls:
+	"""Nmode commands group definition. 12 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("nmode", core, parent)
 
 	@property
-	def le1M(self):
-		"""le1M commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_le1M'):
-			from .LowEnergy_.Le1M import Le1M
-			self._le1M = Le1M(self._core, self._base)
-		return self._le1M
+	def classic(self):
+		"""classic commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_classic'):
+			from .Classic import ClassicCls
+			self._classic = ClassicCls(self._core, self._cmd_group)
+		return self._classic
 
 	@property
-	def le2M(self):
-		"""le2M commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_le2M'):
-			from .LowEnergy_.Le2M import Le2M
-			self._le2M = Le2M(self._core, self._base)
-		return self._le2M
+	def lowEnergy(self):
+		"""lowEnergy commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_lowEnergy'):
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
+		return self._lowEnergy
 
-	@property
-	def lrange(self):
-		"""lrange commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_lrange'):
-			from .LowEnergy_.Lrange import Lrange
-			self._lrange = Lrange(self._core, self._base)
-		return self._lrange
-
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'NmodeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = NmodeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Per_/LowEnergy_/Le1M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Search/Per/LowEnergy/Le1M.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,71 +1,74 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le1M:
-	"""Le1M commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class Le1MCls:
+	"""Le1M commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le1M", core, parent)
+		self._cmd_group = CommandsGroup("le1M", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Per: float: float Packet error rate Range: 0 % to 100 %, Unit: %
-			- Packets_Received: int: decimal Number of correct packets received and reported by the DUT. Range: 0 to 30E+3"""
+			- Reliability: int: No parameter help available
+			- Per: float: No parameter help available
+			- Packets_Received: int: No parameter help available
+			- Search_Result: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Per'),
-			ArgStruct.scalar_int('Packets_Received')]
+			ArgStruct.scalar_int('Packets_Received'),
+			ArgStruct.scalar_float('Search_Result')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Per: float = None
 			self.Packets_Received: int = None
+			self.Search_Result: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LENergy:LE1M \n
-		Snippet: value: ResultData = driver.dtMode.rxQuality.per.lowEnergy.le1M.read() \n
-		Return all results of the non-signaling LE Rx measurement for LE direct test. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE1M \n
+		Snippet: value: ResultData = driver.dtMode.rxQuality.search.per.lowEnergy.le1M.read() \n
+		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LENergy:LE1M?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE1M?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LENergy:LE1M \n
-		Snippet: value: ResultData = driver.dtMode.rxQuality.per.lowEnergy.le1M.fetch() \n
-		Return all results of the non-signaling LE Rx measurement for LE direct test. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE1M \n
+		Snippet: value: ResultData = driver.dtMode.rxQuality.search.per.lowEnergy.le1M.fetch() \n
+		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LENergy:LE1M?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE1M?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Per: float: float Packet error rate Range: 0 % to 100 %, Unit: %
-			- Packets_Received: float: decimal Number of correct packets received and reported by the DUT. Range: 0 to 30E+3"""
+			- Reliability: int: No parameter help available
+			- Per: float or bool: No parameter help available
+			- Packets_Received: float or bool: No parameter help available
+			- Search_Result: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Per'),
-			ArgStruct.scalar_float('Packets_Received')]
+			ArgStruct.scalar_float_ext('Per'),
+			ArgStruct.scalar_float_ext('Packets_Received'),
+			ArgStruct.scalar_float_ext('Search_Result')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Per: float = None
-			self.Packets_Received: float = None
+			self.Per: float or bool = None
+			self.Packets_Received: float or bool = None
+			self.Search_Result: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LENergy:LE1M \n
-		Snippet: value: CalculateStruct = driver.dtMode.rxQuality.per.lowEnergy.le1M.calculate() \n
-		Return all results of the non-signaling LE Rx measurement for LE direct test. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE1M \n
+		Snippet: value: CalculateStruct = driver.dtMode.rxQuality.search.per.lowEnergy.le1M.calculate() \n
+		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LENergy:LE1M?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE1M?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Per_/LowEnergy_/Le2M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Search/Per/LowEnergy/Le2M.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,71 +1,74 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le2M:
-	"""Le2M commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class Le2MCls:
+	"""Le2M commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le2M", core, parent)
+		self._cmd_group = CommandsGroup("le2M", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Per: float: float Packet error rate Range: 0 % to 100 %, Unit: %
-			- Packets_Received: int: decimal Number of correct packets received and reported by the DUT. Range: 0 to 30E+3"""
+			- Reliability: int: No parameter help available
+			- Per: float: No parameter help available
+			- Packets_Received: int: No parameter help available
+			- Search_Result: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Per'),
-			ArgStruct.scalar_int('Packets_Received')]
+			ArgStruct.scalar_int('Packets_Received'),
+			ArgStruct.scalar_float('Search_Result')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Per: float = None
 			self.Packets_Received: int = None
+			self.Search_Result: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LENergy:LE2M \n
-		Snippet: value: ResultData = driver.dtMode.rxQuality.per.lowEnergy.le2M.read() \n
-		Return all results of the non-signaling LE Rx measurement for LE direct test. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE2M \n
+		Snippet: value: ResultData = driver.dtMode.rxQuality.search.per.lowEnergy.le2M.read() \n
+		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LENergy:LE2M?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE2M?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LENergy:LE2M \n
-		Snippet: value: ResultData = driver.dtMode.rxQuality.per.lowEnergy.le2M.fetch() \n
-		Return all results of the non-signaling LE Rx measurement for LE direct test. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE2M \n
+		Snippet: value: ResultData = driver.dtMode.rxQuality.search.per.lowEnergy.le2M.fetch() \n
+		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LENergy:LE2M?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE2M?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Per: float: float Packet error rate Range: 0 % to 100 %, Unit: %
-			- Packets_Received: float: decimal Number of correct packets received and reported by the DUT. Range: 0 to 30E+3"""
+			- Reliability: int: No parameter help available
+			- Per: float or bool: No parameter help available
+			- Packets_Received: float or bool: No parameter help available
+			- Search_Result: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Per'),
-			ArgStruct.scalar_float('Packets_Received')]
+			ArgStruct.scalar_float_ext('Per'),
+			ArgStruct.scalar_float_ext('Packets_Received'),
+			ArgStruct.scalar_float_ext('Search_Result')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Per: float = None
-			self.Packets_Received: float = None
+			self.Per: float or bool = None
+			self.Packets_Received: float or bool = None
+			self.Search_Result: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LENergy:LE2M \n
-		Snippet: value: CalculateStruct = driver.dtMode.rxQuality.per.lowEnergy.le2M.calculate() \n
-		Return all results of the non-signaling LE Rx measurement for LE direct test. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE2M \n
+		Snippet: value: CalculateStruct = driver.dtMode.rxQuality.search.per.lowEnergy.le2M.calculate() \n
+		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LENergy:LE2M?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE2M?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Per_/LowEnergy_/Lrange.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Search/Per/LowEnergy/Lrange.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,71 +1,74 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Lrange:
-	"""Lrange commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class LrangeCls:
+	"""Lrange commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lrange", core, parent)
+		self._cmd_group = CommandsGroup("lrange", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Per: float: float Packet error rate Range: 0 % to 100 %, Unit: %
-			- Packets_Received: int: decimal Number of correct packets received and reported by the DUT. Range: 0 to 30E+3"""
+			- Reliability: int: No parameter help available
+			- Per: float: No parameter help available
+			- Packets_Received: int: No parameter help available
+			- Search_Result: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Per'),
-			ArgStruct.scalar_int('Packets_Received')]
+			ArgStruct.scalar_int('Packets_Received'),
+			ArgStruct.scalar_float('Search_Result')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Per: float = None
 			self.Packets_Received: int = None
+			self.Search_Result: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LENergy:LRANge \n
-		Snippet: value: ResultData = driver.dtMode.rxQuality.per.lowEnergy.lrange.read() \n
-		Return all results of the non-signaling LE Rx measurement for LE direct test. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LRANge \n
+		Snippet: value: ResultData = driver.dtMode.rxQuality.search.per.lowEnergy.lrange.read() \n
+		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LENergy:LRANge?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LRANge?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LENergy:LRANge \n
-		Snippet: value: ResultData = driver.dtMode.rxQuality.per.lowEnergy.lrange.fetch() \n
-		Return all results of the non-signaling LE Rx measurement for LE direct test. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LRANge \n
+		Snippet: value: ResultData = driver.dtMode.rxQuality.search.per.lowEnergy.lrange.fetch() \n
+		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LENergy:LRANge?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LRANge?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Per: float: float Packet error rate Range: 0 % to 100 %, Unit: %
-			- Packets_Received: float: decimal Number of correct packets received and reported by the DUT. Range: 0 to 30E+3"""
+			- Reliability: int: No parameter help available
+			- Per: float or bool: No parameter help available
+			- Packets_Received: float or bool: No parameter help available
+			- Search_Result: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Per'),
-			ArgStruct.scalar_float('Packets_Received')]
+			ArgStruct.scalar_float_ext('Per'),
+			ArgStruct.scalar_float_ext('Packets_Received'),
+			ArgStruct.scalar_float_ext('Search_Result')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Per: float = None
-			self.Packets_Received: float = None
+			self.Per: float or bool = None
+			self.Packets_Received: float or bool = None
+			self.Search_Result: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LENergy:LRANge \n
-		Snippet: value: CalculateStruct = driver.dtMode.rxQuality.per.lowEnergy.lrange.calculate() \n
-		Return all results of the non-signaling LE Rx measurement for LE direct test. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LRANge \n
+		Snippet: value: CalculateStruct = driver.dtMode.rxQuality.search.per.lowEnergy.lrange.calculate() \n
+		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:LENergy:LRANge?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LRANge?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Per_/State.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le2M/YieldPy.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,23 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from ..... import enums
+from typing import List
+
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class State:
-	"""State commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class YieldPyCls:
+	"""YieldPy commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("state", core, parent)
+		self._cmd_group = CommandsGroup("yieldPy", core, parent)
 
-	# noinspection PyTypeChecker
-	def fetch(self) -> enums.ResourceState:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:STATe \n
-		Snippet: value: enums.ResourceState = driver.dtMode.rxQuality.per.state.fetch() \n
-		Queries the main measurement state. Use FETCh:...:STATe:ALL? to query the measurement state including the substates. Use
-		INITiate..., STOP..., ABORt... to change the measurement state. \n
-			:return: meas_status: OFF | RDY | RUN OFF: measurement switched off, no resources allocated, no results available (when entered after ABORt...) RDY: measurement has been terminated, valid results can be available RUN: measurement running (after INITiate..., READ...) , synchronization pending or adjusted, resources active or queued"""
-		response = self._core.io.query_str(f'FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:PER:STATe?')
-		return Conversions.str_to_scalar_enum(response, enums.ResourceState)
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:YIELd \n
+		Snippet: value: List[float] = driver.multiEval.modulation.lowEnergy.le2M.yieldPy.fetch() \n
+		Returns the percentages of auto-detected LE packets with a particular pattern type. Commands for uncoded LE 1M PHY (..
+		:LE1M..) and LE 2M PHY (..:LE2M..) are available. A result is available after the R&S CMW has auto-detected a packet
+		(method RsCmwBluetoothMeas.Configure.InputSignal.dmodeAUTO) . \n
+		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
+			:return: pattern_yield: float Pattern yield for 11110000 patterns, 10101010 patterns, and any other patterns (3 values) Range: 0 to 100, Unit: %"""
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:YIELd?', suppressed)
+		return response
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Search.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/RxQuality/Search/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Search:
-	"""Search commands group definition. 13 total commands, 1 Sub-groups, 0 group commands"""
+class SearchCls:
+	"""Search commands group definition. 13 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("search", core, parent)
+		self._cmd_group = CommandsGroup("search", core, parent)
 
 	@property
 	def per(self):
 		"""per commands group. 2 Sub-classes, 3 commands."""
 		if not hasattr(self, '_per'):
-			from .Search_.Per import Per
-			self._per = Per(self._core, self._base)
+			from .Per import PerCls
+			self._per = PerCls(self._core, self._cmd_group)
 		return self._per
 
-	def clone(self) -> 'Search':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SearchCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Search(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SearchCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Search_/Per.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,104 +1,104 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Per:
-	"""Per commands group definition. 13 total commands, 2 Sub-groups, 3 group commands"""
+class RxQualityCls:
+	"""RxQuality commands group definition. 10 total commands, 5 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("per", core, parent)
+		self._cmd_group = CommandsGroup("rxQuality", core, parent)
 
 	@property
 	def state(self):
-		"""state commands group. 0 Sub-classes, 1 commands."""
+		"""state commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_state'):
-			from .Per_.State import State
-			self._state = State(self._core, self._base)
+			from .State import StateCls
+			self._state = StateCls(self._core, self._cmd_group)
 		return self._state
 
 	@property
-	def lowEnergy(self):
-		"""lowEnergy commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_lowEnergy'):
-			from .Per_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
-		return self._lowEnergy
-
-	def initiate(self) -> None:
-		"""SCPI: INITiate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER \n
-		Snippet: driver.dtMode.rxQuality.search.per.initiate() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'INITiate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER')
+	def sensitivity(self):
+		"""sensitivity commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_sensitivity'):
+			from .Sensitivity import SensitivityCls
+			self._sensitivity = SensitivityCls(self._core, self._cmd_group)
+		return self._sensitivity
+
+	@property
+	def spotCheck(self):
+		"""spotCheck commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_spotCheck'):
+			from .SpotCheck import SpotCheckCls
+			self._spotCheck = SpotCheckCls(self._core, self._cmd_group)
+		return self._spotCheck
+
+	@property
+	def per(self):
+		"""per commands group. 1 Sub-classes, 1 commands."""
+		if not hasattr(self, '_per'):
+			from .Per import PerCls
+			self._per = PerCls(self._core, self._cmd_group)
+		return self._per
+
+	@property
+	def adetected(self):
+		"""adetected commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_adetected'):
+			from .Adetected import AdetectedCls
+			self._adetected = AdetectedCls(self._core, self._cmd_group)
+		return self._adetected
 
-	def initiate_with_opc(self) -> None:
-		"""SCPI: INITiate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER \n
-		Snippet: driver.dtMode.rxQuality.search.per.initiate_with_opc() \n
+	def initiate(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: INITiate:BLUetooth:MEASurement<Instance>:RXQuality \n
+		Snippet: driver.rxQuality.initiate() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		Same as initiate, but waits for the operation to complete before continuing further. Use the RsCmwBluetoothMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'INITiate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'INITiate:BLUetooth:MEASurement<Instance>:RXQuality', opc_timeout_ms)
 
 	def stop(self) -> None:
-		"""SCPI: STOP:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER \n
-		Snippet: driver.dtMode.rxQuality.search.per.stop() \n
+		"""SCPI: STOP:BLUetooth:MEASurement<Instance>:RXQuality \n
+		Snippet: driver.rxQuality.stop() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
 		"""
-		self._core.io.write(f'STOP:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER')
+		self._core.io.write(f'STOP:BLUetooth:MEASurement<Instance>:RXQuality')
 
-	def stop_with_opc(self) -> None:
-		"""SCPI: STOP:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER \n
-		Snippet: driver.dtMode.rxQuality.search.per.stop_with_opc() \n
+	def stop_with_opc(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: STOP:BLUetooth:MEASurement<Instance>:RXQuality \n
+		Snippet: driver.rxQuality.stop_with_opc() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
 		Same as stop, but waits for the operation to complete before continuing further. Use the RsCmwBluetoothMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'STOP:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'STOP:BLUetooth:MEASurement<Instance>:RXQuality', opc_timeout_ms)
 
-	def abort(self) -> None:
-		"""SCPI: ABORt:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER \n
-		Snippet: driver.dtMode.rxQuality.search.per.abort() \n
+	def abort(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: ABORt:BLUetooth:MEASurement<Instance>:RXQuality \n
+		Snippet: driver.rxQuality.abort() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'ABORt:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER')
-
-	def abort_with_opc(self) -> None:
-		"""SCPI: ABORt:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER \n
-		Snippet: driver.dtMode.rxQuality.search.per.abort_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		Same as abort, but waits for the operation to complete before continuing further. Use the RsCmwBluetoothMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'ABORt:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'ABORt:BLUetooth:MEASurement<Instance>:RXQuality', opc_timeout_ms)
 
-	def clone(self) -> 'Per':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RxQualityCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Per(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RxQualityCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Search_/Per_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/EvMagnitude/Absolute/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,43 +1,43 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 9 total commands, 3 Sub-groups, 0 group commands"""
+class AbsoluteCls:
+	"""Absolute commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("absolute", core, parent)
 
 	@property
-	def le1M(self):
-		"""le1M commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_le1M'):
-			from .LowEnergy_.Le1M import Le1M
-			self._le1M = Le1M(self._core, self._base)
-		return self._le1M
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
 
 	@property
-	def le2M(self):
-		"""le2M commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_le2M'):
-			from .LowEnergy_.Le2M import Le2M
-			self._le2M = Le2M(self._core, self._base)
-		return self._le2M
+	def average(self):
+		"""average commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
 
 	@property
-	def lrange(self):
-		"""lrange commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_lrange'):
-			from .LowEnergy_.Lrange import Lrange
-			self._lrange = Lrange(self._core, self._base)
-		return self._lrange
+	def current(self):
+		"""current commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
 
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AbsoluteCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AbsoluteCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Search_/Per_/LowEnergy_/Le1M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Xmaximum/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,77 +1,76 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le1M:
-	"""Le1M commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XmaximumCls:
+	"""Xmaximum commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le1M", core, parent)
+		self._cmd_group = CommandsGroup("xmaximum", core, parent)
 
-	# noinspection PyTypeChecker
-	class ResultData(StructBase):
-		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Per: float: float Packet error rate Range: 0 % to 100 %, Unit: %
-			- Packets_Received: int: decimal Number of correct packets received and reported by the DUT Range: 0 to 30E+3
-			- Search_Result: float: float TX level of the R&S CMW resulting in the configured PER search limit Range: -999 dBm to 0 dBm, Unit: dBm"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Per'),
-			ArgStruct.scalar_int('Packets_Received'),
-			ArgStruct.scalar_float('Search_Result')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Per: float = None
-			self.Packets_Received: int = None
-			self.Search_Result: float = None
-
-	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE1M \n
-		Snippet: value: ResultData = driver.dtMode.rxQuality.search.per.lowEnergy.le1M.read() \n
-		Return the results of PER search RX measurement for LE direct test mode. Commands for uncoded LE 1M PHY (..:LE1M..) , LE
-		2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE1M?', self.__class__.ResultData())
-
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE1M \n
-		Snippet: value: ResultData = driver.dtMode.rxQuality.search.per.lowEnergy.le1M.fetch() \n
-		Return the results of PER search RX measurement for LE direct test mode. Commands for uncoded LE 1M PHY (..:LE1M..) , LE
-		2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE1M?', self.__class__.ResultData())
+	@property
+	def extended(self):
+		"""extended commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_extended'):
+			from .Extended import ExtendedCls
+			self._extended = ExtendedCls(self._core, self._cmd_group)
+		return self._extended
 
 	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
+	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Per: float: float Packet error rate Range: 0 % to 100 %, Unit: %
-			- Packets_Received: float: decimal Number of correct packets received and reported by the DUT Range: 0 to 30E+3
-			- Search_Result: float: float TX level of the R&S CMW resulting in the configured PER search limit Range: -999 dBm to 0 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment. The meaning of the returned values is the same as for the common reliability indicator, see previous parameter.
+			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 % , Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Freq_Acc_Or_Init_Freq_Error: float: float Frequency accuracy (BR, LE) or initial center frequency error ωi (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float: float Frequency drift (BR, LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift_Rate: float: float Maximal drift rate (BR, LE) Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Offset: float: float Frequency offset (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Initial_Freq_Drift: float: float Initial frequency drift (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Per'),
-			ArgStruct.scalar_float('Packets_Received'),
-			ArgStruct.scalar_float('Search_Result')]
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_float('Out_Of_Tol'),
+			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float('Freq_Acc_Or_Init_Freq_Error'),
+			ArgStruct.scalar_float('Freq_Drift'),
+			ArgStruct.scalar_float('Max_Drift_Rate'),
+			ArgStruct.scalar_float('Freq_Offset'),
+			ArgStruct.scalar_float('Initial_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Per: float = None
-			self.Packets_Received: float = None
-			self.Search_Result: float = None
-
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurment<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE1M \n
-		Snippet: value: CalculateStruct = driver.dtMode.rxQuality.search.per.lowEnergy.le1M.calculate() \n
-		Return the results of PER search RX measurement for LE direct test mode. Commands for uncoded LE 1M PHY (..:LE1M..) , LE
-		2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurment<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE1M?', self.__class__.CalculateStruct())
+			self.Seg_Reliability: int = None
+			self.Out_Of_Tol: float = None
+			self.Nominal_Power: float = None
+			self.Freq_Acc_Or_Init_Freq_Error: float = None
+			self.Freq_Drift: float = None
+			self.Max_Drift_Rate: float = None
+			self.Freq_Offset: float = None
+			self.Initial_Freq_Drift: float = None
+
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:XMAXimum \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.xmaximum.fetch(segment = repcap.Segment.Default) \n
+		Returns modulation single extreme minimum and maximum (xmin, xmax) value results for segment<no> in list mode.
+		The command returns all parameters listed below, independent of the selected list mode setup. However, only for some of
+		the parameters measured values are available. For the other parameters, only an indicator is returned (e.g. NAV) . \n
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+			:return: structure: for return value, see the help for FetchStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:XMAXimum?', self.__class__.FetchStruct())
+
+	def clone(self) -> 'XmaximumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = XmaximumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Search_/Per_/LowEnergy_/Le2M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/PowerVsTime/Average.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,77 +1,66 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le2M:
-	"""Le2M commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le2M", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
-	class ResultData(StructBase):
+	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Per: float: float Packet error rate Range: 0 % to 100 %, Unit: %
-			- Packets_Received: int: decimal Number of correct packets received and reported by the DUT Range: 0 to 30E+3
-			- Search_Result: float: float TX level of the R&S CMW resulting in the configured PER search limit Range: -999 dBm to 0 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment. The meaning of the returned values is the same as for the common reliability indicator, see previous parameter.
+			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Power: float: float Peak power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Leakage_Power: float: float Leakage power (BR, LE) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Gfsk_Power: float: float Average power within the GFSK modulated part of the burst (EDR) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Dpsk_Power: float: float Average power within the DPSK modulated part of the burst (EDR) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Dpsk_Minus_Gfsk: float: float Difference between the 8_DPSKPower and 7_GFSKPower (EDR) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Guard_Period: float: float Length of the guard band between the packet header and the EDR synchronization sequence (EDR) Range: 0 µs to 9.99 µs, Unit: s
+			- Peak_Minus_Avg: float: float Difference between the peak power and the average power in the burst (LE) Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Per'),
-			ArgStruct.scalar_int('Packets_Received'),
-			ArgStruct.scalar_float('Search_Result')]
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_float('Out_Of_Tol'),
+			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float('Peak_Power'),
+			ArgStruct.scalar_float('Leakage_Power'),
+			ArgStruct.scalar_float('Gfsk_Power'),
+			ArgStruct.scalar_float('Dpsk_Power'),
+			ArgStruct.scalar_float('Dpsk_Minus_Gfsk'),
+			ArgStruct.scalar_float('Guard_Period'),
+			ArgStruct.scalar_float('Peak_Minus_Avg')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Per: float = None
-			self.Packets_Received: int = None
-			self.Search_Result: float = None
-
-	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE2M \n
-		Snippet: value: ResultData = driver.dtMode.rxQuality.search.per.lowEnergy.le2M.read() \n
-		Return the results of PER search RX measurement for LE direct test mode. Commands for uncoded LE 1M PHY (..:LE1M..) , LE
-		2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE2M?', self.__class__.ResultData())
-
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE2M \n
-		Snippet: value: ResultData = driver.dtMode.rxQuality.search.per.lowEnergy.le2M.fetch() \n
-		Return the results of PER search RX measurement for LE direct test mode. Commands for uncoded LE 1M PHY (..:LE1M..) , LE
-		2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE2M?', self.__class__.ResultData())
-
-	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
-		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Per: float: float Packet error rate Range: 0 % to 100 %, Unit: %
-			- Packets_Received: float: decimal Number of correct packets received and reported by the DUT Range: 0 to 30E+3
-			- Search_Result: float: float TX level of the R&S CMW resulting in the configured PER search limit Range: -999 dBm to 0 dBm, Unit: dBm"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Per'),
-			ArgStruct.scalar_float('Packets_Received'),
-			ArgStruct.scalar_float('Search_Result')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Per: float = None
-			self.Packets_Received: float = None
-			self.Search_Result: float = None
-
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE2M \n
-		Snippet: value: CalculateStruct = driver.dtMode.rxQuality.search.per.lowEnergy.le2M.calculate() \n
-		Return the results of PER search RX measurement for LE direct test mode. Commands for uncoded LE 1M PHY (..:LE1M..) , LE
-		2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LE2M?', self.__class__.CalculateStruct())
+			self.Seg_Reliability: int = None
+			self.Out_Of_Tol: float = None
+			self.Nominal_Power: float = None
+			self.Peak_Power: float = None
+			self.Leakage_Power: float = None
+			self.Gfsk_Power: float = None
+			self.Dpsk_Power: float = None
+			self.Dpsk_Minus_Gfsk: float = None
+			self.Guard_Period: float = None
+			self.Peak_Minus_Avg: float = None
+
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PVTime:AVERage \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.powerVsTime.average.fetch(segment = repcap.Segment.Default) \n
+		Returns statistical power vs time single value results for segment<no> in list mode. The command returns all parameters
+		listed below, independent of the selected list mode setup. However, only for some of the parameters measured values are
+		available. For the other parameters, only an indicator is returned (e.g. NAV) . \n
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+			:return: structure: for return value, see the help for FetchStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PVTime:AVERage?', self.__class__.FetchStruct())
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Search_/Per_/LowEnergy_/Lrange.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/PowerVsTime/Minimum.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,77 +1,66 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Lrange:
-	"""Lrange commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lrange", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
-	class ResultData(StructBase):
+	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Per: float: float Packet error rate Range: 0 % to 100 %, Unit: %
-			- Packets_Received: int: decimal Number of correct packets received and reported by the DUT Range: 0 to 30E+3
-			- Search_Result: float: float TX level of the R&S CMW resulting in the configured PER search limit Range: -999 dBm to 0 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment. The meaning of the returned values is the same as for the common reliability indicator, see previous parameter.
+			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Power: float: float Peak power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Leakage_Power: float: float Leakage power (BR, LE) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Gfsk_Power: float: float Average power within the GFSK modulated part of the burst (EDR) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Dpsk_Power: float: float Average power within the DPSK modulated part of the burst (EDR) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Dpsk_Minus_Gfsk: float: float Difference between the 8_DPSKPower and 7_GFSKPower (EDR) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Guard_Period: float: float Length of the guard band between the packet header and the EDR synchronization sequence (EDR) Range: 0 µs to 9.99 µs, Unit: s
+			- Peak_Minus_Avg: float: float Difference between the peak power and the average power in the burst (LE) Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Per'),
-			ArgStruct.scalar_int('Packets_Received'),
-			ArgStruct.scalar_float('Search_Result')]
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_float('Out_Of_Tol'),
+			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float('Peak_Power'),
+			ArgStruct.scalar_float('Leakage_Power'),
+			ArgStruct.scalar_float('Gfsk_Power'),
+			ArgStruct.scalar_float('Dpsk_Power'),
+			ArgStruct.scalar_float('Dpsk_Minus_Gfsk'),
+			ArgStruct.scalar_float('Guard_Period'),
+			ArgStruct.scalar_float('Peak_Minus_Avg')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Per: float = None
-			self.Packets_Received: int = None
-			self.Search_Result: float = None
-
-	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LRANge \n
-		Snippet: value: ResultData = driver.dtMode.rxQuality.search.per.lowEnergy.lrange.read() \n
-		Return the results of PER search RX measurement for LE direct test mode. Commands for uncoded LE 1M PHY (..:LE1M..) , LE
-		2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LRANge?', self.__class__.ResultData())
-
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LRANge \n
-		Snippet: value: ResultData = driver.dtMode.rxQuality.search.per.lowEnergy.lrange.fetch() \n
-		Return the results of PER search RX measurement for LE direct test mode. Commands for uncoded LE 1M PHY (..:LE1M..) , LE
-		2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LRANge?', self.__class__.ResultData())
-
-	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
-		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Per: float: float Packet error rate Range: 0 % to 100 %, Unit: %
-			- Packets_Received: float: decimal Number of correct packets received and reported by the DUT Range: 0 to 30E+3
-			- Search_Result: float: float TX level of the R&S CMW resulting in the configured PER search limit Range: -999 dBm to 0 dBm, Unit: dBm"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Per'),
-			ArgStruct.scalar_float('Packets_Received'),
-			ArgStruct.scalar_float('Search_Result')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Per: float = None
-			self.Packets_Received: float = None
-			self.Search_Result: float = None
-
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LRANge \n
-		Snippet: value: CalculateStruct = driver.dtMode.rxQuality.search.per.lowEnergy.lrange.calculate() \n
-		Return the results of PER search RX measurement for LE direct test mode. Commands for uncoded LE 1M PHY (..:LE1M..) , LE
-		2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:LENergy:LRANge?', self.__class__.CalculateStruct())
+			self.Seg_Reliability: int = None
+			self.Out_Of_Tol: float = None
+			self.Nominal_Power: float = None
+			self.Peak_Power: float = None
+			self.Leakage_Power: float = None
+			self.Gfsk_Power: float = None
+			self.Dpsk_Power: float = None
+			self.Dpsk_Minus_Gfsk: float = None
+			self.Guard_Period: float = None
+			self.Peak_Minus_Avg: float = None
+
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PVTime:MINimum \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.powerVsTime.minimum.fetch(segment = repcap.Segment.Default) \n
+		Returns statistical power vs time single value results for segment<no> in list mode. The command returns all parameters
+		listed below, independent of the selected list mode setup. However, only for some of the parameters measured values are
+		available. For the other parameters, only an indicator is returned (e.g. NAV) . \n
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+			:return: structure: for return value, see the help for FetchStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PVTime:MINimum?', self.__class__.FetchStruct())
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/DtMode_/RxQuality_/Search_/Per_/State.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/Sacp/Maximum.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,23 +1,35 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal import Conversions
-from ...... import enums
+from typing import List
+
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class State:
-	"""State commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("state", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
+
+	def read(self) -> List[float]:
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:HDRP:TRACe:SACP:MAXimum \n
+		Snippet: value: List[float] = driver.hdrp.trace.sacp.maximum.read() \n
+		No command help available \n
+		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
+			:return: sacp_trace: No help available"""
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:HDRP:TRACe:SACP:MAXimum?', suppressed)
+		return response
 
-	# noinspection PyTypeChecker
-	def fetch(self) -> enums.ResourceState:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:STATe \n
-		Snippet: value: enums.ResourceState = driver.dtMode.rxQuality.search.per.state.fetch() \n
-		Queries the main measurement state. Use FETCh:...:STATe:ALL? to query the measurement state including the substates. Use
-		INITiate..., STOP..., ABORt... to change the measurement state. \n
-			:return: meas_status: OFF | RDY | RUN OFF: measurement switched off, no resources allocated, no results available (when entered after ABORt...) RDY: measurement has been terminated, valid results can be available RUN: measurement running (after INITiate..., READ...) , synchronization pending or adjusted, resources active or queued"""
-		response = self._core.io.query_str(f'FETCh:BLUetooth:MEASurement<Instance>:DTMode:RXQuality:SEARch:PER:STATe?')
-		return Conversions.str_to_scalar_enum(response, enums.ResourceState)
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:HDRP:TRACe:SACP:MAXimum \n
+		Snippet: value: List[float] = driver.hdrp.trace.sacp.maximum.fetch() \n
+		No command help available \n
+		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
+			:return: sacp_trace: No help available"""
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:HDRP:TRACe:SACP:MAXimum?', suppressed)
+		return response
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/InputSignal/Adetected/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,27 +1,35 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class InputSignal:
-	"""InputSignal commands group definition. 23 total commands, 1 Sub-groups, 0 group commands"""
+class AdetectedCls:
+	"""Adetected commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("inputSignal", core, parent)
+		self._cmd_group = CommandsGroup("adetected", core, parent)
 
 	@property
-	def adetected(self):
-		"""adetected commands group. 8 Sub-classes, 0 commands."""
-		if not hasattr(self, '_adetected'):
-			from .InputSignal_.Adetected import Adetected
-			self._adetected = Adetected(self._core, self._base)
-		return self._adetected
+	def plength(self):
+		"""plength commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_plength'):
+			from .Plength import PlengthCls
+			self._plength = PlengthCls(self._core, self._cmd_group)
+		return self._plength
 
-	def clone(self) -> 'InputSignal':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def pcoding(self):
+		"""pcoding commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_pcoding'):
+			from .Pcoding import PcodingCls
+			self._pcoding = PcodingCls(self._core, self._cmd_group)
+		return self._pcoding
+
+	def clone(self) -> 'AdetectedCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = InputSignal(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AdetectedCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,83 +1,91 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Adetected:
-	"""Adetected commands group definition. 23 total commands, 8 Sub-groups, 0 group commands"""
+class AdetectedCls:
+	"""Adetected commands group definition. 39 total commands, 9 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("adetected", core, parent)
+		self._cmd_group = CommandsGroup("adetected", core, parent)
+
+	@property
+	def qhsl(self):
+		"""qhsl commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_qhsl'):
+			from .Qhsl import QhslCls
+			self._qhsl = QhslCls(self._core, self._cmd_group)
+		return self._qhsl
+
+	@property
+	def plength(self):
+		"""plength commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_plength'):
+			from .Plength import PlengthCls
+			self._plength = PlengthCls(self._core, self._cmd_group)
+		return self._plength
 
 	@property
 	def cte(self):
-		"""cte commands group. 1 Sub-classes, 0 commands."""
+		"""cte commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_cte'):
-			from .Adetected_.Cte import Cte
-			self._cte = Cte(self._core, self._base)
+			from .Cte import CteCls
+			self._cte = CteCls(self._core, self._cmd_group)
 		return self._cte
 
 	@property
 	def coding(self):
 		"""coding commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_coding'):
-			from .Adetected_.Coding import Coding
-			self._coding = Coding(self._core, self._base)
+			from .Coding import CodingCls
+			self._coding = CodingCls(self._core, self._cmd_group)
 		return self._coding
 
 	@property
-	def plength(self):
-		"""plength commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_plength'):
-			from .Adetected_.Plength import Plength
-			self._plength = Plength(self._core, self._base)
-		return self._plength
-
-	@property
 	def ptype(self):
 		"""ptype commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_ptype'):
-			from .Adetected_.Ptype import Ptype
-			self._ptype = Ptype(self._core, self._base)
+			from .Ptype import PtypeCls
+			self._ptype = PtypeCls(self._core, self._cmd_group)
 		return self._ptype
 
 	@property
 	def pattern(self):
 		"""pattern commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_pattern'):
-			from .Adetected_.Pattern import Pattern
-			self._pattern = Pattern(self._core, self._base)
+			from .Pattern import PatternCls
+			self._pattern = PatternCls(self._core, self._cmd_group)
 		return self._pattern
 
 	@property
 	def aaddress(self):
 		"""aaddress commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_aaddress'):
-			from .Adetected_.Aaddress import Aaddress
-			self._aaddress = Aaddress(self._core, self._base)
+			from .Aaddress import AaddressCls
+			self._aaddress = AaddressCls(self._core, self._cmd_group)
 		return self._aaddress
 
 	@property
 	def pduType(self):
 		"""pduType commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_pduType'):
-			from .Adetected_.PduType import PduType
-			self._pduType = PduType(self._core, self._base)
+			from .PduType import PduTypeCls
+			self._pduType = PduTypeCls(self._core, self._cmd_group)
 		return self._pduType
 
 	@property
 	def noSlots(self):
 		"""noSlots commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_noSlots'):
-			from .Adetected_.NoSlots import NoSlots
-			self._noSlots = NoSlots(self._core, self._base)
+			from .NoSlots import NoSlotsCls
+			self._noSlots = NoSlotsCls(self._core, self._cmd_group)
 		return self._noSlots
 
-	def clone(self) -> 'Adetected':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AdetectedCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Adetected(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AdetectedCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Aaddress.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/Adetected/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Aaddress:
-	"""Aaddress commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class AdetectedCls:
+	"""Adetected commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("aaddress", core, parent)
+		self._cmd_group = CommandsGroup("adetected", core, parent)
 
 	@property
-	def lowEnergy(self):
-		"""lowEnergy commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_lowEnergy'):
-			from .Aaddress_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
-		return self._lowEnergy
+	def aaddress(self):
+		"""aaddress commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_aaddress'):
+			from .Aaddress import AaddressCls
+			self._aaddress = AaddressCls(self._core, self._cmd_group)
+		return self._aaddress
 
-	def clone(self) -> 'Aaddress':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AdetectedCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Aaddress(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AdetectedCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Aaddress_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Aaddress/LowEnergy/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class LowEnergyCls:
+	"""LowEnergy commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("lowEnergy", core, parent)
 
 	@property
 	def le1M(self):
 		"""le1M commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_le1M'):
-			from .LowEnergy_.Le1M import Le1M
-			self._le1M = Le1M(self._core, self._base)
+			from .Le1M import Le1MCls
+			self._le1M = Le1MCls(self._core, self._cmd_group)
 		return self._le1M
 
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LowEnergyCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LowEnergyCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Aaddress_/LowEnergy_/Le1M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Aaddress/LowEnergy/Le1M.py`

 * *Files 15% similar despite different names*

```diff
@@ -2,20 +2,20 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ......Internal.Utilities import trim_str_response
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le1M:
-	"""Le1M commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class Le1MCls:
+	"""Le1M commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le1M", core, parent)
+		self._cmd_group = CommandsGroup("le1M", core, parent)
 
 	def fetch(self) -> str:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:AADDress:LENergy[:LE1M] \n
 		Snippet: value: str = driver.inputSignal.adetected.aaddress.lowEnergy.le1M.fetch() \n
 		Returns the detected access address of advertiser for LE 1M PHY. A result is available after the R&S CMW has
 		auto-detected a packet (method RsCmwBluetoothMeas.Configure.InputSignal.dmode AUTO) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Coding.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Coding/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Coding:
-	"""Coding commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class CodingCls:
+	"""Coding commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("coding", core, parent)
+		self._cmd_group = CommandsGroup("coding", core, parent)
 
 	@property
 	def lowEnergy(self):
 		"""lowEnergy commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_lowEnergy'):
-			from .Coding_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
 		return self._lowEnergy
 
-	def clone(self) -> 'Coding':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CodingCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Coding(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CodingCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Coding_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Coding/LowEnergy/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class LowEnergyCls:
+	"""LowEnergy commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("lowEnergy", core, parent)
 
 	@property
 	def lrange(self):
 		"""lrange commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_lrange'):
-			from .LowEnergy_.Lrange import Lrange
-			self._lrange = Lrange(self._core, self._base)
+			from .Lrange import LrangeCls
+			self._lrange = LrangeCls(self._core, self._cmd_group)
 		return self._lrange
 
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LowEnergyCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LowEnergyCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Coding_/LowEnergy_/Lrange.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Coding/LowEnergy/Lrange.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Lrange:
-	"""Lrange commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class LrangeCls:
+	"""Lrange commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lrange", core, parent)
+		self._cmd_group = CommandsGroup("lrange", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> enums.CodingScheme:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:CODing:LENergy:LRANge \n
 		Snippet: value: enums.CodingScheme = driver.inputSignal.adetected.coding.lowEnergy.lrange.fetch() \n
 		Returns the detected forward error correction coding for LE coded PHY. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/PduType/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cte:
-	"""Cte commands group definition. 4 total commands, 1 Sub-groups, 0 group commands"""
+class PduTypeCls:
+	"""PduType commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cte", core, parent)
+		self._cmd_group = CommandsGroup("pduType", core, parent)
 
 	@property
 	def lowEnergy(self):
-		"""lowEnergy commands group. 2 Sub-classes, 0 commands."""
+		"""lowEnergy commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_lowEnergy'):
-			from .Cte_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
 		return self._lowEnergy
 
-	def clone(self) -> 'Cte':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PduTypeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cte(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PduTypeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup/Cte/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class CteCls:
+	"""Cte commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("cte", core, parent)
 
 	@property
-	def le1M(self):
-		"""le1M commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_le1M'):
-			from .LowEnergy_.Le1M import Le1M
-			self._le1M = Le1M(self._core, self._base)
-		return self._le1M
+	def typePy(self):
+		"""typePy commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_typePy'):
+			from .TypePy import TypePyCls
+			self._typePy = TypePyCls(self._core, self._cmd_group)
+		return self._typePy
 
 	@property
-	def le2M(self):
-		"""le2M commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_le2M'):
-			from .LowEnergy_.Le2M import Le2M
-			self._le2M = Le2M(self._core, self._base)
-		return self._le2M
+	def units(self):
+		"""units commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_units'):
+			from .Units import UnitsCls
+			self._units = UnitsCls(self._core, self._cmd_group)
+		return self._units
 
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CteCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CteCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/LowEnergy_/Le1M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P6Q/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le1M:
-	"""Le1M commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class P6QCls:
+	"""P6Q commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le1M", core, parent)
-
-	@property
-	def typePy(self):
-		"""typePy commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_typePy'):
-			from .Le1M_.TypePy import TypePy
-			self._typePy = TypePy(self._core, self._base)
-		return self._typePy
+		self._cmd_group = CommandsGroup("p6Q", core, parent)
 
 	@property
 	def units(self):
 		"""units commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_units'):
-			from .Le1M_.Units import Units
-			self._units = Units(self._core, self._base)
+			from .Units import UnitsCls
+			self._units = UnitsCls(self._core, self._cmd_group)
 		return self._units
 
-	def clone(self) -> 'Le1M':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def typePy(self):
+		"""typePy commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_typePy'):
+			from .TypePy import TypePyCls
+			self._typePy = TypePyCls(self._core, self._cmd_group)
+		return self._typePy
+
+	def clone(self) -> 'P6QCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Le1M(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = P6QCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/LowEnergy_/Le1M_/TypePy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/LowEnergy/Le1M/TypePy.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from .......Internal import Conversions
 from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .......Internal.Types import DataType
 from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class TypePy:
-	"""TypePy commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class TypePyCls:
+	"""TypePy commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("typePy", core, parent)
+		self._cmd_group = CommandsGroup("typePy", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> enums.CtePacketType:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:CTE:LENergy:LE1M:TYPE \n
 		Snippet: value: enums.CtePacketType = driver.inputSignal.adetected.cte.lowEnergy.le1M.typePy.fetch() \n
 		Returns the detected CTE type. A result is available after the R&S CMW has auto-detected a packet (method
 		RsCmwBluetoothMeas.Configure.InputSignal.dmodeAUTO) . Commands for uncoded LE 1M PHY (..:LE1M..) and LE 2M PHY (..:LE2M..
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/LowEnergy_/Le1M_/Units.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/LowEnergy/Le1M/Units.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,20 +2,20 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Units:
-	"""Units commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class UnitsCls:
+	"""Units commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("units", core, parent)
+		self._cmd_group = CommandsGroup("units", core, parent)
 
 	def fetch(self) -> int:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:CTE:LENergy:LE1M:UNITs \n
 		Snippet: value: int = driver.inputSignal.adetected.cte.lowEnergy.le1M.units.fetch() \n
 		Returns the detected number of CTE units. A result is available after the R&S CMW has auto-detected a packet (method
 		RsCmwBluetoothMeas.Configure.InputSignal.dmode AUTO) . Commands for uncoded LE 1M PHY (..:LE1M..) and LE 2M PHY (..:LE2M..
 		) are available. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/LowEnergy_/Le2M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Frange/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le2M:
-	"""Le2M commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class FrangeCls:
+	"""Frange commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le2M", core, parent)
+		self._cmd_group = CommandsGroup("frange", core, parent)
 
 	@property
-	def typePy(self):
-		"""typePy commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_typePy'):
-			from .Le2M_.TypePy import TypePy
-			self._typePy = TypePy(self._core, self._base)
-		return self._typePy
+	def brate(self):
+		"""brate commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_brate'):
+			from .Brate import BrateCls
+			self._brate = BrateCls(self._core, self._cmd_group)
+		return self._brate
 
-	@property
-	def units(self):
-		"""units commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_units'):
-			from .Le2M_.Units import Units
-			self._units = Units(self._core, self._base)
-		return self._units
-
-	def clone(self) -> 'Le2M':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'FrangeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Le2M(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = FrangeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/LowEnergy_/Le2M_/TypePy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/LowEnergy/Le2M/TypePy.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from .......Internal import Conversions
 from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .......Internal.Types import DataType
 from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class TypePy:
-	"""TypePy commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class TypePyCls:
+	"""TypePy commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("typePy", core, parent)
+		self._cmd_group = CommandsGroup("typePy", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> enums.CtePacketType:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:CTE:LENergy:LE2M:TYPE \n
 		Snippet: value: enums.CtePacketType = driver.inputSignal.adetected.cte.lowEnergy.le2M.typePy.fetch() \n
 		Returns the detected CTE type. A result is available after the R&S CMW has auto-detected a packet (method
 		RsCmwBluetoothMeas.Configure.InputSignal.dmodeAUTO) . Commands for uncoded LE 1M PHY (..:LE1M..) and LE 2M PHY (..:LE2M..
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Cte_/LowEnergy_/Le2M_/Units.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/LowEnergy/Le2M/Units.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,20 +2,20 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Units:
-	"""Units commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class UnitsCls:
+	"""Units commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("units", core, parent)
+		self._cmd_group = CommandsGroup("units", core, parent)
 
 	def fetch(self) -> int:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:CTE:LENergy:LE2M:UNITs \n
 		Snippet: value: int = driver.inputSignal.adetected.cte.lowEnergy.le2M.units.fetch() \n
 		Returns the detected number of CTE units. A result is available after the R&S CMW has auto-detected a packet (method
 		RsCmwBluetoothMeas.Configure.InputSignal.dmode AUTO) . Commands for uncoded LE 1M PHY (..:LE1M..) and LE 2M PHY (..:LE2M..
 		) are available. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/NoSlots.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/NoSlots/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class NoSlots:
-	"""NoSlots commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class NoSlotsCls:
+	"""NoSlots commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("noSlots", core, parent)
+		self._cmd_group = CommandsGroup("noSlots", core, parent)
 
 	@property
 	def edrate(self):
 		"""edrate commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_edrate'):
-			from .NoSlots_.Edrate import Edrate
-			self._edrate = Edrate(self._core, self._base)
+			from .Edrate import EdrateCls
+			self._edrate = EdrateCls(self._core, self._cmd_group)
 		return self._edrate
 
 	@property
 	def brate(self):
 		"""brate commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_brate'):
-			from .NoSlots_.Brate import Brate
-			self._brate = Brate(self._core, self._base)
+			from .Brate import BrateCls
+			self._brate = BrateCls(self._core, self._cmd_group)
 		return self._brate
 
-	def clone(self) -> 'NoSlots':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'NoSlotsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = NoSlots(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = NoSlotsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/NoSlots_/Brate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/NoSlots/Edrate.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,24 +2,24 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Brate:
-	"""Brate commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class EdrateCls:
+	"""Edrate commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("brate", core, parent)
+		self._cmd_group = CommandsGroup("edrate", core, parent)
 
 	def fetch(self) -> int:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:NOSLots:BRATe \n
-		Snippet: value: int = driver.inputSignal.adetected.noSlots.brate.fetch() \n
-		Returns the detected BR number of off slots. A result is available after the R&S CMW has auto-detected a packet (method
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:NOSLots:EDRate \n
+		Snippet: value: int = driver.inputSignal.adetected.noSlots.edrate.fetch() \n
+		Returns the detected EDR number of off slots. A result is available after the R&S CMW has auto-detected a packet (method
 		RsCmwBluetoothMeas.Configure.InputSignal.dmode AUTO) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
 			:return: no_of_off_slots: decimal Range: 0 to 9"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:NOSLots:BRATe?', suppressed)
+		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:NOSLots:EDRate?', suppressed)
 		return Conversions.str_to_int(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/NoSlots_/Edrate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/Edrate.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,24 +2,24 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Edrate:
-	"""Edrate commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class EdrateCls:
+	"""Edrate commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("edrate", core, parent)
+		self._cmd_group = CommandsGroup("edrate", core, parent)
 
 	def fetch(self) -> int:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:NOSLots:EDRate \n
-		Snippet: value: int = driver.inputSignal.adetected.noSlots.edrate.fetch() \n
-		Returns the detected EDR number of off slots. A result is available after the R&S CMW has auto-detected a packet (method
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PLENgth:EDRate \n
+		Snippet: value: int = driver.inputSignal.adetected.plength.edrate.fetch() \n
+		Returns the detected EDR payload length. A result is available after the R&S CMW has auto-detected a packet (method
 		RsCmwBluetoothMeas.Configure.InputSignal.dmode AUTO) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: no_of_off_slots: decimal Range: 0 to 9"""
+			:return: payload_length: decimal Range: 0 Byte(s) to 1021 Byte(s)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:NOSLots:EDRate?', suppressed)
+		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PLENgth:EDRate?', suppressed)
 		return Conversions.str_to_int(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Pattern.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Pattern/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pattern:
-	"""Pattern commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class PatternCls:
+	"""Pattern commands group definition. 4 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pattern", core, parent)
+		self._cmd_group = CommandsGroup("pattern", core, parent)
 
 	@property
 	def lowEnergy(self):
 		"""lowEnergy commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_lowEnergy'):
-			from .Pattern_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
 		return self._lowEnergy
 
 	@property
 	def brate(self):
 		"""brate commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_brate'):
-			from .Pattern_.Brate import Brate
-			self._brate = Brate(self._core, self._base)
+			from .Brate import BrateCls
+			self._brate = BrateCls(self._core, self._cmd_group)
 		return self._brate
 
-	def clone(self) -> 'Pattern':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PatternCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pattern(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PatternCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Pattern_/Brate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Pattern/LowEnergy/Le1M.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,27 +1,28 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
-from ..... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Brate:
-	"""Brate commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class Le1MCls:
+	"""Le1M commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("brate", core, parent)
+		self._cmd_group = CommandsGroup("le1M", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> enums.DetectedPatternType:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PATTern[:BRATe] \n
-		Snippet: value: enums.DetectedPatternType = driver.inputSignal.adetected.pattern.brate.fetch() \n
-		Returns the detected payload pattern type. A result is available after the R&S CMW has auto-detected a packet (method
-		RsCmwBluetoothMeas.Configure.InputSignal.dmode AUTO) . \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PATTern:LENergy[:LE1M] \n
+		Snippet: value: enums.DetectedPatternType = driver.inputSignal.adetected.pattern.lowEnergy.le1M.fetch() \n
+		Returns the detected payload pattern type. Commands for LE 1M PHY (...:LE1M...) and LE 2M PHY (...:LE2M...) are available.
+		A result is available after the R&S CMW has auto-detected a packet (method RsCmwBluetoothMeas.Configure.InputSignal.dmode
+		AUTO) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
 			:return: pattern_type: P44 | P11 | OTHer | ALTernating P11: 10101010 P44: 11110000 OTHer: any pattern except P11, P44 ALTernating: the periodical change of the pattern P11 and P44"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PATTern:BRATe?', suppressed)
+		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PATTern:LENergy:LE1M?', suppressed)
 		return Conversions.str_to_scalar_enum(response, enums.DetectedPatternType)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Pattern_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/PowerVsTime/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,43 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 3 total commands, 3 Sub-groups, 0 group commands"""
+class PowerVsTimeCls:
+	"""PowerVsTime commands group definition. 12 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("powerVsTime", core, parent)
 
 	@property
-	def lrange(self):
-		"""lrange commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_lrange'):
-			from .LowEnergy_.Lrange import Lrange
-			self._lrange = Lrange(self._core, self._base)
-		return self._lrange
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
 
 	@property
-	def le2M(self):
-		"""le2M commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_le2M'):
-			from .LowEnergy_.Le2M import Le2M
-			self._le2M = Le2M(self._core, self._base)
-		return self._le2M
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
 
 	@property
-	def le1M(self):
-		"""le1M commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_le1M'):
-			from .LowEnergy_.Le1M import Le1M
-			self._le1M = Le1M(self._core, self._base)
-		return self._le1M
+	def average(self):
+		"""average commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
 
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def current(self):
+		"""current commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
+
+	def clone(self) -> 'PowerVsTimeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PowerVsTimeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Pattern_/LowEnergy_/Le1M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Pattern/LowEnergy/Le2M.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,26 +3,26 @@
 from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le1M:
-	"""Le1M commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class Le2MCls:
+	"""Le2M commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le1M", core, parent)
+		self._cmd_group = CommandsGroup("le2M", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> enums.DetectedPatternType:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PATTern:LENergy[:LE1M] \n
-		Snippet: value: enums.DetectedPatternType = driver.inputSignal.adetected.pattern.lowEnergy.le1M.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PATTern:LENergy:LE2M \n
+		Snippet: value: enums.DetectedPatternType = driver.inputSignal.adetected.pattern.lowEnergy.le2M.fetch() \n
 		Returns the detected payload pattern type. Commands for LE 1M PHY (...:LE1M...) and LE 2M PHY (...:LE2M...) are available.
 		A result is available after the R&S CMW has auto-detected a packet (method RsCmwBluetoothMeas.Configure.InputSignal.dmode
 		AUTO) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
 			:return: pattern_type: P44 | P11 | OTHer | ALTernating P11: 10101010 P44: 11110000 OTHer: any pattern except P11, P44 ALTernating: the periodical change of the pattern P11 and P44"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PATTern:LENergy:LE1M?', suppressed)
+		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PATTern:LENergy:LE2M?', suppressed)
 		return Conversions.str_to_scalar_enum(response, enums.DetectedPatternType)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Pattern_/LowEnergy_/Le2M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Pattern/Brate.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,28 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal import Conversions
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .....Internal.Types import DataType
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le2M:
-	"""Le2M commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class BrateCls:
+	"""Brate commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le2M", core, parent)
+		self._cmd_group = CommandsGroup("brate", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> enums.DetectedPatternType:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PATTern:LENergy:LE2M \n
-		Snippet: value: enums.DetectedPatternType = driver.inputSignal.adetected.pattern.lowEnergy.le2M.fetch() \n
-		Returns the detected payload pattern type. Commands for LE 1M PHY (...:LE1M...) and LE 2M PHY (...:LE2M...) are available.
-		A result is available after the R&S CMW has auto-detected a packet (method RsCmwBluetoothMeas.Configure.InputSignal.dmode
-		AUTO) . \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PATTern[:BRATe] \n
+		Snippet: value: enums.DetectedPatternType = driver.inputSignal.adetected.pattern.brate.fetch() \n
+		Returns the detected payload pattern type. A result is available after the R&S CMW has auto-detected a packet (method
+		RsCmwBluetoothMeas.Configure.InputSignal.dmode AUTO) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
 			:return: pattern_type: P44 | P11 | OTHer | ALTernating P11: 10101010 P44: 11110000 OTHer: any pattern except P11, P44 ALTernating: the periodical change of the pattern P11 and P44"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PATTern:LENergy:LE2M?', suppressed)
+		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PATTern:BRATe?', suppressed)
 		return Conversions.str_to_scalar_enum(response, enums.DetectedPatternType)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Pattern_/LowEnergy_/Lrange.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Pattern/LowEnergy/Lrange.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Lrange:
-	"""Lrange commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class LrangeCls:
+	"""Lrange commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lrange", core, parent)
+		self._cmd_group = CommandsGroup("lrange", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> enums.LeRangePaternType:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PATTern:LENergy:LRANge \n
 		Snippet: value: enums.LeRangePaternType = driver.inputSignal.adetected.pattern.lowEnergy.lrange.fetch() \n
 		Returns the detected payload pattern type for LE coded PHY. A result is available after the R&S CMW has auto-detected a
 		packet (method RsCmwBluetoothMeas.Configure.InputSignal.dmode AUTO) . \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/PduType.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class PduType:
-	"""PduType commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class ListPyCls:
+	"""ListPy commands group definition. 20 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pduType", core, parent)
+		self._cmd_group = CommandsGroup("listPy", core, parent)
 
 	@property
-	def lowEnergy(self):
-		"""lowEnergy commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_lowEnergy'):
-			from .PduType_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
-		return self._lowEnergy
+	def segment(self):
+		"""segment commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_segment'):
+			from .Segment import SegmentCls
+			self._segment = SegmentCls(self._core, self._cmd_group)
+		return self._segment
 
-	def clone(self) -> 'PduType':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ListPyCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = PduType(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ListPyCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/PduType_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/PduType/LowEnergy/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class LowEnergyCls:
+	"""LowEnergy commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("lowEnergy", core, parent)
 
 	@property
 	def le1M(self):
 		"""le1M commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_le1M'):
-			from .LowEnergy_.Le1M import Le1M
-			self._le1M = Le1M(self._core, self._base)
+			from .Le1M import Le1MCls
+			self._le1M = Le1MCls(self._core, self._cmd_group)
 		return self._le1M
 
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LowEnergyCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LowEnergyCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/PduType_/LowEnergy_/Le1M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/PduType/LowEnergy/Le1M.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,20 +2,20 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le1M:
-	"""Le1M commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class Le1MCls:
+	"""Le1M commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le1M", core, parent)
+		self._cmd_group = CommandsGroup("le1M", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Current_Pdu_Type: enums.PduType: No parameter help available
 			- Previous_Pdu_Type: enums.PduType: No parameter help available"""
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Plength.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/PowerVsTime/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,43 +1,51 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Plength:
-	"""Plength commands group definition. 5 total commands, 3 Sub-groups, 0 group commands"""
+class PowerVsTimeCls:
+	"""PowerVsTime commands group definition. 8 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("plength", core, parent)
+		self._cmd_group = CommandsGroup("powerVsTime", core, parent)
 
 	@property
-	def lowEnergy(self):
-		"""lowEnergy commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_lowEnergy'):
-			from .Plength_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
-		return self._lowEnergy
+	def current(self):
+		"""current commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
 
 	@property
-	def edrate(self):
-		"""edrate commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_edrate'):
-			from .Plength_.Edrate import Edrate
-			self._edrate = Edrate(self._core, self._base)
-		return self._edrate
+	def average(self):
+		"""average commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
 
 	@property
-	def brate(self):
-		"""brate commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_brate'):
-			from .Plength_.Brate import Brate
-			self._brate = Brate(self._core, self._base)
-		return self._brate
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
 
-	def clone(self) -> 'Plength':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	def clone(self) -> 'PowerVsTimeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Plength(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PowerVsTimeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Plength_/Brate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/Brate.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,20 +2,20 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Brate:
-	"""Brate commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class BrateCls:
+	"""Brate commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("brate", core, parent)
+		self._cmd_group = CommandsGroup("brate", core, parent)
 
 	def fetch(self) -> int:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PLENgth:BRATe \n
 		Snippet: value: int = driver.inputSignal.adetected.plength.brate.fetch() \n
 		Returns the detected BR payload length. A result is available after the R&S CMW has auto-detected a packet (method
 		RsCmwBluetoothMeas.Configure.InputSignal.dmode AUTO) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Plength_/Edrate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Ptype/LowEnergy/Le2M.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,25 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Edrate:
-	"""Edrate commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class Le2MCls:
+	"""Le2M commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("edrate", core, parent)
+		self._cmd_group = CommandsGroup("le2M", core, parent)
 
-	def fetch(self) -> int:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PLENgth:EDRate \n
-		Snippet: value: int = driver.inputSignal.adetected.plength.edrate.fetch() \n
-		Returns the detected EDR payload length. A result is available after the R&S CMW has auto-detected a packet (method
-		RsCmwBluetoothMeas.Configure.InputSignal.dmode AUTO) . \n
+	# noinspection PyTypeChecker
+	def fetch(self) -> enums.LePacketType:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PTYPe:LENergy:LE2M \n
+		Snippet: value: enums.LePacketType = driver.inputSignal.adetected.ptype.lowEnergy.le2M.fetch() \n
+		Returns the detected packet type for LE 2M PHY. A result is available after the R&S CMW has auto-detected a packet
+		(method RsCmwBluetoothMeas.Configure.InputSignal.dmode AUTO) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: payload_length: decimal Range: 0 Byte(s) to 1021 Byte(s)"""
+			:return: packet_type: RFPHytest | ADVertiser | RFCTe RFPHytest: LE test packet (direct test mode) ADVertiser: air interface packet with advertising channel PDU RFCTe: LE test packet with CTE"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PLENgth:EDRate?', suppressed)
-		return Conversions.str_to_int(response)
+		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PTYPe:LENergy:LE2M?', suppressed)
+		return Conversions.str_to_scalar_enum(response, enums.LePacketType)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Plength_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/PowerVsTime/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,43 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 3 total commands, 3 Sub-groups, 0 group commands"""
+class PowerVsTimeCls:
+	"""PowerVsTime commands group definition. 12 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("powerVsTime", core, parent)
 
 	@property
-	def lrange(self):
-		"""lrange commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_lrange'):
-			from .LowEnergy_.Lrange import Lrange
-			self._lrange = Lrange(self._core, self._base)
-		return self._lrange
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
 
 	@property
-	def le2M(self):
-		"""le2M commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_le2M'):
-			from .LowEnergy_.Le2M import Le2M
-			self._le2M = Le2M(self._core, self._base)
-		return self._le2M
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
 
 	@property
-	def le1M(self):
-		"""le1M commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_le1M'):
-			from .LowEnergy_.Le1M import Le1M
-			self._le1M = Le1M(self._core, self._base)
-		return self._le1M
+	def average(self):
+		"""average commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
 
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def current(self):
+		"""current commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
+
+	def clone(self) -> 'PowerVsTimeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PowerVsTimeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Plength_/LowEnergy_/Le1M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/LowEnergy/Lrange.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,25 +2,25 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le1M:
-	"""Le1M commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class LrangeCls:
+	"""Lrange commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le1M", core, parent)
+		self._cmd_group = CommandsGroup("lrange", core, parent)
 
 	def fetch(self) -> int:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PLENgth:LENergy[:LE1M] \n
-		Snippet: value: int = driver.inputSignal.adetected.plength.lowEnergy.le1M.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PLENgth:LENergy:LRANge \n
+		Snippet: value: int = driver.inputSignal.adetected.plength.lowEnergy.lrange.fetch() \n
 		Returns the detected payload length. Commands for uncoded LE 1M PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded
 		PHY (..:LRANge..) are available. A result is available after the R&S CMW has auto-detected a packet (method
 		RsCmwBluetoothMeas.Configure.InputSignal.dmode AUTO) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
 			:return: payload_length: decimal Range: 0 to 255 , Unit: byte"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PLENgth:LENergy:LE1M?', suppressed)
+		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PLENgth:LENergy:LRANge?', suppressed)
 		return Conversions.str_to_int(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Plength_/LowEnergy_/Le2M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/Qhsl/P5Q.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,25 +2,23 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le2M:
-	"""Le2M commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class P5QCls:
+	"""P5Q commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le2M", core, parent)
+		self._cmd_group = CommandsGroup("p5Q", core, parent)
 
 	def fetch(self) -> int:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PLENgth:LENergy:LE2M \n
-		Snippet: value: int = driver.inputSignal.adetected.plength.lowEnergy.le2M.fetch() \n
-		Returns the detected payload length. Commands for uncoded LE 1M PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded
-		PHY (..:LRANge..) are available. A result is available after the R&S CMW has auto-detected a packet (method
-		RsCmwBluetoothMeas.Configure.InputSignal.dmode AUTO) . \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PLENgth:QHSL:P5Q \n
+		Snippet: value: int = driver.inputSignal.adetected.plength.qhsl.p5Q.fetch() \n
+		No command help available \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: payload_length: decimal Range: 0 to 255 , Unit: byte"""
+			:return: payload_length: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PLENgth:LENergy:LE2M?', suppressed)
+		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PLENgth:QHSL:P5Q?', suppressed)
 		return Conversions.str_to_int(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Plength_/LowEnergy_/Lrange.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/LowEnergy/Le2M.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,25 +2,25 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Lrange:
-	"""Lrange commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class Le2MCls:
+	"""Le2M commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lrange", core, parent)
+		self._cmd_group = CommandsGroup("le2M", core, parent)
 
 	def fetch(self) -> int:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PLENgth:LENergy:LRANge \n
-		Snippet: value: int = driver.inputSignal.adetected.plength.lowEnergy.lrange.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PLENgth:LENergy:LE2M \n
+		Snippet: value: int = driver.inputSignal.adetected.plength.lowEnergy.le2M.fetch() \n
 		Returns the detected payload length. Commands for uncoded LE 1M PHY (..:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded
 		PHY (..:LRANge..) are available. A result is available after the R&S CMW has auto-detected a packet (method
 		RsCmwBluetoothMeas.Configure.InputSignal.dmode AUTO) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
 			:return: payload_length: decimal Range: 0 to 255 , Unit: byte"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PLENgth:LENergy:LRANge?', suppressed)
+		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PLENgth:LENergy:LE2M?', suppressed)
 		return Conversions.str_to_int(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Ptype.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,43 +1,59 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ptype:
-	"""Ptype commands group definition. 5 total commands, 3 Sub-groups, 0 group commands"""
+class PowerVsTimeCls:
+	"""PowerVsTime commands group definition. 168 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ptype", core, parent)
+		self._cmd_group = CommandsGroup("powerVsTime", core, parent)
 
 	@property
-	def lowEnergy(self):
-		"""lowEnergy commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_lowEnergy'):
-			from .Ptype_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
-		return self._lowEnergy
+	def qhsl(self):
+		"""qhsl commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_qhsl'):
+			from .Qhsl import QhslCls
+			self._qhsl = QhslCls(self._core, self._cmd_group)
+		return self._qhsl
+
+	@property
+	def nmode(self):
+		"""nmode commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_nmode'):
+			from .Nmode import NmodeCls
+			self._nmode = NmodeCls(self._core, self._cmd_group)
+		return self._nmode
 
 	@property
 	def edrate(self):
-		"""edrate commands group. 0 Sub-classes, 1 commands."""
+		"""edrate commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_edrate'):
-			from .Ptype_.Edrate import Edrate
-			self._edrate = Edrate(self._core, self._base)
+			from .Edrate import EdrateCls
+			self._edrate = EdrateCls(self._core, self._cmd_group)
 		return self._edrate
 
 	@property
 	def brate(self):
-		"""brate commands group. 0 Sub-classes, 1 commands."""
+		"""brate commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_brate'):
-			from .Ptype_.Brate import Brate
-			self._brate = Brate(self._core, self._base)
+			from .Brate import BrateCls
+			self._brate = BrateCls(self._core, self._cmd_group)
 		return self._brate
 
-	def clone(self) -> 'Ptype':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def lowEnergy(self):
+		"""lowEnergy commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_lowEnergy'):
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
+		return self._lowEnergy
+
+	def clone(self) -> 'PowerVsTimeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Ptype(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PowerVsTimeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Ptype_/Brate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Ptype/Brate.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from .....Internal import Conversions
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Brate:
-	"""Brate commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class BrateCls:
+	"""Brate commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("brate", core, parent)
+		self._cmd_group = CommandsGroup("brate", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> enums.BrPacketType:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PTYPe:BRATe \n
 		Snippet: value: enums.BrPacketType = driver.inputSignal.adetected.ptype.brate.fetch() \n
 		Returns the detected BR packet type. A result is available after the R&S CMW has auto-detected a packet (method
 		RsCmwBluetoothMeas.Configure.InputSignal.dmode AUTO) . \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Ptype_/Edrate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Ptype/Edrate.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from .....Internal import Conversions
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Edrate:
-	"""Edrate commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class EdrateCls:
+	"""Edrate commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("edrate", core, parent)
+		self._cmd_group = CommandsGroup("edrate", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> enums.EdrPacketType:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PTYPe:EDRate \n
 		Snippet: value: enums.EdrPacketType = driver.inputSignal.adetected.ptype.edrate.fetch() \n
 		Returns the detected EDR packet type. A result is available after the R&S CMW has auto-detected a packet (method
 		RsCmwBluetoothMeas.Configure.InputSignal.dmode AUTO) . \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Ptype_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le1M/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,43 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 3 total commands, 3 Sub-groups, 0 group commands"""
+class Le1MCls:
+	"""Le1M commands group definition. 12 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("le1M", core, parent)
 
 	@property
-	def lrange(self):
-		"""lrange commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_lrange'):
-			from .LowEnergy_.Lrange import Lrange
-			self._lrange = Lrange(self._core, self._base)
-		return self._lrange
+	def current(self):
+		"""current commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
 
 	@property
-	def le2M(self):
-		"""le2M commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_le2M'):
-			from .LowEnergy_.Le2M import Le2M
-			self._le2M = Le2M(self._core, self._base)
-		return self._le2M
+	def average(self):
+		"""average commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
 
 	@property
-	def le1M(self):
-		"""le1M commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_le1M'):
-			from .LowEnergy_.Le1M import Le1M
-			self._le1M = Le1M(self._core, self._base)
-		return self._le1M
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
 
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	def clone(self) -> 'Le1MCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = Le1MCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Ptype_/LowEnergy_/Le1M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Ptype/LowEnergy/Le1M.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le1M:
-	"""Le1M commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class Le1MCls:
+	"""Le1M commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le1M", core, parent)
+		self._cmd_group = CommandsGroup("le1M", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> enums.LePacketType:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PTYPe:LENergy[:LE1M] \n
 		Snippet: value: enums.LePacketType = driver.inputSignal.adetected.ptype.lowEnergy.le1M.fetch() \n
 		Returns the detected packet type for LE 1M PHY (uncoded) . A result is available after the R&S CMW has auto-detected a
 		packet (method RsCmwBluetoothMeas.Configure.InputSignal.dmode AUTO) . \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Ptype_/LowEnergy_/Le2M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Ptype/LowEnergy/Lrange.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le2M:
-	"""Le2M commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class LrangeCls:
+	"""Lrange commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le2M", core, parent)
+		self._cmd_group = CommandsGroup("lrange", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> enums.LePacketType:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PTYPe:LENergy:LE2M \n
-		Snippet: value: enums.LePacketType = driver.inputSignal.adetected.ptype.lowEnergy.le2M.fetch() \n
-		Returns the detected packet type for LE 2M PHY. A result is available after the R&S CMW has auto-detected a packet
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PTYPe:LENergy:LRANge \n
+		Snippet: value: enums.LePacketType = driver.inputSignal.adetected.ptype.lowEnergy.lrange.fetch() \n
+		Returns the detected packet type for LE coded PHY. A result is available after the R&S CMW has auto-detected a packet
 		(method RsCmwBluetoothMeas.Configure.InputSignal.dmode AUTO) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: packet_type: RFPHytest | ADVertiser | RFCTe RFPHytest: LE test packet (direct test mode) ADVertiser: air interface packet with advertising channel PDU RFCTe: LE test packet with CTE"""
+			:return: packet_type: RFPHytest | ADVertiser RFPHytest: LE test packet (direct test mode) ADVertiser: air interface packet with advertising channel PDU"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PTYPe:LENergy:LE2M?', suppressed)
+		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PTYPe:LENergy:LRANge?', suppressed)
 		return Conversions.str_to_scalar_enum(response, enums.LePacketType)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/InputSignal_/Adetected_/Ptype_/LowEnergy_/Lrange.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/Per/RxPackets.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,27 +1,24 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal import Conversions
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Lrange:
-	"""Lrange commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RxPacketsCls:
+	"""RxPackets commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lrange", core, parent)
+		self._cmd_group = CommandsGroup("rxPackets", core, parent)
 
-	# noinspection PyTypeChecker
-	def fetch(self) -> enums.LePacketType:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PTYPe:LENergy:LRANge \n
-		Snippet: value: enums.LePacketType = driver.inputSignal.adetected.ptype.lowEnergy.lrange.fetch() \n
-		Returns the detected packet type for LE coded PHY. A result is available after the R&S CMW has auto-detected a packet
-		(method RsCmwBluetoothMeas.Configure.InputSignal.dmode AUTO) . \n
+	def fetch(self) -> int:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:RXQuality:PER:RXPackets \n
+		Snippet: value: int = driver.rxQuality.per.rxPackets.fetch() \n
+		Queries the number of packets received during PER measurement. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: packet_type: RFPHytest | ADVertiser RFPHytest: LE test packet (direct test mode) ADVertiser: air interface packet with advertising channel PDU"""
+			:return: packets_received: decimal Packets detected by the R&S CMW Range: 0 to 100E+3"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PTYPe:LENergy:LRANge?', suppressed)
-		return Conversions.str_to_scalar_enum(response, enums.LePacketType)
+		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:RXQuality:PER:RXPackets?', suppressed)
+		return Conversions.str_to_int(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Frange.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Frange/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Frange:
-	"""Frange commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class FrangeCls:
+	"""Frange commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("frange", core, parent)
+		self._cmd_group = CommandsGroup("frange", core, parent)
 
 	@property
 	def brate(self):
 		"""brate commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_brate'):
-			from .Frange_.Brate import Brate
-			self._brate = Brate(self._core, self._base)
+			from .Brate import BrateCls
+			self._brate = BrateCls(self._core, self._cmd_group)
 		return self._brate
 
-	def clone(self) -> 'Frange':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'FrangeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Frange(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = FrangeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Frange_/Brate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Frange/Brate/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Brate:
-	"""Brate commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class BrateCls:
+	"""Brate commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("brate", core, parent)
+		self._cmd_group = CommandsGroup("brate", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Brate_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
-	def clone(self) -> 'Brate':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'BrateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Brate(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = BrateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Frange_/Brate_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Edrate/Maximum.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,106 +1,107 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:FRANge CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:FRANge CMDLINK]. Additional ON/OFF enables/disables the out of tolerance evaluation. Range: 0 % to 100 %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm
-			- Fl: float: float Lowest frequency at which spectral power density drops below specified threshold Range: -1 MHz to +1 MHz
-			- Fh: float: float Highest frequency at which spectral power density drops below specified threshold Range: -1 MHz to +1 MHz"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Fl'),
-			ArgStruct.scalar_float('Fh')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Fl: float = None
-			self.Fh: float = None
-
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:FRANge:BRATe:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.frange.brate.current.calculate() \n
-		Returns the 'Frequency Range' results for BR. The values described below are returned by FETCh and READ commands.
-		CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:FRANge:BRATe:CURRent?', self.__class__.CalculateStruct())
-
-	# noinspection PyTypeChecker
-	class ReadStruct(StructBase):
-		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:FRANge CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:FRANge CMDLINK]. Additional ON/OFF enables/disables the out of tolerance evaluation. Range: 0 % to 100 %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm
-			- Fl: float: float Lowest frequency at which spectral power density drops below specified threshold Range: -1 MHz to +1 MHz
-			- Fh: float: float Highest frequency at which spectral power density drops below specified threshold Range: -1 MHz to +1 MHz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Omega_I: float or bool: float Initial center frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Omega_Iplus_Omega_0_Max: float or bool: float Maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Omega_0_Max: float or bool: float Maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Rms_Devm: float or bool: float Differential EVM results Range: 0 to 1
+			- Peak_Devm: float or bool: float Range: 0 to 1
+			- P_99_Devm: float or bool: float Range: 0 to 1
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Fl'),
-			ArgStruct.scalar_float('Fh')]
+			ArgStruct.scalar_float_ext('Omega_I'),
+			ArgStruct.scalar_float_ext('Omega_Iplus_Omega_0_Max'),
+			ArgStruct.scalar_float_ext('Omega_0_Max'),
+			ArgStruct.scalar_float_ext('Rms_Devm'),
+			ArgStruct.scalar_float_ext('Peak_Devm'),
+			ArgStruct.scalar_float_ext('P_99_Devm'),
+			ArgStruct.scalar_float_ext('Nominal_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float or bool = None
-			self.Nominal_Power: float = None
-			self.Fl: float = None
-			self.Fh: float = None
+			self.Omega_I: float or bool = None
+			self.Omega_Iplus_Omega_0_Max: float or bool = None
+			self.Omega_0_Max: float or bool = None
+			self.Rms_Devm: float or bool = None
+			self.Peak_Devm: float or bool = None
+			self.P_99_Devm: float or bool = None
+			self.Nominal_Power: float or bool = None
 
-	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:FRANge:BRATe:CURRent \n
-		Snippet: value: ReadStruct = driver.multiEval.frange.brate.current.read() \n
-		Returns the 'Frequency Range' results for BR. The values described below are returned by FETCh and READ commands.
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:MAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.edrate.maximum.calculate() \n
+		Returns the modulation results for EDR packets. The values described below are returned by FETCh and READ commands.
 		CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:FRANge:BRATe:CURRent?', self.__class__.ReadStruct())
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:MAXimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
-	class FetchStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:FRANge CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:FRANge CMDLINK]. Additional ON/OFF enables/disables the out of tolerance evaluation. Range: 0 % to 100 %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm
-			- Fl: float: float Lowest frequency at which spectral power density drops below specified threshold Range: -1 MHz to +1 MHz
-			- Fh: float: float Highest frequency at which spectral power density drops below specified threshold Range: -1 MHz to +1 MHz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Omega_I: float: float Initial center frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Omega_Iplus_Omega_0_Max: float: float Maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Omega_0_Max: float: float Maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Rms_Devm: float: float Differential EVM results Range: 0 to 1
+			- Peak_Devm: float: float Range: 0 to 1
+			- P_99_Devm: float: float Range: 0 to 1
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Fl'),
-			ArgStruct.scalar_float('Fh')]
+			ArgStruct.scalar_float('Omega_I'),
+			ArgStruct.scalar_float('Omega_Iplus_Omega_0_Max'),
+			ArgStruct.scalar_float('Omega_0_Max'),
+			ArgStruct.scalar_float('Rms_Devm'),
+			ArgStruct.scalar_float('Peak_Devm'),
+			ArgStruct.scalar_float('P_99_Devm'),
+			ArgStruct.scalar_float('Nominal_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
+			self.Omega_I: float = None
+			self.Omega_Iplus_Omega_0_Max: float = None
+			self.Omega_0_Max: float = None
+			self.Rms_Devm: float = None
+			self.Peak_Devm: float = None
+			self.P_99_Devm: float = None
 			self.Nominal_Power: float = None
-			self.Fl: float = None
-			self.Fh: float = None
 
-	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:FRANge:BRATe:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.frange.brate.current.fetch() \n
-		Returns the 'Frequency Range' results for BR. The values described below are returned by FETCh and READ commands.
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.edrate.maximum.fetch() \n
+		Returns the modulation results for EDR packets. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:MAXimum?', self.__class__.ResultData())
+
+	def read(self) -> ResultData:
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.edrate.maximum.read() \n
+		Returns the modulation results for EDR packets. The values described below are returned by FETCh and READ commands.
 		CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:FRANge:BRATe:CURRent?', self.__class__.FetchStruct())
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/SoBw/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ListPy:
-	"""ListPy commands group definition. 14 total commands, 1 Sub-groups, 0 group commands"""
+class SoBwCls:
+	"""SoBw commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("listPy", core, parent)
+		self._cmd_group = CommandsGroup("soBw", core, parent)
 
 	@property
-	def segment(self):
-		"""segment commands group. 5 Sub-classes, 0 commands."""
-		if not hasattr(self, '_segment'):
-			from .ListPy_.Segment import Segment
-			self._segment = Segment(self._core, self._base)
-		return self._segment
+	def brate(self):
+		"""brate commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_brate'):
+			from .Brate import BrateCls
+			self._brate = BrateCls(self._core, self._cmd_group)
+		return self._brate
 
-	def clone(self) -> 'ListPy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SoBwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ListPy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SoBwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/ListPy/Segment/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,74 +1,66 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.RepeatedCapability import RepeatedCapability
-from .... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.RepeatedCapability import RepeatedCapability
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Segment:
-	"""Segment commands group definition. 14 total commands, 5 Sub-groups, 0 group commands
+class SegmentCls:
+	"""Segment commands group definition. 35 total commands, 4 Subgroups, 0 group commands
 	Repeated Capability: Segment, default value after init: Segment.S1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("segment", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_segment_get', 'repcap_segment_set', repcap.Segment.S1)
+		self._cmd_group = CommandsGroup("segment", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_segment_get', 'repcap_segment_set', repcap.Segment.S1)
 
-	def repcap_segment_set(self, enum_value: repcap.Segment) -> None:
+	def repcap_segment_set(self, segment: repcap.Segment) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Segment.Default
 		Default value after init: Segment.S1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(segment)
 
 	def repcap_segment_get(self) -> repcap.Segment:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
-	def pencoding(self):
-		"""pencoding commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_pencoding'):
-			from .Segment_.Pencoding import Pencoding
-			self._pencoding = Pencoding(self._core, self._base)
-		return self._pencoding
+	def cidx(self):
+		"""cidx commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_cidx'):
+			from .Cidx import CidxCls
+			self._cidx = CidxCls(self._core, self._cmd_group)
+		return self._cidx
 
 	@property
-	def sacp(self):
-		"""sacp commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_sacp'):
-			from .Segment_.Sacp import Sacp
-			self._sacp = Sacp(self._core, self._base)
-		return self._sacp
+	def setup(self):
+		"""setup commands group. 17 Sub-classes, 1 commands."""
+		if not hasattr(self, '_setup'):
+			from .Setup import SetupCls
+			self._setup = SetupCls(self._core, self._cmd_group)
+		return self._setup
 
 	@property
-	def soBw(self):
-		"""soBw commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_soBw'):
-			from .Segment_.SoBw import SoBw
-			self._soBw = SoBw(self._core, self._base)
-		return self._soBw
+	def scount(self):
+		"""scount commands group. 6 Sub-classes, 1 commands."""
+		if not hasattr(self, '_scount'):
+			from .Scount import ScountCls
+			self._scount = ScountCls(self._core, self._cmd_group)
+		return self._scount
 
 	@property
-	def modulation(self):
-		"""modulation commands group. 5 Sub-classes, 0 commands."""
-		if not hasattr(self, '_modulation'):
-			from .Segment_.Modulation import Modulation
-			self._modulation = Modulation(self._core, self._base)
-		return self._modulation
+	def results(self):
+		"""results commands group. 6 Sub-classes, 1 commands."""
+		if not hasattr(self, '_results'):
+			from .Results import ResultsCls
+			self._results = ResultsCls(self._core, self._cmd_group)
+		return self._results
 
-	@property
-	def powerVsTime(self):
-		"""powerVsTime commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_powerVsTime'):
-			from .Segment_.PowerVsTime import PowerVsTime
-			self._powerVsTime = PowerVsTime(self._core, self._base)
-		return self._powerVsTime
-
-	def clone(self) -> 'Segment':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SegmentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Segment(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SegmentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le2M/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,59 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Modulation:
-	"""Modulation commands group definition. 7 total commands, 5 Sub-groups, 0 group commands"""
+class Le2MCls:
+	"""Le2M commands group definition. 12 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("modulation", core, parent)
+		self._cmd_group = CommandsGroup("le2M", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 1 Sub-classes, 1 commands."""
+		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Modulation_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 1 commands."""
+		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Modulation_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 1 commands."""
+		"""minimum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Modulation_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 1 commands."""
+		"""maximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Modulation_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 1 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Modulation_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'Modulation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'Le2MCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Modulation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = Le2MCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Average/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,42 +1,50 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
+
+	@property
+	def extended(self):
+		"""extended commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_extended'):
+			from .Extended import ExtendedCls
+			self._extended = ExtendedCls(self._core, self._cmd_group)
+		return self._extended
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
+			- Reliability: int: decimal 'Reliability indicator'
 			- Seg_Reliability: int: decimal Reliability indicator for the segment. The meaning of the returned values is the same as for the common reliability indicator, see previous parameter.
 			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 % , Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Freq_Acc_Or_Init_Freq_Error: float: float Frequency accuracy (BR, LE) or initial center frequency error ωi (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Frequency drift (BR, LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift_Rate: float: float Maximal drift rate (BR, LE) Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Delta_F_1_Avg: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_1_Min: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_1_Max: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_2_Avg: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_2_Min: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_2_Max: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Omegai_Omega_0: float: No parameter help available
 			- Omega_0_Max: float: float Maximum compensated frequency error (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Rms_Devm: float: float RMS DEVM (EDR) Range: 0 to 1
-			- Peak_Devm: float: float Peak DEVM (EDR) Range: 0 to 1
+			- Rms_Devm: float: float RMS DEVM (EDR) Range: 0.0 to 1.0
+			- Peak_Devm: float: float Peak DEVM (EDR) Range: 0.0 to 1.0
 			- Freq_Offset: float: float Frequency offset (LE) Range: -0.99999 MHz to 0.99999 MHz
 			- Initial_Freq_Drift: float: float Initial frequency drift (LE) Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
@@ -82,9 +90,17 @@
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:AVERage \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.average.fetch(segment = repcap.Segment.Default) \n
 		Returns modulation single value results for segment<no> in list mode. The command returns all parameters listed below,
 		independent of the selected list mode setup. However, only for some of the parameters measured values are available. For
 		the other parameters, only an indicator is returned (e.g. NAV) . \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:AVERage?', self.__class__.FetchStruct())
+
+	def clone(self) -> 'AverageCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = AverageCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Current/__init__.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,52 +1,52 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
 	def extended(self):
 		"""extended commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_extended'):
-			from .Current_.Extended import Extended
-			self._extended = Extended(self._core, self._base)
+			from .Extended import ExtendedCls
+			self._extended = ExtendedCls(self._core, self._cmd_group)
 		return self._extended
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
+			- Reliability: int: decimal 'Reliability indicator'
 			- Seg_Reliability: int: decimal Reliability indicator for the segment. The meaning of the returned values is the same as for the common reliability indicator, see previous parameter.
 			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 % , Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Freq_Acc_Or_Init_Freq_Error: float: float Frequency accuracy (BR, LE) or initial center frequency error ωi (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Frequency drift (BR, LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift_Rate: float: float Maximal drift rate (BR, LE) Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Delta_F_1_Avg: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_1_Min: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_1_Max: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_2_Avg: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_2_Min: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_2_Max: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
-			- Delta_F_299_P: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur (BR, LE)
+			- Delta_F_299_P: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur (BR, LE) .
 			- Omegai_Omega_0: float: No parameter help available
 			- Omega_0_Max: float: float Maximum compensated frequency error (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Rms_Devm: float: float RMS DEVM (EDR) Range: 0 to 1
-			- Peak_Devm: float: float Peak DEVM (EDR) Range: 0 to 1
-			- P_99_Devm: float: float DEVM value below which 99% of all measured DEVM values occur (EDR) Range: 0 to 1
+			- Rms_Devm: float: float RMS DEVM (EDR) Range: 0.0 to 1.0
+			- Peak_Devm: float: float Peak DEVM (EDR) Range: 0.0 to 1.0
+			- P_99_Devm: float: float DEVM value below which 99% of all measured DEVM values occur (EDR) . Range: 0.0 to 1.0
 			- Freq_Offset: float: float Frequency offset (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Initial_Freq_Drift: float: float Initial frequency drift (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
@@ -91,22 +91,22 @@
 			self.P_99_Devm: float = None
 			self.Freq_Offset: float = None
 			self.Initial_Freq_Drift: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:CURRent \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.current.fetch(segment = repcap.Segment.Default) \n
-		Returns modulation single value results for segment<no> in list mode. The command returns all parameters listed below,
-		independent of the selected list mode setup. However, only for some of the parameters measured values are available. For
-		the other parameters, only an indicator is returned (e.g. NAV) . \n
+		Returns modulation single current value results for segment<no> in list mode. The command returns all parameters listed
+		below, independent of the selected list mode setup. However, only for some of the parameters measured values are
+		available. For the other parameters, only an indicator is returned (e.g. NAV) . \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:CURRent?', self.__class__.FetchStruct())
 
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Current_/Extended.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Maximum/Extended.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,96 +2,101 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extended:
-	"""Extended commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ExtendedCls:
+	"""Extended commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extended", core, parent)
+		self._cmd_group = CommandsGroup("extended", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
+			- Reliability: int: decimal 'Reliability indicator'
 			- Seg_Reliability: int: decimal Reliability indicator for the segment. The meaning of the returned values is the same as for the common reliability indicator, see previous parameter.
 			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 % , Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Freq_Acc_Or_Init_Freq_Error: float: float Frequency accuracy (BR, LE) or initial center frequency error ωi (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Frequency drift (BR, LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift_Rate: float: float Maximal drift rate (BR, LE) Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Delta_F_1_Avg: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_1_Min: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_1_Max: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_2_Avg: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_2_Min: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_2_Max: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
-			- Delta_F_299_P: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur (BR, LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Omegai_Omega_0: float: No parameter help available
 			- Omega_0_Max: float: float Maximum compensated frequency error (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Rms_Devm: float: RMS DEVM (EDR) Range: 0 to 1
-			- Peak_Devm: float: float Peak DEVM (EDR) Range: 0 to 1
-			- P_99_Devm: float: float DEVM value below which 99% of all measured DEVM values occur (EDR) Range: 0 to 1
+			- Rms_Devm: float: float RMS DEVM (EDR) Range: 0.0 to 1.0
+			- Peak_Devm: float: float Peak DEVM (EDR) Range: 0.0 to 1.0
 			- Freq_Offset: float: float Frequency offset (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Initial_Freq_Drift: float: float Initial frequency drift (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- P_99_Devm_Per: float: No parameter help available"""
+			- Init_Freq_Drift: float: float Initial frequency drift (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Cte_Freq_Drift: float: No parameter help available
+			- Cte_Mx_Drift_Rate: float: No parameter help available
+			- Cte_Freq_Offset: float: No parameter help available
+			- Cte_Int_Frq_Drift: float: No parameter help available"""
 		__meta_args_list = [
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Freq_Acc_Or_Init_Freq_Error'),
 			ArgStruct.scalar_float('Freq_Drift'),
 			ArgStruct.scalar_float('Max_Drift_Rate'),
 			ArgStruct.scalar_float('Delta_F_1_Avg'),
 			ArgStruct.scalar_float('Delta_F_1_Min'),
 			ArgStruct.scalar_float('Delta_F_1_Max'),
 			ArgStruct.scalar_float('Delta_F_2_Avg'),
 			ArgStruct.scalar_float('Delta_F_2_Min'),
 			ArgStruct.scalar_float('Delta_F_2_Max'),
-			ArgStruct.scalar_float('Delta_F_299_P'),
 			ArgStruct.scalar_float('Omegai_Omega_0'),
 			ArgStruct.scalar_float('Omega_0_Max'),
 			ArgStruct.scalar_float('Rms_Devm'),
 			ArgStruct.scalar_float('Peak_Devm'),
-			ArgStruct.scalar_float('P_99_Devm'),
 			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Initial_Freq_Drift'),
-			ArgStruct.scalar_float('P_99_Devm_Per')]
+			ArgStruct.scalar_float('Init_Freq_Drift'),
+			ArgStruct.scalar_float('Cte_Freq_Drift'),
+			ArgStruct.scalar_float('Cte_Mx_Drift_Rate'),
+			ArgStruct.scalar_float('Cte_Freq_Offset'),
+			ArgStruct.scalar_float('Cte_Int_Frq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
+			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
 			self.Freq_Acc_Or_Init_Freq_Error: float = None
 			self.Freq_Drift: float = None
 			self.Max_Drift_Rate: float = None
 			self.Delta_F_1_Avg: float = None
 			self.Delta_F_1_Min: float = None
 			self.Delta_F_1_Max: float = None
 			self.Delta_F_2_Avg: float = None
 			self.Delta_F_2_Min: float = None
 			self.Delta_F_2_Max: float = None
-			self.Delta_F_299_P: float = None
 			self.Omegai_Omega_0: float = None
 			self.Omega_0_Max: float = None
 			self.Rms_Devm: float = None
 			self.Peak_Devm: float = None
-			self.P_99_Devm: float = None
 			self.Freq_Offset: float = None
-			self.Initial_Freq_Drift: float = None
-			self.P_99_Devm_Per: float = None
+			self.Init_Freq_Drift: float = None
+			self.Cte_Freq_Drift: float = None
+			self.Cte_Mx_Drift_Rate: float = None
+			self.Cte_Freq_Offset: float = None
+			self.Cte_Int_Frq_Drift: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:CURRent:EXTended \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.current.extended.fetch(segment = repcap.Segment.Default) \n
-		Returns modulation single value results for segment<no> in list mode including Bluetooth version 5.0. The command returns
-		all parameters listed below, independent of the selected list mode setup. However, only for some of the parameters
-		measured values are available. For the other parameters, only an indicator is returned (e.g. NAV) . \n
-		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:MAXimum:EXTended \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.maximum.extended.fetch(segment = repcap.Segment.Default) \n
+		Returns single maximum modulation results for segment<no> in list mode including Bluetooth version 5.0 and higher.
+		The command returns all parameters listed below, independent of the selected list mode setup. However, only for some of
+		the parameters measured values are available. For the other parameters, only an indicator is returned (e.g. NAV) . \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:CURRent:EXTended?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:MAXimum:EXTended?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Maximum/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,42 +1,50 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
+
+	@property
+	def extended(self):
+		"""extended commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_extended'):
+			from .Extended import ExtendedCls
+			self._extended = ExtendedCls(self._core, self._cmd_group)
+		return self._extended
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
+			- Reliability: int: decimal 'Reliability indicator'
 			- Seg_Reliability: int: decimal Reliability indicator for the segment. The meaning of the returned values is the same as for the common reliability indicator, see previous parameter.
 			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 % , Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Freq_Acc_Or_Init_Freq_Error: float: float Frequency accuracy (BR, LE) or initial center frequency error ωi (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Frequency drift (BR, LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift_Rate: float: float Maximal drift rate (BR, LE) Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Delta_F_1_Avg: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_1_Min: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_1_Max: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_2_Avg: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_2_Min: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_2_Max: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Omegai_Omega_0: float: No parameter help available
 			- Omega_0_Max: float: float Maximum compensated frequency error (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Rms_Devm: float: float RMS DEVM (EDR) Range: 0 to 1
-			- Peak_Devm: float: float Peak DEVM (EDR) Range: 0 to 1
+			- Rms_Devm: float: float RMS DEVM (EDR) Range: 0.0 to 1.0
+			- Peak_Devm: float: float Peak DEVM (EDR) Range: 0.0 to 1.0
 			- Freq_Offset: float: float Frequency offset (LE) Range: -0.99999 MHz to 0.99999 MHz
 			- Initial_Freq_Drift: float: float Initial frequency drift (LE) Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
@@ -82,9 +90,17 @@
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:MAXimum \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.maximum.fetch(segment = repcap.Segment.Default) \n
 		Returns modulation single value results for segment<no> in list mode. The command returns all parameters listed below,
 		independent of the selected list mode setup. However, only for some of the parameters measured values are available. For
 		the other parameters, only an indicator is returned (e.g. NAV) . \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:MAXimum?', self.__class__.FetchStruct())
+
+	def clone(self) -> 'MaximumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = MaximumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Minimum.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,25 +2,25 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
+			- Reliability: int: decimal 'Reliability indicator'
 			- Seg_Reliability: int: decimal Reliability indicator for the segment. The meaning of the returned values is the same as for the common reliability indicator, see previous parameter.
 			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 % , Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Delta_F_1_Avg: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_1_Min: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_1_Max: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
 			- Delta_F_2_Avg: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
@@ -55,9 +55,9 @@
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:MINimum \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.minimum.fetch(segment = repcap.Segment.Default) \n
 		Returns modulation single value results for segment<no> in list mode. The command returns all parameters listed below,
 		independent of the selected list mode setup. However, only for some of the parameters measured values are available. For
 		the other parameters, only an indicator is returned (e.g. NAV) . \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:MINimum?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/StandardDev.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/StandardDev/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,48 +1,48 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	@property
 	def extended(self):
 		"""extended commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_extended'):
-			from .StandardDev_.Extended import Extended
-			self._extended = Extended(self._core, self._base)
+			from .Extended import ExtendedCls
+			self._extended = ExtendedCls(self._core, self._cmd_group)
 		return self._extended
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
+			- Reliability: int: decimal 'Reliability indicator'
 			- Seg_Reliability: int: decimal Reliability indicator for the segment. The meaning of the returned values is the same as for the common reliability indicator, see previous parameter.
 			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 % , Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Freq_Acc_Or_Init_Freq_Error: float: float Frequency accuracy (BR, LE) or initial center frequency error ωi (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Frequency drift (BR, LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift_Rate: float: float Maximal drift rate (BR, LE) Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Delta_F_299_P: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur (BR, LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Nominal_Power: float: float Standard deviation of average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Freq_Acc_Or_Init_Freq_Error: float: float Standard deviation of frequency accuracy (BR, LE) or initial center frequency error ωi (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float: float Standard deviation of frequency drift (BR, LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift_Rate: float: float Standard deviation of maximal drift rate (BR, LE) Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Delta_F_299_P: float: float Standard deviation of frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur (BR, LE) . Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Omegai_Omega_0: float: No parameter help available
-			- Omega_0_Max: float: float Maximum compensated frequency error (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Rms_Devm: float: float Range: 0 to 1
-			- Peak_Devm: float: float Peak DEVM (EDR) Range: 0 to 1
-			- P_99_Devm: float: float DEVM value below which 99% of all measured DEVM values occur (EDR) Range: 0 to 1
-			- Freq_Offset: float: float Frequency offset (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Initial_Freq_Drift: float: float Initial frequency drift (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Omega_0_Max: float: float Standard deviation of maximum compensated frequency error (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Rms_Devm: float: float Standard deviation of RMS DEVM (EDR) Range: 0.0 to 1.0
+			- Peak_Devm: float: float Standard deviation of peak DEVM (EDR) Range: 0.0 to 1.0
+			- P_99_Devm: float: float Standard deviation of DEVM value below which 99% of all measured DEVM values occur (EDR) . Range: 0.0 to 1.0
+			- Freq_Offset: float: float Standard deviation of frequency offset (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Initial_Freq_Drift: float: float Standard deviation of initial frequency drift (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Freq_Acc_Or_Init_Freq_Error'),
 			ArgStruct.scalar_float('Freq_Drift'),
@@ -78,17 +78,17 @@
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:SDEViation \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.standardDev.fetch(segment = repcap.Segment.Default) \n
 		Returns modulation single value results for segment<no> in list mode. The command returns all parameters listed below,
 		independent of the selected list mode setup. However, only for some of the parameters measured values are available. For
 		the other parameters, only an indicator is returned (e.g. NAV) . \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:SDEViation?', self.__class__.FetchStruct())
 
-	def clone(self) -> 'StandardDev':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'StandardDevCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = StandardDev(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = StandardDevCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/StandardDev_/Extended.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le1M/StandardDev.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,81 +1,86 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extended:
-	"""Extended commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extended", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
-	class FetchStruct(StructBase):
+	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Seg_Reliability: int: decimal Reliability indicator for the segment. The meaning of the returned values is the same as for the common reliability indicator, see previous parameter.
-			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 % , Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Freq_Acc_Or_Init_Freq_Error: float: float Frequency accuracy (BR, LE) or initial center frequency error ωi (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Frequency drift (BR, LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift_Rate: float: float Maximal drift rate (BR, LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Delta_F_299_P: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur (BR, LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Omegai_Omega_0: float: No parameter help available
-			- Omega_0_Max: float: float Maximum compensated frequency error (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Rms_Devm: float: float RMS DEVM (EDR) Range: 0 to 1
-			- Peak_Devm: float: float Peak DEVM (EDR) Range: 0 to 1
-			- P_99_Devm: float: float DEVM value below which 99% of all measured DEVM values occur (EDR) Range: 0 to 1
-			- Freq_Offset: float: float Frequency offset (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Initial_Freq_Drift: float: float Initial frequency drift (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Delta_F_199_P: float: float Frequency deviation value Δf1 above which 99.9% of all measured Δf1 values occur (LE coded PHY) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs"""
+		__meta_args_list = [
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift')]
+
+		def __init__(self):
+			StructBase.__init__(self, self)
+			self.Reliability: int = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:SDEViation \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le1M.standardDev.calculate() \n
+		Returns the standard deviation modulation results for LE 1M PHY in normal mode, see 'Normal mode classic: statistical
+		modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit
+		check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:SDEViation?', self.__class__.CalculateStruct())
+
+	# noinspection PyTypeChecker
+	class ResultData(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
+			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Acc_Or_Init_Freq_Error'),
+			ArgStruct.scalar_float('Freq_Accuracy'),
 			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift_Rate'),
-			ArgStruct.scalar_float('Delta_F_299_P'),
-			ArgStruct.scalar_float('Omegai_Omega_0'),
-			ArgStruct.scalar_float('Omega_0_Max'),
-			ArgStruct.scalar_float('Rms_Devm'),
-			ArgStruct.scalar_float('Peak_Devm'),
-			ArgStruct.scalar_float('P_99_Devm'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Initial_Freq_Drift'),
-			ArgStruct.scalar_float('Delta_F_199_P')]
+			ArgStruct.scalar_float('Max_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Seg_Reliability: int = None
 			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Freq_Acc_Or_Init_Freq_Error: float = None
+			self.Freq_Accuracy: float = None
 			self.Freq_Drift: float = None
-			self.Max_Drift_Rate: float = None
-			self.Delta_F_299_P: float = None
-			self.Omegai_Omega_0: float = None
-			self.Omega_0_Max: float = None
-			self.Rms_Devm: float = None
-			self.Peak_Devm: float = None
-			self.P_99_Devm: float = None
-			self.Freq_Offset: float = None
-			self.Initial_Freq_Drift: float = None
-			self.Delta_F_199_P: float = None
-
-	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:SDEViation:EXTended \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.standardDev.extended.fetch(segment = repcap.Segment.Default) \n
-		Returns modulation single value results for segment<no> in list mode including Bluetooth version 5.0. The command returns
-		all parameters listed below, independent of the selected list mode setup. However, only for some of the parameters
-		measured values are available. For the other parameters, only an indicator is returned (e.g. NAV) . \n
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
-			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:SDEViation:EXTended?', self.__class__.FetchStruct())
+			self.Max_Drift: float = None
+
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:SDEViation \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le1M.standardDev.fetch() \n
+		Returns the standard deviation modulation results for LE 1M PHY in normal mode, see 'Normal mode classic: statistical
+		modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit
+		check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:SDEViation?', self.__class__.ResultData())
+
+	def read(self) -> ResultData:
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:SDEViation \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le1M.standardDev.read() \n
+		Returns the standard deviation modulation results for LE 1M PHY in normal mode, see 'Normal mode classic: statistical
+		modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit
+		check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:SDEViation?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Pencoding.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Pencoding.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,20 +2,20 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pencoding:
-	"""Pencoding commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PencodingCls:
+	"""Pencoding commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pencoding", core, parent)
+		self._cmd_group = CommandsGroup("pencoding", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Out_Of_Tol: float: No parameter help available
@@ -41,9 +41,9 @@
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PENCoding \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.pencoding.fetch(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PENCoding?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/PowerVsTime.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/PowerVsTime/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,51 +1,51 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class PowerVsTime:
-	"""PowerVsTime commands group definition. 4 total commands, 4 Sub-groups, 0 group commands"""
+class PowerVsTimeCls:
+	"""PowerVsTime commands group definition. 8 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("powerVsTime", core, parent)
+		self._cmd_group = CommandsGroup("powerVsTime", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_current'):
-			from .PowerVsTime_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
-
-	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_average'):
-			from .PowerVsTime_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
 
 	@property
 	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 1 commands."""
+		"""minimum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_minimum'):
-			from .PowerVsTime_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_maximum'):
-			from .PowerVsTime_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
+	def average(self):
+		"""average commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
+
+	@property
+	def current(self):
+		"""current commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
 
-	def clone(self) -> 'PowerVsTime':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PowerVsTimeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = PowerVsTime(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PowerVsTimeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/PowerVsTime_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/PowerVsTime/Current.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,25 +2,25 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
+			- Reliability: int: decimal 'Reliability indicator'
 			- Seg_Reliability: int: decimal Reliability indicator for the segment. The meaning of the returned values is the same as for the common reliability indicator, see previous parameter.
 			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Peak_Power: float: float Peak power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Leakage_Power: float: float Leakage power (BR, LE) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Gfsk_Power: float: float Average power within the GFSK modulated part of the burst (EDR) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Dpsk_Power: float: float Average power within the DPSK modulated part of the burst (EDR) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
@@ -51,16 +51,16 @@
 			self.Gfsk_Power: float = None
 			self.Dpsk_Power: float = None
 			self.Dpsk_Minus_Gfsk: float = None
 			self.Guard_Period: float = None
 			self.Peak_Minus_Avg: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PVTime:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.powerVsTime.average.fetch(segment = repcap.Segment.Default) \n
-		Returns statistical power vs. time single value results for segment<no> in list mode. The command returns all parameters
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PVTime:CURRent \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.powerVsTime.current.fetch(segment = repcap.Segment.Default) \n
+		Returns statistical power vs time single value results for segment<no> in list mode. The command returns all parameters
 		listed below, independent of the selected list mode setup. However, only for some of the parameters measured values are
 		available. For the other parameters, only an indicator is returned (e.g. NAV) . \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PVTime:AVERage?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PVTime:CURRent?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/PowerVsTime_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/PowerVsTime/Maximum.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,25 +2,25 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
+			- Reliability: int: decimal 'Reliability indicator'
 			- Seg_Reliability: int: decimal Reliability indicator for the segment. The meaning of the returned values is the same as for the common reliability indicator, see previous parameter.
 			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Peak_Power: float: float Peak power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Leakage_Power: float: float Leakage power (BR, LE) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Gfsk_Power: float: float Average power within the GFSK modulated part of the burst (EDR) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Dpsk_Power: float: float Average power within the DPSK modulated part of the burst (EDR) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
@@ -51,16 +51,16 @@
 			self.Gfsk_Power: float = None
 			self.Dpsk_Power: float = None
 			self.Dpsk_Minus_Gfsk: float = None
 			self.Guard_Period: float = None
 			self.Peak_Minus_Avg: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PVTime:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.powerVsTime.current.fetch(segment = repcap.Segment.Default) \n
-		Returns statistical power vs. time single value results for segment<no> in list mode. The command returns all parameters
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PVTime:MAXimum \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.powerVsTime.maximum.fetch(segment = repcap.Segment.Default) \n
+		Returns statistical power vs time single value results for segment<no> in list mode. The command returns all parameters
 		listed below, independent of the selected list mode setup. However, only for some of the parameters measured values are
 		available. For the other parameters, only an indicator is returned (e.g. NAV) . \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PVTime:CURRent?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PVTime:MAXimum?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/PowerVsTime_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/PowerVsTime/Average.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,66 +1,92 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.StructBase import StructBase
+from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
-	class FetchStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Seg_Reliability: int: decimal Reliability indicator for the segment. The meaning of the returned values is the same as for the common reliability indicator, see previous parameter.
-			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Power: float: float Peak power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Leakage_Power: float: float Leakage power (BR, LE) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Gfsk_Power: float: float Average power within the GFSK modulated part of the burst (EDR) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Dpsk_Power: float: float Average power within the DPSK modulated part of the burst (EDR) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Dpsk_Minus_Gfsk: float: float Difference between the 8_DPSKPower and 7_GFSKPower (EDR) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Guard_Period: float: float Length of the guard band between the packet header and the EDR synchronization sequence (EDR) Range: 0 µs to 9.99 µs, Unit: s
-			- Peak_Minus_Avg: float: float Difference between the peak power and the average power in the burst (LE) Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: No parameter help available
+			- Bursts_Out_Of_Tol: float: No parameter help available
+			- Nominal_Power: float: No parameter help available
+			- Gfsk_Power: float: No parameter help available
+			- Dpsk_Power: float: No parameter help available
+			- Dpsk_Gfsk_Power: float: No parameter help available
+			- Guard_Period: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Seg_Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
+			ArgStruct.scalar_float('Bursts_Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
 			ArgStruct.scalar_float('Gfsk_Power'),
 			ArgStruct.scalar_float('Dpsk_Power'),
-			ArgStruct.scalar_float('Dpsk_Minus_Gfsk'),
-			ArgStruct.scalar_float('Guard_Period'),
-			ArgStruct.scalar_float('Peak_Minus_Avg')]
+			ArgStruct.scalar_float('Dpsk_Gfsk_Power'),
+			ArgStruct.scalar_float('Guard_Period')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Seg_Reliability: int = None
-			self.Out_Of_Tol: float = None
+			self.Bursts_Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
 			self.Gfsk_Power: float = None
 			self.Dpsk_Power: float = None
-			self.Dpsk_Minus_Gfsk: float = None
+			self.Dpsk_Gfsk_Power: float = None
 			self.Guard_Period: float = None
-			self.Peak_Minus_Avg: float = None
 
-	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PVTime:MAXimum \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.powerVsTime.maximum.fetch(segment = repcap.Segment.Default) \n
-		Returns statistical power vs. time single value results for segment<no> in list mode. The command returns all parameters
-		listed below, independent of the selected list mode setup. However, only for some of the parameters measured values are
-		available. For the other parameters, only an indicator is returned (e.g. NAV) . \n
-			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
-			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PVTime:MAXimum?', self.__class__.FetchStruct())
+	def read(self) -> ResultData:
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:HDR:PVTime:AVERage \n
+		Snippet: value: ResultData = driver.hdr.powerVsTime.average.read() \n
+		No command help available \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:HDR:PVTime:AVERage?', self.__class__.ResultData())
+
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:HDR:PVTime:AVERage \n
+		Snippet: value: ResultData = driver.hdr.powerVsTime.average.fetch() \n
+		No command help available \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:HDR:PVTime:AVERage?', self.__class__.ResultData())
+
+	# noinspection PyTypeChecker
+	class CalculateStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: No parameter help available
+			- Bursts_Out_Of_Tol: float or bool: No parameter help available
+			- Nominal_Power: float or bool: No parameter help available
+			- Gfsk_Power: float or bool: No parameter help available
+			- Dpsk_Power: float or bool: No parameter help available
+			- Dpsk_Gfsk_Power: float or bool: No parameter help available
+			- Guard_Period: float or bool: No parameter help available"""
+		__meta_args_list = [
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_float_ext('Bursts_Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Gfsk_Power'),
+			ArgStruct.scalar_float_ext('Dpsk_Power'),
+			ArgStruct.scalar_float_ext('Dpsk_Gfsk_Power'),
+			ArgStruct.scalar_float_ext('Guard_Period')]
+
+		def __init__(self):
+			StructBase.__init__(self, self)
+			self.Reliability: int = None
+			self.Bursts_Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Gfsk_Power: float or bool = None
+			self.Dpsk_Power: float or bool = None
+			self.Dpsk_Gfsk_Power: float or bool = None
+			self.Guard_Period: float or bool = None
+
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:HDR:PVTime:AVERage \n
+		Snippet: value: CalculateStruct = driver.hdr.powerVsTime.average.calculate() \n
+		No command help available \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:HDR:PVTime:AVERage?', self.__class__.CalculateStruct())
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/PowerVsTime_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Xmaximum/Extended.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,66 +1,73 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ExtendedCls:
+	"""Extended commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("extended", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
+			- Reliability: int: decimal 'Reliability indicator'
 			- Seg_Reliability: int: decimal Reliability indicator for the segment. The meaning of the returned values is the same as for the common reliability indicator, see previous parameter.
-			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 %
+			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 % , Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Power: float: float Peak power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Leakage_Power: float: float Leakage power (BR, LE) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Gfsk_Power: float: float Average power within the GFSK modulated part of the burst (EDR) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Dpsk_Power: float: float Average power within the DPSK modulated part of the burst (EDR) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Dpsk_Minus_Gfsk: float: float Difference between the 8_DPSKPower and 7_GFSKPower (EDR) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Guard_Period: float: float Length of the guard band between the packet header and the EDR synchronization sequence (EDR) Range: 0 µs to 9.99 µs, Unit: s
-			- Peak_Minus_Avg: float: float Difference between the peak power and the average power in the burst (LE) Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Freq_Acc_Or_Init_Freq_Error: float: float Frequency accuracy (BR, LE) or initial center frequency error ωi (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float: float Frequency drift (BR, LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift_Rate: float: float Maximal drift rate (BR, LE) Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Offset: float: float Frequency offset (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Init_Freq_Drift: float: float Initial frequency drift (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Cte_Freq_Drift: float: float Frequency drift of CTE portion Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Cte_Mx_Drift_Rate: float: No parameter help available
+			- Cte_Freq_Offset: float: float Frequency offset of CTE portion Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Cte_Int_Frq_Drift: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Gfsk_Power'),
-			ArgStruct.scalar_float('Dpsk_Power'),
-			ArgStruct.scalar_float('Dpsk_Minus_Gfsk'),
-			ArgStruct.scalar_float('Guard_Period'),
-			ArgStruct.scalar_float('Peak_Minus_Avg')]
+			ArgStruct.scalar_float('Freq_Acc_Or_Init_Freq_Error'),
+			ArgStruct.scalar_float('Freq_Drift'),
+			ArgStruct.scalar_float('Max_Drift_Rate'),
+			ArgStruct.scalar_float('Freq_Offset'),
+			ArgStruct.scalar_float('Init_Freq_Drift'),
+			ArgStruct.scalar_float('Cte_Freq_Drift'),
+			ArgStruct.scalar_float('Cte_Mx_Drift_Rate'),
+			ArgStruct.scalar_float('Cte_Freq_Offset'),
+			ArgStruct.scalar_float('Cte_Int_Frq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Gfsk_Power: float = None
-			self.Dpsk_Power: float = None
-			self.Dpsk_Minus_Gfsk: float = None
-			self.Guard_Period: float = None
-			self.Peak_Minus_Avg: float = None
+			self.Freq_Acc_Or_Init_Freq_Error: float = None
+			self.Freq_Drift: float = None
+			self.Max_Drift_Rate: float = None
+			self.Freq_Offset: float = None
+			self.Init_Freq_Drift: float = None
+			self.Cte_Freq_Drift: float = None
+			self.Cte_Mx_Drift_Rate: float = None
+			self.Cte_Freq_Offset: float = None
+			self.Cte_Int_Frq_Drift: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PVTime:MINimum \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.powerVsTime.minimum.fetch(segment = repcap.Segment.Default) \n
-		Returns statistical power vs. time single value results for segment<no> in list mode. The command returns all parameters
-		listed below, independent of the selected list mode setup. However, only for some of the parameters measured values are
-		available. For the other parameters, only an indicator is returned (e.g. NAV) . \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:XMAXimum:EXTended \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.xmaximum.extended.fetch(segment = repcap.Segment.Default) \n
+		Returns single extreme minimum and maximum (xmin and xmax) value modulation results for segment<no> in list mode
+		including Bluetooth version 5.0 and higher. The command returns all parameters listed below, independent of the selected
+		list mode setup. However, only for some of the parameters measured values are available. For the other parameters, only
+		an indicator is returned (e.g. NAV) . \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PVTime:MINimum?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:XMAXimum:EXTended?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Sacp.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sgacp/Edrate/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sacp:
-	"""Sacp commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class EdrateCls:
+	"""Edrate commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sacp", core, parent)
+		self._cmd_group = CommandsGroup("edrate", core, parent)
 
 	@property
 	def ptx(self):
-		"""ptx commands group. 0 Sub-classes, 1 commands."""
+		"""ptx commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_ptx'):
-			from .Sacp_.Ptx import Ptx
-			self._ptx = Ptx(self._core, self._base)
+			from .Ptx import PtxCls
+			self._ptx = PtxCls(self._core, self._cmd_group)
 		return self._ptx
 
-	def clone(self) -> 'Sacp':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EdrateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Sacp(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EdrateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/Sacp_/Ptx.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Sacp/Ptx.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,25 +5,25 @@
 from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ptx:
-	"""Ptx commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PtxCls:
+	"""Ptx commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ptx", core, parent)
+		self._cmd_group = CommandsGroup("ptx", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
+			- Reliability: int: decimal 'Reliability indicator'
 			- Seg_Reliability: int: decimal Reliability indicator for the segment. The meaning of the returned values is the same as for the common reliability indicator, see previous parameter.
 			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- No_Of_Exceptions: int: decimal Number of exceptions, whose power is above 'Exception PTX' Range: 0 to 99
 			- Ptx_Ref: float: float Reference power obtained within the center channel (EDR) Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Ptx_N_26_Ch_N_1_Abs: float: No parameter help available
 			- Ptx_N_26_Ch_P_1_Abs: float: No parameter help available
@@ -61,9 +61,9 @@
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SACP[:PTX] \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.sacp.ptx.fetch(segment = repcap.Segment.Default) \n
 		Returns spectrum ACP single value results for segment<no> in list mode. The command returns all parameters listed below,
 		independent of the selected list mode setup. However, only for some of the parameters measured values are available. For
 		the other parameters, only an indicator is returned (e.g. NAV) . \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SACP:PTX?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/SoBw.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/SoBw/Brate/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SoBw:
-	"""SoBw commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class BrateCls:
+	"""Brate commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("soBw", core, parent)
+		self._cmd_group = CommandsGroup("brate", core, parent)
 
 	@property
 	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 1 commands."""
+		"""maximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_maximum'):
-			from .SoBw_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'SoBw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'BrateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = SoBw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = BrateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/ListPy_/Segment_/SoBw_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/SoBw/Maximum.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,25 +2,25 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
+			- Reliability: int: decimal 'Reliability indicator'
 			- Seg_Reliability: int: decimal Reliability indicator for the segment. The meaning of the returned values is the same as for the common reliability indicator, see previous parameter.
 			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Peak_Emission: float: float Peak power within the maximum spectral trace Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Fl: float: float The smallest frequency at which the transmit power drops 20 dB below the peak power Range: -0.99999E+6 MHz to 0.99999E+6 MHz, Unit: Hz
 			- Fh: float: float The highest frequency at which the transmit power drops 20 dB below the peak power Range: -0.99999E+6 MHz to 0.99999E+6 MHz, Unit: Hz
 			- Fh_Min_Fl: float: float Difference between the 7_fH and 6_fL Range: -0.99999E+6 MHz to 0.99999E+6 MHz, Unit: Hz"""
@@ -48,9 +48,9 @@
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SOBW:MAXimum \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.soBw.maximum.fetch(segment = repcap.Segment.Default) \n
 		Returns spectrum occupied bandwidth (20 dB bandwidth) single value results for segment<no> in list mode.
 		The 20 dB bandwidth measurement is available for BR bursts only. \n
 			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SOBW:MAXimum?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Modulation:
-	"""Modulation commands group definition. 228 total commands, 5 Sub-groups, 0 group commands"""
+class TraceCls:
+	"""Trace commands group definition. 32 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("modulation", core, parent)
+		self._cmd_group = CommandsGroup("trace", core, parent)
 
 	@property
-	def nmode(self):
-		"""nmode commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_nmode'):
-			from .Modulation_.Nmode import Nmode
-			self._nmode = Nmode(self._core, self._base)
-		return self._nmode
+	def sacp(self):
+		"""sacp commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_sacp'):
+			from .Sacp import SacpCls
+			self._sacp = SacpCls(self._core, self._cmd_group)
+		return self._sacp
 
 	@property
-	def cte(self):
-		"""cte commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_cte'):
-			from .Modulation_.Cte import Cte
-			self._cte = Cte(self._core, self._base)
-		return self._cte
+	def iqOffset(self):
+		"""iqOffset commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_iqOffset'):
+			from .IqOffset import IqOffsetCls
+			self._iqOffset = IqOffsetCls(self._core, self._cmd_group)
+		return self._iqOffset
 
 	@property
-	def brate(self):
-		"""brate commands group. 8 Sub-classes, 0 commands."""
-		if not hasattr(self, '_brate'):
-			from .Modulation_.Brate import Brate
-			self._brate = Brate(self._core, self._base)
-		return self._brate
+	def iqAbs(self):
+		"""iqAbs commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_iqAbs'):
+			from .IqAbs import IqAbsCls
+			self._iqAbs = IqAbsCls(self._core, self._cmd_group)
+		return self._iqAbs
 
 	@property
-	def edrate(self):
-		"""edrate commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_edrate'):
-			from .Modulation_.Edrate import Edrate
-			self._edrate = Edrate(self._core, self._base)
-		return self._edrate
+	def evMagnitude(self):
+		"""evMagnitude commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_evMagnitude'):
+			from .EvMagnitude import EvMagnitudeCls
+			self._evMagnitude = EvMagnitudeCls(self._core, self._cmd_group)
+		return self._evMagnitude
 
 	@property
-	def lowEnergy(self):
-		"""lowEnergy commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_lowEnergy'):
-			from .Modulation_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
-		return self._lowEnergy
+	def powerVsTime(self):
+		"""powerVsTime commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_powerVsTime'):
+			from .PowerVsTime import PowerVsTimeCls
+			self._powerVsTime = PowerVsTimeCls(self._core, self._cmd_group)
+		return self._powerVsTime
 
-	def clone(self) -> 'Modulation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'TraceCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Modulation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TraceCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Brate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Lrange/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,83 +1,83 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Brate:
-	"""Brate commands group definition. 22 total commands, 8 Sub-groups, 0 group commands"""
+class LrangeCls:
+	"""Lrange commands group definition. 24 total commands, 8 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("brate", core, parent)
+		self._cmd_group = CommandsGroup("lrange", core, parent)
 
 	@property
 	def xmaximum(self):
 		"""xmaximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_xmaximum'):
-			from .Brate_.Xmaximum import Xmaximum
-			self._xmaximum = Xmaximum(self._core, self._base)
+			from .Xmaximum import XmaximumCls
+			self._xmaximum = XmaximumCls(self._core, self._cmd_group)
 		return self._xmaximum
 
 	@property
 	def xminimum(self):
 		"""xminimum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_xminimum'):
-			from .Brate_.Xminimum import Xminimum
-			self._xminimum = Xminimum(self._core, self._base)
+			from .Xminimum import XminimumCls
+			self._xminimum = XminimumCls(self._core, self._cmd_group)
 		return self._xminimum
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Brate_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Brate_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_average'):
-			from .Brate_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
-
-	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Brate_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
+	def average(self):
+		"""average commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
+
+	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Brate_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
 	@property
-	def yieldPy(self):
-		"""yieldPy commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_yieldPy'):
-			from .Brate_.YieldPy import YieldPy
-			self._yieldPy = YieldPy(self._core, self._base)
-		return self._yieldPy
+	def stDev(self):
+		"""stDev commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_stDev'):
+			from .StDev import StDevCls
+			self._stDev = StDevCls(self._core, self._cmd_group)
+		return self._stDev
 
-	def clone(self) -> 'Brate':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LrangeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Brate(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LrangeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Brate_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Brate/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,86 +2,86 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
 			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:AVERage \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.brate.average.calculate() \n
 		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for BR packets. The
 		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:AVERage?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Brate_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Brate/Current.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,86 +2,86 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
 			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:CURRent \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.brate.current.calculate() \n
 		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for BR packets. The
 		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:CURRent?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Brate_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Lrange/Xmaximum.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,141 +1,122 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
-from ..... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XmaximumCls:
+	"""Xmaximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("xmaximum", core, parent)
 
 	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
+			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
+			ArgStruct.scalar_float('Delta_F_199_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
 			ArgStruct.scalar_float('Freq_Drift'),
 			ArgStruct.scalar_float('Max_Drift'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2)]
+			ArgStruct.scalar_float('Freq_Offset')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
+			self.Delta_F_199_P_9: float = None
 			self.Freq_Accuracy: float = None
 			self.Freq_Drift: float = None
 			self.Max_Drift: float = None
 			self.Freq_Dev_Avg_F_1: float = None
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
 			self.Nominal_Power: float = None
-			self.Mod_Ratio: enums.ResultStatus2 = None
+			self.Freq_Offset: float = None
 
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.brate.maximum.calculate() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for BR packets. The
-		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MAXimum?', self.__class__.CalculateStruct())
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:XMAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.xmaximum.fetch() \n
+		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
+		see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:XMAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
-	class ResultData(StructBase):
+	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Delta_F_199_P_9: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Mod_Ratio')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_199_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Freq_Offset')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
-			self.Mod_Ratio: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_199_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Freq_Offset: float or bool = None
 
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.brate.maximum.fetch() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for BR packets. The
-		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MAXimum?', self.__class__.ResultData())
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:XMAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.lrange.xmaximum.calculate() \n
+		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
+		see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:XMAXimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.brate.maximum.read() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for BR packets. The
-		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:XMAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.xmaximum.read() \n
+		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
+		see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:XMAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Brate_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le1M/Minimum.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,120 +1,123 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
-from ..... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
+			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2)]
+			ArgStruct.scalar_float('Mod_Ratio')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
 			self.Delta_F_299_P_9: float = None
 			self.Freq_Dev_Avg_F_1: float = None
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
 			self.Freq_Dev_Avg_F_2: float = None
 			self.Freq_Dev_Min_F_2: float = None
 			self.Freq_Dev_Max_F_2: float = None
 			self.Nominal_Power: float = None
-			self.Mod_Ratio: enums.ResultStatus2 = None
+			self.Mod_Ratio: float = None
 
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.brate.minimum.calculate() \n
-		Returns the minimum modulation results for BR packets. The values described below are returned by FETCh and READ commands.
-		CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MINimum?', self.__class__.CalculateStruct())
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:MINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.minimum.fetch() \n
+		Returns the minimum modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation
+		statistics'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:MINimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
-	class ResultData(StructBase):
+	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Mod_Ratio')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
-			self.Mod_Ratio: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Mod_Ratio: enums.ResultStatus2 = None
 
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.brate.minimum.fetch() \n
-		Returns the minimum modulation results for BR packets. The values described below are returned by FETCh and READ commands.
-		CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MINimum?', self.__class__.ResultData())
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:MINimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le1M.minimum.calculate() \n
+		Returns the minimum modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation
+		statistics'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:MINimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.brate.minimum.read() \n
-		Returns the minimum modulation results for BR packets. The values described below are returned by FETCh and READ commands.
-		CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:MINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.minimum.read() \n
+		Returns the minimum modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation
+		statistics'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:MINimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Brate_/StandardDev.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Brate/StandardDev.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,67 +2,67 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Nominal_Power: float: float Average power during the carrier-on state Range: 0 dB to 79 dB , Unit: dB
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: 0 dB to 79 dB , Unit: dB
 			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
 			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:SDEViation \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.brate.standardDev.calculate() \n
 		Returns the standard deviation of the modulation results for BR packets. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:SDEViation?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Nominal_Power: float: float Average power during the carrier-on state Range: 0 dB to 79 dB , Unit: dB
 			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Brate_/Xmaximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/Classic/Average.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,141 +1,122 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
-from ..... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Xmaximum:
-	"""Xmaximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("xmaximum", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (BR) ' and 'Modulation limits (EDR) '. Range: 0 % to 100 %
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2)]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
-			self.Mod_Ratio: enums.ResultStatus2 = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.brate.xmaximum.calculate() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for BR packets. The
-		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:AVERage \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.classic.average.calculate() \n
+		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'Normal mode classic:
+		statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands
+		return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:AVERage?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (BR) ' and 'Modulation limits (EDR) '. Range: 0 % to 100 %
+			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz
+			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
+			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
+			- Freq_Dev_Max_F_2: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
 			ArgStruct.scalar_float('Freq_Drift'),
 			ArgStruct.scalar_float('Max_Drift'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Mod_Ratio')]
+			ArgStruct.scalar_float('Freq_Dev_Max_F_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
 			self.Freq_Accuracy: float = None
 			self.Freq_Drift: float = None
 			self.Max_Drift: float = None
 			self.Freq_Dev_Avg_F_1: float = None
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
 			self.Freq_Dev_Avg_F_2: float = None
 			self.Freq_Dev_Min_F_2: float = None
 			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
-			self.Mod_Ratio: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.brate.xmaximum.fetch() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for BR packets. The
-		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.classic.average.fetch() \n
+		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'Normal mode classic:
+		statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands
+		return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:AVERage?', self.__class__.ResultData())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.brate.xmaximum.read() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for BR packets. The
-		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.classic.average.read() \n
+		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'Normal mode classic:
+		statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands
+		return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Brate_/Xminimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Brate/Xmaximum.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,86 +2,86 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Xminimum:
-	"""Xminimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XmaximumCls:
+	"""Xmaximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("xminimum", core, parent)
+		self._cmd_group = CommandsGroup("xmaximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
 			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.brate.xminimum.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.brate.xmaximum.calculate() \n
 		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for BR packets. The
 		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMINimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMAXimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
@@ -119,23 +119,23 @@
 			self.Freq_Dev_Avg_F_2: float = None
 			self.Freq_Dev_Min_F_2: float = None
 			self.Freq_Dev_Max_F_2: float = None
 			self.Nominal_Power: float = None
 			self.Mod_Ratio: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.brate.xminimum.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.brate.xmaximum.fetch() \n
 		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for BR packets. The
 		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMAXimum?', self.__class__.ResultData())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.brate.xminimum.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.brate.xmaximum.read() \n
 		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for BR packets. The
 		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Brate_/YieldPy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Brate/YieldPy.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class YieldPy:
-	"""YieldPy commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class YieldPyCls:
+	"""YieldPy commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("yieldPy", core, parent)
+		self._cmd_group = CommandsGroup("yieldPy", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:YIELd \n
 		Snippet: value: List[float] = driver.multiEval.modulation.brate.yieldPy.fetch() \n
 		Returns the percentages of auto-detected BR packets with a particular pattern type. A result is available after the R&S
 		CMW has auto-detected a packet (method RsCmwBluetoothMeas.Configure.InputSignal.dmodeAUTO) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/RxQuality/Search/Limit/Mper/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cte:
-	"""Cte commands group definition. 36 total commands, 1 Sub-groups, 0 group commands"""
+class MperCls:
+	"""Mper commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cte", core, parent)
+		self._cmd_group = CommandsGroup("mper", core, parent)
 
 	@property
 	def lowEnergy(self):
-		"""lowEnergy commands group. 2 Sub-classes, 0 commands."""
+		"""lowEnergy commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_lowEnergy'):
-			from .Cte_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
 		return self._lowEnergy
 
-	def clone(self) -> 'Cte':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MperCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cte(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MperCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cte/LowEnergy/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 36 total commands, 2 Sub-groups, 0 group commands"""
+class LowEnergyCls:
+	"""LowEnergy commands group definition. 4 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
-
-	@property
-	def le2M(self):
-		"""le2M commands group. 6 Sub-classes, 0 commands."""
-		if not hasattr(self, '_le2M'):
-			from .LowEnergy_.Le2M import Le2M
-			self._le2M = Le2M(self._core, self._base)
-		return self._le2M
+		self._cmd_group = CommandsGroup("lowEnergy", core, parent)
 
 	@property
 	def le1M(self):
-		"""le1M commands group. 6 Sub-classes, 0 commands."""
+		"""le1M commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_le1M'):
-			from .LowEnergy_.Le1M import Le1M
-			self._le1M = Le1M(self._core, self._base)
+			from .Le1M import Le1MCls
+			self._le1M = Le1MCls(self._core, self._cmd_group)
 		return self._le1M
 
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def le2M(self):
+		"""le2M commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_le2M'):
+			from .Le2M import Le2MCls
+			self._le2M = Le2MCls(self._core, self._cmd_group)
+		return self._le2M
+
+	def clone(self) -> 'LowEnergyCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LowEnergyCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le1M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le1M/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,67 +1,67 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le1M:
-	"""Le1M commands group definition. 18 total commands, 6 Sub-groups, 0 group commands"""
+class Le1MCls:
+	"""Le1M commands group definition. 18 total commands, 6 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le1M", core, parent)
+		self._cmd_group = CommandsGroup("le1M", core, parent)
 
 	@property
 	def xmaximum(self):
 		"""xmaximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_xmaximum'):
-			from .Le1M_.Xmaximum import Xmaximum
-			self._xmaximum = Xmaximum(self._core, self._base)
+			from .Xmaximum import XmaximumCls
+			self._xmaximum = XmaximumCls(self._core, self._cmd_group)
 		return self._xmaximum
 
 	@property
 	def xminimum(self):
 		"""xminimum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_xminimum'):
-			from .Le1M_.Xminimum import Xminimum
-			self._xminimum = Xminimum(self._core, self._base)
+			from .Xminimum import XminimumCls
+			self._xminimum = XminimumCls(self._core, self._cmd_group)
 		return self._xminimum
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Le1M_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Le1M_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Le1M_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Le1M_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Le1M':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'Le1MCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Le1M(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = Le1MCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le1M_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le1M/Maximum.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -35,58 +35,58 @@
 			self.Out_Of_Tol: float = None
 			self.Freq_Drift: float = None
 			self.Max_Drift: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le1M.average.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le1M.maximum.fetch() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:MAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.cte.lowEnergy.le1M.average.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:MAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.cte.lowEnergy.le1M.maximum.calculate() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:MAXimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le1M.average.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le1M.maximum.read() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le1M_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le2M/Current.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -35,58 +35,58 @@
 			self.Out_Of_Tol: float = None
 			self.Freq_Drift: float = None
 			self.Max_Drift: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le1M.current.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le2M.current.fetch() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.cte.lowEnergy.le1M.current.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:CURRent \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.cte.lowEnergy.le2M.current.calculate() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:CURRent?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le1M.current.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le2M.current.read() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:CURRent?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le1M_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le2M/Maximum.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -35,58 +35,58 @@
 			self.Out_Of_Tol: float = None
 			self.Freq_Drift: float = None
 			self.Max_Drift: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le1M.maximum.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le2M.maximum.fetch() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:MAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.cte.lowEnergy.le1M.maximum.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:MAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.cte.lowEnergy.le2M.maximum.calculate() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:MAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:MAXimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le1M.maximum.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le2M.maximum.read() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le1M_/StandardDev.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le1M/StandardDev.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -46,36 +46,36 @@
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:SDEViation?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:SDEViation \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.cte.lowEnergy.le1M.standardDev.calculate() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le1M_/Xmaximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le2M/Xmaximum.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Xmaximum:
-	"""Xmaximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XmaximumCls:
+	"""Xmaximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("xmaximum", core, parent)
+		self._cmd_group = CommandsGroup("xmaximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -35,58 +35,58 @@
 			self.Out_Of_Tol: float = None
 			self.Freq_Drift: float = None
 			self.Max_Drift: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:XMAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le1M.xmaximum.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:XMAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le2M.xmaximum.fetch() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:XMAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:XMAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:XMAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.cte.lowEnergy.le1M.xmaximum.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:XMAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.cte.lowEnergy.le2M.xmaximum.calculate() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:XMAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:XMAXimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:XMAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le1M.xmaximum.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:XMAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le2M.xmaximum.read() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:XMAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:XMAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le1M_/Xminimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le1M/Xminimum.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Xminimum:
-	"""Xminimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XminimumCls:
+	"""Xminimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("xminimum", core, parent)
+		self._cmd_group = CommandsGroup("xminimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -46,36 +46,36 @@
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:XMINimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:XMINimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.cte.lowEnergy.le1M.xminimum.calculate() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le2M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/Classic/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,67 +1,75 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le2M:
-	"""Le2M commands group definition. 18 total commands, 6 Sub-groups, 0 group commands"""
+class ClassicCls:
+	"""Classic commands group definition. 21 total commands, 7 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le2M", core, parent)
+		self._cmd_group = CommandsGroup("classic", core, parent)
 
 	@property
 	def xmaximum(self):
 		"""xmaximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_xmaximum'):
-			from .Le2M_.Xmaximum import Xmaximum
-			self._xmaximum = Xmaximum(self._core, self._base)
+			from .Xmaximum import XmaximumCls
+			self._xmaximum = XmaximumCls(self._core, self._cmd_group)
 		return self._xmaximum
 
 	@property
 	def xminimum(self):
 		"""xminimum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_xminimum'):
-			from .Le2M_.Xminimum import Xminimum
-			self._xminimum = Xminimum(self._core, self._base)
+			from .Xminimum import XminimumCls
+			self._xminimum = XminimumCls(self._core, self._cmd_group)
 		return self._xminimum
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Le2M_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_current'):
-			from .Le2M_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
-
-	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Le2M_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
+
+	@property
+	def current(self):
+		"""current commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
+
+	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Le2M_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Le2M':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ClassicCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Le2M(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ClassicCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le2M_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le1M/Xmaximum.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XmaximumCls:
+	"""Xmaximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("xmaximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -35,58 +35,58 @@
 			self.Out_Of_Tol: float = None
 			self.Freq_Drift: float = None
 			self.Max_Drift: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le2M.average.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:XMAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le1M.xmaximum.fetch() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:XMAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.cte.lowEnergy.le2M.average.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:XMAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.cte.lowEnergy.le1M.xmaximum.calculate() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:XMAXimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le2M.average.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:XMAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le1M.xmaximum.read() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:XMAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le2M_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le1M/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -35,58 +35,58 @@
 			self.Out_Of_Tol: float = None
 			self.Freq_Drift: float = None
 			self.Max_Drift: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le2M.current.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le1M.current.fetch() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.cte.lowEnergy.le2M.current.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:CURRent \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.cte.lowEnergy.le1M.current.calculate() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:CURRent?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le2M.current.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le1M.current.read() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:CURRent?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le2M_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le1M/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -35,58 +35,58 @@
 			self.Out_Of_Tol: float = None
 			self.Freq_Drift: float = None
 			self.Max_Drift: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le2M.maximum.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le1M.average.fetch() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.cte.lowEnergy.le2M.maximum.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:AVERage \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.cte.lowEnergy.le1M.average.calculate() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:MAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:AVERage?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le2M.maximum.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le1M.average.read() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE1M:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le2M_/StandardDev.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le2M/StandardDev.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -46,36 +46,36 @@
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:SDEViation?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:SDEViation \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.cte.lowEnergy.le2M.standardDev.calculate() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le2M_/Xmaximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le2M/Average.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Xmaximum:
-	"""Xmaximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("xmaximum", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -35,58 +35,58 @@
 			self.Out_Of_Tol: float = None
 			self.Freq_Drift: float = None
 			self.Max_Drift: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:XMAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le2M.xmaximum.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le2M.average.fetch() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:XMAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:XMAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.cte.lowEnergy.le2M.xmaximum.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:AVERage \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.cte.lowEnergy.le2M.average.calculate() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:XMAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:AVERage?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:XMAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le2M.xmaximum.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.modulation.cte.lowEnergy.le2M.average.read() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:XMAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Cte_/LowEnergy_/Le2M_/Xminimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le2M/Xminimum.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Xminimum:
-	"""Xminimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XminimumCls:
+	"""Xminimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("xminimum", core, parent)
+		self._cmd_group = CommandsGroup("xminimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -46,36 +46,36 @@
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:XMINimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz , Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:CTE:LENergy:LE2M:XMINimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.cte.lowEnergy.le2M.xminimum.calculate() \n
 		Returns current, average, standard deviation, absolute min (xmin) , absolute max (xmax) , and max CTE modulation results
 		for LE uncoded PHY (LE 1M PHY, LE 2M PHY) . The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Edrate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Fdeviation/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Edrate:
-	"""Edrate commands group definition. 14 total commands, 4 Sub-groups, 0 group commands"""
+class FdeviationCls:
+	"""Fdeviation commands group definition. 8 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("edrate", core, parent)
+		self._cmd_group = CommandsGroup("fdeviation", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 1 Sub-classes, 3 commands."""
+		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Edrate_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 3 commands."""
+		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Edrate_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
+
+	@property
 	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Edrate_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Edrate_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'Edrate':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'FdeviationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Edrate(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = FdeviationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Edrate_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Edrate/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,69 +1,69 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Omega_I: float: float Initial center frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Omega_Iplus_Omega_0_Max: float: float Maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Omega_0_Max: float: float Maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Rms_Devm: float: float Differential EVM results Range: 0 to 1
-			- Peak_Devm: float: float Range: 0 to 1
-			- P_99_Devm: float: float Range: 0 to 1
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Omega_I: float or bool: float Initial center frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Omega_Iplus_Omega_0_Max: float or bool: float Maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Omega_0_Max: float or bool: float Maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Rms_Devm: float or bool: float Differential EVM results Range: 0 to 1
+			- Peak_Devm: float or bool: float Range: 0 to 1
+			- P_99_Devm: float or bool: float Range: 0 to 1
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Omega_I'),
-			ArgStruct.scalar_float('Omega_Iplus_Omega_0_Max'),
-			ArgStruct.scalar_float('Omega_0_Max'),
-			ArgStruct.scalar_float('Rms_Devm'),
-			ArgStruct.scalar_float('Peak_Devm'),
-			ArgStruct.scalar_float('P_99_Devm'),
-			ArgStruct.scalar_float('Nominal_Power')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Omega_I'),
+			ArgStruct.scalar_float_ext('Omega_Iplus_Omega_0_Max'),
+			ArgStruct.scalar_float_ext('Omega_0_Max'),
+			ArgStruct.scalar_float_ext('Rms_Devm'),
+			ArgStruct.scalar_float_ext('Peak_Devm'),
+			ArgStruct.scalar_float_ext('P_99_Devm'),
+			ArgStruct.scalar_float_ext('Nominal_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Omega_I: float = None
-			self.Omega_Iplus_Omega_0_Max: float = None
-			self.Omega_0_Max: float = None
-			self.Rms_Devm: float = None
-			self.Peak_Devm: float = None
-			self.P_99_Devm: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Omega_I: float or bool = None
+			self.Omega_Iplus_Omega_0_Max: float or bool = None
+			self.Omega_0_Max: float or bool = None
+			self.Rms_Devm: float or bool = None
+			self.Peak_Devm: float or bool = None
+			self.P_99_Devm: float or bool = None
+			self.Nominal_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:AVERage \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.edrate.average.calculate() \n
 		Returns the modulation results for EDR packets. The values described below are returned by FETCh and READ commands.
 		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:AVERage?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
 			- Omega_I: float: float Initial center frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Omega_Iplus_Omega_0_Max: float: float Maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Omega_0_Max: float: float Maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Rms_Devm: float: float Differential EVM results Range: 0 to 1
 			- Peak_Devm: float: float Range: 0 to 1
 			- P_99_Devm: float: float Range: 0 to 1
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Edrate_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Edrate/Current/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,77 +1,77 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 5 total commands, 1 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 5 total commands, 1 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
 	def extended(self):
 		"""extended commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extended'):
-			from .Current_.Extended import Extended
-			self._extended = Extended(self._core, self._base)
+			from .Extended import ExtendedCls
+			self._extended = ExtendedCls(self._core, self._cmd_group)
 		return self._extended
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Omega_I: float: float Initial center frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Omega_Iplus_Omega_0_Max: float: float Maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Omega_0_Max: float: float Maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Rms_Devm: float: float Differential EVM results Range: 0 to 1
-			- Peak_Devm: float: float Range: 0 to 1
-			- P_99_Devm: float: float Range: 0 to 1
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Omega_I: float or bool: float Initial center frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Omega_Iplus_Omega_0_Max: float or bool: float Maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Omega_0_Max: float or bool: float Maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Rms_Devm: float or bool: float Differential EVM results Range: 0 to 1
+			- Peak_Devm: float or bool: float Range: 0 to 1
+			- P_99_Devm: float or bool: float Range: 0 to 1
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Omega_I'),
-			ArgStruct.scalar_float('Omega_Iplus_Omega_0_Max'),
-			ArgStruct.scalar_float('Omega_0_Max'),
-			ArgStruct.scalar_float('Rms_Devm'),
-			ArgStruct.scalar_float('Peak_Devm'),
-			ArgStruct.scalar_float('P_99_Devm'),
-			ArgStruct.scalar_float('Nominal_Power')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Omega_I'),
+			ArgStruct.scalar_float_ext('Omega_Iplus_Omega_0_Max'),
+			ArgStruct.scalar_float_ext('Omega_0_Max'),
+			ArgStruct.scalar_float_ext('Rms_Devm'),
+			ArgStruct.scalar_float_ext('Peak_Devm'),
+			ArgStruct.scalar_float_ext('P_99_Devm'),
+			ArgStruct.scalar_float_ext('Nominal_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Omega_I: float = None
-			self.Omega_Iplus_Omega_0_Max: float = None
-			self.Omega_0_Max: float = None
-			self.Rms_Devm: float = None
-			self.Peak_Devm: float = None
-			self.P_99_Devm: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Omega_I: float or bool = None
+			self.Omega_Iplus_Omega_0_Max: float or bool = None
+			self.Omega_0_Max: float or bool = None
+			self.Rms_Devm: float or bool = None
+			self.Peak_Devm: float or bool = None
+			self.P_99_Devm: float or bool = None
+			self.Nominal_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:CURRent \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.edrate.current.calculate() \n
 		Returns the modulation results for EDR packets. The values described below are returned by FETCh and READ commands.
 		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:CURRent?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
 			- Omega_I: float: float Initial center frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Omega_Iplus_Omega_0_Max: float: float Maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Omega_0_Max: float: float Maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Rms_Devm: float: float Differential EVM results Range: 0 to 1
 			- Peak_Devm: float: float Range: 0 to 1
 			- P_99_Devm: float: float Range: 0 to 1
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
@@ -110,14 +110,14 @@
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:CURRent \n
 		Snippet: value: ResultData = driver.multiEval.modulation.edrate.current.read() \n
 		Returns the modulation results for EDR packets. The values described below are returned by FETCh and READ commands.
 		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:CURRent?', self.__class__.ResultData())
 
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Edrate_/Current_/Extended.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Edrate/Current/Extended.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extended:
-	"""Extended commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtendedCls:
+	"""Extended commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extended", core, parent)
+		self._cmd_group = CommandsGroup("extended", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tol: float: No parameter help available
 			- Omega_I: float: No parameter help available
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Edrate_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Edrate/StandardDev.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,76 +1,76 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Omega_I: float: float Initial center frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Omega_Iplus_Omega_0_Max: float: float Maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Omega_0_Max: float: float Maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Rms_Devm: float: float Differential EVM results Range: 0 to 1
-			- Peak_Devm: float: float Range: 0 to 1
-			- P_99_Devm: float: float Range: 0 to 1
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Omega_I: float or bool: float Standard deviation of the initial center frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Omega_Iplus_Omega_0_Max: float or bool: float Standard deviation of the maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Omega_0_Max: float or bool: float Standard deviation of the maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Rms_Devm: float or bool: float Standard deviation of the differential EVM results Range: 0 to 1
+			- Peak_Devm: float or bool: float Range: 0 to 1
+			- P_99_Devm: float or bool: float Range: 0 to 1
+			- Nominal_Power: float or bool: float Standard deviation of the average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Omega_I'),
-			ArgStruct.scalar_float('Omega_Iplus_Omega_0_Max'),
-			ArgStruct.scalar_float('Omega_0_Max'),
-			ArgStruct.scalar_float('Rms_Devm'),
-			ArgStruct.scalar_float('Peak_Devm'),
-			ArgStruct.scalar_float('P_99_Devm'),
-			ArgStruct.scalar_float('Nominal_Power')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Omega_I'),
+			ArgStruct.scalar_float_ext('Omega_Iplus_Omega_0_Max'),
+			ArgStruct.scalar_float_ext('Omega_0_Max'),
+			ArgStruct.scalar_float_ext('Rms_Devm'),
+			ArgStruct.scalar_float_ext('Peak_Devm'),
+			ArgStruct.scalar_float_ext('P_99_Devm'),
+			ArgStruct.scalar_float_ext('Nominal_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Omega_I: float = None
-			self.Omega_Iplus_Omega_0_Max: float = None
-			self.Omega_0_Max: float = None
-			self.Rms_Devm: float = None
-			self.Peak_Devm: float = None
-			self.P_99_Devm: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Omega_I: float or bool = None
+			self.Omega_Iplus_Omega_0_Max: float or bool = None
+			self.Omega_0_Max: float or bool = None
+			self.Rms_Devm: float or bool = None
+			self.Peak_Devm: float or bool = None
+			self.P_99_Devm: float or bool = None
+			self.Nominal_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.edrate.maximum.calculate() \n
-		Returns the modulation results for EDR packets. The values described below are returned by FETCh and READ commands.
-		CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:SDEViation \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.edrate.standardDev.calculate() \n
+		Returns the standard deviation of the modulation results for EDR packets. The values described below are returned by
+		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:MAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:SDEViation?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Omega_I: float: float Initial center frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Omega_Iplus_Omega_0_Max: float: float Maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Omega_0_Max: float: float Maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Rms_Devm: float: float Differential EVM results Range: 0 to 1
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Omega_I: float: float Standard deviation of the initial center frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Omega_Iplus_Omega_0_Max: float: float Standard deviation of the maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Omega_0_Max: float: float Standard deviation of the maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Rms_Devm: float: float Standard deviation of the differential EVM results Range: 0 to 1
 			- Peak_Devm: float: float Range: 0 to 1
 			- P_99_Devm: float: float Range: 0 to 1
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Nominal_Power: float: float Standard deviation of the average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Omega_I'),
 			ArgStruct.scalar_float('Omega_Iplus_Omega_0_Max'),
 			ArgStruct.scalar_float('Omega_0_Max'),
 			ArgStruct.scalar_float('Rms_Devm'),
@@ -87,21 +87,21 @@
 			self.Omega_0_Max: float = None
 			self.Rms_Devm: float = None
 			self.Peak_Devm: float = None
 			self.P_99_Devm: float = None
 			self.Nominal_Power: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.edrate.maximum.fetch() \n
-		Returns the modulation results for EDR packets. The values described below are returned by FETCh and READ commands.
-		CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:SDEViation \n
+		Snippet: value: ResultData = driver.multiEval.modulation.edrate.standardDev.fetch() \n
+		Returns the standard deviation of the modulation results for EDR packets. The values described below are returned by
+		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:SDEViation?', self.__class__.ResultData())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.edrate.maximum.read() \n
-		Returns the modulation results for EDR packets. The values described below are returned by FETCh and READ commands.
-		CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:SDEViation \n
+		Snippet: value: ResultData = driver.multiEval.modulation.edrate.standardDev.read() \n
+		Returns the standard deviation of the modulation results for EDR packets. The values described below are returned by
+		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:SDEViation?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Edrate_/StandardDev.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Lrange/StandardDev.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,107 +1,104 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Omega_I: float: float Standard deviation of the initial center frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Omega_Iplus_Omega_0_Max: float: float Standard deviation of the maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Omega_0_Max: float: float Standard deviation of the maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Rms_Devm: float: float Standard deviation of the differential EVM results Range: 0 to 1
-			- Peak_Devm: float: float Range: 0 to 1
-			- P_99_Devm: float: float Range: 0 to 1
-			- Nominal_Power: float: float Standard deviation of the average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz
+			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
+			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
+			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Omega_I'),
-			ArgStruct.scalar_float('Omega_Iplus_Omega_0_Max'),
-			ArgStruct.scalar_float('Omega_0_Max'),
-			ArgStruct.scalar_float('Rms_Devm'),
-			ArgStruct.scalar_float('Peak_Devm'),
-			ArgStruct.scalar_float('P_99_Devm'),
-			ArgStruct.scalar_float('Nominal_Power')]
+			ArgStruct.scalar_float('Delta_F_199_P_9'),
+			ArgStruct.scalar_float('Freq_Accuracy'),
+			ArgStruct.scalar_float('Freq_Drift'),
+			ArgStruct.scalar_float('Max_Drift'),
+			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float('Freq_Offset')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
-			self.Omega_I: float = None
-			self.Omega_Iplus_Omega_0_Max: float = None
-			self.Omega_0_Max: float = None
-			self.Rms_Devm: float = None
-			self.Peak_Devm: float = None
-			self.P_99_Devm: float = None
+			self.Delta_F_199_P_9: float = None
+			self.Freq_Accuracy: float = None
+			self.Freq_Drift: float = None
+			self.Max_Drift: float = None
 			self.Nominal_Power: float = None
+			self.Freq_Offset: float = None
 
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:SDEViation \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.edrate.standardDev.calculate() \n
-		Returns the standard deviation of the modulation results for EDR packets. The values described below are returned by
-		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:SDEViation?', self.__class__.CalculateStruct())
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:SDEViation \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.standardDev.fetch() \n
+		Returns the standard deviation modulation results for LE coded PHY in normal mode, see 'Normal mode classic: statistical
+		modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit
+		check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:SDEViation?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
-	class ResultData(StructBase):
+	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Omega_I: float: float Standard deviation of the initial center frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Omega_Iplus_Omega_0_Max: float: float Standard deviation of the maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Omega_0_Max: float: float Standard deviation of the maximum compensated frequency error Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Rms_Devm: float: float Standard deviation of the differential EVM results Range: 0 to 1
-			- Peak_Devm: float: float Range: 0 to 1
-			- P_99_Devm: float: float Range: 0 to 1
-			- Nominal_Power: float: float Standard deviation of the average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Delta_F_199_P_9: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Nominal_Power: float or bool: float Range: -99.99 dBm to 99.99 dBm
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Omega_I'),
-			ArgStruct.scalar_float('Omega_Iplus_Omega_0_Max'),
-			ArgStruct.scalar_float('Omega_0_Max'),
-			ArgStruct.scalar_float('Rms_Devm'),
-			ArgStruct.scalar_float('Peak_Devm'),
-			ArgStruct.scalar_float('P_99_Devm'),
-			ArgStruct.scalar_float('Nominal_Power')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_199_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Freq_Offset')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Omega_I: float = None
-			self.Omega_Iplus_Omega_0_Max: float = None
-			self.Omega_0_Max: float = None
-			self.Rms_Devm: float = None
-			self.Peak_Devm: float = None
-			self.P_99_Devm: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_199_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Freq_Offset: float or bool = None
 
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.modulation.edrate.standardDev.fetch() \n
-		Returns the standard deviation of the modulation results for EDR packets. The values described below are returned by
-		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:SDEViation?', self.__class__.ResultData())
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:SDEViation \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.lrange.standardDev.calculate() \n
+		Returns the standard deviation modulation results for LE coded PHY in normal mode, see 'Normal mode classic: statistical
+		modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit
+		check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:SDEViation?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.modulation.edrate.standardDev.read() \n
-		Returns the standard deviation of the modulation results for EDR packets. The values described below are returned by
-		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:SDEViation \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.standardDev.read() \n
+		Returns the standard deviation modulation results for LE coded PHY in normal mode, see 'Normal mode classic: statistical
+		modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit
+		check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:EDRate:SDEViation?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:SDEViation?', self.__class__.ResultData())
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Edrate/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,43 +1,51 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 68 total commands, 3 Sub-groups, 0 group commands"""
+class EdrateCls:
+	"""Edrate commands group definition. 12 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("edrate", core, parent)
 
 	@property
-	def le1M(self):
-		"""le1M commands group. 8 Sub-classes, 0 commands."""
-		if not hasattr(self, '_le1M'):
-			from .LowEnergy_.Le1M import Le1M
-			self._le1M = Le1M(self._core, self._base)
-		return self._le1M
+	def current(self):
+		"""current commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
 
 	@property
-	def le2M(self):
-		"""le2M commands group. 8 Sub-classes, 0 commands."""
-		if not hasattr(self, '_le2M'):
-			from .LowEnergy_.Le2M import Le2M
-			self._le2M = Le2M(self._core, self._base)
-		return self._le2M
+	def average(self):
+		"""average commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
 
 	@property
-	def lrange(self):
-		"""lrange commands group. 8 Sub-classes, 0 commands."""
-		if not hasattr(self, '_lrange'):
-			from .LowEnergy_.Lrange import Lrange
-			self._lrange = Lrange(self._core, self._base)
-		return self._lrange
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
 
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	def clone(self) -> 'EdrateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EdrateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le1M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Lrange/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,83 +1,83 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le1M:
-	"""Le1M commands group definition. 22 total commands, 8 Sub-groups, 0 group commands"""
+class LrangeCls:
+	"""Lrange commands group definition. 24 total commands, 8 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le1M", core, parent)
+		self._cmd_group = CommandsGroup("lrange", core, parent)
 
 	@property
 	def xmaximum(self):
 		"""xmaximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_xmaximum'):
-			from .Le1M_.Xmaximum import Xmaximum
-			self._xmaximum = Xmaximum(self._core, self._base)
+			from .Xmaximum import XmaximumCls
+			self._xmaximum = XmaximumCls(self._core, self._cmd_group)
 		return self._xmaximum
 
 	@property
 	def xminimum(self):
 		"""xminimum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_xminimum'):
-			from .Le1M_.Xminimum import Xminimum
-			self._xminimum = Xminimum(self._core, self._base)
+			from .Xminimum import XminimumCls
+			self._xminimum = XminimumCls(self._core, self._cmd_group)
 		return self._xminimum
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Le1M_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Le1M_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Le1M_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Le1M_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Le1M_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
 	@property
-	def yieldPy(self):
-		"""yieldPy commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_yieldPy'):
-			from .Le1M_.YieldPy import YieldPy
-			self._yieldPy = YieldPy(self._core, self._base)
-		return self._yieldPy
+	def stDev(self):
+		"""stDev commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_stDev'):
+			from .StDev import StDevCls
+			self._stDev = StDevCls(self._core, self._cmd_group)
+		return self._stDev
 
-	def clone(self) -> 'Le1M':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LrangeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Le1M(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LrangeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le1M_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le2M/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,38 +2,38 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: float: float Range: 0 to 1
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
@@ -66,88 +66,88 @@
 			self.Freq_Dev_Max_F_2: float = None
 			self.Nominal_Power: float = None
 			self.Mod_Ratio: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.average.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.average.fetch() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: enums.ResultStatus2: float Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
 			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le1M.average.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:AVERage \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le2M.average.calculate() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:AVERage?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.average.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.average.read() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le1M_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le2M/Maximum.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,38 +2,38 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: float: float Range: 0 to 1
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
@@ -66,88 +66,88 @@
 			self.Freq_Dev_Max_F_2: float = None
 			self.Nominal_Power: float = None
 			self.Mod_Ratio: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.current.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.maximum.fetch() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: enums.ResultStatus2: float Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
 			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le1M.current.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le2M.maximum.calculate() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MAXimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.current.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.maximum.read() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le1M_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le1M/Maximum.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,38 +2,38 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: float: float Range: 0 to 1
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
@@ -69,85 +69,85 @@
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:MAXimum \n
 		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.maximum.fetch() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:MAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: enums.ResultStatus2: float Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
 			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:MAXimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le1M.maximum.calculate() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:MAXimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:MAXimum \n
 		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.maximum.read() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le1M_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le2M/Minimum.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,35 +2,35 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: float: float Range: 0 to 1"""
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
@@ -51,73 +51,73 @@
 			self.Freq_Dev_Avg_F_2: float = None
 			self.Freq_Dev_Min_F_2: float = None
 			self.Freq_Dev_Max_F_2: float = None
 			self.Nominal_Power: float = None
 			self.Mod_Ratio: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.minimum.fetch() \n
-		Returns the minimum modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation
-		Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.minimum.fetch() \n
+		Returns the minimum modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation
+		statistics'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MINimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: enums.ResultStatus2: float Range: 0 to 1"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
 			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:MINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le1M.minimum.calculate() \n
-		Returns the minimum modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation
-		Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MINimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le2M.minimum.calculate() \n
+		Returns the minimum modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation
+		statistics'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:MINimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MINimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.minimum.read() \n
-		Returns the minimum modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation
-		Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.minimum.read() \n
+		Returns the minimum modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation
+		statistics'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MINimum?', self.__class__.ResultData())
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le1M_/StandardDev.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le2M/StandardDev.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,32 +2,32 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: float: float Range: 0 to 1
+			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
@@ -48,70 +48,70 @@
 			self.Max_Drift: float = None
 			self.Nominal_Power: float = None
 			self.Mod_Ratio: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.standardDev.fetch() \n
-		Returns the standard deviation of the modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'LE: Statistical
-		Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit
-		check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:SDEViation \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.standardDev.fetch() \n
+		Returns the standard deviation of the modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'View TX
+		Measurement - modulation statistics'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:SDEViation?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:SDEViation?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: enums.ResultStatus2: float Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
 			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:SDEViation \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le1M.standardDev.calculate() \n
-		Returns the standard deviation of the modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'LE: Statistical
-		Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit
-		check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:SDEViation \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le2M.standardDev.calculate() \n
+		Returns the standard deviation of the modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'View TX
+		Measurement - modulation statistics'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:SDEViation?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:SDEViation?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.standardDev.read() \n
-		Returns the standard deviation of the modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'LE: Statistical
-		Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit
-		check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:SDEViation \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.standardDev.read() \n
+		Returns the standard deviation of the modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'View TX
+		Measurement - modulation statistics'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:SDEViation?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:SDEViation?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le1M_/Xmaximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le2M/Xminimum.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,38 +2,38 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Xmaximum:
-	"""Xmaximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XminimumCls:
+	"""Xminimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("xmaximum", core, parent)
+		self._cmd_group = CommandsGroup("xminimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: float: float Range: 0 to 1
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
@@ -66,88 +66,88 @@
 			self.Freq_Dev_Max_F_2: float = None
 			self.Nominal_Power: float = None
 			self.Mod_Ratio: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:XMAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.xmaximum.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.xminimum.fetch() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:XMAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMINimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: enums.ResultStatus2: float Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
 			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:XMAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le1M.xmaximum.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMINimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le2M.xminimum.calculate() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:XMAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMINimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:XMAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.xmaximum.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.xminimum.read() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:XMAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMINimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le1M_/Xminimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le1M/Xmaximum.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,38 +2,38 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Xminimum:
-	"""Xminimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XmaximumCls:
+	"""Xmaximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("xminimum", core, parent)
+		self._cmd_group = CommandsGroup("xmaximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: float: float Range: 0 to 1
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
@@ -66,88 +66,88 @@
 			self.Freq_Dev_Max_F_2: float = None
 			self.Nominal_Power: float = None
 			self.Mod_Ratio: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:XMINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.xminimum.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:XMAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.xmaximum.fetch() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:XMINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:XMAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: enums.ResultStatus2: float Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
 			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:XMINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le1M.xminimum.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:XMAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le1M.xmaximum.calculate() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:XMINimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:XMAXimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:XMINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.xminimum.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:XMAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.xmaximum.read() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:XMINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:XMAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le1M_/YieldPy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le1M/YieldPy.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class YieldPy:
-	"""YieldPy commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class YieldPyCls:
+	"""YieldPy commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("yieldPy", core, parent)
+		self._cmd_group = CommandsGroup("yieldPy", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:YIELd \n
 		Snippet: value: List[float] = driver.multiEval.modulation.lowEnergy.le1M.yieldPy.fetch() \n
 		Returns the percentages of auto-detected LE packets with a particular pattern type. Commands for uncoded LE 1M PHY (..
 		:LE1M..) and LE 2M PHY (..:LE2M..) are available. A result is available after the R&S CMW has auto-detected a packet
 		(method RsCmwBluetoothMeas.Configure.InputSignal.dmodeAUTO) . \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le2M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,83 +1,75 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le2M:
-	"""Le2M commands group definition. 22 total commands, 8 Sub-groups, 0 group commands"""
+class TraceCls:
+	"""Trace commands group definition. 34 total commands, 7 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le2M", core, parent)
+		self._cmd_group = CommandsGroup("trace", core, parent)
 
 	@property
-	def xmaximum(self):
-		"""xmaximum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_xmaximum'):
-			from .Le2M_.Xmaximum import Xmaximum
-			self._xmaximum = Xmaximum(self._core, self._base)
-		return self._xmaximum
-
-	@property
-	def xminimum(self):
-		"""xminimum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_xminimum'):
-			from .Le2M_.Xminimum import Xminimum
-			self._xminimum = Xminimum(self._core, self._base)
-		return self._xminimum
-
-	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Le2M_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
-
-	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Le2M_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
-
-	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_current'):
-			from .Le2M_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
-
-	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_average'):
-			from .Le2M_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
-
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Le2M_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	@property
-	def yieldPy(self):
-		"""yieldPy commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_yieldPy'):
-			from .Le2M_.YieldPy import YieldPy
-			self._yieldPy = YieldPy(self._core, self._base)
-		return self._yieldPy
+	def sgacp(self):
+		"""sgacp commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_sgacp'):
+			from .Sgacp import SgacpCls
+			self._sgacp = SgacpCls(self._core, self._cmd_group)
+		return self._sgacp
+
+	@property
+	def iqError(self):
+		"""iqError commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_iqError'):
+			from .IqError import IqErrorCls
+			self._iqError = IqErrorCls(self._core, self._cmd_group)
+		return self._iqError
+
+	@property
+	def iqDifference(self):
+		"""iqDifference commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_iqDifference'):
+			from .IqDifference import IqDifferenceCls
+			self._iqDifference = IqDifferenceCls(self._core, self._cmd_group)
+		return self._iqDifference
+
+	@property
+	def iqAbs(self):
+		"""iqAbs commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_iqAbs'):
+			from .IqAbs import IqAbsCls
+			self._iqAbs = IqAbsCls(self._core, self._cmd_group)
+		return self._iqAbs
+
+	@property
+	def pdifference(self):
+		"""pdifference commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_pdifference'):
+			from .Pdifference import PdifferenceCls
+			self._pdifference = PdifferenceCls(self._core, self._cmd_group)
+		return self._pdifference
+
+	@property
+	def devMagnitude(self):
+		"""devMagnitude commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_devMagnitude'):
+			from .DevMagnitude import DevMagnitudeCls
+			self._devMagnitude = DevMagnitudeCls(self._core, self._cmd_group)
+		return self._devMagnitude
+
+	@property
+	def powerVsTime(self):
+		"""powerVsTime commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_powerVsTime'):
+			from .PowerVsTime import PowerVsTimeCls
+			self._powerVsTime = PowerVsTimeCls(self._core, self._cmd_group)
+		return self._powerVsTime
 
-	def clone(self) -> 'Le2M':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'TraceCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Le2M(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TraceCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le2M_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le1M/Average.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,38 +2,38 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: float: float Range: 0 to 1
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
@@ -66,88 +66,88 @@
 			self.Freq_Dev_Max_F_2: float = None
 			self.Nominal_Power: float = None
 			self.Mod_Ratio: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.average.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.average.fetch() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: enums.ResultStatus2: float Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
 			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le2M.average.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:AVERage \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le1M.average.calculate() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:AVERage?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.average.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.average.read() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le2M_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le1M/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,38 +2,38 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: float: float Range: 0 to 1
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
@@ -66,88 +66,88 @@
 			self.Freq_Dev_Max_F_2: float = None
 			self.Nominal_Power: float = None
 			self.Mod_Ratio: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.current.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.current.fetch() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: enums.ResultStatus2: float Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
 			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le2M.current.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:CURRent \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le1M.current.calculate() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:CURRent?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.current.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.current.read() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:CURRent?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le2M_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le2M/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,38 +2,38 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: float: float Range: 0 to 1
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
@@ -66,88 +66,88 @@
 			self.Freq_Dev_Max_F_2: float = None
 			self.Nominal_Power: float = None
 			self.Mod_Ratio: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.maximum.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.current.fetch() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: enums.ResultStatus2: float Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
 			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le2M.maximum.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:CURRent \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le2M.current.calculate() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:CURRent?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.maximum.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.current.read() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:CURRent?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le2M_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Brate/Minimum.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,123 +1,120 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
-	class ResultData(StructBase):
+	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: float: float Range: 0 to 1"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Mod_Ratio')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
-			self.Mod_Ratio: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Mod_Ratio: enums.ResultStatus2 = None
 
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.minimum.fetch() \n
-		Returns the minimum modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation
-		Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
-		results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MINimum?', self.__class__.ResultData())
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MINimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.brate.minimum.calculate() \n
+		Returns the minimum modulation results for BR packets. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MINimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: enums.ResultStatus2: float Range: 0 to 1"""
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2)]
+			ArgStruct.scalar_float('Mod_Ratio')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
 			self.Delta_F_299_P_9: float = None
 			self.Freq_Dev_Avg_F_1: float = None
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
 			self.Freq_Dev_Avg_F_2: float = None
 			self.Freq_Dev_Min_F_2: float = None
 			self.Freq_Dev_Max_F_2: float = None
 			self.Nominal_Power: float = None
-			self.Mod_Ratio: enums.ResultStatus2 = None
+			self.Mod_Ratio: float = None
 
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le2M.minimum.calculate() \n
-		Returns the minimum modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation
-		Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
-		results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MINimum?', self.__class__.CalculateStruct())
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.brate.minimum.fetch() \n
+		Returns the minimum modulation results for BR packets. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MINimum?', self.__class__.ResultData())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.minimum.read() \n
-		Returns the minimum modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation
-		Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
-		results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.brate.minimum.read() \n
+		Returns the minimum modulation results for BR packets. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MINimum?', self.__class__.ResultData())
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le2M_/StandardDev.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le2M/StandardDev.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import enums
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
+			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
 			- Mod_Ratio: float: float Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz
+			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
 			ArgStruct.scalar_float('Freq_Drift'),
 			ArgStruct.scalar_float('Max_Drift'),
@@ -48,70 +48,70 @@
 			self.Max_Drift: float = None
 			self.Nominal_Power: float = None
 			self.Mod_Ratio: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.standardDev.fetch() \n
-		Returns the standard deviation of the modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'LE: Statistical
-		Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:SDEViation \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.standardDev.fetch() \n
+		Returns the standard deviation modulation results for LE 2M PHY in normal mode, see 'Normal mode classic: statistical
+		modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit
 		check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:SDEViation?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:SDEViation?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Nominal_Power: float or bool: float Range: -99.99 dBm to 99.99 dBm
 			- Mod_Ratio: enums.ResultStatus2: float Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
 			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:SDEViation \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le2M.standardDev.calculate() \n
-		Returns the standard deviation of the modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'LE: Statistical
-		Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:SDEViation \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le2M.standardDev.calculate() \n
+		Returns the standard deviation modulation results for LE 2M PHY in normal mode, see 'Normal mode classic: statistical
+		modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit
 		check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:SDEViation?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:SDEViation?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.standardDev.read() \n
-		Returns the standard deviation of the modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'LE: Statistical
-		Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:SDEViation \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.standardDev.read() \n
+		Returns the standard deviation modulation results for LE 2M PHY in normal mode, see 'Normal mode classic: statistical
+		modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit
 		check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:SDEViation?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:SDEViation?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le2M_/Xmaximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le1M/Xminimum.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,38 +2,38 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Xmaximum:
-	"""Xmaximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XminimumCls:
+	"""Xminimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("xmaximum", core, parent)
+		self._cmd_group = CommandsGroup("xminimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: float: float Range: 0 to 1
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
@@ -66,88 +66,88 @@
 			self.Freq_Dev_Max_F_2: float = None
 			self.Nominal_Power: float = None
 			self.Mod_Ratio: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.xmaximum.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:XMINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.xminimum.fetch() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:XMINimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: enums.ResultStatus2: float Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
 			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le2M.xmaximum.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:XMINimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le1M.xminimum.calculate() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:XMINimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.xmaximum.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:XMINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.xminimum.read() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:XMINimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le2M_/Xminimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le2M/Xmaximum.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,38 +2,38 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Xminimum:
-	"""Xminimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XmaximumCls:
+	"""Xmaximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("xminimum", core, parent)
+		self._cmd_group = CommandsGroup("xmaximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: float: float Range: 0 to 1
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
@@ -66,88 +66,88 @@
 			self.Freq_Dev_Max_F_2: float = None
 			self.Nominal_Power: float = None
 			self.Mod_Ratio: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.xminimum.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.xmaximum.fetch() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Mod_Ratio: enums.ResultStatus2: float Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
 			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le2M.xminimum.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le2M.xmaximum.calculate() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMINimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMAXimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.xminimum.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le2M.xmaximum.read() \n
 		Returns current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE uncoded PHY (LE
-		1M PHY, LE 2M PHY) , see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		1M PHY, LE 2M PHY) , see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:XMAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Le2M_/YieldPy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le2M/YieldPy.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,27 +1,25 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class YieldPy:
-	"""YieldPy commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class YieldPyCls:
+	"""YieldPy commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("yieldPy", core, parent)
+		self._cmd_group = CommandsGroup("yieldPy", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:YIELd \n
-		Snippet: value: List[float] = driver.multiEval.modulation.lowEnergy.le2M.yieldPy.fetch() \n
-		Returns the percentages of auto-detected LE packets with a particular pattern type. Commands for uncoded LE 1M PHY (..
-		:LE1M..) and LE 2M PHY (..:LE2M..) are available. A result is available after the R&S CMW has auto-detected a packet
-		(method RsCmwBluetoothMeas.Configure.InputSignal.dmodeAUTO) . \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:YIELd \n
+		Snippet: value: List[float] = driver.multiEval.modulation.nmode.lowEnergy.le2M.yieldPy.fetch() \n
+		No command help available \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: pattern_yield: float Pattern yield for 11110000 patterns, 10101010 patterns, and any other patterns (3 values) Range: 0 to 100, Unit: %"""
+			:return: pattern_yield: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE2M:YIELd?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:YIELd?', suppressed)
 		return response
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Lrange.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Limit/LowEnergy/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,83 +1,75 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Lrange:
-	"""Lrange commands group definition. 24 total commands, 8 Sub-groups, 0 group commands"""
+class LowEnergyCls:
+	"""LowEnergy commands group definition. 35 total commands, 7 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lrange", core, parent)
+		self._cmd_group = CommandsGroup("lowEnergy", core, parent)
 
 	@property
-	def xmaximum(self):
-		"""xmaximum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_xmaximum'):
-			from .Lrange_.Xmaximum import Xmaximum
-			self._xmaximum = Xmaximum(self._core, self._base)
-		return self._xmaximum
-
-	@property
-	def xminimum(self):
-		"""xminimum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_xminimum'):
-			from .Lrange_.Xminimum import Xminimum
-			self._xminimum = Xminimum(self._core, self._base)
-		return self._xminimum
-
-	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Lrange_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
-
-	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Lrange_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
-
-	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_current'):
-			from .Lrange_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
-
-	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_average'):
-			from .Lrange_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
-
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Lrange_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	@property
-	def stDev(self):
-		"""stDev commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_stDev'):
-			from .Lrange_.StDev import StDev
-			self._stDev = StDev(self._core, self._base)
-		return self._stDev
+	def lrange(self):
+		"""lrange commands group. 8 Sub-classes, 1 commands."""
+		if not hasattr(self, '_lrange'):
+			from .Lrange import LrangeCls
+			self._lrange = LrangeCls(self._core, self._cmd_group)
+		return self._lrange
+
+	@property
+	def le2M(self):
+		"""le2M commands group. 9 Sub-classes, 1 commands."""
+		if not hasattr(self, '_le2M'):
+			from .Le2M import Le2MCls
+			self._le2M = Le2MCls(self._core, self._cmd_group)
+		return self._le2M
+
+	@property
+	def le1M(self):
+		"""le1M commands group. 5 Sub-classes, 1 commands."""
+		if not hasattr(self, '_le1M'):
+			from .Le1M import Le1MCls
+			self._le1M = Le1MCls(self._core, self._cmd_group)
+		return self._le1M
+
+	@property
+	def delta(self):
+		"""delta commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_delta'):
+			from .Delta import DeltaCls
+			self._delta = DeltaCls(self._core, self._cmd_group)
+		return self._delta
+
+	@property
+	def daverage(self):
+		"""daverage commands group. 1 Sub-classes, 1 commands."""
+		if not hasattr(self, '_daverage'):
+			from .Daverage import DaverageCls
+			self._daverage = DaverageCls(self._core, self._cmd_group)
+		return self._daverage
+
+	@property
+	def dminimum(self):
+		"""dminimum commands group. 1 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dminimum'):
+			from .Dminimum import DminimumCls
+			self._dminimum = DminimumCls(self._core, self._cmd_group)
+		return self._dminimum
+
+	@property
+	def dmaximum(self):
+		"""dmaximum commands group. 1 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dmaximum'):
+			from .Dmaximum import DmaximumCls
+			self._dmaximum = DmaximumCls(self._core, self._cmd_group)
+		return self._dmaximum
 
-	def clone(self) -> 'Lrange':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LowEnergyCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Lrange(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LowEnergyCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Lrange_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Lrange/Xmaximum.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XmaximumCls:
+	"""Xmaximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("xmaximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_199_P_9: float: float Range: -4 MHz to 4 MHz
+			- Freq_Accuracy: float: float Unit: Hz
+			- Freq_Drift: float: float Unit: Hz
+			- Max_Drift: float: float Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
+			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_199_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
 			ArgStruct.scalar_float('Freq_Drift'),
 			ArgStruct.scalar_float('Max_Drift'),
@@ -50,73 +50,73 @@
 			self.Freq_Dev_Avg_F_1: float = None
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
 			self.Nominal_Power: float = None
 			self.Freq_Offset: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.average.fetch() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
-		see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.xmaximum.fetch() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'Normal
+		mode classic: statistical modulation results'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_199_P_9: float or bool: float Range: -4 MHz to 4 MHz
+			- Freq_Accuracy: float or bool: float Unit: Hz
+			- Freq_Drift: float or bool: float Unit: Hz
+			- Max_Drift: float or bool: float Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Range: -99.99 dBm to 99.99 dBm
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_199_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Freq_Offset')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Nominal_Power: float = None
-			self.Freq_Offset: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_199_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Freq_Offset: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.lrange.average.calculate() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
-		see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.lrange.xmaximum.calculate() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'Normal
+		mode classic: statistical modulation results'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMAXimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.average.read() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
-		see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.xmaximum.read() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'Normal
+		mode classic: statistical modulation results'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Lrange_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Lrange/Xminimum.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XminimumCls:
+	"""Xminimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("xminimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_199_P_9: float: float Range: -4 MHz to 4 MHz
+			- Freq_Accuracy: float: float Unit: Hz
+			- Freq_Drift: float: float Unit: Hz
+			- Max_Drift: float: float Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
+			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_199_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
 			ArgStruct.scalar_float('Freq_Drift'),
 			ArgStruct.scalar_float('Max_Drift'),
@@ -50,73 +50,73 @@
 			self.Freq_Dev_Avg_F_1: float = None
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
 			self.Nominal_Power: float = None
 			self.Freq_Offset: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.current.fetch() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
-		see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.xminimum.fetch() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'Normal
+		mode classic: statistical modulation results'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMINimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_199_P_9: float or bool: float Range: -4 MHz to 4 MHz
+			- Freq_Accuracy: float or bool: float Unit: Hz
+			- Freq_Drift: float or bool: float Unit: Hz
+			- Max_Drift: float or bool: float Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Range: -99.99 dBm to 99.99 dBm
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_199_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Freq_Offset')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Nominal_Power: float = None
-			self.Freq_Offset: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_199_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Freq_Offset: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.lrange.current.calculate() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
-		see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMINimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.lrange.xminimum.calculate() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'Normal
+		mode classic: statistical modulation results'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMINimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.current.read() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
-		see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.xminimum.read() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'Normal
+		mode classic: statistical modulation results'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMINimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Lrange_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Lrange/Maximum.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_199_P_9: float: float Range: -4 MHz to 4 MHz
+			- Freq_Accuracy: float: float Unit: Hz
+			- Freq_Drift: float: float Unit: Hz
+			- Max_Drift: float: float Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
+			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_199_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
 			ArgStruct.scalar_float('Freq_Drift'),
 			ArgStruct.scalar_float('Max_Drift'),
@@ -50,73 +50,73 @@
 			self.Freq_Dev_Avg_F_1: float = None
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
 			self.Nominal_Power: float = None
 			self.Freq_Offset: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.maximum.fetch() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
-		see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.maximum.fetch() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'Normal
+		mode classic: statistical modulation results'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_199_P_9: float or bool: float Range: -4 MHz to 4 MHz
+			- Freq_Accuracy: float or bool: float Unit: Hz
+			- Freq_Drift: float or bool: float Unit: Hz
+			- Max_Drift: float or bool: float Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Range: -99.99 dBm to 99.99 dBm
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_199_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Freq_Offset')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Nominal_Power: float = None
-			self.Freq_Offset: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_199_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Freq_Offset: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.lrange.maximum.calculate() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
-		see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.lrange.maximum.calculate() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'Normal
+		mode classic: statistical modulation results'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:MAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MAXimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.maximum.read() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
-		see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.maximum.read() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'Normal
+		mode classic: statistical modulation results'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Lrange_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Lrange/Minimum.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
 			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
@@ -40,59 +40,59 @@
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
 			self.Nominal_Power: float = None
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:MINimum \n
 		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.minimum.fetch() \n
-		Returns current, average and maximum modulation results for LE coded PHY, see 'LE: Statistical Modulation Results '. The
-		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		Returns current, average and maximum modulation results for LE coded PHY, see 'View TX Measurement - modulation
+		statistics'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:MINimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Delta_F_199_P_9: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Nominal_Power')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_199_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Nominal_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_199_P_9: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Nominal_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:MINimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.lrange.minimum.calculate() \n
-		Returns current, average and maximum modulation results for LE coded PHY, see 'LE: Statistical Modulation Results '. The
-		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		Returns current, average and maximum modulation results for LE coded PHY, see 'View TX Measurement - modulation
+		statistics'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:MINimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:MINimum \n
 		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.minimum.read() \n
-		Returns current, average and maximum modulation results for LE coded PHY, see 'LE: Statistical Modulation Results '. The
-		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		Returns current, average and maximum modulation results for LE coded PHY, see 'View TX Measurement - modulation
+		statistics'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:MINimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Lrange_/StDev.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Modulation/Maximum.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,98 +1,98 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.StructBase import StructBase
+from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StDev:
-	"""StDev commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("stDev", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
-			- Out_Of_Tol: float: No parameter help available
-			- Delta_F_199_P_9: float: No parameter help available
-			- Freq_Accuracy: float: No parameter help available
-			- Freq_Drift: float: No parameter help available
-			- Max_Drift: float: No parameter help available
-			- Nominal_Power: float: No parameter help available
-			- Freq_Offset: float: No parameter help available"""
+			- Bursts_Out_Of_Tol: float: No parameter help available
+			- Wi: float: No parameter help available
+			- W_0_Wi: float: No parameter help available
+			- W_0_Max: float: No parameter help available
+			- Rms_Devm: float: No parameter help available
+			- Peak_Devm: float: No parameter help available
+			- Nominal_Power: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
+			ArgStruct.scalar_float('Bursts_Out_Of_Tol'),
+			ArgStruct.scalar_float('Wi'),
+			ArgStruct.scalar_float('W_0_Wi'),
+			ArgStruct.scalar_float('W_0_Max'),
+			ArgStruct.scalar_float('Rms_Devm'),
+			ArgStruct.scalar_float('Peak_Devm'),
+			ArgStruct.scalar_float('Nominal_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
+			self.Bursts_Out_Of_Tol: float = None
+			self.Wi: float = None
+			self.W_0_Wi: float = None
+			self.W_0_Max: float = None
+			self.Rms_Devm: float = None
+			self.Peak_Devm: float = None
 			self.Nominal_Power: float = None
-			self.Freq_Offset: float = None
+
+	def read(self) -> ResultData:
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:HDR:MODulation:MAXimum \n
+		Snippet: value: ResultData = driver.hdr.modulation.maximum.read() \n
+		No command help available \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:HDR:MODulation:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:STDev \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.stDev.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:HDR:MODulation:MAXimum \n
+		Snippet: value: ResultData = driver.hdr.modulation.maximum.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:STDev?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:HDR:MODulation:MAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
-			- Out_Of_Tol: float: No parameter help available
-			- Delta_F_199_P_9: float: No parameter help available
-			- Freq_Accuracy: float: No parameter help available
-			- Freq_Drift: float: No parameter help available
-			- Max_Drift: float: No parameter help available
-			- Nominal_Power: float: No parameter help available
-			- Freq_Offset: float: No parameter help available"""
+			- Bursts_Out_Of_Tol: float or bool: No parameter help available
+			- Wi: float or bool: No parameter help available
+			- W_0_Wi: float or bool: No parameter help available
+			- W_0_Max: float or bool: No parameter help available
+			- Rms_Devm: float or bool: No parameter help available
+			- Peak_Devm: float or bool: No parameter help available
+			- Nominal_Power: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
+			ArgStruct.scalar_float_ext('Bursts_Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Wi'),
+			ArgStruct.scalar_float_ext('W_0_Wi'),
+			ArgStruct.scalar_float_ext('W_0_Max'),
+			ArgStruct.scalar_float_ext('Rms_Devm'),
+			ArgStruct.scalar_float_ext('Peak_Devm'),
+			ArgStruct.scalar_float_ext('Nominal_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Nominal_Power: float = None
-			self.Freq_Offset: float = None
+			self.Bursts_Out_Of_Tol: float or bool = None
+			self.Wi: float or bool = None
+			self.W_0_Wi: float or bool = None
+			self.W_0_Max: float or bool = None
+			self.Rms_Devm: float or bool = None
+			self.Peak_Devm: float or bool = None
+			self.Nominal_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:STDev \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.lrange.stDev.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:HDR:MODulation:MAXimum \n
+		Snippet: value: CalculateStruct = driver.hdr.modulation.maximum.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:STDev?', self.__class__.CalculateStruct())
-
-	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:STDev \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.stDev.read() \n
-		No command help available \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:STDev?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:HDR:MODulation:MAXimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Lrange_/StandardDev.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Lrange/StandardDev.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
 			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
@@ -43,62 +43,62 @@
 			self.Max_Drift: float = None
 			self.Nominal_Power: float = None
 			self.Freq_Offset: float = None
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:SDEViation \n
 		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.standardDev.fetch() \n
-		Returns the standard deviation of the modulation results for LE coded PHY, see 'LE: Statistical Modulation Results '. The
-		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		Returns the standard deviation of the modulation results for LE coded PHY, see 'View TX Measurement - modulation
+		statistics'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:SDEViation?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Delta_F_199_P_9: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Nominal_Power: float or bool: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_199_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Freq_Offset')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Nominal_Power: float = None
-			self.Freq_Offset: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_199_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Freq_Offset: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:SDEViation \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.lrange.standardDev.calculate() \n
-		Returns the standard deviation of the modulation results for LE coded PHY, see 'LE: Statistical Modulation Results '. The
-		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		Returns the standard deviation of the modulation results for LE coded PHY, see 'View TX Measurement - modulation
+		statistics'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:SDEViation?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:SDEViation \n
 		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.standardDev.read() \n
-		Returns the standard deviation of the modulation results for LE coded PHY, see 'LE: Statistical Modulation Results '. The
-		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		Returns the standard deviation of the modulation results for LE coded PHY, see 'View TX Measurement - modulation
+		statistics'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:SDEViation?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Lrange_/Xmaximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Le1M/StandardDev.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,122 +1,117 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Xmaximum:
-	"""Xmaximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("xmaximum", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
 			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
+			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
+			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
 			ArgStruct.scalar_float('Freq_Drift'),
 			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
+			ArgStruct.scalar_float('Mod_Ratio'),
+			ArgStruct.scalar_float('Freq_Offset'),
+			ArgStruct.scalar_float('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
+			self.Delta_F_299_P_9: float = None
 			self.Freq_Accuracy: float = None
 			self.Freq_Drift: float = None
 			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
 			self.Nominal_Power: float = None
+			self.Mod_Ratio: float = None
 			self.Freq_Offset: float = None
+			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:XMAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.xmaximum.fetch() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
-		see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:SDEViation \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.standardDev.fetch() \n
+		Returns the standard deviation of the modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'View TX
+		Measurement - modulation statistics'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:XMAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:SDEViation?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Nominal_Power: float = None
-			self.Freq_Offset: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Mod_Ratio: enums.ResultStatus2 = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:XMAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.lrange.xmaximum.calculate() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
-		see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:SDEViation \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.le1M.standardDev.calculate() \n
+		Returns the standard deviation of the modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'View TX
+		Measurement - modulation statistics'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:XMAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:SDEViation?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:XMAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.xmaximum.read() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
-		see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy[:LE1M]:SDEViation \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.le1M.standardDev.read() \n
+		Returns the standard deviation of the modulation results for LE uncoded PHY (LE 1M PHY, LE 2M PHY) , see 'View TX
+		Measurement - modulation statistics'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:XMAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LE1M:SDEViation?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/LowEnergy_/Lrange_/Xminimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le2M/Minimum.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,122 +1,123 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Xminimum:
-	"""Xminimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("xminimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Freq_Dev_Avg_F_2: float: No parameter help available
+			- Freq_Dev_Min_F_2: float: No parameter help available
+			- Freq_Dev_Max_F_2: float: No parameter help available
+			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
+			- Mod_Ratio: float: float Range: 0 to 1"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
+			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
+			ArgStruct.scalar_float('Mod_Ratio')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
+			self.Delta_F_299_P_9: float = None
 			self.Freq_Dev_Avg_F_1: float = None
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
+			self.Freq_Dev_Avg_F_2: float = None
+			self.Freq_Dev_Min_F_2: float = None
+			self.Freq_Dev_Max_F_2: float = None
 			self.Nominal_Power: float = None
-			self.Freq_Offset: float = None
+			self.Mod_Ratio: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:XMINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.xminimum.fetch() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
-		see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.minimum.fetch() \n
+		Returns the minimum modulation results for LE 2M PHY in normal mode, see 'Normal mode classic: statistical modulation
+		results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:XMINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MINimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Range: -99.99 dBm to 99.99 dBm
+			- Mod_Ratio: enums.ResultStatus2: float Range: 0 to 1"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Nominal_Power: float = None
-			self.Freq_Offset: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Mod_Ratio: enums.ResultStatus2 = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:XMINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.lrange.xminimum.calculate() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
-		see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MINimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le2M.minimum.calculate() \n
+		Returns the minimum modulation results for LE 2M PHY in normal mode, see 'Normal mode classic: statistical modulation
+		results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:XMINimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MINimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:XMINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.xminimum.read() \n
-		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
-		see 'LE: Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.minimum.read() \n
+		Returns the minimum modulation results for LE 2M PHY in normal mode, see 'Normal mode classic: statistical modulation
+		results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:XMINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MINimum?', self.__class__.ResultData())
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cte/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Nmode:
-	"""Nmode commands group definition. 88 total commands, 2 Sub-groups, 0 group commands"""
+class CteCls:
+	"""Cte commands group definition. 14 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nmode", core, parent)
+		self._cmd_group = CommandsGroup("cte", core, parent)
 
 	@property
-	def classic(self):
-		"""classic commands group. 7 Sub-classes, 0 commands."""
-		if not hasattr(self, '_classic'):
-			from .Nmode_.Classic import Classic
-			self._classic = Classic(self._core, self._base)
-		return self._classic
+	def qhsl(self):
+		"""qhsl commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_qhsl'):
+			from .Qhsl import QhslCls
+			self._qhsl = QhslCls(self._core, self._cmd_group)
+		return self._qhsl
 
 	@property
 	def lowEnergy(self):
-		"""lowEnergy commands group. 3 Sub-classes, 0 commands."""
+		"""lowEnergy commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_lowEnergy'):
-			from .Nmode_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
 		return self._lowEnergy
 
-	def clone(self) -> 'Nmode':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CteCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Nmode(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CteCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/Classic_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le1M/Average.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,125 +1,134 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation BR) ' and 'Limits (Modulation EDR) '. Range: 0 % to 100 %
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Accuracy: float or bool: float Unit: Hz
+			- Freq_Offset: float or bool: float Unit: Hz
+			- Freq_Drift: float or bool: float Unit: Hz
+			- Init_Freq_Drift: float or bool: float Unit: Hz
+			- Max_Drift: float or bool: float Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Offset: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.classic.average.calculate() \n
-		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'LE: Statistical
-		Modulation Results '. An R&S CMW100/CMW with MUA returns all results. An R&S CMW500/2xx with BB Meas returns only three
-		values: results 1 to 3. The values described below are returned by FETCh and READ commands. CALCulate commands return
-		limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:AVERage \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le1M.average.calculate() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:AVERage?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation BR) ' and 'Limits (Modulation EDR) '. Range: 0 % to 100 %
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Accuracy: float: float Unit: Hz
+			- Freq_Offset: float: float Unit: Hz
+			- Freq_Drift: float: float Unit: Hz
+			- Init_Freq_Drift: float: float Unit: Hz
+			- Max_Drift: float: float Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
+			ArgStruct.scalar_float('Freq_Offset'),
 			ArgStruct.scalar_float('Freq_Drift'),
+			ArgStruct.scalar_float('Init_Freq_Drift'),
 			ArgStruct.scalar_float('Max_Drift'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
 			self.Freq_Accuracy: float = None
+			self.Freq_Offset: float = None
 			self.Freq_Drift: float = None
+			self.Init_Freq_Drift: float = None
 			self.Max_Drift: float = None
 			self.Freq_Dev_Avg_F_1: float = None
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
 			self.Freq_Dev_Avg_F_2: float = None
 			self.Freq_Dev_Min_F_2: float = None
 			self.Freq_Dev_Max_F_2: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.classic.average.fetch() \n
-		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'LE: Statistical
-		Modulation Results '. An R&S CMW100/CMW with MUA returns all results. An R&S CMW500/2xx with BB Meas returns only three
-		values: results 1 to 3. The values described below are returned by FETCh and READ commands. CALCulate commands return
-		limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le1M.average.fetch() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:AVERage?', self.__class__.ResultData())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.classic.average.read() \n
-		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'LE: Statistical
-		Modulation Results '. An R&S CMW100/CMW with MUA returns all results. An R&S CMW500/2xx with BB Meas returns only three
-		values: results 1 to 3. The values described below are returned by FETCh and READ commands. CALCulate commands return
-		limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le1M.average.read() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/Classic_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le1M/Current.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,125 +1,134 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation BR) ' and 'Limits (Modulation EDR) '. Range: 0 % to 100 %
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Accuracy: float or bool: float Unit: Hz
+			- Freq_Offset: float or bool: float Unit: Hz
+			- Freq_Drift: float or bool: float Unit: Hz
+			- Init_Freq_Drift: float or bool: float Unit: Hz
+			- Max_Drift: float or bool: float Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Offset: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.classic.current.calculate() \n
-		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'LE: Statistical
-		Modulation Results '. An R&S CMW100/CMW with MUA returns all results. An R&S CMW500/2xx with BB Meas returns only three
-		values: results 1 to 3. The values described below are returned by FETCh and READ commands. CALCulate commands return
-		limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:CURRent \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le1M.current.calculate() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:CURRent?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation BR) ' and 'Limits (Modulation EDR) '. Range: 0 % to 100 %
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Accuracy: float: float Unit: Hz
+			- Freq_Offset: float: float Unit: Hz
+			- Freq_Drift: float: float Unit: Hz
+			- Init_Freq_Drift: float: float Unit: Hz
+			- Max_Drift: float: float Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
+			ArgStruct.scalar_float('Freq_Offset'),
 			ArgStruct.scalar_float('Freq_Drift'),
+			ArgStruct.scalar_float('Init_Freq_Drift'),
 			ArgStruct.scalar_float('Max_Drift'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
 			self.Freq_Accuracy: float = None
+			self.Freq_Offset: float = None
 			self.Freq_Drift: float = None
+			self.Init_Freq_Drift: float = None
 			self.Max_Drift: float = None
 			self.Freq_Dev_Avg_F_1: float = None
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
 			self.Freq_Dev_Avg_F_2: float = None
 			self.Freq_Dev_Min_F_2: float = None
 			self.Freq_Dev_Max_F_2: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.classic.current.fetch() \n
-		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'LE: Statistical
-		Modulation Results '. An R&S CMW100/CMW with MUA returns all results. An R&S CMW500/2xx with BB Meas returns only three
-		values: results 1 to 3. The values described below are returned by FETCh and READ commands. CALCulate commands return
-		limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le1M.current.fetch() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:CURRent?', self.__class__.ResultData())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.classic.current.read() \n
-		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'LE: Statistical
-		Modulation Results '. An R&S CMW100/CMW with MUA returns all results. An R&S CMW500/2xx with BB Meas returns only three
-		values: results 1 to 3. The values described below are returned by FETCh and READ commands. CALCulate commands return
-		limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le1M.current.read() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:CURRent?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/Classic_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/Classic/Maximum.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,77 +1,76 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation BR) ' and 'Limits (Modulation EDR) '. Range: 0 % to 100 %
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (BR) ' and 'Modulation limits (EDR) '. Range: 0 % to 100 %
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:MAXimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.classic.maximum.calculate() \n
-		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'LE: Statistical
-		Modulation Results '. An R&S CMW100/CMW with MUA returns all results. An R&S CMW500/2xx with BB Meas returns only three
-		values: results 1 to 3. The values described below are returned by FETCh and READ commands. CALCulate commands return
-		limit check results instead, one value for each result listed below. \n
+		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'Normal mode classic:
+		statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands
+		return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:MAXimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation BR) ' and 'Limits (Modulation EDR) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (BR) ' and 'Modulation limits (EDR) '. Range: 0 % to 100 %
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
 			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
@@ -103,23 +102,21 @@
 			self.Freq_Dev_Avg_F_2: float = None
 			self.Freq_Dev_Min_F_2: float = None
 			self.Freq_Dev_Max_F_2: float = None
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:MAXimum \n
 		Snippet: value: ResultData = driver.multiEval.modulation.nmode.classic.maximum.fetch() \n
-		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'LE: Statistical
-		Modulation Results '. An R&S CMW100/CMW with MUA returns all results. An R&S CMW500/2xx with BB Meas returns only three
-		values: results 1 to 3. The values described below are returned by FETCh and READ commands. CALCulate commands return
-		limit check results instead, one value for each result listed below. \n
+		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'Normal mode classic:
+		statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands
+		return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:MAXimum?', self.__class__.ResultData())
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:MAXimum \n
 		Snippet: value: ResultData = driver.multiEval.modulation.nmode.classic.maximum.read() \n
-		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'LE: Statistical
-		Modulation Results '. An R&S CMW100/CMW with MUA returns all results. An R&S CMW500/2xx with BB Meas returns only three
-		values: results 1 to 3. The values described below are returned by FETCh and READ commands. CALCulate commands return
-		limit check results instead, one value for each result listed below. \n
+		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'Normal mode classic:
+		statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands
+		return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/Classic_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/Classic/Minimum.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,52 +1,52 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
-			- Out_Of_Tol: float: No parameter help available
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available"""
+			- Out_Of_Tol: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:MINimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.classic.minimum.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:MINimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/Classic_/StandardDev.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/Classic/StandardDev.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,59 +1,58 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation BR) ' and 'Limits (Modulation EDR) '. Range: 0 % to 100 %
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (BR) ' and 'Modulation limits (EDR) '. Range: 0 % to 100 %
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:SDEViation \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.classic.standardDev.calculate() \n
-		Returns standard deviation modulation results for BR/EDR, normal mode, see 'LE: Statistical Modulation Results '. An R&S
-		CMW100/CMW with MUA returns all results. An R&S CMW500/2xx with BB Meas returns only three values: results 1 to 3.
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		Returns standard deviation modulation results for BR/EDR, normal mode, see 'Normal mode classic: statistical modulation
+		results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:SDEViation?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation BR) ' and 'Limits (Modulation EDR) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (BR) ' and 'Modulation limits (EDR) '. Range: 0 % to 100 %
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
 			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
@@ -67,23 +66,21 @@
 			self.Freq_Accuracy: float = None
 			self.Freq_Drift: float = None
 			self.Max_Drift: float = None
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:SDEViation \n
 		Snippet: value: ResultData = driver.multiEval.modulation.nmode.classic.standardDev.fetch() \n
-		Returns standard deviation modulation results for BR/EDR, normal mode, see 'LE: Statistical Modulation Results '. An R&S
-		CMW100/CMW with MUA returns all results. An R&S CMW500/2xx with BB Meas returns only three values: results 1 to 3.
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		Returns standard deviation modulation results for BR/EDR, normal mode, see 'Normal mode classic: statistical modulation
+		results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:SDEViation?', self.__class__.ResultData())
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:SDEViation \n
 		Snippet: value: ResultData = driver.multiEval.modulation.nmode.classic.standardDev.read() \n
-		Returns standard deviation modulation results for BR/EDR, normal mode, see 'LE: Statistical Modulation Results '. An R&S
-		CMW100/CMW with MUA returns all results. An R&S CMW500/2xx with BB Meas returns only three values: results 1 to 3.
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		Returns standard deviation modulation results for BR/EDR, normal mode, see 'Normal mode classic: statistical modulation
+		results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:SDEViation?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/Classic_/Xmaximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/Classic/Xmaximum.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,77 +1,76 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Xmaximum:
-	"""Xmaximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XmaximumCls:
+	"""Xmaximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("xmaximum", core, parent)
+		self._cmd_group = CommandsGroup("xmaximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation BR) ' and 'Limits (Modulation EDR) '. Range: 0 % to 100 %
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Max_Drift_Rate: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (BR) ' and 'Modulation limits (EDR) '. Range: 0 % to 100 %
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Max_Drift_Rate: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift_Rate'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift_Rate'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift_Rate: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift_Rate: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:XMAXimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.classic.xmaximum.calculate() \n
-		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'LE: Statistical
-		Modulation Results '. An R&S CMW100/CMW with MUA returns all results. An R&S CMW500/2xx with BB Meas returns only three
-		values: results 1 to 3. The values described below are returned by FETCh and READ commands. CALCulate commands return
-		limit check results instead, one value for each result listed below. \n
+		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'Normal mode classic:
+		statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands
+		return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:XMAXimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation BR) ' and 'Limits (Modulation EDR) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (BR) ' and 'Modulation limits (EDR) '. Range: 0 % to 100 %
 			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz
 			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
 			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
@@ -103,23 +102,21 @@
 			self.Freq_Dev_Avg_F_2: float = None
 			self.Freq_Dev_Min_F_2: float = None
 			self.Freq_Dev_Max_F_2: float = None
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:XMAXimum \n
 		Snippet: value: ResultData = driver.multiEval.modulation.nmode.classic.xmaximum.fetch() \n
-		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'LE: Statistical
-		Modulation Results '. An R&S CMW100/CMW with MUA returns all results. An R&S CMW500/2xx with BB Meas returns only three
-		values: results 1 to 3. The values described below are returned by FETCh and READ commands. CALCulate commands return
-		limit check results instead, one value for each result listed below. \n
+		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'Normal mode classic:
+		statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands
+		return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:XMAXimum?', self.__class__.ResultData())
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:XMAXimum \n
 		Snippet: value: ResultData = driver.multiEval.modulation.nmode.classic.xmaximum.read() \n
-		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'LE: Statistical
-		Modulation Results '. An R&S CMW100/CMW with MUA returns all results. An R&S CMW500/2xx with BB Meas returns only three
-		values: results 1 to 3. The values described below are returned by FETCh and READ commands. CALCulate commands return
-		limit check results instead, one value for each result listed below. \n
+		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'Normal mode classic:
+		statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands
+		return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:XMAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/Classic_/Xminimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le1M/Xmaximum.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,125 +1,134 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Xminimum:
-	"""Xminimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XmaximumCls:
+	"""Xmaximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("xminimum", core, parent)
+		self._cmd_group = CommandsGroup("xmaximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation BR) ' and 'Limits (Modulation EDR) '. Range: 0 % to 100 %
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Accuracy: float or bool: float Unit: Hz
+			- Freq_Offset: float or bool: float Unit: Hz
+			- Freq_Drift: float or bool: float Unit: Hz
+			- Init_Freq_Drift: float or bool: float Unit: Hz
+			- Max_Drift_Rate: float or bool: float Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift_Rate'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Offset: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
+			self.Max_Drift_Rate: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:XMINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.classic.xminimum.calculate() \n
-		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'LE: Statistical
-		Modulation Results '. An R&S CMW100/CMW with MUA returns all results. An R&S CMW500/2xx with BB Meas returns only three
-		values: results 1 to 3. The values described below are returned by FETCh and READ commands. CALCulate commands return
-		limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:XMAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le1M.xmaximum.calculate() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:XMINimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:XMAXimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation BR) ' and 'Limits (Modulation EDR) '. Range: 0 % to 100 %
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Accuracy: float: float Unit: Hz
+			- Freq_Offset: float: float Unit: Hz
+			- Freq_Drift: float: float Unit: Hz
+			- Init_Freq_Drift: float: float Unit: Hz
+			- Max_Drift: float: float Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
+			ArgStruct.scalar_float('Freq_Offset'),
 			ArgStruct.scalar_float('Freq_Drift'),
+			ArgStruct.scalar_float('Init_Freq_Drift'),
 			ArgStruct.scalar_float('Max_Drift'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
 			self.Freq_Accuracy: float = None
+			self.Freq_Offset: float = None
 			self.Freq_Drift: float = None
+			self.Init_Freq_Drift: float = None
 			self.Max_Drift: float = None
 			self.Freq_Dev_Avg_F_1: float = None
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
 			self.Freq_Dev_Avg_F_2: float = None
 			self.Freq_Dev_Min_F_2: float = None
 			self.Freq_Dev_Max_F_2: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:XMINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.classic.xminimum.fetch() \n
-		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'LE: Statistical
-		Modulation Results '. An R&S CMW100/CMW with MUA returns all results. An R&S CMW500/2xx with BB Meas returns only three
-		values: results 1 to 3. The values described below are returned by FETCh and READ commands. CALCulate commands return
-		limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:XMAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le1M.xmaximum.fetch() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:XMINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:XMAXimum?', self.__class__.ResultData())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:XMINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.classic.xminimum.read() \n
-		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'LE: Statistical
-		Modulation Results '. An R&S CMW100/CMW with MUA returns all results. An R&S CMW500/2xx with BB Meas returns only three
-		values: results 1 to 3. The values described below are returned by FETCh and READ commands. CALCulate commands return
-		limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:XMAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le1M.xmaximum.read() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:XMINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:XMAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,43 +1,43 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 67 total commands, 3 Sub-groups, 0 group commands"""
+class LowEnergyCls:
+	"""LowEnergy commands group definition. 68 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("lowEnergy", core, parent)
 
 	@property
 	def le1M(self):
-		"""le1M commands group. 7 Sub-classes, 0 commands."""
+		"""le1M commands group. 8 Sub-classes, 0 commands."""
 		if not hasattr(self, '_le1M'):
-			from .LowEnergy_.Le1M import Le1M
-			self._le1M = Le1M(self._core, self._base)
+			from .Le1M import Le1MCls
+			self._le1M = Le1MCls(self._core, self._cmd_group)
 		return self._le1M
 
 	@property
 	def le2M(self):
 		"""le2M commands group. 8 Sub-classes, 0 commands."""
 		if not hasattr(self, '_le2M'):
-			from .LowEnergy_.Le2M import Le2M
-			self._le2M = Le2M(self._core, self._base)
+			from .Le2M import Le2MCls
+			self._le2M = Le2MCls(self._core, self._cmd_group)
 		return self._le2M
 
 	@property
 	def lrange(self):
 		"""lrange commands group. 8 Sub-classes, 0 commands."""
 		if not hasattr(self, '_lrange'):
-			from .LowEnergy_.Lrange import Lrange
-			self._lrange = Lrange(self._core, self._base)
+			from .Lrange import LrangeCls
+			self._lrange = LrangeCls(self._core, self._cmd_group)
 		return self._lrange
 
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LowEnergyCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LowEnergyCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le1M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Cte/LowEnergy/Le2M/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,75 +1,67 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le1M:
-	"""Le1M commands group definition. 21 total commands, 7 Sub-groups, 0 group commands"""
+class Le2MCls:
+	"""Le2M commands group definition. 18 total commands, 6 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le1M", core, parent)
+		self._cmd_group = CommandsGroup("le2M", core, parent)
 
 	@property
 	def xmaximum(self):
 		"""xmaximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_xmaximum'):
-			from .Le1M_.Xmaximum import Xmaximum
-			self._xmaximum = Xmaximum(self._core, self._base)
+			from .Xmaximum import XmaximumCls
+			self._xmaximum = XmaximumCls(self._core, self._cmd_group)
 		return self._xmaximum
 
 	@property
 	def xminimum(self):
 		"""xminimum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_xminimum'):
-			from .Le1M_.Xminimum import Xminimum
-			self._xminimum = Xminimum(self._core, self._base)
+			from .Xminimum import XminimumCls
+			self._xminimum = XminimumCls(self._core, self._cmd_group)
 		return self._xminimum
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Le1M_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Le1M_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
+	def current(self):
+		"""current commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Le1M_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_current'):
-			from .Le1M_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
-
-	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Le1M_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Le1M':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'Le2MCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Le1M(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = Le2MCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le1M_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le1M/Xminimum.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,82 +1,82 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XminimumCls:
+	"""Xminimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("xminimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Offset: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Init_Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Accuracy: float or bool: float Unit: Hz
+			- Freq_Offset: float or bool: float Unit: Hz
+			- Freq_Drift: float or bool: float Unit: Hz
+			- Init_Freq_Drift: float or bool: float Unit: Hz
+			- Max_Drift: float or bool: float Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Init_Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Offset: float = None
-			self.Freq_Drift: float = None
-			self.Init_Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Offset: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le1M.average.calculate() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:XMINimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le1M.xminimum.calculate() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:XMINimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
 			- Freq_Accuracy: float: float Unit: Hz
 			- Freq_Offset: float: float Unit: Hz
 			- Freq_Drift: float: float Unit: Hz
 			- Init_Freq_Drift: float: float Unit: Hz
 			- Max_Drift: float: float Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
@@ -112,23 +112,23 @@
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
 			self.Freq_Dev_Avg_F_2: float = None
 			self.Freq_Dev_Min_F_2: float = None
 			self.Freq_Dev_Max_F_2: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le1M.average.fetch() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:XMINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le1M.xminimum.fetch() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:XMINimum?', self.__class__.ResultData())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le1M.average.read() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:XMINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le1M.xminimum.read() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:XMINimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le1M_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Lrange/Average.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,134 +1,122 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_199_P_9: float: float Range: -4 MHz to 4 MHz
 			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Offset: float: float Unit: Hz
 			- Freq_Drift: float: float Unit: Hz
-			- Init_Freq_Drift: float: float Unit: Hz
 			- Max_Drift: float: float Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available"""
+			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
+			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
+			ArgStruct.scalar_float('Delta_F_199_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Offset'),
 			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Init_Freq_Drift'),
 			ArgStruct.scalar_float('Max_Drift'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2')]
+			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float('Freq_Offset')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
+			self.Delta_F_199_P_9: float = None
 			self.Freq_Accuracy: float = None
-			self.Freq_Offset: float = None
 			self.Freq_Drift: float = None
-			self.Init_Freq_Drift: float = None
 			self.Max_Drift: float = None
 			self.Freq_Dev_Avg_F_1: float = None
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
+			self.Nominal_Power: float = None
+			self.Freq_Offset: float = None
 
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le1M.current.calculate() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:CURRent?', self.__class__.CalculateStruct())
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.average.fetch() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'Normal
+		mode classic: statistical modulation results'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
-	class ResultData(StructBase):
+	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Offset: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Init_Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_199_P_9: float or bool: float Range: -4 MHz to 4 MHz
+			- Freq_Accuracy: float or bool: float Unit: Hz
+			- Freq_Drift: float or bool: float Unit: Hz
+			- Max_Drift: float or bool: float Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Range: -99.99 dBm to 99.99 dBm
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Init_Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_199_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Freq_Offset')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Offset: float = None
-			self.Freq_Drift: float = None
-			self.Init_Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_199_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Freq_Offset: float or bool = None
 
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le1M.current.fetch() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:CURRent?', self.__class__.ResultData())
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:AVERage \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.lrange.average.calculate() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'Normal
+		mode classic: statistical modulation results'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:AVERage?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le1M.current.read() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.average.read() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'Normal
+		mode classic: statistical modulation results'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le1M_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le1M/Maximum.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,82 +1,82 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Offset: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Init_Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Accuracy: float or bool: float Unit: Hz
+			- Freq_Offset: float or bool: float Unit: Hz
+			- Freq_Drift: float or bool: float Unit: Hz
+			- Init_Freq_Drift: float or bool: float Unit: Hz
+			- Max_Drift: float or bool: float Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Init_Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Offset: float = None
-			self.Freq_Drift: float = None
-			self.Init_Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Offset: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:MAXimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le1M.maximum.calculate() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:MAXimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
 			- Freq_Accuracy: float: float Unit: Hz
 			- Freq_Offset: float: float Unit: Hz
 			- Freq_Drift: float: float Unit: Hz
 			- Init_Freq_Drift: float: float Unit: Hz
 			- Max_Drift: float: float Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
@@ -114,25 +114,25 @@
 			self.Freq_Dev_Avg_F_2: float = None
 			self.Freq_Dev_Min_F_2: float = None
 			self.Freq_Dev_Max_F_2: float = None
 
 	def fetch(self) -> FetchStruct:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:MAXimum \n
 		Snippet: value: FetchStruct = driver.multiEval.modulation.nmode.lowEnergy.le1M.maximum.fetch() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:MAXimum?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
 			- Freq_Accuracy: float: float Unit: Hz
 			- Freq_Offset: float: float Unit: Hz
 			- Freq_Drift: float: float Unit: Hz
 			- Init_Freq_Drift: float: float Unit: Hz
 			- Max_Drift: float: float Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: str: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
@@ -170,12 +170,12 @@
 			self.Freq_Dev_Avg_F_2: float = None
 			self.Freq_Dev_Min_F_2: float = None
 			self.Freq_Dev_Max_F_2: float = None
 
 	def read(self) -> ReadStruct:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:MAXimum \n
 		Snippet: value: ReadStruct = driver.multiEval.modulation.nmode.lowEnergy.le1M.maximum.read() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:MAXimum?', self.__class__.ReadStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le1M_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le1M/Minimum.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,67 +1,67 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:MINimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le1M.minimum.calculate() \n
-		Returns the minimum modulation results for LE 1M PHY in normal mode, see 'LE: Statistical Modulation Results '.
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		Returns the minimum modulation results for LE 1M PHY in normal mode, see 'Normal mode classic: statistical modulation
+		results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:MINimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available"""
 		__meta_args_list = [
@@ -84,25 +84,25 @@
 			self.Freq_Dev_Avg_F_2: float = None
 			self.Freq_Dev_Min_F_2: float = None
 			self.Freq_Dev_Max_F_2: float = None
 
 	def fetch(self) -> FetchStruct:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:MINimum \n
 		Snippet: value: FetchStruct = driver.multiEval.modulation.nmode.lowEnergy.le1M.minimum.fetch() \n
-		Returns the minimum modulation results for LE 1M PHY in normal mode, see 'LE: Statistical Modulation Results '.
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		Returns the minimum modulation results for LE 1M PHY in normal mode, see 'Normal mode classic: statistical modulation
+		results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:MINimum?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
 			- Freq_Dev_Avg_F_1: str: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available"""
 		__meta_args_list = [
@@ -125,12 +125,12 @@
 			self.Freq_Dev_Avg_F_2: float = None
 			self.Freq_Dev_Min_F_2: float = None
 			self.Freq_Dev_Max_F_2: float = None
 
 	def read(self) -> ReadStruct:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:MINimum \n
 		Snippet: value: ReadStruct = driver.multiEval.modulation.nmode.lowEnergy.le1M.minimum.read() \n
-		Returns the minimum modulation results for LE 1M PHY in normal mode, see 'LE: Statistical Modulation Results '.
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		Returns the minimum modulation results for LE 1M PHY in normal mode, see 'Normal mode classic: statistical modulation
+		results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:MINimum?', self.__class__.ReadStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le1M_/StandardDev.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Nmode/LowEnergy/Le1M.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,86 +1,74 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class Le1MCls:
+	"""Le1M commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("le1M", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128.0 dBm to +30.0 dBm , Unit: dBm
+			- No_Of_Exceptions: float or bool: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift')]
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('No_Of_Exceptions')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
+			self.Nominal_Power: float or bool = None
+			self.No_Of_Exceptions: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:SDEViation \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le1M.standardDev.calculate() \n
-		Returns the standard deviation modulation results for LE 1M PHY in normal mode, see 'LE: Statistical Modulation Results '.
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy[:LE1M] \n
+		Snippet: value: CalculateStruct = driver.multiEval.sacp.nmode.lowEnergy.le1M.calculate() \n
+		Returns the 'Spectrum ACP' results for LE normal mode, see 'View Spectrum ACP'. Commands for uncoded LE 1M PHY (..:LE1M..
+		) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by
+		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:SDEViation?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LE1M?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to +30.0 dBm , Unit: dBm
+			- No_Of_Exceptions: int: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift')]
+			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_int('No_Of_Exceptions')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
+			self.Nominal_Power: float = None
+			self.No_Of_Exceptions: int = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le1M.standardDev.fetch() \n
-		Returns the standard deviation modulation results for LE 1M PHY in normal mode, see 'LE: Statistical Modulation Results '.
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy[:LE1M] \n
+		Snippet: value: ResultData = driver.multiEval.sacp.nmode.lowEnergy.le1M.fetch() \n
+		Returns the 'Spectrum ACP' results for LE normal mode, see 'View Spectrum ACP'. Commands for uncoded LE 1M PHY (..:LE1M..
+		) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by
+		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:SDEViation?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LE1M?', self.__class__.ResultData())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le1M.standardDev.read() \n
-		Returns the standard deviation modulation results for LE 1M PHY in normal mode, see 'LE: Statistical Modulation Results '.
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy[:LE1M] \n
+		Snippet: value: ResultData = driver.multiEval.sacp.nmode.lowEnergy.le1M.read() \n
+		Returns the 'Spectrum ACP' results for LE normal mode, see 'View Spectrum ACP'. Commands for uncoded LE 1M PHY (..:LE1M..
+		) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by
+		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:SDEViation?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LE1M?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le1M_/Xmaximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/Classic/Xminimum.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,134 +1,122 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Xmaximum:
-	"""Xmaximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XminimumCls:
+	"""Xminimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("xmaximum", core, parent)
+		self._cmd_group = CommandsGroup("xminimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Offset: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Init_Freq_Drift: float: float Unit: Hz
-			- Max_Drift_Rate: float: float Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (BR) ' and 'Modulation limits (EDR) '. Range: 0 % to 100 %
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Init_Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift_Rate'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Offset: float = None
-			self.Freq_Drift: float = None
-			self.Init_Freq_Drift: float = None
-			self.Max_Drift_Rate: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:XMAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le1M.xmaximum.calculate() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:XMINimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.classic.xminimum.calculate() \n
+		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'Normal mode classic:
+		statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands
 		return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:XMAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:XMINimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Offset: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Init_Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (BR) ' and 'Modulation limits (EDR) '. Range: 0 % to 100 %
+			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz
+			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
+			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Offset'),
 			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Init_Freq_Drift'),
 			ArgStruct.scalar_float('Max_Drift'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
 			self.Freq_Accuracy: float = None
-			self.Freq_Offset: float = None
 			self.Freq_Drift: float = None
-			self.Init_Freq_Drift: float = None
 			self.Max_Drift: float = None
 			self.Freq_Dev_Avg_F_1: float = None
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
 			self.Freq_Dev_Avg_F_2: float = None
 			self.Freq_Dev_Min_F_2: float = None
 			self.Freq_Dev_Max_F_2: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:XMAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le1M.xmaximum.fetch() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:XMINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.classic.xminimum.fetch() \n
+		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'Normal mode classic:
+		statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands
 		return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:XMAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:XMINimum?', self.__class__.ResultData())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:XMAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le1M.xmaximum.read() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:XMINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.classic.xminimum.read() \n
+		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'Normal mode classic:
+		statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands
 		return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:XMAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:XMINimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le1M_/Xminimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Lrange/Current.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,134 +1,122 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Xminimum:
-	"""Xminimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("xminimum", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_199_P_9: float: float Range: -4 MHz to 4 MHz
 			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Offset: float: float Unit: Hz
 			- Freq_Drift: float: float Unit: Hz
-			- Init_Freq_Drift: float: float Unit: Hz
 			- Max_Drift: float: float Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available"""
+			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
+			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
+			ArgStruct.scalar_float('Delta_F_199_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Offset'),
 			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Init_Freq_Drift'),
 			ArgStruct.scalar_float('Max_Drift'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2')]
+			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float('Freq_Offset')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
+			self.Delta_F_199_P_9: float = None
 			self.Freq_Accuracy: float = None
-			self.Freq_Offset: float = None
 			self.Freq_Drift: float = None
-			self.Init_Freq_Drift: float = None
 			self.Max_Drift: float = None
 			self.Freq_Dev_Avg_F_1: float = None
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
+			self.Nominal_Power: float = None
+			self.Freq_Offset: float = None
 
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:XMINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le1M.xminimum.calculate() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:XMINimum?', self.__class__.CalculateStruct())
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.current.fetch() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'Normal
+		mode classic: statistical modulation results'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
-	class ResultData(StructBase):
+	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Offset: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Init_Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_199_P_9: float or bool: float Range: -4 MHz to 4 MHz
+			- Freq_Accuracy: float or bool: float Unit: Hz
+			- Freq_Drift: float or bool: float Unit: Hz
+			- Max_Drift: float or bool: float Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Range: -99.99 dBm to 99.99 dBm
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Init_Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_199_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Freq_Offset')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Offset: float = None
-			self.Freq_Drift: float = None
-			self.Init_Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_199_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Freq_Offset: float or bool = None
 
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:XMINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le1M.xminimum.fetch() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:XMINimum?', self.__class__.ResultData())
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:CURRent \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.lrange.current.calculate() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'Normal
+		mode classic: statistical modulation results'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:CURRent?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy[:LE1M]:XMINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le1M.xminimum.read() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.current.read() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'Normal
+		mode classic: statistical modulation results'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE1M:XMINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:CURRent?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le2M_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le2M/Average.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,26 +2,26 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
 			- Delta_F_299_P_9: float: float Range: -4 MHz to 4 MHz
 			- Freq_Accuracy: float: float Unit: Hz
 			- Freq_Drift: float: float Unit: Hz
 			- Max_Drift: float: float Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
@@ -68,86 +68,86 @@
 			self.Mod_Ratio: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:AVERage \n
 		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.average.fetch() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -4 MHz to 4 MHz
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float or bool: float Range: -4 MHz to 4 MHz
+			- Freq_Accuracy: float or bool: float Unit: Hz
+			- Freq_Drift: float or bool: float Unit: Hz
+			- Max_Drift: float or bool: float Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Range: -99.99 dBm to 99.99 dBm
 			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz"""
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
 			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:AVERage \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le2M.average.calculate() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:AVERage?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:AVERage \n
 		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.average.read() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le2M_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le2M/Xmaximum.py`

 * *Files 15% similar despite different names*

```diff
@@ -2,26 +2,26 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XmaximumCls:
+	"""Xmaximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("xmaximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
 			- Delta_F_299_P_9: float: float Range: -4 MHz to 4 MHz
 			- Freq_Accuracy: float: float Unit: Hz
 			- Freq_Drift: float: float Unit: Hz
 			- Max_Drift: float: float Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
@@ -66,88 +66,88 @@
 			self.Freq_Dev_Max_F_2: float = None
 			self.Nominal_Power: float = None
 			self.Mod_Ratio: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.current.fetch() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:XMAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.xmaximum.fetch() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:XMAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -4 MHz to 4 MHz
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float or bool: float Range: -4 MHz to 4 MHz
+			- Freq_Accuracy: float or bool: float Unit: Hz
+			- Freq_Drift: float or bool: float Unit: Hz
+			- Max_Drift: float or bool: float Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Range: -99.99 dBm to 99.99 dBm
 			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz"""
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
 			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le2M.current.calculate() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:XMAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le2M.xmaximum.calculate() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:XMAXimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.current.read() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:XMAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.xmaximum.read() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:XMAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le2M_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Brate/Maximum.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,123 +1,113 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
-	class ResultData(StructBase):
+	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -4 MHz to 4 MHz
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
-			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Mod_Ratio'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
-			self.Mod_Ratio: float = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Mod_Ratio: enums.ResultStatus2 = None
 
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.maximum.fetch() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MAXimum?', self.__class__.ResultData())
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.brate.maximum.calculate() \n
+		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for BR packets. The
+		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
+		one value for each result listed below. \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MAXimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -4 MHz to 4 MHz
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
-			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz"""
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
 			ArgStruct.scalar_float('Freq_Drift'),
 			ArgStruct.scalar_float('Max_Drift'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float('Mod_Ratio')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
 			self.Delta_F_299_P_9: float = None
 			self.Freq_Accuracy: float = None
@@ -126,28 +116,26 @@
 			self.Freq_Dev_Avg_F_1: float = None
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
 			self.Freq_Dev_Avg_F_2: float = None
 			self.Freq_Dev_Min_F_2: float = None
 			self.Freq_Dev_Max_F_2: float = None
 			self.Nominal_Power: float = None
-			self.Mod_Ratio: enums.ResultStatus2 = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Mod_Ratio: float = None
 
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le2M.maximum.calculate() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MAXimum?', self.__class__.CalculateStruct())
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.brate.maximum.fetch() \n
+		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for BR packets. The
+		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
+		one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MAXimum?', self.__class__.ResultData())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.maximum.read() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.brate.maximum.read() \n
+		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for BR packets. The
+		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
+		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le2M_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le2M/Maximum.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,122 +2,152 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float: float Range: -4 MHz to 4 MHz
+			- Freq_Accuracy: float: float Unit: Hz
+			- Freq_Drift: float: float Unit: Hz
+			- Max_Drift: float: float Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available
 			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
-			- Mod_Ratio: float: float Range: 0 to 1"""
+			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
+			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz
+			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_299_P_9'),
+			ArgStruct.scalar_float('Freq_Accuracy'),
+			ArgStruct.scalar_float('Freq_Drift'),
+			ArgStruct.scalar_float('Max_Drift'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Mod_Ratio')]
+			ArgStruct.scalar_float('Mod_Ratio'),
+			ArgStruct.scalar_float('Freq_Offset'),
+			ArgStruct.scalar_float('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
 			self.Delta_F_299_P_9: float = None
+			self.Freq_Accuracy: float = None
+			self.Freq_Drift: float = None
+			self.Max_Drift: float = None
 			self.Freq_Dev_Avg_F_1: float = None
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
 			self.Freq_Dev_Avg_F_2: float = None
 			self.Freq_Dev_Min_F_2: float = None
 			self.Freq_Dev_Max_F_2: float = None
 			self.Nominal_Power: float = None
 			self.Mod_Ratio: float = None
+			self.Freq_Offset: float = None
+			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.minimum.fetch() \n
-		Returns the minimum modulation results for LE 2M PHY in normal mode, see 'LE: Statistical Modulation Results '.
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.maximum.fetch() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
-			- Mod_Ratio: enums.ResultStatus2: float Range: 0 to 1"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float or bool: float Range: -4 MHz to 4 MHz
+			- Freq_Accuracy: float or bool: float Unit: Hz
+			- Freq_Drift: float or bool: float Unit: Hz
+			- Max_Drift: float or bool: float Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Range: -99.99 dBm to 99.99 dBm
+			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2)]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le2M.minimum.calculate() \n
-		Returns the minimum modulation results for LE 2M PHY in normal mode, see 'LE: Statistical Modulation Results '.
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le2M.maximum.calculate() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MINimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MAXimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.minimum.read() \n
-		Returns the minimum modulation results for LE 2M PHY in normal mode, see 'LE: Statistical Modulation Results '.
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.maximum.read() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:MAXimum?', self.__class__.ResultData())
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le2M_/StandardDev.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/StandardDev/Extended.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,117 +1,93 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
-from ....... import enums
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class ExtendedCls:
+	"""Extended commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("extended", core, parent)
 
 	# noinspection PyTypeChecker
-	class ResultData(StructBase):
+	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
-			- Mod_Ratio: float: float Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment. The meaning of the returned values is the same as for the common reliability indicator, see previous parameter.
+			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 % , Unit: %
+			- Nominal_Power: float: float Standard deviation of average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Freq_Acc_Or_Init_Freq_Error: float: float Standard deviation of frequency accuracy (BR, LE) or initial center frequency error ωi (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float: float Standard deviation of frequency drift (BR, LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift_Rate: float: float Standard deviation of maximal drift rate (BR, LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Delta_F_299_P: float: float Standard deviation of frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur (BR, LE) . Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Omegai_Omega_0: float: No parameter help available
+			- Omega_0_Max: float: float Standard deviation of maximum compensated frequency error (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Rms_Devm: float: float Standard deviation of RMS DEVM (EDR) Range: 0.0 to 1.0
+			- Peak_Devm: float: float Standard deviation of peak DEVM (EDR) Range: 0.0 to 1.0
+			- P_99_Devm: float: float Standard deviation of DEVM value below which 99% of all measured DEVM values occur (EDR) . Range: 0.0 to 1.0
+			- Freq_Offset: float: float Standard deviation of frequency offset (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Init_Freq_Drift: float: float Standard deviation of initial frequency drift (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Delta_F_199_P: float: float Standard deviation of frequency deviation value Δf1 above which 99.9% of all measured Δf1 values occur (LE coded PHY) . Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Cte_Freq_Drift: float: float Frequency drift of CTE portion Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Cte_Mx_Drift_Rate: float: No parameter help available
+			- Cte_Freq_Offset: float: float Frequency offset of CTE portion Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Cte_Int_Frq_Drift: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Mod_Ratio'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Nominal_Power: float = None
-			self.Mod_Ratio: float = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
-
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.standardDev.fetch() \n
-		Returns the standard deviation modulation results for LE 2M PHY in normal mode, see 'LE: Statistical Modulation Results '.
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:SDEViation?', self.__class__.ResultData())
-
-	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
-		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
-			- Mod_Ratio: enums.ResultStatus2: float Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
+			ArgStruct.scalar_float('Freq_Acc_Or_Init_Freq_Error'),
 			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
+			ArgStruct.scalar_float('Max_Drift_Rate'),
+			ArgStruct.scalar_float('Delta_F_299_P'),
+			ArgStruct.scalar_float('Omegai_Omega_0'),
+			ArgStruct.scalar_float('Omega_0_Max'),
+			ArgStruct.scalar_float('Rms_Devm'),
+			ArgStruct.scalar_float('Peak_Devm'),
+			ArgStruct.scalar_float('P_99_Devm'),
 			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float('Init_Freq_Drift'),
+			ArgStruct.scalar_float('Delta_F_199_P'),
+			ArgStruct.scalar_float('Cte_Freq_Drift'),
+			ArgStruct.scalar_float('Cte_Mx_Drift_Rate'),
+			ArgStruct.scalar_float('Cte_Freq_Offset'),
+			ArgStruct.scalar_float('Cte_Int_Frq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
+			self.Seg_Reliability: int = None
 			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
 			self.Nominal_Power: float = None
-			self.Mod_Ratio: enums.ResultStatus2 = None
+			self.Freq_Acc_Or_Init_Freq_Error: float = None
+			self.Freq_Drift: float = None
+			self.Max_Drift_Rate: float = None
+			self.Delta_F_299_P: float = None
+			self.Omegai_Omega_0: float = None
+			self.Omega_0_Max: float = None
+			self.Rms_Devm: float = None
+			self.Peak_Devm: float = None
+			self.P_99_Devm: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
-
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:SDEViation \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le2M.standardDev.calculate() \n
-		Returns the standard deviation modulation results for LE 2M PHY in normal mode, see 'LE: Statistical Modulation Results '.
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:SDEViation?', self.__class__.CalculateStruct())
-
-	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.standardDev.read() \n
-		Returns the standard deviation modulation results for LE 2M PHY in normal mode, see 'LE: Statistical Modulation Results '.
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:SDEViation?', self.__class__.ResultData())
+			self.Delta_F_199_P: float = None
+			self.Cte_Freq_Drift: float = None
+			self.Cte_Mx_Drift_Rate: float = None
+			self.Cte_Freq_Offset: float = None
+			self.Cte_Int_Frq_Drift: float = None
+
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:SDEViation:EXTended \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.standardDev.extended.fetch(segment = repcap.Segment.Default) \n
+		Returns modulation single value results for segment<no> in list mode including Bluetooth version 5.0 and higher.
+		The command returns all parameters listed below, independent of the selected list mode setup. However, only for some of
+		the parameters measured values are available. For the other parameters, only an indicator is returned (e.g. NAV) . \n
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+			:return: structure: for return value, see the help for FetchStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:SDEViation:EXTended?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le2M_/Xmaximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Brate/Xminimum.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,123 +1,113 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Xmaximum:
-	"""Xmaximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XminimumCls:
+	"""Xminimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("xmaximum", core, parent)
+		self._cmd_group = CommandsGroup("xminimum", core, parent)
 
 	# noinspection PyTypeChecker
-	class ResultData(StructBase):
+	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -4 MHz to 4 MHz
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
-			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float or bool: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Mod_Ratio'),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
-			self.Mod_Ratio: float = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Mod_Ratio: enums.ResultStatus2 = None
 
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:XMAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.xmaximum.fetch() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:XMAXimum?', self.__class__.ResultData())
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMINimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.brate.xminimum.calculate() \n
+		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for BR packets. The
+		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
+		one value for each result listed below. \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMINimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -4 MHz to 4 MHz
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Delta_F_299_P_9: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
-			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz"""
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
 			ArgStruct.scalar_float('Freq_Drift'),
 			ArgStruct.scalar_float('Max_Drift'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float('Mod_Ratio')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
 			self.Delta_F_299_P_9: float = None
 			self.Freq_Accuracy: float = None
@@ -126,28 +116,26 @@
 			self.Freq_Dev_Avg_F_1: float = None
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
 			self.Freq_Dev_Avg_F_2: float = None
 			self.Freq_Dev_Min_F_2: float = None
 			self.Freq_Dev_Max_F_2: float = None
 			self.Nominal_Power: float = None
-			self.Mod_Ratio: enums.ResultStatus2 = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Mod_Ratio: float = None
 
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:XMAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le2M.xmaximum.calculate() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:XMAXimum?', self.__class__.CalculateStruct())
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.brate.xminimum.fetch() \n
+		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for BR packets. The
+		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
+		one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMINimum?', self.__class__.ResultData())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:XMAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.xmaximum.read() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.brate.xminimum.read() \n
+		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for BR packets. The
+		values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
+		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:XMAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:BRATe:XMINimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le2M_/Xminimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le2M/Xminimum.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,26 +2,26 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Xminimum:
-	"""Xminimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XminimumCls:
+	"""Xminimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("xminimum", core, parent)
+		self._cmd_group = CommandsGroup("xminimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
 			- Delta_F_299_P_9: float: float Range: -4 MHz to 4 MHz
 			- Freq_Accuracy: float: float Unit: Hz
 			- Freq_Drift: float: float Unit: Hz
 			- Max_Drift: float: float Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
@@ -68,86 +68,86 @@
 			self.Mod_Ratio: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:XMINimum \n
 		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.xminimum.fetch() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:XMINimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_299_P_9: float: float Range: -4 MHz to 4 MHz
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Freq_Dev_Avg_F_2: float: No parameter help available
-			- Freq_Dev_Min_F_2: float: No parameter help available
-			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float or bool: float Range: -4 MHz to 4 MHz
+			- Freq_Accuracy: float or bool: float Unit: Hz
+			- Freq_Drift: float or bool: float Unit: Hz
+			- Max_Drift: float or bool: float Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Range: -99.99 dBm to 99.99 dBm
 			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz"""
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_299_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
-			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
 			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
-			ArgStruct.scalar_float('Freq_Offset'),
-			ArgStruct.scalar_float('Init_Freq_Drift')]
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_299_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Freq_Dev_Avg_F_2: float = None
-			self.Freq_Dev_Min_F_2: float = None
-			self.Freq_Dev_Max_F_2: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
 			self.Mod_Ratio: enums.ResultStatus2 = None
-			self.Freq_Offset: float = None
-			self.Init_Freq_Drift: float = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:XMINimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le2M.xminimum.calculate() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:XMINimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:XMINimum \n
 		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.xminimum.read() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:XMINimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Le2M_/YieldPy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/Qhsl/P2Q.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,25 +1,24 @@
-from typing import List
-
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .......Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class YieldPy:
-	"""YieldPy commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class P2QCls:
+	"""P2Q commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("yieldPy", core, parent)
+		self._cmd_group = CommandsGroup("p2Q", core, parent)
 
-	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:YIELd \n
-		Snippet: value: List[float] = driver.multiEval.modulation.nmode.lowEnergy.le2M.yieldPy.fetch() \n
+	def fetch(self) -> int:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PLENgth:QHSL:P2Q \n
+		Snippet: value: int = driver.inputSignal.adetected.plength.qhsl.p2Q.fetch() \n
 		No command help available \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: pattern_yield: No help available"""
+			:return: payload_length: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:YIELd?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:PLENgth:QHSL:P2Q?', suppressed)
+		return Conversions.str_to_int(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Lrange.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le1M/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,83 +1,75 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Lrange:
-	"""Lrange commands group definition. 24 total commands, 8 Sub-groups, 0 group commands"""
+class Le1MCls:
+	"""Le1M commands group definition. 21 total commands, 7 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lrange", core, parent)
+		self._cmd_group = CommandsGroup("le1M", core, parent)
 
 	@property
 	def xmaximum(self):
 		"""xmaximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_xmaximum'):
-			from .Lrange_.Xmaximum import Xmaximum
-			self._xmaximum = Xmaximum(self._core, self._base)
+			from .Xmaximum import XmaximumCls
+			self._xmaximum = XmaximumCls(self._core, self._cmd_group)
 		return self._xmaximum
 
 	@property
 	def xminimum(self):
 		"""xminimum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_xminimum'):
-			from .Lrange_.Xminimum import Xminimum
-			self._xminimum = Xminimum(self._core, self._base)
+			from .Xminimum import XminimumCls
+			self._xminimum = XminimumCls(self._core, self._cmd_group)
 		return self._xminimum
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Lrange_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Lrange_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_current'):
-			from .Lrange_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
-
-	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Lrange_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
+	def current(self):
+		"""current commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
+
+	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Lrange_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	@property
-	def stDev(self):
-		"""stDev commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_stDev'):
-			from .Lrange_.StDev import StDev
-			self._stDev = StDev(self._core, self._base)
-		return self._stDev
-
-	def clone(self) -> 'Lrange':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'Le1MCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Lrange(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = Le1MCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Lrange_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Lrange/Minimum.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,122 +1,98 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_199_P_9: float: float Range: -4 MHz to 4 MHz
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz"""
+			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
 			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
 			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
+			ArgStruct.scalar_float('Nominal_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
 			self.Delta_F_199_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
 			self.Freq_Dev_Avg_F_1: float = None
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
 			self.Nominal_Power: float = None
-			self.Freq_Offset: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.average.fetch() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.minimum.fetch() \n
+		Returns the minimum modulation results for LE coded PHY in normal mode, see 'Normal mode classic: statistical modulation
+		results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MINimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_199_P_9: float: float Range: -4 MHz to 4 MHz
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_199_P_9: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Range: -99.99 dBm to 99.99 dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_199_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Nominal_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Nominal_Power: float = None
-			self.Freq_Offset: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_199_P_9: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Nominal_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.lrange.average.calculate() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MINimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.lrange.minimum.calculate() \n
+		Returns the minimum modulation results for LE coded PHY in normal mode, see 'Normal mode classic: statistical modulation
+		results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MINimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.average.read() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MINimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.minimum.read() \n
+		Returns the minimum modulation results for LE coded PHY in normal mode, see 'Normal mode classic: statistical modulation
+		results'. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MINimum?', self.__class__.ResultData())
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Lrange_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Lrange/Average.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_199_P_9: float: float Range: -4 MHz to 4 MHz
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz"""
+			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_199_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
 			ArgStruct.scalar_float('Freq_Drift'),
 			ArgStruct.scalar_float('Max_Drift'),
@@ -50,73 +50,73 @@
 			self.Freq_Dev_Avg_F_1: float = None
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
 			self.Nominal_Power: float = None
 			self.Freq_Offset: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.current.fetch() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.average.fetch() \n
+		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
+		see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_199_P_9: float: float Range: -4 MHz to 4 MHz
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Delta_F_199_P_9: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_199_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Freq_Offset')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Nominal_Power: float = None
-			self.Freq_Offset: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_199_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Freq_Offset: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.lrange.current.calculate() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:AVERage \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.lrange.average.calculate() \n
+		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
+		see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:AVERage?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.current.read() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.average.read() \n
+		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
+		see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Lrange_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le1M/Average.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,122 +1,115 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
-	class ResultData(StructBase):
+	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_199_P_9: float: float Range: -4 MHz to 4 MHz
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Power: float or bool: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Leakage_Power: float or bool: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
+
+		def __init__(self):
+			StructBase.__init__(self, self)
+			self.Reliability: int = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
+
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy[:LE1M]:AVERage \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.le1M.average.calculate() \n
+		Returns the power results for LE 1M PHY (uncoded) . The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE1M:AVERage?', self.__class__.CalculateStruct())
+
+	# noinspection PyTypeChecker
+	class ReadStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+		__meta_args_list = [
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
+			ArgStruct.scalar_float('Peak_Power'),
+			ArgStruct.scalar_float('Leakage_Power'),
+			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
+			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
-			self.Freq_Offset: float = None
-
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.maximum.fetch() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MAXimum?', self.__class__.ResultData())
+			self.Peak_Power: float = None
+			self.Leakage_Power: float = None
+			self.Peak_Min_Avg_Pow: float = None
+
+	def read(self) -> ReadStruct:
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy[:LE1M]:AVERage \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.lowEnergy.le1M.average.read() \n
+		Returns the power results for LE 1M PHY (uncoded) . The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ReadStruct structure arguments."""
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE1M:AVERage?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
+	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_199_P_9: float: float Range: -4 MHz to 4 MHz
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
+			ArgStruct.scalar_float('Peak_Power'),
+			ArgStruct.scalar_float('Leakage_Power'),
+			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
 			self.Nominal_Power: float = None
-			self.Freq_Offset: float = None
-
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.lrange.maximum.calculate() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MAXimum?', self.__class__.CalculateStruct())
-
-	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.maximum.read() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MAXimum?', self.__class__.ResultData())
+			self.Peak_Power: float = None
+			self.Leakage_Power: float = None
+			self.Peak_Min_Avg_Pow: float = None
+
+	def fetch(self) -> FetchStruct:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy[:LE1M]:AVERage \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.lowEnergy.le1M.average.fetch() \n
+		Returns the power results for LE 1M PHY (uncoded) . The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for FetchStruct structure arguments."""
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE1M:AVERage?', self.__class__.FetchStruct())
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Lrange_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Nmode/Classic.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,98 +1,86 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from typing import List
+
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Types import DataType
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class ClassicCls:
+	"""Classic commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("classic", core, parent)
 
 	# noinspection PyTypeChecker
-	class ResultData(StructBase):
+	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Sacp CMDLINKRESOLVED]) exceeding the specified BR limits, see 'ACP (BR, LE) '. Range: 0 % to 100 %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm
+			- No_Of_Exceptions: float or bool: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99
+			- Acp: List[float or bool]: float 21 ACP values - results for the relative channels -10, ..., 0, ..., +10 (mode 'ACP +/-10 Channels') Range: -99.99 dBm to 99.99 dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Nominal_Power')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('No_Of_Exceptions'),
+			ArgStruct('Acp', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Nominal_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.No_Of_Exceptions: float or bool = None
+			self.Acp: List[float or bool] = None
 
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.minimum.fetch() \n
-		Returns the minimum modulation results for LE coded PHY in normal mode, see 'LE: Statistical Modulation Results '.
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MINimum?', self.__class__.ResultData())
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:CLASsic \n
+		Snippet: value: CalculateStruct = driver.multiEval.sacp.nmode.classic.calculate() \n
+		Returns the 'Spectrum ACP' results for normal mode classic. The values described below are returned by FETCh and READ
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:CLASsic?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Sacp CMDLINKRESOLVED]) exceeding the specified BR limits, see 'ACP (BR, LE) '. Range: 0 % to 100 %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm
+			- No_Of_Exceptions: int: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99
+			- Acp: List[float]: float 21 ACP values - results for the relative channels -10, ..., 0, ..., +10 (mode 'ACP +/-10 Channels') Range: -99.99 dBm to 99.99 dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Nominal_Power')]
+			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_int('No_Of_Exceptions'),
+			ArgStruct('Acp', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
 			self.Nominal_Power: float = None
-
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.lrange.minimum.calculate() \n
-		Returns the minimum modulation results for LE coded PHY in normal mode, see 'LE: Statistical Modulation Results '.
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MINimum?', self.__class__.CalculateStruct())
+			self.No_Of_Exceptions: int = None
+			self.Acp: List[float] = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.minimum.read() \n
-		Returns the minimum modulation results for LE coded PHY in normal mode, see 'LE: Statistical Modulation Results '.
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:CLASsic \n
+		Snippet: value: ResultData = driver.multiEval.sacp.nmode.classic.read() \n
+		Returns the 'Spectrum ACP' results for normal mode classic. The values described below are returned by FETCh and READ
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:CLASsic?', self.__class__.ResultData())
+
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:CLASsic \n
+		Snippet: value: ResultData = driver.multiEval.sacp.nmode.classic.fetch() \n
+		Returns the 'Spectrum ACP' results for normal mode classic. The values described below are returned by FETCh and READ
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:CLASsic?', self.__class__.ResultData())
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Lrange_/StDev.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Lrange/StDev.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StDev:
-	"""StDev commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StDevCls:
+	"""StDev commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("stDev", core, parent)
+		self._cmd_group = CommandsGroup("stDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tol: float: No parameter help available
 			- Delta_F_199_P_9: float: No parameter help available
@@ -51,41 +51,41 @@
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:STDev?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
-			- Out_Of_Tol: float: No parameter help available
-			- Delta_F_199_P_9: float: No parameter help available
-			- Freq_Accuracy: float: No parameter help available
-			- Freq_Drift: float: No parameter help available
-			- Max_Drift: float: No parameter help available
-			- Nominal_Power: float: No parameter help available
-			- Freq_Offset: float: No parameter help available"""
+			- Out_Of_Tol: float or bool: No parameter help available
+			- Delta_F_199_P_9: float or bool: No parameter help available
+			- Freq_Accuracy: float or bool: No parameter help available
+			- Freq_Drift: float or bool: No parameter help available
+			- Max_Drift: float or bool: No parameter help available
+			- Nominal_Power: float or bool: No parameter help available
+			- Freq_Offset: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_199_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Freq_Offset')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Nominal_Power: float = None
-			self.Freq_Offset: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_199_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Freq_Offset: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:STDev \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.lrange.stDev.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:STDev?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Lrange_/StandardDev.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Average/Extended.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,104 +1,102 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class ExtendedCls:
+	"""Extended commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("extended", core, parent)
 
 	# noinspection PyTypeChecker
-	class ResultData(StructBase):
+	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment. The meaning of the returned values is the same as for the common reliability indicator, see previous parameter.
+			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 % , Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Freq_Acc_Or_Init_Freq_Error: float: float Frequency accuracy (BR, LE) or initial center frequency error ωi (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float: float Frequency drift (BR, LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift_Rate: float: float Maximal drift rate (BR, LE) Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Delta_F_1_Avg: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
+			- Delta_F_1_Min: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
+			- Delta_F_1_Max: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
+			- Delta_F_2_Avg: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
+			- Delta_F_2_Min: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
+			- Delta_F_2_Max: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
+			- Omegai_Omega_0: float: No parameter help available
+			- Omega_0_Max: float: float Maximum compensated frequency error (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Rms_Devm: float: float RMS DEVM (EDR) Range: 0.0 to 1.0
+			- Peak_Devm: float: float Peak DEVM (EDR) Range: 0.0 to 1.0
+			- Freq_Offset: float: float Frequency offset (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Init_Freq_Drift: float: float Initial frequency drift (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Cte_Freq_Drift: float: float Frequency drift of CTE portion Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Cte_Mx_Drift_Rate: float: No parameter help available
+			- Cte_Freq_Offset: float: float Frequency offset of CTE portion Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Cte_Int_Frq_Drift: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Nominal_Power: float = None
-			self.Freq_Offset: float = None
-
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.standardDev.fetch() \n
-		Returns the standard deviation modulation results for LE coded PHY in normal mode, see 'LE: Statistical Modulation
-		Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
-		results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:SDEViation?', self.__class__.ResultData())
-
-	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
-		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %, Unit: %
-			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
-			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
-			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
+			ArgStruct.scalar_float('Freq_Acc_Or_Init_Freq_Error'),
 			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
+			ArgStruct.scalar_float('Max_Drift_Rate'),
+			ArgStruct.scalar_float('Delta_F_1_Avg'),
+			ArgStruct.scalar_float('Delta_F_1_Min'),
+			ArgStruct.scalar_float('Delta_F_1_Max'),
+			ArgStruct.scalar_float('Delta_F_2_Avg'),
+			ArgStruct.scalar_float('Delta_F_2_Min'),
+			ArgStruct.scalar_float('Delta_F_2_Max'),
+			ArgStruct.scalar_float('Omegai_Omega_0'),
+			ArgStruct.scalar_float('Omega_0_Max'),
+			ArgStruct.scalar_float('Rms_Devm'),
+			ArgStruct.scalar_float('Peak_Devm'),
+			ArgStruct.scalar_float('Freq_Offset'),
+			ArgStruct.scalar_float('Init_Freq_Drift'),
+			ArgStruct.scalar_float('Cte_Freq_Drift'),
+			ArgStruct.scalar_float('Cte_Mx_Drift_Rate'),
+			ArgStruct.scalar_float('Cte_Freq_Offset'),
+			ArgStruct.scalar_float('Cte_Int_Frq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
+			self.Seg_Reliability: int = None
 			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
 			self.Nominal_Power: float = None
+			self.Freq_Acc_Or_Init_Freq_Error: float = None
+			self.Freq_Drift: float = None
+			self.Max_Drift_Rate: float = None
+			self.Delta_F_1_Avg: float = None
+			self.Delta_F_1_Min: float = None
+			self.Delta_F_1_Max: float = None
+			self.Delta_F_2_Avg: float = None
+			self.Delta_F_2_Min: float = None
+			self.Delta_F_2_Max: float = None
+			self.Omegai_Omega_0: float = None
+			self.Omega_0_Max: float = None
+			self.Rms_Devm: float = None
+			self.Peak_Devm: float = None
 			self.Freq_Offset: float = None
-
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:SDEViation \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.lrange.standardDev.calculate() \n
-		Returns the standard deviation modulation results for LE coded PHY in normal mode, see 'LE: Statistical Modulation
-		Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
-		results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:SDEViation?', self.__class__.CalculateStruct())
-
-	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.standardDev.read() \n
-		Returns the standard deviation modulation results for LE coded PHY in normal mode, see 'LE: Statistical Modulation
-		Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
-		results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:SDEViation?', self.__class__.ResultData())
+			self.Init_Freq_Drift: float = None
+			self.Cte_Freq_Drift: float = None
+			self.Cte_Mx_Drift_Rate: float = None
+			self.Cte_Freq_Offset: float = None
+			self.Cte_Int_Frq_Drift: float = None
+
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:AVERage:EXTended \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.average.extended.fetch(segment = repcap.Segment.Default) \n
+		Returns modulation single average value results for segment<no> in list mode including Bluetooth version 5.0 and higher.
+		The command returns all parameters listed below, independent of the selected list mode setup. However, only for some of
+		the parameters measured values are available. For the other parameters, only an indicator is returned (e.g. NAV) . \n
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+			:return: structure: for return value, see the help for FetchStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:AVERage:EXTended?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Lrange_/Xmaximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/LowEnergy/Lrange/Maximum.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Xmaximum:
-	"""Xmaximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("xmaximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_199_P_9: float: float Range: -4 MHz to 4 MHz
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Delta_F_199_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz"""
+			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_199_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
 			ArgStruct.scalar_float('Freq_Drift'),
 			ArgStruct.scalar_float('Max_Drift'),
@@ -50,73 +50,73 @@
 			self.Freq_Dev_Avg_F_1: float = None
 			self.Freq_Dev_Min_F_1: float = None
 			self.Freq_Dev_Max_F_1: float = None
 			self.Nominal_Power: float = None
 			self.Freq_Offset: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.xmaximum.fetch() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.maximum.fetch() \n
+		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
+		see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:MAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_199_P_9: float: float Range: -4 MHz to 4 MHz
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %, Unit: %
+			- Delta_F_199_P_9: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Delta_F_199_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Freq_Offset')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
-			self.Nominal_Power: float = None
-			self.Freq_Offset: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Delta_F_199_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Freq_Offset: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.lrange.xmaximum.calculate() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:MAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.lowEnergy.lrange.maximum.calculate() \n
+		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
+		see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:MAXimum?', self.__class__.CalculateStruct())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMAXimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.xmaximum.read() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.modulation.lowEnergy.lrange.maximum.read() \n
+		Returns the current, average, absolute min (xmin) , absolute max (xmax) , and max modulation results for LE coded PHY,
+		see 'View TX Measurement - modulation statistics'. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:LENergy:LRANge:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Modulation_/Nmode_/LowEnergy_/Lrange_/Xminimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le1M/Maximum.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,122 +1,115 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Xminimum:
-	"""Xminimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("xminimum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
-	class ResultData(StructBase):
+	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_199_P_9: float: float Range: -4 MHz to 4 MHz
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Power: float or bool: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Leakage_Power: float or bool: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
+
+		def __init__(self):
+			StructBase.__init__(self, self)
+			self.Reliability: int = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
+
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy[:LE1M]:MAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.le1M.maximum.calculate() \n
+		Returns the power results for LE 1M PHY (uncoded) . The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE1M:MAXimum?', self.__class__.CalculateStruct())
+
+	# noinspection PyTypeChecker
+	class ReadStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+		__meta_args_list = [
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
+			ArgStruct.scalar_float('Peak_Power'),
+			ArgStruct.scalar_float('Leakage_Power'),
+			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
+			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
-			self.Freq_Offset: float = None
-
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.xminimum.fetch() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMINimum?', self.__class__.ResultData())
+			self.Peak_Power: float = None
+			self.Leakage_Power: float = None
+			self.Peak_Min_Avg_Pow: float = None
+
+	def read(self) -> ReadStruct:
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy[:LE1M]:MAXimum \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.lowEnergy.le1M.maximum.read() \n
+		Returns the power results for LE 1M PHY (uncoded) . The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ReadStruct structure arguments."""
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE1M:MAXimum?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
+	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '. Range: 0 % to 100 %
-			- Delta_F_199_P_9: float: float Range: -4 MHz to 4 MHz
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float Unit: Hz/50 μs
-			- Freq_Dev_Avg_F_1: float: No parameter help available
-			- Freq_Dev_Min_F_1: float: No parameter help available
-			- Freq_Dev_Max_F_1: float: No parameter help available
-			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
-			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Delta_F_199_P_9'),
-			ArgStruct.scalar_float('Freq_Accuracy'),
-			ArgStruct.scalar_float('Freq_Drift'),
-			ArgStruct.scalar_float('Max_Drift'),
-			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
-			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Freq_Offset')]
+			ArgStruct.scalar_float('Peak_Power'),
+			ArgStruct.scalar_float('Leakage_Power'),
+			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
-			self.Delta_F_199_P_9: float = None
-			self.Freq_Accuracy: float = None
-			self.Freq_Drift: float = None
-			self.Max_Drift: float = None
-			self.Freq_Dev_Avg_F_1: float = None
-			self.Freq_Dev_Min_F_1: float = None
-			self.Freq_Dev_Max_F_1: float = None
 			self.Nominal_Power: float = None
-			self.Freq_Offset: float = None
-
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.lrange.xminimum.calculate() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMINimum?', self.__class__.CalculateStruct())
-
-	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMINimum \n
-		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.lrange.xminimum.read() \n
-		Returns the current, average, xmin, xmax, and maximum modulation results for LE coded PHY in normal mode, see 'LE:
-		Statistical Modulation Results '. The values described below are returned by FETCh and READ commands. CALCulate commands
-		return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LRANge:XMINimum?', self.__class__.ResultData())
+			self.Peak_Power: float = None
+			self.Leakage_Power: float = None
+			self.Peak_Min_Avg_Pow: float = None
+
+	def fetch(self) -> FetchStruct:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy[:LE1M]:MAXimum \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.lowEnergy.le1M.maximum.fetch() \n
+		Returns the power results for LE 1M PHY (uncoded) . The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for FetchStruct structure arguments."""
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE1M:MAXimum?', self.__class__.FetchStruct())
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sgacp/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pencoding:
-	"""Pencoding commands group definition. 7 total commands, 2 Sub-groups, 0 group commands"""
+class SgacpCls:
+	"""Sgacp commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pencoding", core, parent)
-
-	@property
-	def ssequence(self):
-		"""ssequence commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_ssequence'):
-			from .Pencoding_.Ssequence import Ssequence
-			self._ssequence = Ssequence(self._core, self._base)
-		return self._ssequence
+		self._cmd_group = CommandsGroup("sgacp", core, parent)
 
 	@property
 	def edrate(self):
 		"""edrate commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_edrate'):
-			from .Pencoding_.Edrate import Edrate
-			self._edrate = Edrate(self._core, self._base)
+			from .Edrate import EdrateCls
+			self._edrate = EdrateCls(self._core, self._cmd_group)
 		return self._edrate
 
-	def clone(self) -> 'Pencoding':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SgacpCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pencoding(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SgacpCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/Edrate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Pencoding/Ssequence/Edrate/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Edrate:
-	"""Edrate commands group definition. 4 total commands, 1 Sub-groups, 0 group commands"""
+class EdrateCls:
+	"""Edrate commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("edrate", core, parent)
+		self._cmd_group = CommandsGroup("edrate", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 1 Sub-classes, 3 commands."""
+		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Edrate_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
-	def clone(self) -> 'Edrate':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EdrateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Edrate(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EdrateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/Edrate_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Pencoding/Edrate/Current/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,33 +1,33 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 4 total commands, 1 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 4 total commands, 1 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
 	def c(self):
 		"""c commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_c'):
-			from .Current_.C import C
-			self._c = C(self._core, self._base)
+			from .C import CCls
+			self._c = CCls(self._core, self._cmd_group)
 		return self._c
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: float 'Reliability Indicator'
+			- Reliability: int: float 'Reliability indicator'
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Bit_Error_Rate: float: float Number of bit errors in the received burst, as a percentage of the total number of bits received Range: 0 % to 100 %, Unit: %
 			- Packets_0_Errors: float: float Number of bit error free packets received, as a percentage of all the bursts received Range: 0 % to 100 %, Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Bit_Error_Rate'),
@@ -75,40 +75,40 @@
 		No command help available \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PENCoding:EDRate:CURRent?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: float 'Reliability Indicator'
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Bit_Error_Rate: float: float Number of bit errors in the received burst, as a percentage of the total number of bits received Range: 0 % to 100 %, Unit: %
-			- Packets_0_Errors: float: float Number of bit error free packets received, as a percentage of all the bursts received Range: 0 % to 100 %, Unit: %"""
+			- Reliability: int: float 'Reliability indicator'
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Bit_Error_Rate: float or bool: float Number of bit errors in the received burst, as a percentage of the total number of bits received Range: 0 % to 100 %, Unit: %
+			- Packets_0_Errors: float or bool: float Number of bit error free packets received, as a percentage of all the bursts received Range: 0 % to 100 %, Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Bit_Error_Rate'),
-			ArgStruct.scalar_float('Packets_0_Errors')]
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Bit_Error_Rate'),
+			ArgStruct.scalar_float_ext('Packets_0_Errors')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Nominal_Power: float = None
-			self.Bit_Error_Rate: float = None
-			self.Packets_0_Errors: float = None
+			self.Nominal_Power: float or bool = None
+			self.Bit_Error_Rate: float or bool = None
+			self.Packets_0_Errors: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PENCoding:EDRate:CURRent \n
 		Snippet: value: CalculateStruct = driver.multiEval.pencoding.edrate.current.calculate() \n
 		Returns the 'Differential Phase Encoding' results for EDR packets (single values) . The values described below are
 		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
 		listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PENCoding:EDRate:CURRent?', self.__class__.CalculateStruct())
 
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/Edrate_/Current_/C.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Pencoding/Edrate/Current/C.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,25 +1,25 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class C:
-	"""C commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CCls:
+	"""C commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("c", core, parent)
+		self._cmd_group = CommandsGroup("c", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: float 'Reliability Indicator'
+			- Reliability: int: float 'Reliability indicator'
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Bit_Error_Rate: float: float Number of bit errors in the received burst, as a percentage of the total number of bits received Range: 0 % to 100 %, Unit: %
 			- Packets_0_Errors: float: float Number of bit error free packets received, as a percentage of all the bursts received Range: 0 % to 100 %, Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Bit_Error_Rate'),
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/Ssequence.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/LowEnergy/Le1M/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ssequence:
-	"""Ssequence commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class Le1MCls:
+	"""Le1M commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ssequence", core, parent)
+		self._cmd_group = CommandsGroup("le1M", core, parent)
 
 	@property
-	def edrate(self):
-		"""edrate commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_edrate'):
-			from .Ssequence_.Edrate import Edrate
-			self._edrate = Edrate(self._core, self._base)
-		return self._edrate
+	def measurement(self):
+		"""measurement commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_measurement'):
+			from .Measurement import MeasurementCls
+			self._measurement = MeasurementCls(self._core, self._cmd_group)
+		return self._measurement
 
-	def clone(self) -> 'Ssequence':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'Le1MCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Ssequence(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = Le1MCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/Ssequence_/Edrate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Sgacp/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Edrate:
-	"""Edrate commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class SgacpCls:
+	"""Sgacp commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("edrate", core, parent)
+		self._cmd_group = CommandsGroup("sgacp", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Edrate_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
-	def clone(self) -> 'Edrate':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SgacpCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Edrate(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SgacpCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Pencoding_/Ssequence_/Edrate_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Pencoding/Ssequence/Edrate/Current.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Nominal_Power: float: float Average burst power during the carrier-on state Range: -99.99 dBm to 99.99 dBm
-			- Sync_Bit_Errors: float: decimal Sync bit errors Range: 0 to 10E+3
-			- Trailer_Bit_Errs: float: decimal Trailer bit errors Range: 0 to 10E+3"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Nominal_Power: float or bool: float Average burst power during the carrier-on state Range: -99.99 dBm to 99.99 dBm
+			- Sync_Bit_Errors: float or bool: decimal Sync bit errors Range: 0 to 10E+3
+			- Trailer_Bit_Errs: float or bool: decimal Trailer bit errors Range: 0 to 10E+3"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Sync_Bit_Errors'),
-			ArgStruct.scalar_float('Trailer_Bit_Errs')]
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Sync_Bit_Errors'),
+			ArgStruct.scalar_float_ext('Trailer_Bit_Errs')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Nominal_Power: float = None
-			self.Sync_Bit_Errors: float = None
-			self.Trailer_Bit_Errs: float = None
+			self.Nominal_Power: float or bool = None
+			self.Sync_Bit_Errors: float or bool = None
+			self.Trailer_Bit_Errs: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PENCoding:SSEQuence:EDRate:CURRent \n
 		Snippet: value: CalculateStruct = driver.multiEval.pencoding.ssequence.edrate.current.calculate() \n
 		Returns the 'Differential Phase Encoding' results for EDR packets in combined signal path. The values described below are
 		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
 		listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PENCoding:SSEQuence:EDRate:CURRent?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
+			- Reliability: int: decimal 'Reliability indicator'
 			- Nominal_Power: float: float Average burst power during the carrier-on state Range: -99.99 dBm to 99.99 dBm
 			- Sync_Bit_Errors: int: decimal Sync bit errors Range: 0 to 10E+3
 			- Trailer_Bit_Errs: int: decimal Trailer bit errors Range: 0 to 10E+3"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_int('Sync_Bit_Errors'),
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Qhsl/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,51 +1,59 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class PowerVsTime:
-	"""PowerVsTime commands group definition. 108 total commands, 4 Sub-groups, 0 group commands"""
+class QhslCls:
+	"""Qhsl commands group definition. 15 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("powerVsTime", core, parent)
+		self._cmd_group = CommandsGroup("qhsl", core, parent)
 
 	@property
-	def nmode(self):
-		"""nmode commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_nmode'):
-			from .PowerVsTime_.Nmode import Nmode
-			self._nmode = Nmode(self._core, self._base)
-		return self._nmode
+	def p2Q(self):
+		"""p2Q commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_p2Q'):
+			from .P2Q import P2QCls
+			self._p2Q = P2QCls(self._core, self._cmd_group)
+		return self._p2Q
 
 	@property
-	def edrate(self):
-		"""edrate commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_edrate'):
-			from .PowerVsTime_.Edrate import Edrate
-			self._edrate = Edrate(self._core, self._base)
-		return self._edrate
+	def p3Q(self):
+		"""p3Q commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_p3Q'):
+			from .P3Q import P3QCls
+			self._p3Q = P3QCls(self._core, self._cmd_group)
+		return self._p3Q
 
 	@property
-	def brate(self):
-		"""brate commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_brate'):
-			from .PowerVsTime_.Brate import Brate
-			self._brate = Brate(self._core, self._base)
-		return self._brate
+	def p4Q(self):
+		"""p4Q commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_p4Q'):
+			from .P4Q import P4QCls
+			self._p4Q = P4QCls(self._core, self._cmd_group)
+		return self._p4Q
 
 	@property
-	def lowEnergy(self):
-		"""lowEnergy commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_lowEnergy'):
-			from .PowerVsTime_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
-		return self._lowEnergy
+	def p5Q(self):
+		"""p5Q commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_p5Q'):
+			from .P5Q import P5QCls
+			self._p5Q = P5QCls(self._core, self._cmd_group)
+		return self._p5Q
 
-	def clone(self) -> 'PowerVsTime':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def p6Q(self):
+		"""p6Q commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_p6Q'):
+			from .P6Q import P6QCls
+			self._p6Q = P6QCls(self._core, self._cmd_group)
+		return self._p6Q
+
+	def clone(self) -> 'QhslCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = PowerVsTime(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = QhslCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Brate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P6Q/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Brate:
-	"""Brate commands group definition. 12 total commands, 4 Sub-groups, 0 group commands"""
+class P6QCls:
+	"""P6Q commands group definition. 12 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("brate", core, parent)
-
-	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_average'):
-			from .Brate_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+		self._cmd_group = CommandsGroup("p6Q", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Brate_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
+	def average(self):
+		"""average commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
+
+	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Brate_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Brate_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'Brate':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'P6QCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Brate(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = P6QCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Brate_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Brate/Current.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,63 +1,63 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
-			- Gfsk_Power: float: float Average power within the access code and header portion of the BR burst (first 126 symbols) . Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Power: float or bool: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Leakage_Power: float or bool: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Packet_Timing: float or bool: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
+			- Gfsk_Power: float or bool: float Average power within the access code and header portion of the BR burst (first 126 symbols) . Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Packet_Timing'),
-			ArgStruct.scalar_float('Gfsk_Power')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Packet_Timing'),
+			ArgStruct.scalar_float_ext('Gfsk_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Packet_Timing: float = None
-			self.Gfsk_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Packet_Timing: float or bool = None
+			self.Gfsk_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.brate.average.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:CURRent \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.brate.current.calculate() \n
 		Returns the power results for BR packets. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:CURRent?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
 			- Gfsk_Power: float: float Average power within the access code and header portion of the BR burst (first 126 symbols) . Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
@@ -75,26 +75,26 @@
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Packet_Timing: float = None
 			self.Gfsk_Power: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:AVERage \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.brate.average.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:CURRent \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.brate.current.read() \n
 		Returns the power results for BR packets. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:AVERage?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:CURRent?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
 			- Gfsk_Power: float: float Average power within the access code and header portion of the BR burst (first 126 symbols) . Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
@@ -112,13 +112,13 @@
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Packet_Timing: float = None
 			self.Gfsk_Power: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.brate.average.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:CURRent \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.brate.current.fetch() \n
 		Returns the power results for BR packets. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:AVERage?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:CURRent?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Brate_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Brate/Average.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,63 +1,63 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
-			- Gfsk_Power: float: float Average power within the access code and header portion of the BR burst (first 126 symbols) . Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Power: float or bool: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Leakage_Power: float or bool: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Packet_Timing: float or bool: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
+			- Gfsk_Power: float or bool: float Average power within the access code and header portion of the BR burst (first 126 symbols) . Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Packet_Timing'),
-			ArgStruct.scalar_float('Gfsk_Power')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Packet_Timing'),
+			ArgStruct.scalar_float_ext('Gfsk_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Packet_Timing: float = None
-			self.Gfsk_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Packet_Timing: float or bool = None
+			self.Gfsk_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.brate.current.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:AVERage \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.brate.average.calculate() \n
 		Returns the power results for BR packets. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:AVERage?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
 			- Gfsk_Power: float: float Average power within the access code and header portion of the BR burst (first 126 symbols) . Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
@@ -75,26 +75,26 @@
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Packet_Timing: float = None
 			self.Gfsk_Power: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:CURRent \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.brate.current.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:AVERage \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.brate.average.read() \n
 		Returns the power results for BR packets. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:CURRent?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:AVERage?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
 			- Gfsk_Power: float: float Average power within the access code and header portion of the BR burst (first 126 symbols) . Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
@@ -112,13 +112,13 @@
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Packet_Timing: float = None
 			self.Gfsk_Power: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.brate.current.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:AVERage \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.brate.average.fetch() \n
 		Returns the power results for BR packets. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:CURRent?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Brate_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Brate/Maximum.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,63 +1,63 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
-			- Gfsk_Power: float: float Average power within the access code and header portion of the BR burst (first 126 symbols) . Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Power: float or bool: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Leakage_Power: float or bool: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Packet_Timing: float or bool: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
+			- Gfsk_Power: float or bool: float Average power within the access code and header portion of the BR burst (first 126 symbols) . Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Packet_Timing'),
-			ArgStruct.scalar_float('Gfsk_Power')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Packet_Timing'),
+			ArgStruct.scalar_float_ext('Gfsk_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Packet_Timing: float = None
-			self.Gfsk_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Packet_Timing: float or bool = None
+			self.Gfsk_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:MAXimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.brate.maximum.calculate() \n
 		Returns the power results for BR packets. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:MAXimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
 			- Gfsk_Power: float: float Average power within the access code and header portion of the BR burst (first 126 symbols) . Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
@@ -85,16 +85,16 @@
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:MAXimum?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
 			- Gfsk_Power: float: float Average power within the access code and header portion of the BR burst (first 126 symbols) . Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Brate_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Brate/Minimum.py`

 * *Files 16% similar despite different names*

```diff
@@ -2,63 +2,63 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Power: float or bool: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Leakage_Power: float or bool: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Packet_Timing: enums.ResultStatus2: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
-			- Gfsk_Power: float: float Average power within the access code and header portion of the BR burst (first 126 symbols) . Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Gfsk_Power: float or bool: float Average power within the access code and header portion of the BR burst (first 126 symbols) . Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
 			ArgStruct.scalar_enum('Packet_Timing', enums.ResultStatus2),
-			ArgStruct.scalar_float('Gfsk_Power')]
+			ArgStruct.scalar_float_ext('Gfsk_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
 			self.Packet_Timing: enums.ResultStatus2 = None
-			self.Gfsk_Power: float = None
+			self.Gfsk_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:MINimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.brate.minimum.calculate() \n
 		Returns the power results for BR packets. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:MINimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
 			- Gfsk_Power: float: float Average power within the access code and header portion of the BR burst (first 126 symbols) . Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
@@ -86,16 +86,16 @@
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:BRATe:MINimum?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
 			- Gfsk_Power: float: float Average power within the access code and header portion of the BR burst (first 126 symbols) . Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Edrate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le2M/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Edrate:
-	"""Edrate commands group definition. 12 total commands, 4 Sub-groups, 0 group commands"""
+class Le2MCls:
+	"""Le2M commands group definition. 12 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("edrate", core, parent)
+		self._cmd_group = CommandsGroup("le2M", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Edrate_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Edrate_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Edrate_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Edrate_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'Edrate':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'Le2MCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Edrate(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = Le2MCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Edrate_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Edrate/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,69 +1,69 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Gfsk_Power: float: float Average power in the GFSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Dpsk_Power: float: float Average power in the DPSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Dpsk_Minus_Gfsk: float: float Difference between DPSK and GFSK power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Guard_Period: float: float Length of the guard band between the packet header and the synchronization sequence Range: 0 µs to 9.99 µs, Unit: s
-			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
-			- Peak_Power: float: float Maximum power within the whole burst. The result is only available via remote command. Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Gfsk_Power: float or bool: float Average power in the GFSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Dpsk_Power: float or bool: float Average power in the DPSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Dpsk_Minus_Gfsk: float or bool: float Difference between DPSK and GFSK power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Guard_Period: float or bool: float Length of the guard band between the packet header and the synchronization sequence Range: 0 µs to 9.99 µs, Unit: s
+			- Packet_Timing: float or bool: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
+			- Peak_Power: float or bool: float Maximum power within the whole burst. The result is only available via remote command. Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Gfsk_Power'),
-			ArgStruct.scalar_float('Dpsk_Power'),
-			ArgStruct.scalar_float('Dpsk_Minus_Gfsk'),
-			ArgStruct.scalar_float('Guard_Period'),
-			ArgStruct.scalar_float('Packet_Timing'),
-			ArgStruct.scalar_float('Peak_Power')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Gfsk_Power'),
+			ArgStruct.scalar_float_ext('Dpsk_Power'),
+			ArgStruct.scalar_float_ext('Dpsk_Minus_Gfsk'),
+			ArgStruct.scalar_float_ext('Guard_Period'),
+			ArgStruct.scalar_float_ext('Packet_Timing'),
+			ArgStruct.scalar_float_ext('Peak_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Gfsk_Power: float = None
-			self.Dpsk_Power: float = None
-			self.Dpsk_Minus_Gfsk: float = None
-			self.Guard_Period: float = None
-			self.Packet_Timing: float = None
-			self.Peak_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Gfsk_Power: float or bool = None
+			self.Dpsk_Power: float or bool = None
+			self.Dpsk_Minus_Gfsk: float or bool = None
+			self.Guard_Period: float or bool = None
+			self.Packet_Timing: float or bool = None
+			self.Peak_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:EDRate:AVERage \n
 		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.edrate.average.calculate() \n
 		Returns the power results for EDR packets. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:EDRate:AVERage?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Gfsk_Power: float: float Average power in the GFSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Dpsk_Power: float: float Average power in the DPSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Dpsk_Minus_Gfsk: float: float Difference between DPSK and GFSK power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Guard_Period: float: float Length of the guard band between the packet header and the synchronization sequence Range: 0 µs to 9.99 µs, Unit: s
 			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
 			- Peak_Power: float: float Maximum power within the whole burst. The result is only available via remote command. Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
@@ -97,16 +97,16 @@
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:EDRate:AVERage?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Gfsk_Power: float: float Average power in the GFSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Dpsk_Power: float: float Average power in the DPSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Dpsk_Minus_Gfsk: float: float Difference between DPSK and GFSK power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Guard_Period: float: float Length of the guard band between the packet header and the synchronization sequence Range: 0 µs to 9.99 µs, Unit: s
 			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
 			- Peak_Power: float: float Maximum power within the whole burst. The result is only available via remote command. Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Edrate_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Edrate/Current.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,69 +1,69 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Gfsk_Power: float: float Average power in the GFSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Dpsk_Power: float: float Average power in the DPSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Dpsk_Minus_Gfsk: float: float Difference between DPSK and GFSK power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Guard_Period: float: float Length of the guard band between the packet header and the synchronization sequence Range: 0 µs to 9.99 µs, Unit: s
-			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
-			- Peak_Power: float: float Maximum power within the whole burst. The result is only available via remote command. Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Gfsk_Power: float or bool: float Average power in the GFSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Dpsk_Power: float or bool: float Average power in the DPSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Dpsk_Minus_Gfsk: float or bool: float Difference between DPSK and GFSK power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Guard_Period: float or bool: float Length of the guard band between the packet header and the synchronization sequence Range: 0 µs to 9.99 µs, Unit: s
+			- Packet_Timing: float or bool: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
+			- Peak_Power: float or bool: float Maximum power within the whole burst. The result is only available via remote command. Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Gfsk_Power'),
-			ArgStruct.scalar_float('Dpsk_Power'),
-			ArgStruct.scalar_float('Dpsk_Minus_Gfsk'),
-			ArgStruct.scalar_float('Guard_Period'),
-			ArgStruct.scalar_float('Packet_Timing'),
-			ArgStruct.scalar_float('Peak_Power')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Gfsk_Power'),
+			ArgStruct.scalar_float_ext('Dpsk_Power'),
+			ArgStruct.scalar_float_ext('Dpsk_Minus_Gfsk'),
+			ArgStruct.scalar_float_ext('Guard_Period'),
+			ArgStruct.scalar_float_ext('Packet_Timing'),
+			ArgStruct.scalar_float_ext('Peak_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Gfsk_Power: float = None
-			self.Dpsk_Power: float = None
-			self.Dpsk_Minus_Gfsk: float = None
-			self.Guard_Period: float = None
-			self.Packet_Timing: float = None
-			self.Peak_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Gfsk_Power: float or bool = None
+			self.Dpsk_Power: float or bool = None
+			self.Dpsk_Minus_Gfsk: float or bool = None
+			self.Guard_Period: float or bool = None
+			self.Packet_Timing: float or bool = None
+			self.Peak_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:EDRate:CURRent \n
 		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.edrate.current.calculate() \n
 		Returns the power results for EDR packets. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:EDRate:CURRent?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Gfsk_Power: float: float Average power in the GFSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Dpsk_Power: float: float Average power in the DPSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Dpsk_Minus_Gfsk: float: float Difference between DPSK and GFSK power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Guard_Period: float: float Length of the guard band between the packet header and the synchronization sequence Range: 0 µs to 9.99 µs, Unit: s
 			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
 			- Peak_Power: float: float Maximum power within the whole burst. The result is only available via remote command. Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
@@ -97,16 +97,16 @@
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:EDRate:CURRent?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Gfsk_Power: float: float Average power in the GFSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Dpsk_Power: float: float Average power in the DPSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Dpsk_Minus_Gfsk: float: float Difference between DPSK and GFSK power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Guard_Period: float: float Length of the guard band between the packet header and the synchronization sequence Range: 0 µs to 9.99 µs, Unit: s
 			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
 			- Peak_Power: float: float Maximum power within the whole burst. The result is only available via remote command. Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Edrate_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Edrate/Maximum.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,69 +2,69 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Gfsk_Power: float: float Average power in the GFSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Dpsk_Power: float: float Average power in the DPSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Dpsk_Minus_Gfsk: float: float Difference between DPSK and GFSK power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Guard_Period: float: float Length of the guard band between the packet header and the synchronization sequence Range: 0 µs to 9.99 µs, Unit: s
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Gfsk_Power: float or bool: float Average power in the GFSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Dpsk_Power: float or bool: float Average power in the DPSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Dpsk_Minus_Gfsk: float or bool: float Difference between DPSK and GFSK power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Guard_Period: float or bool: float Length of the guard band between the packet header and the synchronization sequence Range: 0 µs to 9.99 µs, Unit: s
 			- Packet_Timing: enums.ResultStatus2: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
-			- Peak_Power: float: float Maximum power within the whole burst. The result is only available via remote command. Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Peak_Power: float or bool: float Maximum power within the whole burst. The result is only available via remote command. Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Gfsk_Power'),
-			ArgStruct.scalar_float('Dpsk_Power'),
-			ArgStruct.scalar_float('Dpsk_Minus_Gfsk'),
-			ArgStruct.scalar_float('Guard_Period'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Gfsk_Power'),
+			ArgStruct.scalar_float_ext('Dpsk_Power'),
+			ArgStruct.scalar_float_ext('Dpsk_Minus_Gfsk'),
+			ArgStruct.scalar_float_ext('Guard_Period'),
 			ArgStruct.scalar_enum('Packet_Timing', enums.ResultStatus2),
-			ArgStruct.scalar_float('Peak_Power')]
+			ArgStruct.scalar_float_ext('Peak_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Gfsk_Power: float = None
-			self.Dpsk_Power: float = None
-			self.Dpsk_Minus_Gfsk: float = None
-			self.Guard_Period: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Gfsk_Power: float or bool = None
+			self.Dpsk_Power: float or bool = None
+			self.Dpsk_Minus_Gfsk: float or bool = None
+			self.Guard_Period: float or bool = None
 			self.Packet_Timing: enums.ResultStatus2 = None
-			self.Peak_Power: float = None
+			self.Peak_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:EDRate:MAXimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.edrate.maximum.calculate() \n
 		Returns the power results for EDR packets. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:EDRate:MAXimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Gfsk_Power: float: float Average power in the GFSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Dpsk_Power: float: float Average power in the DPSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Dpsk_Minus_Gfsk: float: float Difference between DPSK and GFSK power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Guard_Period: float: float Length of the guard band between the packet header and the synchronization sequence Range: 0 µs to 9.99 µs, Unit: s
 			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
 			- Peak_Power: float: float Maximum power within the whole burst. The result is only available via remote command. Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
@@ -98,16 +98,16 @@
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:EDRate:MAXimum?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Gfsk_Power: float: float Average power in the GFSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Dpsk_Power: float: float Average power in the DPSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Dpsk_Minus_Gfsk: float: float Difference between DPSK and GFSK power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Guard_Period: float: float Length of the guard band between the packet header and the synchronization sequence Range: 0 µs to 9.99 µs, Unit: s
 			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
 			- Peak_Power: float: float Maximum power within the whole burst. The result is only available via remote command. Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Edrate_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Lrange/Current.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,143 +1,118 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
-from ..... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Gfsk_Power: float: float Average power in the GFSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Dpsk_Power: float: float Average power in the DPSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Dpsk_Minus_Gfsk: float: float Difference between DPSK and GFSK power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Guard_Period: float: float Length of the guard band between the packet header and the synchronization sequence Range: 0 µs to 9.99 µs, Unit: s
-			- Packet_Timing: enums.ResultStatus2: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
-			- Peak_Power: float: float Maximum power within the whole burst. The result is only available via remote command. Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Power: float or bool: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Leakage_Power: float or bool: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Gfsk_Power'),
-			ArgStruct.scalar_float('Dpsk_Power'),
-			ArgStruct.scalar_float('Dpsk_Minus_Gfsk'),
-			ArgStruct.scalar_float('Guard_Period'),
-			ArgStruct.scalar_enum('Packet_Timing', enums.ResultStatus2),
-			ArgStruct.scalar_float('Peak_Power')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Gfsk_Power: float = None
-			self.Dpsk_Power: float = None
-			self.Dpsk_Minus_Gfsk: float = None
-			self.Guard_Period: float = None
-			self.Packet_Timing: enums.ResultStatus2 = None
-			self.Peak_Power: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:EDRate:MINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.edrate.minimum.calculate() \n
-		Returns the power results for EDR packets. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:CURRent \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.current.calculate() \n
+		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
+		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
+		listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:EDRate:MINimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:CURRent?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Gfsk_Power: float: float Average power in the GFSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Dpsk_Power: float: float Average power in the DPSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Dpsk_Minus_Gfsk: float: float Difference between DPSK and GFSK power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Guard_Period: float: float Length of the guard band between the packet header and the synchronization sequence Range: 0 µs to 9.99 µs, Unit: s
-			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
-			- Peak_Power: float: float Maximum power within the whole burst. The result is only available via remote command. Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Gfsk_Power'),
-			ArgStruct.scalar_float('Dpsk_Power'),
-			ArgStruct.scalar_float('Dpsk_Minus_Gfsk'),
-			ArgStruct.scalar_float('Guard_Period'),
-			ArgStruct.scalar_float('Packet_Timing'),
-			ArgStruct.scalar_float('Peak_Power')]
+			ArgStruct.scalar_float('Peak_Power'),
+			ArgStruct.scalar_float('Leakage_Power'),
+			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
-			self.Gfsk_Power: float = None
-			self.Dpsk_Power: float = None
-			self.Dpsk_Minus_Gfsk: float = None
-			self.Guard_Period: float = None
-			self.Packet_Timing: float = None
 			self.Peak_Power: float = None
+			self.Leakage_Power: float = None
+			self.Peak_Min_Avg_Pow: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:EDRate:MINimum \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.edrate.minimum.read() \n
-		Returns the power results for EDR packets. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:CURRent \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.current.read() \n
+		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
+		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
+		listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:EDRate:MINimum?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:CURRent?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Gfsk_Power: float: float Average power in the GFSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Dpsk_Power: float: float Average power in the DPSK portion of the burst Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Dpsk_Minus_Gfsk: float: float Difference between DPSK and GFSK power Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Guard_Period: float: float Length of the guard band between the packet header and the synchronization sequence Range: 0 µs to 9.99 µs, Unit: s
-			- Packet_Timing: float: float Time between the expected and actual start of the first symbol of the Bluetooth burst Range: -99.99 µs to 99.99 µs, Unit: s
-			- Peak_Power: float: float Maximum power within the whole burst. The result is only available via remote command. Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Gfsk_Power'),
-			ArgStruct.scalar_float('Dpsk_Power'),
-			ArgStruct.scalar_float('Dpsk_Minus_Gfsk'),
-			ArgStruct.scalar_float('Guard_Period'),
-			ArgStruct.scalar_float('Packet_Timing'),
-			ArgStruct.scalar_float('Peak_Power')]
+			ArgStruct.scalar_float('Peak_Power'),
+			ArgStruct.scalar_float('Leakage_Power'),
+			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
-			self.Gfsk_Power: float = None
-			self.Dpsk_Power: float = None
-			self.Dpsk_Minus_Gfsk: float = None
-			self.Guard_Period: float = None
-			self.Packet_Timing: float = None
 			self.Peak_Power: float = None
+			self.Leakage_Power: float = None
+			self.Peak_Min_Avg_Pow: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:EDRate:MINimum \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.edrate.minimum.fetch() \n
-		Returns the power results for EDR packets. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:CURRent \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.current.fetch() \n
+		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
+		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
+		listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:EDRate:MINimum?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:CURRent?', self.__class__.FetchStruct())
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/EvMagnitude/Offset/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 36 total commands, 3 Sub-groups, 0 group commands"""
+class OffsetCls:
+	"""Offset commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("offset", core, parent)
 
 	@property
-	def le1M(self):
-		"""le1M commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_le1M'):
-			from .LowEnergy_.Le1M import Le1M
-			self._le1M = Le1M(self._core, self._base)
-		return self._le1M
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
 
 	@property
-	def le2M(self):
-		"""le2M commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_le2M'):
-			from .LowEnergy_.Le2M import Le2M
-			self._le2M = Le2M(self._core, self._base)
-		return self._le2M
+	def average(self):
+		"""average commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
 
 	@property
-	def lrange(self):
-		"""lrange commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_lrange'):
-			from .LowEnergy_.Lrange import Lrange
-			self._lrange = Lrange(self._core, self._base)
-		return self._lrange
+	def current(self):
+		"""current commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
 
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'OffsetCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = OffsetCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le1M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le1M/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le1M:
-	"""Le1M commands group definition. 12 total commands, 4 Sub-groups, 0 group commands"""
+class Le1MCls:
+	"""Le1M commands group definition. 12 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le1M", core, parent)
+		self._cmd_group = CommandsGroup("le1M", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Le1M_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Le1M_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Le1M_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Le1M_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'Le1M':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'Le1MCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Le1M(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = Le1MCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le1M_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Lrange/Current.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,64 +1,65 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float or bool: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float or bool: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy[:LE1M]:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.le1M.average.calculate() \n
-		Returns the power results for LE 1M PHY (uncoded) . The values described below are returned by FETCh and READ commands.
-		CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:CURRent \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.current.calculate() \n
+		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
+		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE1M:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:CURRent?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Peak_Power'),
 			ArgStruct.scalar_float('Leakage_Power'),
 			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
@@ -69,30 +70,31 @@
 			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy[:LE1M]:AVERage \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.lowEnergy.le1M.average.read() \n
-		Returns the power results for LE 1M PHY (uncoded) . The values described below are returned by FETCh and READ commands.
-		CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:CURRent \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.current.read() \n
+		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
+		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE1M:AVERage?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:CURRent?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Peak_Power'),
 			ArgStruct.scalar_float('Leakage_Power'),
 			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
@@ -103,13 +105,14 @@
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy[:LE1M]:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.lowEnergy.le1M.average.fetch() \n
-		Returns the power results for LE 1M PHY (uncoded) . The values described below are returned by FETCh and READ commands.
-		CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:CURRent \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.current.fetch() \n
+		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
+		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE1M:AVERage?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:CURRent?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le1M_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Lrange/Average.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,64 +1,65 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Power: float or bool: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Leakage_Power: float or bool: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy[:LE1M]:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.le1M.current.calculate() \n
-		Returns the power results for LE 1M PHY (uncoded) . The values described below are returned by FETCh and READ commands.
-		CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:AVERage \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.average.calculate() \n
+		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
+		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
+		listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE1M:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:AVERage?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Peak_Power'),
 			ArgStruct.scalar_float('Leakage_Power'),
 			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
@@ -69,30 +70,31 @@
 			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy[:LE1M]:CURRent \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.lowEnergy.le1M.current.read() \n
-		Returns the power results for LE 1M PHY (uncoded) . The values described below are returned by FETCh and READ commands.
-		CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:AVERage \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.average.read() \n
+		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
+		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
+		listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE1M:CURRent?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:AVERage?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Peak_Power'),
 			ArgStruct.scalar_float('Leakage_Power'),
 			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
@@ -103,13 +105,14 @@
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy[:LE1M]:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.lowEnergy.le1M.current.fetch() \n
-		Returns the power results for LE 1M PHY (uncoded) . The values described below are returned by FETCh and READ commands.
-		CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:AVERage \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.average.fetch() \n
+		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
+		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
+		listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE1M:CURRent?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le1M_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Lrange/Minimum.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,64 +1,65 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Power: float or bool: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Leakage_Power: float or bool: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy[:LE1M]:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.le1M.maximum.calculate() \n
-		Returns the power results for LE 1M PHY (uncoded) . The values described below are returned by FETCh and READ commands.
-		CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MINimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.minimum.calculate() \n
+		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
+		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
+		listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE1M:MAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MINimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Peak_Power'),
 			ArgStruct.scalar_float('Leakage_Power'),
 			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
@@ -69,30 +70,31 @@
 			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy[:LE1M]:MAXimum \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.lowEnergy.le1M.maximum.read() \n
-		Returns the power results for LE 1M PHY (uncoded) . The values described below are returned by FETCh and READ commands.
-		CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MINimum \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.minimum.read() \n
+		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
+		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
+		listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE1M:MAXimum?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MINimum?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Peak_Power'),
 			ArgStruct.scalar_float('Leakage_Power'),
 			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
@@ -103,13 +105,14 @@
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy[:LE1M]:MAXimum \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.lowEnergy.le1M.maximum.fetch() \n
-		Returns the power results for LE 1M PHY (uncoded) . The values described below are returned by FETCh and READ commands.
-		CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MINimum \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.minimum.fetch() \n
+		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
+		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
+		listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE1M:MAXimum?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MINimum?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le1M_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le1M/Minimum.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,60 +1,60 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Power: float or bool: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Leakage_Power: float or bool: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy[:LE1M]:MINimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.le1M.minimum.calculate() \n
 		Returns the power results for LE 1M PHY (uncoded) . The values described below are returned by FETCh and READ commands.
 		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE1M:MINimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
@@ -79,16 +79,16 @@
 		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE1M:MINimum?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le2M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/PowerVsTime/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,51 +1,51 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le2M:
-	"""Le2M commands group definition. 12 total commands, 4 Sub-groups, 0 group commands"""
+class PowerVsTimeCls:
+	"""PowerVsTime commands group definition. 8 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le2M", core, parent)
+		self._cmd_group = CommandsGroup("powerVsTime", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_current'):
-			from .Le2M_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
-
-	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_average'):
-			from .Le2M_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
 
 	@property
 	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		"""minimum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Le2M_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Le2M_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
+	def average(self):
+		"""average commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
+
+	@property
+	def current(self):
+		"""current commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
 
-	def clone(self) -> 'Le2M':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PowerVsTimeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Le2M(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PowerVsTimeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le2M_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le2M/Average.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,65 +1,65 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float or bool: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float or bool: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.le2M.average.calculate() \n
-		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
-		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
-		listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:AVERage \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.average.calculate() \n
+		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
+		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:AVERage?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Peak_Power'),
 			ArgStruct.scalar_float('Leakage_Power'),
 			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
@@ -70,31 +70,31 @@
 			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:AVERage \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.lowEnergy.le2M.average.read() \n
-		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
-		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
-		listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:AVERage \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.average.read() \n
+		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
+		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:AVERage?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:AVERage?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Peak_Power'),
 			ArgStruct.scalar_float('Leakage_Power'),
 			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
@@ -105,14 +105,14 @@
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.lowEnergy.le2M.average.fetch() \n
-		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
-		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
-		listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:AVERage \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.average.fetch() \n
+		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
+		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:AVERage?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le2M_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le2M/Minimum.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,61 +1,61 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Power: float or bool: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Leakage_Power: float or bool: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.le2M.current.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:MINimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.le2M.minimum.calculate() \n
 		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
 		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
 		listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:MINimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
@@ -70,27 +70,27 @@
 			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:CURRent \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.lowEnergy.le2M.current.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:MINimum \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.lowEnergy.le2M.minimum.read() \n
 		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
 		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
 		listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:CURRent?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:MINimum?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -105,14 +105,14 @@
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.lowEnergy.le2M.current.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:MINimum \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.lowEnergy.le2M.minimum.fetch() \n
 		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
 		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
 		listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:CURRent?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:MINimum?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le2M_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le2M/Maximum.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,61 +1,61 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Power: float or bool: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Leakage_Power: float or bool: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:MAXimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.le2M.maximum.calculate() \n
 		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
 		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
 		listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:MAXimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
@@ -81,16 +81,16 @@
 		listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:MAXimum?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Le2M_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Lrange/Maximum.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,61 +1,61 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Power: float or bool: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Leakage_Power: float or bool: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:MINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.le2M.minimum.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.maximum.calculate() \n
 		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
 		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
 		listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:MINimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MAXimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
@@ -70,27 +70,27 @@
 			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:MINimum \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.lowEnergy.le2M.minimum.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MAXimum \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.maximum.read() \n
 		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
 		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
 		listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:MINimum?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MAXimum?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -105,14 +105,14 @@
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:MINimum \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.lowEnergy.le2M.minimum.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MAXimum \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.maximum.fetch() \n
 		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
 		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
 		listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:MINimum?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MAXimum?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Lrange.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P2Q/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Lrange:
-	"""Lrange commands group definition. 12 total commands, 4 Sub-groups, 0 group commands"""
+class P2QCls:
+	"""P2Q commands group definition. 12 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lrange", core, parent)
+		self._cmd_group = CommandsGroup("p2Q", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Lrange_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Lrange_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Lrange_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Lrange_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'Lrange':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'P2QCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Lrange(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = P2QCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Lrange_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le1M/Average.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,65 +1,65 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float or bool: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float or bool: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.average.calculate() \n
-		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
-		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
-		listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy[:LE1M]:AVERage \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le1M.average.calculate() \n
+		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
+		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE1M:AVERage?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Peak_Power'),
 			ArgStruct.scalar_float('Leakage_Power'),
 			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
@@ -70,31 +70,31 @@
 			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:AVERage \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.average.read() \n
-		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
-		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
-		listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy[:LE1M]:AVERage \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le1M.average.read() \n
+		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
+		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:AVERage?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE1M:AVERage?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Peak_Power'),
 			ArgStruct.scalar_float('Leakage_Power'),
 			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
@@ -105,14 +105,14 @@
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.average.fetch() \n
-		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
-		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
-		listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy[:LE1M]:AVERage \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le1M.average.fetch() \n
+		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
+		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:AVERage?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE1M:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Lrange_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le2M/Minimum.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,65 +1,65 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float or bool: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float or bool: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.current.calculate() \n
-		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
-		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
-		listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MINimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.minimum.calculate() \n
+		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
+		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MINimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Peak_Power'),
 			ArgStruct.scalar_float('Leakage_Power'),
 			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
@@ -70,31 +70,31 @@
 			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:CURRent \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.current.read() \n
-		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
-		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
-		listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MINimum \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.minimum.read() \n
+		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
+		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:CURRent?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MINimum?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Peak_Power'),
 			ArgStruct.scalar_float('Leakage_Power'),
 			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
@@ -105,14 +105,14 @@
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.current.fetch() \n
-		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
-		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
-		listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MINimum \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.minimum.fetch() \n
+		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
+		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:CURRent?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MINimum?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Lrange_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le2M/Current.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,61 +1,61 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Power: float or bool: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Leakage_Power: float or bool: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.maximum.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:CURRent \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.le2M.current.calculate() \n
 		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
 		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
 		listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:CURRent?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
@@ -70,27 +70,27 @@
 			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MAXimum \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.maximum.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:CURRent \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.lowEnergy.le2M.current.read() \n
 		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
 		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
 		listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MAXimum?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:CURRent?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -105,14 +105,14 @@
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MAXimum \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.maximum.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:CURRent \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.lowEnergy.le2M.current.fetch() \n
 		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
 		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
 		listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MAXimum?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:CURRent?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/LowEnergy_/Lrange_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le1M/Maximum.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,65 +1,65 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float or bool: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float or bool: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.minimum.calculate() \n
-		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
-		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
-		listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy[:LE1M]:MAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le1M.maximum.calculate() \n
+		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
+		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MINimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE1M:MAXimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Peak_Power'),
 			ArgStruct.scalar_float('Leakage_Power'),
 			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
@@ -70,31 +70,31 @@
 			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MINimum \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.minimum.read() \n
-		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
-		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
-		listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy[:LE1M]:MAXimum \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le1M.maximum.read() \n
+		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
+		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MINimum?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE1M:MAXimum?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LE2M:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:LENergy:LRANge:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Peak_Power'),
 			ArgStruct.scalar_float('Leakage_Power'),
 			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
@@ -105,14 +105,14 @@
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MINimum \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.lowEnergy.lrange.minimum.fetch() \n
-		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
-		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
-		listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy[:LE1M]:MAXimum \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le1M.maximum.fetch() \n
+		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
+		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LRANge:MINimum?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE1M:MAXimum?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Nmode:
-	"""Nmode commands group definition. 48 total commands, 2 Sub-groups, 0 group commands"""
+class CteCls:
+	"""Cte commands group definition. 14 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nmode", core, parent)
+		self._cmd_group = CommandsGroup("cte", core, parent)
 
 	@property
-	def classic(self):
-		"""classic commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_classic'):
-			from .Nmode_.Classic import Classic
-			self._classic = Classic(self._core, self._base)
-		return self._classic
+	def qhsl(self):
+		"""qhsl commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_qhsl'):
+			from .Qhsl import QhslCls
+			self._qhsl = QhslCls(self._core, self._cmd_group)
+		return self._qhsl
 
 	@property
 	def lowEnergy(self):
-		"""lowEnergy commands group. 3 Sub-classes, 0 commands."""
+		"""lowEnergy commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_lowEnergy'):
-			from .Nmode_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
 		return self._lowEnergy
 
-	def clone(self) -> 'Nmode':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CteCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Nmode(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CteCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/Classic.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Modulation/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Classic:
-	"""Classic commands group definition. 12 total commands, 4 Sub-groups, 0 group commands"""
+class ModulationCls:
+	"""Modulation commands group definition. 12 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("classic", core, parent)
+		self._cmd_group = CommandsGroup("modulation", core, parent)
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_average'):
-			from .Classic_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def standardDev(self):
+		"""standardDev commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_standardDev'):
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
+		return self._standardDev
+
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Classic_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Classic_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
-
-	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Classic_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
+	def average(self):
+		"""average commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
 
-	def clone(self) -> 'Classic':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ModulationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Classic(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ModulationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/Classic_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/Classic/Average.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,51 +1,51 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:BRATe:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:EDRate:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.Brate.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.Edrate#PowerVsTime CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
+			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:AVERage \n
 		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.classic.average.calculate() \n
 		Returns the current, average, min, and max power results for BR/EDR, normal mode. The values described below are returned
 		by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:AVERage?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:BRATe:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:EDRate:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.Brate.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.Edrate#PowerVsTime CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power')]
 
 		def __init__(self):
@@ -61,16 +61,16 @@
 		by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:AVERage?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:BRATe:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:EDRate:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.Brate.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.Edrate#PowerVsTime CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power')]
 
 		def __init__(self):
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/Classic_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/Classic/Current.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,51 +1,51 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:BRATe:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:EDRate:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.Brate.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.Edrate#PowerVsTime CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
+			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:CURRent \n
 		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.classic.current.calculate() \n
 		Returns the current, average, min, and max power results for BR/EDR, normal mode. The values described below are returned
 		by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:CURRent?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:BRATe:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:EDRate:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.Brate.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.Edrate#PowerVsTime CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power')]
 
 		def __init__(self):
@@ -61,16 +61,16 @@
 		by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:CURRent?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:BRATe:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:EDRate:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.Brate.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.Edrate#PowerVsTime CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power')]
 
 		def __init__(self):
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/Classic_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Brate/Ptx.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,88 +1,95 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from typing import List
+
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Types import DataType
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class PtxCls:
+	"""Ptx commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("ptx", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:BRATe:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:EDRate:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.classic.maximum.calculate() \n
-		Returns the current, average, min, and max power results for BR/EDR, normal mode. The values described below are returned
-		by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:MAXimum?', self.__class__.CalculateStruct())
-
-	# noinspection PyTypeChecker
-	class ReadStruct(StructBase):
-		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:BRATe:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:EDRate:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Sacp CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- No_Of_Exceptions: float or bool: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99
+			- Acp: List[float or bool]: float 79 ACP results Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power')]
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('No_Of_Exceptions'),
+			ArgStruct('Acp', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float or bool = None
-			self.Nominal_Power: float = None
+			self.Nominal_Power: float or bool = None
+			self.No_Of_Exceptions: float or bool = None
+			self.Acp: List[float or bool] = None
 
-	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:MAXimum \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.classic.maximum.read() \n
-		Returns the current, average, min, and max power results for BR/EDR, normal mode. The values described below are returned
-		by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:MAXimum?', self.__class__.ReadStruct())
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:BRATe[:PTX] \n
+		Snippet: value: CalculateStruct = driver.multiEval.sacp.brate.ptx.calculate() \n
+		Returns the 'Spectrum ACP' results for BR packets. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below.
+			INTRO_CMD_HELP: The number of valid ACP results depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.Brate.Measurement.mode CH21 | CH79) : \n
+			- If 'ACP +/- 10 Channels' is selected, the first 21 ACP values contain the results for the relative channels –10, ..., 0, ..., +10; the remaining 58 values are not displayed.
+			- If 'ACP 79 Channels' is selected, valid ACP values are available for all channels in the Bluetooth regulatory range. \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:BRATe:PTX?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
-	class FetchStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:BRATe:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:EDRate:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Sacp CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- No_Of_Exceptions: int: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99
+			- Acp: List[float]: float 79 ACP results Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power')]
+			ArgStruct.scalar_float('Nominal_Power'),
+			ArgStruct.scalar_int('No_Of_Exceptions'),
+			ArgStruct('Acp', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
+			self.No_Of_Exceptions: int = None
+			self.Acp: List[float] = None
 
-	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:MAXimum \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.classic.maximum.fetch() \n
-		Returns the current, average, min, and max power results for BR/EDR, normal mode. The values described below are returned
-		by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:MAXimum?', self.__class__.FetchStruct())
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:BRATe[:PTX] \n
+		Snippet: value: ResultData = driver.multiEval.sacp.brate.ptx.fetch() \n
+		Returns the 'Spectrum ACP' results for BR packets. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below.
+			INTRO_CMD_HELP: The number of valid ACP results depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.Brate.Measurement.mode CH21 | CH79) : \n
+			- If 'ACP +/- 10 Channels' is selected, the first 21 ACP values contain the results for the relative channels –10, ..., 0, ..., +10; the remaining 58 values are not displayed.
+			- If 'ACP 79 Channels' is selected, valid ACP values are available for all channels in the Bluetooth regulatory range. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:BRATe:PTX?', self.__class__.ResultData())
+
+	def read(self) -> ResultData:
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:BRATe[:PTX] \n
+		Snippet: value: ResultData = driver.multiEval.sacp.brate.ptx.read() \n
+		Returns the 'Spectrum ACP' results for BR packets. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below.
+			INTRO_CMD_HELP: The number of valid ACP results depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.Brate.Measurement.mode CH21 | CH79) : \n
+			- If 'ACP +/- 10 Channels' is selected, the first 21 ACP values contain the results for the relative channels –10, ..., 0, ..., +10; the remaining 58 values are not displayed.
+			- If 'ACP 79 Channels' is selected, valid ACP values are available for all channels in the Bluetooth regulatory range. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:BRATe:PTX?', self.__class__.ResultData())
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/Classic_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/Classic/Minimum.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,51 +1,51 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:BRATe:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:EDRate:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.Brate.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.Edrate#PowerVsTime CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
+			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:MINimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.classic.minimum.calculate() \n
 		Returns the current, average, min, and max power results for BR/EDR, normal mode. The values described below are returned
 		by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:MINimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:BRATe:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:EDRate:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.Brate.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.Edrate#PowerVsTime CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power')]
 
 		def __init__(self):
@@ -61,16 +61,16 @@
 		by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:MINimum?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:BRATe:PVTime CMDLINK] and [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:EDRate:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.Brate.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.Edrate#PowerVsTime CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power')]
 
 		def __init__(self):
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P4Q/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,43 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 36 total commands, 3 Sub-groups, 0 group commands"""
+class P4QCls:
+	"""P4Q commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("p4Q", core, parent)
 
 	@property
-	def le1M(self):
-		"""le1M commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_le1M'):
-			from .LowEnergy_.Le1M import Le1M
-			self._le1M = Le1M(self._core, self._base)
-		return self._le1M
+	def units(self):
+		"""units commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_units'):
+			from .Units import UnitsCls
+			self._units = UnitsCls(self._core, self._cmd_group)
+		return self._units
 
 	@property
-	def le2M(self):
-		"""le2M commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_le2M'):
-			from .LowEnergy_.Le2M import Le2M
-			self._le2M = Le2M(self._core, self._base)
-		return self._le2M
+	def typePy(self):
+		"""typePy commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_typePy'):
+			from .TypePy import TypePyCls
+			self._typePy = TypePyCls(self._core, self._cmd_group)
+		return self._typePy
 
-	@property
-	def lrange(self):
-		"""lrange commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_lrange'):
-			from .LowEnergy_.Lrange import Lrange
-			self._lrange = Lrange(self._core, self._base)
-		return self._lrange
-
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'P4QCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = P4QCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le1M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Qhsl/P5Q/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,51 +1,51 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le1M:
-	"""Le1M commands group definition. 12 total commands, 4 Sub-groups, 0 group commands"""
+class P5QCls:
+	"""P5Q commands group definition. 12 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le1M", core, parent)
+		self._cmd_group = CommandsGroup("p5Q", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Le1M_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Le1M_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Le1M_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Le1M_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'Le1M':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'P5QCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Le1M(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = P5QCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le1M_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Lrange/Minimum.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,61 +1,61 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float or bool: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float or bool: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy[:LE1M]:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le1M.average.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:MINimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.minimum.calculate() \n
 		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
 		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE1M:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:MINimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
@@ -70,27 +70,27 @@
 			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy[:LE1M]:AVERage \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le1M.average.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:MINimum \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.minimum.read() \n
 		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
 		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE1M:AVERage?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:MINimum?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -105,14 +105,14 @@
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy[:LE1M]:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le1M.average.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:MINimum \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.minimum.fetch() \n
 		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
 		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE1M:AVERage?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:MINimum?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le1M_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le1M/Current.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,61 +1,61 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float or bool: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float or bool: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy[:LE1M]:CURRent \n
 		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le1M.current.calculate() \n
 		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
 		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE1M:CURRent?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
@@ -81,16 +81,16 @@
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE1M:CURRent?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le1M_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le2M/Maximum.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,61 +1,61 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float or bool: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float or bool: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy[:LE1M]:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le1M.maximum.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.maximum.calculate() \n
 		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
 		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE1M:MAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MAXimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
@@ -70,27 +70,27 @@
 			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy[:LE1M]:MAXimum \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le1M.maximum.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MAXimum \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.maximum.read() \n
 		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
 		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE1M:MAXimum?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MAXimum?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -105,14 +105,14 @@
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy[:LE1M]:MAXimum \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le1M.maximum.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MAXimum \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.maximum.fetch() \n
 		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
 		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE1M:MAXimum?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MAXimum?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le1M_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le2M/Current.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,61 +1,61 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float or bool: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float or bool: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy[:LE1M]:MINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le1M.minimum.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:CURRent \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.current.calculate() \n
 		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
 		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE1M:MINimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:CURRent?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
@@ -70,27 +70,27 @@
 			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy[:LE1M]:MINimum \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le1M.minimum.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:CURRent \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.current.read() \n
 		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
 		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE1M:MINimum?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:CURRent?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -105,14 +105,14 @@
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy[:LE1M]:MINimum \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le1M.minimum.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:CURRent \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.current.fetch() \n
 		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
 		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE1M:MINimum?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:CURRent?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le2M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/DevMagnitude/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,51 +1,43 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le2M:
-	"""Le2M commands group definition. 12 total commands, 4 Sub-groups, 0 group commands"""
+class DevMagnitudeCls:
+	"""DevMagnitude commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le2M", core, parent)
+		self._cmd_group = CommandsGroup("devMagnitude", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 3 commands."""
+		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Le2M_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 3 commands."""
+		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Le2M_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Le2M_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
-
-	@property
 	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Le2M_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'Le2M':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'DevMagnitudeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Le2M(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = DevMagnitudeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le2M_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Lrange/Average.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,61 +1,61 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float or bool: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float or bool: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.average.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:AVERage \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.average.calculate() \n
 		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
 		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:AVERage?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
@@ -70,27 +70,27 @@
 			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:AVERage \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.average.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:AVERage \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.average.read() \n
 		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
 		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:AVERage?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:AVERage?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -105,14 +105,14 @@
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.average.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:AVERage \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.average.fetch() \n
 		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
 		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:AVERage?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le2M_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Lrange/Maximum.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,61 +1,61 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float or bool: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float or bool: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.current.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:MAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.maximum.calculate() \n
 		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
 		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:MAXimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
@@ -70,27 +70,27 @@
 			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:CURRent \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.current.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:MAXimum \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.maximum.read() \n
 		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
 		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:CURRent?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:MAXimum?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -105,14 +105,14 @@
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.current.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:MAXimum \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.maximum.fetch() \n
 		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
 		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:CURRent?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:MAXimum?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le2M_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/LowEnergy/Le1M/Minimum.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,61 +1,61 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Power: float or bool: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Leakage_Power: float or bool: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.maximum.calculate() \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy[:LE1M]:MINimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le1M.minimum.calculate() \n
 		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
 		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE1M:MINimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
@@ -70,27 +70,27 @@
 			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MAXimum \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.maximum.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy[:LE1M]:MINimum \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le1M.minimum.read() \n
 		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
 		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MAXimum?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE1M:MINimum?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -105,14 +105,14 @@
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MAXimum \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.maximum.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy[:LE1M]:MINimum \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le1M.minimum.fetch() \n
 		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
 		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MAXimum?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE1M:MINimum?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Le2M_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/LowEnergy/Le2M/Current.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,118 +1,153 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
+from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float: float Range: -4 MHz to 4 MHz
+			- Freq_Accuracy: float: float Unit: Hz
+			- Freq_Drift: float: float Unit: Hz
+			- Max_Drift: float: float Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float: No parameter help available
+			- Freq_Dev_Min_F_1: float: No parameter help available
+			- Freq_Dev_Max_F_1: float: No parameter help available
+			- Freq_Dev_Avg_F_2: float: No parameter help available
+			- Freq_Dev_Min_F_2: float: No parameter help available
+			- Freq_Dev_Max_F_2: float: No parameter help available
+			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm
+			- Mod_Ratio: float: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
+			- Freq_Offset: float: float Range: -0.99999 MHz to 0.99999 MHz
+			- Init_Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
+			ArgStruct.scalar_float('Delta_F_299_P_9'),
+			ArgStruct.scalar_float('Freq_Accuracy'),
+			ArgStruct.scalar_float('Freq_Drift'),
+			ArgStruct.scalar_float('Max_Drift'),
+			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float('Freq_Dev_Max_F_2'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float('Mod_Ratio'),
+			ArgStruct.scalar_float('Freq_Offset'),
+			ArgStruct.scalar_float('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
+			self.Delta_F_299_P_9: float = None
+			self.Freq_Accuracy: float = None
+			self.Freq_Drift: float = None
+			self.Max_Drift: float = None
+			self.Freq_Dev_Avg_F_1: float = None
+			self.Freq_Dev_Min_F_1: float = None
+			self.Freq_Dev_Max_F_1: float = None
+			self.Freq_Dev_Avg_F_2: float = None
+			self.Freq_Dev_Min_F_2: float = None
+			self.Freq_Dev_Max_F_2: float = None
 			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
-
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.minimum.calculate() \n
-		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
-		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MINimum?', self.__class__.CalculateStruct())
+			self.Mod_Ratio: float = None
+			self.Freq_Offset: float = None
+			self.Init_Freq_Drift: float = None
+
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.current.fetch() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
-	class ReadStruct(StructBase):
+	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float or bool: float Range: -4 MHz to 4 MHz
+			- Freq_Accuracy: float or bool: float Unit: Hz
+			- Freq_Drift: float or bool: float Unit: Hz
+			- Max_Drift: float or bool: float Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available
+			- Nominal_Power: float or bool: float Range: -99.99 dBm to 99.99 dBm
+			- Mod_Ratio: enums.ResultStatus2: float Modulation ratio Δf2 avg / Δf1 avg Range: 0 to 1
+			- Freq_Offset: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Init_Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Delta_F_299_P_9'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_enum('Mod_Ratio', enums.ResultStatus2),
+			ArgStruct.scalar_float_ext('Freq_Offset'),
+			ArgStruct.scalar_float_ext('Init_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float or bool = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
-
-	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MINimum \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.minimum.read() \n
-		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
-		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MINimum?', self.__class__.ReadStruct())
+			self.Delta_F_299_P_9: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Mod_Ratio: enums.ResultStatus2 = None
+			self.Freq_Offset: float or bool = None
+			self.Init_Freq_Drift: float or bool = None
 
-	# noinspection PyTypeChecker
-	class FetchStruct(StructBase):
-		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:CURRent \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.lowEnergy.le2M.current.calculate() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 2M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:CURRent?', self.__class__.CalculateStruct())
 
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
-
-	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MINimum \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.le2M.minimum.fetch() \n
-		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
-		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LE2M:MINimum?', self.__class__.FetchStruct())
+	def read(self) -> ResultData:
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.lowEnergy.le2M.current.read() \n
+		Returns the current, average, xmin, xmax, and maximum modulation results for LE 1M PHY in normal mode, see 'Normal mode
+		classic: statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:LENergy:LE2M:CURRent?', self.__class__.ResultData())
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Lrange.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/PowerVsTime/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,51 +1,51 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Lrange:
-	"""Lrange commands group definition. 12 total commands, 4 Sub-groups, 0 group commands"""
+class PowerVsTimeCls:
+	"""PowerVsTime commands group definition. 4 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lrange", core, parent)
+		self._cmd_group = CommandsGroup("powerVsTime", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 3 commands."""
+		"""current commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_current'):
-			from .Lrange_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 3 commands."""
+		"""average commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_average'):
-			from .Lrange_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		"""minimum commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Lrange_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		"""maximum commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Lrange_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'Lrange':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PowerVsTimeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Lrange(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PowerVsTimeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Lrange_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Current/Extended.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,118 +1,111 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class ExtendedCls:
+	"""Extended commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
-
-	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
-		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
-
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.average.calculate() \n
-		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
-		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:AVERage?', self.__class__.CalculateStruct())
-
-	# noinspection PyTypeChecker
-	class ReadStruct(StructBase):
-		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float_ext('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Out_Of_Tol: float or bool = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
-
-	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:AVERage \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.average.read() \n
-		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
-		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:AVERage?', self.__class__.ReadStruct())
+		self._cmd_group = CommandsGroup("extended", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment. The meaning of the returned values is the same as for the common reliability indicator, see previous parameter.
+			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 % , Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Freq_Acc_Or_Init_Freq_Error: float: float Frequency accuracy (BR, LE) or initial center frequency error ωi (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float: float Frequency drift (BR, LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift_Rate: float: float Maximal drift rate (BR, LE) Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Delta_F_1_Avg: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
+			- Delta_F_1_Min: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
+			- Delta_F_1_Max: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
+			- Delta_F_2_Avg: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
+			- Delta_F_2_Min: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
+			- Delta_F_2_Max: float: float Frequency deviation results (BR, LE) Range: 0 Hz to 250 kHz , Unit: Hz
+			- Delta_F_299_P: float: float Frequency deviation value Δf2 above which 99.9% of all measured Δf2 values occur (BR, LE) . Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Omegai_Omega_0: float: No parameter help available
+			- Omega_0_Max: float: float Maximum compensated frequency error (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Rms_Devm: float: float RMS DEVM (EDR) Range: 0.0 to 1.0
+			- Peak_Devm: float: float Peak DEVM (EDR) Range: 0.0 to 1.0
+			- P_99_Devm: float: float DEVM value below which 99% of all measured DEVM values occur (EDR) . Range: 0.0 to 1.0
+			- Freq_Offset: float: float Frequency offset (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Init_Freq_Drift: float: float Initial frequency drift (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Delta_F_199_P: float: float Standard deviation of frequency deviation value Δf1 above which 99.9% of all measured Δf1 values occur (LE coded PHY) . Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Cte_Freq_Drift: float: float Frequency drift of CTE portion Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Cte_Mx_Drift_Rate: float: No parameter help available
+			- Cte_Freq_Offset: float: float Frequency offset of CTE portion Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Cte_Int_Frq_Drift: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float('Freq_Acc_Or_Init_Freq_Error'),
+			ArgStruct.scalar_float('Freq_Drift'),
+			ArgStruct.scalar_float('Max_Drift_Rate'),
+			ArgStruct.scalar_float('Delta_F_1_Avg'),
+			ArgStruct.scalar_float('Delta_F_1_Min'),
+			ArgStruct.scalar_float('Delta_F_1_Max'),
+			ArgStruct.scalar_float('Delta_F_2_Avg'),
+			ArgStruct.scalar_float('Delta_F_2_Min'),
+			ArgStruct.scalar_float('Delta_F_2_Max'),
+			ArgStruct.scalar_float('Delta_F_299_P'),
+			ArgStruct.scalar_float('Omegai_Omega_0'),
+			ArgStruct.scalar_float('Omega_0_Max'),
+			ArgStruct.scalar_float('Rms_Devm'),
+			ArgStruct.scalar_float('Peak_Devm'),
+			ArgStruct.scalar_float('P_99_Devm'),
+			ArgStruct.scalar_float('Freq_Offset'),
+			ArgStruct.scalar_float('Init_Freq_Drift'),
+			ArgStruct.scalar_float('Delta_F_199_P'),
+			ArgStruct.scalar_float('Cte_Freq_Drift'),
+			ArgStruct.scalar_float('Cte_Mx_Drift_Rate'),
+			ArgStruct.scalar_float('Cte_Freq_Offset'),
+			ArgStruct.scalar_float('Cte_Int_Frq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
+			self.Seg_Reliability: int = None
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
-
-	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.average.fetch() \n
-		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
-		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+			self.Freq_Acc_Or_Init_Freq_Error: float = None
+			self.Freq_Drift: float = None
+			self.Max_Drift_Rate: float = None
+			self.Delta_F_1_Avg: float = None
+			self.Delta_F_1_Min: float = None
+			self.Delta_F_1_Max: float = None
+			self.Delta_F_2_Avg: float = None
+			self.Delta_F_2_Min: float = None
+			self.Delta_F_2_Max: float = None
+			self.Delta_F_299_P: float = None
+			self.Omegai_Omega_0: float = None
+			self.Omega_0_Max: float = None
+			self.Rms_Devm: float = None
+			self.Peak_Devm: float = None
+			self.P_99_Devm: float = None
+			self.Freq_Offset: float = None
+			self.Init_Freq_Drift: float = None
+			self.Delta_F_199_P: float = None
+			self.Cte_Freq_Drift: float = None
+			self.Cte_Mx_Drift_Rate: float = None
+			self.Cte_Freq_Offset: float = None
+			self.Cte_Int_Frq_Drift: float = None
+
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:CURRent:EXTended \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.current.extended.fetch(segment = repcap.Segment.Default) \n
+		Returns modulation single current value results for segment<no> in list mode including Bluetooth version 5.0 and higher.
+		The command returns all parameters listed below, independent of the selected list mode setup. However, only for some of
+		the parameters measured values are available. For the other parameters, only an indicator is returned (e.g. NAV) . \n
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:AVERage?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:CURRent:EXTended?', self.__class__.FetchStruct())
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Lrange_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le1M/Current.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,65 +1,64 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Power: float or bool: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Leakage_Power: float or bool: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.current.calculate() \n
-		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
-		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy[:LE1M]:CURRent \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.le1M.current.calculate() \n
+		Returns the power results for LE 1M PHY (uncoded) . The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE1M:CURRent?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Peak_Power'),
 			ArgStruct.scalar_float('Leakage_Power'),
 			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
@@ -70,31 +69,30 @@
 			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:CURRent \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.current.read() \n
-		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
-		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy[:LE1M]:CURRent \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.lowEnergy.le1M.current.read() \n
+		Returns the power results for LE 1M PHY (uncoded) . The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:CURRent?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE1M:CURRent?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Power: float: float Peak power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Leakage_Power: float: float Average power during the carrier-off state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Peak_Power'),
 			ArgStruct.scalar_float('Leakage_Power'),
 			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
@@ -105,14 +103,13 @@
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.current.fetch() \n
-		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
-		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy[:LE1M]:CURRent \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.lowEnergy.le1M.current.fetch() \n
+		Returns the power results for LE 1M PHY (uncoded) . The values described below are returned by FETCh and READ commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:CURRent?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE1M:CURRent?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/PowerVsTime_/Nmode_/LowEnergy_/Lrange_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/LowEnergy/Le2M/Average.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,65 +1,65 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Power: float or bool: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Leakage_Power: float or bool: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float or bool: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Leakage_Power'),
-			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Leakage_Power'),
+			ArgStruct.scalar_float_ext('Peak_Min_Avg_Pow')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Power: float = None
-			self.Leakage_Power: float = None
-			self.Peak_Min_Avg_Pow: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Leakage_Power: float or bool = None
+			self.Peak_Min_Avg_Pow: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.maximum.calculate() \n
-		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
-		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:AVERage \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.lowEnergy.le2M.average.calculate() \n
+		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
+		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
+		listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:MAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:AVERage?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float_ext('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Peak_Power'),
 			ArgStruct.scalar_float('Leakage_Power'),
 			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
@@ -70,31 +70,31 @@
 			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def read(self) -> ReadStruct:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:MAXimum \n
-		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.maximum.read() \n
-		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
-		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:AVERage \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.lowEnergy.le2M.average.read() \n
+		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
+		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
+		listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:MAXimum?', self.__class__.ReadStruct())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:AVERage?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK]. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Power: float: float Peak power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Leakage_Power: float: float Leakage power Range: -128.0 dBm to 30.0 dBm , Unit: dBm
-			- Peak_Min_Avg_Pow: float: float Difference between the peak power and the average power in the burst Range: -128.0 dBm to 30.0 dBm , Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le2M.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Lrange.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Power: float: float Peak power during the carrier-on state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Leakage_Power: float: float Average power during the carrier-off state Range: -128 dBm to 30 dBm , Unit: dBm
+			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_float('Peak_Power'),
 			ArgStruct.scalar_float('Leakage_Power'),
 			ArgStruct.scalar_float('Peak_Min_Avg_Pow')]
@@ -105,14 +105,14 @@
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:MAXimum \n
-		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.lowEnergy.lrange.maximum.fetch() \n
-		Returns the current, average, min, and max power results for LE normal mode. Commands for uncoded LE 1M PHY (..:LE1M..) ,
-		LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by FETCh
-		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:AVERage \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.lowEnergy.le2M.average.fetch() \n
+		Returns the power results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . The values described below are
+		returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result
+		listed below. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:LENergy:LRANge:MAXimum?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:LENergy:LE2M:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sacp:
-	"""Sacp commands group definition. 24 total commands, 3 Sub-groups, 0 group commands"""
+class SacpCls:
+	"""Sacp commands group definition. 4 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sacp", core, parent)
+		self._cmd_group = CommandsGroup("sacp", core, parent)
 
 	@property
-	def nmode(self):
-		"""nmode commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_nmode'):
-			from .Sacp_.Nmode import Nmode
-			self._nmode = Nmode(self._core, self._base)
-		return self._nmode
+	def qhsl(self):
+		"""qhsl commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_qhsl'):
+			from .Qhsl import QhslCls
+			self._qhsl = QhslCls(self._core, self._cmd_group)
+		return self._qhsl
 
 	@property
 	def lowEnergy(self):
-		"""lowEnergy commands group. 3 Sub-classes, 0 commands."""
+		"""lowEnergy commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_lowEnergy'):
-			from .Sacp_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
 		return self._lowEnergy
 
 	@property
 	def brate(self):
 		"""brate commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_brate'):
-			from .Sacp_.Brate import Brate
-			self._brate = Brate(self._core, self._base)
+			from .Brate import BrateCls
+			self._brate = BrateCls(self._core, self._cmd_group)
 		return self._brate
 
-	def clone(self) -> 'Sacp':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SacpCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Sacp(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SacpCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/Brate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/EvMagnitude/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,27 +1,35 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Brate:
-	"""Brate commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class EvMagnitudeCls:
+	"""EvMagnitude commands group definition. 12 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("brate", core, parent)
+		self._cmd_group = CommandsGroup("evMagnitude", core, parent)
 
 	@property
-	def ptx(self):
-		"""ptx commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_ptx'):
-			from .Brate_.Ptx import Ptx
-			self._ptx = Ptx(self._core, self._base)
-		return self._ptx
+	def offset(self):
+		"""offset commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_offset'):
+			from .Offset import OffsetCls
+			self._offset = OffsetCls(self._core, self._cmd_group)
+		return self._offset
 
-	def clone(self) -> 'Brate':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def absolute(self):
+		"""absolute commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_absolute'):
+			from .Absolute import AbsoluteCls
+			self._absolute = AbsoluteCls(self._core, self._cmd_group)
+		return self._absolute
+
+	def clone(self) -> 'EvMagnitudeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Brate(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EvMagnitudeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/Brate_/Ptx.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Modulation/Nmode/Classic/Current.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,95 +1,122 @@
-from typing import List
-
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.Types import DataType
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ptx:
-	"""Ptx commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ptx", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:SACP CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- No_Of_Exceptions: float: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99
-			- Acp: List[float]: float 79 ACP results Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (BR) ' and 'Modulation limits (EDR) '. Range: 0 % to 100 %
+			- Freq_Accuracy: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Freq_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz
+			- Max_Drift: float or bool: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float or bool: No parameter help available
+			- Freq_Dev_Min_F_1: float or bool: No parameter help available
+			- Freq_Dev_Max_F_1: float or bool: No parameter help available
+			- Freq_Dev_Avg_F_2: float or bool: No parameter help available
+			- Freq_Dev_Min_F_2: float or bool: No parameter help available
+			- Freq_Dev_Max_F_2: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('No_Of_Exceptions'),
-			ArgStruct('Acp', DataType.FloatList, None, False, True, 1)]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Freq_Accuracy'),
+			ArgStruct.scalar_float_ext('Freq_Drift'),
+			ArgStruct.scalar_float_ext('Max_Drift'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float_ext('Freq_Dev_Max_F_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.No_Of_Exceptions: float = None
-			self.Acp: List[float] = None
+			self.Out_Of_Tol: float or bool = None
+			self.Freq_Accuracy: float or bool = None
+			self.Freq_Drift: float or bool = None
+			self.Max_Drift: float or bool = None
+			self.Freq_Dev_Avg_F_1: float or bool = None
+			self.Freq_Dev_Min_F_1: float or bool = None
+			self.Freq_Dev_Max_F_1: float or bool = None
+			self.Freq_Dev_Avg_F_2: float or bool = None
+			self.Freq_Dev_Min_F_2: float or bool = None
+			self.Freq_Dev_Max_F_2: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:BRATe[:PTX] \n
-		Snippet: value: CalculateStruct = driver.multiEval.sacp.brate.ptx.calculate() \n
-		Returns the 'Spectrum ACP' results for BR packets. The values described below are returned by FETCh and READ commands.
-		CALCulate commands return limit check results instead, one value for each result listed below.
-			INTRO_CMD_HELP: The number of valid ACP results depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.Brate.Measurement.mode CH21 | CH79) : \n
-			- If 'ACP +/- 10 Channels' is selected, the first 21 ACP values contain the results for the relative channels –10, ..., 0, ..., +10; the remaining 58 values are not displayed.
-			- If 'ACP 79 Channels' is selected, valid ACP values are available for all channels in the Bluetooth regulatory range. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:CURRent \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.nmode.classic.current.calculate() \n
+		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'Normal mode classic:
+		statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands
+		return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:BRATe:PTX?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:CURRent?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:SACP CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- No_Of_Exceptions: int: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99
-			- Acp: List[float]: float 79 ACP results Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (BR) ' and 'Modulation limits (EDR) '. Range: 0 % to 100 %
+			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz
+			- Freq_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz
+			- Max_Drift: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz/50 μs
+			- Freq_Dev_Avg_F_1: float: No parameter help available
+			- Freq_Dev_Min_F_1: float: No parameter help available
+			- Freq_Dev_Max_F_1: float: No parameter help available
+			- Freq_Dev_Avg_F_2: float: No parameter help available
+			- Freq_Dev_Min_F_2: float: No parameter help available
+			- Freq_Dev_Max_F_2: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_int('No_Of_Exceptions'),
-			ArgStruct('Acp', DataType.FloatList, None, False, True, 1)]
+			ArgStruct.scalar_float('Freq_Accuracy'),
+			ArgStruct.scalar_float('Freq_Drift'),
+			ArgStruct.scalar_float('Max_Drift'),
+			ArgStruct.scalar_float('Freq_Dev_Avg_F_1'),
+			ArgStruct.scalar_float('Freq_Dev_Min_F_1'),
+			ArgStruct.scalar_float('Freq_Dev_Max_F_1'),
+			ArgStruct.scalar_float('Freq_Dev_Avg_F_2'),
+			ArgStruct.scalar_float('Freq_Dev_Min_F_2'),
+			ArgStruct.scalar_float('Freq_Dev_Max_F_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.No_Of_Exceptions: int = None
-			self.Acp: List[float] = None
+			self.Freq_Accuracy: float = None
+			self.Freq_Drift: float = None
+			self.Max_Drift: float = None
+			self.Freq_Dev_Avg_F_1: float = None
+			self.Freq_Dev_Min_F_1: float = None
+			self.Freq_Dev_Max_F_1: float = None
+			self.Freq_Dev_Avg_F_2: float = None
+			self.Freq_Dev_Min_F_2: float = None
+			self.Freq_Dev_Max_F_2: float = None
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:BRATe[:PTX] \n
-		Snippet: value: ResultData = driver.multiEval.sacp.brate.ptx.fetch() \n
-		Returns the 'Spectrum ACP' results for BR packets. The values described below are returned by FETCh and READ commands.
-		CALCulate commands return limit check results instead, one value for each result listed below.
-			INTRO_CMD_HELP: The number of valid ACP results depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.Brate.Measurement.mode CH21 | CH79) : \n
-			- If 'ACP +/- 10 Channels' is selected, the first 21 ACP values contain the results for the relative channels –10, ..., 0, ..., +10; the remaining 58 values are not displayed.
-			- If 'ACP 79 Channels' is selected, valid ACP values are available for all channels in the Bluetooth regulatory range. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.classic.current.fetch() \n
+		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'Normal mode classic:
+		statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands
+		return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:BRATe:PTX?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:CURRent?', self.__class__.ResultData())
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:BRATe[:PTX] \n
-		Snippet: value: ResultData = driver.multiEval.sacp.brate.ptx.read() \n
-		Returns the 'Spectrum ACP' results for BR packets. The values described below are returned by FETCh and READ commands.
-		CALCulate commands return limit check results instead, one value for each result listed below.
-			INTRO_CMD_HELP: The number of valid ACP results depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.Brate.Measurement.mode CH21 | CH79) : \n
-			- If 'ACP +/- 10 Channels' is selected, the first 21 ACP values contain the results for the relative channels –10, ..., 0, ..., +10; the remaining 58 values are not displayed.
-			- If 'ACP 79 Channels' is selected, valid ACP values are available for all channels in the Bluetooth regulatory range. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.modulation.nmode.classic.current.read() \n
+		Returns the current, average, xmin, xmax, and max modulation results for BR/EDR, normal mode, see 'Normal mode classic:
+		statistical modulation results'. The values described below are returned by FETCh and READ commands. CALCulate commands
+		return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:BRATe:PTX?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:MODulation:NMODe:CLASsic:CURRent?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/DevMagnitude/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 9 total commands, 3 Sub-groups, 0 group commands"""
+class DevMagnitudeCls:
+	"""DevMagnitude commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("devMagnitude", core, parent)
 
 	@property
-	def lrange(self):
-		"""lrange commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_lrange'):
-			from .LowEnergy_.Lrange import Lrange
-			self._lrange = Lrange(self._core, self._base)
-		return self._lrange
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
 
 	@property
-	def le2M(self):
-		"""le2M commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_le2M'):
-			from .LowEnergy_.Le2M import Le2M
-			self._le2M = Le2M(self._core, self._base)
-		return self._le2M
+	def average(self):
+		"""average commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
 
 	@property
-	def le1M(self):
-		"""le1M commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_le1M'):
-			from .LowEnergy_.Le1M import Le1M
-			self._le1M = Le1M(self._core, self._base)
-		return self._le1M
+	def current(self):
+		"""current commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
 
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'DevMagnitudeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = DevMagnitudeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/LowEnergy_/Le1M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/LowEnergy/Le1M.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,50 +1,50 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le1M:
-	"""Le1M commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class Le1MCls:
+	"""Le1M commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le1M", core, parent)
+		self._cmd_group = CommandsGroup("le1M", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm
-			- No_Of_Exceptions: float: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm
+			- No_Of_Exceptions: float or bool: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('No_Of_Exceptions')]
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('No_Of_Exceptions')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Nominal_Power: float = None
-			self.No_Of_Exceptions: float = None
+			self.Nominal_Power: float or bool = None
+			self.No_Of_Exceptions: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy[:LE1M] \n
 		Snippet: value: CalculateStruct = driver.multiEval.sacp.lowEnergy.le1M.calculate() \n
-		Returns the 'Spectrum ACP' results for LE1M, see 'LE: Spectrum ACP Results '. The values described below are returned by
-		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		Returns the 'Spectrum ACP' results for LE1M. See 'View Spectrum ACP'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE1M?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
+			- Reliability: int: decimal 'Reliability indicator'
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm
 			- No_Of_Exceptions: int: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_int('No_Of_Exceptions')]
 
@@ -53,19 +53,19 @@
 			self.Reliability: int = None
 			self.Nominal_Power: float = None
 			self.No_Of_Exceptions: int = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy[:LE1M] \n
 		Snippet: value: ResultData = driver.multiEval.sacp.lowEnergy.le1M.read() \n
-		Returns the 'Spectrum ACP' results for LE1M, see 'LE: Spectrum ACP Results '. The values described below are returned by
-		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		Returns the 'Spectrum ACP' results for LE1M. See 'View Spectrum ACP'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE1M?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy[:LE1M] \n
 		Snippet: value: ResultData = driver.multiEval.sacp.lowEnergy.le1M.fetch() \n
-		Returns the 'Spectrum ACP' results for LE1M, see 'LE: Spectrum ACP Results '. The values described below are returned by
-		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		Returns the 'Spectrum ACP' results for LE1M. See 'View Spectrum ACP'. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE1M?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/LowEnergy_/Le2M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/LowEnergy/Le2M.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,25 +1,25 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le2M:
-	"""Le2M commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class Le2MCls:
+	"""Le2M commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le2M", core, parent)
+		self._cmd_group = CommandsGroup("le2M", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
+			- Reliability: int: decimal 'Reliability indicator'
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm
 			- No_Of_Exceptions: int: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_int('No_Of_Exceptions')]
 
@@ -28,47 +28,47 @@
 			self.Reliability: int = None
 			self.Nominal_Power: float = None
 			self.No_Of_Exceptions: int = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE2M \n
 		Snippet: value: ResultData = driver.multiEval.sacp.lowEnergy.le2M.read() \n
-		Returns the 'Spectrum ACP' results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) , see 'LE: Spectrum ACP
-		Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
-		results instead, one value for each result listed below. \n
+		Returns the 'Spectrum ACP' results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . See 'View Spectrum ACP'.
+		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
+		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE2M?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE2M \n
 		Snippet: value: ResultData = driver.multiEval.sacp.lowEnergy.le2M.fetch() \n
-		Returns the 'Spectrum ACP' results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) , see 'LE: Spectrum ACP
-		Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
-		results instead, one value for each result listed below. \n
+		Returns the 'Spectrum ACP' results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . See 'View Spectrum ACP'.
+		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
+		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE2M?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm
-			- No_Of_Exceptions: float: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm
+			- No_Of_Exceptions: float or bool: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('No_Of_Exceptions')]
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('No_Of_Exceptions')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Nominal_Power: float = None
-			self.No_Of_Exceptions: float = None
+			self.Nominal_Power: float or bool = None
+			self.No_Of_Exceptions: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE2M \n
 		Snippet: value: CalculateStruct = driver.multiEval.sacp.lowEnergy.le2M.calculate() \n
-		Returns the 'Spectrum ACP' results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) , see 'LE: Spectrum ACP
-		Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
-		results instead, one value for each result listed below. \n
+		Returns the 'Spectrum ACP' results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) . See 'View Spectrum ACP'.
+		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
+		one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LE2M?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/LowEnergy_/Lrange.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sacp/Nmode/LowEnergy/Lrange.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,74 +1,74 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Lrange:
-	"""Lrange commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class LrangeCls:
+	"""Lrange commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lrange", core, parent)
+		self._cmd_group = CommandsGroup("lrange", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm
+			- Reliability: int: decimal 'Reliability indicator'
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to +30.0 dBm , Unit: dBm
 			- No_Of_Exceptions: int: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_int('No_Of_Exceptions')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Nominal_Power: float = None
 			self.No_Of_Exceptions: int = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LRANge \n
-		Snippet: value: ResultData = driver.multiEval.sacp.lowEnergy.lrange.read() \n
-		Returns the 'Spectrum ACP' results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) , see 'LE: Spectrum ACP
-		Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
-		results instead, one value for each result listed below. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LRANge \n
+		Snippet: value: ResultData = driver.multiEval.sacp.nmode.lowEnergy.lrange.read() \n
+		Returns the 'Spectrum ACP' results for LE normal mode, see 'View Spectrum ACP'. Commands for uncoded LE 1M PHY (..:LE1M..
+		) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by
+		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LRANge?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LRANge?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LRANge \n
-		Snippet: value: ResultData = driver.multiEval.sacp.lowEnergy.lrange.fetch() \n
-		Returns the 'Spectrum ACP' results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) , see 'LE: Spectrum ACP
-		Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
-		results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LRANge \n
+		Snippet: value: ResultData = driver.multiEval.sacp.nmode.lowEnergy.lrange.fetch() \n
+		Returns the 'Spectrum ACP' results for LE normal mode, see 'View Spectrum ACP'. Commands for uncoded LE 1M PHY (..:LE1M..
+		) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by
+		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LRANge?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LRANge?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm
-			- No_Of_Exceptions: float: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -128.0 dBm to +30.0 dBm , Unit: dBm
+			- No_Of_Exceptions: float or bool: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('No_Of_Exceptions')]
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('No_Of_Exceptions')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Nominal_Power: float = None
-			self.No_Of_Exceptions: float = None
+			self.Nominal_Power: float or bool = None
+			self.No_Of_Exceptions: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LRANge \n
-		Snippet: value: CalculateStruct = driver.multiEval.sacp.lowEnergy.lrange.calculate() \n
-		Returns the 'Spectrum ACP' results for LE 2M PHY (...:LE2M...) and LE coded PHY (...:LRANge...) , see 'LE: Spectrum ACP
-		Results '. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
-		results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LRANge \n
+		Snippet: value: CalculateStruct = driver.multiEval.sacp.nmode.lowEnergy.lrange.calculate() \n
+		Returns the 'Spectrum ACP' results for LE normal mode, see 'View Spectrum ACP'. Commands for uncoded LE 1M PHY (..:LE1M..
+		) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned by
+		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:LENergy:LRANge?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LRANge?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/Nmode.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/InputSignal/Cte/Qhsl/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,35 +1,59 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Nmode:
-	"""Nmode commands group definition. 12 total commands, 2 Sub-groups, 0 group commands"""
+class QhslCls:
+	"""Qhsl commands group definition. 10 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nmode", core, parent)
+		self._cmd_group = CommandsGroup("qhsl", core, parent)
 
 	@property
-	def classic(self):
-		"""classic commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_classic'):
-			from .Nmode_.Classic import Classic
-			self._classic = Classic(self._core, self._base)
-		return self._classic
+	def p2Q(self):
+		"""p2Q commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_p2Q'):
+			from .P2Q import P2QCls
+			self._p2Q = P2QCls(self._core, self._cmd_group)
+		return self._p2Q
 
 	@property
-	def lowEnergy(self):
-		"""lowEnergy commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_lowEnergy'):
-			from .Nmode_.LowEnergy import LowEnergy
-			self._lowEnergy = LowEnergy(self._core, self._base)
-		return self._lowEnergy
+	def p3Q(self):
+		"""p3Q commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_p3Q'):
+			from .P3Q import P3QCls
+			self._p3Q = P3QCls(self._core, self._cmd_group)
+		return self._p3Q
 
-	def clone(self) -> 'Nmode':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def p4Q(self):
+		"""p4Q commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_p4Q'):
+			from .P4Q import P4QCls
+			self._p4Q = P4QCls(self._core, self._cmd_group)
+		return self._p4Q
+
+	@property
+	def p5Q(self):
+		"""p5Q commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_p5Q'):
+			from .P5Q import P5QCls
+			self._p5Q = P5QCls(self._core, self._cmd_group)
+		return self._p5Q
+
+	@property
+	def p6Q(self):
+		"""p6Q commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_p6Q'):
+			from .P6Q import P6QCls
+			self._p6Q = P6QCls(self._core, self._cmd_group)
+		return self._p6Q
+
+	def clone(self) -> 'QhslCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Nmode(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = QhslCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/Nmode_/Classic.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Nmode/Classic/Maximum.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,86 +1,88 @@
-from typing import List
-
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.Types import DataType
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Classic:
-	"""Classic commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("classic", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:SACP CMDLINK]) exceeding the specified BR limits, see 'ACP (BR, LE) '. Range: 0 % to 100 %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm
-			- No_Of_Exceptions: float: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99
-			- Acp: List[float]: float 21 ACP values - results for the relative channels -10, ..., 0, ..., +10 (mode 'ACP +/-10 Channels') Range: -99.99 dBm to 99.99 dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.Brate.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.Edrate#PowerVsTime CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('No_Of_Exceptions'),
-			ArgStruct('Acp', DataType.FloatList, None, False, True, 1)]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float('Nominal_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
+			self.Out_Of_Tol: float or bool = None
 			self.Nominal_Power: float = None
-			self.No_Of_Exceptions: float = None
-			self.Acp: List[float] = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:CLASsic \n
-		Snippet: value: CalculateStruct = driver.multiEval.sacp.nmode.classic.calculate() \n
-		Returns the 'Spectrum ACP' results for normal mode classic. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:MAXimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.powerVsTime.nmode.classic.maximum.calculate() \n
+		Returns the current, average, min, and max power results for BR/EDR, normal mode. The values described below are returned
+		by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:CLASsic?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:MAXimum?', self.__class__.CalculateStruct())
+
+	# noinspection PyTypeChecker
+	class ReadStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.Brate.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.Edrate#PowerVsTime CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+		__meta_args_list = [
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float('Nominal_Power')]
+
+		def __init__(self):
+			StructBase.__init__(self, self)
+			self.Reliability: int = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float = None
+
+	def read(self) -> ReadStruct:
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:MAXimum \n
+		Snippet: value: ReadStruct = driver.multiEval.powerVsTime.nmode.classic.maximum.read() \n
+		Returns the current, average, min, and max power results for BR/EDR, normal mode. The values described below are returned
+		by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ReadStruct structure arguments."""
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:MAXimum?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
-	class ResultData(StructBase):
+	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:SACP CMDLINK]) exceeding the specified BR limits, see 'ACP (BR, LE) '. Range: 0 % to 100 %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm
-			- No_Of_Exceptions: int: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99
-			- Acp: List[float]: float 21 ACP values - results for the relative channels -10, ..., 0, ..., +10 (mode 'ACP +/-10 Channels') Range: -99.99 dBm to 99.99 dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.Brate.PowerVsTime#set CMDLINKRESOLVED] and [CMDLINKRESOLVED Configure.MultiEval.Limit.Edrate#PowerVsTime CMDLINKRESOLVED]. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_int('No_Of_Exceptions'),
-			ArgStruct('Acp', DataType.FloatList, None, False, True, 1)]
+			ArgStruct.scalar_float('Nominal_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
-			self.No_Of_Exceptions: int = None
-			self.Acp: List[float] = None
 
-	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:CLASsic \n
-		Snippet: value: ResultData = driver.multiEval.sacp.nmode.classic.read() \n
-		Returns the 'Spectrum ACP' results for normal mode classic. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:CLASsic?', self.__class__.ResultData())
-
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:CLASsic \n
-		Snippet: value: ResultData = driver.multiEval.sacp.nmode.classic.fetch() \n
-		Returns the 'Spectrum ACP' results for normal mode classic. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:CLASsic?', self.__class__.ResultData())
+	def fetch(self) -> FetchStruct:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:MAXimum \n
+		Snippet: value: FetchStruct = driver.multiEval.powerVsTime.nmode.classic.maximum.fetch() \n
+		Returns the current, average, min, and max power results for BR/EDR, normal mode. The values described below are returned
+		by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for FetchStruct structure arguments."""
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:PVTime:NMODe:CLASsic:MAXimum?', self.__class__.FetchStruct())
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/Nmode_/LowEnergy.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/PowerVsTime/Brate/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,43 +1,51 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class LowEnergy:
-	"""LowEnergy commands group definition. 9 total commands, 3 Sub-groups, 0 group commands"""
+class BrateCls:
+	"""Brate commands group definition. 12 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("lowEnergy", core, parent)
+		self._cmd_group = CommandsGroup("brate", core, parent)
 
 	@property
-	def le1M(self):
-		"""le1M commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_le1M'):
-			from .LowEnergy_.Le1M import Le1M
-			self._le1M = Le1M(self._core, self._base)
-		return self._le1M
+	def average(self):
+		"""average commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
 
 	@property
-	def lrange(self):
-		"""lrange commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_lrange'):
-			from .LowEnergy_.Lrange import Lrange
-			self._lrange = Lrange(self._core, self._base)
-		return self._lrange
+	def current(self):
+		"""current commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
 
 	@property
-	def le2M(self):
-		"""le2M commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_le2M'):
-			from .LowEnergy_.Le2M import Le2M
-			self._le2M = Le2M(self._core, self._base)
-		return self._le2M
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
 
-	def clone(self) -> 'LowEnergy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	def clone(self) -> 'BrateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = LowEnergy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = BrateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sacp_/Nmode_/LowEnergy_/Le2M.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Xminimum/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,74 +1,76 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Le2M:
-	"""Le2M commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class XminimumCls:
+	"""Xminimum commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("le2M", core, parent)
+		self._cmd_group = CommandsGroup("xminimum", core, parent)
 
-	# noinspection PyTypeChecker
-	class ResultData(StructBase):
-		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to +30.0 dBm , Unit: dBm
-			- No_Of_Exceptions: int: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_int('No_Of_Exceptions')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Nominal_Power: float = None
-			self.No_Of_Exceptions: int = None
-
-	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LE2M \n
-		Snippet: value: ResultData = driver.multiEval.sacp.nmode.lowEnergy.le2M.read() \n
-		Returns the 'Spectrum ACP' results for LE normal mode, see 'LE: Spectrum ACP Results '. Commands for uncoded LE 1M PHY (..
-		:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned
-		by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LE2M?', self.__class__.ResultData())
-
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LE2M \n
-		Snippet: value: ResultData = driver.multiEval.sacp.nmode.lowEnergy.le2M.fetch() \n
-		Returns the 'Spectrum ACP' results for LE normal mode, see 'LE: Spectrum ACP Results '. Commands for uncoded LE 1M PHY (..
-		:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned
-		by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LE2M?', self.__class__.ResultData())
+	@property
+	def extended(self):
+		"""extended commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_extended'):
+			from .Extended import ExtendedCls
+			self._extended = ExtendedCls(self._core, self._cmd_group)
+		return self._extended
 
 	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
+	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to +30.0 dBm , Unit: dBm
-			- No_Of_Exceptions: float: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment. The meaning of the returned values is the same as for the common reliability indicator, see previous parameter.
+			- Out_Of_Tol: float: float Percentage of measured bursts with failed limit check Range: 0 % to 100 % , Unit: %
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Freq_Acc_Or_Init_Freq_Error: float: float Frequency accuracy (BR, LE) or initial center frequency error ωi (EDR) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float: float Frequency drift (BR, LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Max_Drift_Rate: float: float Maximal drift rate (BR, LE) Range: -0.99999 MHz/50 μs to 0.99999 MHz/50 μs , Unit: Hz/50 μs
+			- Freq_Offset: float: float Frequency offset (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Initial_Freq_Drift: float: float Initial frequency drift (LE) Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('No_Of_Exceptions')]
+			ArgStruct.scalar_float('Freq_Acc_Or_Init_Freq_Error'),
+			ArgStruct.scalar_float('Freq_Drift'),
+			ArgStruct.scalar_float('Max_Drift_Rate'),
+			ArgStruct.scalar_float('Freq_Offset'),
+			ArgStruct.scalar_float('Initial_Freq_Drift')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
+			self.Seg_Reliability: int = None
+			self.Out_Of_Tol: float = None
 			self.Nominal_Power: float = None
-			self.No_Of_Exceptions: float = None
-
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LE2M \n
-		Snippet: value: CalculateStruct = driver.multiEval.sacp.nmode.lowEnergy.le2M.calculate() \n
-		Returns the 'Spectrum ACP' results for LE normal mode, see 'LE: Spectrum ACP Results '. Commands for uncoded LE 1M PHY (..
-		:LE1M..) , LE 2M PHY (..:LE2M..) , and LE coded PHY (..:LRANge..) are available. The values described below are returned
-		by FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SACP:NMODe:LENergy:LE2M?', self.__class__.CalculateStruct())
+			self.Freq_Acc_Or_Init_Freq_Error: float = None
+			self.Freq_Drift: float = None
+			self.Max_Drift_Rate: float = None
+			self.Freq_Offset: float = None
+			self.Initial_Freq_Drift: float = None
+
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:XMINimum \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.xminimum.fetch(segment = repcap.Segment.Default) \n
+		Returns modulation single extreme minimum and maximum (xmin, xmax) value results for segment<no> in list mode.
+		The command returns all parameters listed below, independent of the selected list mode setup. However, only for some of
+		the parameters measured values are available. For the other parameters, only an indicator is returned (e.g. NAV) . \n
+			:param segment: optional repeated capability selector. Default value: S1 (settable in the interface 'Segment')
+			:return: structure: for return value, see the help for FetchStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:XMINimum?', self.__class__.FetchStruct())
+
+	def clone(self) -> 'XminimumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = XminimumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sgacp.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Aaddress/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sgacp:
-	"""Sgacp commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class AaddressCls:
+	"""Aaddress commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sgacp", core, parent)
+		self._cmd_group = CommandsGroup("aaddress", core, parent)
 
 	@property
-	def edrate(self):
-		"""edrate commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_edrate'):
-			from .Sgacp_.Edrate import Edrate
-			self._edrate = Edrate(self._core, self._base)
-		return self._edrate
+	def lowEnergy(self):
+		"""lowEnergy commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_lowEnergy'):
+			from .LowEnergy import LowEnergyCls
+			self._lowEnergy = LowEnergyCls(self._core, self._cmd_group)
+		return self._lowEnergy
 
-	def clone(self) -> 'Sgacp':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AaddressCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Sgacp(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AaddressCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sgacp_/Edrate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sgacp/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Edrate:
-	"""Edrate commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class SgacpCls:
+	"""Sgacp commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("edrate", core, parent)
+		self._cmd_group = CommandsGroup("sgacp", core, parent)
 
 	@property
-	def ptx(self):
-		"""ptx commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_ptx'):
-			from .Edrate_.Ptx import Ptx
-			self._ptx = Ptx(self._core, self._base)
-		return self._ptx
+	def edrate(self):
+		"""edrate commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_edrate'):
+			from .Edrate import EdrateCls
+			self._edrate = EdrateCls(self._core, self._cmd_group)
+		return self._edrate
 
-	def clone(self) -> 'Edrate':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SgacpCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Edrate(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SgacpCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Sgacp_/Edrate_/Ptx.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Sgacp/Edrate/Ptx.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ptx:
-	"""Ptx commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class PtxCls:
+	"""Ptx commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ptx", core, parent)
+		self._cmd_group = CommandsGroup("ptx", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:SGACp CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Sgacp CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- No_Of_Exceptions: int: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99
 			- Ptx_Ref: float: float Reference power PTXref, measured in the center channel Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Ptx_N_26_Ch_N_1_Abs: float: No parameter help available
 			- Ptx_N_26_Ch_P_1_Abs: float: No parameter help available
 			- Ptx_N_26_Ch_N_1_Rel: float: No parameter help available
 			- Ptx_N_26_Ch_P_1_Rel: float: No parameter help available"""
@@ -62,45 +62,45 @@
 		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:SGACp:EDRate:PTX?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:SGACp CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- No_Of_Exceptions: float: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99
-			- Ptx_Ref: float: float Reference power PTXref, measured in the center channel Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Ptx_N_26_Ch_N_1_Abs: float: No parameter help available
-			- Ptx_N_26_Ch_P_1_Abs: float: No parameter help available
-			- Ptx_N_26_Ch_N_1_Rel: float: No parameter help available
-			- Ptx_N_26_Ch_P_1_Rel: float: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Sgacp CMDLINKRESOLVED]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- No_Of_Exceptions: float or bool: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99
+			- Ptx_Ref: float or bool: float Reference power PTXref, measured in the center channel Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Ptx_N_26_Ch_N_1_Abs: float or bool: No parameter help available
+			- Ptx_N_26_Ch_P_1_Abs: float or bool: No parameter help available
+			- Ptx_N_26_Ch_N_1_Rel: float or bool: No parameter help available
+			- Ptx_N_26_Ch_P_1_Rel: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('No_Of_Exceptions'),
-			ArgStruct.scalar_float('Ptx_Ref'),
-			ArgStruct.scalar_float('Ptx_N_26_Ch_N_1_Abs'),
-			ArgStruct.scalar_float('Ptx_N_26_Ch_P_1_Abs'),
-			ArgStruct.scalar_float('Ptx_N_26_Ch_N_1_Rel'),
-			ArgStruct.scalar_float('Ptx_N_26_Ch_P_1_Rel')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('No_Of_Exceptions'),
+			ArgStruct.scalar_float_ext('Ptx_Ref'),
+			ArgStruct.scalar_float_ext('Ptx_N_26_Ch_N_1_Abs'),
+			ArgStruct.scalar_float_ext('Ptx_N_26_Ch_P_1_Abs'),
+			ArgStruct.scalar_float_ext('Ptx_N_26_Ch_N_1_Rel'),
+			ArgStruct.scalar_float_ext('Ptx_N_26_Ch_P_1_Rel')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.No_Of_Exceptions: float = None
-			self.Ptx_Ref: float = None
-			self.Ptx_N_26_Ch_N_1_Abs: float = None
-			self.Ptx_N_26_Ch_P_1_Abs: float = None
-			self.Ptx_N_26_Ch_N_1_Rel: float = None
-			self.Ptx_N_26_Ch_P_1_Rel: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.No_Of_Exceptions: float or bool = None
+			self.Ptx_Ref: float or bool = None
+			self.Ptx_N_26_Ch_N_1_Abs: float or bool = None
+			self.Ptx_N_26_Ch_P_1_Abs: float or bool = None
+			self.Ptx_N_26_Ch_N_1_Rel: float or bool = None
+			self.Ptx_N_26_Ch_P_1_Rel: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SGACp:EDRate[:PTX] \n
 		Snippet: value: CalculateStruct = driver.multiEval.sgacp.edrate.ptx.calculate() \n
 		Returns the 'Spectrum Gated ACP' results for EDR packets (single values) . The values described below are returned by
 		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/SoBw.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/DtMode/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SoBw:
-	"""SoBw commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class DtModeCls:
+	"""DtMode commands group definition. 23 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("soBw", core, parent)
+		self._cmd_group = CommandsGroup("dtMode", core, parent)
 
 	@property
-	def brate(self):
-		"""brate commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_brate'):
-			from .SoBw_.Brate import Brate
-			self._brate = Brate(self._core, self._base)
-		return self._brate
+	def rxQuality(self):
+		"""rxQuality commands group. 6 Sub-classes, 0 commands."""
+		if not hasattr(self, '_rxQuality'):
+			from .RxQuality import RxQualityCls
+			self._rxQuality = RxQualityCls(self._core, self._cmd_group)
+		return self._rxQuality
 
-	def clone(self) -> 'SoBw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'DtModeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = SoBw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = DtModeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/SoBw_/Brate.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/DtMode/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Brate:
-	"""Brate commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class DtModeCls:
+	"""DtMode commands group definition. 26 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("brate", core, parent)
+		self._cmd_group = CommandsGroup("dtMode", core, parent)
 
 	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Brate_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
+	def rxQuality(self):
+		"""rxQuality commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_rxQuality'):
+			from .RxQuality import RxQualityCls
+			self._rxQuality = RxQualityCls(self._core, self._cmd_group)
+		return self._rxQuality
 
-	def clone(self) -> 'Brate':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'DtModeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Brate(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = DtModeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/SoBw_/Brate_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/SoBw/Brate/Maximum.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,63 +1,63 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:SOBW CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
-			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Emission: float: float Peak power in the measured spectral range Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Fl: float: float Lower frequency where the transmit power drops 20 dB below the peak emission Range: -0.99999E+6 MHz to 0.99999E+6 MHz, Unit: Hz
-			- Fh: float: float Higher frequency where the transmit power drops 20 dB below the peak emission Range: -0.99999E+6 MHz to 0.99999E+6 MHz
-			- Fh_Min_Fl: float: float 20 dB bandwidth; difference between fH – fL. Range: -0.99999E+6 MHz to 0.99999E+6 MHz, Unit: Hz"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#SoBw CMDLINKRESOLVED]) exceeding the specified limit. ([CMDLINKRESOLVED Configure.MultiEval.Limit.SoBw#set CMDLINKRESOLVED]) Range: 0 % to 100 %, Unit: %
+			- Nominal_Power: float or bool: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Peak_Emission: float or bool: float Peak power in the measured spectral range Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- Fl: float or bool: float Lower frequency where the transmit power drops 20 dB below the peak emission Range: -0.99999E+6 MHz to 0.99999E+6 MHz, Unit: Hz
+			- Fh: float or bool: float Higher frequency where the transmit power drops 20 dB below the peak emission Range: -0.99999E+6 MHz to 0.99999E+6 MHz
+			- Fh_Min_Fl: float or bool: float 20 dB bandwidth; difference between fH – fL. Range: -0.99999E+6 MHz to 0.99999E+6 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Out_Of_Tol'),
-			ArgStruct.scalar_float('Nominal_Power'),
-			ArgStruct.scalar_float('Peak_Emission'),
-			ArgStruct.scalar_float('Fl'),
-			ArgStruct.scalar_float('Fh'),
-			ArgStruct.scalar_float('Fh_Min_Fl')]
+			ArgStruct.scalar_float_ext('Out_Of_Tol'),
+			ArgStruct.scalar_float_ext('Nominal_Power'),
+			ArgStruct.scalar_float_ext('Peak_Emission'),
+			ArgStruct.scalar_float_ext('Fl'),
+			ArgStruct.scalar_float_ext('Fh'),
+			ArgStruct.scalar_float_ext('Fh_Min_Fl')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tol: float = None
-			self.Nominal_Power: float = None
-			self.Peak_Emission: float = None
-			self.Fl: float = None
-			self.Fh: float = None
-			self.Fh_Min_Fl: float = None
+			self.Out_Of_Tol: float or bool = None
+			self.Nominal_Power: float or bool = None
+			self.Peak_Emission: float or bool = None
+			self.Fl: float or bool = None
+			self.Fh: float or bool = None
+			self.Fh_Min_Fl: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SOBW:BRATe:MAXimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.soBw.brate.maximum.calculate() \n
 		Returns the 'Spectrum 20 dB Bandwidth' results. The values described below are returned by FETCh and READ commands.
 		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:SOBW:BRATe:MAXimum?', self.__class__.CalculateStruct())
 
 	# noinspection PyTypeChecker
 	class ReadStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:SOBW CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float or bool: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#SoBw CMDLINKRESOLVED]) exceeding the specified limit. ([CMDLINKRESOLVED Configure.MultiEval.Limit.SoBw#set CMDLINKRESOLVED]) Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Peak_Emission: float: float Peak power in the measured spectral range Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Fl: float: float Lower frequency where the transmit power drops 20 dB below the peak emission Range: -0.99999E+6 MHz to 0.99999E+6 MHz, Unit: Hz
 			- Fh: float: float Higher frequency where the transmit power drops 20 dB below the peak emission Range: -0.99999E+6 MHz to 0.99999E+6 MHz
 			- Fh_Min_Fl: float: float 20 dB bandwidth; difference between fH – fL. Range: -0.99999E+6 MHz to 0.99999E+6 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
@@ -85,16 +85,16 @@
 		CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ReadStruct structure arguments."""
 		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:SOBW:BRATe:MAXimum?', self.__class__.ReadStruct())
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:SOBW CMDLINK]) exceeding the specified limits. Range: 0 % to 100 %, Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float | ON | OFF Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#SoBw CMDLINKRESOLVED]) exceeding the specified limit. ([CMDLINKRESOLVED Configure.MultiEval.Limit.SoBw#set CMDLINKRESOLVED]) Range: 0 % to 100 %, Unit: %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Peak_Emission: float: float Peak power in the measured spectral range Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Fl: float: float Lower frequency where the transmit power drops 20 dB below the peak emission Range: -0.99999E+6 MHz to 0.99999E+6 MHz, Unit: Hz
 			- Fh: float: float Higher frequency where the transmit power drops 20 dB below the peak emission Range: -0.99999E+6 MHz to 0.99999E+6 MHz
 			- Fh_Min_Fl: float: float 20 dB bandwidth; difference between fH – fL. Range: -0.99999E+6 MHz to 0.99999E+6 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/State.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trx/State/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,39 +1,46 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.Types import DataType
+from ....Internal.ArgSingleList import ArgSingleList
+from ....Internal.ArgSingle import ArgSingle
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class State:
-	"""State commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class StateCls:
+	"""State commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("state", core, parent)
+		self._cmd_group = CommandsGroup("state", core, parent)
 
 	@property
 	def all(self):
 		"""all commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_all'):
-			from .State_.All import All
-			self._all = All(self._core, self._base)
+			from .All import AllCls
+			self._all = AllCls(self._core, self._cmd_group)
 		return self._all
 
 	# noinspection PyTypeChecker
-	def fetch(self) -> enums.ResourceState:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:STATe \n
-		Snippet: value: enums.ResourceState = driver.multiEval.state.fetch() \n
+	def fetch(self, timeout: float = None, target_main_state: enums.ResourceState = None, target_sync_state: enums.SyncState = None) -> enums.ResourceState:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:TRX:STATe \n
+		Snippet: value: enums.ResourceState = driver.trx.state.fetch(timeout = 1.0, target_main_state = enums.ResourceState.ACTive, target_sync_state = enums.SyncState.ADJusted) \n
 		Queries the main measurement state. Use FETCh:...:STATe:ALL? to query the measurement state including the substates. Use
 		INITiate..., STOP..., ABORt... to change the measurement state. \n
-			:return: meas_state: OFF | RUN | RDY OFF: Measurement switched off, no resources allocated, no results available (when entered after ABORt...) RUN: Measurement running (after INITiate..., READ...) , synchronization pending or adjusted, resources active or queued RDY: Measurement has been terminated, valid results are available"""
-		response = self._core.io.query_str(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:STATe?')
+			:param timeout: No help available
+			:param target_main_state: No help available
+			:param target_sync_state: No help available
+			:return: meas_state: OFF | RDY | RUN OFF: measurement switched off, no resources allocated, no results available (when entered after ABORt...) RDY: measurement has been terminated, valid results are available RUN: measurement running (after INITiate..., READ...) , synchronization pending or adjusted, resources active or queued"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('timeout', timeout, DataType.Float, None, is_optional=True), ArgSingle('target_main_state', target_main_state, DataType.Enum, enums.ResourceState, is_optional=True), ArgSingle('target_sync_state', target_sync_state, DataType.Enum, enums.SyncState, is_optional=True))
+		response = self._core.io.query_str(f'FETCh:BLUetooth:MEASurement<Instance>:TRX:STATe? {param}'.rstrip())
 		return Conversions.str_to_scalar_enum(response, enums.ResourceState)
 
-	def clone(self) -> 'State':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'StateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = State(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = StateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/State_/All.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/State/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,40 +1,46 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from ....Internal import Conversions
+from ....Internal.Types import DataType
+from ....Internal.ArgSingleList import ArgSingleList
+from ....Internal.ArgSingle import ArgSingle
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class All:
-	"""All commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StateCls:
+	"""State commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("all", core, parent)
+		self._cmd_group = CommandsGroup("state", core, parent)
+
+	@property
+	def all(self):
+		"""all commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_all'):
+			from .All import AllCls
+			self._all = AllCls(self._core, self._cmd_group)
+		return self._all
 
 	# noinspection PyTypeChecker
-	class FetchStruct(StructBase):
-		"""Response structure. Fields: \n
-			- Main_State: enums.ResourceState: OFF | RDY | RUN OFF: Measurement switched off, no resources allocated, no results available (when entered after STOP...) RDY: Measurement has been terminated, valid results are available RUN: Measurement running (after INITiate..., READ...) , synchronization pending or adjusted, resources active or queued
-			- Sync_State: enums.ResourceState: PEND | ADJ | INV PEND: Waiting for resource allocation, adjustment, hardware switching ('pending') ADJ: All necessary adjustments finished, measurement running ('adjusted') INV: Not applicable because main_state: OFF or RDY ('invalid')
-			- Resource_State: enums.ResourceState: QUE | ACT | INV QUE: Measurement without resources, no results available ('queued') ACT: Resources allocated, acquisition of results in progress but not complete ('active') INV: Not applicable because main_state: OFF or RDY ('invalid')"""
-		__meta_args_list = [
-			ArgStruct.scalar_enum('Main_State', enums.ResourceState),
-			ArgStruct.scalar_enum('Sync_State', enums.ResourceState),
-			ArgStruct.scalar_enum('Resource_State', enums.ResourceState)]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Main_State: enums.ResourceState = None
-			self.Sync_State: enums.ResourceState = None
-			self.Resource_State: enums.ResourceState = None
-
-	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:STATe:ALL \n
-		Snippet: value: FetchStruct = driver.multiEval.state.all.fetch() \n
-		Queries the main measurement state and the measurement substates. Both measurement substates are relevant for running
-		measurements only. Use FETCh:...:STATe? to query the main measurement state only. Use INITiate..., STOP..., ABORt...
-		to change the measurement state. \n
-			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:STATe:ALL?', self.__class__.FetchStruct())
+	def fetch(self, timeout: float = None, target_main_state: enums.ResourceState = None, target_sync_state: enums.SyncState = None) -> enums.ResourceState:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:STATe \n
+		Snippet: value: enums.ResourceState = driver.multiEval.state.fetch(timeout = 1.0, target_main_state = enums.ResourceState.ACTive, target_sync_state = enums.SyncState.ADJusted) \n
+		Queries the main measurement state. Use FETCh:...:STATe:ALL? to query the measurement state including the substates. Use
+		INITiate..., STOP..., ABORt... to change the measurement state. \n
+			:param timeout: No help available
+			:param target_main_state: No help available
+			:param target_sync_state: No help available
+			:return: meas_state: OFF | RUN | RDY OFF: Measurement switched off, no resources allocated, no results available (when entered after ABORt...) . RUN: Measurement running (after INITiate..., READ...) , synchronization pending or adjusted, resources active or queued RDY: Measurement has been terminated, valid results are available."""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('timeout', timeout, DataType.Float, None, is_optional=True), ArgSingle('target_main_state', target_main_state, DataType.Enum, enums.ResourceState, is_optional=True), ArgSingle('target_sync_state', target_sync_state, DataType.Enum, enums.SyncState, is_optional=True))
+		response = self._core.io.query_str(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:STATe? {param}'.rstrip())
+		return Conversions.str_to_scalar_enum(response, enums.ResourceState)
+
+	def clone(self) -> 'StateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = StateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,123 +1,123 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Trace:
-	"""Trace commands group definition. 72 total commands, 13 Sub-groups, 0 group commands"""
+class TraceCls:
+	"""Trace commands group definition. 72 total commands, 13 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("trace", core, parent)
+		self._cmd_group = CommandsGroup("trace", core, parent)
 
 	@property
 	def frange(self):
 		"""frange commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_frange'):
-			from .Trace_.Frange import Frange
-			self._frange = Frange(self._core, self._base)
+			from .Frange import FrangeCls
+			self._frange = FrangeCls(self._core, self._cmd_group)
 		return self._frange
 
 	@property
 	def soBw(self):
 		"""soBw commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_soBw'):
-			from .Trace_.SoBw import SoBw
-			self._soBw = SoBw(self._core, self._base)
+			from .SoBw import SoBwCls
+			self._soBw = SoBwCls(self._core, self._cmd_group)
 		return self._soBw
 
 	@property
 	def sacp(self):
 		"""sacp commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_sacp'):
-			from .Trace_.Sacp import Sacp
-			self._sacp = Sacp(self._core, self._base)
+			from .Sacp import SacpCls
+			self._sacp = SacpCls(self._core, self._cmd_group)
 		return self._sacp
 
 	@property
 	def sgacp(self):
 		"""sgacp commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_sgacp'):
-			from .Trace_.Sgacp import Sgacp
-			self._sgacp = Sgacp(self._core, self._base)
+			from .Sgacp import SgacpCls
+			self._sgacp = SgacpCls(self._core, self._cmd_group)
 		return self._sgacp
 
 	@property
 	def devMagnitude(self):
 		"""devMagnitude commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_devMagnitude'):
-			from .Trace_.DevMagnitude import DevMagnitude
-			self._devMagnitude = DevMagnitude(self._core, self._base)
+			from .DevMagnitude import DevMagnitudeCls
+			self._devMagnitude = DevMagnitudeCls(self._core, self._cmd_group)
 		return self._devMagnitude
 
 	@property
 	def pdifference(self):
 		"""pdifference commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_pdifference'):
-			from .Trace_.Pdifference import Pdifference
-			self._pdifference = Pdifference(self._core, self._base)
+			from .Pdifference import PdifferenceCls
+			self._pdifference = PdifferenceCls(self._core, self._cmd_group)
 		return self._pdifference
 
 	@property
 	def iqAbs(self):
 		"""iqAbs commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_iqAbs'):
-			from .Trace_.IqAbs import IqAbs
-			self._iqAbs = IqAbs(self._core, self._base)
+			from .IqAbs import IqAbsCls
+			self._iqAbs = IqAbsCls(self._core, self._cmd_group)
 		return self._iqAbs
 
 	@property
 	def iqDifference(self):
 		"""iqDifference commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_iqDifference'):
-			from .Trace_.IqDifference import IqDifference
-			self._iqDifference = IqDifference(self._core, self._base)
+			from .IqDifference import IqDifferenceCls
+			self._iqDifference = IqDifferenceCls(self._core, self._cmd_group)
 		return self._iqDifference
 
 	@property
 	def iqError(self):
 		"""iqError commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_iqError'):
-			from .Trace_.IqError import IqError
-			self._iqError = IqError(self._core, self._base)
+			from .IqError import IqErrorCls
+			self._iqError = IqErrorCls(self._core, self._cmd_group)
 		return self._iqError
 
 	@property
 	def fdeviation(self):
 		"""fdeviation commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_fdeviation'):
-			from .Trace_.Fdeviation import Fdeviation
-			self._fdeviation = Fdeviation(self._core, self._base)
+			from .Fdeviation import FdeviationCls
+			self._fdeviation = FdeviationCls(self._core, self._cmd_group)
 		return self._fdeviation
 
 	@property
 	def spower(self):
 		"""spower commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_spower'):
-			from .Trace_.Spower import Spower
-			self._spower = Spower(self._core, self._base)
+			from .Spower import SpowerCls
+			self._spower = SpowerCls(self._core, self._cmd_group)
 		return self._spower
 
 	@property
 	def pdeviation(self):
 		"""pdeviation commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_pdeviation'):
-			from .Trace_.Pdeviation import Pdeviation
-			self._pdeviation = Pdeviation(self._core, self._base)
+			from .Pdeviation import PdeviationCls
+			self._pdeviation = PdeviationCls(self._core, self._cmd_group)
 		return self._pdeviation
 
 	@property
 	def powerVsTime(self):
 		"""powerVsTime commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_powerVsTime'):
-			from .Trace_.PowerVsTime import PowerVsTime
-			self._powerVsTime = PowerVsTime(self._core, self._base)
+			from .PowerVsTime import PowerVsTimeCls
+			self._powerVsTime = PowerVsTimeCls(self._core, self._cmd_group)
 		return self._powerVsTime
 
-	def clone(self) -> 'Trace':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'TraceCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Trace(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TraceCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/DevMagnitude.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Trace/Pdifference/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DevMagnitude:
-	"""DevMagnitude commands group definition. 6 total commands, 3 Sub-groups, 0 group commands"""
+class PdifferenceCls:
+	"""Pdifference commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("devMagnitude", core, parent)
+		self._cmd_group = CommandsGroup("pdifference", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .DevMagnitude_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .DevMagnitude_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_maximum'):
-			from .DevMagnitude_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
+	def current(self):
+		"""current commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
 
-	def clone(self) -> 'DevMagnitude':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PdifferenceCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = DevMagnitude(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PdifferenceCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/DevMagnitude_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/DevMagnitude/Average.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:DEVMagnitude:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.trace.devMagnitude.average.fetch() \n
 		Returns the values of the DEVM traces. The results of the current, average minimum and maximum traces can be retrieved.
 		The DEVM traces are available for EDR bursts (method RsCmwBluetoothMeas.Configure.InputSignal.btype EDR) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: devm: float m DEVM results, depending on the packet type and payload length; see 'DEVM Trace Points for Test Mode (EDR) '. Range: 0 % to 100 % , Unit: %"""
+			:return: devm: float N DEVM results, depending on the packet type and payload length. Range: 0 % to 100 % , Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:DEVMagnitude:AVERage?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:DEVMagnitude:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.trace.devMagnitude.average.read() \n
 		Returns the values of the DEVM traces. The results of the current, average minimum and maximum traces can be retrieved.
 		The DEVM traces are available for EDR bursts (method RsCmwBluetoothMeas.Configure.InputSignal.btype EDR) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: devm: float m DEVM results, depending on the packet type and payload length; see 'DEVM Trace Points for Test Mode (EDR) '. Range: 0 % to 100 % , Unit: %"""
+			:return: devm: float N DEVM results, depending on the packet type and payload length. Range: 0 % to 100 % , Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:DEVMagnitude:AVERage?', suppressed)
 		return response
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/DevMagnitude_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/DevMagnitude/Maximum.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:DEVMagnitude:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.trace.devMagnitude.current.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:DEVMagnitude:MAXimum \n
+		Snippet: value: List[float] = driver.multiEval.trace.devMagnitude.maximum.fetch() \n
 		Returns the values of the DEVM traces. The results of the current, average minimum and maximum traces can be retrieved.
 		The DEVM traces are available for EDR bursts (method RsCmwBluetoothMeas.Configure.InputSignal.btype EDR) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: devm: float m DEVM results, depending on the packet type and payload length; see 'DEVM Trace Points for Test Mode (EDR) '. Range: 0 % to 100 % , Unit: %"""
+			:return: devm: float N DEVM results, depending on the packet type and payload length. Range: 0 % to 100 % , Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:DEVMagnitude:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:DEVMagnitude:MAXimum?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:DEVMagnitude:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.trace.devMagnitude.current.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:DEVMagnitude:MAXimum \n
+		Snippet: value: List[float] = driver.multiEval.trace.devMagnitude.maximum.read() \n
 		Returns the values of the DEVM traces. The results of the current, average minimum and maximum traces can be retrieved.
 		The DEVM traces are available for EDR bursts (method RsCmwBluetoothMeas.Configure.InputSignal.btype EDR) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: devm: float m DEVM results, depending on the packet type and payload length; see 'DEVM Trace Points for Test Mode (EDR) '. Range: 0 % to 100 % , Unit: %"""
+			:return: devm: float N DEVM results, depending on the packet type and payload length. Range: 0 % to 100 % , Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:DEVMagnitude:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:DEVMagnitude:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/DevMagnitude_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/DevMagnitude/Current.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:DEVMagnitude:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.devMagnitude.maximum.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:DEVMagnitude:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.trace.devMagnitude.current.fetch() \n
 		Returns the values of the DEVM traces. The results of the current, average minimum and maximum traces can be retrieved.
 		The DEVM traces are available for EDR bursts (method RsCmwBluetoothMeas.Configure.InputSignal.btype EDR) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: devm: float m DEVM results, depending on the packet type and payload length; see 'DEVM Trace Points for Test Mode (EDR) '. Range: 0 % to 100 % , Unit: %"""
+			:return: devm: float N DEVM results, depending on the packet type and payload length. Range: 0 % to 100 % , Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:DEVMagnitude:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:DEVMagnitude:CURRent?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:DEVMagnitude:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.devMagnitude.maximum.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:DEVMagnitude:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.trace.devMagnitude.current.read() \n
 		Returns the values of the DEVM traces. The results of the current, average minimum and maximum traces can be retrieved.
 		The DEVM traces are available for EDR bursts (method RsCmwBluetoothMeas.Configure.InputSignal.btype EDR) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: devm: float m DEVM results, depending on the packet type and payload length; see 'DEVM Trace Points for Test Mode (EDR) '. Range: 0 % to 100 % , Unit: %"""
+			:return: devm: float N DEVM results, depending on the packet type and payload length. Range: 0 % to 100 % , Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:DEVMagnitude:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:DEVMagnitude:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Fdeviation.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Spower/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Fdeviation:
-	"""Fdeviation commands group definition. 8 total commands, 4 Sub-groups, 0 group commands"""
+class SpowerCls:
+	"""Spower commands group definition. 8 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("fdeviation", core, parent)
+		self._cmd_group = CommandsGroup("spower", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Fdeviation_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Fdeviation_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Fdeviation_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Fdeviation_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'Fdeviation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SpowerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Fdeviation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SpowerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Fdeviation_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Fdeviation/Current.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,37 +3,37 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.trace.fdeviation.average.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.trace.fdeviation.current.fetch() \n
 		Returns the values of the frequency deviation traces. The results of the current, average minimum and maximum traces can
-		be retrieved. The frequency deviation traces are available for BR and LE bursts (see method RsCmwBluetoothMeas.Configure.
-		InputSignal.btype) . \n
+		be retrieved. The frequency deviation traces are available for BR and LE bursts. See also 'PvT and frequency deviation
+		trace points (classic) ' and 'PvT and modulation trace points (LE) ' \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: freq_deviation: float m frequency deviation results, depending on the packet type and payload length; see 'PvT and Freq. Dev. Trace Points (Classic) ' and 'PvT and Modulation Trace Points (LE) '. Range: –2 MHz to 2 MHz , Unit: Hz"""
+			:return: freq_deviation: float m frequency deviation results, depending on the packet type and payload length Range: –2 MHz to 2 MHz , Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:CURRent?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.trace.fdeviation.average.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.trace.fdeviation.current.read() \n
 		Returns the values of the frequency deviation traces. The results of the current, average minimum and maximum traces can
-		be retrieved. The frequency deviation traces are available for BR and LE bursts (see method RsCmwBluetoothMeas.Configure.
-		InputSignal.btype) . \n
+		be retrieved. The frequency deviation traces are available for BR and LE bursts. See also 'PvT and frequency deviation
+		trace points (classic) ' and 'PvT and modulation trace points (LE) ' \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: freq_deviation: float m frequency deviation results, depending on the packet type and payload length; see 'PvT and Freq. Dev. Trace Points (Classic) ' and 'PvT and Modulation Trace Points (LE) '. Range: –2 MHz to 2 MHz , Unit: Hz"""
+			:return: freq_deviation: float m frequency deviation results, depending on the packet type and payload length Range: –2 MHz to 2 MHz , Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Fdeviation_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/PowerVsTime/Average.py`

 * *Files 20% similar despite different names*

```diff
@@ -3,37 +3,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.trace.fdeviation.current.fetch() \n
-		Returns the values of the frequency deviation traces. The results of the current, average minimum and maximum traces can
-		be retrieved. The frequency deviation traces are available for BR and LE bursts (see method RsCmwBluetoothMeas.Configure.
-		InputSignal.btype) . \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.trace.powerVsTime.average.fetch() \n
+		Returns the values of the power vs time traces. The results of the current, average minimum and maximum traces can be
+		retrieved. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: freq_deviation: float m frequency deviation results, depending on the packet type and payload length; see 'PvT and Freq. Dev. Trace Points (Classic) ' and 'PvT and Modulation Trace Points (LE) '. Range: –2 MHz to 2 MHz , Unit: Hz"""
+			:return: power_vs_time: float N power results, depending on the packet type and payload length; see 'PvT and frequency deviation trace points (classic) ', 'DEVM trace points for test mode (EDR) ' and 'PvT and modulation trace points (LE) '. Range: –128.0 dBm to 30.0 dBm , Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:AVERage?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.trace.fdeviation.current.read() \n
-		Returns the values of the frequency deviation traces. The results of the current, average minimum and maximum traces can
-		be retrieved. The frequency deviation traces are available for BR and LE bursts (see method RsCmwBluetoothMeas.Configure.
-		InputSignal.btype) . \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.trace.powerVsTime.average.read() \n
+		Returns the values of the power vs time traces. The results of the current, average minimum and maximum traces can be
+		retrieved. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: freq_deviation: float m frequency deviation results, depending on the packet type and payload length; see 'PvT and Freq. Dev. Trace Points (Classic) ' and 'PvT and Modulation Trace Points (LE) '. Range: –2 MHz to 2 MHz , Unit: Hz"""
+			:return: power_vs_time: float N power results, depending on the packet type and payload length; see 'PvT and frequency deviation trace points (classic) ', 'DEVM trace points for test mode (EDR) ' and 'PvT and modulation trace points (LE) '. Range: –128.0 dBm to 30.0 dBm , Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:AVERage?', suppressed)
 		return response
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Fdeviation_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Fdeviation/Minimum.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,37 +3,37 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.fdeviation.maximum.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:MINimum \n
+		Snippet: value: List[float] = driver.multiEval.trace.fdeviation.minimum.fetch() \n
 		Returns the values of the frequency deviation traces. The results of the current, average minimum and maximum traces can
-		be retrieved. The frequency deviation traces are available for BR and LE bursts (see method RsCmwBluetoothMeas.Configure.
-		InputSignal.btype) . \n
+		be retrieved. The frequency deviation traces are available for BR and LE bursts. See also 'PvT and frequency deviation
+		trace points (classic) ' and 'PvT and modulation trace points (LE) ' \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: freq_deviation: float m frequency deviation results, depending on the packet type and payload length; see 'PvT and Freq. Dev. Trace Points (Classic) ' and 'PvT and Modulation Trace Points (LE) '. Range: –2 MHz to 2 MHz , Unit: Hz"""
+			:return: freq_deviation: float m frequency deviation results, depending on the packet type and payload length Range: –2 MHz to 2 MHz , Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:MINimum?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.fdeviation.maximum.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:MINimum \n
+		Snippet: value: List[float] = driver.multiEval.trace.fdeviation.minimum.read() \n
 		Returns the values of the frequency deviation traces. The results of the current, average minimum and maximum traces can
-		be retrieved. The frequency deviation traces are available for BR and LE bursts (see method RsCmwBluetoothMeas.Configure.
-		InputSignal.btype) . \n
+		be retrieved. The frequency deviation traces are available for BR and LE bursts. See also 'PvT and frequency deviation
+		trace points (classic) ' and 'PvT and modulation trace points (LE) ' \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: freq_deviation: float m frequency deviation results, depending on the packet type and payload length; see 'PvT and Freq. Dev. Trace Points (Classic) ' and 'PvT and Modulation Trace Points (LE) '. Range: –2 MHz to 2 MHz , Unit: Hz"""
+			:return: freq_deviation: float m frequency deviation results, depending on the packet type and payload length Range: –2 MHz to 2 MHz , Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:MINimum?', suppressed)
 		return response
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Fdeviation_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Fdeviation/Average.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,37 +3,37 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.fdeviation.minimum.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.trace.fdeviation.average.fetch() \n
 		Returns the values of the frequency deviation traces. The results of the current, average minimum and maximum traces can
-		be retrieved. The frequency deviation traces are available for BR and LE bursts (see method RsCmwBluetoothMeas.Configure.
-		InputSignal.btype) . \n
+		be retrieved. The frequency deviation traces are available for BR and LE bursts. See also 'PvT and frequency deviation
+		trace points (classic) ' and 'PvT and modulation trace points (LE) ' \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: freq_deviation: float m frequency deviation results, depending on the packet type and payload length; see 'PvT and Freq. Dev. Trace Points (Classic) ' and 'PvT and Modulation Trace Points (LE) '. Range: –2 MHz to 2 MHz , Unit: Hz"""
+			:return: freq_deviation: float m frequency deviation results, depending on the packet type and payload length Range: –2 MHz to 2 MHz , Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:AVERage?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.fdeviation.minimum.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.trace.fdeviation.average.read() \n
 		Returns the values of the frequency deviation traces. The results of the current, average minimum and maximum traces can
-		be retrieved. The frequency deviation traces are available for BR and LE bursts (see method RsCmwBluetoothMeas.Configure.
-		InputSignal.btype) . \n
+		be retrieved. The frequency deviation traces are available for BR and LE bursts. See also 'PvT and frequency deviation
+		trace points (classic) ' and 'PvT and modulation trace points (LE) ' \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: freq_deviation: float m frequency deviation results, depending on the packet type and payload length; see 'PvT and Freq. Dev. Trace Points (Classic) ' and 'PvT and Modulation Trace Points (LE) '. Range: –2 MHz to 2 MHz , Unit: Hz"""
+			:return: freq_deviation: float m frequency deviation results, depending on the packet type and payload length Range: –2 MHz to 2 MHz , Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FDEViation:AVERage?', suppressed)
 		return response
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Frange.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/MultiEval/Sacp/LowEnergy/Le2M/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Frange:
-	"""Frange commands group definition. 2 total commands, 1 Sub-groups, 0 group commands"""
+class Le2MCls:
+	"""Le2M commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("frange", core, parent)
+		self._cmd_group = CommandsGroup("le2M", core, parent)
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .Frange_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def measurement(self):
+		"""measurement commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_measurement'):
+			from .Measurement import MeasurementCls
+			self._measurement = MeasurementCls(self._core, self._cmd_group)
+		return self._measurement
 
-	def clone(self) -> 'Frange':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'Le2MCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Frange(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = Le2MCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Frange_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Frange/Average.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:FRANge:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.trace.frange.average.read() \n
 		Returns the average values of the 'Frequency Range' trace. The values are available for BR packets. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
 			:return: frequency_range: float RX signal level measured at the frequencies between 501 pixels (502 values) Range: -100 dBm to 42 dBm , Unit: dBm"""
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/IqAbs.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/IqDifference.py`

 * *Files 15% similar despite different names*

```diff
@@ -4,48 +4,48 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.Types import DataType
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class IqAbs:
-	"""IqAbs commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class IqDifferenceCls:
+	"""IqDifference commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("iqAbs", core, parent)
+		self._cmd_group = CommandsGroup("iqDifference", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Iphase: List[float]: float
-			- Qphase: List[float]: float"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Iphase: List[float]: float N in-phase amplitudes (IPhase) and N quadrature-phase (QPhase) amplitudes, where N is equal to the number of processed 50-symbol blocks; see 'Trace points for IQ constellation diagrams (EDR) '. Range: -2 to 2
+			- Qphase: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Iphase', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Qphase', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Iphase: List[float] = None
 			self.Qphase: List[float] = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:IQABs \n
-		Snippet: value: ResultData = driver.multiEval.trace.iqAbs.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:IQDiff \n
+		Snippet: value: ResultData = driver.multiEval.trace.iqDifference.read() \n
 		Returns the values of the traces in the I/Q constellation diagrams. The mnemonics IQABs, IQDiff, and IQERr denote the
 		absolute, differential and I/Q constellation error results. The I/Q traces are available for EDR packets (method
 		RsCmwBluetoothMeas.Configure.InputSignal.btype EDR) . \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:IQABs?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:IQDiff?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:IQABs \n
-		Snippet: value: ResultData = driver.multiEval.trace.iqAbs.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:IQDiff \n
+		Snippet: value: ResultData = driver.multiEval.trace.iqDifference.fetch() \n
 		Returns the values of the traces in the I/Q constellation diagrams. The mnemonics IQABs, IQDiff, and IQERr denote the
 		absolute, differential and I/Q constellation error results. The I/Q traces are available for EDR packets (method
 		RsCmwBluetoothMeas.Configure.InputSignal.btype EDR) . \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:IQABs?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:IQDiff?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/IqDifference.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/IqOffset.py`

 * *Files 23% similar despite different names*

```diff
@@ -4,48 +4,44 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.Types import DataType
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class IqDifference:
-	"""IqDifference commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class IqOffsetCls:
+	"""IqOffset commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("iqDifference", core, parent)
+		self._cmd_group = CommandsGroup("iqOffset", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Iphase: List[float]: float
-			- Qphase: List[float]: float"""
+			- Reliability: int: No parameter help available
+			- Iphase: List[float]: No parameter help available
+			- Qphase: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Iphase', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Qphase', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Iphase: List[float] = None
 			self.Qphase: List[float] = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:IQDiff \n
-		Snippet: value: ResultData = driver.multiEval.trace.iqDifference.read() \n
-		Returns the values of the traces in the I/Q constellation diagrams. The mnemonics IQABs, IQDiff, and IQERr denote the
-		absolute, differential and I/Q constellation error results. The I/Q traces are available for EDR packets (method
-		RsCmwBluetoothMeas.Configure.InputSignal.btype EDR) . \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:HDRP:TRACe:IQOFfset \n
+		Snippet: value: ResultData = driver.hdrp.trace.iqOffset.read() \n
+		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:IQDiff?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:BLUetooth:MEASurement<Instance>:HDRP:TRACe:IQOFfset?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:IQDiff \n
-		Snippet: value: ResultData = driver.multiEval.trace.iqDifference.fetch() \n
-		Returns the values of the traces in the I/Q constellation diagrams. The mnemonics IQABs, IQDiff, and IQERr denote the
-		absolute, differential and I/Q constellation error results. The I/Q traces are available for EDR packets (method
-		RsCmwBluetoothMeas.Configure.InputSignal.btype EDR) . \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:HDRP:TRACe:IQOFfset \n
+		Snippet: value: ResultData = driver.hdrp.trace.iqOffset.fetch() \n
+		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:IQDiff?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:HDRP:TRACe:IQOFfset?', self.__class__.ResultData())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/IqError.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/IqError.py`

 * *Files 18% similar despite different names*

```diff
@@ -4,27 +4,27 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.Types import DataType
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class IqError:
-	"""IqError commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class IqErrorCls:
+	"""IqError commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("iqError", core, parent)
+		self._cmd_group = CommandsGroup("iqError", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Iphase: List[float]: float
-			- Qphase: List[float]: float"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Iphase: List[float]: float N in-phase amplitudes (IPhase) and N quadrature-phase (QPhase) amplitudes, where N is equal to the number of processed 50-symbol blocks; see 'Trace points for IQ constellation diagrams (EDR) '. Range: -2 to 2
+			- Qphase: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Iphase', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Qphase', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Pdeviation.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdr/Pencoding/Ssequence/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pdeviation:
-	"""Pdeviation commands group definition. 6 total commands, 2 Sub-groups, 0 group commands"""
+class SsequenceCls:
+	"""Ssequence commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pdeviation", core, parent)
+		self._cmd_group = CommandsGroup("ssequence", core, parent)
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Pdeviation_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
+	def current(self):
+		"""current commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
 
-	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Pdeviation_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
-
-	def clone(self) -> 'Pdeviation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SsequenceCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pdeviation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SsequenceCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Pdeviation_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Pdeviation/Maximum.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,22 +1,23 @@
 from typing import List
 
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDEViation:MAXimum \n
 		Snippet: value: List[float] = driver.multiEval.trace.pdeviation.maximum.fetch() \n
 		Returns the results of power deviation per slot for LE CTE traces. Deviation value is calculated as peak to average power
 		ratio. The results of the minimum and maximum traces can be retrieved. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
@@ -34,18 +35,18 @@
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
 			:return: power_vs_slot: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDEViation:MAXimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDEViation:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.pdeviation.maximum.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.trace.pdeviation.maximum.calculate() \n
 		Returns the results of power deviation per slot for LE CTE traces. Deviation value is calculated as peak to average power
 		ratio. The results of the minimum and maximum traces can be retrieved. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_vs_slot: No help available"""
+			:return: power_vs_slot: (float or boolean items) No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDEViation:MAXimum?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDEViation:MAXimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Pdeviation_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Pdeviation/Minimum.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,22 +1,23 @@
 from typing import List
 
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDEViation:MINimum \n
 		Snippet: value: List[float] = driver.multiEval.trace.pdeviation.minimum.fetch() \n
 		Returns the results of power deviation per slot for LE CTE traces. Deviation value is calculated as peak to average power
 		ratio. The results of the minimum and maximum traces can be retrieved. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
@@ -34,18 +35,18 @@
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
 			:return: power_vs_slot: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDEViation:MINimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDEViation:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.pdeviation.minimum.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.trace.pdeviation.minimum.calculate() \n
 		Returns the results of power deviation per slot for LE CTE traces. Deviation value is calculated as peak to average power
 		ratio. The results of the minimum and maximum traces can be retrieved. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_vs_slot: No help available"""
+			:return: power_vs_slot: (float or boolean items) No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDEViation:MINimum?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDEViation:MINimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Pdifference.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Pdifference/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pdifference:
-	"""Pdifference commands group definition. 6 total commands, 3 Sub-groups, 0 group commands"""
+class PdifferenceCls:
+	"""Pdifference commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pdifference", core, parent)
+		self._cmd_group = CommandsGroup("pdifference", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Pdifference_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Pdifference_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Pdifference_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'Pdifference':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PdifferenceCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pdifference(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PdifferenceCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Pdifference_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Pdifference/Average.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,37 +3,37 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDIFference:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.trace.pdifference.average.fetch() \n
 		Returns the values of the phase difference traces. The results of the current, average minimum and maximum traces can be
 		retrieved. The phase difference traces are available for EDR bursts (method RsCmwBluetoothMeas.Configure.InputSignal.
 		btype EDR) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: phase_difference: float m phase difference results, depending on the packet type and payload length; see 'Phase Difference Trace Points (EDR) '. Range: –1.00 rad/π to 1.00 rad/π , Unit: rad/π"""
+			:return: phase_difference: float N phase difference results, depending on the packet type and payload length; see 'Phase difference trace points (EDR) '. Range: –1.00 rad/π to 1.00 rad/π , Unit: rad/π"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDIFference:AVERage?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDIFference:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.trace.pdifference.average.read() \n
 		Returns the values of the phase difference traces. The results of the current, average minimum and maximum traces can be
 		retrieved. The phase difference traces are available for EDR bursts (method RsCmwBluetoothMeas.Configure.InputSignal.
 		btype EDR) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: phase_difference: float m phase difference results, depending on the packet type and payload length; see 'Phase Difference Trace Points (EDR) '. Range: –1.00 rad/π to 1.00 rad/π , Unit: rad/π"""
+			:return: phase_difference: float N phase difference results, depending on the packet type and payload length; see 'Phase difference trace points (EDR) '. Range: –1.00 rad/π to 1.00 rad/π , Unit: rad/π"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDIFference:AVERage?', suppressed)
 		return response
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Pdifference_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Pdifference/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,37 +3,37 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDIFference:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.trace.pdifference.current.fetch() \n
 		Returns the values of the phase difference traces. The results of the current, average minimum and maximum traces can be
 		retrieved. The phase difference traces are available for EDR bursts (method RsCmwBluetoothMeas.Configure.InputSignal.
 		btype EDR) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: phase_difference: float m phase difference results, depending on the packet type and payload length; see 'Phase Difference Trace Points (EDR) '. Range: –1.00 rad/π to 1.00 rad/π , Unit: rad/π"""
+			:return: phase_difference: float N phase difference results, depending on the packet type and payload length; see 'Phase difference trace points (EDR) '. Range: –1.00 rad/π to 1.00 rad/π , Unit: rad/π"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDIFference:CURRent?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDIFference:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.trace.pdifference.current.read() \n
 		Returns the values of the phase difference traces. The results of the current, average minimum and maximum traces can be
 		retrieved. The phase difference traces are available for EDR bursts (method RsCmwBluetoothMeas.Configure.InputSignal.
 		btype EDR) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: phase_difference: float m phase difference results, depending on the packet type and payload length; see 'Phase Difference Trace Points (EDR) '. Range: –1.00 rad/π to 1.00 rad/π , Unit: rad/π"""
+			:return: phase_difference: float N phase difference results, depending on the packet type and payload length; see 'Phase difference trace points (EDR) '. Range: –1.00 rad/π to 1.00 rad/π , Unit: rad/π"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDIFference:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Pdifference_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Pdifference/Maximum.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,37 +3,37 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDIFference:MAXimum \n
 		Snippet: value: List[float] = driver.multiEval.trace.pdifference.maximum.fetch() \n
 		Returns the values of the phase difference traces. The results of the current, average minimum and maximum traces can be
 		retrieved. The phase difference traces are available for EDR bursts (method RsCmwBluetoothMeas.Configure.InputSignal.
 		btype EDR) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: phase_difference: float m phase difference results, depending on the packet type and payload length; see 'Phase Difference Trace Points (EDR) '. Range: –1.00 rad/π to 1.00 rad/π , Unit: rad/π"""
+			:return: phase_difference: float N phase difference results, depending on the packet type and payload length; see 'Phase difference trace points (EDR) '. Range: –1.00 rad/π to 1.00 rad/π , Unit: rad/π"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDIFference:MAXimum?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDIFference:MAXimum \n
 		Snippet: value: List[float] = driver.multiEval.trace.pdifference.maximum.read() \n
 		Returns the values of the phase difference traces. The results of the current, average minimum and maximum traces can be
 		retrieved. The phase difference traces are available for EDR bursts (method RsCmwBluetoothMeas.Configure.InputSignal.
 		btype EDR) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: phase_difference: float m phase difference results, depending on the packet type and payload length; see 'Phase Difference Trace Points (EDR) '. Range: –1.00 rad/π to 1.00 rad/π , Unit: rad/π"""
+			:return: phase_difference: float N phase difference results, depending on the packet type and payload length; see 'Phase difference trace points (EDR) '. Range: –1.00 rad/π to 1.00 rad/π , Unit: rad/π"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PDIFference:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/PowerVsTime.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/SoBw/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,51 +1,43 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class PowerVsTime:
-	"""PowerVsTime commands group definition. 8 total commands, 4 Sub-groups, 0 group commands"""
+class SoBwCls:
+	"""SoBw commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("powerVsTime", core, parent)
+		self._cmd_group = CommandsGroup("soBw", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .PowerVsTime_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .PowerVsTime_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_minimum'):
-			from .PowerVsTime_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
-
-	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .PowerVsTime_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'PowerVsTime':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SoBwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = PowerVsTime(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SoBwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/PowerVsTime_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/PowerVsTime/Maximum.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.trace.powerVsTime.average.fetch() \n
-		Returns the values of the power vs. time traces. The results of the current, average minimum and maximum traces can be
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:MAXimum \n
+		Snippet: value: List[float] = driver.multiEval.trace.powerVsTime.maximum.fetch() \n
+		Returns the values of the power vs time traces. The results of the current, average minimum and maximum traces can be
 		retrieved. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_vs_time: float M power results, depending on the packet type and payload length; see 'PvT and Freq. Dev. Trace Points (Classic) ', 'DEVM Trace Points for Test Mode (EDR) ' and 'PvT and Modulation Trace Points (LE) '. Range: –128.0 dBm to 30.0 dBm , Unit: dBm"""
+			:return: power_vs_time: float N power results, depending on the packet type and payload length; see 'PvT and frequency deviation trace points (classic) ', 'DEVM trace points for test mode (EDR) ' and 'PvT and modulation trace points (LE) '. Range: –128.0 dBm to 30.0 dBm , Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:MAXimum?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.trace.powerVsTime.average.read() \n
-		Returns the values of the power vs. time traces. The results of the current, average minimum and maximum traces can be
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:MAXimum \n
+		Snippet: value: List[float] = driver.multiEval.trace.powerVsTime.maximum.read() \n
+		Returns the values of the power vs time traces. The results of the current, average minimum and maximum traces can be
 		retrieved. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_vs_time: float M power results, depending on the packet type and payload length; see 'PvT and Freq. Dev. Trace Points (Classic) ', 'DEVM Trace Points for Test Mode (EDR) ' and 'PvT and Modulation Trace Points (LE) '. Range: –128.0 dBm to 30.0 dBm , Unit: dBm"""
+			:return: power_vs_time: float N power results, depending on the packet type and payload length; see 'PvT and frequency deviation trace points (classic) ', 'DEVM trace points for test mode (EDR) ' and 'PvT and modulation trace points (LE) '. Range: –128.0 dBm to 30.0 dBm , Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/PowerVsTime_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/PowerVsTime/Current.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.trace.powerVsTime.current.fetch() \n
-		Returns the values of the power vs. time traces. The results of the current, average minimum and maximum traces can be
+		Returns the values of the power vs time traces. The results of the current, average minimum and maximum traces can be
 		retrieved. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_vs_time: float M power results, depending on the packet type and payload length; see 'PvT and Freq. Dev. Trace Points (Classic) ', 'DEVM Trace Points for Test Mode (EDR) ' and 'PvT and Modulation Trace Points (LE) '. Range: –128.0 dBm to 30.0 dBm , Unit: dBm"""
+			:return: power_vs_time: float N power results, depending on the packet type and payload length; see 'PvT and frequency deviation trace points (classic) ', 'DEVM trace points for test mode (EDR) ' and 'PvT and modulation trace points (LE) '. Range: –128.0 dBm to 30.0 dBm , Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:CURRent?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.trace.powerVsTime.current.read() \n
-		Returns the values of the power vs. time traces. The results of the current, average minimum and maximum traces can be
+		Returns the values of the power vs time traces. The results of the current, average minimum and maximum traces can be
 		retrieved. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_vs_time: float M power results, depending on the packet type and payload length; see 'PvT and Freq. Dev. Trace Points (Classic) ', 'DEVM Trace Points for Test Mode (EDR) ' and 'PvT and Modulation Trace Points (LE) '. Range: –128.0 dBm to 30.0 dBm , Unit: dBm"""
+			:return: power_vs_time: float N power results, depending on the packet type and payload length; see 'PvT and frequency deviation trace points (classic) ', 'DEVM trace points for test mode (EDR) ' and 'PvT and modulation trace points (LE) '. Range: –128.0 dBm to 30.0 dBm , Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/PowerVsTime_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/PowerVsTime/Minimum.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.powerVsTime.maximum.fetch() \n
-		Returns the values of the power vs. time traces. The results of the current, average minimum and maximum traces can be
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:MINimum \n
+		Snippet: value: List[float] = driver.multiEval.trace.powerVsTime.minimum.fetch() \n
+		Returns the values of the power vs time traces. The results of the current, average minimum and maximum traces can be
 		retrieved. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_vs_time: float M power results, depending on the packet type and payload length; see 'PvT and Freq. Dev. Trace Points (Classic) ', 'DEVM Trace Points for Test Mode (EDR) ' and 'PvT and Modulation Trace Points (LE) '. Range: –128.0 dBm to 30.0 dBm , Unit: dBm"""
+			:return: power_vs_time: float N power results, depending on the packet type and payload length; see 'PvT and frequency deviation trace points (classic) ', 'DEVM trace points for test mode (EDR) ' and 'PvT and modulation trace points (LE) '. Range: –128.0 dBm to 30.0 dBm , Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:MINimum?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.powerVsTime.maximum.read() \n
-		Returns the values of the power vs. time traces. The results of the current, average minimum and maximum traces can be
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:MINimum \n
+		Snippet: value: List[float] = driver.multiEval.trace.powerVsTime.minimum.read() \n
+		Returns the values of the power vs time traces. The results of the current, average minimum and maximum traces can be
 		retrieved. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_vs_time: float M power results, depending on the packet type and payload length; see 'PvT and Freq. Dev. Trace Points (Classic) ', 'DEVM Trace Points for Test Mode (EDR) ' and 'PvT and Modulation Trace Points (LE) '. Range: –128.0 dBm to 30.0 dBm , Unit: dBm"""
+			:return: power_vs_time: float N power results, depending on the packet type and payload length; see 'PvT and frequency deviation trace points (classic) ', 'DEVM trace points for test mode (EDR) ' and 'PvT and modulation trace points (LE) '. Range: –128.0 dBm to 30.0 dBm , Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:MINimum?', suppressed)
 		return response
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/PowerVsTime_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Spower/Maximum.py`

 * *Files 15% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.powerVsTime.minimum.fetch() \n
-		Returns the values of the power vs. time traces. The results of the current, average minimum and maximum traces can be
-		retrieved. \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SPOWer:MAXimum \n
+		Snippet: value: List[float] = driver.multiEval.trace.spower.maximum.fetch() \n
+		Returns the results of the power per CTE slot for LE CTE traces. The results of the current, average, minimum and maximum
+		traces can be retrieved. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_vs_time: float M power results, depending on the packet type and payload length; see 'PvT and Freq. Dev. Trace Points (Classic) ', 'DEVM Trace Points for Test Mode (EDR) ' and 'PvT and Modulation Trace Points (LE) '. Range: –128.0 dBm to 30.0 dBm , Unit: dBm"""
+			:return: power_vs_slot: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SPOWer:MAXimum?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.powerVsTime.minimum.read() \n
-		Returns the values of the power vs. time traces. The results of the current, average minimum and maximum traces can be
-		retrieved. \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SPOWer:MAXimum \n
+		Snippet: value: List[float] = driver.multiEval.trace.spower.maximum.read() \n
+		Returns the results of the power per CTE slot for LE CTE traces. The results of the current, average, minimum and maximum
+		traces can be retrieved. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_vs_time: float M power results, depending on the packet type and payload length; see 'PvT and Freq. Dev. Trace Points (Classic) ', 'DEVM Trace Points for Test Mode (EDR) ' and 'PvT and Modulation Trace Points (LE) '. Range: –128.0 dBm to 30.0 dBm , Unit: dBm"""
+			:return: power_vs_slot: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:PVTime:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SPOWer:MAXimum?', suppressed)
 		return response
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sacp.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trigger/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,51 +1,43 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sacp:
-	"""Sacp commands group definition. 8 total commands, 4 Sub-groups, 0 group commands"""
+class TriggerCls:
+	"""Trigger commands group definition. 10 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sacp", core, parent)
+		self._cmd_group = CommandsGroup("trigger", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .Sacp_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def hdrp(self):
+		"""hdrp commands group. 1 Sub-classes, 3 commands."""
+		if not hasattr(self, '_hdrp'):
+			from .Hdrp import HdrpCls
+			self._hdrp = HdrpCls(self._core, self._cmd_group)
+		return self._hdrp
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .Sacp_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def hdr(self):
+		"""hdr commands group. 1 Sub-classes, 3 commands."""
+		if not hasattr(self, '_hdr'):
+			from .Hdr import HdrCls
+			self._hdr = HdrCls(self._core, self._cmd_group)
+		return self._hdr
 
 	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Sacp_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
+	def multiEval(self):
+		"""multiEval commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_multiEval'):
+			from .MultiEval import MultiEvalCls
+			self._multiEval = MultiEvalCls(self._core, self._cmd_group)
+		return self._multiEval
 
-	@property
-	def ptx(self):
-		"""ptx commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_ptx'):
-			from .Sacp_.Ptx import Ptx
-			self._ptx = Ptx(self._core, self._base)
-		return self._ptx
-
-	def clone(self) -> 'Sacp':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'TriggerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Sacp(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TriggerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sacp_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Sacp/Average.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,26 +3,25 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SACP:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.trace.sacp.average.read() \n
-		Returns the current, average and maximum values of the 'Spectrum ACP' traces for BR and LE packets.
-			INTRO_CMD_HELP: The number of returned values depends on the current burst type. \n
+			INTRO_CMD_HELP: Returns the current, average and maximum values of the 'Spectrum ACP' traces for BR and LE packets. The number of returned values depends on the current burst type. \n
 			- For BR bursts, the trace returns 79 values.The number of valid ACP results depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.Brate.Measurement.mode) :
 			Table Header:  \n
 			- In CH21 mode ('ACP +/- 10 Channels') , the first 21 ACP values contain results for the relative channels –10, ..., 0, ..., +10; the remaining 58 values are not displayed.
 			- In CH79 mode ('ACP 79 Channels') , valid ACP values are available for all 79 Bluetooth channels (2402 MHz, 2403 MHz, ..., 2480 MHz)
 			- For LE bursts, the trace returns 81 values.The number of valid ACP results
 		depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.LowEnergy.Le2M.Measurement.mode)
 		:
@@ -34,16 +33,15 @@
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SACP:AVERage?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SACP:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.trace.sacp.average.fetch() \n
-		Returns the current, average and maximum values of the 'Spectrum ACP' traces for BR and LE packets.
-			INTRO_CMD_HELP: The number of returned values depends on the current burst type. \n
+			INTRO_CMD_HELP: Returns the current, average and maximum values of the 'Spectrum ACP' traces for BR and LE packets. The number of returned values depends on the current burst type. \n
 			- For BR bursts, the trace returns 79 values.The number of valid ACP results depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.Brate.Measurement.mode) :
 			Table Header:  \n
 			- In CH21 mode ('ACP +/- 10 Channels') , the first 21 ACP values contain results for the relative channels –10, ..., 0, ..., +10; the remaining 58 values are not displayed.
 			- In CH79 mode ('ACP 79 Channels') , valid ACP values are available for all 79 Bluetooth channels (2402 MHz, 2403 MHz, ..., 2480 MHz)
 			- For LE bursts, the trace returns 81 values.The number of valid ACP results
 		depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.LowEnergy.Le2M.Measurement.mode)
 		:
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sacp_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Sacp/Current.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,26 +3,25 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SACP:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.trace.sacp.current.read() \n
-		Returns the current, average and maximum values of the 'Spectrum ACP' traces for BR and LE packets.
-			INTRO_CMD_HELP: The number of returned values depends on the current burst type. \n
+			INTRO_CMD_HELP: Returns the current, average and maximum values of the 'Spectrum ACP' traces for BR and LE packets. The number of returned values depends on the current burst type. \n
 			- For BR bursts, the trace returns 79 values.The number of valid ACP results depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.Brate.Measurement.mode) :
 			Table Header:  \n
 			- In CH21 mode ('ACP +/- 10 Channels') , the first 21 ACP values contain results for the relative channels –10, ..., 0, ..., +10; the remaining 58 values are not displayed.
 			- In CH79 mode ('ACP 79 Channels') , valid ACP values are available for all 79 Bluetooth channels (2402 MHz, 2403 MHz, ..., 2480 MHz)
 			- For LE bursts, the trace returns 81 values.The number of valid ACP results
 		depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.LowEnergy.Le2M.Measurement.mode)
 		:
@@ -34,16 +33,15 @@
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SACP:CURRent?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SACP:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.trace.sacp.current.fetch() \n
-		Returns the current, average and maximum values of the 'Spectrum ACP' traces for BR and LE packets.
-			INTRO_CMD_HELP: The number of returned values depends on the current burst type. \n
+			INTRO_CMD_HELP: Returns the current, average and maximum values of the 'Spectrum ACP' traces for BR and LE packets. The number of returned values depends on the current burst type. \n
 			- For BR bursts, the trace returns 79 values.The number of valid ACP results depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.Brate.Measurement.mode) :
 			Table Header:  \n
 			- In CH21 mode ('ACP +/- 10 Channels') , the first 21 ACP values contain results for the relative channels –10, ..., 0, ..., +10; the remaining 58 values are not displayed.
 			- In CH79 mode ('ACP 79 Channels') , valid ACP values are available for all 79 Bluetooth channels (2402 MHz, 2403 MHz, ..., 2480 MHz)
 			- For LE bursts, the trace returns 81 values.The number of valid ACP results
 		depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.LowEnergy.Le2M.Measurement.mode)
 		:
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sacp_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Sacp/Maximum.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,26 +3,25 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SACP:MAXimum \n
 		Snippet: value: List[float] = driver.multiEval.trace.sacp.maximum.read() \n
-		Returns the current, average and maximum values of the 'Spectrum ACP' traces for BR and LE packets.
-			INTRO_CMD_HELP: The number of returned values depends on the current burst type. \n
+			INTRO_CMD_HELP: Returns the current, average and maximum values of the 'Spectrum ACP' traces for BR and LE packets. The number of returned values depends on the current burst type. \n
 			- For BR bursts, the trace returns 79 values.The number of valid ACP results depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.Brate.Measurement.mode) :
 			Table Header:  \n
 			- In CH21 mode ('ACP +/- 10 Channels') , the first 21 ACP values contain results for the relative channels –10, ..., 0, ..., +10; the remaining 58 values are not displayed.
 			- In CH79 mode ('ACP 79 Channels') , valid ACP values are available for all 79 Bluetooth channels (2402 MHz, 2403 MHz, ..., 2480 MHz)
 			- For LE bursts, the trace returns 81 values.The number of valid ACP results
 		depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.LowEnergy.Le2M.Measurement.mode)
 		:
@@ -34,16 +33,15 @@
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SACP:MAXimum?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SACP:MAXimum \n
 		Snippet: value: List[float] = driver.multiEval.trace.sacp.maximum.fetch() \n
-		Returns the current, average and maximum values of the 'Spectrum ACP' traces for BR and LE packets.
-			INTRO_CMD_HELP: The number of returned values depends on the current burst type. \n
+			INTRO_CMD_HELP: Returns the current, average and maximum values of the 'Spectrum ACP' traces for BR and LE packets. The number of returned values depends on the current burst type. \n
 			- For BR bursts, the trace returns 79 values.The number of valid ACP results depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.Brate.Measurement.mode) :
 			Table Header:  \n
 			- In CH21 mode ('ACP +/- 10 Channels') , the first 21 ACP values contain results for the relative channels –10, ..., 0, ..., +10; the remaining 58 values are not displayed.
 			- In CH79 mode ('ACP 79 Channels') , valid ACP values are available for all 79 Bluetooth channels (2402 MHz, 2403 MHz, ..., 2480 MHz)
 			- For LE bursts, the trace returns 81 values.The number of valid ACP results
 		depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.LowEnergy.Le2M.Measurement.mode)
 		:
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sacp_/Ptx.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Sacp/Ptx.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,55 +3,53 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ptx:
-	"""Ptx commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class PtxCls:
+	"""Ptx commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ptx", core, parent)
+		self._cmd_group = CommandsGroup("ptx", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SACP[:PTX] \n
 		Snippet: value: List[float] = driver.multiEval.trace.sacp.ptx.fetch() \n
-		Returns the values of the 'Spectrum ACP' table for BR and LE packets in line with Bluetooth test specification.
-			INTRO_CMD_HELP: Note that the number of returned values depends on the current burst type. \n
+			INTRO_CMD_HELP: Returns the results of the 'Spectrum ACP' table for BR and LE packets in line with Bluetooth test specification. Note that the number of returned values depends on the current burst type. \n
 			- For BR bursts, the trace returns 79 values.The number of valid ACP results depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.Brate.Measurement.mode) :
 			Table Header:  \n
 			- In CH21 mode, the first 21 ACP values contain results for the relative channels –10, ..., 0, ..., +10; the remaining 58 values are not displayed.
 			- In CH79 mode, valid ACP values are available for all 79 Bluetooth channels (2402 MHz, 2403 MHz, ..., 2480 MHz)
 			- For LE bursts, the trace returns 81 values.The number of valid ACP results
 		depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.LowEnergy.Le2M.Measurement.mode)
 		:
 			Table Header:  \n
 			- In CH10 ('ACP +/- 5 Channels') mode, the first 21 ACP values contain results for the 1 MHz channels centered at fTX – 10 MHz, fTX – 9 MHz, ..., fTX + 10 MHz. The remaining 58 values are invalid (NAV) . This mode is applicable to all types of LE bursts.
 			- In CH40 mode ('LE All Channels') , ACP values 1 to 81 contain results for the 1 MHz channels centered at 2401 MHz, 2402 MHz, ..., 2481 MHz This mode is only applicable to test packets using LE 1M PHY or LE 2M PHY. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: acp: float As explained above, for BR bursts the trace returns N=79, and for LE bursts it returns N=81 values. Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			:return: acp: float As explained above, for BR bursts the trace returns 79, and for LE bursts it returns 81 values. Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SACP:PTX?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SACP[:PTX] \n
 		Snippet: value: List[float] = driver.multiEval.trace.sacp.ptx.read() \n
-		Returns the values of the 'Spectrum ACP' table for BR and LE packets in line with Bluetooth test specification.
-			INTRO_CMD_HELP: Note that the number of returned values depends on the current burst type. \n
+			INTRO_CMD_HELP: Returns the results of the 'Spectrum ACP' table for BR and LE packets in line with Bluetooth test specification. Note that the number of returned values depends on the current burst type. \n
 			- For BR bursts, the trace returns 79 values.The number of valid ACP results depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.Brate.Measurement.mode) :
 			Table Header:  \n
 			- In CH21 mode, the first 21 ACP values contain results for the relative channels –10, ..., 0, ..., +10; the remaining 58 values are not displayed.
 			- In CH79 mode, valid ACP values are available for all 79 Bluetooth channels (2402 MHz, 2403 MHz, ..., 2480 MHz)
 			- For LE bursts, the trace returns 81 values.The number of valid ACP results
 		depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.LowEnergy.Le2M.Measurement.mode)
 		:
 			Table Header:  \n
 			- In CH10 ('ACP +/- 5 Channels') mode, the first 21 ACP values contain results for the 1 MHz channels centered at fTX – 10 MHz, fTX – 9 MHz, ..., fTX + 10 MHz. The remaining 58 values are invalid (NAV) . This mode is applicable to all types of LE bursts.
 			- In CH40 mode ('LE All Channels') , ACP values 1 to 81 contain results for the 1 MHz channels centered at 2401 MHz, 2402 MHz, ..., 2481 MHz This mode is only applicable to test packets using LE 1M PHY or LE 2M PHY. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: acp: float As explained above, for BR bursts the trace returns N=79, and for LE bursts it returns N=81 values. Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
+			:return: acp: float As explained above, for BR bursts the trace returns 79, and for LE bursts it returns 81 values. Range: -99.99 dBm to 99.99 dBm, Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SACP:PTX?', suppressed)
 		return response
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sgacp.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Plength/Qhsl/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,51 +1,59 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sgacp:
-	"""Sgacp commands group definition. 8 total commands, 4 Sub-groups, 0 group commands"""
+class QhslCls:
+	"""Qhsl commands group definition. 5 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sgacp", core, parent)
+		self._cmd_group = CommandsGroup("qhsl", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .Sgacp_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def p2Q(self):
+		"""p2Q commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_p2Q'):
+			from .P2Q import P2QCls
+			self._p2Q = P2QCls(self._core, self._cmd_group)
+		return self._p2Q
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .Sgacp_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def p3Q(self):
+		"""p3Q commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_p3Q'):
+			from .P3Q import P3QCls
+			self._p3Q = P3QCls(self._core, self._cmd_group)
+		return self._p3Q
 
 	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Sgacp_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
+	def p4Q(self):
+		"""p4Q commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_p4Q'):
+			from .P4Q import P4QCls
+			self._p4Q = P4QCls(self._core, self._cmd_group)
+		return self._p4Q
 
 	@property
-	def ptx(self):
-		"""ptx commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_ptx'):
-			from .Sgacp_.Ptx import Ptx
-			self._ptx = Ptx(self._core, self._base)
-		return self._ptx
+	def p5Q(self):
+		"""p5Q commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_p5Q'):
+			from .P5Q import P5QCls
+			self._p5Q = P5QCls(self._core, self._cmd_group)
+		return self._p5Q
 
-	def clone(self) -> 'Sgacp':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def p6Q(self):
+		"""p6Q commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_p6Q'):
+			from .P6Q import P6QCls
+			self._p6Q = P6QCls(self._core, self._cmd_group)
+		return self._p6Q
+
+	def clone(self) -> 'QhslCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Sgacp(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = QhslCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sgacp_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Sgacp/Average.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SGACp:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.trace.sgacp.average.fetch() \n
 		Returns the results of the 'Spectrum Gated ACP' traces for EDR packets. The R&S CMW measures the current, average and
 		maximum adjacent channel power values.
 			INTRO_CMD_HELP: The number of valid results depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sgacp.Edrate.Measurement.modeCH21 | CH79) : \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sgacp_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Sgacp/Current.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SGACp:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.trace.sgacp.current.fetch() \n
 		Returns the results of the 'Spectrum Gated ACP' traces for EDR packets. The R&S CMW measures the current, average and
 		maximum adjacent channel power values.
 			INTRO_CMD_HELP: The number of valid results depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sgacp.Edrate.Measurement.modeCH21 | CH79) : \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sgacp_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Sgacp/Maximum.py`

 * *Files 0% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SGACp:MAXimum \n
 		Snippet: value: List[float] = driver.multiEval.trace.sgacp.maximum.fetch() \n
 		Returns the results of the 'Spectrum Gated ACP' traces for EDR packets. The R&S CMW measures the current, average and
 		maximum adjacent channel power values.
 			INTRO_CMD_HELP: The number of valid results depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sgacp.Edrate.Measurement.modeCH21 | CH79) : \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Sgacp_/Ptx.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Sgacp/Ptx.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ptx:
-	"""Ptx commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class PtxCls:
+	"""Ptx commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ptx", core, parent)
+		self._cmd_group = CommandsGroup("ptx", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SGACp[:PTX] \n
 		Snippet: value: List[float] = driver.multiEval.trace.sgacp.ptx.fetch() \n
 		Returns the values of the 'Spectrum Gated ACP' tables for EDR packets. The R&S CMW measures the adjacent channel power
 		values PTX(f) in line with Bluetooth test specification.
 			INTRO_CMD_HELP: The number of valid results depends on the ACP measurement mode (method RsCmwBluetoothMeas.Configure.MultiEval.Sacp.Brate.Measurement.mode CH21 | CH79) : \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/SoBw.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Modulation/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,43 +1,51 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SoBw:
-	"""SoBw commands group definition. 6 total commands, 3 Sub-groups, 0 group commands"""
+class ModulationCls:
+	"""Modulation commands group definition. 12 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("soBw", core, parent)
+		self._cmd_group = CommandsGroup("modulation", core, parent)
+
+	@property
+	def standardDev(self):
+		"""standardDev commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_standardDev'):
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
+		return self._standardDev
+
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
+		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .SoBw_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
+		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .SoBw_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
-	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_maximum'):
-			from .SoBw_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
-
-	def clone(self) -> 'SoBw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ModulationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = SoBw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ModulationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/SoBw_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/SoBw/Average.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SOBW:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.trace.soBw.average.read() \n
 		Returns current, average and maximum results of the 'Spectrum 20 dB Bandwidth' trace. The 20 dB bandwidth values are
 		available for BR bursts (method RsCmwBluetoothMeas.Configure.InputSignal.btype) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/SoBw_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/SoBw/Current.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SOBW:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.trace.soBw.current.read() \n
 		Returns current, average and maximum results of the 'Spectrum 20 dB Bandwidth' trace. The 20 dB bandwidth values are
 		available for BR bursts (method RsCmwBluetoothMeas.Configure.InputSignal.btype) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/SoBw_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/SoBw/Maximum.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SOBW:MAXimum \n
 		Snippet: value: List[float] = driver.multiEval.trace.soBw.maximum.fetch() \n
 		Returns current, average and maximum results of the 'Spectrum 20 dB Bandwidth' trace. The 20 dB bandwidth values are
 		available for BR bursts (method RsCmwBluetoothMeas.Configure.InputSignal.btype) . \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Spower.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,59 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Spower:
-	"""Spower commands group definition. 8 total commands, 4 Sub-groups, 0 group commands"""
+class QhslCls:
+	"""Qhsl commands group definition. 10 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("spower", core, parent)
+		self._cmd_group = CommandsGroup("qhsl", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .Spower_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def p2Q(self):
+		"""p2Q commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_p2Q'):
+			from .P2Q import P2QCls
+			self._p2Q = P2QCls(self._core, self._cmd_group)
+		return self._p2Q
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .Spower_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def p3Q(self):
+		"""p3Q commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_p3Q'):
+			from .P3Q import P3QCls
+			self._p3Q = P3QCls(self._core, self._cmd_group)
+		return self._p3Q
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Spower_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
+	def p4Q(self):
+		"""p4Q commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_p4Q'):
+			from .P4Q import P4QCls
+			self._p4Q = P4QCls(self._core, self._cmd_group)
+		return self._p4Q
 
 	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Spower_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
+	def p5Q(self):
+		"""p5Q commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_p5Q'):
+			from .P5Q import P5QCls
+			self._p5Q = P5QCls(self._core, self._cmd_group)
+		return self._p5Q
 
-	def clone(self) -> 'Spower':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def p6Q(self):
+		"""p6Q commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_p6Q'):
+			from .P6Q import P6QCls
+			self._p6Q = P6QCls(self._core, self._cmd_group)
+		return self._p6Q
+
+	def clone(self) -> 'QhslCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Spower(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = QhslCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Spower_/Average.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Spower/Average.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SPOWer:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.trace.spower.average.fetch() \n
 		Returns the results of the power per CTE slot for LE CTE traces. The results of the current, average, minimum and maximum
 		traces can be retrieved. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Spower_/Current.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Spower/Current.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SPOWer:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.trace.spower.current.fetch() \n
 		Returns the results of the power per CTE slot for LE CTE traces. The results of the current, average, minimum and maximum
 		traces can be retrieved. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Spower_/Maximum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/MultiEval/Trace/Spower/Minimum.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SPOWer:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.spower.maximum.fetch() \n
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SPOWer:MINimum \n
+		Snippet: value: List[float] = driver.multiEval.trace.spower.minimum.fetch() \n
 		Returns the results of the power per CTE slot for LE CTE traces. The results of the current, average, minimum and maximum
 		traces can be retrieved. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
 			:return: power_vs_slot: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SPOWer:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SPOWer:MINimum?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SPOWer:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.spower.maximum.read() \n
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SPOWer:MINimum \n
+		Snippet: value: List[float] = driver.multiEval.trace.spower.minimum.read() \n
 		Returns the results of the power per CTE slot for LE CTE traces. The results of the current, average, minimum and maximum
 		traces can be retrieved. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
 			:return: power_vs_slot: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SPOWer:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SPOWer:MINimum?', suppressed)
 		return response
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/MultiEval_/Trace_/Spower_/Minimum.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Trace/PowerVsTime/Minimum.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,35 +3,33 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
-	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SPOWer:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.spower.minimum.fetch() \n
-		Returns the results of the power per CTE slot for LE CTE traces. The results of the current, average, minimum and maximum
-		traces can be retrieved. \n
+	def read(self) -> List[float]:
+		"""SCPI: READ:BLUetooth:MEASurement<Instance>:HDRP:TRACe:PVTime:MINimum \n
+		Snippet: value: List[float] = driver.hdrp.trace.powerVsTime.minimum.read() \n
+		No command help available \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_vs_slot: No help available"""
+			:return: pvt_trace: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SPOWer:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:HDRP:TRACe:PVTime:MINimum?', suppressed)
 		return response
 
-	def read(self) -> List[float]:
-		"""SCPI: READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SPOWer:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.spower.minimum.read() \n
-		Returns the results of the power per CTE slot for LE CTE traces. The results of the current, average, minimum and maximum
-		traces can be retrieved. \n
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:HDRP:TRACe:PVTime:MINimum \n
+		Snippet: value: List[float] = driver.hdrp.trace.powerVsTime.minimum.fetch() \n
+		No command help available \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_vs_slot: No help available"""
+			:return: pvt_trace: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:BLUetooth:MEASurement<Instance>:MEValuation:TRACe:SPOWer:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:HDRP:TRACe:PVTime:MINimum?', suppressed)
 		return response
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Route.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/RxQuality/Route/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,67 +1,66 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
-from ..Internal.StructBase import StructBase
-from ..Internal.ArgStruct import ArgStruct
-from .. import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Types import DataType
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
+from .....Internal.ArgSingleList import ArgSingleList
+from .....Internal.ArgSingle import ArgSingle
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Route:
-	"""Route commands group definition. 6 total commands, 2 Sub-groups, 1 group commands"""
+class RouteCls:
+	"""Route commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("route", core, parent)
+		self._cmd_group = CommandsGroup("route", core, parent)
 
 	@property
-	def scenario(self):
-		"""scenario commands group. 1 Sub-classes, 3 commands."""
-		if not hasattr(self, '_scenario'):
-			from .Route_.Scenario import Scenario
-			self._scenario = Scenario(self._core, self._base)
-		return self._scenario
-
-	@property
-	def rfSettings(self):
-		"""rfSettings commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_rfSettings'):
-			from .Route_.RfSettings import RfSettings
-			self._rfSettings = RfSettings(self._core, self._base)
-		return self._rfSettings
+	def usage(self):
+		"""usage commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_usage'):
+			from .Usage import UsageCls
+			self._usage = UsageCls(self._core, self._cmd_group)
+		return self._usage
+
+	def set(self, tx_connector: enums.TxConnector, rf_converter: enums.TxConverter) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:ROUTe \n
+		Snippet: driver.configure.rxQuality.route.set(tx_connector = enums.TxConnector.I12O, rf_converter = enums.TxConverter.ITX1) \n
+		Selects the RF output path for the RF signal generated using ARB files. For possible TX module values, see 'Values for RF
+		path selection'. \n
+			:param tx_connector: RF connector for the output path
+			:param rf_converter: TX module for the output path
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('tx_connector', tx_connector, DataType.Enum, enums.TxConnector), ArgSingle('rf_converter', rf_converter, DataType.Enum, enums.TxConverter))
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:ROUTe {param}'.rstrip())
 
 	# noinspection PyTypeChecker
-	class ValueStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Scenario: enums.TestScenario: SALone | CSPath SALone: standalone (non-signaling) CSPath: combined signal path
-			- Master: str: string Master application for scenario CSPath
-			- Rf_Connector: enums.RxConnector: RF connector for the input path
-			- Rf_Converter: enums.RxConverter: RX module for the input path"""
+	class RouteStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Tx_Connector: enums.TxConnector: RF connector for the output path
+			- Rf_Converter: enums.TxConverter: TX module for the output path"""
 		__meta_args_list = [
-			ArgStruct.scalar_enum('Scenario', enums.TestScenario),
-			ArgStruct.scalar_str('Master'),
-			ArgStruct.scalar_enum('Rf_Connector', enums.RxConnector),
-			ArgStruct.scalar_enum('Rf_Converter', enums.RxConverter)]
+			ArgStruct.scalar_enum('Tx_Connector', enums.TxConnector),
+			ArgStruct.scalar_enum('Rf_Converter', enums.TxConverter)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Scenario: enums.TestScenario = None
-			self.Master: str = None
-			self.Rf_Connector: enums.RxConnector = None
-			self.Rf_Converter: enums.RxConverter = None
+			self.Tx_Connector: enums.TxConnector = None
+			self.Rf_Converter: enums.TxConverter = None
 
-	# noinspection PyTypeChecker
-	def get_value(self) -> ValueStruct:
-		"""SCPI: ROUTe:BLUetooth:MEASurement<Instance> \n
-		Snippet: value: ValueStruct = driver.route.get_value() \n
-		Returns the configured routing settings. For possible connector and converter values, see 'Values for RF Path Selection'. \n
-			:return: structure: for return value, see the help for ValueStruct structure arguments.
-		"""
-		return self._core.io.query_struct('ROUTe:BLUetooth:MEASurement<Instance>?', self.__class__.ValueStruct())
+	def get(self) -> RouteStruct:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:ROUTe \n
+		Snippet: value: RouteStruct = driver.configure.rxQuality.route.get() \n
+		Selects the RF output path for the RF signal generated using ARB files. For possible TX module values, see 'Values for RF
+		path selection'. \n
+			:return: structure: for return value, see the help for RouteStruct structure arguments."""
+		return self._core.io.query_struct(f'CONFigure:BLUetooth:MEASurement<Instance>:RXQuality:ROUTe?', self.__class__.RouteStruct())
 
-	def clone(self) -> 'Route':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RouteCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Route(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RouteCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Route_/RfSettings.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Route/RfSettings.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,32 +1,32 @@
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal import Conversions
 from ... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RfSettings:
-	"""RfSettings commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RfSettingsCls:
+	"""RfSettings commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rfSettings", core, parent)
+		self._cmd_group = CommandsGroup("rfSettings", core, parent)
 
 	# noinspection PyTypeChecker
-	def get_connector(self) -> enums.RxConnector:
+	def get_connector(self) -> enums.RfConnector:
 		"""SCPI: ROUTe:BLUetooth:MEASurement<Instance>:RFSettings:CONNector \n
-		Snippet: value: enums.RxConnector = driver.route.rfSettings.get_connector() \n
+		Snippet: value: enums.RfConnector = driver.route.rfSettings.get_connector() \n
 		No command help available \n
 			:return: rf_input_con: No help available
 		"""
 		response = self._core.io.query_str('ROUTe:BLUetooth:MEASurement<Instance>:RFSettings:CONNector?')
-		return Conversions.str_to_scalar_enum(response, enums.RxConnector)
+		return Conversions.str_to_scalar_enum(response, enums.RfConnector)
 
-	def set_connector(self, rf_input_con: enums.RxConnector) -> None:
+	def set_connector(self, rf_input_con: enums.RfConnector) -> None:
 		"""SCPI: ROUTe:BLUetooth:MEASurement<Instance>:RFSettings:CONNector \n
-		Snippet: driver.route.rfSettings.set_connector(rf_input_con = enums.RxConnector.I11I) \n
+		Snippet: driver.route.rfSettings.set_connector(rf_input_con = enums.RfConnector.I11I) \n
 		No command help available \n
 			:param rf_input_con: No help available
 		"""
-		param = Conversions.enum_scalar_to_str(rf_input_con, enums.RxConnector)
+		param = Conversions.enum_scalar_to_str(rf_input_con, enums.RfConnector)
 		self._core.io.write(f'ROUTe:BLUetooth:MEASurement<Instance>:RFSettings:CONNector {param}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Route_/Scenario_/MaProtocol.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdr/Sgacp/Measurement.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,26 +1,32 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class MaProtocol:
-	"""MaProtocol commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MeasurementCls:
+	"""Measurement commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maProtocol", core, parent)
+		self._cmd_group = CommandsGroup("measurement", core, parent)
 
-	def set(self) -> None:
-		"""SCPI: ROUTe:BLUetooth:MEASurement<Instance>:SCENario:MAPRotocol \n
-		Snippet: driver.route.scenario.maProtocol.set() \n
+	# noinspection PyTypeChecker
+	def get_mode(self) -> enums.BrEdrChannelsRange:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:HDR:SGACp:MEASurement:MODE \n
+		Snippet: value: enums.BrEdrChannelsRange = driver.configure.hdr.sgacp.measurement.get_mode() \n
 		No command help available \n
+			:return: meas_mode: No help available
 		"""
-		self._core.io.write(f'ROUTe:BLUetooth:MEASurement<Instance>:SCENario:MAPRotocol')
+		response = self._core.io.query_str('CONFigure:BLUetooth:MEASurement<Instance>:HDR:SGACp:MEASurement:MODE?')
+		return Conversions.str_to_scalar_enum(response, enums.BrEdrChannelsRange)
 
-	def set_with_opc(self) -> None:
-		"""SCPI: ROUTe:BLUetooth:MEASurement<Instance>:SCENario:MAPRotocol \n
-		Snippet: driver.route.scenario.maProtocol.set_with_opc() \n
+	def set_mode(self, meas_mode: enums.BrEdrChannelsRange) -> None:
+		"""SCPI: CONFigure:BLUetooth:MEASurement<Instance>:HDR:SGACp:MEASurement:MODE \n
+		Snippet: driver.configure.hdr.sgacp.measurement.set_mode(meas_mode = enums.BrEdrChannelsRange.CH21) \n
 		No command help available \n
-		Same as set, but waits for the operation to complete before continuing further. Use the RsCmwBluetoothMeas.utilities.opc_timeout_set() to set the timeout value. \n
+			:param meas_mode: No help available
 		"""
-		self._core.io.write_with_opc(f'ROUTe:BLUetooth:MEASurement<Instance>:SCENario:MAPRotocol')
+		param = Conversions.enum_scalar_to_str(meas_mode, enums.BrEdrChannelsRange)
+		self._core.io.write(f'CONFigure:BLUetooth:MEASurement<Instance>:HDR:SGACp:MEASurement:MODE {param}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trx/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,128 +1,104 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RxQuality:
-	"""RxQuality commands group definition. 10 total commands, 5 Sub-groups, 3 group commands"""
+class TrxCls:
+	"""Trx commands group definition. 9 total commands, 5 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rxQuality", core, parent)
+		self._cmd_group = CommandsGroup("trx", core, parent)
 
 	@property
 	def state(self):
 		"""state commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_state'):
-			from .RxQuality_.State import State
-			self._state = State(self._core, self._base)
+			from .State import StateCls
+			self._state = StateCls(self._core, self._cmd_group)
 		return self._state
 
 	@property
-	def sensitivity(self):
-		"""sensitivity commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_sensitivity'):
-			from .RxQuality_.Sensitivity import Sensitivity
-			self._sensitivity = Sensitivity(self._core, self._base)
-		return self._sensitivity
+	def spot(self):
+		"""spot commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_spot'):
+			from .Spot import SpotCls
+			self._spot = SpotCls(self._core, self._cmd_group)
+		return self._spot
 
 	@property
-	def spotCheck(self):
-		"""spotCheck commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_spotCheck'):
-			from .RxQuality_.SpotCheck import SpotCheck
-			self._spotCheck = SpotCheck(self._core, self._base)
-		return self._spotCheck
+	def modulation(self):
+		"""modulation commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_modulation'):
+			from .Modulation import ModulationCls
+			self._modulation = ModulationCls(self._core, self._cmd_group)
+		return self._modulation
 
 	@property
-	def per(self):
-		"""per commands group. 1 Sub-classes, 1 commands."""
-		if not hasattr(self, '_per'):
-			from .RxQuality_.Per import Per
-			self._per = Per(self._core, self._base)
-		return self._per
+	def power(self):
+		"""power commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_power'):
+			from .Power import PowerCls
+			self._power = PowerCls(self._core, self._cmd_group)
+		return self._power
 
 	@property
-	def adetected(self):
-		"""adetected commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_adetected'):
-			from .RxQuality_.Adetected import Adetected
-			self._adetected = Adetected(self._core, self._base)
-		return self._adetected
-
-	def initiate(self) -> None:
-		"""SCPI: INITiate:BLUetooth:MEASurement<Instance>:RXQuality \n
-		Snippet: driver.rxQuality.initiate() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'INITiate:BLUetooth:MEASurement<Instance>:RXQuality')
+	def acp(self):
+		"""acp commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_acp'):
+			from .Acp import AcpCls
+			self._acp = AcpCls(self._core, self._cmd_group)
+		return self._acp
 
-	def initiate_with_opc(self) -> None:
-		"""SCPI: INITiate:BLUetooth:MEASurement<Instance>:RXQuality \n
-		Snippet: driver.rxQuality.initiate_with_opc() \n
+	def initiate(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: INITiate:BLUetooth:MEASurement<Instance>:TRX \n
+		Snippet: driver.trx.initiate() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		Same as initiate, but waits for the operation to complete before continuing further. Use the RsCmwBluetoothMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'INITiate:BLUetooth:MEASurement<Instance>:RXQuality')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'INITiate:BLUetooth:MEASurement<Instance>:TRX', opc_timeout_ms)
 
 	def stop(self) -> None:
-		"""SCPI: STOP:BLUetooth:MEASurement<Instance>:RXQuality \n
-		Snippet: driver.rxQuality.stop() \n
+		"""SCPI: STOP:BLUetooth:MEASurement<Instance>:TRX \n
+		Snippet: driver.trx.stop() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
 		"""
-		self._core.io.write(f'STOP:BLUetooth:MEASurement<Instance>:RXQuality')
+		self._core.io.write(f'STOP:BLUetooth:MEASurement<Instance>:TRX')
 
-	def stop_with_opc(self) -> None:
-		"""SCPI: STOP:BLUetooth:MEASurement<Instance>:RXQuality \n
-		Snippet: driver.rxQuality.stop_with_opc() \n
+	def stop_with_opc(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: STOP:BLUetooth:MEASurement<Instance>:TRX \n
+		Snippet: driver.trx.stop_with_opc() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
 		Same as stop, but waits for the operation to complete before continuing further. Use the RsCmwBluetoothMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'STOP:BLUetooth:MEASurement<Instance>:RXQuality')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'STOP:BLUetooth:MEASurement<Instance>:TRX', opc_timeout_ms)
 
-	def abort(self) -> None:
-		"""SCPI: ABORt:BLUetooth:MEASurement<Instance>:RXQuality \n
-		Snippet: driver.rxQuality.abort() \n
+	def abort(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: ABORt:BLUetooth:MEASurement<Instance>:TRX \n
+		Snippet: driver.trx.abort() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'ABORt:BLUetooth:MEASurement<Instance>:RXQuality')
-
-	def abort_with_opc(self) -> None:
-		"""SCPI: ABORt:BLUetooth:MEASurement<Instance>:RXQuality \n
-		Snippet: driver.rxQuality.abort_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		Same as abort, but waits for the operation to complete before continuing further. Use the RsCmwBluetoothMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'ABORt:BLUetooth:MEASurement<Instance>:RXQuality')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'ABORt:BLUetooth:MEASurement<Instance>:TRX', opc_timeout_ms)
 
-	def clone(self) -> 'RxQuality':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'TrxCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = RxQuality(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TrxCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/Adetected.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Diagnostic/Bluetooth/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Adetected:
-	"""Adetected commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class BluetoothCls:
+	"""Bluetooth commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("adetected", core, parent)
+		self._cmd_group = CommandsGroup("bluetooth", core, parent)
 
 	@property
-	def aaddress(self):
-		"""aaddress commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_aaddress'):
-			from .Adetected_.Aaddress import Aaddress
-			self._aaddress = Aaddress(self._core, self._base)
-		return self._aaddress
+	def synchronise(self):
+		"""synchronise commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_synchronise'):
+			from .Synchronise import SynchroniseCls
+			self._synchronise = SynchroniseCls(self._core, self._cmd_group)
+		return self._synchronise
 
-	def clone(self) -> 'Adetected':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'BluetoothCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Adetected(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = BluetoothCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/Adetected_/Aaddress.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/Adetected/Aaddress.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,20 +2,20 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 from ....Internal.Utilities import trim_str_response
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Aaddress:
-	"""Aaddress commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AaddressCls:
+	"""Aaddress commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("aaddress", core, parent)
+		self._cmd_group = CommandsGroup("aaddress", core, parent)
 
 	def fetch(self) -> str:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:RXQuality:ADETected:AADDress \n
 		Snippet: value: str = driver.rxQuality.adetected.aaddress.fetch() \n
 		Queries the automatically detected advertiser address of EUT. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
 			:return: adv_address: string 12-digit hexadecimal number Range: #H0 to #HFFFFFFFFFFFF"""
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/Per.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/Per/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,40 +1,40 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ...Internal.Types import DataType
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Per:
-	"""Per commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class PerCls:
+	"""Per commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("per", core, parent)
+		self._cmd_group = CommandsGroup("per", core, parent)
 
 	@property
 	def rxPackets(self):
 		"""rxPackets commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rxPackets'):
-			from .Per_.RxPackets import RxPackets
-			self._rxPackets = RxPackets(self._core, self._base)
+			from .RxPackets import RxPacketsCls
+			self._rxPackets = RxPacketsCls(self._core, self._cmd_group)
 		return self._rxPackets
 
 	def fetch(self) -> float:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:RXQuality:PER \n
 		Snippet: value: float = driver.rxQuality.per.fetch() \n
 		Queries the PER results for the specified Tx level of R&S CMW. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
 			:return: result: float Packet error rate"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:RXQuality:PER?', suppressed)
 		return Conversions.str_to_float(response)
 
-	def clone(self) -> 'Per':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Per(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/Per_/RxPackets.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/InputSignal/Adetected/Cte/Qhsl/P3Q/TypePy.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,24 +1,26 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ....Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RxPackets:
-	"""RxPackets commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class TypePyCls:
+	"""TypePy commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rxPackets", core, parent)
+		self._cmd_group = CommandsGroup("typePy", core, parent)
 
-	def fetch(self) -> int:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:RXQuality:PER:RXPackets \n
-		Snippet: value: int = driver.rxQuality.per.rxPackets.fetch() \n
-		Queries the number of packets received during PER measurement. \n
+	# noinspection PyTypeChecker
+	def fetch(self) -> enums.CtePacketType:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:CTE:QHSL:P3Q:TYPE \n
+		Snippet: value: enums.CtePacketType = driver.inputSignal.adetected.cte.qhsl.p3Q.typePy.fetch() \n
+		No command help available \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: packets_received: decimal Packets detected by the R&S CMW Range: 0 to 100E+3"""
+			:return: packet_type: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:RXQuality:PER:RXPackets?', suppressed)
-		return Conversions.str_to_int(response)
+		response = self._core.io.query_str_suppressed(f'FETCh:BLUetooth:MEASurement<Instance>:ISIGnal:ADETected:CTE:QHSL:P3Q:TYPE?', suppressed)
+		return Conversions.str_to_scalar_enum(response, enums.CtePacketType)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/Sensitivity.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/Sensitivity.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,20 +2,20 @@
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal import Conversions
 from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ...Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sensitivity:
-	"""Sensitivity commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SensitivityCls:
+	"""Sensitivity commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sensitivity", core, parent)
+		self._cmd_group = CommandsGroup("sensitivity", core, parent)
 
 	def fetch(self) -> float:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:RXQuality:SENSitivity \n
 		Snippet: value: float = driver.rxQuality.sensitivity.fetch() \n
 		Queries the results of sensitivity search measurements for a target PER. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
 			:return: sensitivity_search: float Determined Tx level of R&S CMW for the specified PER value. Range: -120 dBm to 0 dBm"""
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/SpotCheck.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/SpotCheck.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from ...Internal import Conversions
 from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ...Internal.Types import DataType
 from ... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SpotCheck:
-	"""SpotCheck commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SpotCheckCls:
+	"""SpotCheck commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("spotCheck", core, parent)
+		self._cmd_group = CommandsGroup("spotCheck", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> enums.Result:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:RXQuality:SPOTcheck \n
 		Snippet: value: enums.Result = driver.rxQuality.spotCheck.fetch() \n
 		Queries the verdict of spot check. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/State.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/State/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,39 +1,46 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.Types import DataType
+from ....Internal.ArgSingleList import ArgSingleList
+from ....Internal.ArgSingle import ArgSingle
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class State:
-	"""State commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class StateCls:
+	"""State commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("state", core, parent)
+		self._cmd_group = CommandsGroup("state", core, parent)
 
 	@property
 	def all(self):
 		"""all commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_all'):
-			from .State_.All import All
-			self._all = All(self._core, self._base)
+			from .All import AllCls
+			self._all = AllCls(self._core, self._cmd_group)
 		return self._all
 
 	# noinspection PyTypeChecker
-	def fetch(self) -> enums.ResourceState:
+	def fetch(self, timeout: float = None, target_main_state: enums.ResourceState = None, target_sync_state: enums.SyncState = None) -> enums.ResourceState:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:RXQuality:STATe \n
-		Snippet: value: enums.ResourceState = driver.rxQuality.state.fetch() \n
+		Snippet: value: enums.ResourceState = driver.rxQuality.state.fetch(timeout = 1.0, target_main_state = enums.ResourceState.ACTive, target_sync_state = enums.SyncState.ADJusted) \n
 		Queries the main measurement state. Use FETCh:...:STATe:ALL? to query the measurement state including the substates. Use
 		INITiate..., STOP..., ABORt... to change the measurement state. \n
+			:param timeout: No help available
+			:param target_main_state: No help available
+			:param target_sync_state: No help available
 			:return: meas_state: OFF | RDY | RUN OFF: measurement switched off, no resources allocated, no results available (when entered after ABORt...) RDY: measurement has been terminated, valid results are available RUN: measurement running (after INITiate..., READ...) , synchronization pending or adjusted, resources active or queued"""
-		response = self._core.io.query_str(f'FETCh:BLUetooth:MEASurement<Instance>:RXQuality:STATe?')
+		param = ArgSingleList().compose_cmd_string(ArgSingle('timeout', timeout, DataType.Float, None, is_optional=True), ArgSingle('target_main_state', target_main_state, DataType.Enum, enums.ResourceState, is_optional=True), ArgSingle('target_sync_state', target_sync_state, DataType.Enum, enums.SyncState, is_optional=True))
+		response = self._core.io.query_str(f'FETCh:BLUetooth:MEASurement<Instance>:RXQuality:STATe? {param}'.rstrip())
 		return Conversions.str_to_scalar_enum(response, enums.ResourceState)
 
-	def clone(self) -> 'State':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'StateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = State(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = StateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/RxQuality_/State_/All.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trx/State/All.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,21 +1,24 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.Types import DataType
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
+from ....Internal.ArgSingleList import ArgSingleList
+from ....Internal.ArgSingle import ArgSingle
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class All:
-	"""All commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AllCls:
+	"""All commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("all", core, parent)
+		self._cmd_group = CommandsGroup("all", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Main_State: enums.ResourceState: OFF | RDY | RUN OFF: measurement switched off, no resources allocated, no results available (when entered after STOP...) RDY: measurement has been terminated, valid results are available RUN: measurement running (after INITiate..., READ...) , synchronization pending or adjusted, resources active or queued
 			- Sync_State: enums.ResourceState: PEND | ADJ | INV PEND: waiting for resource allocation, adjustment, hardware switching ('pending') ADJ: all necessary adjustments finished, measurement running ('adjusted') INV: not applicable because main_state: OFF or RDY ('invalid')
 			- Resource_State: enums.ResourceState: QUE | ACT | INV QUE: measurement without resources, no results available ('queued') ACT: resources allocated, acquisition of results in progress but not complete ('active') INV: not applicable because main_state: OFF or RDY ('invalid')"""
@@ -26,15 +29,19 @@
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Main_State: enums.ResourceState = None
 			self.Sync_State: enums.ResourceState = None
 			self.Resource_State: enums.ResourceState = None
 
-	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:RXQuality:STATe:ALL \n
-		Snippet: value: FetchStruct = driver.rxQuality.state.all.fetch() \n
+	def fetch(self, timeout: float = None, target_main_state: enums.ResourceState = None, target_sync_state: enums.SyncState = None) -> FetchStruct:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:TRX:STATe:ALL \n
+		Snippet: value: FetchStruct = driver.trx.state.all.fetch(timeout = 1.0, target_main_state = enums.ResourceState.ACTive, target_sync_state = enums.SyncState.ADJusted) \n
 		Queries the main measurement state and the measurement substates. Both measurement substates are relevant for running
 		measurements only. Use FETCh:...:STATe? to query the main measurement state only. Use INITiate..., STOP..., ABORt...
 		to change the measurement state. \n
+			:param timeout: No help available
+			:param target_main_state: No help available
+			:param target_sync_state: No help available
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:RXQuality:STATe:ALL?', self.__class__.FetchStruct())
+		param = ArgSingleList().compose_cmd_string(ArgSingle('timeout', timeout, DataType.Float, None, is_optional=True), ArgSingle('target_main_state', target_main_state, DataType.Enum, enums.ResourceState, is_optional=True), ArgSingle('target_sync_state', target_sync_state, DataType.Enum, enums.SyncState, is_optional=True))
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:TRX:STATe:ALL? {param}'.rstrip(), self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Sense.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Sense/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sense:
-	"""Sense commands group definition. 2 total commands, 1 Sub-groups, 0 group commands"""
+class SenseCls:
+	"""Sense commands group definition. 2 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sense", core, parent)
+		self._cmd_group = CommandsGroup("sense", core, parent)
 
 	@property
 	def elogging(self):
 		"""elogging commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_elogging'):
-			from .Sense_.Elogging import Elogging
-			self._elogging = Elogging(self._core, self._base)
+			from .Elogging import EloggingCls
+			self._elogging = EloggingCls(self._core, self._cmd_group)
 		return self._elogging
 
-	def clone(self) -> 'Sense':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SenseCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Sense(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SenseCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trigger.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Configure/Hdr/Sgacp/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Trigger:
-	"""Trigger commands group definition. 4 total commands, 1 Sub-groups, 0 group commands"""
+class SgacpCls:
+	"""Sgacp commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("trigger", core, parent)
+		self._cmd_group = CommandsGroup("sgacp", core, parent)
 
 	@property
-	def multiEval(self):
-		"""multiEval commands group. 1 Sub-classes, 3 commands."""
-		if not hasattr(self, '_multiEval'):
-			from .Trigger_.MultiEval import MultiEval
-			self._multiEval = MultiEval(self._core, self._base)
-		return self._multiEval
+	def measurement(self):
+		"""measurement commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_measurement'):
+			from .Measurement import MeasurementCls
+			self._measurement = MeasurementCls(self._core, self._cmd_group)
+		return self._measurement
 
-	def clone(self) -> 'Trigger':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SgacpCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Trigger(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SgacpCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trigger_/MultiEval_/Catalog.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Hdrp/Sacp/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,23 +1,27 @@
-from typing import List
-
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Catalog:
-	"""Catalog commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SacpCls:
+	"""Sacp commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("catalog", core, parent)
+		self._cmd_group = CommandsGroup("sacp", core, parent)
+
+	@property
+	def current(self):
+		"""current commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
 
-	def get_source(self) -> List[str]:
-		"""SCPI: TRIGger:BLUetooth:MEASurement<Instance>:MEValuation:CATalog:SOURce \n
-		Snippet: value: List[str] = driver.trigger.multiEval.catalog.get_source() \n
-		Lists all trigger source values that can be set using method RsCmwBluetoothMeas.Trigger.MultiEval.source. \n
-			:return: source_list: string Comma-separated list of all supported values. Each value is represented as a string.
-		"""
-		response = self._core.io.query_str('TRIGger:BLUetooth:MEASurement<Instance>:MEValuation:CATalog:SOURce?')
-		return Conversions.str_to_str_list(response)
+	def clone(self) -> 'SacpCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = SacpCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trx_/Acp.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trx/Acp.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,38 +1,38 @@
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal.StructBase import StructBase
 from ...Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Acp:
-	"""Acp commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AcpCls:
+	"""Acp commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("acp", core, parent)
+		self._cmd_group = CommandsGroup("acp", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Nominal_Power: float: float Average power during the carrier-on state Unit: dBm
-			- No_Of_Exceptions: int: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold )"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Nominal_Power: float: float Average power during the carrier-on state Range: -99.99 dBm to 99.99 dBm, Unit: dBm
+			- No_Of_Exceptions: int: decimal Number of exceptions (channels ±3, ±4 ... with an ACP above the 'Exception PTx' threshold ) Range: 0 to 99"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Nominal_Power'),
 			ArgStruct.scalar_int('No_Of_Exceptions')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Nominal_Power: float = None
 			self.No_Of_Exceptions: int = None
 
 	def fetch(self) -> FetchStruct:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:TRX:ACP \n
 		Snippet: value: FetchStruct = driver.trx.acp.fetch() \n
-		Returns the 'Spectrum ACP' results for Tx-Rx tests on advertiser packets (LE 1M PHY) . Only 'ACP+/-5 channel' mode is
-		supported (21 half-channels) . See also 'LE: Spectrum ACP Results '. \n
+		Returns the 'Spectrum ACP' results for TX-RX tests on advertiser packets (LE 1M PHY) . Only 'ACP+/-5 channel' mode is
+		supported (21 half-channels) . See also 'View Spectrum ACP'. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:TRX:ACP?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trx_/Modulation.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trx/Modulation.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,40 +1,40 @@
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal.StructBase import StructBase
 from ...Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Modulation:
-	"""Modulation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ModulationCls:
+	"""Modulation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("modulation", core, parent)
+		self._cmd_group = CommandsGroup("modulation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal See 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:MODulation CMDLINK]) exceeding the specified limits, see 'Limits (Modulation LE) '.
-			- Delta_F_299_P_9: float: float Unit: %
-			- Freq_Accuracy: float: float Unit: Hz
-			- Freq_Drift: float: float Unit: Hz
-			- Max_Drift: float: float
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#Modulation CMDLINKRESOLVED]) exceeding the specified limits, see 'Modulation limits (LE) '. Range: 0 % to 100 %
+			- Delta_F_299_P_9: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: %
+			- Freq_Accuracy: float: float Range: -0.99999 MHz to 0.99999 MHz, Unit: Hz
+			- Freq_Drift: float: float Range: -99.99 kHz to 99.99 kHz, Unit: Hz
+			- Max_Drift: float: float Range: -99.99 kHz to 99.99 kHz
 			- Freq_Dev_Avg_F_1: float: No parameter help available
 			- Freq_Dev_Min_F_1: float: No parameter help available
 			- Freq_Dev_Max_F_1: float: No parameter help available
 			- Freq_Dev_Avg_F_2: float: No parameter help available
 			- Freq_Dev_Min_F_2: float: No parameter help available
 			- Freq_Dev_Max_F_2: float: No parameter help available
-			- Nominal_Power: float: float Unit: dBm
+			- Nominal_Power: float: float Range: -99.99 dBm to 99.99 dBm, Unit: dBm
 			- Mod_Ratio: float: float Range: 0 to 1
-			- Freq_Offset: float: float
-			- Init_Freq_Drift: float: float"""
+			- Freq_Offset: float: float Range: -0.99999 MHz to 99.99 kHz
+			- Init_Freq_Drift: float: float Range: -99.99 kHz to 99.99 kHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
 			ArgStruct.scalar_float('Delta_F_299_P_9'),
 			ArgStruct.scalar_float('Freq_Accuracy'),
 			ArgStruct.scalar_float('Freq_Drift'),
 			ArgStruct.scalar_float('Max_Drift'),
@@ -67,11 +67,11 @@
 			self.Mod_Ratio: float = None
 			self.Freq_Offset: float = None
 			self.Init_Freq_Drift: float = None
 
 	def fetch(self) -> FetchStruct:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:TRX:MODulation \n
 		Snippet: value: FetchStruct = driver.trx.modulation.fetch() \n
-		Returns current modulation results for TRx tests on advertiser packets (LE 1M PHY) . See also 'LE: Statistical Modulation
-		Results '. \n
+		Returns current modulation results for TX-RX tests on advertiser packets (LE 1M PHY) . See also 'View TX Measurement -
+		modulation statistics'. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:TRX:MODulation?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trx_/Power.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trx/Power.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal.StructBase import StructBase
 from ...Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Power:
-	"""Power commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PowerCls:
+	"""Power commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("power", core, parent)
+		self._cmd_group = CommandsGroup("power", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: decimal 'Reliability Indicator'
-			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:SCOunt:PVTime CMDLINK]) exceeding the specified limits, see [CMDLINK: CONFigure:BLUetooth:MEASi:MEValuation:LIMit:PVTime CMDLINK].
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tol: float: float Out of tolerance result, i.e. percentage of measurement intervals of the statistic count ([CMDLINKRESOLVED Configure.MultiEval.Scount#PowerVsTime CMDLINKRESOLVED]) exceeding the specified limits, see [CMDLINKRESOLVED Configure.MultiEval.Limit.LowEnergy.Le1M.PowerVsTime#set CMDLINKRESOLVED]. Range: 0 % to 100 %
 			- Nominal_Power: float: float Average power during the carrier-on state Range: -128.0 dBm to 130.0 dBm , Unit: dBm
 			- Peak_Power: float: float Peak power during the carrier-on state Range: -128.0 dBm to 130.0 dBm , Unit: dBm
 			- Leakage_Power: float: float Average power during the carrier-off state Range: -128.0 dBm to 130.0 dBm , Unit: dBm
 			- Peak_Min_Avg_Pow: float: float Peak power minus average power Range: 0 dB to 158 dB , Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Out_Of_Tol'),
@@ -37,10 +37,11 @@
 			self.Peak_Power: float = None
 			self.Leakage_Power: float = None
 			self.Peak_Min_Avg_Pow: float = None
 
 	def fetch(self) -> FetchStruct:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:TRX:POWer \n
 		Snippet: value: FetchStruct = driver.trx.power.fetch() \n
-		Returns the power results for Tx-Rx measurements on advertiser packets LE 1M PHY (uncoded) . \n
+		Returns the power results for TX-RX measurements on advertiser packets LE 1M PHY (uncoded) .
+		See also 'View TX Measurement - power vs time statistics'. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:TRX:POWer?', self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trx_/Spot.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/Trx/Spot.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from ...Internal import Conversions
 from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ...Internal.Types import DataType
 from ... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Spot:
-	"""Spot commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SpotCls:
+	"""Spot commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("spot", core, parent)
+		self._cmd_group = CommandsGroup("spot", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> enums.Result:
 		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:TRX:SPOT \n
 		Snippet: value: enums.Result = driver.trx.spot.fetch() \n
 		Queries the verdict of spot check. \n
 		Use RsCmwBluetoothMeas.reliability.last_value to read the updated reliability indicator. \n
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Implementations/Trx_/State_/All.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Implementations/RxQuality/State/All.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,21 +1,24 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.Types import DataType
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
+from ....Internal.ArgSingleList import ArgSingleList
+from ....Internal.ArgSingle import ArgSingle
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class All:
-	"""All commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AllCls:
+	"""All commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("all", core, parent)
+		self._cmd_group = CommandsGroup("all", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Main_State: enums.ResourceState: OFF | RDY | RUN OFF: measurement switched off, no resources allocated, no results available (when entered after STOP...) RDY: measurement has been terminated, valid results are available RUN: measurement running (after INITiate..., READ...) , synchronization pending or adjusted, resources active or queued
 			- Sync_State: enums.ResourceState: PEND | ADJ | INV PEND: waiting for resource allocation, adjustment, hardware switching ('pending') ADJ: all necessary adjustments finished, measurement running ('adjusted') INV: not applicable because main_state: OFF or RDY ('invalid')
 			- Resource_State: enums.ResourceState: QUE | ACT | INV QUE: measurement without resources, no results available ('queued') ACT: resources allocated, acquisition of results in progress but not complete ('active') INV: not applicable because main_state: OFF or RDY ('invalid')"""
@@ -26,15 +29,19 @@
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Main_State: enums.ResourceState = None
 			self.Sync_State: enums.ResourceState = None
 			self.Resource_State: enums.ResourceState = None
 
-	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:TRX:STATe:ALL \n
-		Snippet: value: FetchStruct = driver.trx.state.all.fetch() \n
+	def fetch(self, timeout: float = None, target_main_state: enums.ResourceState = None, target_sync_state: enums.SyncState = None) -> FetchStruct:
+		"""SCPI: FETCh:BLUetooth:MEASurement<Instance>:RXQuality:STATe:ALL \n
+		Snippet: value: FetchStruct = driver.rxQuality.state.all.fetch(timeout = 1.0, target_main_state = enums.ResourceState.ACTive, target_sync_state = enums.SyncState.ADJusted) \n
 		Queries the main measurement state and the measurement substates. Both measurement substates are relevant for running
 		measurements only. Use FETCh:...:STATe? to query the main measurement state only. Use INITiate..., STOP..., ABORt...
 		to change the measurement state. \n
+			:param timeout: No help available
+			:param target_main_state: No help available
+			:param target_sync_state: No help available
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:TRX:STATe:ALL?', self.__class__.FetchStruct())
+		param = ArgSingleList().compose_cmd_string(ArgSingle('timeout', timeout, DataType.Float, None, is_optional=True), ArgSingle('target_main_state', target_main_state, DataType.Enum, enums.ResourceState, is_optional=True), ArgSingle('target_sync_state', target_sync_state, DataType.Enum, enums.SyncState, is_optional=True))
+		return self._core.io.query_struct(f'FETCh:BLUetooth:MEASurement<Instance>:RXQuality:STATe:ALL? {param}'.rstrip(), self.__class__.FetchStruct())
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/ArgLinkedEventArgs.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ArgLinkedEventArgs.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""Class defining Linked argument Event."""
+
 import time
 
 
 class ArgLinkedEventArgs(object):
 	"""Contains event data for suppressed argument."""
 
 	def __init__(self, link_name: str, arg_name: str, value: object = None, context: str = '', timestamp: time = None):
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/ArgSingle.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ArgSingle.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,54 +1,57 @@
+"""Single argument definition for a scalar argument."""
+
 from .ConverterFromScpiString import ConverterFromScpiString
 from .ConverterToScpiString import ConverterToScpiString
+from .InstrumentErrors import RsInstrException
+
 from .Types import DataType
 
 
 class ArgSingle(object):
 	"""Single Argument outside a structure - used for composing query arguments.
 	Contains the argument value as well (self.value)."""
 
-	def __init__(self, name: str, value, data_type: DataType, is_optional: bool = False, is_open_list: bool = False, repetition: int = 1, intern_link: str = None):
+	def __init__(self, name: str, value, data_type: DataType, enum_type=None, is_optional: bool = False, is_open_list: bool = False, repetition: int = 1, intern_link: str = None):
 		self.name = name if name else ''
 		self.argument_ix = None
 		self.value = value
 		self.data_type = data_type
+		self.enum_type = enum_type
 		self.is_optional = is_optional
 		self.is_open_list = is_open_list
 		self.repetition = repetition
 		self.intern_link = intern_link
 		self.conv_from_scpi_string = None
 		self.conv_to_scpi_string = None
 
-		if self.data_type == DataType.Enum:
-			self.assert_mandatory_has_value(self)
-			if self.value is not None:
-				self.enum_type = type(self.value)
-				self.conv_from_scpi_string = ConverterFromScpiString(self.data_type, self.enum_type)
-				self.conv_to_scpi_string = ConverterToScpiString(self.data_type, self.enum_type)
-		elif self.data_type == DataType.EnumList:
-			self.assert_mandatory_has_value(self)
+		if self.data_type.is_scalar_enum:
+			# self.assert_mandatory_has_value(self)
+			self.conv_from_scpi_string = ConverterFromScpiString(self.data_type, self.enum_type)
+			self.conv_to_scpi_string = ConverterToScpiString(self.data_type, self.enum_type)
+		elif self.data_type.is_list_enum:
+			# self.assert_mandatory_has_value(self)
 			if self.value is not None:
-				self.enum_type = type(self.value[0])
 				self.conv_from_scpi_string = ConverterFromScpiString(self.data_type, self.enum_type)
 				self.conv_to_scpi_string = ConverterToScpiString(self.data_type, self.enum_type)
 		else:
 			self.conv_from_scpi_string = ConverterFromScpiString(self.data_type)
 			self.conv_to_scpi_string = ConverterToScpiString(self.data_type)
 
 		self.check_consistency()
 
 	@classmethod
-	def as_open_list(cls, name: str, value: object, data_type: DataType) -> 'ArgSingle':
+	def as_open_list(cls, name: str, value: object, data_type: DataType, enum_type=None) -> 'ArgSingle':
 		"""Creates new ArgSingle of open list type.Use this method for all non-interleaved list types. \n
-		:param name: name of the argument.
-		:param value: value of the argument.
-		:param data_type: data type of the argument.
-		:return: ArgSingle object of an open list type."""
-		return cls(name, value, data_type, False, True, 1, None)
+		:param name: name of the argument
+		:param value: value of the argument
+		:param data_type: data type of the argument
+		:param enum_type: enum type if the data_type is Enum or EnumExt (or list of those)
+		:return: ArgSingle object of an open list type"""
+		return cls(name, value, data_type, enum_type, False, True, 1, None)
 
 	def __str__(self):
 		opt = '~' if self.is_optional else ''
 		name = f" '{self.name}'" if self.name != '' else ''
 		out = f"SingleArg {opt}{self.data_type.name}{name}"
 
 		if self.is_open_list is False and self.repetition > 1:
@@ -72,15 +75,15 @@
 
 	# noinspection PyUnusedLocal
 	def assert_is_optional(self, obj=None) -> None:
 		"""Asserts that the parameter is optional.
 		If not, the method throws an exception."""
 		if self.is_optional:
 			return
-		raise Exception(f'Single argument is not optional: {self}')
+		raise RsInstrException(f'Single argument is not optional: {self}')
 
 	# noinspection PyUnusedLocal
 	def assert_mandatory_has_value(self, value_obj=None) -> None:
 		"""Asserts that if the parameter is mandatory, it must have value assigned.
 		If not, the method throws an exception."""
 		if self.is_optional:
 			return
@@ -93,11 +96,11 @@
 
 	def check_consistency(self) -> None:
 		"""Checks the consistency of the object"""
 		if self.value is None:
 			return
 		if isinstance(self.value, list):
 			if self.data_type.is_scalar:
-				raise Exception(f'Argument real data type is list, but it is declared as {self.data_type}. Value: {self.value}')
+				raise RsInstrException(f'Argument real data type is list, but it is declared as {self.data_type}. Value: {self.value}')
 		else:
 			if self.data_type.is_list:
-				raise Exception(f'Argument real data type is scalar, but it is declared as {self.data_type}. Value: {self.value}')
+				raise RsInstrException(f'Argument real data type is scalar, but it is declared as {self.data_type}. Value: {self.value}')
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/ArgSingleList.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ArgSingleList.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""Single argument definition for a list argument."""
+
 from .ArgSingle import ArgSingle
 from .ArgStringComposer import compose_cmd_string_from_single_args
 
 
 class ArgSingleList(object):
 	"""Contains methods for composing cmd string for the list of single arguments.
 	Used in methods with 1+ set or query arguments.
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/ArgSingleSuppressed.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ArgSingleSuppressed.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,7 +1,10 @@
+"""Contains definition for an argument that is suppressed and not exposed to the user.
+Usually such arguments are also linked to a callback."""
+
 from .Types import DataType
 
 
 class ArgSingleSuppressed(object):
 	"""Single suppressed Argument - used in Query_XxXx_Suppressed() to remove it from the returned value.
 	It does not contain:
 	- 'value' attribute, since this is discarded or linked internally directly  in the Query_XxXx_Suppressed().
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/ArgStringComposer.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ArgStringComposer.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,14 +6,15 @@
 The composing of the SCPI parameter string is similar for the ArgStruct and ArgSingle[] objects, therefore they share the same module."""
 
 from typing import Dict
 
 from .ArgSingle import ArgSingle
 from .ArgStruct import ArgStruct
 from .Utilities import get_plural_string
+from .InstrumentErrors import RsInstrException
 
 
 class SingleComposer:
 	"""Composes strings for single argument.
 	Provides Composer interface with 3 functions:
 	- from_scalar_arg
 	- from_list_arg
@@ -135,15 +136,15 @@
 					# The last argument, ignore the repetitions and convert the whole list to string
 					string_arg.append(composer.from_list_arg(arg))
 				else:
 					# The optional argument, which has no value. End the entire string_arg composition
 					arg.assert_is_optional(values_obj)
 					opt_null_ix = arg_ix
 			else:
-				# More than one arguments remaining. Loop through them interleaving the result strings
+				# More than one argument remaining. Loop through them interleaving the result strings
 				# Interleaving arguments must all have values
 
 				# Check if each list has at least Repetition number of elements
 				cycles_error = False
 				alignments_error = False
 				cycle = -1
 				data = {}
@@ -151,19 +152,18 @@
 					arg = args[x]
 					curr_size: int = composer.get_arg_list_size(arg)
 					curr_cycle: int = curr_size // arg.repetition
 					curr_align: int = curr_size % arg.repetition
 					data[x] = (curr_size, curr_cycle, curr_align)
 
 					if curr_size < 0:
-						raise Exception(
-							f"Argument '{arg.name}' has repetitions, therefore it must be declared as a list. Current Declaration: '{arg.data_type}'")
+						raise RsInstrException(f"Argument '{arg.name}' has repetitions, therefore it must be declared as a list. Current Declaration: '{arg.data_type}'")
 
 					if arg.repetition > curr_size:
-						raise Exception(f"Argument '{arg.name}' has repetitions {arg.repetition}, but its list size is only {curr_size}")
+						raise RsInstrException(f"Argument '{arg.name}' has repetitions {arg.repetition}, but its list size is only {curr_size}")
 
 					# noinspection PyChainedComparisons
 					if cycle >= 0 and curr_cycle != cycle:
 						cycles_error = True
 
 					cycle = curr_cycle
 
@@ -171,23 +171,21 @@
 						alignments_error = True
 
 				if cycles_error:
 					message = 'Arguments interleaving is not aligned - all the cycles must be the same. Actual cycles:\n'
 					for x in range(arg_ix, arg_count):
 						message += f'{args[x].name}[{data[x][0]}] sliced by {get_plural_string("element", args[x].repetition)} ' \
 							f'results in {data[x][0] / args[x].repetition} cycles\n'
-
-					raise Exception(message)
+					raise RsInstrException(message)
 
 				if alignments_error:
 					message = 'At least one argument has a list size not dividable by the defined repetitions:\n'
 					for x in range(arg_ix, arg_count):
 						message += f'{args[x].name}[{data[x][0]}] modulo {args[x].repetition}x results in {data[x][0] % args[x].repetition}\n'
-
-					raise Exception(message)
+					raise RsInstrException(message)
 
 				for x in range(cycle):
 					for y in range(arg_ix, arg_count):
 						arg = args[y]
 						string_arg.append(composer.from_list_arg(arg, arg.repetition * x, arg.repetition))
 
 	if opt_null_ix >= 0:
@@ -198,15 +196,15 @@
 			if arg.has_value(values_obj):
 				rest.append(arg.name)
 
 		if len(rest):
 			msg = f"Optional Argument '{args[opt_null_ix].name}' has no value, but the further ones do. " \
 				f"If you skip an optional argument, you have to skip all the ones following it. " \
 				f"Clear the values for the rest of the argument(s):\n{', '.join(rest)}"
-			raise Exception(msg)
+			raise RsInstrException(msg)
 
 	return ','.join(string_arg)
 
 
 def compose_cmd_string_from_single_args(args: Dict[int, ArgSingle]) -> str:
 	"""Returns SCPI-composed string based on the single args specification.
 	We can use the same function as for the struct arguments, with the difference of providing a SingleComposer.
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/ArgStruct.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ArgStruct.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,13 @@
+"""Definition for an argument which is a part of a structure."""
+
 from .ConverterFromScpiString import ConverterFromScpiString
 from .ConverterToScpiString import ConverterToScpiString
 from .Types import DataType
+from .InstrumentErrors import RsInstrException
 
 
 class ArgStruct(object):
 	"""Describes an argument in data structures.
 	This info is used to parse a string query response to the output structure,
 	or to parse the output structure to the string parameter for writing.
 	Contains reference to the value in the owning structure."""
@@ -121,17 +124,17 @@
 	def assert_is_optional(self, obj) -> None:
 		"""Asserts that the parameter is optional.
 		If not, the method throws an exception."""
 		if self.is_optional:
 			return
 		value = getattr(obj, self.name)
 		if value is None:
-			raise Exception(f"Structure '{obj}', argument without value is not optional: {self}")
+			raise RsInstrException(f"Structure '{obj}', argument without value is not optional: {self}")
 		else:
-			raise Exception(f"Structure '{obj}', argument is not optional: {self}', value '{value}'")
+			raise RsInstrException(f"Structure '{obj}', argument is not optional: {self}', value '{value}'")
 
 	def assert_mandatory_has_value(self, obj) -> None:
 		"""Asserts that if the parameter is mandatory, it must have value assigned.
 		If not, the method throws an exception."""
 		if self.is_optional:
 			return
 		if getattr(obj, self.name) is None:
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/ArgStructList.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ArgStructList.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,13 @@
+"""See the class docstring."""
+
 from .ArgStringComposer import StructComposer, compose_cmd_string_from_struct_args
 from .ArgStructStringParser import ArgStructStringParser
 from .StructBase import StructBase
+from .InstrumentErrors import RsInstrException
 
 
 class ArgStructList(object):
 	"""Contains methods for composing cmd string and parsing cmd response to the provided structure instance."""
 
 	RAW_DATA_PROP_NAME = 'RawReturnData'
 
@@ -53,22 +56,22 @@
 			# Still some args to go
 			if arg.is_open_list is True:
 				# The previous loop ended because the next argument had is_open_list True
 				if arg_ix == (arg_count - 1):
 					# This is the last argument, ignore the repetitions and take the whole rest of the elements
 					parser.to_list_value(arg, True, 0, parser.remaining, parser.remaining, 1)
 				else:
-					# More than one arguments remaining. Loop through them interleaving the result strings
+					# More than one argument remaining. Loop through them interleaving the result strings
 					open_list_args = {key: value for key, value in self.args.items() if key >= arg_ix}
 
 					# Accumulate the number of repetitions from all the open_list_args
 					period: int = sum(open_list_args[ix].repetition for ix in open_list_args)
 					reminder: int = parser.remaining % period
 					if reminder != 0:
-						raise Exception(
+						raise RsInstrException(
 							f'Arguments parsing is not aligned - source string elements remaining to parse {parser.remaining}'
 							f'is not dividable by the summary Period {period} of all the open list arguments:\n' + '\n'.join(['{}'.format(x) for x in open_list_args]))
 					# Go through the arguments and accumulate the list content
 					offset = 0
 					for x in open_list_args:
 						arg = open_list_args[x]
 						parser.to_list_value(arg, False, offset, arg.repetition, period, -1)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/ArgStructStringParser.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ArgStructStringParser.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,9 +1,12 @@
+"""See the class docstring."""
+
 from . import Utilities
 from .ArgStruct import ArgStruct
+from .InstrumentErrors import RsInstrException
 
 
 class ArgStructStringParser:
 	"""Class for parsing a response from the instrument to an output structure of arguments.
 	It is used by the ArgStructList class for filling structures with return values."""
 
 	def __init__(self, struct, value: str):
@@ -17,34 +20,34 @@
 		"""Remaining items to parse."""
 		return self.count - self.position
 
 	def to_scalar_value(self, arg: ArgStruct):
 		"""Parses the current element to a scalar argument."""
 		assert arg.data_type.is_scalar, f'to_scalar_value() method only works with scalar values. Data type: {arg.data_type}'
 		if self.position >= self.count:
-			raise Exception(
+			raise RsInstrException(
 				f"Cannot parse a scalar value to structure argument. Response contains only {self.count} elements, "
 				f"argument '{arg.name}' has position {self.position + 1}.\n"
 				f"Response (commas replaced by new lines):\n" + Utilities.truncate_string_from_end('\n'.join(self.elements), 1000))
 		string = self.elements[self.position]
 		value = arg.conv_from_scpi_string.get_one_element_value(string)
 		setattr(self.struct, arg.name, value)
 		self.position += 1
 
 	def to_list_value(self, arg: ArgStruct, increase_pos: bool, offset: int, count: int, period: int, cycles: int) -> None:
 		"""Parses more elements to the list argument - slicing."""
 		assert arg.data_type.is_list, f'to_list_value method only works with list values. Data type: {arg.data_type}'
 		if cycles < 0:
 			cycles = self.remaining // period
 		if self.position >= self.count:
-			raise Exception(
+			raise RsInstrException(
 				f"Cannot parse an list value to the argument '{arg.name}', "
 				f"because the element position {self.position} is over the parsed list length {self.count}")
 		if (self.position + offset + count) > self.count:
-			raise Exception(
+			raise RsInstrException(
 				f"Cannot parse the whole list value to the argument '{arg.name}', because the element position {self.position} "
 				f"plus the argument offset {offset} and argument length {count} would be over the parsed list length {self.count}")
 
 		result = []
 		for cycle in range(cycles):
 			start_ix = self.position + (cycle * period) + offset
 			for i in range(count):
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/CommandsGroup.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/CommandsGroup.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""See the class docstring."""
+
 from enum import Enum
 from typing import List
 from .Core import Core
 from .RepeatedCapability import RepeatedCapability as RepCap
 from .InstrumentErrors import DriverValueError
 
 
@@ -38,27 +40,27 @@
 		return self.multi_repcap_types != ''
 
 	def add_existing_child(self, child: 'CommandsGroup') -> None:
 		"""Adds the child to the parent's list of created children.
 		This is used when the group is cloned, where the whole existing tree of groups have to be recreated"""
 		self.existing_children.append(child)
 
-	def set_repcap_enum_value(self, enum_value: Enum) -> None:
-		"""Sets RepCap value as enum
-		Default is not allowed."""
+	def set_repcap_enum_value(self, enum_value: Enum or int) -> None:
+		"""Sets RepCap value as enum or integer
+		Default is not allowed here."""
 		try:
 			self.rep_cap.set_enum_value(enum_value)
 		except ValueError:
 			raise DriverValueError(self.io.resource_name, f"Commands group RepCap value '{self.rep_cap.name}.Default' cannot be set. Please select a concrete value.")
 
 	def get_repcap_enum_value(self) -> Enum:
 		"""Returns RepCap value as enum"""
 		return self.rep_cap.get_enum_value()
 
-	def get_repcap_cmd_value(self, enum_value: Enum, enum_type) -> str:
+	def get_repcap_cmd_value(self, enum_value: Enum or int, enum_type) -> str:
 		"""Returns the current string of RepCapCmdValue for the entered RepCapEnumName
 		The enum_value can be a repcap of the current CommandsGroup or any of their parents"""
 		# Use the static functions of the RepeatedCapability to get the non-default value
 		# It is faster, since there is no need to use the RepCap instance
 		if not RepCap.clsm_is_default_value(enum_value, enum_type):
 			return RepCap.clsm_get_cmd_string_value(enum_value, enum_type)
 		# Default value - get it from the group or the parent groups
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/Conversions.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/Conversions.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,14 +1,20 @@
+"""Contains conversion functions for SCPI string -> parameter and vice versa."""
+
 import math
 import struct
 import sys
 from enum import Enum
-from typing import List
+from typing import List, Tuple
+from .ScpiEnums import ScpiEnum, enum_spec_prefixes, enum_spec_strings
+from .Properties import Properties
+from datetime import datetime
 
 from . import Utilities
+from .InstrumentErrors import RsInstrException
 
 
 class BinFloatFormat(Enum):
 	"""Binary format of a float number."""
 	Single_4bytes = 1
 	Single_4bytes_swapped = 2
 	Double_8bytes = 3
@@ -24,15 +30,15 @@
 
 
 def assert_string_data(value: str) -> None:
 	"""Asserts value is string type."""
 	assert isinstance(value, str), f"Input value type must be string. Actual type: {type(value)}, value: {value}"
 
 
-def assert_list_data(value: list) -> None:
+def assert_list_data(value: List) -> None:
 	"""Asserts value is list type."""
 	assert isinstance(value, list), f"Input value type must be a list. Actual type: {type(value)}, value: {value}"
 
 
 def _get_endianness_symbol(swap_endianness: bool) -> str:
 	"""Based on the current endianness returns the symbol used in the 'struct' module."""
 	if swap_endianness is False:
@@ -143,15 +149,15 @@
 bool_true_lookup = frozenset(['1', 'on', 'On', 'ON', 'true', 'True', 'TRUE'])
 bool_false_lookup = frozenset(['0', 'off', 'Off', 'OFF', 'false', 'False', 'FALSE'])
 pure_bool_false_lookup = frozenset(['off', 'Off', 'OFF', 'false', 'False', 'FALSE'])
 
 
 def str_to_bool(string: str) -> bool:
 	"""Converts string to boolean value.
-	The function robust, and case insensitive.
+	The function is robust, and case-insensitive.
 	If the string can not be converted to a boolean, the function returns False."""
 	assert_string_data(string)
 	if string in bool_true_lookup:
 		return True
 	if string in bool_false_lookup:
 		return False
 	# If leading/trailing spaces
@@ -193,24 +199,38 @@
 
 
 number_plus_inf_lookup = frozenset(['Inf', 'INF', 'INFINITY', '+Inf', '+INF', '+inf', '+INFINITY', '+Infinity', '+infinity'])
 number_minus_inf_lookup = frozenset(['-Inf', '-INF', '-inf', '-INFINITY', '-Infinity', '-infinity'])
 number_nan_lookup = frozenset(['Nan', 'NAN', 'nan', 'NaN', 'NAV', 'NaV', 'NCAP', 'INV', 'NONE', 'none', 'None', 'DTX', 'UND', 'und'])
 number_max_lookup = frozenset(['OFL', 'ofl', 'Ofl'])
 number_min_lookup = frozenset(['UFL', 'ufl', 'Ufl'])
+number_si_suffix = {
+	'pHz': 1E-12, 'MHz': 1E+6, 'kHz': 1E+3, 'GHz': 1E+9, 'mHz': 1E-3, 'uHz': 1E-6, 'µHz': 1E-6, 'THz': 1E+12, 'nHz': 1E-9, 'ns': 1E-9, 'fW': 1E-15,
+	'pW': 1E-12, 'nW': 1E-9, 'uW': 1E-6, 'µW': 1E-6, 'mW': 1E-3, 'kW': 1E3, 'MW': 1E6, 'GW': 1E9, 'MV': 1E+6, 'MA': 1E+6, 'ps': 1E-12, 'fs': 1E-15,
+	'km': 1E+3, 'kV': 1E+3, 'kA': 1E+3, 'pF': 1E-2, 'Hz': 1.0, 'mm': 1E-3, 'mA': 1E-3, 'mF': 1E-3, 'mV': 1E-3, 'pV': 1E-12, 'nF': 1E-9, 'nA': 1E-9,
+	'nV': 1E-9, 'nm': 1E-9, 'pm': 1E-12, 'us': 1E-6, 'µs': 1E-6, 'uF': 1E-6, 'µF': 1E-6, 'ms': 1E-3, 'uA': 1E-6, 'µA': 1E-6, 'uV': 1E-6, 'µV': 1E-6,
+	'um': 1E-6, 'µm': 1E-6, 'pA': 1E-12, 'V': 1, 'W': 1, 'A': 1, 'F': 1, 's': 1, 'm': 1}
 int_neg_inf = -(sys.maxsize - 1)
-enum_spec_prefixes = {'_minus': '-', '_plus': '+', '_': ''}
-enum_spec_strings = {'_dash_': '-', '_dot_': '.'}
+
+
+def strip_si_suffix(string: str) -> Tuple[bool, str, float]:
+	"""Tries to find defined suffixes in the text and returns the stripped text and the multiplier as double number.
+	If no known suffix is detected, the method returns false, strippedText=text, multiplier=1.0
+	Example: text='123 MHz' strippedText='123' multiplier=1E6"""
+	for suffix in number_si_suffix.keys():
+		if string.endswith(suffix):
+			return True, string[:-len(suffix)].rstrip(), number_si_suffix[suffix]
+	return False, string, 1.0
 
 
 def str_to_int(string: str) -> int:
 	"""Converts string to integer value. Float values are coerced to integer.
-	Also recognizes case insensitive special values like NaN, INV, NCAP..."""
+	Also recognizes case-insensitive special values like NaN, INV, NCAP..."""
 	assert_string_data(string)
-	string = string.strip()
+	string = string.strip(" \t\r\n'\"")
 	if string == '':
 		return 0
 	value = str_special_values_to_int(string)
 	if value:
 		return value
 
 	# Hexadecimal numbers
@@ -232,15 +252,24 @@
 		if ',' in string:
 			return int(string[2:string.find(',')], 8)
 		else:
 			return int(string[2:], 8)
 	# Simulation
 	if string == 'Simulating':
 		return 0
-	return int(round(float(string)))
+	try:
+		return int(round(float(string)))
+	except ValueError:
+		result = strip_si_suffix(string)
+		if result[0] is False:
+			raise
+		try:
+			return int(round(float(result[1]) * result[2]))
+		except ValueError:
+			raise ValueError(f"could not convert string to integer: '{string}'")
 
 
 def str_special_values_to_int(string: str) -> int:
 	"""Converts special string values to integer. Returns None if no special value was found."""
 	assert_string_data(string)
 	if string in number_plus_inf_lookup or string in number_max_lookup:
 		return sys.maxsize
@@ -270,17 +299,17 @@
 	if result is not None:
 		return result
 	return str_to_int(string)
 
 
 def str_to_float(string: str) -> float:
 	"""Converts string to float value.
-	Also recognizes case insensitive special values like NaN, INV, NCAP..."""
+	Also recognizes case-insensitive special values like NaN, INV, NCAP..."""
 	assert_string_data(string)
-	string = string.strip()
+	string = string.strip(" \t\r\n'\"")
 	if string == '':
 		return 0.0
 	if string in number_plus_inf_lookup:
 		return math.inf
 	if string in number_minus_inf_lookup:
 		return -math.inf
 	if string in number_nan_lookup:
@@ -299,15 +328,24 @@
 		return -sys.float_info.max / 100
 	if string == 'ULEU':
 		return sys.float_info.max / 10
 	if string == 'ULEL':
 		return -sys.float_info.max / 10
 	if string == 'Simulating':
 		return 0.0
-	return float(string)
+	try:
+		return float(string)
+	except ValueError:
+		result = strip_si_suffix(string)
+		if result[0] is False:
+			raise
+		try:
+			return float(result[1]) * result[2]
+		except ValueError:
+			raise ValueError(f"could not convert string to float: '{string}'")
 
 
 def str_to_float_or_bool(string: str) -> float or bool:
 	"""Similar to str_to_float, but for special values "ON/OFF" the function returns boolean"""
 	result = string_to_pure_bool(string)
 	if result is not None:
 		return result
@@ -320,24 +358,24 @@
 
 
 def bool_to_str(value: bool) -> str:
 	"""Converts boolean to 'ON' or 'OFF' string."""
 	if type(value) is bool:
 		return 'ON' if value is True else 'OFF'
 	else:
-		raise Exception(f"bool_to_str: unsupported variable type '{type(value)}', value '{value}'. Only boolean values are supported.")
+		raise RsInstrException(f"bool_to_str: unsupported variable type '{type(value)}', value '{value}'. Only boolean values are supported.")
 
 
 def str_enclose_by_quotes(string: str) -> str:
 	"""Returns string enclosed by single quotes."""
 	assert_string_data(string)
-	return "'" + string + "'"
+	return Properties.scpi_quotes + string + Properties.scpi_quotes
 
 
-def list_to_csv_str(value: list) -> str:
+def list_to_csv_str(value: List, delimiter: str = ',') -> str:
 	"""Converts list of elements to strings separated by commas.
 	Element types can differ on an individual basis.
 	Supported element types:
 	- int
 	- bool
 	- float
 	- string -> string no quotes
@@ -345,18 +383,18 @@
 	assert_list_data(value)
 	result = []
 	for x in value:
 		el = value_to_str(x)
 		if not el:
 			raise TypeError(f"List element type is not supported by Conversions.list_to_csv_str: '{x}'")
 		result.append(el)
-	return ','.join(result)
+	return delimiter.join(result)
 
 
-def list_to_csv_quoted_str(value: list) -> str:
+def list_to_csv_quoted_str(value: List) -> str:
 	"""Converts list of elements to quoted strings separated by commas.
 	Only string elements are enclosed by single quotes
 	Element types can differ on an individual basis.
 	Supported element types:
 	- int
 	- bool
 	- float
@@ -368,29 +406,28 @@
 		if isinstance(x, str):
 			el = str_enclose_by_quotes(x)
 		else:
 			el = value_to_str(x)
 		if not el:
 			raise TypeError(f"List element type is not supported by Conversions.list_to_csv_quoted_str: '{x}'")
 		result.append(el)
-
 	return ','.join(result)
 
 
 def decimal_value_to_str(x: int or float) -> str:
 	"""Converts scalar decimal value to string.
 	Supported element types:
 	- int
 	- float"""
 	if isinstance(x, int) and type(x) is not bool:
 		return str(x)
 	elif isinstance(x, float):
 		return float_to_str(x)
 	else:
-		raise Exception(f"decimal_value_to_str: unsupported variable type '{type(x)}', value '{x}'. Only integer and float types are supported.")
+		raise RsInstrException(f"decimal_value_to_str: unsupported variable type '{type(x)}', value '{x}'. Only integer and float types are supported.")
 
 
 def decimal_or_bool_value_to_str(x: int or float or bool) -> str:
 	"""Converts scalar decimal value to string.
 	Supported element types:
 	- int
 	- float
@@ -398,15 +435,15 @@
 	if type(x) is bool:
 		return bool_to_str(x)
 	if isinstance(x, int):
 		return str(x)
 	elif isinstance(x, float):
 		return float_to_str(x)
 	else:
-		raise Exception(f"decimal_or_bool_value_to_str: unsupported variable type '{type(x)}', value '{x}'. Only integer, float and boolean types are supported.")
+		raise RsInstrException(f"decimal_or_bool_value_to_str: unsupported variable type '{type(x)}', value '{x}'. Only integer, float and boolean types are supported.")
 
 
 def value_to_str(x: int or bool or float or str or Enum) -> str:
 	"""Converts scalar value to string.
 	Supported element types:
 	- int
 	- bool
@@ -418,17 +455,19 @@
 	elif isinstance(x, int):
 		return str(x)
 	elif isinstance(x, float):
 		return float_to_str(x)
 	elif isinstance(x, str):
 		return x
 	elif isinstance(x, Enum):
+		if isinstance(x.value, str):
+			return enum_value_to_scpi_string(x.value)
 		return enum_value_to_scpi_string(x.name)
 	else:
-		raise Exception(f"value_to_str: unsupported variable type '{type(x)}', value '{x}'. Supported types: int, bool, float, str, enum.")
+		raise RsInstrException(f"value_to_str: unsupported variable type '{type(x)}', value '{x}'. Supported types: int, bool, float, str, enum.")
 
 
 def enum_value_to_scpi_string(enum_value: str) -> str:
 	"""Conversion EnumValue -> SCPI_String
 	Unescapes all the special characters that can not be contained in the enum member definition, but can be sent to the instrument as enum string.
 	Use this to send the scpi enum value to the instrument."""
 	for key in enum_spec_prefixes:
@@ -443,15 +482,15 @@
 	"""Converts scalar value to string enclosed by single quotes.
 	Supported element types:
 	- int
 	- bool
 	- float
 	- string
 	- enum"""
-	return f"'{value_to_str(x)}'"
+	return Properties.scpi_quotes + value_to_str(x) + Properties.scpi_quotes
 
 
 def str_to_float_list(string: str) -> List[float]:
 	"""Converts string with comma-separated values to list of Floats."""
 	assert_string_data(string)
 	if not string:
 		return []
@@ -504,103 +543,158 @@
 		return []
 	result = [*map(Utilities.trim_str_response, string.split(','))]
 	if clear_one_empty_item and len(result) == 1 and result[0] == '':
 		return []
 	return result
 
 
-def _find_in_enum_members(item: str, enum_members: List[str]) -> int:
-	"""Matches a string in the provided list of member strings.
-	The item must be not fully matched.
-	The item is matched if a member string starts with the item (the item is a prefix of the member).
-	Example: item='CONN' will match the enum_member 'CONNected'
-	If the item contains a comma, only the value before comma is considered
-	Returns found index in the enum_members list"""
-	if ',' in item:
-		item = item[:item.index(',')].strip()
-	i = 0
-	for x in enum_members:
-		if x.startswith(item):
-			return i
-		i += 1
-
-	# smart matching:
-	# item = 'MAX' matches enum 'MAXpeak'
-	# item = 'SPECtrum1' matches enum 'SPEC1'
-	# item = 'SPEC' matches enum 'SPECtrum1'
-
-	item = ''.join([c for c in item if not c.islower()])
-	# item must be longer than 1 character
-	if len(item) < 2:
-		return -1
-	i = 0
-	for x in enum_members:
-		x_uc = ''.join([c for c in x if not c.islower()])
-		if x_uc == item:
-			return i
-		i += 1
-	return -1
-
-
-def str_to_scalar_enum_helper(string: str, enum_type: Enum, enum_members=None) -> Enum:
+def str_to_scalar_enum_helper(string: str, scpi_enum: ScpiEnum, array_search: bool, exc_if_not_found) -> Enum:
 	"""Converts string to one enum element.
-	enum_members are optional to improve the performance for repeated conversions.
-	If you do not provide them, they are generated inside the function."""
-	value = Utilities.trim_str_response(string)
-	if not enum_members:
-		# noinspection PyTypeChecker
-		enum_members = [x.name for x in enum_type]
-
-	# Search in the enum member and return the index of the matched item
-	ix = _find_in_enum_members(value, enum_members)
-	if ix >= 0:
-		# noinspection PyUnresolvedReferences
-		return enum_type[enum_members[ix]]
-
-	# If the result is -1 (not found), try to replace the special values and search again
-	# This is done to improve the performance, since most of the enums have no special values
-	enum_members_conv = [enum_value_to_scpi_string(x) for x in enum_members]
-	ix = _find_in_enum_members(value, enum_members_conv)
-	if ix >= 0:
-		# noinspection PyUnresolvedReferences
-		return enum_type[enum_members[ix]]
-
+	array_search signal no need to force the comma removing,
+	because the elements definitely do not have any commas - commas have been used to split string to the list of strings
+	The function can also return:
+	- integer special value, if the string was not found in the enum, and it is a special value.
+	- input string, if the string was not found and raise_if_not_found is set to False - used for the EnumExt types."""
+	if scpi_enum.has_quotes:
+		value = Utilities.trim_str_response(string, mode=Utilities.TrimStringMode.white_chars_double_quotes)
+	else:
+		value = Utilities.trim_str_response(string)
+	enum_value = scpi_enum.find_in_enum_members(value, False)
+	if enum_value is not None:
+		return enum_value
+	if array_search is False:
+		# If the result is still -1 (not found), try to force removing the comma in the string.
+		enum_value = scpi_enum.find_in_enum_members(value, True)
+		if enum_value is not None:
+			return enum_value
 	# If not found, search in the special integer numbers:
 	spec_value = str_special_values_to_int(value)
-	if not spec_value:
-		raise Exception(f"String '{value}' can not be found in the enum type '{enum_type}'")
+	if spec_value:
+		# noinspection PyTypeChecker
+		return spec_value
+	if exc_if_not_found:
+		raise RsInstrException(f"String '{value}' can not be found in the enum type '{scpi_enum.enum_type}'")
 	# noinspection PyTypeChecker
-	return spec_value
+	return Utilities.trim_str_response(string)
 
 
-def str_to_list_enum_helper(string: str, enum_type: Enum, enum_members=None) -> List[Enum]:
-	"""Converts string to list of enum elements.
-	enum_members are optional to improve the performance for repeated conversions.
-	If you do not provide them, they are generated inside the function."""
-	if not enum_members:
-		# noinspection PyTypeChecker
-		enum_members = [x.name for x in enum_type]
+def str_to_simple_scalar_enum(string: str, enum_type, case_sensitive: bool = True, ignore_underscores: bool = False) -> Enum or None:
+	"""Converts string to one enum element.
+	Does not handle special value or non-mandatory parts.
+	The function is used in core only for standard enum conversions, not for SCPI enum conversions."""
+	value = Utilities.trim_str_response(string)
+	enum_members = [x.name for x in enum_type]
+	enum_members_mod = [x.name for x in enum_type]
+	if not case_sensitive:
+		enum_members_mod = [x.upper() for x in enum_members]
+		value = value.upper()
+	if ignore_underscores:
+		enum_members_mod = [x.replace('_', '') for x in enum_members_mod]
+		value = value.replace('_', '')
+	if value in enum_members_mod:
+		return enum_type[enum_members[enum_members_mod.index(value)]]
+	return None
+
+
+def str_to_list_enum_helper(string: str, scpi_enum: ScpiEnum, exc_if_not_found: bool = True) -> List[Enum]:
+	"""Converts string to list of enum elements. separated by comma"""
 	elements = string.split(',')
-	return [str_to_scalar_enum_helper(x, enum_type, enum_members) for x in elements]
+	return [str_to_scalar_enum_helper(x, scpi_enum, True, exc_if_not_found) for x in elements]
 
 
 def enum_scalar_to_str(data, enum_type) -> str:
 	"""Converts enum scalar value to string."""
 	assert isinstance(data, enum_type), f"Expected command parameter {enum_type}, actual data type: {type(data)}. Value: {data}"
 	return value_to_str(data)
 
 
+def enum_ext_scalar_to_str(data, enum_type) -> str:
+	"""Converts enum scalar value to string.
+	If the input value is string, the function returns the string with single quotes."""
+	if isinstance(data, str):
+		# Return string with quotes
+		return value_to_quoted_str(Utilities.trim_str_response(data))
+	assert isinstance(data, enum_type), f"Expected command parameter string or {enum_type}, actual data type: {type(data)}. Value: {data}"
+	return value_to_str(data)
+
+
 def enum_list_to_str(data: List, enum_type) -> str:
 	"""Converts enum list to csv-string."""
 	# For enums, check that each element is an enum
 	assert all(isinstance(x, enum_type) for x in data), f"Expected command parameter list of {enum_type}, detected one or more elements of non-enum type. Value: {data}"
 	return list_to_csv_str(data)
 
 
+def enum_ext_list_to_str(data: List, enum_type) -> str:
+	"""Converts enum list to csv-string. Allows the elements to be either enum or string."""
+	assert all((isinstance(x, enum_type or str) or isinstance(x, str)) for x in data), f"Expected command parameter list of strings or {enum_type}, detected one or more elements of non-enum/non-string type. Value: {data}"
+	return list_to_csv_quoted_str(data)
+
+
 def str_to_scalar_enum(string: str, enum_type) -> Enum:
-	"""Converts string to one enum element."""
-	return str_to_scalar_enum_helper(string, enum_type)
+	"""Converts string to one enum element.
+	Throws exception if the string can not be converted to an enum element or a special value."""
+	return str_to_scalar_enum_helper(string, ScpiEnum(enum_type), False, exc_if_not_found=True)
+
+
+def str_to_scalar_enum_ext(string: str, enum_type) -> Enum:
+	"""Converts string to one enum element.
+	Compared to str_to_scalar_enum, in case the string can not be converted, it is returned trimmed for quotes and ."""
+	return str_to_scalar_enum_helper(string, ScpiEnum(enum_type), False, exc_if_not_found=False)
 
 
 def str_to_list_enum(string: str, enum_type) -> List[Enum]:
 	"""Converts string to list of enum elements."""
-	return str_to_list_enum_helper(string, enum_type)
+	return str_to_list_enum_helper(string, ScpiEnum(enum_type))
+
+
+def str_to_list_enum_ext(string: str, enum_type) -> List[Enum]:
+	"""Converts string to list of enum or string elements."""
+	return str_to_list_enum_helper(string, ScpiEnum(enum_type), exc_if_not_found=False)
+
+
+def convert_ts_to_datetime(timestamp: datetime or float) -> datetime:
+	"""Converts timestamp as float to datetime. For datetime tuple it just passes the value."""
+	if isinstance(timestamp, float) or isinstance(timestamp, int):
+		return datetime.fromtimestamp(timestamp)
+	return timestamp
+
+
+def get_timestamp_string(timestamp: datetime or float) -> str:
+	"""Returns the timestamp as string. The timestamp can be a datetime tuple or float seconds coming from the time.time()."""
+	timestamp = convert_ts_to_datetime(timestamp)
+	cur_time = timestamp.strftime('%H:%M:%S.%f')[:-3]
+	return cur_time
+
+
+def get_timedelta_fixed_string(time_start: datetime or float, time_end: datetime or float) -> str:
+	"""Returns the time span as string - fixed in the format of '%H:%M:%S.%f'."""
+	time_a = convert_ts_to_datetime(time_start)
+	time_b = convert_ts_to_datetime(time_end)
+	frac = (time_b - time_a).total_seconds()
+	wh = math.floor(frac)
+	d = int(wh / 86400)
+	h = int((wh - (d * 86400)) / 3600)
+	m = int((wh - (d * 86400 + h * 3600)) / 60)
+	s = int((wh - (d * 86400 + h * 3600 + m * 60)))
+	ms = int((frac - wh) * 1000)
+	res = f'{h:02d}:{m:02d}:{s:02d}.{ms:03d}'
+	if d > 0:
+		res = f'{d}d ' + res
+	return res
+
+
+def get_timedelta_string(time_a: datetime or float, time_b: datetime or float) -> str:
+	"""Returns the time span as string - dynamic based on the difference."""
+	time_a = convert_ts_to_datetime(time_a)
+	time_b = convert_ts_to_datetime(time_b)
+	if time_b < time_a:
+		return '0.000 ms'
+	diff = time_b - time_a
+	if diff.seconds < 10:
+		return f'{diff.total_seconds() * 1000:0.3f} ms'
+	elif diff.seconds < 1000:
+		a = diff.total_seconds()
+		return f'{a:0.3f} secs'
+	hours, remainder = divmod(diff.seconds, 3600)
+	minutes, seconds = divmod(remainder, 60)
+	return f'{hours:02d}:{minutes:02d}:{seconds:02d}'
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/ConverterFromScpiString.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ConverterFromScpiString.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,28 +1,32 @@
+"""See the class docstring."""
+
 from enum import Enum
 
 from .Conversions import str_to_bool, str_to_int, str_to_int_or_bool, str_to_float, str_to_float_or_bool, str_to_scalar_enum_helper
 from .Conversions import str_to_str_list, str_to_bool_list, str_to_int_list, str_to_int_or_bool_list, str_to_float_list, str_to_float_or_bool_list, str_to_list_enum_helper
 from .Types import DataType
 from .Utilities import trim_str_response
+from .InstrumentErrors import RsInstrException
+from .ScpiEnums import ScpiEnum
 
 
 class ConverterFromScpiString:
 	"""Converter from SCPI response string to argument value
 	For list argument types, you must use the method get_one_element_value in a loop for each element.
 	Provides methods:
 	- get_one_element_value(str): returns one scalar value converted from the SCPI string.
 	- get_list_value(str): return complete list value converted from the SCPI string.
 	- get_value(str): calls either get_one_element_value or get_list_value() depending on the data type. \n
 	The reason for the different methods is, that sometimes the list data are interleaved with other arguments.
 	In order to parse them properly, the ArgStructStringParser module must be able to set the argument value element-by-element.
-	On the other side, the driver methods might want to set the whole argument value, because the result scpi string is a single argument response."""
+	The driver methods might want to set the whole argument value, because the result scpi string is a single argument response."""
 
 	def __init__(self, data_type: DataType, enum_type: Enum = None):
-		self.enum_type = enum_type
+		self.scpi_enum = None
 		self.data_type = data_type
 		self.element_type = self.data_type.element_type
 
 		if self.element_type == DataType.RawString:
 			self.converter = trim_str_response
 			self.list_converter = str_to_str_list
 
@@ -46,30 +50,29 @@
 			self.converter = str_to_float
 			self.list_converter = str_to_float_list
 
 		elif self.element_type == DataType.FloatExt:
 			self.converter = str_to_float_or_bool
 			self.list_converter = str_to_float_or_bool_list
 
-		elif self.element_type == DataType.Enum:
-			assert self.enum_type, f"For data type enum, you have to define the enum_type variable."
+		elif self.element_type.is_scalar_enum:
+			assert enum_type, f"For data type enum, you have to define the enum_type variable."
 			# noinspection PyTypeChecker
-			self.enum_members = [x.name for x in self.enum_type]
+			self.scpi_enum = ScpiEnum(enum_type)
 		else:
-			raise Exception(f"Unsupported data type '{data_type}'")
+			raise RsInstrException(f"Unsupported data type '{data_type}'")
 
 	def get_one_element_value(self, scpi_string: str):
-		"""Returns single element !!! of the argument value converted from the SCPI string (single element)"""
+		"""Returns single element (not an array!!!) of the argument value converted from the SCPI string (single element)"""
 		assert isinstance(scpi_string, str), f"Input parameter scpi_string must be string. Actual parameter: {type(scpi_string)}, value: {scpi_string}"
-		if self.element_type is DataType.Enum:
-			return str_to_scalar_enum_helper(scpi_string, self.enum_type, self.enum_members)
+		if self.element_type.is_scalar_enum:
+			return str_to_scalar_enum_helper(scpi_string, self.scpi_enum, False, exc_if_not_found=self.element_type == DataType.Enum)
 		return self.converter(scpi_string)
 
 	def get_value(self, scpi_string: str):
 		"""Returns complete value of the argument converted from the SCPI string (list or scalar)"""
 		if not self.data_type.is_list:
 			return self.get_one_element_value(scpi_string)
-
 		assert isinstance(scpi_string, str), f"Input parameter scpi_string must be string. Actual parameter: {type(scpi_string)}, value: {scpi_string}"
 		if self.element_type is DataType.Enum:
-			return str_to_list_enum_helper(scpi_string, self.enum_type, self.enum_members)
+			return str_to_list_enum_helper(scpi_string, self.scpi_enum, exc_if_not_found=self.element_type == DataType.Enum)
 		return self.list_converter(scpi_string)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/ConverterToScpiString.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/ConverterToScpiString.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,19 @@
+"""See the class docstring."""
+
 from enum import Enum
 
-from .Conversions import list_to_csv_quoted_str, value_to_quoted_str, list_to_csv_str, value_to_str, enum_list_to_str, enum_scalar_to_str
+from .Conversions import list_to_csv_quoted_str, value_to_quoted_str, list_to_csv_str, value_to_str, enum_list_to_str, enum_scalar_to_str, enum_ext_scalar_to_str, enum_ext_list_to_str
 from .Types import DataType
+from .InstrumentErrors import RsInstrException
 
 
-def value_to_scpi_string(data, data_type: DataType):
-	"""Method to be used in the driver implementation.
-	Convert data to SCPI string parameter: data -> str"""
+def value_to_scpi_string(data, data_type: DataType) -> str:
+	"""Convert data to SCPI string parameter: data -> str.
+	Does not work with enum data types."""
 	if data_type.is_list:
 		assert isinstance(data, list), f"Expected command parameter list, actual data type: {type(data)}. Value: {data}"
 	else:
 		assert not isinstance(data, list), f"Expected command parameter scalar, actual data type: {type(data)}. Value: {data}"
 	# Strings are enclosed by single quotes
 	if data_type == DataType.StringList:
 		assert all(isinstance(x, str) for x in data), f"Expected command parameter list of strings, detected one or more elements of non-string type. Value: {data}"
@@ -46,35 +49,37 @@
 	elif data_type == DataType.IntegerExtList or data_type == DataType.FloatExtList:
 		assert all((isinstance(x, int) or isinstance(x, float) or isinstance(x, bool)) for x in data), f"Expected command parameter list of numbers or booleans, detected one or more elements of non-number type. Value: {data}"
 		return list_to_csv_str(data)
 	elif data_type == DataType.IntegerExt or data_type == DataType.FloatExt:
 		assert (isinstance(data, int) or isinstance(data, float) or isinstance(data, bool)), f"Expected command parameter number or boolean, actual data type: {type(data)}. Value: {data}"
 		return value_to_str(data)
 	else:
-		raise Exception(f"Unsupported data type: '{type(data_type)}'.")
+		raise RsInstrException(f"Unsupported data type: '{type(data_type)}'.")
 
 
 class ConverterToScpiString:
 	"""Converter from argument value to SCPI string.
 	Provides method get_value(arg_value) -> str
 	"""
 
 	def __init__(self, data_type: DataType, enum_type: Enum = None):
 		self.enum_type = enum_type
 		self.data_type = data_type
 		self.element_type = self.data_type.element_type
-		if self.element_type == DataType.Enum:
+		if self.element_type == DataType.Enum or self.element_type == DataType.EnumExt:
 			assert self.enum_type, f"For data_type {data_type.name}, you have to define the enum_type variable."
 
 	def get_value(self, data) -> str:
 		"""Returns SCPI string converted from the argument data."""
 		if self.data_type.is_list:
 			assert isinstance(data, list), f"Expected command parameter list, actual data type: {type(data)}. Value: {data}"
 		else:
 			assert not isinstance(data, list), f"Expected command parameter scalar, actual data type: {type(data)}. Value: {data}"
-
 		if self.data_type == DataType.Enum:
 			return enum_scalar_to_str(data, self.enum_type)
-		elif self.data_type == DataType.EnumList:
+		if self.data_type == DataType.EnumExt:
+			return enum_ext_scalar_to_str(data, self.enum_type)
+		if self.data_type == DataType.EnumList:
 			return enum_list_to_str(data, self.enum_type)
-
+		if self.data_type == DataType.EnumExtList:
+			return enum_ext_list_to_str(data, self.enum_type)
 		return value_to_scpi_string(data, self.data_type)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/Core.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/Core.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,28 +1,126 @@
-import re
+"""See the class docstring."""
+
 from typing import Callable
 
-from . import InstrumentOptions as Options, Conversions as Conv
+from . import InstrumentOptions as Options
 from .ArgSingle import ArgSingle
 from .ArgSingleList import ArgSingleList
 from .Conversions import BinFloatFormat, BinIntFormat
 from .Instrument import Instrument
-from .InstrumentSettings import InstrViClearMode, InstrumentSettings, WaitForOpcMode
-from .Utilities import parse_token_to_key_and_value, trim_str_response
+from .InstrumentSettings import InstrViClearMode, InstrumentSettings, WaitForOpcMode, OpcSyncQueryMechanism
+from .ScpiLogger import LoggingMode
+from .InstrumentErrors import RsInstrException
+from .Properties import Properties
 
 
 class Core(object):
 	"""Main driver component. Provides: \n
 		- Main core constructor
 		- 'io' interface for all the write / query operations
 		- Command parameters string composer for single arguments...
 		- Link handlers adding / changing / deleting
 
 		Version history:
 
+		1.70.0 (27.02.2024)
+			- Added settings profile 'XK41' for R&S Software Defined Radios.
+			- Added settings 'FirstCmds' where you can send the defined commands right after the init. Send more commands in a row with ';;' separator.
+			- Added settings 'EachCmdPrefix' - this prefix is added to each command sent to the instrument. Supported values are also 'lf', 'cr', 'tab'
+
+		1.60.0 (31.01.2024)
+			- Added Properties script for global properties.
+			- Added Properties.scpi_quotes, string option settings token: 'ScpiQuotes'. Example: ScpiQuotes=double. Default: Single
+			- Fixed VisaPluginSocketIo read() method for cases where the session is lost. The method now generates exception in that case.
+			- Added settings 'OpcSyncQueryMechanism' with values: Standard, AlsoCheckMav, ClsOnlyCheckMavErrQueue, OnlyCheckMavErrQueue
+
+		1.54.0 (27.06.2023)
+			- Added new options profile for ATS chambers.
+			- Added settings boolean token EachCmdAsQuery. Example: EachCmdAsQuery=True. Default: False
+
+		1.53.0 (18.10.2022)
+			- Improved mode where the instrument works with a session from another object.
+			- Silently ignoring invalid *IDN? string.
+			- Added new options profile 'Minimal' for non-SCPI-99 instruments.
+
+		1.52.0 (28.09.2022)
+			- Fixed DisableOpcQuery=True settings effect.
+			- Improved robustness of the TerminationCharacter option value entry.
+			- Added new options profile for CMQ500.
+
+		1.51.0 (08.09.2022)
+			- Changed the accepted IDN? response to more permissive.
+			- added methods go_to_remote() and go_to_local()
+			- added methods file_exists() and get_file_size()
+
+		1.50.0 (23.06.2022)
+			- Added relative timestamp to the logger.
+			- ScpiLogger can read GlobalData class variables making it possible to define common target and reference timestamp for all instances.
+			- Logger stream entries are by default immediately flushed, making sure that the log is complete.
+			- Added time statistic methods get_total_execution_time(), get_total_time(), reset_time_statistics().
+
+		1.24.0 (03.06.2022)
+			- Changed parsing of SYST:ERR? response to tolerate +0,"No Error" response.
+			- Added settings integer token OpenTimeout. Example: OpenTimeout=5000. Default: 0
+			- Added settings boolean token ExclusiveLock. Example: ExclusiveLock=True. Default: False
+
+		1.23.0 (24.05.2022)
+			- Added stripping of trailing commas when parsing the *IDN? response.
+			- If the Resource Manager does not find any default VISA implementation, it falls back to R&S VISA - relevant for LINUX or macOS
+			- Other typos and formatting corrections.
+
+		1.22.0 (20.04.2022)
+			- Added optional parameter timeout to reset()
+			- Added query list methods:  query_bool_list, query_bool_list_with_opc
+
+		1.21.0 (07.01.2022)
+			- Added logging to UDP port (49200) to integrate with new R&S Instrument Control plugin for Pycharm
+
+		1.20.0 (19.11.2021)
+			- Fixed logging strings when device name was a substring of the resource name
+
+		1.18.0 (build 64) 05.11.2021
+			- Added setting profile for non-standard instruments. Example of the options string: options='Profile=hm8123'
+
+		1.17.0 (build 63) 15.10.2021
+			- Added correct conversion of strings with SI suffixes (e.g.: MHz, KHz, THz, GHz, ms, us) to float and integer
+
+		1.16.0 (build 62) 31.08.2021
+			- Changed default encoding of string<=>bin from utf-8 to charmap.
+			- Added settable encoding for the session. Property: RsInstrument.encoding
+
+		1.15.0 (build 61) 17.08.2021
+			- Added support for EnumExt and EnumExtList
+			- Added support for custom scpi enums
+			- Improved exception handling in cases where the instrument session is closed.
+			- Fixed warning in Instrument.py
+			- Fixed Instrument.query_bin_block() for timeout errors
+			- Repeated capabilities are now allowed to be integer numbers as well
+
+		1.14.0 (build 53) 12.07.2021
+			- Scpi logger time entries now support not only datetime tuples, but also float timestamps
+			- changed handling of the syst:err? responses - now they are always Tuple (code, message)
+			- StatusException has new field errors_list: List[ Tuple[code, message] ]
+			- Added logger.log_status_check_ok property. This allows for skipping lines with 'Status check: OK'
+
+		1.12.0 (build 50) 26.06.2021
+			- Added SCPI Logger
+			- Simplified constructor's options string format - removed DriverSetup=() syntax:
+			Instead of "DriverSetup=(TerminationCharacter='\n')", you use "TerminationCharacter='\n'"
+			The original format is still supported.
+
+			- Fixed calling SYST:ERR? even if *STB? returned 0
+			- Replaced @ni backend with @ivi for resource manager - this is necessary for the future pyvisa version 1.12+
+
+		1.11.0 (build 49) 09.06.2021
+			- Added is_connection_active() + reconnect()
+
+		1.10.1 (build 47) 01.06.2021
+			- Fixed bug with error checking when events are defined
+
 		1.10.0 (build 46) 03.05.2021
 			- Added methods to Instrument: query_struct_with_opc(), query_str_suppressed_with_opc()
 
 		1.9.0 (build 45) 13.04.2021
 			- Added option to set callbacks before_write and before_query
 			- When a RepCap has a member with integer number 0 defined, the command string interpretation of such member is '0', not empty string
 
@@ -32,15 +130,15 @@
 		1.7.7 (build 42) 26.11.2020
 			- Extended ArgSingleList.compose_cmd_string() to 9 arguments
 
 		1.7.6 (build 41) 23.11.2020
 			- Extended data types for IntegerExt, FloatExt, IntegerExtArray, FloatExtArray
 
 		1.7.5 (build 40) 12.11.2020
-			- Extended Conversions method str_to_str_list() by parameter 'clear_one_empty_item' with default value False
+			- Extended 'Conversions' method str_to_str_list() by parameter 'clear_one_empty_item' with default value False
 
 		1.7.4 (build 39) 11.09.2020
 			- Fixed parsing of the instrument errors when an error message contains two double quotes
 
 		1.7.3 (build 38) 21.10.2020
 			- Added 'UND' to the list of float numbers that are represented as NaN
 
@@ -60,15 +158,15 @@
 
 		1.4.0 (build 32) 17.09.2020
 			- Added recognition of RsVisa library location for linux when using options string 'SelectVisa=rs'
 			- Fixed bug in reading binary data 16 bit
 
 		1.3.0 (build 31) 04.09.2020
 			- added DRIVERSETUP_QUERYOPT to the driver's option string
-			- *OPT? is no longer performed at the init, but only at the first access to options string.
+			- *OPT? is no longer performed at the init, but only at the first access to the options string.
 				In addition, the *OPT? query is executed with 1000 ms timeout, and the errors are suppressed
 
 		1.2.0 (build 30), 03.08.2020
 			- Fixed NRP-Z session parameters: vxi_capable = False, io_segment_size = 1000000
 
 		1.1.0 (build 29), 20.06.2020
 			- Added RepeatedCapability and base class CommandsGroup
@@ -89,85 +187,94 @@
 			reset: bool = False,
 			driver_options: str = None,
 			user_options: str = None,
 			direct_session: object = None):
 		"""Initializes new driver session. For cleaner code, use the class methods: \n
 		- Core.from_existing_session() - initializes a new Core with an existing pyvisa session."""
 
-		self.core_version = '1.9.0'
-		self.simulating = False
-		self.supported_idn_patterns = []
-		self.supported_instr_models = []
-
-		self._args_single_list = ArgSingleList()
-		sett_dr = self._parse_init_settings_string(driver_options)
-		self._apply_settings_to_core(sett_dr)
-		sett_user = self._parse_init_settings_string(user_options)
-		self._apply_settings_to_core(sett_user)
+		self.core_version = '1.55.0'
+		self.resource_name = resource_name
 
 		# Typical settings for the Core
 		self._instrumentSettings = InstrumentSettings(
 			InstrViClearMode.execute_on_all,  # Instrument viClear mode
 			False,  # Full model name. True: SMW200A, False: SMW
 			0,  # Delay by each write
 			0,  # Delay by each read
-			100000,  # Max chunk read / write size in bytes
+			1000000,  # Max chunk read / write size in bytes
 			WaitForOpcMode.stb_poll,  # Waiting for OPC Mode: Status byte polling
 			30000,  # OPC timeout
 			10000,  # VISA timeout
 			60000,  # Self-test timeout
 			Options.ParseMode.Auto,  # *OPT? response parsing mode
 			BinFloatFormat.Single_4bytes,  # Format for parsing of binary float numbers
 			BinIntFormat.Integer32_4bytes,  # Format for parsing of binary integer numbers
-			False  # OPC query after each setting
+			False,  # OPC query after each setting
+			LoggingMode.Off,
+			OpcSyncQueryMechanism.only_check_mav_err_queue
+			# Logging mode
 		)
 
-		self._instrumentSettings.apply_option_settings(sett_dr)
-		self._instrumentSettings.apply_option_settings(sett_user)
+		self._instrumentSettings.apply_option_settings(driver_options)
+		self._instrumentSettings.apply_option_settings(user_options)
 
-		# Resolve the direct_session to handle. Options for direct_session type:
-		# - VisaSession object, retrieved from the driver's RsInstrument.get_session_handle() method
-		# - string in case of a simulation session
-		handle = direct_session
-		if handle:
-			# Check if the entered 'direct_session' is either the driver object or the Visa session
-			if hasattr(direct_session, 'get_session_handle'):
-				assert hasattr(direct_session, '_core'), f"Direct session is a class type. It must be an instance of the top-level driver class."
-				handle = direct_session.get_session_handle()
-			# Check if the handle is not a simulation mode string
-			if isinstance(handle, str):
-				if "Simulating session, resource name " in handle:
-					self.simulating = True
-					handle = None
+		self.simulating = self._instrumentSettings.simulating
+		self.supported_idn_patterns = self._instrumentSettings.supported_idn_patterns
+		self.supported_instr_models = self._instrumentSettings.supported_instr_models
 
-		self.io = Instrument(resource_name, self.simulating, self._instrumentSettings, handle)
+		self._args_single_list = ArgSingleList()
+		handle = self._resolve_direct_session(direct_session)
+		self.io = Instrument(self.resource_name, self.simulating, self._instrumentSettings, handle)
 		self.io.query_instr_status = True
+		# Update the resource name if it changed, for example because of the direct session
+		self.resource_name = self.io.resource_name
+		self.allow_reconnect = self.io.allow_reconnect
 
-		self._apply_settings_to_instrument(sett_dr)
-		self._apply_settings_to_instrument(sett_user)
-
+		self._apply_settings_to_instrument(self._instrumentSettings)
+		self._apply_global_properties(self._instrumentSettings)
 		self.io.set_simulating_cmds()
 
 		if id_query:
 			self.io.fits_idn_pattern(self.supported_idn_patterns, self.supported_instr_models)
 
 		if reset:
 			self.io.reset()
 		else:
 			self.io.check_status()
 
 	@classmethod
 	def from_existing_session(cls, session: object, driver_options: str = None) -> 'Core':
 		"""Creates a new Core object with the entered 'session' reused."""
 		# noinspection PyTypeChecker
-		return cls(None, False, False, driver_options, None, session)
+		return cls(resource_name=None, id_query=False, reset=False, driver_options=driver_options, user_options=None, direct_session=session)
 
 	def __str__(self):
 		return f"Core session '{self.io.resource_name}'"
 
+	def _resolve_direct_session(self, direct_session):
+		# Resolve the direct_session to handle. Options for direct_session type:
+		# - VisaSession object, retrieved from the driver's RsInstrument.get_session_handle() method
+		# - string in case of a simulation session
+		handle = direct_session
+		if not direct_session:
+			return None
+		# Check if the entered 'direct_session' is either the driver object or the Visa session
+		if hasattr(direct_session, 'get_session_handle'):
+			if not hasattr(direct_session, '_core'):
+				raise RsInstrException('Direct session is a class type. It must be an instance of the top-level driver class.')
+			handle = direct_session.get_session_handle()
+		# If the handle is a simulating session, change the session to simulating and set disable the 'from existing session' feature
+		if isinstance(handle, str):
+			mand_string = 'Simulating session, resource name '
+			if mand_string in handle:
+				self.resource_name = handle[len(mand_string):].strip().strip("'").strip()
+				self.simulating = True
+				handle = None
+		return handle
+
 	def set_link_handler(self, link_name: str, handler: Callable) -> Callable:
 		"""Adds / Updates link handler for the entered link_name.
 		Handler API: handler(event_args: ArgLinkedEventArgs)
 		Returns the previous registered handler, or None if no handler was registered before."""
 		return self.io.set_link_handler(link_name, handler)
 
 	def del_link_handler(self, link_name: str) -> Callable:
@@ -176,82 +283,30 @@
 		return self.io.del_link_handler(link_name)
 
 	def del_all_link_handlers(self) -> int:
 		"""Deletes all the link handlers.
 		Returns number of deleted links."""
 		return self.io.del_all_link_handlers()
 
-	# noinspection PyMethodMayBeStatic
-	def _parse_init_settings_string(self, text: str) -> dict:
-		"""Parses init string to a dictionary of settings: name -> value."""
-		tokens = {}
-		if not text:
-			return tokens
-
-		# Text enclosed in single brackets '' must have the commas escaped
-		literal_pattern = r"'([^']+)'"
-		while True:
-			# literal loop
-			m = re.search(literal_pattern, text)
-			if not m:
-				break
-			lit_part = '"' + m.group(1).replace(',', '<COMMA_ESC>') + '"'
-			text = text.replace(m.group(0), lit_part)
-
-		# Remove all the class-options enclosed by round brackets e.g. "<groupName>=(<groupTokens>)"
-		group_pattern = r'(\w+)\s*=\s*\(([^\)]*)\)'
-		# Match class-settings, add them as separate keys with groupName_Key
-		while True:
-			# Group loop
-			m = re.search(group_pattern, text)
-			if not m:
-				break
-			text = text.replace(m.group(0), '')
-			group_name = m.group(1).upper()
-			group_tokens = m.group(2).strip().split(',')
-			for token in group_tokens:
-				key, value = parse_token_to_key_and_value(token)
-				if value:
-					tokens[f'{group_name}_{key.upper()}'] = value
-
-		# All groups are removed from the text, now we can use splitting on commas and remove white-space-only elements
-		for token in text.split(','):
-			key, value = parse_token_to_key_and_value(token.replace('<COMMA_ESC>', ','))
-			if value:
-				tokens[key.upper()] = value
-		return tokens
-
-	def _apply_settings_to_core(self, settings: dict) -> None:
-		"""Applies settings relevant for the Core from the dictionary."""
-		value = settings.get('SIMULATE')
-		if value:
-			self.simulating = Conv.str_to_bool(value)
-
-		value = settings.get('SUPPORTEDINSTRMODELS')
-		if value:
-			self.supported_instr_models = [*map(trim_str_response, value.split('/'))]
-
-		value = settings.get('SUPPORTEDIDNPATTERNS')
-		if value:
-			self.supported_idn_patterns = [*map(trim_str_response, value.split('/'))]
-
-	def _apply_settings_to_instrument(self, settings: dict) -> None:
-		"""Applies settings relevant for the Instrument from the dictionary."""
-		value = settings.get('QUERYINSTRUMENTSTATUS')
-		if value:
-			self.io.query_instr_status = Conv.str_to_bool(value)
-
-		value = settings.get('SIMULATIONIDNSTRING')
-		if value and self.simulating:
-			# Use the '*' instead of the ',' in the value to avoid comma as token delimiter
-			self.io.idn_string = value.replace('*', ',')
+	def _apply_settings_to_instrument(self, settings: InstrumentSettings) -> None:
+		"""Applies settings relevant for the Instrument from the InstrumentSettings structure."""
+		if settings.instrument_status_check is not None:
+			self.io.query_instr_status = settings.instrument_status_check
+		if self.simulating and settings.instrument_simulation_idn_string is not None:
+			self.io.idn_string = settings.instrument_simulation_idn_string
+
+	@staticmethod
+	def _apply_global_properties(settings: InstrumentSettings) -> None:
+		"""Applies settings valid for the entire module. All are available in the module 'Properties'."""
+		if settings.scpi_quotes is not None:
+			Properties.scpi_quotes = settings.scpi_quotes
 
 	def compose_cmd_arg_param(
 			self, arg1: ArgSingle, arg2: ArgSingle = None, arg3: ArgSingle = None, arg4: ArgSingle = None, arg5: ArgSingle = None, arg6: ArgSingle = None) -> str:
-		"""Composes command parameter string based on the single arguments definition."""
+		"""Composes command parameter string based on the single argument definition."""
 		return self._args_single_list.compose_cmd_string(arg1, arg2, arg3, arg4, arg5, arg6)
 
 	def get_last_sent_cmd(self) -> str:
 		"""Returns the last commands sent to the instrument. Only works in simulation mode"""
 		return self.io.get_last_sent_cmd()
 
 	def get_session_handle(self):
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/InstrumentErrors.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/InstrumentErrors.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,63 +1,79 @@
+"""Definition of RsInstrument exceptions, assert functions, and other error-related functions."""
+
+from typing import List, Tuple
+
+
 class RsInstrException(Exception):
 	"""Exception base class for all the RsInstrument exceptions."""
 	def __init__(self, message: str):
 		super(RsInstrException, self).__init__(message)
+		self.message = message
 
 
 class TimeoutException(RsInstrException):
 	"""Exception for timeout errors."""
 	def __init__(self, message: str):
 		super(TimeoutException, self).__init__(message)
 
 
 class StatusException(RsInstrException):
-	"""Exception for instrument status errors."""
-	def __init__(self, rsrc_name: str, message: str):
-		self.rsrc_name = rsrc_name
+	"""Exception for instrument status errors.
+	Tje field  errors_list contains the complete list of all the errors with messages and codes."""
+	def __init__(self, rsrc_name: str, message: str, errors_list: List[Tuple[int, str]], first_exc: Exception = None):
+		self.rsrc_name: str = rsrc_name
+		self.first_exc: Exception = first_exc
+		self.errors_list: List[Tuple[int, str]] = errors_list
 		super(StatusException, self).__init__(message)
 
 
 class UnexpectedResponseException(RsInstrException):
 	"""Exception for instrument unexpected responses."""
 	def __init__(self, rsrc_name: str, message: str):
-		self.rsrc_name = rsrc_name
+		self.rsrc_name: str = rsrc_name
 		super(UnexpectedResponseException, self).__init__(message)
 
 
 class ResourceError(RsInstrException):
 	"""Exception for resource name - e.g. resource not found."""
 	def __init__(self, rsrc_name: str, message: str):
-		self.rsrc_name = rsrc_name
+		self.rsrc_name: str = rsrc_name
 		super(ResourceError, self).__init__(message)
 
 
 class DriverValueError(RsInstrException):
 	"""Exception for different driver value settings e.g. RepCap values or Enum values."""
 	def __init__(self, rsrc_name: str, message: str):
-		self.rsrc_name = rsrc_name
+		self.rsrc_name: str = rsrc_name
 		super(DriverValueError, self).__init__(message)
 
 
-def assert_no_instrument_status_errors(rsrc_name: str, errors: list, context: str = '') -> None:
-	"""Checks the errors list and of it contains at least one element, it throws StatusException."""
-	if errors is None:
-		return
-	if len(errors) == 0:
+def get_instrument_status_errors(rsrc_name: str, errors: List[Tuple[int, str]], context: str = '') -> str or None:
+	"""Checks the errors list and of it contains at least one element, it returns the error message.
+	Otherwise, it returns None."""
+	if errors is None or len(errors) == 0:
 		return
 	if context:
 		message = f"'{rsrc_name}': {context} "
 	else:
 		message = f"'{rsrc_name}': "
+	errors_msg = '\n'.join([f'{x[0]},"{x[1]}"' for x in errors])
 	if len(errors) == 1:
-		message += f'Instrument error detected: {errors[0]}'
-		raise StatusException(rsrc_name, message)
+		message += f'Instrument error detected: {errors_msg}'
+		return message
 	if len(errors) > 1:
-		message += '{} Instrument errors detected:\n{}'.format(len(errors), '\n'.join(errors))
-		raise StatusException(rsrc_name, message)
+		message += f'{len(errors)} Instrument errors detected:\n{errors_msg}'
+		return message
+
+
+def assert_no_instrument_status_errors(rsrc_name: str, errors: List[Tuple[int, str]], context: str = '', first_exc=None) -> None:
+	"""Checks the errors list and of it contains at least one element, it throws StatusException."""
+	msg = get_instrument_status_errors(rsrc_name, errors, context)
+	if msg:
+		raise StatusException(rsrc_name, msg, errors, first_exc=first_exc)
 
 
 def throw_opc_tout_exception(opc_tout: int, used_tout: int, context: str = '') -> None:
 	"""Throws TimeoutException - use it for any timeout error."""
 	if not context:
 		message = ''
 	else:
@@ -83,21 +99,21 @@
 
 def assert_query_has_qmark(query: str, context: str = '') -> None:
 	"""Throws Exception if the query does not contain any question marks."""
 	if '?' in query:
 		return
 	message = ''
 	if context:
-		message = ' ' + context
+		message = context.strip() + ': '
 	message = message + "Query commands must contain question-marks. Sent query: '{0}'".format(query.strip('\n'))
-	raise Exception(message)
+	raise RsInstrException(message)
 
 
 def assert_cmd_has_no_qmark(command: str, context: str = '') -> None:
 	"""Throws Exception if the query contains a question marks."""
 	if '?' not in command:
 		return
 	message = ''
 	if context:
-		message = ' ' + context
+		message = context.strip() + ': '
 	message = message + "Set commands must not contain question-marks. Sent command: '{0}'".format(command.strip('\n'))
-	raise Exception(message)
+	raise RsInstrException(message)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/InstrumentOptions.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/InstrumentOptions.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""See the class docstring."""
+
 import re
 from enum import Enum
 
 from .Utilities import trim_str_response
 
 
 class ParseMode(Enum):
@@ -10,14 +12,15 @@
 	KeepOriginal = 1
 	KeepBeforeDash = 2
 	KeepAfterDash = 3
 	Auto = 4
 
 
 class Options(object):
+	"""Class for handling the instrument options - parsing from the *OPT? string and providing method get_all()"""
 	_optionsList = []
 
 	def __init__(self, options_str: str, mode=ParseMode.Auto):
 		"""Initializes the options with the *OPT? return string."""
 		self._initialize_from_string(options_str, mode)
 
 	def __str__(self):
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/InternalLinker.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/InternalLinker.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,13 +1,16 @@
+"""Links a variable from a structure to a callback in the driver."""
+
 from time import time
 from typing import Dict, Callable
 
 from . import ArgSingle, ArgSingleSuppressed
 from .ArgLinkedEventArgs import ArgLinkedEventArgs
 from .Utilities import get_plural_string
+from .InstrumentErrors import RsInstrException
 
 
 class InternalLinker(object):
 	"""Class for:
 		- cutting out suppressed arguments from a device response.
 		- invoking a handler if the argument has InternalLinking defined.
 		- holds dictionary of handlers where the dict_key is the InternalLinking string.
@@ -44,22 +47,22 @@
 		Returns number of deleted links."""
 		count = len(self._handlers)
 		self._handlers = {}
 		return count
 
 	def cut_from_response_string(self, arg: ArgSingleSuppressed, response: str, context: str) -> str:
 		"""Takes the string 'response', removes the suppressed argument value from it and returns the rest.
-		The cut out part is sent via handler if the internal linking exists for that argument exists."""
+		The cut-out part is sent via handler if the internal linking exists for that argument exists."""
 		result = ''
 		if arg.argument_ix is None:
-			raise Exception(f'Argument has argument_ix attribute not assigned (equals None). Argument: {arg}')
+			raise RsInstrException(f'Argument has argument_ix attribute not assigned (equals None). Argument: {arg}')
 		if arg.argument_ix != 0:
-			raise Exception(f'Only arguments with index 0 can be suppressed. Argument: {arg}')
+			raise RsInstrException(f'Only arguments with index 0 can be suppressed. Argument: {arg}')
 		if arg.is_open_list:
-			raise Exception(f'Open List arguments can not be suppressed. Argument: {arg}')
+			raise RsInstrException(f'Open List arguments can not be suppressed. Argument: {arg}')
 		repetition = 0
 		i = 0
 		for c in response:
 			if c == ',':
 				repetition += 1
 			if repetition == arg.repetition:
 				break
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/IoTransferEventArgs.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/IoTransferEventArgs.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""See the docstring for the IoTransferEventArgs class."""
+
 import itertools
 from typing import AnyStr
 
 from .Utilities import size_to_kb_mb_string
 
 
 class IoTransferEventArgs(object):
@@ -48,25 +50,25 @@
 		return cls(True, opc_sync, None, context)
 
 	@classmethod
 	def write_str(cls, opc_sync: bool, total_size: int, context: str) -> 'IoTransferEventArgs':
 		"""Creates new IoTransferEventArgs of write string \n
 		:param opc_sync: defines if the command is OPC-synchronised
 		:param total_size: size of the data to write
-		:param context: SCPI command write. It is truncated to maximum of 100 characters.
-		:return: IoTransferEventArgs object of a write string operation."""
+		:param context: SCPI command write. It is truncated to maximum of 100 characters
+		:return: IoTransferEventArgs object of a write-string operation."""
 		obj = cls(False, opc_sync, total_size, context)
 		obj.binary = False
 		return obj
 
 	@classmethod
 	def write_bin(cls, context: str) -> 'IoTransferEventArgs':
 		"""Creates new IoTransferEventArgs of read binary data \n
 		:param context: SCPI command. It is truncated to maximum of 100 characters.
-		:return: IoTransferEventArgs object of a write binary data operation."""
+		:return: IoTransferEventArgs object of a write-binary-data operation."""
 		# noinspection PyTypeChecker
 		obj = cls(False, False, None, context.rstrip())
 		obj.binary = True
 		return obj
 
 	def __str__(self):
 		if self.binary:
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/RepeatedCapability.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/RepeatedCapability.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""See the docstring for the RepeatedCapability class."""
+
 from enum import Enum
 
 
 # Command integer value that signals Default value "DEFAULT"
 VALUE_DEFAULT = -1
 
 # Command integer value that signals "EMPTY"
@@ -26,39 +28,47 @@
 	def __str__(self) -> str:
 		out = f'RepCap {self.name}'
 		if self._enum_value is not None:
 			out += f" = {self._enum_value}"
 		return out
 
 	@classmethod
-	def clsm_assert_type(cls, enum_value: Enum, enum_type) -> None:
-		"""Static assertion function to check if the entered value is a member of the defined repcap enum"""
+	def clsm_assert_type(cls, enum_value: Enum or int, enum_type) -> None:
+		"""Static assertion function to check if the entered value is a member of the defined repcap enum.
+		In addition, the integer value is also supported."""
+		if isinstance(enum_value, int):
+			return
 		if not isinstance(enum_value, enum_type):
 			raise TypeError(f"RepCap value must be of type '{enum_type}'. Entered value type: {type(enum_value)}, value '{enum_value}'")
 
 	@classmethod
-	def clsm_get_direct_cmd_value_int(cls, enum_value: Enum, enum_type) -> int:
+	def clsm_get_direct_cmd_value_int(cls, enum_value: Enum or int, enum_type) -> int:
 		"""Static function to get an integer interpretation of a direct enum value
 		Does not work with Empty or Default"""
 		RepeatedCapability.clsm_assert_type(enum_value, enum_type)
+		if isinstance(enum_value, int):
+			return enum_value
 		return enum_value.value
 
 	@classmethod
-	def clsm_is_default_value(cls, enum_value: Enum, enum_type) -> bool:
+	def clsm_is_default_value(cls, enum_value: Enum or int, enum_type) -> bool:
 		"""Returns True, if the entered value is enum.Default"""
 		return cls.clsm_get_direct_cmd_value_int(enum_value, enum_type) == VALUE_DEFAULT
 
 	def is_default_value(self) -> bool:
 		"""Returns True, if the repcap value is enum.Default"""
 		return RepeatedCapability.clsm_is_default_value(self._enum_value, self.enum_type)
 
-	def set_enum_value(self, enum_value: Enum) -> None:
+	def set_enum_value(self, enum_value: Enum or int) -> None:
 		"""Sets new enum value. Can not be Default"""
 		if RepeatedCapability.clsm_is_default_value(enum_value, self.enum_type):
 			raise ValueError(f"Setting RepCap enum value '{enum_value}' is not allowed. Please select a concrete value")
+		if isinstance(enum_value, int):
+			# Find the enum value that corresponds to the entered integer value
+			enum_value = self.enum_type(enum_value)
 		self._enum_value = enum_value
 
 	def get_enum_value(self) -> Enum:
 		"""Returns the actual enum value"""
 		return self._enum_value
 
 	def set_to_start_value(self) -> None:
@@ -66,16 +76,17 @@
 		self.set_enum_value(self._start_value)
 
 	def matches_type(self, enum_type) -> bool:
 		"""Returns true, if the entered type matches the EnumType"""
 		return self.enum_type == enum_type
 
 	@classmethod
-	def clsm_get_cmd_string_value(cls, enum_value: Enum, enum_type) -> str:
-		"""Converts RepCap integer value to string
+	def clsm_get_cmd_string_value(cls, enum_value: Enum or int, enum_type) -> str:
+		"""Class method version of the get_cmd_string_value().
+		Converts RepCap integer value to string
 		ValueEmpty is converted to "" (Not valid, but tolerated)
 		ValueDefault throws an exception
 		0 is converted to "" (Not valid, but tolerated)
 		Positive numbers are converted to integer strings e.g. 1 => '1' """
 		number = cls.clsm_get_direct_cmd_value_int(enum_value, enum_type)
 		if number == VALUE_EMPTY:
 			return ''
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/StreamReader.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/StreamReader.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,19 @@
+"""See the docstring for the StreamReader class."""
+
 from enum import Enum
 from os import path
 from typing import AnyStr
 
 from .Utilities import size_to_kb_mb_string
+from .InstrumentErrors import RsInstrException
 
 
 class Type(Enum):
+	"""Defines type of the stream - variable or file."""
 	Variable = 1
 	File = 2
 
 
 class StreamReader:
 	"""Lightweight stream reader implementation. Data source can be: \n
 	- variable
@@ -21,31 +25,32 @@
 		:param source: Source type for the stream. Variable / File
 		:param data: Depending on the 'binary' and 'source':
 		For source type Variable the data must be either bytes() or str
 		For source type File data must be string with existing file path."""
 		self._source = source
 		self._binary = binary
 		self._start_ptr = 0
+		self._read_len = 0
 
 		if self._source == Type.Variable:
 			if self._binary:
 				assert isinstance(data, bytes), f'Data must be of bytes type. Actual type: {type(data)}'
 			else:
 				assert isinstance(data, str), f'Data must be of string type. Actual type: {type(data)}'
 			self._data = data
 			self._full_len = len(self._data)
 		elif self._source == Type.File:
 			assert isinstance(data, str), f'Data must be of string type (file path). Actual type: {type(data)}'
 			if not path.isfile(data):
-				raise Exception(f'File does not exist. File path: {data}')
+				raise RsInstrException(f'File does not exist. File path: {data}')
 			self.file_path = data
 			self._data = open(self.file_path, 'rb' if self._binary else 'r')
 			self._full_len = path.getsize(self.file_path)
 		else:
-			raise Exception(f'StreamReader unknown type {source}')
+			raise RsInstrException(f'StreamReader unknown type {source}')
 
 	@classmethod
 	def as_bin_var(cls, data: bytes) -> 'StreamReader':
 		"""Creates new StreamReader from bytes.
 		:param data: [bytes] data for the stream."""
 		return cls(True, Type.Variable, data)
 
@@ -100,29 +105,34 @@
 		If the remaining length is smaller than the chunk_size, the method returns the remaining length only.
 		:param chunk_size: chunk to read. If not set, the method reads the entire data."""
 		assert self._data is not None, 'StreamReader buffer is invalid. You have probably closed it already.'
 		chunk_size = len(self) if chunk_size is None else chunk_size
 		chunk_size = min(chunk_size, len(self))
 		if chunk_size < 0:
 			raise ValueError(f'Chunk size can not be negative number: {chunk_size}')
-
+		self._read_len += chunk_size
 		if self._source == Type.Variable:
 			self._start_ptr += chunk_size
 			return self._data[self._start_ptr - chunk_size: self._start_ptr]
 		elif self._source == Type.File:
 			self._start_ptr += chunk_size
 			return self._data.read(chunk_size)
 
-	def read_as_binary(self, chunk_size: int = None) -> bytes:
+	@property
+	def read_len(self) -> int:
+		"""Returns number of bytes read from the stream since its creation."""
+		return self._read_len
+
+	def read_as_binary(self, encoding: str, chunk_size: int = None) -> bytes:
 		"""Same as read(), but always returns the data in binary format.
 		Practically works exactly as read() for binary streams.
-		For string streams, the method converts the returned data using utf-8 encoding to bytes()."""
+		For string streams, the method converts the returned data using the provided encoding to bytes()."""
 		if self._binary:
 			return self.read(chunk_size)
 		else:
-			return self.read(chunk_size).encode('utf-8')
+			return self.read(chunk_size).encode(encoding)
 
 	def close(self):
 		"""Closes the StreamReader. You can not use its instance afterwards."""
 		if self._source == Type.File and self._data:
 			self._data.close()
 		self._data = None
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/StreamWriter.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/StreamWriter.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,17 +1,23 @@
+"""See the docstring for the StreamWriter class."""
+
 from enum import Flag
 from typing import AnyStr
+from io import BytesIO, StringIO
 
 from .Utilities import size_to_kb_mb_string
+from .InstrumentErrors import RsInstrException
 
 
 class Type(Flag):
+	"""Defines type of the stream - variable or file."""
 	Variable = 1
-	File = 2
-	FileAppend = 6
+	Forget = 2
+	File = 4
+	FileAppend = 12
 
 
 class StreamWriter:
 	"""Lightweight stream writer implementation. Data target can be: \n
 	- bytes
 	- string
 	- file"""
@@ -19,41 +25,48 @@
 	def __init__(self, binary: bool, target: Type, meta_data=None):
 		"""Initializes StreamWriter instance.\n
 		:param binary: True: Binary data, False: ASCII data
 		:param target: Target for the stream. Variable / File (FileAppend)
 		:param meta_data: Only valid for File and FileAppend - define file path as string:
 		For Type.File, data must be string with file path. If the file exists, it will be overwritten.
 		For Type.FileAppend, data must be string with file path. If the file exists, it will be appended."""
-		self._binary = binary
-		self._written_len = 0
+		self._binary: bool = binary
+		self._written_len: int = 0
 		self._target = target
 
 		if Type.Variable in self._target:
 			assert meta_data is None, f'You can not define input meta_data for a Variable StreamWriter.'
-			self._data: AnyStr = bytes() if binary else ''
+			self._data = BytesIO() if binary else StringIO()
+		elif Type.Forget in self._target:
+			self._data: AnyStr = ''
 		elif Type.File in self._target:
 			assert isinstance(meta_data, str), f'Additional data must be of string type (file path). Actual type: {type(meta_data)}'
 			self._file_path = meta_data
 			mode = 'w' if self._target == Type.File else 'a'
 			mode += 'b' if self._binary else ''
 			self._data = open(self._file_path, mode)
 		else:
-			raise Exception(f'StreamWriter unknown target {target}')
+			raise RsInstrException(f'StreamWriter unknown target {target}')
 
 	@classmethod
 	def as_bin_var(cls) -> 'StreamWriter':
 		"""Creates new StreamWriter with bytes variable."""
 		return cls(True, Type.Variable)
 
 	@classmethod
 	def as_string_var(cls) -> 'StreamWriter':
 		"""Creates new StreamWriter with string variable."""
 		return cls(False, Type.Variable)
 
 	@classmethod
+	def as_forget(cls) -> 'StreamWriter':
+		"""Creates new StreamWriter which writes to nowhere - forgets the data."""
+		return cls(False, Type.Forget)
+
+	@classmethod
 	def as_bin_file(cls, file_path: str, append: bool = False) -> 'StreamWriter':
 		"""Creates new StreamWriter to binary file.
 		:param file_path: [str] Path to the file.
 		:param append: Optional [bool] If True, the content is appended to the existing content."""
 		return cls(True, Type.FileAppend if append else Type.File, file_path)
 
 	@classmethod
@@ -67,14 +80,16 @@
 		if Type.Variable in self._target:
 			mode = 'binary' if self._binary else 'string'
 			return f'StreamWriter {mode} variable, current size {size_to_kb_mb_string(len(self), True)}'
 		if Type.File in self._target:
 			mode = 'binary' if self._binary else 'text'
 			append = ' appended' if Type.FileAppend in self._target else ''
 			return f'StreamWriter {mode} file{append}, current{append} size {size_to_kb_mb_string(len(self), True)}, file: {self._file_path}'
+		if Type.Forget in self._target:
+			return 'StreamWriter to nowhere.'
 
 	def __len__(self):
 		"""Returns remaining length."""
 		return self._written_len
 
 	def __enter__(self):
 		return self
@@ -88,49 +103,62 @@
 		File streams are always binary."""
 		return self._binary
 
 	def write(self, data: AnyStr) -> None:
 		"""Writes chunk to the stream.
 			- For Type.Bytes data must be bytes.
 			- For Type.String, data must be string.
-			- For Type.File and Type.FileAppend, data must be bytes"""
+			- For Type.File and Type.FileAppend, data must be bytes."""
+		if Type.Forget in self._target:
+			self._written_len += len(data)
+			return
+
 		assert self._data is not None, 'StreamWriter buffer is invalid. You have probably closed it already.'
 		if self._binary:
 			assert isinstance(data, bytes), f'Bytes data is required. Actual type: {type(data)}. {self}'
 		else:
 			assert isinstance(data, str), f'String data is required. Actual type: {type(data)}. {self}'
-
 		if Type.Variable in self._target:
-			self._data += data
+			self._data.write(data)
 		elif Type.File in self._target:
 			self._data.write(data)
 		self._written_len += len(data)
 
-	def switch_to_string_data(self) -> None:
+	def switch_to_string_data(self, encoding: str) -> None:
 		"""Switches from binary to string data.
-		For variables, the current content is converted.
+		For variables, the current content is converted to string using the provided encoding.
 		For files, they are closed and reopened as for appended text writing."""
 		if self._binary is False:
 			return
 		self._binary = False
 		if Type.Variable in self._target:
-			if len(self) == 0:
-				self._data = ''
-			else:
-				# noinspection PyUnresolvedReferences
-				self._data = self._data.decode('utf-8')
+			self._data = StringIO(self.content.decode(encoding))
 		elif Type.File in self._target:
 			self._data.close()
 			self._data = open(self._file_path, 'a')
 
+	# noinspection PyTypeChecker
 	@property
 	def content(self) -> AnyStr:
-		"""Returns content of the writer. Does only work with variable types."""
-		assert Type.Variable in self._target, f'Can not return content for the current {self}'
+		"""Returns content of the writer. Only works with variable types."""
+		if self._target == Type.Forget:
+			return ''
+		if self._target != Type.Variable:
+			raise RsInstrException(f'Can not return content for the current {self}')
 		# noinspection PyTypeChecker
-		return self._data
+		if not self._data:
+			return None
+		self._data.seek(0)
+		ret_val = self._data.read()
+		self._data.close()
+		return ret_val
+
+	@property
+	def written_len(self) -> int:
+		"""Returns number of bytes written to the stream since its creation."""
+		return self._written_len
 
 	def close(self) -> None:
 		"""Closes the StreamWriter. You can not use its instance afterwards."""
 		if Type.File in self._target and self._data:
 			self._data.close()
 		self._data = None
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/StructBase.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/StructBase.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,20 +1,22 @@
+"""See the docstring for the StructBase class."""
+
 from .Types import DataType
 
 
 class StructBase:
 	"""Base class for all the driver's argument structures."""
 	def __init__(self, owner):
 		self.__meta_args_link = dict()
 		ix = 0
 		for arg in self.__get_meta_args_list(owner):
 			arg.argument_ix = ix
 			ix += 1
 
-			if arg.data_type == DataType.Enum or arg.data_type == DataType.EnumList:
+			if arg.data_type in [DataType.Enum, DataType.EnumExt, DataType.EnumList, DataType.EnumExtList]:
 				assert arg.enum_type, f"Struct Argument '{arg.name}' is of enum type, you must define the parameter 'enum_type'"
 			else:
 				assert not arg.enum_type, f"Struct Argument '{arg.name}' data type is '{arg.data_type.name}'. You must set the parameter 'enum_type' to None"
 
 			if arg.is_optional:
 				# set all optional values to None
 				setattr(self, arg.name, None)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/Types.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/Types.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,54 +1,70 @@
+"""Data type class for the variables containing all the methods related to data types."""
+
 from enum import Enum, auto
 from typing import Any
 
 
+# noinspection PyArgumentList
 class DataType(Enum):
-	"""Data type of a variable in the driver."""
+	"""Data type of variable in the driver."""
 	String = auto()
 	RawString = auto()
 	Integer = auto()
 	IntegerExt = auto()
 	Boolean = auto()
 	Float = auto()
 	FloatExt = auto()
 	Enum = auto()
+	EnumExt = auto()
 	StringList = auto()
 	RawStringList = auto()
 	IntegerList = auto()
 	IntegerExtList = auto()
 	BooleanList = auto()
 	FloatList = auto()
 	FloatExtList = auto()
 	EnumList = auto()
+	EnumExtList = auto()
 
 	@property
 	def is_list(self) -> bool:
 		"""Returns True, if the data type is a list."""
 		return self in frozenset(
 			{
 				DataType.StringList,
 				DataType.RawStringList,
 				DataType.IntegerList,
 				DataType.IntegerExtList,
 				DataType.BooleanList,
 				DataType.FloatList,
 				DataType.FloatExtList,
-				DataType.EnumList
+				DataType.EnumList,
+				DataType.EnumExtList
 			})
 
 	@property
 	def is_scalar(self) -> bool:
 		"""Returns True, if the data type is a scalar."""
 		return not self.is_list
 
 	@property
+	def is_scalar_enum(self) -> bool:
+		"""Returns True, if the data type is a scalar enum or enum_ext."""
+		return self == DataType.Enum or self == DataType.EnumExt
+
+	@property
+	def is_list_enum(self) -> bool:
+		"""Returns True, if the data type is a list enum or list enum_ext."""
+		return self == DataType.EnumList or self == DataType.EnumExtList
+
+	@property
 	def is_enum(self) -> bool:
-		"""Returns True, if the data type is enum or enum array."""
-		return self == DataType.Enum or self == DataType.EnumList
+		"""Returns True, if the data type is enum or enum array - including the extended."""
+		return self in [DataType.Enum, DataType.EnumExt, DataType.EnumList, DataType.EnumExtList]
 
 	@property
 	def is_raw_string(self) -> bool:
 		"""Returns True for raw string and raw string list."""
 		return self == DataType.RawString or self == DataType.RawStringList
 
 	@property
@@ -81,14 +97,16 @@
 			return DataType.IntegerExt
 		elif self == DataType.FloatList:
 			return DataType.Float
 		elif self == DataType.FloatExtList:
 			return DataType.FloatExt
 		elif self == DataType.EnumList:
 			return DataType.Enum
+		elif self == DataType.EnumExtList:
+			return DataType.EnumExt
 
 	def get_default_value(self, enm: Enum = None) -> Any:
 		"""Returns default value for the current type.
 		If the data type is Enum or EnumString, you have to provide the enum class."""
 		if self.is_list:
 			return []
 		if self == DataType.RawString:
@@ -103,7 +121,9 @@
 			return 0
 		elif self == DataType.Float:
 			return 0.0
 		elif self == DataType.FloatExt:
 			return 0.0
 		elif self == DataType.Enum:
 			return enm(0)
+		elif self == DataType.EnumExt:
+			return enm(0)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/Utilities.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/Utilities.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""Utilities for string manipulation and string formatting for the user."""
+
 from enum import Flag
 from typing import Tuple
 
 
 class TrimStringMode(Flag):
 	"""Trimming mode for strings."""
 	white_chars_only = 1
@@ -133,7 +135,41 @@
 
 
 def calculate_chunks_count(data_size: int, chunk_size: int) -> int:
 	"""Returns number of chunks needed to transfer the data_size split to maximum of chunk_size blocks. \n
 	:param data_size: total data size
 	:param chunk_size: maximum size of one block"""
 	return (data_size // chunk_size) + (1 if (data_size % chunk_size) > 0 else 0)
+
+
+def escape_nonprintable_chars(string: str, encoding: str = 'charmap') -> str:
+	"""
+	Replace nonprintable characters in string s by its hex representation.
+	"""
+	if string.isprintable():
+		return string
+	new_string = ''
+	for char in string:
+		if char.isprintable():
+			new_string += char
+		elif char == '\n':
+			new_string += r'\n'
+		elif char == '\r':
+			new_string += r'\r'
+		elif char == '\t':
+			new_string += r'\t'
+		else:
+			byte = bytes(char, encoding)
+			char = byte.hex()
+			new_string += r'\x' + char
+	return new_string
+
+
+def shorten_string_middle(string: str, max_len: int) -> str:
+	"""If the length of the string is bigger than the max_len,
+	the middle of the string is abbreviated with ' .... ' """
+	count = len(string)
+	if count <= max_len:
+		return string
+	half = int((max_len - 6) / 2)
+	md = (max_len - 6) % 2
+	return string[:half + md] + ' .... ' + string[(count - half):]
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/VisaPluginSocketIo.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/VisaPluginSocketIo.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,23 +1,28 @@
+"""See the docstring for the SocketIo class."""
+
 import socket
 import re
 from contextlib import contextmanager
+from typing import Any
+
+from .InstrumentErrors import RsInstrException
 
 # noinspection PyPackageRequirements
 import pyvisa
 
 
 class SocketIo:
-
+	"""Socket IO plugin providing implementations for all the necessary VISA functions. This class does not need the underlying VISA installation."""
 	def __init__(self, resource_name: str):
 		self.session = socket.socket()
 		self.resource_name = resource_name
 		m = re.search(r'TCPIP::([^:]+)::([^:]+)::SOCKET', self.resource_name)
 		if not m:
-			raise Exception(f"SocketIO instrument unsupported resource name. '{self.resource_name}' Supported resource name example: 'TCPIP::192.168.1.100::5025::SOCKET'")
+			raise RsInstrException(f"SocketIO instrument unsupported resource name. '{self.resource_name}' Supported resource name example: 'TCPIP::192.168.1.100::5025::SOCKET'")
 		self.host = m.group(1).strip()
 		self.port = int(m.group(2).strip())
 		self._read_termination = None
 		self._chunk_size = 1024
 		self._timeout = 5000
 		self.visalib = VisaLib(self)
 
@@ -90,14 +95,22 @@
 
 	# noinspection PyUnusedLocal
 	def read_bytes(self, count: int, **kwargs) -> bytes:
 		"""Reads count bytes"""
 		data, status = self.visalib.read(self.session, count)
 		return data
 
+	def go_to_local(self) -> None:
+		"""Puts the instrument into local state."""
+		self.write("&GTL")
+
+	def go_to_remote(self) -> None:
+		"""Puts the instrument into remote state."""
+		self.write("&GTR")
+
 	# noinspection PyUnusedLocal
 	@contextmanager
 	def ignore_warning(self, filter_value: int) -> None:
 		"""Context property with no effect for the socket connection"""
 		try:
 			yield None
 		finally:
@@ -106,15 +119,15 @@
 
 	def close(self) -> None:
 		"""Closes the socket connection"""
 		self.session.close()
 
 
 class VisaLib:
-
+	"""Implementation of the pyvisa's VisaLib providing the method read()"""
 	def __init__(self, socket_io: SocketIo):
 		self._socket_io = socket_io
 
 	def __str__(self):
 		return "SocketIO"
 
 	# noinspection PyUnresolvedReferences
@@ -127,14 +140,16 @@
 
 		try:
 			while True:
 				to_read_len = chunk_size - read_len
 				if to_read_len <= 0:
 					break
 				data = session.recv(to_read_len)
+				if not data:
+					raise pyvisa.VisaIOError(pyvisa.constants.VI_ERROR_CONN_LOST)
 				chunk += data
 				read_len += len(data)
 
 				if self._socket_io.read_termination is not None:
 					# Read termination character is ON, look for it and stop the reading if found
 					term_char = self._socket_io.read_termination.encode()
 					if term_char in data:
@@ -159,17 +174,18 @@
 				more_data_available = True
 
 		return_code = pyvisa.constants.StatusCode.success_max_count_read if more_data_available else pyvisa.constants.StatusCode.success
 		return chunk, return_code
 
 
 class ResourceManager:
-
+	"""Implementation of the VISA's Resource Manager."""
 	def __init__(self):
 		self.VisaManufacturerName = "SocketIO"
 		self.connection = None
 
-	def open_resource(self, resource_name: str) -> SocketIo:
-		"""Creates new Socket connection"""
+	# noinspection PyUnusedLocal
+	def open_resource(self, resource_name: str, access_mode: Any = None, open_timeout: Any = None) -> SocketIo:
+		"""Creates new Socket connection. access_mode and open_timeout are here for compatibility reasons with the pyvisa rm.open_resource()"""
 		self.connection = SocketIo(resource_name)
 		self.connection.connect()
 		return self.connection
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/VisaSession.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/VisaSession.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,20 +1,23 @@
+"""Visa Session is an extension of the pure VISA providing higher level of methods regardless of the session kind."""
+
 import time
 from enum import Enum, Flag
-from typing import Tuple, Callable, AnyStr
+from typing import List, Tuple, Callable, AnyStr
 import os.path
 import re
 import threading
 
 # noinspection PyPackageRequirements
 import pyvisa
+from pyvisa.errors import StatusCode
 
 from .VisaPluginSocketIo import ResourceManager, SocketIo
 from . import InstrumentSettings, InstrumentErrors, Conversions as Conv
-from .InstrumentSettings import WaitForOpcMode, InstrViClearMode as ViClearMode
+from .InstrumentSettings import WaitForOpcMode, OpcSyncQueryMechanism, InstrViClearMode as ViClearMode
 from .StreamReader import StreamReader
 from .StreamWriter import StreamWriter
 from .Utilities import size_to_kb_mb_string, calculate_chunks_count
 import platform
 import struct
 
 
@@ -37,14 +40,16 @@
 	bin_known_len = 3
 	bin_unknown_len = 4
 
 
 class StatusByte(Flag):
 	"""Status Byte flags."""
 	NONE = 0x00
+	custom_bit_0 = 0x01
+	custom_bit_1 = 0x02
 	error_queue_not_empty = 0x04
 	questionable_status_reg = 0x08
 	message_available = 0x10
 	event_status_byte = 0x20
 	request_service = 0x40
 	operation_status_reg = 0x80
 
@@ -64,14 +69,22 @@
 		# noinspection PyTypeChecker
 		self._data_chunk_size: int = None
 		self._std_bin_block_header_max_len: int = 999999999
 		self._lock = None
 		self.disable_opc_query: bool = settings.disable_opc_query
 		self.last_status = None
 		self.visa_library_name = None
+		self.resource_name = resource_name  # might be changed later if direct_session is used
+		self.encoding = settings.encoding  # default encoder between bytes and string
+		self.cmd_idn = settings.cmd_idn
+		self.skip_status_system_setting = settings.skip_status_system_setting
+		self.skip_clear_status = settings.skip_clear_status
+		self.stb_in_error_check = settings.stb_in_error_check
+		self.opc_sync_query_mechanism = settings.opc_query_sync_mechanism
+		self.each_cmd_prefix = settings.each_cmd_prefix
 
 		# Implemented for interface compatibility with VisaSessionSim
 		self.cached_to_stream = False
 
 		# Event handlers
 		# noinspection PyTypeChecker
 		self.on_read_chunk_handler: Callable = None
@@ -80,36 +93,36 @@
 		self.on_write_chunk_handler: Callable = None
 		"""If assigned a handler, the VisaSession sends it event on each write chunk transfer."""
 		self.io_events_include_data: bool = False
 		"""If true, the VisaSession events sent to on_read_chunk_handler and on_write_chunk_handler contain transferred data."""
 
 		if self.reusing_session:
 			# Reuse the session
-			assert isinstance(direct_session, pyvisa.Resource) or isinstance(direct_session, SocketIo), f"Direct_session must be a VISA resource object. Actual type: '{type(direct_session)}', value: '{direct_session}'"
-			self._session = direct_session
-			self._resource_name = self._session.resource_name
+			self._session = VisaSession.get_and_check_direct_session(direct_session)
+			self.resource_name = self._session.resource_name
 		else:
 			# Create new session
 			# Check resource_name for the trailing (SelectVisa=..)
 			pure_resource_name, visa_select = self._get_pure_resource_name(resource_name)
 			if settings.visa_select is not None:
 				visa_select = settings.visa_select
 			self._rm = VisaSession.get_resource_manager(visa_select)
 			self.manufacturer = self._get_visa_manufacturer()
 
 			# Resource manager opening
 			try:
-				self._session = self._rm.open_resource(pure_resource_name)
+				acc_mode = pyvisa.constants.AccessModes.no_lock if settings.exclusive_lock is False else pyvisa.constants.AccessModes.exclusive_lock
+				self._session = self._rm.open_resource(resource_name=pure_resource_name, open_timeout=settings.open_timeout, access_mode=acc_mode)
 			except pyvisa.VisaIOError as e:
 				if e.error_code != pyvisa.constants.StatusCode.error_resource_not_found:
 					raise e
 				message = e.description
 				message += f"\nLibrary: {self._rm.visalib}\nManufacturer: {self.manufacturer}\nResource Name: '{resource_name}'"
 				raise InstrumentErrors.ResourceError(resource_name, message)
-			self._resource_name = resource_name
+			self.resource_name = resource_name
 
 		# Decide, whether to create a new thread lock or the existing one from the session
 		if hasattr(self._session, 'session_thread_rlock'):
 			rlock = self._session.session_thread_rlock
 			if isinstance(rlock, type(threading.RLock())):
 				self.assign_lock(rlock)
 		if self.get_lock() is None:
@@ -136,28 +149,22 @@
 			self._interface_type = SessionKind.vxi11
 			if self._session.resource_class == 'SOCKET':
 				self._interface_type = SessionKind.socket
 
 		# Specifics for different interfaces
 		self._assure_write_with_tc = settings.assure_write_with_tc
 		self._term_char = settings.term_char
-		self._term_char_bin = self._term_char.encode('utf-8')
+		self._term_char_bin = self._term_char.encode(self.encoding)
 		self._session.write_termination = ''
-		self.vxi_capable = True
+		self.vxi_capable = settings.vxi_capable
 
 		if self._interface_type == SessionKind.serial:
-			self._session.read_termination = self._term_char
 			self.vxi_capable = False
-			self._assure_write_with_tc = True
 		elif self._interface_type == SessionKind.socket:
-			self._session.read_termination = self._term_char
 			self.vxi_capable = False
-			self._assure_write_with_tc = True
-		else:
-			self._session.read_termination = ''
 
 		# NRP-Z specific settings
 		if self.is_rsnrp_session():
 			self.disable_opc_query = True
 			# NRP-Z does not support chunk reading, therefore the segment must be in one piece
 			settings.io_segment_size = 1000000
 			self.vxi_capable = False
@@ -166,78 +173,125 @@
 		self.read_delay = settings.read_delay
 		self._viclear_exe_mode = settings.viclear_exe_mode
 		self._opc_wait_mode = settings.opc_wait_mode
 
 		# Parameters that need to be coerced based on Vxi-capability
 		if self.vxi_capable:
 			self._add_term_char_to_write_bin_block = settings.add_term_char_to_write_bin_block
+			self._session.read_termination = ''
 		else:
 			self._add_term_char_to_write_bin_block = True
+			self._session.read_termination = self._term_char
+			self._assure_write_with_tc = True
 
 		# Changeable settings
 		self.opc_timeout = 10000 if settings.opc_timeout == 0 else settings.opc_timeout
 		self.visa_timeout = settings.visa_timeout
 		self._session.chunk_size = settings.io_segment_size
 		self._data_chunk_size = settings.io_segment_size
 
-		# Must call the VISA viClear() before the any communication with the instrument
+		# Must call the VISA viClear() before any communication with the instrument
 		self.clear()
 
 		# Further steps are for NRP-Z session not valid
 		if self.is_rsnrp_session():
 			return
 
+		# First commands, can be more than one, separated by ';;'
+		if settings.first_cmds:
+			cmds = settings.first_cmds.split(';;')
+			for cmd in cmds:
+				if cmd.startswith('<w>'):
+					self.write(cmd[3:])
+				elif cmd.startswith('<q>'):
+					_ = self._query_str_no_events(cmd[3:])
+				elif '?' in cmd:
+					_ = self._query_str_no_events(cmd)
+				else:
+					self.write(cmd)
+
 		# Clear instrument status
-		self.write('*CLS')
-		if self.vxi_capable:
-			stb = self._read_stb()
-			if stb & StatusByte.message_available:
-				self._flush_junk_data()
+		if self.skip_clear_status is False:
+			self.write('*CLS')
+			if self.vxi_capable:
+				stb = self._read_stb()
+				if stb & StatusByte.message_available:
+					self._flush_junk_data()
 
 		# Apply settings for ESE and SRE, plus coerce the _opcWaitMode if necessary
 		self._opc_wait_mode = self._set_regs_ese_sre(self._opc_wait_mode)
 
 	@staticmethod
+	def get_and_check_direct_session(direct_session):
+		"""Returns direct session if it's a proper type.
+		If the direct_session is None, the function returns None.
+		If the direct_session is of an unsupported type, the function raises RsInstrException."""
+		if direct_session is None:
+			return None
+		# Reuse the session
+		if not isinstance(direct_session, pyvisa.Resource) and not isinstance(direct_session, SocketIo):
+			raise InstrumentErrors.RsInstrException(f"Direct_session must be a VISA resource object. Actual type: '{type(direct_session)}', value: '{direct_session}'")
+		return direct_session
+
+	@staticmethod
 	def _get_pure_resource_name(resource_name: str):
 		"""Returns pure resource name stripped of the (SelectVisa) part and the visa_select string"""
 		m = re.search(r'(.+)\(SelectVisa=([^),]+)\)', resource_name)
 		if not m:
 			return resource_name, None
 		resource_name = m.group(1).strip()
 		visa_select = m.group(2).strip()
 		return resource_name, visa_select
 
 	@classmethod
 	def get_resource_manager(cls, visa_select: str) -> pyvisa.ResourceManager:
 		"""Returns resource manager for the desired VISA implementation"""
 		operating_system = platform.system().lower()
+		vsl = None if visa_select is None else visa_select.lower()
 		bittness = struct.calcsize('P') * 8
-		if visa_select is None or visa_select in ['@default', '@standard', 'default', 'standard', 'defaultvisa', 'standardvisa', '@defaultvisa', '@standardvisa']:
-			return pyvisa.ResourceManager()
-		if visa_select.lower() in ['@ni', 'ni', 'visa-ni', 'nivisa', 'ni-visa', 'nationalinstruments', 'nationalinstrumentsvisa']:
-			return pyvisa.ResourceManager('@ni')
-		if visa_select.lower() in ['@py', 'pyvisa', 'visa-py', 'pyvisa-py']:
-			return pyvisa.ResourceManager('@py')
-		if 'rohde&schwarz' in visa_select.lower() or 'rohdeschwarz' in visa_select.lower() or visa_select.lower() == 'rsvisa' or visa_select.lower() == 'rs' or visa_select.lower() == 'r&s':
+		# Try if you find the default VISA dll
+		try:
+			if visa_select is None or visa_select in ['@default', '@standard', 'default', 'standard', 'defaultvisa', 'standardvisa', '@defaultvisa', '@standardvisa']:
+				return pyvisa.ResourceManager()
+
+			if vsl in ['@ni', 'ni', 'ivi', '@ivi', 'visa-ni', 'nivisa', 'ni-visa', 'nationalinstruments', 'nationalinstrumentsvisa']:
+				return pyvisa.ResourceManager()
+
+			if vsl in ['@py', 'pyvisa', 'visa-py', 'pyvisa-py']:
+				return pyvisa.ResourceManager('@py')
+		except ValueError:
+			# None of the required implementations found, fall back to the R&S VISA
+			visa_select = 'rsvisa'
+			vsl = visa_select.lower()
+
+		# from here, RsVisa implementation is considered
+		if 'rohde&schwarz' in vsl or 'rohdeschwarz' in vsl or vsl == 'rsvisa' or vsl == 'rs' or vsl == 'r&s':
 			if operating_system == 'windows':
 				if bittness == 32:
 					visa_select = r'c:\Windows\SysWOW64\RsVisa32.dll'
 				else:
 					visa_select = r'c:\Windows\system32\RsVisa32.dll'
 				return pyvisa.ResourceManager(visa_select)
 			elif operating_system == 'linux':
 				# The default install location may be different
 				# for debian/red hat/opensuse derived distributions
 				check_visa = [f'/usr/lib{bittness}/librsvisa.so', r'/usr/lib/librsvisa.so']
 				for check in check_visa:
 					if os.path.isfile(check):
 						return pyvisa.ResourceManager(check)
+			elif operating_system == 'darwin':
+				# MacOS
+				check_visa = [f'/Library/Frameworks/RsVisa.framework/Versions/Current/RsVisa/librsvisa.dylib']
+				for check in check_visa:
+					if os.path.isfile(check):
+						return pyvisa.ResourceManager(check)
 
-		if visa_select.lower() in ['socketio', 'socket', 'none']:
+		if vsl in ['socketio', 'socket', 'none']:
 			return ResourceManager()
+
 		return pyvisa.ResourceManager(visa_select)
 
 	def _get_visa_manufacturer(self) -> str:
 		"""Returns manufacturer of the current VISA"""
 		if hasattr(self._rm, 'VisaManufacturerName'):
 			return self._rm.VisaManufacturerName
 		try:
@@ -256,14 +310,26 @@
 		setattr(self._session, 'session_thread_rlock', lock)
 		self._lock = lock
 
 	def get_lock(self) -> threading.RLock:
 		"""Returns the current RLock object."""
 		return self._lock
 
+	def lock_resource(self, timeout: int, requested_key: str or bytes = None) -> bytes or None:
+		"""Locks the instrument to prevent it from communicating with other clients."""
+		if requested_key is None:
+			self._session.lock_excl(timeout)
+			return None
+		else:
+			return self._session.lock(timeout, requested_key)
+
+	def unlock_resource(self) -> None:
+		"""Unlocks the instrument to other clients."""
+		self._session.unlock()
+
 	@property
 	def visa_timeout(self) -> int:
 		"""See the visa_timeout.setter."""
 		return int(self._session.timeout)
 
 	@visa_timeout.setter
 	def visa_timeout(self, value: int) -> None:
@@ -278,73 +344,96 @@
 	@data_chunk_size.setter
 	def data_chunk_size(self, chunk_size: int) -> None:
 		"""Sets the maximum size of one block transferred during write/read operations."""
 		self._data_chunk_size = int(chunk_size)
 		self._session.chunk_size = int(chunk_size)
 
 	def _resolve_opc_timeout(self, timeout: int) -> int:
-		"""Resolves entered timeout value - if the input value is less than 1, it is replaces with opc_timeout."""
+		"""Resolves entered timeout value - if the input value is less than 1, it is replaced with opc_timeout."""
 		if timeout is None or timeout < 1:
 			return self.opc_timeout
 		else:
 			return timeout
 
 	def _set_regs_ese_sre(self, mode: WaitForOpcMode) -> WaitForOpcMode:
 		"""Based on the WaitForOpcMode, it sets the ESE and SRE register masks.
 		Returns coerced WaitForOpcMode."""
 		# Set the SRE and ESE registers accordingly
 		# No SRE is supported
+		if self.skip_status_system_setting:
+			return mode
 		self._set_ese_mask(EventStatusRegister.operation_complete)
 		self._set_sre_mask(StatusByte.NONE)
 		return mode
 
+	# noinspection PyTypeChecker
 	def _set_ese_mask(self, mask: EventStatusRegister, reset: bool = True) -> None:
 		"""Sends *ESE command with mask parameter."""
 		if reset is False:
 			current_value = int(self._query_str_no_events('*ESE?'))
 			mask = current_value | mask.value
 		self.write("*ESE %d" % mask.value)
 
+	# noinspection PyTypeChecker
 	def _set_sre_mask(self, mask: StatusByte, reset: bool = True) -> None:
 		"""Sends *SRE command with StatusByte mask parameter."""
 		if reset is False:
 			current_value = int(self._query_str_no_events('*SRE?'))
 			mask = current_value | mask.value
 		# Also affect the _opc_wait_mode:
 		# If the mask has event_status_byte == false, and the _opc_wait_mode is service_request, set it to stb_poll
 		# If the mask has event_status_byte == true, do not change anything
 		self.write(f'*SRE {mask.value}')
 
-	def _write_and_poll_stb_vxi(self, command: str, is_query: bool, timeout: int, end_mask: StatusByte) -> StatusByte:
+	def _write_and_poll_stb_vxi(self, command: str, is_query: bool, timeout: int) -> StatusByte:
 		"""Reads Status Byte Register and ends if the ESB bit (5) is set to 1.
 		Also works with the SOCKET and SERIAL interface by sending *STB? query.
 		In that case however, command cannot be a query.
 		Returns the last read Status Byte value."""
 		timeout_secs = timeout / 1000
-		self.clear_before_read()
+		end_mask = StatusByte.error_queue_not_empty | StatusByte.event_status_byte
 		if command.endswith(self._term_char):
 			command = command.rstrip(self._term_char)
-		self.write(command + ';*OPC')
-		# Use catch to return the VISA Timeout back
+
+		if is_query is True:
+			if self.opc_sync_query_mechanism == OpcSyncQueryMechanism.standard or self.opc_sync_query_mechanism == OpcSyncQueryMechanism.also_check_mav:
+				self.clear_before_read()
+				self.write(command + ';*OPC')
+				if self.opc_sync_query_mechanism == OpcSyncQueryMechanism.also_check_mav:
+					end_mask |= StatusByte.message_available
+
+			elif self.opc_sync_query_mechanism == OpcSyncQueryMechanism.only_check_mav_err_queue:
+				self.write(command)
+				end_mask = StatusByte.error_queue_not_empty | StatusByte.message_available
+
+			elif self.opc_sync_query_mechanism == OpcSyncQueryMechanism.cls_only_check_mav_err_queue:
+				self.clear_before_read()
+				self.write(command)
+				end_mask = StatusByte.error_queue_not_empty | StatusByte.message_available
+		else:
+			self.clear_before_read()
+			self.write(command + ';*OPC')
+
 		start = time.time()
 		# STB polling loop
 		while True:
 			stb = self._read_stb()
 			elapsed = self._polling_delay(start)
 			if elapsed > timeout_secs:
 				self._narrow_down_opc_tout_error(command, is_query, timeout)
 			if end_mask & stb:
 				break
 		return stb
 
-	def _write_and_poll_stb_non_vxi(self, command: str, timeout: int, end_mask: StatusByte) -> StatusByte:
+	def _write_and_poll_stb_non_vxi(self, command: str, timeout: int) -> StatusByte:
 		"""Queries Status Byte Register (*STB?) and ends if the ESB bit (5) is set to 1.
 			The command must not be a query. Also works with the SOCKET and SERIAL interface.
 			Returns the last read Status Byte value."""
 		timeout_secs = timeout / 1000
+		end_mask = StatusByte.error_queue_not_empty | StatusByte.event_status_byte
 		self.clear_before_read()
 		if command.endswith(self._term_char):
 			command = command.rstrip(self._term_char)
 		self.write(command + ';*OPC')
 		start = time.time()
 		# STB polling loop
 		while True:
@@ -360,43 +449,47 @@
 		"""Called by the _write_and_poll_stb_vxi when the timeout expires.
 		The method tries to closer identify the cause of the timeout."""
 		stb = self._read_stb()
 		timeout = self._resolve_opc_timeout(timeout)
 		if is_query:
 			if stb & StatusByte.error_queue_not_empty:
 				self.clear()
-				context = f"Sending query '{command.strip()}' with OPC Wait resulted in timeout. OPC Timeout is set to {timeout} ms. Additionally, "
-				InstrumentErrors.assert_no_instrument_status_errors(self._resource_name, self.query_all_syst_errors(), context)
-			InstrumentErrors.throw_opc_tout_exception(self.opc_timeout, timeout, f"Sending query '{command.strip()}'.")
+				context = f"Query '{command.strip()}' with OPC Wait resulted in timeout. OPC Timeout is set to {timeout} ms. Additionally, "
+				InstrumentErrors.assert_no_instrument_status_errors(self.resource_name, self.query_all_syst_errors(), context, first_exc=InstrumentErrors.TimeoutException)
+			InstrumentErrors.throw_opc_tout_exception(self.opc_timeout, timeout, f"Query '{command.strip()}'.")
 		else:
 			if stb & StatusByte.error_queue_not_empty:
 				self.clear()
-				context = f"Sending command '{command.strip()}' with OPC Wait resulted in timeout. OPC Timeout is set to {timeout} ms. Additionally, "
-				InstrumentErrors.assert_no_instrument_status_errors(self._resource_name, self.query_all_syst_errors(), context)
-			InstrumentErrors.throw_opc_tout_exception(self.opc_timeout, timeout, f"Sending command '{command.strip()}'.")
+				context = f"Command '{command.strip()}' with OPC Wait resulted in timeout. OPC Timeout is set to {timeout} ms. Additionally, "
+				InstrumentErrors.assert_no_instrument_status_errors(self.resource_name, self.query_all_syst_errors(), context, first_exc=InstrumentErrors.TimeoutException)
+			InstrumentErrors.throw_opc_tout_exception(self.opc_timeout, timeout, f"Command '{command.strip()}'.")
 
 	def _narrow_down_io_tout_error(self, context: str, visa_timeout: int = 0) -> None:
 		"""Called internally after IOTimeoutException can narrow down the error to more specific exception.
-		You can define the visa_timeout value for the error message. Otherwise the current visa_timeout is reported."""
+		You can define the visa_timeout value for the error message. Otherwise, the current visa_timeout is reported."""
+		context_stripped = context.strip().rstrip("- ")
+		if self.stb_in_error_check is False:
+			raise InstrumentErrors.TimeoutException(context_stripped)
 		if self.vxi_capable:
 			stb = self._read_stb()
 		else:
 			# Non-Vxi session
 			old_tout = self.visa_timeout
 			try:
 				self.visa_timeout = 500
-				stb = self._query_stb()
+				stb = self._query_stb(False)
 			finally:
 				self.visa_timeout = old_tout
 		if visa_timeout <= 0:
 			visa_timeout = self.visa_timeout
+
 		context = context + f'VISA Timeout error occurred ({visa_timeout} milliseconds)'
 		if stb & StatusByte.error_queue_not_empty:
-			InstrumentErrors.assert_no_instrument_status_errors(self._resource_name, self.query_all_syst_errors(), context + ' and ...')
-		# In case the previous exception is not thrown
+			InstrumentErrors.assert_no_instrument_status_errors(self.resource_name, self.query_all_syst_errors(), context + ' and ...', first_exc=InstrumentErrors.TimeoutException)
+		# In case none of the previous exceptions is thrown
 		raise InstrumentErrors.TimeoutException(context)
 
 	def _polling_delay(self, start):
 		"""Generates progressive polling delay."""
 
 		elapsed = time.time() - start
 		if self._opc_wait_mode == WaitForOpcMode.stb_poll:
@@ -445,59 +538,80 @@
 			if elapsed < 20:
 				time.sleep(1)
 				return elapsed
 			time.sleep(2)
 
 		return elapsed
 
-	def query_syst_error(self) -> str or None:
-		"""Returns one response to the SYSTEM:ERROR? query."""
-		error = self.query_str('SYST:ERR?')
-		if error.startswith('0,'):
+	@staticmethod
+	def _parse_err_query_response(response: str) -> Tuple[int, str]:
+		"""
+		Parses entered response string to Tuple(code, message).
+		E.g.: response = '-110,"Command error"' returns: (-110,'Command error')
+		"""
+		m = re.match(r'([-+]?\d+).*?[\'"](.*)[\'"]', response)
+		code = 0
+		if m:
+			try:
+				code = int(m.group(1))
+			except ValueError:
+				pass
+			return code, m.group(2)
+		else:
+			return code, response
+
+	def query_syst_error(self) -> Tuple[int, str] or None:
+		"""Returns one response to the SYSTEM:ERROR? query.
+		The response is a Tuple of (code: int, message: str)"""
+		error = self._query_str_no_events('SYST:ERR?')
+		if error.startswith('0,') or error.startswith('+0,'):
 			return None
-		return error.strip()
+		return self._parse_err_query_response(error.strip())
 
-	def query_all_syst_errors(self) -> list or None:
-		"""Returns all errors in the instrument's error queue."""
+	def query_all_syst_errors(self) -> List[Tuple[int, str]] or None:
+		"""Returns all errors in the instrument's error queue.
+		If no error is detected, the return value is None."""
 		errors = []
 		while True:
 			entry = self.query_syst_error()
 			if entry is None:
 				break
 			errors.append(entry)
 			if len(errors) > 50:
 				# Safety stop
 				errors.append('query_all_syst_errors - max limit 50 of SYST:ERR? sent.')
 				break
-
 		if len(errors) == 0:
 			return None
 		else:
 			return errors
 
-	def _query_stb(self) -> StatusByte:
+	def _query_stb(self, allow_tout_error_narrow_down: bool = True) -> StatusByte:
 		"""Sends *STB? query and reads the result."""
-		return StatusByte(int(self._query_str_no_events('*STB?')))
+		return StatusByte(int(self._query_str_no_events('*STB?', allow_tout_error_narrow_down)))
 
 	def _read_stb(self) -> StatusByte:
 		"""Calls viReadStb and returns the result."""
 		return StatusByte(self._session.read_stb())
 
 	def clear_before_read(self) -> None:
 		"""Clears IO buffers and the ESR register before reading/writing responses synchronized with *OPC."""
 
 		# For NRP-Z sessions, skip this completely
-		if self.is_rsnrp_session():
+		if self.is_rsnrp_session() or self.skip_clear_status:
 			return
 
 		if not self.vxi_capable:
 			# Non-Vxi session must use *CLS in any case
 			self.write('*CLS')
 			correct = False
-			opc = self._query_str_no_events('*OPC?')
+			if self.disable_opc_query:
+				opc = '1'
+			else:
+				opc = self._query_str_no_events('*OPC?')
 			repeat = 0
 			while not correct:
 				if len(opc) <= 2:
 					opc = opc.strip()
 					correct = opc == '0' or opc == '1'
 				if not correct:
 					# Read again with a small VISA timeout
@@ -525,15 +639,15 @@
 				self.query_and_clear_esr()
 			# Check if the status byte value changed
 			previous_stb = stb
 			stb = self._query_stb()
 			if stb == previous_stb:
 				repeat += 1
 				if repeat > 10:
-					raise Exception(f"Cannot clear the instrument's status subsystem. Status Byte: '{stb}'")
+					raise RsInstrException(f"Cannot clear the instrument's status subsystem. Status Byte: '{stb}'")
 
 	def _flush_junk_data(self) -> None:
 		"""Reads junk bytes to clear the instrument's output buffer."""
 		if self.read_delay > 0:
 			time.sleep(self.read_delay / 1000)
 		self._read_unknown_len(StreamWriter.as_bin_var(), False)
 
@@ -568,39 +682,55 @@
 			try:
 				self._session.clear()
 			except Exception:
 				pass
 		else:
 			self._session.clear()
 
+	def is_connection_active(self) -> bool:
+		"""Returns true, if the VISA connection is active and the communication with the instrument still works.
+		This is achieved by:
+		- checking the session property timeout
+		- sending the *IDN? query"""
+		if self._session is None:
+			return False
+		# noinspection PyBroadException
+		try:
+			old_tout = self.visa_timeout
+			self.visa_timeout = 2000
+			if len(self.cmd_idn) > 0:
+				self.write(self.cmd_idn)
+				_ = self._read_str_no_events()
+			self.visa_timeout = old_tout
+			return True
+		except Exception:
+			return False
+
 	def _write_and_wait_for_opc(self, command: str, is_query: bool, timeout: int) -> StatusByte:
 		"""Internal method to synchronise a command with OPC timeout.
 		Timeout value 0 means the OPC timeout is used."""
 		timeout = self._resolve_opc_timeout(timeout)
 
 		if command.endswith(self._term_char):
 			command = command.rstrip(self._term_char)
 		if is_query:
 			InstrumentErrors.assert_query_has_qmark(command, 'Query with OPC')
 		else:
 			InstrumentErrors.assert_cmd_has_no_qmark(command, 'Write with OPC')
 
 		if self._opc_wait_mode == WaitForOpcMode.opc_query:
 			if is_query:
-				raise Exception('Sending a query with OpcQuery synchronization is not possible')
+				raise RsInstrException('Sending a query with OpcQuery synchronization is not possible')
 			stb = self._write_and_query_opc(command, timeout)
 		else:
 			# STB polling
-			end_stb_mask = StatusByte.error_queue_not_empty | StatusByte.event_status_byte
-			if is_query:
-				end_stb_mask |= StatusByte.message_available
 			if self.vxi_capable:
-				stb = self._write_and_poll_stb_vxi(command, is_query, timeout, end_stb_mask)
+				stb = self._write_and_poll_stb_vxi(command, is_query, timeout)
 			else:
-				stb = self._write_and_poll_stb_non_vxi(command, timeout, end_stb_mask)
+				stb = self._write_and_poll_stb_non_vxi(command, timeout)
 
 		return stb
 
 	def _write_and_query_opc(self, cmd: str, timeout: int) -> StatusByte:
 		"""Internal method to write a command followed by query_opc().
 		Used for opc-synchronization if the mode is set to WaitForOpcMode.opc_query or the session is not-vxi.
 		Timeout value 0 means the OPC timeout is used."""
@@ -614,40 +744,52 @@
 			self.write(cmd)
 			self.query_opc()
 		finally:
 			if old_tout != timeout:
 				self.visa_timeout = old_tout
 		return self._query_stb()
 
+	def clear_status_after_query_with_opc(self) -> bool:
+		"""Returns true, if the opc-sync queries require status clearing afterward."""
+		if self.vxi_capable is False or self._opc_wait_mode is WaitForOpcMode.opc_query:
+			return False
+		if self.opc_sync_query_mechanism == InstrumentSettings.OpcSyncQueryMechanism.standard:
+			return True
+		if self.opc_sync_query_mechanism == InstrumentSettings.OpcSyncQueryMechanism.also_check_mav:
+			return True
+		return False
+
 	def write(self, cmd: str) -> None:
 		"""Writes command to the instrument."""
 		if self.write_delay > 0:
 			time.sleep(self.write_delay / 1000)
 		add_tc = False
 		if self._assure_write_with_tc and not cmd.endswith(self._term_char):
 			add_tc = True
+		if self.each_cmd_prefix:
+			cmd = self.each_cmd_prefix + cmd
+		cmd_bytes = cmd.encode(self.encoding)
 		if add_tc:
-			self._session.write(cmd + self._term_char)
-		else:
-			self._session.write(cmd)
+			cmd_bytes += self._term_char.encode(self.encoding)
+		self._session.write_raw(cmd_bytes)
 
 	def _read_unknown_len(self, stream: StreamWriter, allow_chunk_events: bool, prepend_data: AnyStr = None) -> None:
 		"""Reads data of unknown length to the provided WriteStream.
 		The read is performed in an incremental chunk steps to optimize memory use (for NRP-Z session it is set to fixed self._data_chunk_size):
 			- The first read is performed with the fixed size of 1024 bytes
 			- The 2nd one reads 64 kBytes
 			- The 3rd one reads 128 kBytes
 			- The 4th one reads 256 kBytes and so on, with the max cap of self._data_chunk_size
 		:param stream: [StreamWriter] target for the read data
 		:param allow_chunk_events: [bool] if True, the method can send the chunk_events. If False, sending events is blocked.
-		:param prepend_data: Optional[bytes or string] You can prepend this data to the beginning. It will be considered part of the first chunk read
+		:param prepend_data: Optional[bytes or string] You can prepend this data to the beginning. It will be considered part of the first read chunk
 		:return: read data [bytes or string], depending on the parameter binary."""
 		with self._session.ignore_warning(pyvisa.constants.StatusCode.success_max_count_read):
 			if prepend_data and isinstance(prepend_data, str):
-				prepend_data = prepend_data.encode('utf-8')
+				prepend_data = prepend_data.encode(self.encoding)
 			chunk_ix = 0
 			eot = False
 			while not eot:
 				if self.is_rsnrp_session():
 					chunk_size = self._data_chunk_size
 				else:
 					if chunk_ix == 0:
@@ -660,15 +802,15 @@
 				if chunk_size > self._data_chunk_size:
 					chunk_size = self._data_chunk_size
 				chunk, self.last_status = self._session.visalib.read(self._session.session, chunk_size)
 				if chunk_ix == 0 and prepend_data:
 					chunk = prepend_data + chunk
 				eot = not self._last_status_more_data_available()
 				if not stream.binary:
-					chunk = chunk.decode('utf-8')
+					chunk = chunk.decode(self.encoding)
 					if eot:
 						chunk = chunk.rstrip(self._term_char)
 				stream.write(chunk)
 				if self.on_read_chunk_handler and allow_chunk_events:
 					total_size = len(stream) if eot is True else None
 					event_args = EventArgsChunk(stream.binary, chunk_ix, len(chunk), total_size, len(stream), eot, None, chunk if self.io_events_include_data else None)
 					self.on_read_chunk_handler(event_args)
@@ -683,37 +825,44 @@
 		Sending of any read events is blocked."""
 		if self.read_delay > 0:
 			time.sleep(self.read_delay / 1000)
 		stream = StreamWriter.as_string_var()
 		self._read_unknown_len(stream, False)
 		return stream.content
 
-	def _query_str_no_events(self, query: str) -> str:
+	def _query_str_no_events(self, query: str, allow_tout_error_narrow_down: bool = True) -> str:
 		"""Queries the instrument and reads the response as string.
 		The length of the string is not limited. The response is then trimmed for trailing LF.
 		Sending of any read events is blocked. Use this method for all the service VisaSession queries."""
 		response = ''
 		self.write(query)
 		try:
 			response = self._read_str_no_events()
-		except pyvisa.VisaIOError:
-			self._narrow_down_io_tout_error(f"Querying '{query.rstrip(self._term_char)}' - ")
+		except pyvisa.VisaIOError as e:
+			context = f"Query '{query.rstrip(self._term_char)}'"
+			if e.error_code == StatusCode.error_timeout:
+				if allow_tout_error_narrow_down:
+					self._narrow_down_io_tout_error(context + ' - ')
+				else:
+					raise InstrumentErrors.TimeoutException(context)
+			else:
+				raise InstrumentErrors.RsInstrException(context)
 		return response
 
 	def _query_str_no_events_timed(self, query: str, timeout: int, suppress_read_tout: bool = False) -> str:
 		"""Queries the instrument and reads the response as string.
 		The entered timeout sets the VISA timeout just for this call. You can suppress the timeout error.
 		The length of the string is not limited. The response is then trimmed for trailing LF.
 		Sending of any read events is blocked. Use this method for all the service VisaSession queries."""
 		response = ''
 		self.write(query)
 		try:
 			response = self._read_str_timed(timeout, suppress_read_tout)
 		except pyvisa.VisaIOError:
-			self._narrow_down_io_tout_error(f"Querying with timeout {timeout} ms '{query.rstrip(self._term_char)}' - ", timeout)
+			self._narrow_down_io_tout_error(f"Query with timeout {timeout} ms '{query.rstrip(self._term_char)}' - ", timeout)
 		return response
 
 	def _read_str_timed(self, timeout: int, suppress_read_tout: bool = False) -> str:
 		"""Reads response from the instrument with a VISA timeout temporarily set for the read.
 		The VISA timeout is set back to the previous value before the method finishes even if an exception occurs.
 		Sending of any read events is blocked."""
 		old_visa_tout = self.visa_timeout
@@ -748,15 +897,15 @@
 		"""Queries the instrument and reads the response as string.
 		The length of the string is not limited. The response is then trimmed for trailing LF."""
 		response = ''
 		self.write(query)
 		try:
 			response = self._read_str()
 		except pyvisa.VisaIOError:
-			self._narrow_down_io_tout_error(f"Querying '{query.rstrip(self._term_char)}' - ")
+			self._narrow_down_io_tout_error(f"Query '{query.rstrip(self._term_char)}' - ")
 		return response
 
 	def query_str_no_tout_err(self, query: str, tout: int) -> str:
 		"""Same as query_str, but you can set the timeout just for this one call.
 		If the timeout exception occurs, it is suppressed and the method returns Null"""
 		response = None
 		old_tout = self.visa_timeout
@@ -770,23 +919,23 @@
 		return response
 
 	def write_with_opc(self, command: str, timeout: int = None) -> None:
 		"""Sends command with OPC-sync.
 		If you do not provide timeout, the method uses current opc_timeout."""
 		self._write_and_wait_for_opc(command, False, timeout)
 
-	def query_str_with_opc(self, query: str, timeout: int = None) -> str:
+	def query_str_with_opc(self, query: str, timeout: int = None, context: str = 'Query string with OPC') -> str:
 		"""Query string with OPC synchronization.
 		The response is trimmed for any trailing LF.
 		If you do not provide timeout, the method uses current opc_timeout."""
 		timeout = self._resolve_opc_timeout(timeout)
 		if self.vxi_capable and self._opc_wait_mode is not WaitForOpcMode.opc_query:
 			# For Vxi session, use the STB poll or SRQ wait and then read the response
 			stb = self._write_and_wait_for_opc(query, True, timeout)
-			self._check_msg_available_after_opc_wait(stb, query, timeout, 'Query String With OPC')
+			self._check_msg_available_after_opc_wait(stb, query, timeout, context)
 			response = self._read_str()
 		else:
 			# For non-Vxi sessions, use the longer VISA Timeout without the *OPC?
 			# Same is valid for WaitForOpcMode.OpcQuery
 			InstrumentErrors.assert_query_has_qmark(query, 'Query with VISA timeout')
 			self.write(query)
 			old_tout = self.visa_timeout
@@ -824,57 +973,59 @@
 		"""Used internally after _StbPolling() to check if the message is available.
 		Throws an exception in case of MAV not available."""
 		if not self.vxi_capable:
 			return
 		if stb & StatusByte.message_available:
 			return
 		# Message not available
-		context = context + f" SCPI query '{query.rstrip(self._term_char)}'"
+		context = context + f" Query '{query.rstrip(self._term_char)}'"
 		if stb & StatusByte.error_queue_not_empty:
 			# Instrument reports an error
-			InstrumentErrors.assert_no_instrument_status_errors(self._resource_name, self.query_all_syst_errors(), context)
+			InstrumentErrors.assert_no_instrument_status_errors(self.resource_name, self.query_all_syst_errors(), context)
 		else:
 			# Sometimes even if the StatusByte.MessageAvailable is false, the message is available.
 			# Try to read the STB again
 			stb = self._read_stb()
 			if not stb & StatusByte.event_status_byte:
 				# Instrument did not respond within the defined time
 				InstrumentErrors.throw_opc_tout_exception(self.opc_timeout, timeout, f'{context} No response from the instrument.')
 
 	def error_in_error_queue(self) -> bool:
 		"""Returns true, if error queue contains at least one error."""
 		stb = self._query_stb()
-		return (stb & StatusByte.error_queue_not_empty) != 0
+		if stb & StatusByte.error_queue_not_empty:
+			return True
+		return False
 
 	def reset_ese_sre(self) -> None:
 		"""Resets the status of ESE and SRE registers to default values."""
 		self._set_regs_ese_sre(self._opc_wait_mode)
 
 	def write_bin_block(self, cmd: str, data_stream: StreamReader) -> None:
 		"""Writes all the payload as binary data block to the instrument.
 		The binary data header is added at the beginning of the transmission automatically.
 		:param cmd: [str] SCPI command with which to send the data
 		:param data_stream: [StreamReader] data provider for the payload"""
 		data_size = len(data_stream)
 		len_str = f'{data_size}'
 		cmd = cmd.rstrip(self._term_char)
 		if '#' in cmd:
-			raise Exception(
+			raise RsInstrException(
 				f"Command '{cmd}' must be provided without the binary data header. "
 				f"The method 'write_bin_block' composes and prepends the binary data header automatically.")
 		if data_size <= self._std_bin_block_header_max_len:
 			# Standard bin data header for sizes below 1E9 bytes, e.g.: '#512345'
-			cmd_plus_header = f'{cmd}#{len(len_str)}{len_str}'.encode('utf-8')
+			cmd_plus_header = f'{cmd}#{len(len_str)}{len_str}'.encode(self.encoding)
 		else:
 			# Big sizes bin data header: e.g.: '#(3000000000)'
-			cmd_plus_header = f'{cmd}#({len_str})'.encode('utf-8')
+			cmd_plus_header = f'{cmd}#({len_str})'.encode(self.encoding)
 
 		if data_size <= self._data_chunk_size:
 			# Write all in one step
-			full_chunk = data_stream.read_as_binary()
+			full_chunk = data_stream.read_as_binary(self.encoding)
 			write_buf = cmd_plus_header + full_chunk
 			if self._add_term_char_to_write_bin_block:
 				write_buf += self._term_char_bin
 			self._session.write_raw(write_buf)
 			# Event sending
 			if self.on_write_chunk_handler:
 				event_args = EventArgsChunk(True, 0, data_size, data_size, data_size, True, 1, full_chunk if self.io_events_include_data else None)
@@ -890,24 +1041,24 @@
 					time.sleep(self.write_delay / 1000)
 				# Write bin header
 				self._session.write_raw(cmd_plus_header)
 				# Write chunks
 				while True:
 					if len(data_stream) > self._data_chunk_size:
 						#  Not the last segment
-						chunk = data_stream.read_as_binary(self._data_chunk_size)
+						chunk = data_stream.read_as_binary(self.encoding, self._data_chunk_size)
 						self._session.write_raw(chunk)
 						# Event sending
 						if self.on_write_chunk_handler:
 							event_args = EventArgsChunk(
 								True, chunk_ix, self._data_chunk_size, data_size, data_size - len(data_stream), False, total_chunks, chunk if self.io_events_include_data else None)
 							self.on_write_chunk_handler(event_args)
 					else:
 						# Last segment, indicate end of message again
-						chunk = data_stream.read_as_binary()
+						chunk = data_stream.read_as_binary(self.encoding)
 						if self._add_term_char_to_write_bin_block:
 							# Append LF
 							self._session.write_raw(chunk)
 							self._session.send_end = True
 							self._session.write_raw(self._term_char_bin)
 						else:
 							self._session.send_end = True
@@ -936,60 +1087,88 @@
 			char = self._session.read_bytes(1, break_on_termchar=True)
 			if char == b'0':
 				data_type = ReadDataType.bin_unknown_len
 				return data_type, '#0', -1
 			if char == b'(':
 				# format for big lengths i.e. > 1E9 bytes: '#(1234567890123)...'
 				data_type = ReadDataType.bin_known_len
-				len_str = (self.read_up_to_char(b')', 100)[:-1]).decode('utf-8')
+				len_str = (self.read_up_to_char(b')', 100)[:-1]).decode(self.encoding)
 				whole_hdr = '#(' + len_str + ')'
 				length = int(len_str)
 				return data_type, whole_hdr, length
 
 			# classic format for < 1E9 bytes: '#9123456789...'
 			data_type = ReadDataType.bin_known_len
 			len_of_len = int(char)
-			len_str = self._session.read_bytes(len_of_len).decode('utf-8')
+			len_str = self._session.read_bytes(len_of_len).decode(self.encoding)
 			length = int(len_str)
-			whole_hdr = '#' + char.decode('utf-8') + len_str
+			whole_hdr = '#' + char.decode(self.encoding) + len_str
 			return data_type, whole_hdr, length
 
 		data_type = ReadDataType.ascii
 		if char == self._term_char_bin:
 			data_type = ReadDataType.null
 		if self.vxi_capable:
 			# For Vxi session, to be sure, check whether there are more chars in the read buffer
 			stb = self._read_stb()
 			if stb & StatusByte.message_available:
 				data_type = ReadDataType.ascii
-		whole_hdr = char.decode('utf-8')
+		whole_hdr = char.decode(self.encoding)
 		if exc_if_not_bin:
 			if data_type == ReadDataType.null:
-				InstrumentErrors.throw_bin_block_unexp_resp_exception(self._resource_name, self._term_char)
+				InstrumentErrors.throw_bin_block_unexp_resp_exception(self.resource_name, self._term_char)
 			# Read 20 more characters to compose a better exception message
-			whole_hdr += self.read_up_to_char(self._term_char_bin, 20).decode('utf-8')
+			whole_hdr += self.read_up_to_char(self._term_char_bin, 20).decode(self.encoding)
 			if self.last_status == pyvisa.constants.StatusCode.success_max_count_read:
 				self._flush_junk_data()
-			InstrumentErrors.throw_bin_block_unexp_resp_exception(self._resource_name, whole_hdr)
+			InstrumentErrors.throw_bin_block_unexp_resp_exception(self.resource_name, whole_hdr)
 		return data_type, whole_hdr, length
 
+	def get_bin_data_length(self, query: str) -> int or None:
+		"""Returns only the length binary data header, and discards the actual data.
+		Any timeout error is suppressed, and the method returns None instead.
+		Warning!!! - for non-VXI sessions (SOCKET, ASRL) this method transfers the entire file to the control PC, which might take a long time."""
+		if self.vxi_capable and self._opc_wait_mode != WaitForOpcMode.opc_query:
+			# For Vxi session, use the STB poll and read the header
+			stb = self._write_and_wait_for_opc(query, True, 0)
+			try:
+				self._check_msg_available_after_opc_wait(stb, query, 0, 'get_bin_data_length')
+			except InstrumentErrors.StatusException:
+				return None
+			data_type, header, length = self._parse_bin_data_header(True)
+			self.clear()
+			self.clear_before_read()
+			return length
+		else:
+			with StreamWriter.as_forget() as stream:
+				old_timeout = self.visa_timeout
+				try:
+					self.visa_timeout = 2000
+					self.query_bin_block(query, stream, True)
+				except InstrumentErrors.StatusException:
+					return None
+				finally:
+					self.visa_timeout = old_timeout
+				length = stream.written_len
+		return length
+
 	def read_bin_block(self, stream: StreamWriter, exc_if_not_bin: bool) -> None:
 		"""Reads binary data block to the provided stream. \n
 		:param stream: [StreamWriter] target for the read data. Can be string, bytes, or a file
 		:param exc_if_not_bin: if True, the method throws exception if the received data is not binary"""
 		data_type, header, length = self._parse_bin_data_header(exc_if_not_bin)
 		if data_type == ReadDataType.ascii:
-			stream.switch_to_string_data()
+			stream.switch_to_string_data(self.encoding)
 			self._read_unknown_len(stream, True, header)
 		elif data_type == ReadDataType.null:
-			# No data, consider it ASCII, Return empty string, and False (signaling ASCII transfer)
-			stream.switch_to_string_data()
+			# No data, consider it ASCII. Change the stream type to ASCII and return empty string
+			stream.switch_to_string_data(self.encoding)
 		elif data_type == ReadDataType.bin_unknown_len:
 			if not self.vxi_capable:
-				raise Exception(f'Non-Vxi11 sessions can not read binary data block of unknown length.')
+				raise RsInstrException(f'Non-Vxi11 sessions can not read binary data block of unknown length.')
 			self._read_unknown_len(stream, True)
 		elif length == 0:
 			self._flush_junk_data()
 		else:
 			self._read_bin_block_known_len(stream, length)
 
 	def _read_bin_block_known_len(self, stream: StreamWriter, length: int) -> None:
@@ -1027,15 +1206,18 @@
 
 	def query_bin_block(self, query: str, stream: StreamWriter, exc_if_not_bin: bool = True) -> None:
 		"""Query binary data block and returns it as byte data. \n
 		:param query: [str] query to send to the instrument
 		:param stream: [StreamWriter] target for the read data. Can be string, bytes, or a file
 		:param exc_if_not_bin: [Boolean] if True, the method throws exception if the received data is not binary"""
 		self.write(query)
-		self.read_bin_block(stream, exc_if_not_bin)
+		try:
+			self.read_bin_block(stream, exc_if_not_bin)
+		except pyvisa.VisaIOError:
+			self._narrow_down_io_tout_error(f"Query bin block '{query.rstrip(self._term_char)}' - ")
 		return
 
 	def query_bin_block_with_opc(self, query: str, stream: StreamWriter, exc_if_not_bin: bool = True, timeout: int = None) -> None:
 		"""Query binary data block with OPC and returns it as byte data.
 		:param query: [str] query to send to the instrument
 		:param stream: [StreamWriter] target for the read data. Can be string, bytes, or a file
 		:param exc_if_not_bin: [Boolean] if True, the method throws exception if the received data is not binary
@@ -1073,14 +1255,28 @@
 			response += char
 			if char in stop_chars:
 				break
 			if self.last_status != pyvisa.constants.StatusCode.success_max_count_read:
 				break
 		return response
 
+	def go_to_local(self) -> None:
+		"""Puts the instrument into local state."""
+		if self.vxi_capable:
+			self._session.control_ren(pyvisa.constants.RENLineOperation.deassert_gtl)
+		else:
+			self.write("&GTL")
+
+	def go_to_remote(self) -> None:
+		"""Puts the instrument into remote state."""
+		if self.vxi_capable:
+			self._session.control_ren(pyvisa.constants.RENLineOperation.asrt_address)
+		else:
+			self.write("&GTR")
+
 	def get_session_handle(self) -> object:
 		"""Returns the underlying pyvisa session."""
 		return self._session
 
 	def close(self) -> None:
 		"""Closes the Visa session.
 		If the object was created with the direct session input, the session is not closed."""
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/Internal/VisaSessionSim.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/Internal/VisaSessionSim.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""VisaSession for simulated sessions."""
+
 import threading
 from typing import Callable, Dict, AnyStr
 
 from . import InstrumentSettings
 from .StreamReader import StreamReader
 from .StreamWriter import StreamWriter
 
@@ -9,14 +11,15 @@
 # noinspection PyMethodMayBeStatic,PyUnusedLocal
 class VisaSessionSim(object):
 	"""Visa session in simulation mode.
 	Provides the properties for the simulation mode.
 	Also serves as a cache for the SCPI command values: If you query a SCPI command value, it returns the last set value by that SCPI command."""
 
 	def __init__(self, resource_name: str, settings: InstrumentSettings, direct_session=None):
+		self.reusing_session = direct_session is not None
 		# noinspection PyTypeChecker
 		self._data_chunk_size: int = None
 		# noinspection PyTypeChecker
 		self._lock: threading.RLock = None
 
 		# Event handlers
 		# noinspection PyTypeChecker
@@ -25,16 +28,17 @@
 		# noinspection PyTypeChecker
 		self.on_write_chunk_handler: Callable = None
 		"""If assigned a handler, the VisaSession sends it event on each write chunk transfer."""
 		self.io_events_include_data: bool = False
 		"""If true, the VisaSession events sent to on_read_chunk_handler and on_write_chunk_handler contain transferred data."""
 
 		self.manufacturer: str = 'Rohde&Schwarz'
-		self._resource_name = resource_name
+		self.resource_name = resource_name
 		self.vxi_capable = True
+		self.encoding = settings.encoding  # default encoder between bytes and string
 
 		# Changeable settings
 		self.opc_timeout = 10000 if settings.opc_timeout == 0 else settings.opc_timeout
 		self.visa_timeout = settings.visa_timeout
 		self.data_chunk_size = settings.io_segment_size
 
 		self._last_cmd = None
@@ -50,14 +54,17 @@
 			rlock = direct_session.session_thread_rlock
 			if isinstance(rlock, type(threading.RLock())):
 				self.assign_lock(rlock)
 		if self.get_lock() is None:
 			# The existing session did not have a thread lock, assign a new one
 			self.assign_lock(threading.RLock())
 
+		if self.reusing_session:
+			self.resource_name = direct_session.resource_name
+
 	def assign_lock(self, lock: threading.RLock) -> None:
 		"""Assigns the provided thread lock. The lock is only used by the parent class Instrument."""
 		self._lock = lock
 
 	def get_lock(self) -> threading.RLock:
 		"""Returns the current RLock object."""
 		return self._lock
@@ -92,25 +99,30 @@
 		return False
 
 	def query_syst_error(self) -> str or None:
 		"""Returns one response to the SYSTEM:ERROR? query."""
 		return None
 
 	def query_all_syst_errors(self) -> list or None:
-		"""Returns all errors in the instrument's error queue."""
-		return []
+		"""Returns all errors in the instrument's error queue.
+		If no error is detected, the return value is None."""
+		return None
 
 	def clear_before_read(self) -> None:
 		"""Clears IO buffers and the ESR register before reading/writing responses synchronized with *OPC."""
 		return
 
 	def clear(self) -> None:
 		"""Perform VISA viClear conditionally based on the instrument settings."""
 		return
 
+	def clear_status_after_query_with_opc(self) -> bool:
+		"""Returns true, if the opc-sync queries require status clearing afterward."""
+		return False
+
 	def write(self, cmd: str) -> None:
 		"""Writes command to the instrument."""
 		self._last_cmd = cmd
 		self._update_cmd_vals_cache(cmd)
 		return
 
 	def query_str(self, query: str) -> str:
@@ -121,15 +133,15 @@
 		return 'Simulating' if cached is None else cached
 
 	def write_with_opc(self, cmd: str, timeout: int = None) -> None:
 		"""Sends command with OPC-sync.
 		If you do not provide timeout, the method uses current opc_timeout."""
 		self.write(cmd)
 
-	def query_str_with_opc(self, query: str, timeout: int = None) -> str:
+	def query_str_with_opc(self, query: str, timeout: int = None, context: str = 'Query string with OPC') -> str:
 		"""Query string with OPC synchronization.
 		The response is trimmed for any trailing LF.
 		If you do not provide timeout, the method uses current opc_timeout."""
 		return self.query_str(query)
 
 	def query_opc(self, timeout: int = 0) -> bool:
 		"""Sends *OPC? query and reads the result."""
@@ -160,28 +172,28 @@
 		cached = self._get_cmd_cached_value(query)
 
 		if cached is None:
 			stream.write(bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 65, 66]))
 			self.cached_to_stream = False
 		else:
 			if isinstance(cached, str):
-				stream.switch_to_string_data()
+				stream.switch_to_string_data(self.encoding)
 			stream.write(cached)
 			self.cached_to_stream = True
 
 	def query_bin_block_with_opc(self, query: str, stream: StreamWriter, exc_if_not_bin: bool = True, timeout: int = None) -> None:
 		"""Query binary data block with OPC and returns it as byte data."""
 		self.query_bin_block(query, stream)
 
 	def read_up_to_char(self, stop_chars: bytes, max_cnt: int) -> bytes:
 		"""Reads until one of the stop_chars is read or the max_cnt is reached, or EOT is detected.
 		Returns the read data including the stop character."""
 		return b'Simulating'
 
 	def get_session_handle(self) -> object:
 		"""Returns the underlying pyvisa session."""
-		return f"Simulating session, resource name '{self._resource_name}'"
+		return f"Simulating session, resource name '{self.resource_name}'"
 
 	def close(self) -> None:
 		"""Closes the Visa session.
 		If the object was created with the direct session input, the session is not closed."""
 		return
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/RsCmwBluetoothMeas.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/RsCmwBluetoothMeas.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,92 +1,157 @@
-from typing import List
+from typing import ClassVar, List
 
 from .Internal.Core import Core
 from .Internal.InstrumentErrors import RsInstrException
 from .Internal.CommandsGroup import CommandsGroup
 from .Internal.VisaSession import VisaSession
+from datetime import datetime, timedelta
 from . import repcap
 from .Internal.RepeatedCapability import RepeatedCapability
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
 class RsCmwBluetoothMeas:
-	"""797 total commands, 12 Sub-groups, 0 group commands"""
-	_driver_options = "SupportedInstrModels = CMW500/CMW100/CMW270/CMW280/CMP, SupportedIdnPatterns = CMW, SimulationIdnString = 'Rohde&Schwarz,CMW500,100001,3.8.20.0028'"
+	"""1209 total commands, 14 Subgroups, 0 group commands"""
+	_driver_options = "SupportedInstrModels = CMW500/CMW100/CMW270/CMW280/CMP, SupportedIdnPatterns = CMW, SimulationIdnString = 'Rohde&Schwarz,CMW500,100001,4.0.110.0031'"
+	_global_logging_relative_timestamp: ClassVar[datetime] = None
+	_global_logging_target_stream: ClassVar = None
 
 	def __init__(self, resource_name: str, id_query: bool = True, reset: bool = False, options: str = None, direct_session: object = None):
 		"""Initializes new RsCmwBluetoothMeas session. \n
 		Parameter options tokens examples:
-			- 'Simulate=True' - starts the session in simulation mode. Default: False
-			- 'SelectVisa=socket' - uses no VISA implementation for socket connections - you do not need any VISA-C installation
-			- 'SelectVisa=rs' - forces usage of RohdeSchwarz Visa
-			- 'SelectVisa=ni' - forces usage of National Instruments Visa
-			- 'QueryInstrumentStatus = False' - same as driver.utilities.instrument_status_checking = False
-			- 'DriverSetup=(WriteDelay = 20, ReadDelay = 5)' - Introduces delay of 20ms before each write and 5ms before each read
-			- 'DriverSetup=(OpcWaitMode = OpcQuery)' - mode for all the opc-synchronised write/reads. Other modes: StbPolling, StbPollingSlow, StbPollingSuperSlow
-			- 'DriverSetup=(AddTermCharToWriteBinBLock = True)' - Adds one additional LF to the end of the binary data (some instruments require that)
-			- 'DriverSetup=(AssureWriteWithTermChar = True)' - Makes sure each command/query is terminated with termination character. Default: Interface dependent
-			- 'DriverSetup=(TerminationCharacter = 'x')' - Sets the termination character for reading. Default: '<LF>' (LineFeed)
-			- 'DriverSetup=(IoSegmentSize = 10E3)' - Maximum size of one write/read segment. If transferred data is bigger, it is split to more segments
-			- 'DriverSetup=(OpcTimeout = 10000)' - same as driver.utilities.opc_timeout = 10000
-			- 'DriverSetup=(VisaTimeout = 5000)' - same as driver.utilities.visa_timeout = 5000
-			- 'DriverSetup=(ViClearExeMode = 255)' - Binary combination where 1 means performing viClear() on a certain interface as the very first command in init
-			- 'DriverSetup=(OpcQueryAfterWrite = True)' - same as driver.utilities.opc_query_after_write = True
+			- ``Simulate=True`` - starts the session in simulation mode. Default: ``False``
+			- ``SelectVisa=socket`` - uses no VISA implementation for socket connections - you do not need any VISA-C installation
+			- ``SelectVisa=rs`` - forces usage of RohdeSchwarz Visa
+			- ``SelectVisa=ivi`` - forces usage of National Instruments Visa
+			- ``QueryInstrumentStatus = False`` - same as ``driver.utilities.instrument_status_checking = False``. Default: ``True``
+			- ``WriteDelay = 20, ReadDelay = 5`` - Introduces delay of 20ms before each write and 5ms before each read. Default: ``0ms`` for both
+			- ``OpcWaitMode = OpcQuery`` - mode for all the opc-synchronised write/reads. Other modes: StbPolling, StbPollingSlow, StbPollingSuperSlow. Default: ``StbPolling``
+			- ``AddTermCharToWriteBinBLock = True`` - Adds one additional LF to the end of the binary data (some instruments require that). Default: ``False``
+			- ``AssureWriteWithTermChar = True`` - Makes sure each command/query is terminated with termination character. Default: Interface dependent
+			- ``TerminationCharacter = "\\r"`` - Sets the termination character for reading. Default: ``\\n`` (LineFeed or LF)
+			- ``DataChunkSize = 10E3`` - Maximum size of one write/read segment. If transferred data is bigger, it is split to more segments. Default: ``1E6`` bytes
+			- ``OpcTimeout = 10000`` - same as driver.utilities.opc_timeout = 10000. Default: ``30000ms``
+			- ``VisaTimeout = 5000`` - same as driver.utilities.visa_timeout = 5000. Default: ``10000ms``
+			- ``ViClearExeMode = Disabled`` - viClear() execution mode. Default: ``execute_on_all``
+			- ``OpcQueryAfterWrite = True`` - same as driver.utilities.opc_query_after_write = True. Default: ``False``
+			- ``StbInErrorCheck = False`` - if true, the driver checks errors with *STB? If false, it uses SYST:ERR?. Default: ``True``
+			- ``ScpiQuotes = double'. - for SCPI commands, you can define how strings are quoted. With single or double quotes. Possible values: single | double | {char}. Default: ``single``
+			- ``LoggingMode = On`` - Sets the logging status right from the start. Default: ``Off``
+			- ``LoggingName = 'MyDevice'`` - Sets the name to represent the session in the log entries. Default: ``'resource_name'``
+			- ``LogToGlobalTarget = True`` - Sets the logging target to the class-property previously set with RsCmwBluetoothMeas.set_global_logging_target() Default: ``False``
+			- ``LoggingToConsole = True`` - Immediately starts logging to the console. Default: False
+			- ``LoggingToUdp = True`` - Immediately starts logging to the UDP port. Default: False
+			- ``LoggingUdpPort = 49200`` - UDP port to log to. Default: 49200
 		:param resource_name: VISA resource name, e.g. 'TCPIP::192.168.2.1::INSTR'
-		:param id_query: if True: the instrument's model name is verified against the models supported by the driver and eventually throws an exception.
-		:param reset: Resets the instrument (sends *RST command) and clears its status sybsystem
+		:param id_query: if True, the instrument's model name is verified against the models supported by the driver and eventually throws an exception.
+		:param reset: Resets the instrument (sends *RST command) and clears its status sybsystem.
 		:param options: string tokens alternating the driver settings.
 		:param direct_session: Another driver object or pyVisa object to reuse the session instead of opening a new session."""
 		self._core = Core(resource_name, id_query, reset, RsCmwBluetoothMeas._driver_options, options, direct_session)
-		self._core.driver_version = '3.8.20.0028'
+		self._core.driver_version = '4.0.110.0031'
 		self._options = options
 		self._add_all_global_repcaps()
 		self._custom_properties_init()
+		self.utilities.default_instrument_setup()
 		# noinspection PyTypeChecker
-		self._base = CommandsGroup("ROOT", self._core, None)
+		self._cmd_group = CommandsGroup("ROOT", self._core, None)
 
 	@classmethod
 	def from_existing_session(cls, session: object, options: str = None) -> 'RsCmwBluetoothMeas':
 		"""Creates a new RsCmwBluetoothMeas object with the entered 'session' reused. \n
-		:param session: can be an another driver or a direct pyvisa session.
+		:param session: can be another driver or a direct pyvisa session.
 		:param options: string tokens alternating the driver settings."""
 		# noinspection PyTypeChecker
-		return cls(None, False, False, options, session)
+		resource_name = None
+		if hasattr(session, 'resource_name'):
+			resource_name = getattr(session, 'resource_name')
+		return cls(resource_name, False, False, options, session)
+		
+	@classmethod
+	def set_global_logging_target(cls, target) -> None:
+		"""Sets global common target stream that each instance can use. To use it, call the following: io.utilities.logger.set_logging_target_global().
+		If an instance uses global logging target, it automatically uses the global relative timestamp (if set).
+		You can set the target to None to invalidate it."""
+		cls._global_logging_target_stream = target
+
+	@classmethod
+	def get_global_logging_target(cls):
+		"""Returns global common target stream."""
+		return cls._global_logging_target_stream
+
+	@classmethod
+	def set_global_logging_relative_timestamp(cls, timestamp: datetime) -> None:
+		"""Sets global common relative timestamp for log entries. To use it, call the following: io.utilities.logger.set_relative_timestamp_global()"""
+		cls._global_logging_relative_timestamp = timestamp
+
+	@classmethod
+	def set_global_logging_relative_timestamp_now(cls) -> None:
+		"""Sets global common relative timestamp for log entries to this moment.
+		To use it, call the following: io.utilities.logger.set_relative_timestamp_global()."""
+		cls._global_logging_relative_timestamp = datetime.now()
+
+	@classmethod
+	def clear_global_logging_relative_timestamp(cls) -> None:
+		"""Clears the global relative timestamp. After this, all the instances using the global relative timestamp continue logging with the absolute timestamps."""
+		# noinspection PyTypeChecker
+		cls._global_logging_relative_timestamp = None
+
+	@classmethod
+	def get_global_logging_relative_timestamp(cls) -> datetime or None:
+		"""Returns global common relative timestamp for log entries."""
+		return cls._global_logging_relative_timestamp
 
 	def __str__(self) -> str:
 		if self._core.io:
 			return f"RsCmwBluetoothMeas session '{self._core.io.resource_name}'"
 		else:
 			return f"RsCmwBluetoothMeas with session closed"
 
+	def get_total_execution_time(self) -> timedelta:
+		"""Returns total time spent by the library on communicating with the instrument.
+		This time is always shorter than get_total_time(), since it does not include gaps between the communication.
+		You can reset this counter with reset_time_statistics()."""
+		return self._core.io.total_execution_time
+
+	def get_total_time(self) -> timedelta:
+		"""Returns total time spent by the library on communicating with the instrument.
+		This time is always shorter than get_total_time(), since it does not include gaps between the communication.
+		You can reset this counter with reset_time_statistics()."""
+		return datetime.now() - self._core.io.total_time_startpoint
+
+	def reset_time_statistics(self) -> None:
+		"""Resets all execution and total time counters. Affects the results of get_total_time() and get_total_execution_time()"""
+		self._core.io.reset_time_statistics()
+
 	@staticmethod
 	def assert_minimum_version(min_version: str) -> None:
 		"""Asserts that the driver version fulfills the minimum required version you have entered.
 		This way you make sure your installed driver is of the entered version or newer."""
 		min_version_list = min_version.split('.')
-		curr_version_list = '3.8.20.0028'.split('.')
+		curr_version_list = '4.0.110.0031'.split('.')
 		count_min = len(min_version_list)
 		count_curr = len(curr_version_list)
 		count = count_min if count_min < count_curr else count_curr
 		for i in range(count):
 			minimum = int(min_version_list[i])
 			curr = int(curr_version_list[i])
 			if curr > minimum:
 				break
 			if curr < minimum:
-				raise RsInstrException(f"Assertion for minimum RsCmwBluetoothMeas version failed. Current version: '3.8.20.0028', minimum required version: '{min_version}'")
-				
+				raise RsInstrException(f"Assertion for minimum RsCmwBluetoothMeas version failed. Current version: '4.0.110.0031', minimum required version: '{min_version}'")
+
 	@staticmethod
 	def list_resources(expression: str = '?*::INSTR', visa_select: str = None) -> List[str]:
 		"""Finds all the resources defined by the expression
 			- '?*' - matches all the available instruments
 			- 'USB::?*' - matches all the USB instruments
-			- "TCPIP::192?*' - matches all the LAN instruments with the IP address starting with 192
+			- 'TCPIP::192?*' - matches all the LAN instruments with the IP address starting with 192
 		:param expression: see the examples in the function
-		:param visa_select: optional parameter selecting a specific VISA. Examples: '@ni', '@rs'
+		:param visa_select: optional parameter selecting a specific VISA. Examples: '@ivi', '@rs'
 		"""
 		rm = VisaSession.get_resource_manager(visa_select)
 		resources = rm.list_resources(expression)
 		rm.close()
 		# noinspection PyTypeChecker
 		return resources
 
@@ -99,138 +164,159 @@
 		return self._core.get_session_handle()
 
 	def _add_all_global_repcaps(self) -> None:
 		"""Adds all the repcaps defined as global to the instrument's global repcaps dictionary."""
 		self._core.io.add_global_repcap('<Instance>', RepeatedCapability("ROOT", 'repcap_instance_get', 'repcap_instance_set', repcap.Instance.Inst1))
 
 	def repcap_instance_get(self) -> repcap.Instance:
-		"""Returns Global Repeated capability Instance \n
-		Selects the instrument"""
+		"""Returns Global Repeated capability Instance"""
 		return self._core.io.get_global_repcap_value('<Instance>')
 
 	def repcap_instance_set(self, value: repcap.Instance) -> None:
-		"""Sets Global Repeated capability Instance \n
-		Selects the instrument
+		"""Sets Global Repeated capability Instance
 		Default value after init: Instance.Inst1"""
 		self._core.io.set_global_repcap_value('<Instance>', value)
 
-	def _custom_properties_init(self):
+	def _custom_properties_init(self) -> None:
 		"""Adds all the interfaces that are custom for the driver."""
 		from .CustomFiles.utilities import Utilities
 		self.utilities = Utilities(self._core)
 		from .CustomFiles.events import Events
 		self.events = Events(self._core)
 		from .CustomFiles.reliability import Reliability
 		self.reliability = Reliability(self._core)
+		
+	def _sync_to_custom_properties(self, cloned: 'RsCmwBluetoothMeas') -> None:
+		"""Synchronises the state of all the custom properties to the entered object."""
+		cloned.utilities.sync_from(self.utilities)
+		cloned.events.sync_from(self.events)
+		cloned.reliability.sync_from(self.reliability)
 
 	@property
-	def call(self):
-		"""call commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_call'):
-			from .Implementations.Call import Call
-			self._call = Call(self._core, self._base)
-		return self._call
+	def hdrp(self):
+		"""hdrp commands group. 6 Sub-classes, 3 commands."""
+		if not hasattr(self, '_hdrp'):
+			from .Implementations.Hdrp import HdrpCls
+			self._hdrp = HdrpCls(self._core, self._cmd_group)
+		return self._hdrp
+
+	@property
+	def trigger(self):
+		"""trigger commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_trigger'):
+			from .Implementations.Trigger import TriggerCls
+			self._trigger = TriggerCls(self._core, self._cmd_group)
+		return self._trigger
 
 	@property
 	def configure(self):
-		"""configure commands group. 7 Sub-classes, 6 commands."""
+		"""configure commands group. 10 Sub-classes, 5 commands."""
 		if not hasattr(self, '_configure'):
-			from .Implementations.Configure import Configure
-			self._configure = Configure(self._core, self._base)
+			from .Implementations.Configure import ConfigureCls
+			self._configure = ConfigureCls(self._core, self._cmd_group)
 		return self._configure
 
 	@property
+	def route(self):
+		"""route commands group. 2 Sub-classes, 1 commands."""
+		if not hasattr(self, '_route'):
+			from .Implementations.Route import RouteCls
+			self._route = RouteCls(self._core, self._cmd_group)
+		return self._route
+
+	@property
+	def hdr(self):
+		"""hdr commands group. 7 Sub-classes, 3 commands."""
+		if not hasattr(self, '_hdr'):
+			from .Implementations.Hdr import HdrCls
+			self._hdr = HdrCls(self._core, self._cmd_group)
+		return self._hdr
+
+	@property
+	def multiEval(self):
+		"""multiEval commands group. 10 Sub-classes, 3 commands."""
+		if not hasattr(self, '_multiEval'):
+			from .Implementations.MultiEval import MultiEvalCls
+			self._multiEval = MultiEvalCls(self._core, self._cmd_group)
+		return self._multiEval
+
+	@property
+	def inputSignal(self):
+		"""inputSignal commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_inputSignal'):
+			from .Implementations.InputSignal import InputSignalCls
+			self._inputSignal = InputSignalCls(self._core, self._cmd_group)
+		return self._inputSignal
+
+	@property
+	def call(self):
+		"""call commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_call'):
+			from .Implementations.Call import CallCls
+			self._call = CallCls(self._core, self._cmd_group)
+		return self._call
+
+	@property
 	def dtMode(self):
 		"""dtMode commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_dtMode'):
-			from .Implementations.DtMode import DtMode
-			self._dtMode = DtMode(self._core, self._base)
+			from .Implementations.DtMode import DtModeCls
+			self._dtMode = DtModeCls(self._core, self._cmd_group)
 		return self._dtMode
 
 	@property
 	def sense(self):
 		"""sense commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_sense'):
-			from .Implementations.Sense import Sense
-			self._sense = Sense(self._core, self._base)
+			from .Implementations.Sense import SenseCls
+			self._sense = SenseCls(self._core, self._cmd_group)
 		return self._sense
 
 	@property
 	def clean(self):
 		"""clean commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_clean'):
-			from .Implementations.Clean import Clean
-			self._clean = Clean(self._core, self._base)
+			from .Implementations.Clean import CleanCls
+			self._clean = CleanCls(self._core, self._cmd_group)
 		return self._clean
 
 	@property
 	def diagnostic(self):
 		"""diagnostic commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_diagnostic'):
-			from .Implementations.Diagnostic import Diagnostic
-			self._diagnostic = Diagnostic(self._core, self._base)
+			from .Implementations.Diagnostic import DiagnosticCls
+			self._diagnostic = DiagnosticCls(self._core, self._cmd_group)
 		return self._diagnostic
 
 	@property
 	def rxQuality(self):
 		"""rxQuality commands group. 5 Sub-classes, 3 commands."""
 		if not hasattr(self, '_rxQuality'):
-			from .Implementations.RxQuality import RxQuality
-			self._rxQuality = RxQuality(self._core, self._base)
+			from .Implementations.RxQuality import RxQualityCls
+			self._rxQuality = RxQualityCls(self._core, self._cmd_group)
 		return self._rxQuality
 
 	@property
 	def trx(self):
 		"""trx commands group. 5 Sub-classes, 3 commands."""
 		if not hasattr(self, '_trx'):
-			from .Implementations.Trx import Trx
-			self._trx = Trx(self._core, self._base)
+			from .Implementations.Trx import TrxCls
+			self._trx = TrxCls(self._core, self._cmd_group)
 		return self._trx
 
-	@property
-	def multiEval(self):
-		"""multiEval commands group. 10 Sub-classes, 3 commands."""
-		if not hasattr(self, '_multiEval'):
-			from .Implementations.MultiEval import MultiEval
-			self._multiEval = MultiEval(self._core, self._base)
-		return self._multiEval
-
-	@property
-	def inputSignal(self):
-		"""inputSignal commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_inputSignal'):
-			from .Implementations.InputSignal import InputSignal
-			self._inputSignal = InputSignal(self._core, self._base)
-		return self._inputSignal
-
-	@property
-	def trigger(self):
-		"""trigger commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_trigger'):
-			from .Implementations.Trigger import Trigger
-			self._trigger = Trigger(self._core, self._base)
-		return self._trigger
-
-	@property
-	def route(self):
-		"""route commands group. 2 Sub-classes, 1 commands."""
-		if not hasattr(self, '_route'):
-			from .Implementations.Route import Route
-			self._route = Route(self._core, self._base)
-		return self._route
-
 	def clone(self) -> 'RsCmwBluetoothMeas':
 		"""Creates a deep copy of the RsCmwBluetoothMeas object. Also copies:
 			- All the existing Global repeated capability values
 			- All the default group repeated capabilities setting \n
 		Does not check the *IDN? response, and does not perform Reset.
 		After cloning, you can set all the repeated capabilities settings independentely from the original group.
 		Calling close() on the new object does not close the original VISA session"""
 		cloned = RsCmwBluetoothMeas.from_existing_session(self.get_session_handle(), self._options)
-		self._base.synchronize_repcaps(cloned)
+		self._cmd_group.synchronize_repcaps(cloned)
 		cloned.repcap_instance_set(self.repcap_instance_get())
+		self._sync_to_custom_properties(cloned)
 		return cloned
 
 	def restore_all_repcaps_to_default(self) -> None:
 		"""Sets all the Group and Global repcaps to their initial values"""
-		self._base.restore_repcaps()
+		self._cmd_group.restore_repcaps()
 		self.repcap_instance_set(repcap.Instance.Inst1)
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/__init__.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,27 +1,30 @@
 """RsCmwBluetoothMeas instrument driver
-	:version: 3.8.20.28
-	:copyright: 2021 by Rohde & Schwarz GMBH & Co. KG
+	:version: 4.0.110.31
+	:copyright: 2023 by Rohde & Schwarz GMBH & Co. KG
 	:license: MIT, see LICENSE for more details.
 """
 
-__version__ = '3.8.20.28'
+__version__ = '4.0.110.31'
 
 # Main class
 from RsCmwBluetoothMeas.RsCmwBluetoothMeas import RsCmwBluetoothMeas
 
 # Bin data format
 from RsCmwBluetoothMeas.Internal.Conversions import BinIntFormat, BinFloatFormat
 
 # Exceptions
 from RsCmwBluetoothMeas.Internal.InstrumentErrors import RsInstrException, TimeoutException, StatusException, UnexpectedResponseException, ResourceError, DriverValueError
 
 # Callback Event Argument prototypes
 from RsCmwBluetoothMeas.Internal.IoTransferEventArgs import IoTransferEventArgs
 
+# Logging Mode
+from RsCmwBluetoothMeas.Internal.ScpiLogger import LoggingMode
+
 # enums
 from RsCmwBluetoothMeas import enums
 
 # repcaps
 from RsCmwBluetoothMeas import repcap
 
 # Reliability interface
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/enums.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/enums.py`

 * *Files 14% similar despite different names*

```diff
@@ -57,18 +57,19 @@
 	DH1 = 0
 	DH3 = 1
 	DH5 = 2
 
 
 # noinspection SpellCheckingInspection
 class BurstType(Enum):
-	"""3 Members, BR ... LE"""
+	"""4 Members, BR ... QHSL"""
 	BR = 0
 	EDR = 1
 	LE = 2
+	QHSL = 3
 
 
 # noinspection SpellCheckingInspection
 class CmwSingleConnector(Enum):
 	"""48 Members, R11 ... RB8"""
 	R11 = 0
 	R12 = 1
@@ -141,14 +142,22 @@
 	AOA2us = 1
 	AOAus = 2
 	AOD1us = 3
 	AOD2us = 4
 
 
 # noinspection SpellCheckingInspection
+class CteType(Enum):
+	"""3 Members, AOA ... AOD2"""
+	AOA = 0
+	AOD1 = 1
+	AOD2 = 2
+
+
+# noinspection SpellCheckingInspection
 class DataBits(Enum):
 	"""2 Members, D7 ... D8"""
 	D7 = 0
 	D8 = 1
 
 
 # noinspection SpellCheckingInspection
@@ -157,14 +166,24 @@
 	ALTernating = 0
 	OTHer = 1
 	P11 = 2
 	P44 = 3
 
 
 # noinspection SpellCheckingInspection
+class DetectedPhyTypeIsignal(Enum):
+	"""5 Members, P2Q ... P6Q"""
+	P2Q = 0
+	P3Q = 1
+	P4Q = 2
+	P5Q = 3
+	P6Q = 4
+
+
+# noinspection SpellCheckingInspection
 class DisplayMeasurement(Enum):
 	"""1 Members, MEV ... MEV"""
 	MEV = 0
 
 
 # noinspection SpellCheckingInspection
 class DisplayView(Enum):
@@ -240,14 +259,27 @@
 	"""3 Members, LE1M ... LELR"""
 	LE1M = 0
 	LE2M = 1
 	LELR = 2
 
 
 # noinspection SpellCheckingInspection
+class LePhysicalTypeB(Enum):
+	"""8 Members, LE1M ... P6Q"""
+	LE1M = 0
+	LE2M = 1
+	LELR = 2
+	P2Q = 3
+	P3Q = 4
+	P4Q = 5
+	P5Q = 6
+	P6Q = 7
+
+
+# noinspection SpellCheckingInspection
 class LeRangePaternType(Enum):
 	"""6 Members, ALL0 ... PRBS9"""
 	ALL0 = 0
 	ALL1 = 1
 	OTHer = 2
 	P11 = 3
 	P44 = 4
@@ -285,14 +317,31 @@
 	ALTernating = 1
 	OTHer = 2
 	P11 = 3
 	P44 = 4
 
 
 # noinspection SpellCheckingInspection
+class PacketTypeIsignal(Enum):
+	"""6 Members, H41P ... H85P"""
+	H41P = 0
+	H43P = 1
+	H45P = 2
+	H81P = 3
+	H83P = 4
+	H85P = 5
+
+
+# noinspection SpellCheckingInspection
+class PacketTypeQhsl(Enum):
+	"""1 Members, DATA ... DATA"""
+	DATA = 0
+
+
+# noinspection SpellCheckingInspection
 class ParameterSetMode(Enum):
 	"""2 Members, GLOBal ... LIST"""
 	GLOBal = 0
 	LIST = 1
 
 
 # noinspection SpellCheckingInspection
@@ -317,14 +366,29 @@
 	ALL1 = 1
 	P11 = 2
 	P44 = 3
 	PRBS9 = 4
 
 
 # noinspection SpellCheckingInspection
+class PatternTypeIsignal(Enum):
+	"""2 Members, OTHer ... PRBS9"""
+	OTHer = 0
+	PRBS9 = 1
+
+
+# noinspection SpellCheckingInspection
+class PayloadCoding(Enum):
+	"""3 Members, L12D ... NONE"""
+	L12D = 0
+	L34D = 1
+	NONE = 2
+
+
+# noinspection SpellCheckingInspection
 class PayloadLength(Enum):
 	"""2 Members, _255 ... _37"""
 	_255 = 0
 	_37 = 1
 
 
 # noinspection SpellCheckingInspection
@@ -336,14 +400,21 @@
 	ADVScan = 3
 	CONReq = 4
 	SCReq = 5
 	SCRSp = 6
 
 
 # noinspection SpellCheckingInspection
+class PhyIsignal(Enum):
+	"""2 Members, P4HP ... P8HP"""
+	P4HP = 0
+	P8HP = 1
+
+
+# noinspection SpellCheckingInspection
 class Protocol(Enum):
 	"""3 Members, CTSRts ... XONXoff"""
 	CTSRts = 0
 	NONE = 1
 	XONXoff = 2
 
 
@@ -386,16 +457,16 @@
 	OK = 6
 	UFL = 7
 	ULEL = 8
 	ULEU = 9
 
 
 # noinspection SpellCheckingInspection
-class RxConnector(Enum):
-	"""154 Members, I11I ... RH8"""
+class RfConnector(Enum):
+	"""163 Members, I11I ... RH8"""
 	I11I = 0
 	I13I = 1
 	I15I = 2
 	I17I = 3
 	I21I = 4
 	I23I = 5
 	I25I = 6
@@ -404,152 +475,161 @@
 	I33I = 9
 	I35I = 10
 	I37I = 11
 	I41I = 12
 	I43I = 13
 	I45I = 14
 	I47I = 15
-	IF1 = 16
-	IF2 = 17
-	IF3 = 18
-	IQ1I = 19
-	IQ3I = 20
-	IQ5I = 21
-	IQ7I = 22
-	R11 = 23
-	R11C = 24
-	R12 = 25
-	R12C = 26
-	R12I = 27
-	R13 = 28
-	R13C = 29
-	R14 = 30
-	R14C = 31
-	R14I = 32
-	R15 = 33
-	R16 = 34
-	R17 = 35
-	R18 = 36
-	R21 = 37
-	R21C = 38
-	R22 = 39
-	R22C = 40
-	R22I = 41
-	R23 = 42
-	R23C = 43
-	R24 = 44
-	R24C = 45
-	R24I = 46
-	R25 = 47
-	R26 = 48
-	R27 = 49
-	R28 = 50
-	R31 = 51
-	R31C = 52
-	R32 = 53
-	R32C = 54
-	R32I = 55
-	R33 = 56
-	R33C = 57
-	R34 = 58
-	R34C = 59
-	R34I = 60
-	R35 = 61
-	R36 = 62
-	R37 = 63
-	R38 = 64
-	R41 = 65
-	R41C = 66
-	R42 = 67
-	R42C = 68
-	R42I = 69
-	R43 = 70
-	R43C = 71
-	R44 = 72
-	R44C = 73
-	R44I = 74
-	R45 = 75
-	R46 = 76
-	R47 = 77
-	R48 = 78
-	RA1 = 79
-	RA2 = 80
-	RA3 = 81
-	RA4 = 82
-	RA5 = 83
-	RA6 = 84
-	RA7 = 85
-	RA8 = 86
-	RB1 = 87
-	RB2 = 88
-	RB3 = 89
-	RB4 = 90
-	RB5 = 91
-	RB6 = 92
-	RB7 = 93
-	RB8 = 94
-	RC1 = 95
-	RC2 = 96
-	RC3 = 97
-	RC4 = 98
-	RC5 = 99
-	RC6 = 100
-	RC7 = 101
-	RC8 = 102
-	RD1 = 103
-	RD2 = 104
-	RD3 = 105
-	RD4 = 106
-	RD5 = 107
-	RD6 = 108
-	RD7 = 109
-	RD8 = 110
-	RE1 = 111
-	RE2 = 112
-	RE3 = 113
-	RE4 = 114
-	RE5 = 115
-	RE6 = 116
-	RE7 = 117
-	RE8 = 118
-	RF1 = 119
-	RF1C = 120
-	RF2 = 121
-	RF2C = 122
-	RF2I = 123
-	RF3 = 124
-	RF3C = 125
-	RF4 = 126
-	RF4C = 127
-	RF4I = 128
-	RF5 = 129
-	RF5C = 130
-	RF6 = 131
-	RF6C = 132
-	RF7 = 133
-	RF8 = 134
-	RFAC = 135
-	RFBC = 136
-	RFBI = 137
-	RG1 = 138
-	RG2 = 139
-	RG3 = 140
-	RG4 = 141
-	RG5 = 142
-	RG6 = 143
-	RG7 = 144
-	RG8 = 145
-	RH1 = 146
-	RH2 = 147
-	RH3 = 148
-	RH4 = 149
-	RH5 = 150
-	RH6 = 151
-	RH7 = 152
-	RH8 = 153
+	IFI1 = 16
+	IFI2 = 17
+	IFI3 = 18
+	IFI4 = 19
+	IFI5 = 20
+	IFI6 = 21
+	IQ1I = 22
+	IQ3I = 23
+	IQ5I = 24
+	IQ7I = 25
+	R10D = 26
+	R11 = 27
+	R11C = 28
+	R11D = 29
+	R12 = 30
+	R12C = 31
+	R12D = 32
+	R12I = 33
+	R13 = 34
+	R13C = 35
+	R14 = 36
+	R14C = 37
+	R14I = 38
+	R15 = 39
+	R16 = 40
+	R17 = 41
+	R18 = 42
+	R21 = 43
+	R21C = 44
+	R22 = 45
+	R22C = 46
+	R22I = 47
+	R23 = 48
+	R23C = 49
+	R24 = 50
+	R24C = 51
+	R24I = 52
+	R25 = 53
+	R26 = 54
+	R27 = 55
+	R28 = 56
+	R31 = 57
+	R31C = 58
+	R32 = 59
+	R32C = 60
+	R32I = 61
+	R33 = 62
+	R33C = 63
+	R34 = 64
+	R34C = 65
+	R34I = 66
+	R35 = 67
+	R36 = 68
+	R37 = 69
+	R38 = 70
+	R41 = 71
+	R41C = 72
+	R42 = 73
+	R42C = 74
+	R42I = 75
+	R43 = 76
+	R43C = 77
+	R44 = 78
+	R44C = 79
+	R44I = 80
+	R45 = 81
+	R46 = 82
+	R47 = 83
+	R48 = 84
+	RA1 = 85
+	RA2 = 86
+	RA3 = 87
+	RA4 = 88
+	RA5 = 89
+	RA6 = 90
+	RA7 = 91
+	RA8 = 92
+	RB1 = 93
+	RB2 = 94
+	RB3 = 95
+	RB4 = 96
+	RB5 = 97
+	RB6 = 98
+	RB7 = 99
+	RB8 = 100
+	RC1 = 101
+	RC2 = 102
+	RC3 = 103
+	RC4 = 104
+	RC5 = 105
+	RC6 = 106
+	RC7 = 107
+	RC8 = 108
+	RD1 = 109
+	RD2 = 110
+	RD3 = 111
+	RD4 = 112
+	RD5 = 113
+	RD6 = 114
+	RD7 = 115
+	RD8 = 116
+	RE1 = 117
+	RE2 = 118
+	RE3 = 119
+	RE4 = 120
+	RE5 = 121
+	RE6 = 122
+	RE7 = 123
+	RE8 = 124
+	RF1 = 125
+	RF1C = 126
+	RF2 = 127
+	RF2C = 128
+	RF2I = 129
+	RF3 = 130
+	RF3C = 131
+	RF4 = 132
+	RF4C = 133
+	RF4I = 134
+	RF5 = 135
+	RF5C = 136
+	RF6 = 137
+	RF6C = 138
+	RF7 = 139
+	RF7C = 140
+	RF8 = 141
+	RF8C = 142
+	RF9C = 143
+	RFAC = 144
+	RFBC = 145
+	RFBI = 146
+	RG1 = 147
+	RG2 = 148
+	RG3 = 149
+	RG4 = 150
+	RG5 = 151
+	RG6 = 152
+	RG7 = 153
+	RG8 = 154
+	RH1 = 155
+	RH2 = 156
+	RH3 = 157
+	RH4 = 158
+	RH5 = 159
+	RH6 = 160
+	RH7 = 161
+	RH8 = 162
 
 
 # noinspection SpellCheckingInspection
 class RxConverter(Enum):
 	"""40 Members, IRX1 ... RX44"""
 	IRX1 = 0
 	IRX11 = 1
@@ -599,26 +679,28 @@
 	PER = 0
 	SENS = 1
 	SPOT = 2
 
 
 # noinspection SpellCheckingInspection
 class SegmentPacketType(Enum):
-	"""11 Members, ADVertiser ... RFPHytest"""
+	"""13 Members, ADVertiser ... RFPHytest"""
 	ADVertiser = 0
-	DH1 = 1
-	DH3 = 2
-	DH5 = 3
-	E21P = 4
-	E23P = 5
-	E25P = 6
-	E31P = 7
-	E33P = 8
-	E35P = 9
-	RFPHytest = 10
+	DATA = 1
+	DH1 = 2
+	DH3 = 3
+	DH5 = 4
+	E21P = 5
+	E23P = 6
+	E25P = 7
+	E31P = 8
+	E33P = 9
+	E35P = 10
+	RFCTe = 11
+	RFPHytest = 12
 
 
 # noinspection SpellCheckingInspection
 class StopBits(Enum):
 	"""2 Members, S1 ... S2"""
 	S1 = 0
 	S2 = 1
@@ -628,14 +710,29 @@
 class StopCondition(Enum):
 	"""2 Members, NONE ... SLFail"""
 	NONE = 0
 	SLFail = 1
 
 
 # noinspection SpellCheckingInspection
+class SyncState(Enum):
+	"""2 Members, ADJusted ... PENDing"""
+	ADJusted = 0
+	PENDing = 1
+
+
+# noinspection SpellCheckingInspection
+class TargetMainState(Enum):
+	"""3 Members, OFF ... RUN"""
+	OFF = 0
+	RDY = 1
+	RUN = 2
+
+
+# noinspection SpellCheckingInspection
 class TestScenario(Enum):
 	"""3 Members, CSPath ... UNDefined"""
 	CSPath = 0
 	SALone = 1
 	UNDefined = 2
 
 
@@ -644,15 +741,15 @@
 	"""2 Members, ALL1 ... OTHer"""
 	ALL1 = 0
 	OTHer = 1
 
 
 # noinspection SpellCheckingInspection
 class TxConnector(Enum):
-	"""77 Members, I12O ... RH18"""
+	"""86 Members, I12O ... RH18"""
 	I12O = 0
 	I14O = 1
 	I16O = 2
 	I18O = 3
 	I22O = 4
 	I24O = 5
 	I26O = 6
@@ -661,75 +758,84 @@
 	I34O = 9
 	I36O = 10
 	I38O = 11
 	I42O = 12
 	I44O = 13
 	I46O = 14
 	I48O = 15
-	IF1 = 16
-	IF2 = 17
-	IF3 = 18
-	IQ2O = 19
-	IQ4O = 20
-	IQ6O = 21
-	IQ8O = 22
-	R118 = 23
-	R1183 = 24
-	R1184 = 25
-	R11C = 26
-	R11O = 27
-	R11O3 = 28
-	R11O4 = 29
-	R12C = 30
-	R13C = 31
-	R13O = 32
-	R14C = 33
-	R214 = 34
-	R218 = 35
-	R21C = 36
-	R21O = 37
-	R22C = 38
-	R23C = 39
-	R23O = 40
-	R24C = 41
-	R258 = 42
-	R318 = 43
-	R31C = 44
-	R31O = 45
-	R32C = 46
-	R33C = 47
-	R33O = 48
-	R34C = 49
-	R418 = 50
-	R41C = 51
-	R41O = 52
-	R42C = 53
-	R43C = 54
-	R43O = 55
-	R44C = 56
-	RA18 = 57
-	RB14 = 58
-	RB18 = 59
-	RC18 = 60
-	RD18 = 61
-	RE18 = 62
-	RF18 = 63
-	RF1C = 64
-	RF1O = 65
-	RF2C = 66
-	RF3C = 67
-	RF3O = 68
-	RF4C = 69
-	RF5C = 70
-	RF6C = 71
-	RFAC = 72
-	RFAO = 73
-	RFBC = 74
-	RG18 = 75
-	RH18 = 76
+	IFO1 = 16
+	IFO2 = 17
+	IFO3 = 18
+	IFO4 = 19
+	IFO5 = 20
+	IFO6 = 21
+	IQ2O = 22
+	IQ4O = 23
+	IQ6O = 24
+	IQ8O = 25
+	R10D = 26
+	R118 = 27
+	R1183 = 28
+	R1184 = 29
+	R11C = 30
+	R11D = 31
+	R11O = 32
+	R11O3 = 33
+	R11O4 = 34
+	R12C = 35
+	R12D = 36
+	R13C = 37
+	R13O = 38
+	R14C = 39
+	R214 = 40
+	R218 = 41
+	R21C = 42
+	R21O = 43
+	R22C = 44
+	R23C = 45
+	R23O = 46
+	R24C = 47
+	R258 = 48
+	R318 = 49
+	R31C = 50
+	R31O = 51
+	R32C = 52
+	R33C = 53
+	R33O = 54
+	R34C = 55
+	R418 = 56
+	R41C = 57
+	R41O = 58
+	R42C = 59
+	R43C = 60
+	R43O = 61
+	R44C = 62
+	RA18 = 63
+	RB14 = 64
+	RB18 = 65
+	RC18 = 66
+	RD18 = 67
+	RE18 = 68
+	RF18 = 69
+	RF1C = 70
+	RF1O = 71
+	RF2C = 72
+	RF3C = 73
+	RF3O = 74
+	RF4C = 75
+	RF5C = 76
+	RF6C = 77
+	RF7C = 78
+	RF8C = 79
+	RF9C = 80
+	RFAC = 81
+	RFAO = 82
+	RFBC = 83
+	RG18 = 84
+	RH18 = 85
 
 
 # noinspection SpellCheckingInspection
 class TxConnectorBench(Enum):
 	"""15 Members, R118 ... RH18"""
 	R118 = 0
 	R214 = 1
```

### Comparing `RsCmwBluetoothMeas-3.8.20.28/RsCmwBluetoothMeas/repcap.py` & `RsCmwBluetoothMeas-4.0.110/RsCmwBluetoothMeas/repcap.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,18 +1,19 @@
 from enum import Enum
-from .Internal.RepeatedCapability import VALUE_DEFAULT
-from .Internal.RepeatedCapability import VALUE_EMPTY
+# noinspection PyPep8Naming
+from .Internal.RepeatedCapability import VALUE_DEFAULT as DefaultRepCap
+# noinspection PyPep8Naming
+from .Internal.RepeatedCapability import VALUE_EMPTY as EmptyRepCap
 
 
 # noinspection SpellCheckingInspection
 class Instance(Enum):
-	"""Global Repeated capability Instance \n
-	Selects the instrument"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Global Repeated capability Instance"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Inst1 = 1
 	Inst2 = 2
 	Inst3 = 3
 	Inst4 = 4
 	Inst5 = 5
 	Inst6 = 6
 	Inst7 = 7
@@ -25,18 +26,17 @@
 	Inst14 = 14
 	Inst15 = 15
 	Inst16 = 16
 
 
 # noinspection SpellCheckingInspection
 class Segment(Enum):
-	"""Repeated capability Segment \n
-	Segment Number"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability Segment"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	S1 = 1
 	S2 = 2
 	S3 = 3
 	S4 = 4
 	S5 = 5
 	S6 = 6
 	S7 = 7
```

